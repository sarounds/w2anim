############################################################################
#
#  W2 Animator
#  Perl Tcl/Tk Interface
#  Copyright (c) 2022-2025, Stewart A. Rounds
#
#  Contact:
#    Stewart A. Rounds
#    roundsstewart@gmail.com
#
#  This program is free software; you may redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation, either version 3
#  of the License or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
############################################################################

#
# Organization of this source file:
#
# The first part of the code sets up some shared variables and creates
# the GUI's main window, the drawing canvas, the main menus, and finishes
# up with the main event loop.
#
# After the main code, a number of subroutines are provided in groups:
#  Menu group:
#    confirm_exit
#    make_menubar
#    prepare_to
#    popup_menu
#    edit_pts_menu
#
#  General-purpose routines:
#    read_ini_file
#    write_ini_file
#    adjust_main_position
#    adjust_window_position
#    initialize_canvas_scrollbars
#    manage_canvas_scrollbars
#    update_canvas_scrollbars
#    update_scrollable_menu
#    update_scrollable_tab
#    get_xy
#    show_xypos
#    make_crosshair
#    find_rect_from_text_or_image
#    get_coords
#    get_group_type
#    numeric_entry_only
#    reset_bindings
#    altp_popup
#    start_anew
#    remove_and_restore_menus
#    create_progress_bar
#    update_progress_bar
#    reset_progress_bar
#    destroy_progress_bar
#    create_alt_progress_bar
#    update_alt_progress_bar
#
#  Object drawing, movement, rotation, and manipulation:
#    draw
#    start_drawing
#    begin_resize
#    size_rde  (rectangle, diamond, ellipse)
#    size_poly
#    size_object
#    next_pt
#    add_pt
#    begin_move_pt
#    move_pt
#    delete_pt
#    edit_add_pt
#    exit_edit_pts
#    end_poly
#    end_drawing
#    forget_drawing
#    forget_resize
#    begin_move
#    move_object
#    move_selected
#    end_move_object
#    forget_move_object
#    begin_rotate
#    rotate_object
#    end_rotate_object
#    forget_rotate_object
#    align_objects
#    flip_object
#    raise_lower
#    begin_edit
#    duplicate
#    object_kill
#
#  Image placement and rotation:
#    draw_image
#    end_place_image
#    begin_resize_image
#    size_image
#    end_resize_image
#    revert_image
#    forget_resize_image
#    flip_image
#    begin_crop_image
#    highlight_crop_pt
#    adjust_crop
#    crop_image
#    uncrop_image
#    forget_crop_image
#    begin_rotate_image
#    rotate_image
#    end_rotate_image
#    forget_rotate_image
#
#  Object selection:
#    object_select
#    add_selection
#    group_items
#    ungroup_items
#    show_group
#    group_kill
#    clear_selection_marks
#    clear_selection
#    begin_select_box
#    draw_select_box
#    end_select_box
#    select_item
#    end_select
#    show_points
#    highlight_pt
#    show_anchors
#    highlight_anchor
#    set_anchor
#    forget_set_anchor
#
#  Show or edit object properties:
#    edit_text_props
#    set_text_props
#    edit_object_props
#    set_object_props
#    preview_object_props
#    restore_object_props
#    edit_graph_props
#    color_profile_menu
#    update_graph_props
#    edit_link
#    set_link
#    update_links
#    edit_stat_link
#    set_stat_link
#    update_stat_link
#    edit_matrix_fit_stats
#    set_matrix_stats
#    edit_ind_link
#    set_ind_link
#    update_ind_links
#    forget_ind_link
#    forget_link
#    add_ts_link
#    set_ts_link
#    start_ts_graph
#    show_info
#    edit_canvas_props
#    set_canvas_props
#    edit_defaults
#    set_defaults
#    
#  Graph objects:
#    setup_w2_profile
#    change_w2_profile
#    edit_w2_profile_matrix
#    make_w2_profile
#    setup_w2_slice_or_tdmap_or_wlevels
#    setup_w2_slice_part2
#    setup_w2_slice_part3
#    change_w2_slice
#    make_w2_slice
#    setup_w2_tdmap_part2
#    setup_w2_tdmap_part3
#    setup_w2_tdmap_parmdiff
#    setup_w2_tdmap_filediff
#    undo_w2_tdmap_diffs
#    reverse_w2_tdmap_diffs
#    change_w2_tdmap
#    make_w2_tdmap
#    swap_w2_tdmap_axes
#    setup_data_profile
#    make_data_profile
#    setup_wd_zone
#    make_wd_zone
#    generate_outflow_temps
#    make_bulkhead_graphic
#    setup_w2_outflow
#    setup_w2_outflow_part2
#    make_w2_outflow
#    setup_w2_wlevels_part2
#    setup_w2_wlevels_part3
#    make_w2_wlevels
#    make_ts_graph
#    add_ts_data
#    plot_ts_data
#    add_ts_graph
#    add_ref_data
#    plot_ref_profile
#
#  Statistics, differences, limits, and references:
#    convert_to_diffs
#    calculate_diffs
#    undo_diffs
#    find_data_limits
#    find_w2_profile_limits
#    find_w2_outflow_limits
#    find_w2_slice_limits
#    find_w2_tdmap_limits
#    find_w2_wlevel_limits
#    find_ts_limits
#    setup_ref_stats
#    show_ref_stats
#    choose_datasets
#    show_ts_stats
#
#  Standard graph parts:
#    make_axis
#    make_seg_axis
#    make_date_axis
#    find_axis_limits
#    make_color_key
#    make_ts_legend
#    update_legend_box
#    image_put_color
#    paint_slice_cell
#
#  Date calculations:
#    rebuild_datelist
#    build_profile_match_list
#    build_matrix_match_list
#    set_global_date_limits
#
#  Animation tools:
#    animate_toolbar
#    restore_btn
#    next_profile_dti
#    get_animation_date
#    update_animate
#
#  Zoom tools:
#    zoom_toolbar
#    begin_zoom_box
#    draw_zoom_box
#    end_zoom_box
#    zoom_in
#    zoom_in_X
#    zoom_in_Y
#    zoom_out
#    zoom_out_X
#    zoom_out_Y
#    zoom_full
#    zoom_full_X
#    zoom_full_Y
#
#  Open or save project files:
#    open_file
#    pop_up_error2
#    add_to_recent
#    clear_recent
#    autosave
#    reassign_autosave_files
#    compare_saved
#    save_file
#    print_canvas
#    scale_output
#    make_anim_frames
#    make_animation
#    next_gif_frame
#    stop_and_reset
#
#  Window-related routines:
#    footer
#    configure_helper_apps
#    helper_prog_notice
#    helper_autosearch
#    support
#    about
#

use strict;
use warnings;
use diagnostics;

#
# Use the Perl Tkx interface to the Tcl/Tk toolkit for the GUI.
# Use the Perl Imager module for image manipulations.
# Use the Perl Proc::Background module for running a process in the background.
#
use Tkx;
use Tkx::Scrolled;
use Tkx::ROText;
use Math::Trig 'pi';
use Time::HiRes 'usleep';
use Imager;
use File::Copy;
use File::Spec;
use File::Find;
use Cwd 'abs_path';
use Proc::Background;

#
# The File::Find::Object module might not be available on all Perl systems.
# If not, set a flag so that other algorithms can be used, but print a message.
#
my $FileFindObject = 1;
unless (eval "use File::Find::Object; 1") {
    $FileFindObject = 0;
    print "\nModule File::Find::Object not found.\nInstall with `cpanm File::Find::Object`\n";
}

#
# Use the Win32 Process module if it becomes necessary to spawn an internet
#  browser on a Windows system, if needed.  Win32 systems don't have a
#  properly working fork, so the Win32 calls are needed.
# Use the Win32::GUI module to minimize or show the command prompt window.
#
if ( $^O =~ /MSWin32/i ) {
    require Win32::Process;
    use Win32::GUI;
}

#
# Set aside some global variables that can be shared with other source files.
#
our (
     $background_color, $cursor_norm, $default_size, $have_symbol_font,
     $load_w2a, $main, $pixels_per_pt, $prog_path, $version,

     @color_scheme_names, @color_scheme_names2, @conv_types, @days_in_month,
     @full_color_schemes, @mon_names, @tz_offsets, @valid_nc, @valid_nc_alt,

     %grid, %link_status,
    );

#
# Set aside some local variables.
#
my (

    $about_window, $add_ref_data_menu, $add_ts_data_menu,
    $add_ts_graph_menu, $add_ts_link_menu, $anchor_fill_color,
    $anchor_line_color, $anchor_select_color, $anim_tb_status, $animate_tb,
    $autosave_file, $autosave_file2, $autosave_id1, $autosave_id2,
    $autosave_interval, $autosave_menu, $bg_proc, $canvas, $canvas_color,
    $canvas_height, $canvas_props_menu, $canvas_width, $canvas_xscroll,
    $canvas_yscroll, $choose_sets_menu, $cmap_datemax, $cmap_datemin,
    $configure_helper_menu, $convert_diff_menu, $cursor_draw,
    $cursor_hand, $cursor_kill, $cursor_move, $cursor_select,
    $cursor_text, $cursor_wait, $date_limits_menu, $default_ahd1,
    $default_ahd2, $default_ahd3, $default_angle, $default_arrow,
    $default_canvas_color, $default_canvas_height, $default_canvas_width,
    $default_color, $default_family, $default_fill, $default_fillcolor,
    $default_grid_spacing, $default_props_menu, $default_slant,
    $default_smooth, $default_snap2grid, $default_text_select_color,
    $default_underline, $default_weight, $default_width, $delay,
    $delay_autosave, $delay_frame_id, $delete_frames, $delta_dti,
    $dir_entry, $dir_handle, $dir_tree, $dti, $dti_max, $dti_old,
    $edit_ind_link_menu, $edit_link_menu, $edit_matrix_stat_menu,
    $edit_stat_link_menu, $export_menu, $FFmpeg_off, $FFmpeg_PROG, $file,
    $frame_end, $frame_rate, $frame_start, $global_dt_begin, $global_dt_end,
    $global_dt_limits, $graph_num, $graph_props_menu, $grid_spacing,
    $grid_spacing_max, $grid_spacing_min, $grprops_notebook, $GS_off,
    $GS_PROG, $helper_note_win, $helper_search_win, $icon_img, $ini_path,
    $main_footer_height, $main_frame, $max_canvas_height, $max_canvas_width,
    $max_main_height, $max_main_width, $min_canvas_height, $min_canvas_width,
    $move_delete_menu, $nconfig_events, $object_infobox, $object_props_menu,
    $old_id, $old_item, $popmenu, $pref_menu, $profile_setup_menu,
    $recent_menu, $ref_stats_interp_window, $ref_stats_menu,
    $ref_stats_window, $repeat_anim, $save_ahd1, $save_ahd2, $save_ahd3,
    $save_angle, $save_arrow, $save_color, $save_family, $save_fill,
    $save_fillcolor, $save_size, $save_slant, $save_smooth, $save_underline,
    $save_weight, $save_width, $savefile, $scale_output_menu, $scalefac,
    $screen_height, $screen_width, $search_dir, $snap2grid, $status_line,
    $support_window, $temp_dir, $text_props_menu, $text_select_color,
    $ts_datemax, $ts_datemin, $ts_stats_window, $undo_diff_menu, $use_FFmpeg,
    $use_GS, $use_temp, $w2a_dir, $w2a_error, $w2a_fh, $w2a_line, $w2a_vol,
    $w2levels_setup_menu, $w2profile_data, $w2profile_matrix_menu,
    $w2profile_mod_menu, $w2profile_setup_menu, $w2outflow_setup_menu,
    $w2slice_mod_menu, $w2slice_setup_menu, $w2tdmap_diff_menu,
    $w2tdmap_mod_menu, $w2tdmap_rev_menu, $w2tdmap_setup_menu,
    $w2tdmap_undo_menu, $wdzone_setup_menu, $zoom_tb, $zoom_tip,

    @animate_ids, @arrow_options, @arrow_type, @available_fonts, @dates,
    @dtis_with_pdata, @ind_link_ids, @object_types, @search_dirs,
    @slant_options, @slant_type, @smooth_options, @smooth_type,
    @text_anchors,

    %anc_props, %gr_props, %link_props, %props, %pt_props,
   );

#
# Set the default mouse shapes.
#
$cursor_draw   = 'crosshair';
$cursor_hand   = 'hand2';
$cursor_kill   = 'pirate';
$cursor_move   = 'fleur';
$cursor_norm   = 'left_ptr';
$cursor_select = 'right_ptr';
$cursor_text   = 'xterm';
$cursor_wait   = 'watch';

#
# Create the main window.
#
$main = Tkx::widget->new(".");
$main->g_wm_title("W2 Animator");
$main->configure(-cursor => $cursor_norm);

#
# If a W2Anim project file was mentioned on the command line, get its path and go there.
#
if ($load_w2a =~ /.*\.w2a$/) {
    if (-e $load_w2a) {
        $load_w2a = File::Spec->rel2abs($load_w2a);
        ($w2a_vol, $w2a_dir, undef) = File::Spec->splitpath($load_w2a);
        chdir $w2a_vol . $w2a_dir;
        $w2a_error = 0;
    } else {
        $w2a_error = 1;
    }
}

#
# Set some defaults for text, drawing objects, autosave, and animations.
#
@object_types      = qw(text image line circle ellipse
                        rectangle diamond polygon polyline graph);
$default_size      = 10;
$default_weight    = "normal";
@slant_options     = ("normal", "italic");
@slant_type        = ("roman",  "italic");
$default_slant     = 0;
$default_underline = 0;
$default_angle     = 0;
$default_color     = "black";
$default_width     = 1;
$default_fill      = 0;
$default_fillcolor = "white";
@arrow_options     = ("none", "start", "end",  "both");
@arrow_type        = ("none", "first", "last", "both");
$default_arrow     = 0;
$default_ahd1      = 12;
$default_ahd2      = 15;
$default_ahd3      = 5;
@smooth_options    = ("standard", "rounded");
@smooth_type       = ("false",    "true");
$default_smooth    = 0;
$graph_num         = -1;
$savefile          = "";
$autosave_interval = -1;
$autosave_id1      = $autosave_id2 = $delay_frame_id = "";
$anim_tb_status    = "stopped";
$delay_autosave    = 0;
$repeat_anim       = 0;
$delta_dti         = 1;

$anchor_line_color   = "black";
$anchor_fill_color   = "cyan";
$anchor_select_color = "magenta";
@text_anchors        = qw(nw n ne e se s sw w center);
@animate_ids         = ();
@ind_link_ids        = ();
@dtis_with_pdata     = ();
$w2profile_data      = 0;

#
# Get the available font list and a default font.
# Create some default fonts.  Determine whether the symbol font is available.
#
($default_family, $have_symbol_font, @available_fonts)
    = &create_fonts($main, $default_size);

#
# Try to find the helper programs:  Ghostscript and FFmpeg
# Ghostscript:  Under Windows, look for gswin64c.exe or gswin32c.exe
#               Under Linux, look for gs
# FFmpeg:  Look for ffmpeg.exe under Windows, and probably ffmpeg under Linux
#
# Default search directories:
#   Windows: 
#     Ghostscript:  C:\Program Files\gs
#                   C:\Program Files\Ghostscript
#                   C:\Program Files (x86)\gs
#                   C:\Program Files (x86)\Ghostscript
#     FFmpeg:       C:\Program Files\FFmpeg
#                   C:\Program Files (x86)\FFmpeg
#
#   Linux/other:
#     Ghostscript:  /usr/bin
#                   /usr/local/bin
#                   /bin
#     FFmpeg:       /usr/bin
#                   /usr/local/bin
#                   /bin
#
$GS_PROG = $FFmpeg_PROG = "";
$use_GS  = $use_FFmpeg  = 0;
$GS_off  = $FFmpeg_off  = 0;
if ( $^O =~ /MSWin32/i ) {
    {   local $SIG{__WARN__} = sub { warn @_  unless $_[0] =~ /^Can't opendir/; };
        @search_dirs = ();
        push (@search_dirs,'C:\Program Files\gs')                if (-e 'C:\Program Files\gs');
        push (@search_dirs,'C:\Program Files\Ghostscript')       if (-e 'C:\Program Files\Ghostscript');
        push (@search_dirs,'C:\Program Files (x86)\gs')          if (-e 'C:\Program Files (x86)\gs');
        push (@search_dirs,'C:\Program Files (x86)\Ghostscript') if (-e 'C:\Program Files (x86)\Ghostscript');
        if ($#search_dirs >= 0) {
            if ($FileFindObject) {
                $dir_tree = File::Find::Object->new({}, @search_dirs);
                while ($file = $dir_tree->next()) {
                    if ($file =~ /gswin\d\dc\.exe$/) {
                        $GS_PROG = $file;
                        last;
                    }
                }
            } else {
                foreach $search_dir (@search_dirs) {
                    find( { wanted => sub { if ($_ =~ /gswin\d\dc\.exe$/) {
                                              ($GS_PROG = $File::Find::name) =~ s/\//\\/g;
                                            }},
                            no_chdir => 1 }, $search_dir);
                    last if ($GS_PROG =~ /gswin\d\dc\.exe$/);
                    $GS_PROG = "";
                }
            }
        }
        @search_dirs = ();
        push (@search_dirs, 'C:\Program Files\FFmpeg')       if (-e 'C:\Program Files\FFmpeg');
        push (@search_dirs, 'C:\Program Files (x86)\FFmpeg') if (-e 'C:\Program Files (x86)\FFmpeg');
        if ($#search_dirs >= 0) {
            if ($FileFindObject) {
                $dir_tree = File::Find::Object->new({}, @search_dirs);
                while ($file = $dir_tree->next()) {
                    if ($file =~ /ffmpeg\.exe$/) {
                        $FFmpeg_PROG = $file;
                        last;
                    }
                }
            } else {
                foreach $search_dir (@search_dirs) {
                    find( { wanted => sub { if ($_ =~ /ffmpeg\.exe$/) {
                                              ($FFmpeg_PROG = $File::Find::name) =~ s/\//\\/g;
                                            }},
                            no_chdir => 1 }, $search_dir);
                    last if ($FFmpeg_PROG =~ /ffmpeg\.exe$/);
                    $FFmpeg_PROG = "";
                }
            }
        }
        undef @search_dirs;
    }
    if ($GS_PROG =~ /gswin\d\dc\.exe$/) {
        $use_GS  = 1;
    } else {
        $use_GS  = 0;
        $GS_PROG = "";
    }
    if ($FFmpeg_PROG =~ /ffmpeg\.exe$/) {
        $use_FFmpeg  = 1;
    } else {
        $use_FFmpeg  = 0;
        $FFmpeg_PROG = "";
    }

} else {
    {   local $SIG{__WARN__} = sub { warn @_  unless $_[0] =~ /^Can't opendir/; };
        @search_dirs = ();
        push (@search_dirs, '/usr/bin')       if (-e '/usr/bin');
        push (@search_dirs, '/usr/local/bin') if (-e '/usr/local/bin');
        push (@search_dirs, '/bin')           if (-e '/bin');
        if ($#search_dirs >= 0) {
            if ($FileFindObject) {
                $dir_tree = File::Find::Object->new({}, @search_dirs );
                while ($file = $dir_tree->next()) {
                    if ($GS_PROG eq "") {
                        $GS_PROG = $file if ($file =~ /gs$/);
                    }
                    if ($FFmpeg_PROG eq "") {
                        $FFmpeg_PROG = $file if ($file =~ /ffmpeg$/);
                    }
                    last if ($GS_PROG ne "" && $FFmpeg_PROG ne "");
                }
            } else {
                foreach $search_dir (@search_dirs) {
                    find( { wanted => sub { if ($_ =~ /gs$/) { $GS_PROG = $File::Find::name; }},
                            no_chdir => 1 }, $search_dir);
                    last if ($GS_PROG =~ /gs$/);
                    $GS_PROG = "";
                }
                foreach $search_dir (@search_dirs) {
                    find( { wanted => sub { if ($_ =~ /ffmpeg$/) { $FFmpeg_PROG = $File::Find::name; }},
                            no_chdir => 1 }, $search_dir);
                    last if ($FFmpeg_PROG =~ /ffmpeg$/);
                    $FFmpeg_PROG = "";
                }
            }
        }
        undef @search_dirs;
    }
    if ($GS_PROG =~ /gs$/) {
        $use_GS  = 1;
    } else {
        $use_GS  = 0;
        $GS_PROG = "";
    }
    if ($FFmpeg_PROG =~ /ffmpeg$/) {
        $use_FFmpeg  = 1;
    } else {
        $use_FFmpeg  = 0;
        $FFmpeg_PROG = "";
    }
}

#
# Set a default temporary directory as the current directory,
# or a subdirectory named tmp or temp
#
$use_temp = 1;
$temp_dir = File::Spec->rel2abs(abs_path(), $prog_path);
opendir($dir_handle, $temp_dir) or &pop_up_error($main,
                                    "Failed to read current directory:\n $temp_dir");
while (defined($dir_entry = readdir($dir_handle))) {
    next if (! -d $dir_entry);
    if (lc($dir_entry) eq "tmp") {
        $temp_dir = File::Spec->rel2abs($dir_entry, $temp_dir);
        last;
    } elsif (lc($dir_entry) eq "temp") {
        $temp_dir = File::Spec->rel2abs($dir_entry, $temp_dir);
        last;
    }
}
closedir($dir_handle);

#
# Set some canvas defaults and read the initialization file.
# The initialization file may redefine the temporary directory.
#
$canvas_width      = 600;
$canvas_height     = 450;
$canvas_color      = "white";
$text_select_color = "magenta";
$snap2grid         =   0;
$grid_spacing      =  10;
$ini_path          = $prog_path;
if (-e "w2anim.ini" && -r "w2anim.ini" && ! -z "w2anim.ini" && ! -d "w2anim.ini") {
    $ini_path = File::Spec->rel2abs(".");
    &read_ini_file("w2anim.ini");
} elsif (-e "${prog_path}w2anim.ini" && -r "${prog_path}w2anim.ini"
         && ! -z "${prog_path}w2anim.ini" && ! -d "${prog_path}w2anim.ini") {
    &read_ini_file("${prog_path}w2anim.ini");
}
$grid_spacing_min  =   2;
$grid_spacing_max  = 100;
$grid_spacing      = $grid_spacing_min if ($grid_spacing < $grid_spacing_min);
$grid_spacing      = $grid_spacing_max if ($grid_spacing > $grid_spacing_max);

#
# Set the name of the autosave files for this session. A unique random number is
# used to ensure that separate instances of W2Anim do not use the same files.
# Must do this after $temp_dir may be set in initialization file.
# Must reset these names if $temp_dir is reset later.
#
$autosave_file   = "_autosave" . &get_random_number() . ".w2a";
($autosave_file2 = $autosave_file) =~ s/\.w2a$/_2\.w2a/;
$autosave_file   = File::Spec->rel2abs($autosave_file,  $temp_dir);
$autosave_file2  = File::Spec->rel2abs($autosave_file2, $temp_dir);

#
# Make the main menu bar.
#
&make_menubar($main);

#
# Create a footer for the main page.  Sets the main footer height.
#
$background_color = &footer($main, "main");

#
# Find the screen size.
# Revise the default canvas size and its limits based on screen size and footer height.
#
$screen_height     = Tkx::winfo_screenheight($main) -6 -3*$main_footer_height;
$screen_width      = Tkx::winfo_screenwidth($main)  -6;
$max_canvas_width  = &min(20000, $screen_width);
$max_canvas_height = &min(20000, $screen_height);
$min_canvas_width  = &min(200, $max_canvas_width);
$min_canvas_height = &min(150, $max_canvas_height);
$canvas_width      = $min_canvas_width  if ($canvas_width  < $min_canvas_width);
$canvas_height     = $min_canvas_height if ($canvas_height < $min_canvas_height);
$canvas_width      = 20000              if ($canvas_width  > 20000);
$canvas_height     = 20000              if ($canvas_height > 20000);
$max_canvas_width  = $canvas_width      if ($canvas_width  > $max_canvas_width);
$max_canvas_height = $canvas_height     if ($canvas_height > $max_canvas_height);
$pixels_per_pt     = Tkx::tk_scaling();
$scalefac          = 100;

#
# Save main default settings.
#
$default_canvas_width      = $canvas_width;
$default_canvas_height     = $canvas_height;
$default_canvas_color      = $canvas_color;
$default_text_select_color = $text_select_color;
$default_grid_spacing      = $grid_spacing;
$default_snap2grid         = $snap2grid;

$save_family    = $default_family;
$save_size      = $default_size;
$save_weight    = $default_weight;
$save_slant     = $default_slant;
$save_underline = $default_underline;
$save_angle     = $default_angle;
$save_width     = $default_width;
$save_color     = $default_color;
$save_smooth    = $default_smooth;
$save_fill      = $default_fill;
$save_fillcolor = $default_fillcolor;
$save_arrow     = $default_arrow;
$save_ahd1      = $default_ahd1;
$save_ahd2      = $default_ahd2;
$save_ahd3      = $default_ahd3;

#
# Create the canvas widget to hold the drawings.
# Add scrollbars that can be activated or inactivated later.
#
($main_frame = $main->new_frame(
          ))->g_pack(-anchor => 'nw', -expand => 1, -fill => 'both');
($canvas_xscroll = $main_frame->new_scrollbar(
          -orient => 'horizontal',
          -width  => 15,
          ))->g_grid(-row => 1, -column => 0, -sticky => 'ew');
($canvas_yscroll = $main_frame->new_scrollbar(
          -orient => 'vertical',
          -width  => 15,
          ))->g_grid(-row => 0, -column => 1, -sticky => 'ns');
($canvas = $main_frame->new_tk__canvas(
          -background  => $canvas_color,
          -cursor      => $cursor_norm,
          -width       => $canvas_width,
          -height      => $canvas_height,
          -scrollregion => [0, 0, $canvas_width, $canvas_height],
          -borderwidth => 1,
          -relief      => "groove",
          -xscrollcommand => [$canvas_xscroll, 'set'],
          -yscrollcommand => [$canvas_yscroll, 'set'],
          ))->g_grid(-row => 0, -column => 0, -sticky => 'nw');
$canvas_xscroll->configure(-command => [$canvas, 'xview']);
$canvas_yscroll->configure(-command => [$canvas, 'yview']);
$main_frame->g_grid_rowconfigure(0, -weight => 1);
$main_frame->g_grid_columnconfigure(0, -weight => 1);

#
# Allow the main window to be resized via window handles.
# Set the minimum main window size.
# Remove scrollbars if not needed.  Set the maximum main window size.
# Adjust scrollbar visibility when main window frame is resized.
#
Tkx::wm_resizable($main,1,1);
Tkx::wm_minsize($main, $min_canvas_width +21, $min_canvas_height +21 +$main_footer_height);
&initialize_canvas_scrollbars();
Tkx::update();
$nconfig_events = 0;
$main_frame->g_bind("<Configure>", [ \&manage_canvas_scrollbars, Tkx::Ev("%W")]);

#
# Trap for a Delete Window event from the main window manager.
#
Tkx::wm_protocol($main, 'WM_DELETE_WINDOW', \&confirm_exit);

#
# Bind some keyboard shortcuts
#
$main->g_bind("<Alt-p>", [ \&altp_popup,    Tkx::Ev("%x","%y","%X","%Y"), $canvas ]);
$main->g_bind("<Left>",  [ \&move_selected, Tkx::Ev("%k"), $canvas ]);
$main->g_bind("<Right>", [ \&move_selected, Tkx::Ev("%k"), $canvas ]);
$main->g_bind("<Up>",    [ \&move_selected, Tkx::Ev("%k"), $canvas ]);
$main->g_bind("<Down>",  [ \&move_selected, Tkx::Ev("%k"), $canvas ]);

#
# Reset bindings for the canvas
#
&reset_bindings;

#
# Minimize the command prompt window, if on a Win32 system.
# And set the icon bitmap.
#
if ( $^O =~ /MSWin32/i ) {
    Win32::GUI::Minimize(scalar(Win32::GUI::GetPerlWindow()));
    Tkx::wm_iconbitmap($main, -default => "${prog_path}w2anim.ico");
} else {
    $icon_img = Tkx::image_create_photo(-file => "${prog_path}images/w2anim.png");
    Tkx::wm_iconphoto($main, -default => $icon_img);
}

#
# Load a W2Anim project file from the command line, if present.
#
if ($load_w2a =~ /.*\.w2a$/) {
    if ($w2a_error) {
        &pop_up_error($main, "Unable to locate\n$load_w2a");
        $load_w2a = "";
    } else {
        open ($w2a_fh, "<", $load_w2a) || return &pop_up_error($main, "Unable to open\n$load_w2a");
        $w2a_line = <$w2a_fh>;
        close ($w2a_fh);
        if ($w2a_line =~ /^\# W2 Animator data file, version /) {
            &open_file($load_w2a);
        } else {
            &pop_up_error($main, "Unable to open\n$load_w2a");
            $load_w2a = "";
        }
    }
}

#
# Adjust main window position if part of it is not visible.
#
if ($load_w2a !~ /.*\.w2a$/) {
    &adjust_main_position();
}

#
# Remove any autosaved files in the temporary directory that are older than 5 days.
# Autosave files may exist in the temporary directory from other instances of
#   W2Anim that are running, or from sessions that terminated abnormally.
# Leave an autosave file alone if the user is in the process of opening it.
#
opendir($dir_handle, $temp_dir) or &pop_up_error($main,
                                    "Failed to read temporary directory:\n $temp_dir");
while (defined($dir_entry = readdir($dir_handle))) {
    next if (-d $dir_entry || ($dir_entry !~ /^_autosave\d+\.w2a$/ &&
                               $dir_entry !~ /^_autosave\d+_2\.w2a$/));
    $dir_entry = File::Spec->rel2abs($dir_entry, $temp_dir);
    unlink $dir_entry if ($dir_entry ne $load_w2a && -M $dir_entry > 5.);
}
closedir($dir_handle);

#
# Pop up an information window if either of the helper programs was not found.
#
#$use_GS = 0; $GS_PROG = "";
#$use_FFmpeg = 0; $FFmpeg_PROG = "";
if ((! $use_GS && ! $GS_off) || (! $use_FFmpeg && ! $FFmpeg_off)) {
    &helper_prog_notice();
}

Tkx::MainLoop();

exit;


################################################################################
#
# Menu group
#
################################################################################

#
# When the user tries to exit the program, either via the File/Exit menu option
# or by destroying the application with the windows close function, test whether
# the current project might need to be saved. At least one object tagged "keep"
# must be present for something to be worth saving.
# Show the console window, remove various arrays and hashes, and delete any
# current autosave files before exiting.
#
sub confirm_exit {
    my ($answer, $different, $i, $id, $n, $tmp_file, @id_list, @tmp_list);
    @id_list  = Tkx::SplitList($canvas->find_withtag("keep"));
    @tmp_list = @id_list;
    for ($i=0; $i<=$#tmp_list; $i++) {
        $id = $tmp_list[$i];
        if ($props{$id}{type} eq "graph") {
            if (! defined($props{$id}{gnum})) {        # Graph not fully created yet
                $n = &list_match($id, @id_list);
                splice(@id_list, $n, 1) if ($n >= 0);  # Remove from list
            }
        }
    }
    if ($#id_list >= 0) {
        $tmp_file = "";
        if (-e $autosave_file) {
            ($tmp_file = $autosave_file) =~ s/\.w2a$/tmp\.w2a/;
            copy($autosave_file, $tmp_file);
        }
        &save_file($autosave_file, 1);

      # If an autosave file already existed, push it to autosave_file2 if different
        if ($tmp_file ne "") {
            $different = &compare_saved($autosave_file, $tmp_file);
            if ($different) {
                unlink $autosave_file2 if (-e $autosave_file2);
                move($tmp_file, $autosave_file2);
                $autosave_menu->entryconfigure('end', -state => 'normal');
            } else {
                unlink $tmp_file;
            }
        }
        $autosave_menu->entryconfigure(8, -state => 'normal');  # entry 8 is "Revert, recent"

      # Compare current project file to saved file
        if ($savefile ne "" && -e $savefile) {
            $different = &compare_saved($autosave_file, $savefile);
            if ($different) {
                $answer = &pop_up_question($main,
                               "Current project is different than\n"
                             . "saved project file. Do you want to save\n"
                             . "the current project before exiting?");
                return &save_file if (lc($answer) eq "yes");
            }
        } else {
            $answer = &pop_up_question($main,
                           "Current project has not been saved.\n"
                         . "Do you want to save it before exiting?");
            return &save_file if (lc($answer) eq "yes");
        }
    }
    if ($^O =~ /MSWin32/i) {
        Win32::GUI::Show(scalar(Win32::GUI::GetPerlWindow()));
    }
    Tkx::wm_protocol($main, 'WM_DELETE_WINDOW', "");
    unlink $autosave_file  if (-e $autosave_file);
    unlink $autosave_file2 if (-e $autosave_file2);
    undef @dates;
    undef %grid;
    undef %props;
    undef %gr_props;
    undef %link_props;
    $main->g_destroy();
    exit;
}


sub make_menubar {
    my ($window) = @_;
    my (
        $about_menu, $add_graph, $add_obj, $add_w2graph, $edit_menu,
        $fh, $file, $file_menu, $gs_status, $help_menu, $IS_AQUA, $line,
        $menubar, $mi, $nfiles, $success,
       );

#   Test for the Mac operating system, which has some of its own menu items.
    $IS_AQUA = Tkx::tk_windowingsystem() eq "aqua";

    $menubar = $window->new_menu(-tearoff => 0,
                                 -cursor  => $cursor_norm);
    $window->configure(-menu => $menubar);

    $file_menu = $menubar->new_menu(-tearoff => 0);
    $menubar->add_cascade(
                -label     => "File",
                -underline => 0,
                -menu      => $file_menu,
                );
    $file_menu->add_command(
                -label       => "New",
                -underline   => 0,
                -accelerator => "Ctrl+n",
                -command     => \&start_anew,
                );
    $window->g_bind("<Control-n>", \&start_anew);
    $file_menu->add_command(
                -label       => "Open",
                -underline   => 0,
                -accelerator => "Ctrl+o",
                -command     => \&open_file,
                );
    $window->g_bind("<Control-o>", \&open_file);
    $file_menu->add_command(
                -label       => "Save",
                -accelerator => "Ctrl+s",
                -underline   => 0,
                -command     => sub { &save_file($savefile, 0) },
                );
    $window->g_bind("<Control-s>", sub { &save_file($savefile, 0) });
    $file_menu->add_command(
                -label     => "Save As",
                -underline => 5,
                -command   => \&save_file,
                );

    if ($window eq $main) {
        $autosave_menu = $file_menu->new_menu(-tearoff => 0);
        $file_menu->add_cascade(
                    -label     => "Autosave",
                    -underline => 1,
                    -menu      => $autosave_menu,
                    );
        $autosave_menu->add_radiobutton(
                    -label     => "Off",
                    -underline => 0,
                    -variable  => \$autosave_interval,
                    -value     => -1,
                    -command   => sub { my ($id);
                                        $status_line = "Autosave turned off.";
                                        if ($autosave_id1 ne "" && $autosave_id2 ne "") {
                                            foreach $id (Tkx::SplitList(Tkx::after_info())) {
                                                Tkx::after_cancel($id) if ($id eq $autosave_id1 ||
                                                                           $id eq $autosave_id2);
                                            }
                                        }
                                      },
                    );
        foreach $mi (1, 2, 3, 4, 5, 10, 20) {
            $autosave_menu->add_radiobutton(
                        -label     => ($mi == 1) ? $mi . " minute" : $mi . " minutes",
                        -underline => ($mi < 10) ? 0 : ($mi == 10) ? 1 : 3,
                        -variable  => \$autosave_interval,
                        -value     => $mi,
                        -command   => sub { my ($id, $interval);
                                            if ($autosave_interval == 1) {
                                                $status_line = "Autosave turned on. Interval = 1 minute.";
                                            } else {
                                                $status_line = "Autosave turned on. Interval = "
                                                             . $autosave_interval . " minutes.";
                                            }
                                            if ($autosave_id1 ne "" && $autosave_id2 ne "") {
                                                foreach $id (Tkx::SplitList(Tkx::after_info())) {
                                                    Tkx::after_cancel($id) if ($id eq $autosave_id1 ||
                                                                               $id eq $autosave_id2);
                                                }
                                            }
                                            $interval = 60000 *$autosave_interval;
                                            $autosave_id2 = Tkx::after_idle(
                                                              sub {$autosave_id1
                                                                    = Tkx::after($interval, [\&autosave]);
                                                                  });
                                          },
                        );
        }
        $autosave_menu->add_command(
                    -label     => "Revert, recent",
                    -underline => 0,
                    -state     => 'disabled',
                    -command   => sub { if (-e $autosave_file) {
                                            $status_line = "Reverting to recent autosaved file.";
                                            &open_file($autosave_file, 1);
                                        } else {
                                            $status_line = "No recent autosaved file to open.";
                                        }
                                      },
                    );
        $autosave_menu->add_command(
                    -label     => "Revert, previous",
                    -underline => 8,
                    -state     => 'disabled',
                    -command   => sub { if (-e $autosave_file2) {
                                            $status_line = "Reverting to previous autosaved file.";
                                            &open_file($autosave_file2, 1);
                                        } else {
                                            $status_line = "No previous autosaved file to open.";
                                        }
                                      },
                    );

        $export_menu = $file_menu->new_menu(-tearoff => 0);
        $file_menu->add_cascade(
                    -label     => "Export",
                    -underline => 0,
                    -menu      => $export_menu,
                    );
        $export_menu->add_command(
                    -label     => "PostScript",
                    -underline => 4,
                    -command   => sub { &print_canvas("PostScript") },
                    );
        $gs_status = ($use_GS) ? 'normal' : 'disabled';
        $export_menu->add_command(
                    -label     => "PDF",
                    -underline => 0,
                    -state     => $gs_status,
                    -command   => sub { &print_canvas("PDF") },
                    );
        $export_menu->add_command(
                    -label     => "Raster",
                    -underline => 0,
                    -state     => $gs_status,
                    -command   => sub { &scale_output("Raster") },
                    );
        $export_menu->add_command(
                    -label     => "Animation",
                    -underline => 0,
                    -state     => 'disabled',
                    -command   => sub { &scale_output("Animation") },
                    );

        $recent_menu = $file_menu->new_menu(-tearoff => 0);
        $file_menu->add_cascade(
                    -label     => "Recent",
                    -underline => 0,
                    -menu      => $recent_menu,
                    );
        $file   = "${prog_path}w2anim_recent.txt";
        $nfiles = 0;
        if (-e $file && -s $file > 0) {
            $success = open ($fh, "<", $file);
            if (defined($success)) {
                $line = <$fh>;
                if ($line =~ /^\# W2 Animator recent files list/) {
                    while (defined( $line = <$fh> )) {
                        $line =~ s/^\s+//;
                        $line =~ s/\s+$//;
                        next if ($line =~ /^#/ || $line eq "");
                        $file = $line;
                        if ($file =~ /\.w2a$/ && -e $file && -s $file > 0) {
                            $file = File::Spec->rel2abs($file);
                            $recent_menu->add_command(
                                        -label   => $file,
                                        -command => [ \&open_file, $file, 0 ],
                                        );
                            $nfiles++;
                        }
                    }
                }
                close ($fh);
            }
        }
        if ($nfiles == 0) {
            $recent_menu->add_command(
                        -label     => "None",
                        -underline => 0,
                        -state     => 'disabled',
                        );
        } else {
            $recent_menu->add_command(
                        -label     => "Clear recent list",
                        -underline => 0,
                        -state     => 'normal',
                        -command   => \&clear_recent,
                        );
        }
    }

    $file_menu->add_separator();
    $file_menu->add_command(
                -label     => "Exit",
                -underline => 1,
                -command   => \&confirm_exit,
                ) unless $IS_AQUA;

    $edit_menu = $menubar->new_menu(-tearoff => 0);
    $menubar->add_cascade(
                -label     => "Edit",
                -underline => 0,
                -menu      => $edit_menu,
                );
    $add_obj = $edit_menu->new_menu(-tearoff => 0);
    $edit_menu->add_cascade(
                -label     => "Add Object",
                -underline => 4,
                -menu      => $add_obj,
                );
    $add_obj->add_command(
                -label     => "Line",
                -underline => 0,
                -command   => sub { &draw("line") },
                );
    $add_obj->add_command(
                -label     => "Circle",
                -underline => 0,
                -command   => sub { &draw("circle") },
                );
    $add_obj->add_command(
                -label     => "Ellipse",
                -underline => 0,
                -command   => sub { &draw("ellipse") },
                );
    $add_obj->add_command(
                -label     => "Rectangle",
                -underline => 0,
                -command   => sub { &draw("rectangle") },
                );
    $add_obj->add_command(
                -label     => "Diamond",
                -underline => 0,
                -command   => sub { &draw("diamond") },
                );
    $add_obj->add_command(
                -label     => "Polygon",
                -underline => 0,
                -command   => sub { &draw("polygon") },
                );
    $add_obj->add_command(
                -label     => "Polyline",
                -underline => 3,
                -command   => sub { &draw("polyline") },
                );
    $add_obj->add_command(
                -label     => "Text",
                -underline => 0,
                -command   => sub { &draw("text") },
                );
    $add_obj->add_command(
                -label     => "Text Link",
                -underline => 8,
                -command   => sub { &edit_ind_link($canvas, 0, 0, 0) },
                );
    $add_obj->add_command(
                -label     => "Image",
                -underline => 0,
                -command   => \&draw_image,
                );

    $add_graph = $edit_menu->new_menu(-tearoff => 0);
    $edit_menu->add_cascade(
                -label     => "Add Graph",
                -underline => 4,
                -menu      => $add_graph,
                );
    $add_graph->add_command(
                -label     => "Profile",
                -underline => 0,
                -command   => sub { &draw("graph", "data_profile") },
                );
    $add_graph->add_command(
                -label     => "Profile Colormap",
                -underline => 8,
                -command   => sub { &draw("graph", "data_profile_cmap") },
                );
    $add_graph->add_command(
                -label     => "Vertical Withdrawal Zone",
                -underline => 0,
                -command   => sub { &draw("graph", "vert_wd_zone") },
                );
    $add_graph->add_command(
                -label     => "Time-Series",
                -underline => 0,
                -command   => sub { &draw("graph", "time_series") },
                );

    $add_w2graph = $edit_menu->new_menu(-tearoff => 0);
    $edit_menu->add_cascade(
                -label     => "Add W2 Graph",
                -underline => 4,
                -menu      => $add_w2graph,
                );
    $add_w2graph->add_command(
                -label     => "W2 Profile",
                -underline => 3,
                -command   => sub { &draw("graph", "w2_profile") },
                );
    $add_w2graph->add_command(
                -label     => "W2 Profile Colormap",
                -underline => 11,
                -command   => sub { &draw("graph", "w2_profile_cmap") },
                );
    $add_w2graph->add_command(
                -label     => "W2 Longitudinal Slice",
                -underline => 3,
                -command   => sub { &draw("graph", "w2_slice") },
                );
    $add_w2graph->add_command(
                -label     => "W2 Time/Distance Map",
                -underline => 8,
                -command   => sub { &draw("graph", "w2_tdmap") },
                );
    $add_w2graph->add_command(
                -label     => "W2 Outflow Profile",
                -underline => 3,
                -command   => sub { &draw("graph", "w2_outflow") },
                );
    $add_w2graph->add_command(
                -label     => "W2 Water Levels",
                -underline => 3,
                -command   => sub { &draw("graph", "w2_wlevels") },
                );
    $add_w2graph->add_command(
                -label     => "Time-Series",
                -underline => 0,
                -command   => sub { &draw("graph", "time_series") },
                );

    $edit_menu->add_command(
                -label     => "Edit",
                -underline => 0,
                -command   => sub { &prepare_to("edit") },
                );
    $edit_menu->add_command(
                -label     => "Move",
                -underline => 0,
                -command   => sub { &prepare_to("move") },
                );
    $edit_menu->add_command(
                -label     => "Duplicate",
                -underline => 5,
                -command   => sub { &prepare_to("duplicate") },
                );
    $edit_menu->add_command(
                -label     => "Delete",
                -underline => 0,
                -command   => sub { &prepare_to("kill") },
                );

    $pref_menu = $edit_menu->new_menu(-tearoff => 0);
    $edit_menu->add_cascade(
                -label     => "Preferences",
                -underline => 0,
                -menu      => $pref_menu,
                );
    $pref_menu->add_command(
                -label     => "Date Limits",
                -underline => 5,
                -state     => 'disabled',
                -command   => sub { &set_global_date_limits(0, 0) },
                );
    $pref_menu->add_command(
                -label     => "Canvas Props",
                -underline => 0,
                -command   => sub { &edit_canvas_props(0, 0) },
                );
    $pref_menu->add_command(
                -label     => "Defaults",
                -underline => 0,
                -command   => sub { &edit_defaults(0, 0, 0) },
                );
    $pref_menu->add_command(
                -label     => "Save w2anim.ini",
                -underline => 0,
                -command   => sub { &write_ini_file },
                );

    $help_menu = $menubar->new_menu(-tearoff => 0,
                                    -name    => "help");
    $menubar->add_cascade(
                -label     => "Help",
                -underline => 0,
                -menu      => $help_menu,
                );
    $about_menu = $help_menu;
    if ($IS_AQUA) {
        # On Mac OS we want about box to appear in the application
        # menu.  Anything added to a menu with the name "apple" will
        # appear in this menu.
        $about_menu = $menubar->new_menu(-tearoff => 0,
                                         -name    => "apple");
        $menubar->add_cascade(-menu => $about_menu);
    }
    $help_menu->add_command(
                -label     => "Configure",
                -underline => 0,
                -command   => \&configure_helper_apps,
                );
    $help_menu->add_command(
                -label     => "Support",
                -underline => 0,
                -command   => \&support,
                );
    $help_menu->add_command(
                -label     => "About",
                -underline => 0,
                -command   => \&about,
                );
}


sub prepare_to {
    my ($action) = @_;      # kill, edit, move, duplicate, zoom

    if ($action eq "kill") {
        $canvas->configure(-cursor => $cursor_kill);
        $canvas->g_bind("<Button-3>", [ \&reset_bindings ]);
    } elsif ($action =~ /zoom_in/) {
        $canvas->configure(-cursor => $cursor_draw);
        $canvas->g_bind("<Button-3>", [ \&forget_drawing, '' ]);
    } else {
        $canvas->configure(-cursor => $cursor_hand);
        $canvas->g_bind("<Button-3>", [ \&forget_drawing, '' ]);
    }
    $canvas->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"), $canvas, $action ]);
}


sub popup_menu {
    my ($X, $Y, $canv, $id) = @_;
    my (
        $add_dt, $add_graph, $add_obj, $add_w2graph, $align_menu,
        $align_ready, $anchor_src, $bf_grp_status, $bf_status, $change_menu,
        $crop_menu, $cropped, $diff_menu, $fit_menu, $flip_menu, $group_menu,
        $group_order, $group_ready, $group_tag, $hide_menu, $hide_txt, $i,
        $id_tmp, $item, $match, $next_id, $order, $ref_menu, $rotate_menu,
        $sb_grp_status, $sb_status, $tag, $type,

        @add_ts_setnum, @crop, @gtags, @ids, @items, @rev_tags, @tags,

        %add_ts_parms,
       );

    $popmenu = $canv->new_menu(-tearoff => 0);

    $id = "" if (! defined($id));
    $group_tag   = "";
    $group_ready = 0;
    $align_ready = 0;

    if ($id ne "") {

#       Check whether user has selected items
        @tags = Tkx::SplitList($canv->itemcget($id, -tags));
        if (&list_match("select", @tags) > -1) {
            @items = Tkx::SplitList($canv->find_withtag("select"));
            if ($#items > 0) {
                $align_ready = 1;
                $group_ready = 1;
            }
        }

#       Check whether a group tag is present.  Select the latest.
        if (&list_search("group_", @tags) > -1) {
            @rev_tags  = reverse @tags;
            $group_tag = @rev_tags[&list_search("group_", @rev_tags)];
            @gtags = ();
            foreach $tag (@tags) {
                push (@gtags, $tag) if ($tag =~ /^group_/);
            }
        }

#       Check whether the selection corresponds to existing group
        if ($align_ready && $group_tag ne "") {
            foreach $tag (@gtags) {
                @ids = Tkx::SplitList($canv->find_withtag($tag));
                next if ($#ids != $#items);
                $match = 1;
                foreach $item (@items) {
                    if (&list_match($item, @ids) == -1) {
                        $match = 0;
                        last;
                    }
                }
                if ($match) {
                    $group_ready = 0;
                    last;
                }
            }
        }
    }

    if ($id ne "" && ($group_ready || $align_ready)) {
        if ($group_ready) {
            $popmenu->add_command(-label     => "Group",
                                  -underline => 0,
                                  -command   => sub { &group_items($canv, @items) },
                                  );
        }
        $tag = "select";
        $align_menu = $popmenu->new_menu(-tearoff => 0);
        $popmenu->add_cascade(-label     => "Align",
                              -underline => 0,
                              -menu      => $align_menu,
                              );
        $align_menu->add_command(
                       -label     => "Align Left",
                       -underline => 6,
                       -command   => sub { &align_objects($canv, $id, "left", $tag) },
                       );
        $align_menu->add_command(
                       -label     => "Align Center",
                       -underline => 6,
                       -command   => sub { &align_objects($canv, $id, "center", $tag) },
                       );
        $align_menu->add_command(
                       -label     => "Align Right",
                       -underline => 6,
                       -command   => sub { &align_objects($canv, $id, "right", $tag) },
                       );
        $align_menu->add_separator();
        $align_menu->add_command(
                       -label     => "Align Top",
                       -underline => 6,
                       -command   => sub { &align_objects($canv, $id, "top", $tag) },
                       );
        $align_menu->add_command(
                       -label     => "Align Middle",
                       -underline => 6,
                       -command   => sub { &align_objects($canv, $id, "middle", $tag) },
                       );
        $align_menu->add_command(
                       -label     => "Align Bottom",
                       -underline => 6,
                       -command   => sub { &align_objects($canv, $id, "bottom", $tag) },
                       );
        $align_menu->add_separator();
        $align_menu->add_command(
                       -label     => "Align XY Centers",
                       -underline => 15,
                       -command   => sub { &align_objects($canv, $id, "xycenters", $tag) },
                       );
        $align_menu->add_separator();
        $align_menu->add_command(
                       -label     => "Align Anchors X",
                       -underline => 14,
                       -command   => sub { &align_objects($canv, $id, "anchor_x", $tag) },
                       );
        $align_menu->add_command(
                       -label     => "Align Anchors Y",
                       -underline => 14,
                       -command   => sub { &align_objects($canv, $id, "anchor_y", $tag) },
                       );
        $align_menu->add_command(
                       -label     => "Align Anchors XY",
                       -underline => 6,
                       -command   => sub { &align_objects($canv, $id, "anchor_xy", $tag) },
                       );

    } elsif ($id ne "") {
        &clear_selection($canv);

        $type   = $props{$id}{type};
        $id_tmp = ($type eq "graph") ? "graph" . $id : $id;

        $bf_status = 'disabled';
        while (($next_id = $canv->find_above($id_tmp)) ne "") {
            @tags = Tkx::SplitList($canv->itemcget($next_id, -tags));
            if (&list_match("working", @tags) > -1) {
                $canv->lower($next_id, $id_tmp);
                next;
            }
            $bf_status = 'normal';
            last;
        }
        $sb_status = 'disabled';
        while (($next_id = $canv->find_below($id_tmp)) ne "") {
            @tags = Tkx::SplitList($canv->itemcget($next_id, -tags));
            if (&list_match("working", @tags) > -1) {
                $canv->raise($next_id, $id_tmp);
                next;
            }
            $sb_status = 'normal';
            last;
        }

        if ($group_tag ne "") {
            $bf_grp_status = 'disabled';
            $sb_grp_status = 'disabled';

            @items = ();
            foreach $item (Tkx::SplitList($canv->find_withtag($group_tag))) {
                next if (! defined($props{$item}{type}));
                push (@items, $item);
            }
            foreach $item (@items) {
                $id_tmp = ($props{$item}{type} eq "graph") ? "graph" . $item : $item;
                while ($bf_grp_status eq 'disabled' && ($next_id = $canv->find_above($id_tmp)) ne "") {
                    if (&list_match($next_id, @items) > -1) {
                        $id_tmp = ($props{$next_id}{type} eq "graph") ? "graph" . $next_id : $next_id;
                        next;
                    }
                    @tags = Tkx::SplitList($canv->itemcget($next_id, -tags));
                    if (&list_match("working", @tags) > -1) {
                        $canv->lower($next_id, $id_tmp);
                        next;
                    }
                    $bf_grp_status = 'normal';
                }
                $id_tmp = ($props{$item}{type} eq "graph") ? "graph" . $item : $item;
                while ($sb_grp_status eq 'disabled' && ($next_id = $canv->find_below($id_tmp)) ne "") {
                    if (&list_match($next_id, @items) > -1) {
                        $id_tmp = ($props{$next_id}{type} eq "graph") ? "graph" . $next_id : $next_id;
                        next;
                    }
                    @tags = Tkx::SplitList($canv->itemcget($next_id, -tags));
                    if (&list_match("working", @tags) > -1) {
                        $canv->raise($next_id, $id_tmp);
                        next;
                    }
                    $sb_grp_status = 'normal';
                }
                last if ($bf_grp_status eq 'normal' && $sb_grp_status eq 'normal');
            }

            $group_menu = $popmenu->new_menu(-tearoff => 0);
            $popmenu->add_cascade(-label     => "Group",
                                  -underline => 0,
                                  -menu      => $group_menu,
                                  );
            $group_menu->add_command(
                           -label     => "Ungroup",
                           -underline => 0,
                           -command   => sub { &ungroup_items($canv, $group_tag) },
                           );
            $group_menu->add_command(
                           -label     => "Show Group",
                           -underline => 0,
                           -command   => sub { &show_group($canv, $group_tag) },
                           );
            $group_menu->add_command(
                           -label     => "Move Group",
                           -underline => 0,
                           -command   => sub { &begin_move($canv, $group_tag, "group") },
                           );
            $align_menu = $group_menu->new_menu(-tearoff => 0);
            $group_menu->add_cascade(-label     => "Align",
                                     -underline => 0,
                                     -menu      => $align_menu,
                                     );
            $align_menu->add_command(
                           -label     => "Align Left",
                           -underline => 6,
                           -command   => sub { &align_objects($canv, $id, "left", $group_tag) },
                           );
            $align_menu->add_command(
                           -label     => "Align Center",
                           -underline => 6,
                           -command   => sub { &align_objects($canv, $id, "center", $group_tag) },
                           );
            $align_menu->add_command(
                           -label     => "Align Right",
                           -underline => 6,
                           -command   => sub { &align_objects($canv, $id, "right", $group_tag) },
                           );
            $align_menu->add_separator();
            $align_menu->add_command(
                           -label     => "Align Top",
                           -underline => 6,
                           -command   => sub { &align_objects($canv, $id, "top", $group_tag) },
                           );
            $align_menu->add_command(
                           -label     => "Align Middle",
                           -underline => 6,
                           -command   => sub { &align_objects($canv, $id, "middle", $group_tag) },
                           );
            $align_menu->add_command(
                           -label     => "Align Bottom",
                           -underline => 6,
                           -command   => sub { &align_objects($canv, $id, "bottom", $group_tag) },
                           );
            $align_menu->add_separator();
            $align_menu->add_command(
                           -label     => "Align XY Centers",
                           -underline => 15,
                           -command   => sub { &align_objects($canv, $id, "xycenters", $group_tag) },
                           );
            $align_menu->add_separator();
            $align_menu->add_command(
                           -label     => "Align Anchors X",
                           -underline => 14,
                           -command   => sub { &align_objects($canv, $id, "anchor_x", $group_tag) },
                           );
            $align_menu->add_command(
                           -label     => "Align Anchors Y",
                           -underline => 14,
                           -command   => sub { &align_objects($canv, $id, "anchor_y", $group_tag) },
                           );
            $align_menu->add_command(
                           -label     => "Align Anchors XY",
                           -underline => 6,
                           -command   => sub { &align_objects($canv, $id, "anchor_xy", $group_tag) },
                           );
            $group_order = $group_menu->new_menu(-tearoff => 0);
            $group_menu->add_cascade(
                           -label     => "Order Group",
                           -underline => 0,
                           -menu      => $group_order,
                           );
            $group_order->add_command(
                           -label     => "Bring to Front",
                           -underline => 13,
                           -state     => $bf_grp_status,
                           -command   => sub { &raise_lower($canv, $group_tag, "top") },
                           );
            $group_order->add_command(
                           -label     => "Bring Forward",
                           -underline => 6,
                           -state     => $bf_grp_status,
                           -command   => sub { &raise_lower($canv, $group_tag, "raise") },
                           );
            $group_order->add_command(
                           -label     => "Send to Back",
                           -underline => 11,
                           -state     => $sb_grp_status,
                           -command   => sub { &raise_lower($canv, $group_tag, "bottom") },
                           );
            $group_order->add_command(
                           -label     => "Send Backward",
                           -underline => 5,
                           -state     => $sb_grp_status,
                           -command   => sub { &raise_lower($canv, $group_tag, "lower") },
                           );
            $group_menu->add_command(
                           -label     => "Delete Members",
                           -underline => 0,
                           -command   => sub { &group_kill($canv, $group_tag) },
                           );
        }

        if ($type ne "image") {
            $popmenu->add_command(
                        -label     => "Edit",
                        -underline => 0,
                        -command   => sub { &begin_edit($X, $Y, $canv, $id) },
                        );
        }
        if ($type =~ /^(text|circle|ellipse|rectangle|diamond|polygon)$/
                && defined($link_props{$id}{id}) && $link_props{$id}{form} ne "stat") {
            $popmenu->add_command(
                        -label     => "Edit Link",
                        -underline => 5,
                        -command   => sub { &edit_link($canv, $link_props{$id}{id}, $X+5, $Y+5, $id) },
                        );
        }
        if ($type eq "text" && defined($link_props{$id}{id})
                            && $link_props{$id}{form} eq "stat") {
            $popmenu->add_command(
                        -label     => "Edit Link",
                        -underline => 5,
                        -command   => sub { &edit_stat_link($canv, $link_props{$id}{id}, $X+5, $Y+5, $id) },
                        );
        }
        if ($type eq "text" && &list_match($id, @ind_link_ids) >= 0) {
            $popmenu->add_command(
                        -label     => "Edit Link",
                        -underline => 5,
                        -command   => sub { &edit_ind_link($canv, $id, $X+5, $Y+5) },
                        );
        }
        if ($type =~ /^(polygon|polyline)$/) {
            $popmenu->add_command(
                        -label     => "Edit Points",
                        -underline => 5,
                        -command   => sub { &show_points($canv, $id) },
                        );
        }

        if ($type eq "graph") {
            if ($props{$id}{meta}
                    =~ /^(data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)$/) {
                $popmenu->add_command(
                            -label     => "Animate",
                            -underline => 0,
                            -command   => sub { &animate_toolbar($X, $Y, $id) },
                            );
            }
        }

        $popmenu->add_command(
                    -label     => "Move",
                    -underline => 0,
                    -command   => sub { &begin_move($canv, $id, "") },
                    );
        if ($type eq "graph"
              && $props{$id}{meta} =~ /(data_profile|w2_profile|w2_tdmap|w2_slice|w2_outflow|vert_wd_zone)/) {
            if ($gr_props{$id}{add_cs} && ! $gr_props{$id}{cs_hide}) {
                $popmenu->add_command(
                            -label     => "Move Color Key",
                            -underline => 11,
                            -command   => sub { &begin_move($canv, $id, "Color Key") },
                            );
            }
            if ($props{$id}{meta} eq "vert_wd_zone") {
                if ($props{$id}{wd_alg} eq "Libby Dam" &&   $gr_props{$id}{bh_show}
                                                       && ! $gr_props{$id}{bh_docked}) {
                    $popmenu->add_command(
                                -label     => "Move Bulkhead Key",
                                -underline => 5,
                                -command   => sub { &begin_move($canv, $id, "Bulkhead Key") },
                                );
                }
            }
        }
        if ($type eq "graph" && $props{$id}{meta} =~ /time_series/) {
            $popmenu->add_command(
                        -label     => "Move Legend",
                        -underline => 5,
                        -command   => sub { &begin_move($canv, $id, "Legend") },
                        );
            $popmenu->add_command(
                        -label     => "Zoom Toolbar",
                        -underline => 0,
                        -command   => sub { &end_select($canv, $id, 1);
                                            &zoom_toolbar($X, $Y);
                                          },
                        );
        }

        if ($type !~ /^(image|text)$/) {
            $popmenu->add_command(
                        -label     => "Resize",
                        -underline => 4,
                        -command   => sub { &begin_resize($canv, $id) },
                        );
        } elsif ($type eq "image") {
            $popmenu->add_command(
                        -label     => "Resize",
                        -underline => 4,
                        -command   => sub { &begin_resize_image($canv, $id) },
                        );
            if ($props{$id}{iw} != $props{$id}{iwo} ||
                $props{$id}{ih} != $props{$id}{iho} ||
                $props{$id}{angle} != 0 || $props{$id}{flip} ne "none") {
                $popmenu->add_command(
                            -label     => "Revert",
                            -underline => 2,
                            -command   => sub { &revert_image($canv, $id) },
                            );
            }
        }

        if ($type =~ /^(text|ellipse|rectangle|diamond|polygon|polyline)$/) {
            $popmenu->add_command(
                        -label     => "Rotate",
                        -underline => 0,
                        -command   => sub { &begin_rotate($canv, $id) },
                        );
        } elsif ($type eq "image") {
            $rotate_menu = $popmenu->new_menu(-tearoff => 0);
            $popmenu->add_cascade(
                        -label     => "Rotate",
                        -underline => 0,
                        -menu      => $rotate_menu,
                        );
            $rotate_menu->add_command(
                        -label     => "Clockwise 90",
                        -underline => 1,
                        -command   => sub { &rotate_image($canv, $id, -90, 0) },
                        );
            $rotate_menu->add_command(
                        -label     => "Counterclockwise 90",
                        -underline => 0,
                        -command   => sub { &rotate_image($canv, $id, 90, 0) },
                        );
            if ($props{$id}{angle} != 0) {
                $rotate_menu->add_command(
                            -label     => "To Zero",
                            -underline => 3,
                            -command   => sub { &rotate_image($canv, $id, -1 *$props{$id}{angle}, 0) },
                            );
            }
            $rotate_menu->add_command(
                        -label     => "Free Rotate",
                        -underline => 0,
                        -command   => sub { &begin_rotate($canv, $id) },
                        );
        }
        if ($type =~ /^(line|ellipse|rectangle|diamond|polygon|polyline)$/) {
            $flip_menu = $popmenu->new_menu(-tearoff => 0);
            $popmenu->add_cascade(
                        -label     => "Flip",
                        -underline => 0,
                        -menu      => $flip_menu,
                        );
            $flip_menu->add_command(
                        -label     => "Left to Right",
                        -underline => 0,
                        -command   => sub { &flip_object($canv, $id, "left_right") },
                        );
            if ($props{$id}{anchor} ne 'center') {
                $flip_menu->add_command(
                            -label     => "Left to Right, via Anchor",
                            -underline => 8,
                            -command   => sub { &flip_object($canv, $id, "left_right_anchor") },
                            );
            }
            $flip_menu->add_command(
                        -label     => "Top to Bottom",
                        -underline => 0,
                        -command   => sub { &flip_object($canv, $id, "top_bottom") },
                        );
            if ($props{$id}{anchor} ne 'center') {
                $flip_menu->add_command(
                            -label     => "Top to Bottom, via Anchor",
                            -underline => 7,
                            -command   => sub { &flip_object($canv, $id, "top_bottom_anchor") },
                            );
            }
        }
        if ($type eq "image" && $props{$id}{angle} == 0) {
            $flip_menu = $popmenu->new_menu(-tearoff => 0);
            $popmenu->add_cascade(
                        -label     => "Flip",
                        -underline => 0,
                        -menu      => $flip_menu,
                        );
            $flip_menu->add_command(
                        -label     => "Left to Right",
                        -underline => 0,
                        -command   => sub { &flip_image($canv, $id, "left_right") },
                        );
            if ($props{$id}{anchor} !~ /^(n|s|center)$/) {
                $flip_menu->add_command(
                            -label     => "Left to Right, via Anchor",
                            -underline => 8,
                            -command   => sub { &flip_image($canv, $id, "left_right_anchor") },
                            );
            }
            $flip_menu->add_command(
                        -label     => "Top to Bottom",
                        -underline => 0,
                        -command   => sub { &flip_image($canv, $id, "top_bottom") },
                        );
            if ($props{$id}{anchor} !~ /^(e|w|center)$/) {
                $flip_menu->add_command(
                            -label     => "Top to Bottom, via Anchor",
                            -underline => 7,
                            -command   => sub { &flip_image($canv, $id, "top_bottom_anchor") },
                            );
            }
            if ($props{$id}{flip} ne "none") {
                $flip_menu->add_command(
                            -label     => "Original",
                            -underline => 0,
                            -command   => sub { &flip_image($canv, $id, "original") },
                            );
            }
        }
        if ($type eq "image") {
            @crop = @{ $props{$id}{crop} };
            $cropped = 0;
            for ($i=0; $i<4; $i++) {
                if ($crop[$i] != 0.0) {
                    $cropped = 1;
                    last;
                }
            }
            if ($cropped) {
                $crop_menu = $popmenu->new_menu(-tearoff => 0);
                $popmenu->add_cascade(
                            -label     => "Crop",
                            -underline => 3,
                            -menu      => $crop_menu,
                            );
                $crop_menu->add_command(
                            -label     => "Modify",
                            -underline => 0,
                            -command   => sub { &begin_crop_image($canv, $id) },
                            );
                $crop_menu->add_command(
                            -label     => "Uncrop",
                            -underline => 0,
                            -command   => sub { &uncrop_image($canv, $id) },
                            );
            } else {
                $popmenu->add_command(
                            -label     => "Crop",
                            -underline => 3,
                            -command   => sub { &begin_crop_image($canv, $id) },
                            );
            }
        }
        if ($type =~ /^(circle|ellipse|rectangle|diamond|text|image|line|graph)$/) {
            $popmenu->add_command(
                        -label     => "Select Anchor",
                        -underline => 0,
                        -command   => sub { &show_anchors($canv, $id) },
                        );
        } elsif ($type =~ /^(polygon|polyline)$/) {
            $anchor_src = $popmenu->new_menu(-tearoff => 0);
            $popmenu->add_cascade(
                        -label     => "Select Anchor",
                        -underline => 0,
                        -menu      => $anchor_src,
                        );
            $anchor_src->add_command(
                        -label     => "from Bounding Box",
                        -underline => 5,
                        -command   => sub { &show_anchors($canv, $id, "bbox") },
                        );
            $anchor_src->add_command(
                        -label     => "from Points",
                        -underline => 5,
                        -command   => sub { &show_anchors($canv, $id, "pts") },
                        );
        }
        $order = $popmenu->new_menu(-tearoff => 0);
        $popmenu->add_cascade(
                    -label     => "Order",
                    -underline => 0,
                    -menu      => $order,
                    );
        $order->add_command(
                    -label     => "Bring to Front",
                    -underline => 13,
                    -state     => $bf_status,
                    -command   => sub { &raise_lower($canv, $id, "top") },
                    );
        $order->add_command(
                    -label     => "Bring Forward",
                    -underline => 6,
                    -state     => $bf_status,
                    -command   => sub { &raise_lower($canv, $id, "raise") },
                    );
        $order->add_command(
                    -label     => "Send to Back",
                    -underline => 11,
                    -state     => $sb_status,
                    -command   => sub { &raise_lower($canv, $id, "bottom") },
                    );
        $order->add_command(
                    -label     => "Send Backward",
                    -underline => 5,
                    -state     => $sb_status,
                    -command   => sub { &raise_lower($canv, $id, "lower") },
                    );
        if ($type eq "graph") {
            if ($props{$id}{meta} eq "w2_profile_matrix") {
                $popmenu->add_command(
                            -label     => "Modify Matrix",
                            -underline => 12,
                            -command   => sub { &edit_w2_profile_matrix($canv, $id) },
                            );
                if (! defined($gr_props{$id}{ms_stats})) {
                    $popmenu->add_command(
                                -label     => "Fit Statistics",
                                -underline => 0,
                                -command   => sub { &edit_matrix_fit_stats($canv, $id, $X+5, $Y+5) },
                                );
                } else {
                    $fit_menu = $popmenu->new_menu(-tearoff => 0);
                    $popmenu->add_cascade(
                                -label     => "Fit Statistics",
                                -underline => 0,
                                -menu      => $fit_menu,
                                );
                    if ($gr_props{$id}{ms_stats}) {
                        $fit_menu->add_command(
                                    -label     => "Hide Stats",
                                    -underline => 0,
                                    -command   => sub { $gr_props{$id}{ms_stats} = 0;
                                                        $canv->itemconfigure("graph" . $id . "_stats",
                                                                             -state => 'hidden');
                                                      },
                                    );
                        $fit_menu->add_command(
                                    -label     => "Delete Stats",
                                    -underline => 0,
                                    -command   => sub { $gr_props{$id}{ms_stats} = 0;
                                                        $canv->delete("graph" . $id . "_stats");
                                                      },
                                    );
                        $fit_menu->add_command(
                                    -label     => "Edit Properties",
                                    -underline => 0,
                                    -command   => sub { &edit_matrix_fit_stats($canv, $id, $X+5, $Y+5) },
                                    );
                    } else {
                        $fit_menu->add_command(
                                    -label     => "Show Stats",
                                    -underline => 0,
                                    -command   => sub { my ($tag, @items);
                                                        $gr_props{$id}{ms_stats} = 1;
                                                        $tag   = "graph" . $id . "_stats";
                                                        @items = Tkx::SplitList($canv->find_withtag($tag));
                                                        if ($#items >= 0) {
                                                            $canv->itemconfigure("graph" . $id . "_stats",
                                                                                 -state => 'normal');
                                                        } else {
                                                            &set_matrix_stats($canv, $id);
                                                        }
                                                      },
                                    );
                        $fit_menu->add_command(
                                    -label     => "Edit and Show",
                                    -underline => 0,
                                    -command   => sub { &edit_matrix_fit_stats($canv, $id, $X+5, $Y+5) },
                                    );
                    }
                }
            } elsif ($props{$id}{meta} =~ /w2_profile|w2_slice|w2_wlevels/
                  || ($props{$id}{meta} eq "w2_tdmap" && $props{$id}{src_type} !~ /RiverCon/i)) {
                $change_menu = $popmenu->new_menu(-tearoff => 0);
                $popmenu->add_cascade(
                            -label     => "Change",
                            -underline => 1,
                            -menu      => $change_menu,
                            );
                if ($props{$id}{meta} =~ /w2_profile/) {
                    if ($props{$id}{src_type} =~ /LakeCon/i) {
                        $change_menu->add_command(
                                    -label     => "Base Year",
                                    -underline => 0,
                                    -command   => sub { &change_w2_profile($canv, $id, $X+5, $Y+5, "base") },
                                    );
                    } else {
                        $change_menu->add_command(
                                    -label     => "Segment",
                                    -underline => 0,
                                    -command   => sub { &change_w2_profile($canv, $id, $X+5, $Y+5, "seg") },
                                    );
                        $change_menu->add_command(
                                    -label     => "Parameter",
                                    -underline => 0,
                                    -command   => sub { &change_w2_profile($canv, $id, $X+5, $Y+5, "parm") },
                                    );
                        $change_menu->add_command(
                                    -label     => "Misc",
                                    -underline => 0,
                                    -command   => sub { &change_w2_profile($canv, $id, $X+5, $Y+5, "misc") },
                                    );
                    }
                    $change_menu->add_command(
                                -label     => "Data Source",
                                -underline => 0,
                                -command   => sub { &setup_w2_profile($canv, $id) },
                                );
                } elsif ($props{$id}{meta} eq "w2_slice") {
                    $change_menu->add_command(
                                -label     => "Parameter",
                                -underline => 0,
                                -command   => sub { &change_w2_slice($canv, $id, $X+5, $Y+5, "parm") },
                                );
                    $change_menu->add_command(
                                -label     => "Misc",
                                -underline => 0,
                                -command   => sub { &change_w2_slice($canv, $id, $X+5, $Y+5, "misc") },
                                );
                } elsif ($props{$id}{meta} eq "w2_wlevels") {
                    $change_menu->add_command(
                                -label     => "Misc",
                                -underline => 0,
                                -command   => sub { &setup_w2_wlevels_part3($canv, $id, $X+5, $Y+5, "misc") },
                                );
                } elsif ($props{$id}{meta} eq "w2_tdmap" && $props{$id}{src_type} !~ /RiverCon/i) {
                    $change_menu->add_command(
                                -label     => "Parameter",
                                -underline => 0,
                                -command   => sub { &change_w2_tdmap($canv, $id, $X+5, $Y+5, "parm") },
                                );
                    $change_menu->add_command(
                                -label     => "Misc",
                                -underline => 0,
                                -command   => sub { &change_w2_tdmap($canv, $id, $X+5, $Y+5, "misc") },
                                );
                }
            }
            if ($props{$id}{meta} eq "w2_tdmap") {
                if ($props{$id}{map_type} eq "standard") {
                    $diff_menu = $popmenu->new_menu(-tearoff => 0);
                    $popmenu->add_cascade(
                                -label     => "Convert to Diff",
                                -underline => 3,
                                -menu      => $diff_menu,
                                );
                    $diff_menu->add_command(
                                -label     => "Same Parameter, Different Run",
                                -underline => 0,
                                -command   => sub { &setup_w2_tdmap_filediff($canv, $id, $X+5, $Y+5) },
                                );
                    if ($props{$id}{src_type} !~ /RiverCon/i) {
                        $diff_menu->add_command(
                                    -label     => "Different Parameter, Same Run",
                                    -underline => 0,
                                    -command   => sub { &setup_w2_tdmap_parmdiff($canv, $id, $X+5, $Y+5) },
                                    );
                    }
                } else {
                    $popmenu->add_command(
                                -label     => "Undo Difference",
                                -underline => 0,
                                -command   => sub { &undo_w2_tdmap_diffs($canv, $id, $X+5, $Y+5) },
                                );
                    $popmenu->add_command(
                                -label     => "Reverse Difference",
                                -underline => 0,
                                -command   => sub { &reverse_w2_tdmap_diffs($canv, $id, $X+5, $Y+5) },
                                );
                }
                $hide_menu = $popmenu->new_menu(-tearoff => 0);
                $popmenu->add_cascade(
                            -label     => "Hide/Show",
                            -underline => 8,
                            -menu      => $hide_menu,
                            );
                if ($gr_props{$id}{hide_title} || $gr_props{$id}{hide_taxis}
                                               || $gr_props{$id}{hide_daxis}) {
                    $hide_menu->add_command(
                                -label     => "Show All",
                                -underline => 0,
                                -command   => sub { my ($gtag);
                                                    $gtag = "graph" . $id;
                                                    if ($gr_props{$id}{hide_title}) {
                                                        $gr_props{$id}{hide_title} = 0;
                                                        $canv->itemconfigure($gtag . "_gtitle",
                                                                             -state => 'normal');
                                                    }
                                                    if ($gr_props{$id}{hide_taxis}) {
                                                        $gr_props{$id}{hide_taxis} = 0;
                                                        if ($gr_props{$id}{date_axis} eq "X") {
                                                            $canv->itemconfigure($gtag . "_xaxis",
                                                                                 -state => 'normal');
                                                            $canv->itemconfigure($gtag . "_xaxisTitle",
                                                                                 -state => 'normal');
                                                        } else {
                                                            $canv->itemconfigure($gtag . "_yaxis",
                                                                                 -state => 'normal');
                                                            $canv->itemconfigure($gtag . "_yaxisTitle",
                                                                                 -state => 'normal');
                                                        }
                                                    }
                                                    if ($gr_props{$id}{hide_daxis}) {
                                                        $gr_props{$id}{hide_daxis} = 0;
                                                        if ($gr_props{$id}{date_axis} eq "Y") {
                                                            $canv->itemconfigure($gtag . "_xaxis",
                                                                                 -state => 'normal');
                                                            $canv->itemconfigure($gtag . "_xaxisTitle",
                                                                                 -state => 'normal');
                                                        } else {
                                                            $canv->itemconfigure($gtag . "_yaxis",
                                                                                 -state => 'normal');
                                                            $canv->itemconfigure($gtag . "_yaxisTitle",
                                                                                 -state => 'normal');
                                                        }
                                                    }
                                                  },
                                );
                }
                if (! $gr_props{$id}{hide_title} || ! $gr_props{$id}{hide_taxis}
                                                 || ! $gr_props{$id}{hide_daxis}) {
                    $hide_menu->add_command(
                                -label     => "Hide All",
                                -underline => 0,
                                -command   => sub { my ($gtag);
                                                    $gtag = "graph" . $id;
                                                    if (! $gr_props{$id}{hide_title}) {
                                                        $gr_props{$id}{hide_title} = 1;
                                                        $canv->itemconfigure($gtag . "_gtitle",
                                                                             -state => 'hidden');
                                                    }
                                                    if (! $gr_props{$id}{hide_taxis}) {
                                                        $gr_props{$id}{hide_taxis} = 1;
                                                        if ($gr_props{$id}{date_axis} eq "X") {
                                                            $canv->itemconfigure($gtag . "_xaxis",
                                                                                 -state => 'hidden');
                                                            $canv->itemconfigure($gtag . "_xaxisTitle",
                                                                                 -state => 'hidden');
                                                        } else {
                                                            $canv->itemconfigure($gtag . "_yaxis",
                                                                                 -state => 'hidden');
                                                            $canv->itemconfigure($gtag . "_yaxisTitle",
                                                                                 -state => 'hidden');
                                                        }
                                                    }
                                                    if (! $gr_props{$id}{hide_daxis}) {
                                                        $gr_props{$id}{hide_daxis} = 1;
                                                        if ($gr_props{$id}{date_axis} eq "Y") {
                                                            $canv->itemconfigure($gtag . "_xaxis",
                                                                                 -state => 'hidden');
                                                            $canv->itemconfigure($gtag . "_xaxisTitle",
                                                                                 -state => 'hidden');
                                                        } else {
                                                            $canv->itemconfigure($gtag . "_yaxis",
                                                                                 -state => 'hidden');
                                                            $canv->itemconfigure($gtag . "_yaxisTitle",
                                                                                 -state => 'hidden');
                                                        }
                                                    }
                                                  },
                                );
                }
                $hide_txt = ($gr_props{$id}{hide_title}) ? "Show Titles" : "Hide Titles";
                $hide_menu->add_command(
                            -label     => $hide_txt,
                            -underline => 5,
                            -command   => sub { my ($gtag, $state);
                                                $gtag = "graph" . $id;
                                                if ($gr_props{$id}{hide_title}) {
                                                    $state = 'normal';
                                                    $gr_props{$id}{hide_title} = 0;
                                                } else {
                                                    $state = 'hidden';
                                                    $gr_props{$id}{hide_title} = 1;
                                                }
                                                $canv->itemconfigure($gtag . "_gtitle", -state => $state);
                                              },
                            );
                if ($gr_props{$id}{date_axis} eq "X") {
                    $hide_txt = ($gr_props{$id}{hide_taxis}) ? "Show X Axis" : "Hide X Axis";
                } else {
                    $hide_txt = ($gr_props{$id}{hide_daxis}) ? "Show X Axis" : "Hide X Axis";
                }
                $hide_menu->add_command(
                            -label     => $hide_txt,
                            -underline => 5,
                            -command   => sub { my ($gtag, $proptag, $state);
                                                $gtag = "graph" . $id;
                                                if ($gr_props{$id}{date_axis} eq "X") {
                                                    $proptag = "hide_taxis";
                                                } else {
                                                    $proptag = "hide_daxis";
                                                }
                                                if ($gr_props{$id}{$proptag}) {
                                                    $state = 'normal';
                                                    $gr_props{$id}{$proptag} = 0;
                                                } else {
                                                    $state = 'hidden';
                                                    $gr_props{$id}{$proptag} = 1;
                                                }
                                                $canv->itemconfigure($gtag . "_xaxis", -state => $state);
                                                $canv->itemconfigure($gtag . "_xaxisTitle", -state => $state);
                                              },
                            );
                if ($gr_props{$id}{date_axis} eq "Y") {
                    $hide_txt = ($gr_props{$id}{hide_taxis}) ? "Show Y Axis" : "Hide Y Axis";
                } else {
                    $hide_txt = ($gr_props{$id}{hide_daxis}) ? "Show Y Axis" : "Hide Y Axis";
                }
                $hide_menu->add_command(
                            -label     => $hide_txt,
                            -underline => 5,
                            -command   => sub { my ($gtag, $proptag, $state);
                                                $gtag = "graph" . $id;
                                                if ($gr_props{$id}{date_axis} eq "Y") {
                                                    $proptag = "hide_taxis";
                                                } else {
                                                    $proptag = "hide_daxis";
                                                }
                                                if ($gr_props{$id}{$proptag}) {
                                                    $state = 'normal';
                                                    $gr_props{$id}{$proptag} = 0;
                                                } else {
                                                    $state = 'hidden';
                                                    $gr_props{$id}{$proptag} = 1;
                                                }
                                                $canv->itemconfigure($gtag . "_yaxis", -state => $state);
                                                $canv->itemconfigure($gtag . "_yaxisTitle", -state => $state);
                                              },
                            );
                $popmenu->add_command(
                            -label     => "Swap Axes",
                            -underline => 1,
                            -command   => sub { &swap_w2_tdmap_axes($canv, $id) },
                            );
            }
        }
        $popmenu->add_command(
                    -label     => "Info",
                    -underline => 0,
                    -command   => sub { &show_info($canv, $id, $X+5, $Y+5) },
                    );
        if ($type eq "graph" && $props{$id}{meta} =~ /^(data_profile|vert_wd_zone|w2_profile|w2_outflow)$/) {
            $popmenu->add_command(
                        -label     => "Add Link",
                        -underline => 4,
                        -command   => sub { &edit_link($canv, $id, $X+5, $Y+5, 0) },
                        );
            $popmenu->add_command(
                        -label     => "Add Time Series Link",
                        -underline => 4,
                        -command   => sub { &add_ts_link($canv, $id, $X+5, $Y+5) },
                        );
        }
        if ($type eq "graph" && $props{$id}{meta} =~ /time_series/) {
            $popmenu->add_command(
                        -label     => "Add Dataset",
                        -underline => 0,
                        -command   => sub { &add_ts_data($canv, $id, $X+5, $Y+5) },
                        );
            if (defined($props{$id}{add_ts_parms})) {
                %add_ts_parms  = %{ $props{$id}{add_ts_parms} };
                @add_ts_setnum = @{ $add_ts_parms{ts_setnum}  };
                if (($props{$id}{meta} eq "linked_time_series" && $#add_ts_setnum >= 0)
                        || ($props{$id}{meta} eq "time_series" && $#add_ts_setnum >= 1)) {
                    $popmenu->add_command(
                                -label     => "Fit Statistics",
                                -underline => 0,
                                -command   => sub { &choose_datasets($canv, $id, $X+5, $Y+5) },
                                );
                }
            }
        }
        if ($type eq "graph" && $props{$id}{meta} =~ /data_profile/) {
            if ($props{$id}{prof_type} =~ /standard/i) {
                $popmenu->add_command(
                            -label     => "Convert to Difference",
                            -underline => 3,
                            -command   => sub { &convert_to_diffs($canv, $id, $X+5, $Y+5) },
                            );
            } else {
                $popmenu->add_command(
                            -label     => "Undo Differences",
                            -underline => 0,
                            -command   => sub { &undo_diffs($canv, $id, $X+5, $Y+5); },
                            );
            }
        }
        if ($type eq "graph" && $props{$id}{meta} eq "w2_profile") {
            if (! defined($props{$id}{ref_file})) {
                $popmenu->add_command(
                            -label     => "Add Reference Data",
                            -underline => 4,
                            -command   => sub { &add_ref_data($canv, $id, $X+5, $Y+5) },
                            );
            } else {
                $ref_menu = $popmenu->new_menu(-tearoff => 0);
                $popmenu->add_cascade(
                            -label     => "Reference Data",
                            -underline => 2,
                            -menu      => $ref_menu,
                            );
                if ($props{$id}{ref_hide}) {
                    $ref_menu->add_command(
                                -label     => "Show Reference Data",
                                -underline => 0,
                                -command   => sub { my ($geom, $tabid, $X, $Y);
                                                    $canv->itemconfigure("graph" . $id . "_refData",
                                                                         -state => 'normal');
                                                    $props{$id}{ref_hide} = 0;
                                                    &build_profile_match_list();
                                                    &update_links($canv, $id, $dates[$dti-1]);

                                                  # Rebuild the animation toolbar, if present
                                                    if (defined($animate_tb)
                                                          && Tkx::winfo_exists($animate_tb)) {
                                                        if ($animate_tb->g_wm_title()
                                                              eq "Animation toolbar") {
                                                            $geom = $animate_tb->g_wm_geometry();
                                                            (undef, $X, $Y) = split(/\+/, $geom);
                                                            $animate_tb->g_destroy();
                                                            undef $animate_tb;
                                                            &animate_toolbar($X, $Y, -1);
                                                        }
                                                    }

                                                  # Refresh the Graph Properties menu, if present
                                                    if (defined($graph_props_menu)
                                                          && Tkx::winfo_exists($graph_props_menu)) {
                                                        if ($graph_props_menu->g_wm_title()
                                                              =~ /Graph Properties/) {
                                                            $tabid = $grprops_notebook->index('current');
                                                            $geom  = $graph_props_menu->g_wm_geometry();
                                                            (undef, $X, $Y) = split(/\+/, $geom);
                                                            &edit_graph_props($id, $X, $Y, $tabid);
                                                        }
                                                    }
                                                  },
                                );
                } else {
                    $ref_menu->add_command(
                                -label     => "Hide Reference Data",
                                -underline => 0,
                                -command   => sub { my ($geom, $tabid, $X, $Y);
                                                    $canv->itemconfigure("graph" . $id . "_refData",
                                                                         -state => 'hidden');
                                                    $props{$id}{ref_hide} = 1;
                                                    &build_profile_match_list();
                                                    &update_links($canv, $id, $dates[$dti-1]);

                                                  # Rebuild the animation toolbar, if present
                                                    if (defined($animate_tb)
                                                          && Tkx::winfo_exists($animate_tb)) {
                                                        if ($animate_tb->g_wm_title()
                                                              eq "Animation toolbar") {
                                                            $geom = $animate_tb->g_wm_geometry();
                                                            (undef, $X, $Y) = split(/\+/, $geom);
                                                            $animate_tb->g_destroy();
                                                            undef $animate_tb;
                                                            &animate_toolbar($X, $Y, -1);
                                                        }
                                                    }

                                                  # Refresh the Graph Properties menu, if present
                                                    if (defined($graph_props_menu)
                                                          && Tkx::winfo_exists($graph_props_menu)) {
                                                        if ($graph_props_menu->g_wm_title()
                                                              =~ /Graph Properties/) {
                                                            $tabid = $grprops_notebook->index('current');
                                                            $geom  = $graph_props_menu->g_wm_geometry();
                                                            (undef, $X, $Y) = split(/\+/, $geom);
                                                            &edit_graph_props($id, $X, $Y, $tabid);
                                                        }
                                                    }
                                                  },
                                );
                }
                $ref_menu->add_command(
                            -label     => "Delete Reference Data",
                            -underline => 0,
                            -command   => sub { my ($geom, $item, $tabid, $X, $Y, @items);
                                                $canv->delete("graph" . $id . "_refData");
                                                undef $props{$id}{ref_file};
                                                undef $gr_props{$id}{ref_data};
                                                &build_profile_match_list();
                                                &update_links($canv, $id, $dates[$dti-1]);

                                              # Rebuild Object Info box for this graph, if necessary
                                                if (defined($object_infobox) &&
                                                    Tkx::winfo_exists($object_infobox)) {
                                                    if ($object_infobox->g_wm_title()
                                                            eq "Object Info, ID $id") {
                                                        $geom = $object_infobox->g_wm_geometry();
                                                        (undef, $X, $Y) = split(/\+/, $geom);
                                                        &show_info($canv, $id, $X, $Y);
                                                    }
                                                }

                                              # Rebuild the animation toolbar, if present
                                                if (defined($animate_tb) && Tkx::winfo_exists($animate_tb)) {
                                                    if ($animate_tb->g_wm_title() eq "Animation toolbar") {
                                                        $geom = $animate_tb->g_wm_geometry();
                                                        (undef, $X, $Y) = split(/\+/, $geom);
                                                        $animate_tb->g_destroy();
                                                        undef $animate_tb;
                                                        &animate_toolbar($X, $Y, -1);
                                                    }
                                                }

                                              # Refresh the Graph Properties menu, if present
                                                if (defined($graph_props_menu)
                                                      && Tkx::winfo_exists($graph_props_menu)) {
                                                    if ($graph_props_menu->g_wm_title()
                                                          =~ /Graph Properties/) {
                                                        $tabid = $grprops_notebook->index('current');
                                                        $geom  = $graph_props_menu->g_wm_geometry();
                                                        (undef, $X, $Y) = split(/\+/, $geom);
                                                        &edit_graph_props($id, $X, $Y, $tabid);
                                                    }
                                                }
                                              },
                            );
                $ref_menu->add_command(
                            -label     => "Fit Statistics Table",
                            -underline => 0,
                            -command   => sub { &setup_ref_stats($canv, $id, $X+5, $Y+5) },
                            );
                $ref_menu->add_command(
                            -label     => "Add Goodness-of-Fit Link",
                            -underline => 0,
                            -command   => sub { &edit_stat_link($canv, $id, $X+5, $Y+5, 0) },
                            );
                $ref_menu->add_command(
                            -label     => "Create Profile Matrix Plot",
                            -underline => 0,
                            -command   => sub { my (@tmp);
                                                @tmp = &build_matrix_match_list($id);
                                                if ($#tmp < 0) {
                                                    return &pop_up_error($main,
                                                                         "No date/time matches between\n"
                                                                       . "modeled and measured profiles.");
                                                }
                                                &draw("graph", "w2_profile_matrix_" . $id);
                                              },
                            );
            }
        }
        if ($type eq "graph" && $props{$id}{meta} eq "w2_outflow") {
            if ($props{$id}{add_parm}) {
                $popmenu->add_command(
                            -label     => "Change Color Parameter",
                            -underline => 13,
                            -command   => sub { &setup_w2_outflow_part2($canv, $id, $X+5, $Y+5, 1) },
                            );
            } else {
                $popmenu->add_command(
                            -label     => "Add Color Parameter",
                            -underline => 10,
                            -command   => sub { &setup_w2_outflow_part2($canv, $id, $X+5, $Y+5, 1) },
                            );
            }
        }
        $popmenu->add_command(
                    -label     => "Duplicate",
                    -underline => 5,
                    -command   => sub { &duplicate($canv, $id) },
                    );
        $popmenu->add_command(
                    -label     => "Delete",
                    -underline => 0,
                    -command   => sub { &object_kill($canv, $id) },
                    );

#   No object selected
    } else {
        &clear_selection($canv);

        $add_obj = $popmenu->new_menu(-tearoff => 0);
        $popmenu->add_cascade(
                    -label     => "Add Object",
                    -underline => 4,
                    -menu      => $add_obj,
                    );
        $add_obj->add_command(
                    -label     => "Line",
                    -underline => 0,
                    -command   => sub { &draw("line") },
                    );
        $add_obj->add_command(
                    -label     => "Circle",
                    -underline => 0,
                    -command   => sub { &draw("circle") },
                    );
        $add_obj->add_command(
                    -label     => "Ellipse",
                    -underline => 0,
                    -command   => sub { &draw("ellipse") },
                    );
        $add_obj->add_command(
                    -label     => "Rectangle",
                    -underline => 0,
                    -command   => sub { &draw("rectangle") },
                    );
        $add_obj->add_command(
                    -label     => "Diamond",
                    -underline => 0,
                    -command   => sub { &draw("diamond") },
                    );
        $add_obj->add_command(
                    -label     => "Polygon",
                    -underline => 0,
                    -command   => sub { &draw("polygon") },
                    );
        $add_obj->add_command(
                    -label     => "Polyline",
                    -underline => 3,
                    -command   => sub { &draw("polyline") },
                    );
        $add_obj->add_command(
                    -label     => "Text",
                    -underline => 0,
                    -command   => sub { &draw("text") },
                    );
        if (@animate_ids && $#animate_ids >= 0) {
            $add_obj->add_command(
                        -label     => "Text Link",
                        -underline => 8,
                        -command   => sub { &edit_ind_link($canvas, 0, $X+5, $Y+5) },
                        );
        }
        $add_obj->add_command(
                    -label     => "Image",
                    -underline => 0,
                    -command   => \&draw_image,
                    );

        $add_graph = $popmenu->new_menu(-tearoff => 0);
        $popmenu->add_cascade(
                    -label     => "Add Graph",
                    -underline => 4,
                    -menu      => $add_graph,
                    );
        $add_graph->add_command(
                    -label     => "Profile",
                    -underline => 0,
                    -command   => sub { &draw("graph", "data_profile") },
                    );
        $add_graph->add_command(
                    -label     => "Profile Colormap",
                    -underline => 8,
                    -command   => sub { &draw("graph", "data_profile_cmap") },
                    );
        $add_graph->add_command(
                    -label     => "Vertical Withdrawal Zone",
                    -underline => 0,
                    -command   => sub { &draw("graph", "vert_wd_zone") },
                    );
        $add_graph->add_command(
                    -label     => "Time-Series",
                    -underline => 0,
                    -command   => sub { &draw("graph", "time_series") },
                    );

        $add_w2graph = $popmenu->new_menu(-tearoff => 0);
        $popmenu->add_cascade(
                    -label     => "Add W2 Graph",
                    -underline => 4,
                    -menu      => $add_w2graph,
                    );
        $add_w2graph->add_command(
                    -label     => "W2 Profile",
                    -underline => 3,
                    -command   => sub { &draw("graph", "w2_profile") },
                    );
        $add_w2graph->add_command(
                    -label     => "W2 Profile Colormap",
                    -underline => 11,
                    -command   => sub { &draw("graph", "w2_profile_cmap") },
                    );
        $add_w2graph->add_command(
                    -label     => "W2 Longitudinal Slice",
                    -underline => 3,
                    -command   => sub { &draw("graph", "w2_slice") },
                    );
        $add_w2graph->add_command(
                    -label     => "W2 Time/Distance Map",
                    -underline => 8,
                    -command   => sub { &draw("graph", "w2_tdmap") },
                    );
        $add_w2graph->add_command(
                    -label     => "W2 Outflow Profile",
                    -underline => 3,
                    -command   => sub { &draw("graph", "w2_outflow") },
                    );
        $add_w2graph->add_command(
                    -label     => "W2 Water Levels",
                    -underline => 3,
                    -command   => sub { &draw("graph", "w2_wlevels") },
                    );
        $add_w2graph->add_command(
                    -label     => "Time-Series",
                    -underline => 0,
                    -command   => sub { &draw("graph", "time_series") },
                    );

        if (@animate_ids && $#animate_ids >= 0) {
            foreach $item (@animate_ids) {
                if ($props{$item}{meta}
                         =~ /^(data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)$/) {
                    $popmenu->add_command(
                                -label     => "Date Limits",
                                -underline => 5,
                                -command   => sub { &set_global_date_limits($X, $Y) },
                                );
                    last;
                }
            }
        }
        $popmenu->add_command(
                    -label     => "Canvas Props",
                    -underline => 0,
                    -command   => sub { &edit_canvas_props($X, $Y) },
                    );
        $popmenu->add_command(
                    -label     => "Defaults",
                    -underline => 0,
                    -command   => sub { &edit_defaults($X, $Y, 0) },
                    );
    }

    $popmenu->post($X, $Y);
    &reset_bindings;
}


sub edit_pts_menu {
    my ($X, $Y, $canv, $id, $insert_pt) = @_;

    $move_delete_menu = $canv->new_menu(-tearoff => 0);
    $move_delete_menu->add_command(
                -label     => "Move point",
                -underline => 0,
                -command   => sub { &begin_move_pt($canv, $id, $insert_pt) },
                );
    $move_delete_menu->add_command(
                -label     => "Delete point",
                -underline => 0,
                -command   => sub { &delete_pt($canv, $id, $insert_pt) },
                );
    $move_delete_menu->post($X, $Y);
}


################################################################################
#
# General-purpose routines
#
################################################################################

sub read_ini_file {
    my ($ini_file) = @_;
    my (
        $arrow, $acl, $ahw, $asl, $canvas_color_tmp, $canvas_height_tmp,
        $canvas_width_tmp, $error, $f_angle, $f_size, $f_slant, $f_under,
        $f_weight, $family, $ffmp_path, $fh, $grid_spacing_tmp, $gs_path,
        $i, $key, $line, $ob_color, $ob_corner, $ob_fcolor, $ob_fill,
        $ob_width, $pos, $select_color_tmp, $snap2grid_tmp, $tmp_path, $val,
       );

    $canvas_width_tmp  = $canvas_width;
    $canvas_height_tmp = $canvas_height;
    $canvas_color_tmp  = $canvas_color;
    $select_color_tmp  = $text_select_color;
    $snap2grid_tmp     = $snap2grid;
    $grid_spacing_tmp  = $grid_spacing;

    $family    = $default_family;
    $f_size    = $default_size;
    $f_weight  = $default_weight;
    $f_slant   = $default_slant;
    $f_under   = $default_underline;
    $f_angle   = $default_angle;

    $ob_width  = $default_width;
    $ob_color  = $default_color;
    $ob_corner = $default_smooth;
    $ob_fill   = $default_fill;
    $ob_fcolor = $default_fillcolor;

    $arrow     = $default_arrow;
    $acl       = $default_ahd1;   # arrow center length
    $asl       = $default_ahd2;   # arrow side length
    $ahw       = $default_ahd3;   # arrow half width

    $tmp_path  = "";
    $gs_path   = "";
    $ffmp_path = "";

#   Open the initialization file
    open ($fh, "<", $ini_file) || return &pop_up_error($main, "Unable to open\n$ini_file");

    while (defined($line = <$fh>)) {
        $line =~ s/^\s+//;
        $line =~ s/\s+$//;
        next if ($line =~ /^#/ || $line eq "" || $line =~ /^===/);

        if ($line =~ /[a-zA-Z_]+: /) {
            $pos = index($line, ":");
            $key = substr($line, 0, $pos);
            $val = substr($line, $pos + 1);
            $val =~ s/^\s+//;
            $val =~ s/\s+$//;

            $canvas_width_tmp  = $val if ($key eq "width");
            $canvas_height_tmp = $val if ($key eq "height");
            $canvas_color_tmp  = $val if ($key eq "color");
            $select_color_tmp  = $val if ($key eq "text_slct");
            $snap2grid_tmp     = $val if ($key eq "snap2grid");
            $grid_spacing_tmp  = $val if ($key eq "grid_spac");

            $family    = $val if ($key eq "family");
            $f_size    = $val if ($key eq "f_size");
            $f_weight  = $val if ($key eq "f_weight");
            $f_slant   = $val if ($key eq "f_slant");
            $f_under   = $val if ($key eq "f_under");
            $f_angle   = $val if ($key eq "f_angle");

            $ob_width  = $val if ($key eq "ob_width");
            $ob_color  = $val if ($key eq "ob_color");
            $ob_corner = $val if ($key eq "ob_corner");
            $ob_fill   = $val if ($key eq "ob_fill");
            $ob_fcolor = $val if ($key eq "ob_fcolor");

            $arrow     = $val if ($key eq "arrow");
            $acl       = $val if ($key eq "center");
            $asl       = $val if ($key eq "side");
            $ahw       = $val if ($key eq "halfwidth");

            $tmp_path  = $val if ($key eq "tmp_path");
            $gs_path   = $val if ($key eq "gs_path");
            $ffmp_path = $val if ($key eq "ffmp_path");
        }
    }

#   Close the initialization file
    close ($fh);

#   Check canvas inputs
    if ($canvas_width_tmp +0 >= 200) {
        $canvas_width = int($canvas_width_tmp +0.000001);
    }
    if ($canvas_height_tmp +0 >= 150) {
        $canvas_height = int($canvas_height_tmp +0.000001);
    }
    if (&get_rgb_code($canvas_color_tmp)) {
        $canvas_color = &get_rgb_code($canvas_color_tmp);
    } else {
        print "The specified canvas color is unrecognized.\n";
    }
    if (&get_rgb_code($select_color_tmp)) {
        $text_select_color = &get_rgb_code($select_color_tmp);
    } else {
        print "The specified text selection color is unrecognized.\n";
    }
    $snap2grid = ($snap2grid_tmp +0 == 1) ? 1 : 0;
    if ($grid_spacing_tmp +0 >= 2 && $grid_spacing_tmp +0 <= 100) {
        $grid_spacing = int($grid_spacing_tmp +0.000001);
    }

#   Check text inputs
    if (&list_match($family, @available_fonts) >= 0) {
        $default_family = $family;
    } else {
        print "The specified font family is not available.\n";
    }
    if ($f_size +0 >= 5 && $f_size +0 <= 32) {
        $default_size = int($f_size +0.000001);
    }
    if ($f_weight =~ /^(normal|bold)$/) {
        $default_weight = ($f_weight eq "bold") ? "bold" : "normal";
    }
    if ($f_slant =~ /^(normal|italic)$/) {
        $default_slant = ($f_slant eq "italic") ? 1 : 0;
    }
    if ($f_under =~ /^(no|yes)$/) {
        $default_underline = ($f_under eq "yes") ? 1 : 0;
    }
    if ($f_angle +0  >= 0 && $f_angle +0  <= 359) {
        $default_angle = int($f_angle +0.000001);
    }

#   Check object inputs
    if ($ob_width +0 >= 1 && $ob_width +0 <= 10) {
        $default_width = int($ob_width +0.000001);
    }
    if (&get_rgb_code($ob_color)) {
        $default_color = &get_rgb_code($ob_color);
    } else {
        print "The specified object color is unrecognized.\n";
    }
    if ($ob_corner =~ /^(standard|rounded)$/) {
        $default_smooth = ($ob_corner eq "rounded") ? 1 : 0;
    }
    if ($ob_fill =~ /^(no|yes)$/) {
        $default_fill = ($ob_fill eq "yes") ? 1 : 0;
    }
    if (&get_rgb_code($ob_fcolor)) {
        $default_fillcolor = &get_rgb_code($ob_fcolor);
    } else {
        print "The specified object fill color is unrecognized.\n";
    }

#   Check arrow inputs
    if ($arrow =~ /^(none|start|end|both)$/) {
        $default_arrow = &list_match($arrow, @arrow_options);
    }
    if ($acl +0 >= 6 && $acl +0 <= 100) {
        $default_ahd1 = int($acl +0.000001);
    }
    if ($asl +0 >= 10 && $asl +0 <= 100) {
        $default_ahd2 = int($asl +0.000001);
    }
    if ($ahw +0 >= 3 && $ahw +0 <= 40) {
        $default_ahd3 = int($ahw +0.000001);
    }

#   Check the tmp path, if present
    if ($tmp_path ne "") {
        if ($ini_file eq "${prog_path}w2anim.ini") {
            $tmp_path = File::Spec->rel2abs($tmp_path, $prog_path);
        } else {
            $tmp_path = File::Spec->rel2abs($tmp_path);
        }
        $error = 0;
        if (! -e $tmp_path) {
            print "The temporary space specified in w2anim.ini does not exist.\n"
                . "Using $temp_dir instead.\n";
            $error = 1;
        } elsif (! -d $tmp_path) {
            print "The temporary space specified in w2anim.ini is not a directory.\n"
                . "Using $temp_dir instead.\n";
            $error = 1;
        } elsif (! -r $tmp_path) {
            print "The temporary space specified in w2anim.ini is not readable.\n"
                . "Using $temp_dir instead.\n";
            $error = 1;
        } elsif (! -w $tmp_path) {
            print "The temporary space specified in w2anim.ini is not writable.\n"
                . "Using $temp_dir instead.\n";
            $error = 1;
        }
        $temp_dir = $tmp_path if (! $error);
    }

#   Check the GS path, if present
    if ($gs_path ne "") {
        if (lc($gs_path) eq "off") {
            $use_GS = 0;
            $GS_off = 1;
        } else {
            $gs_path = File::Spec->rel2abs($gs_path);
            $error = 0;
            if (! -e $gs_path) {
                print "The path to Ghostscript specified in w2anim.ini does not exist.\n";
                $error = 1;
            } elsif (-d $gs_path) {
                print "The path to Ghostscript specified in w2anim.ini is a directory.\n";
                $error = 1;
            }
            if (! $error) {
                $GS_PROG = $gs_path;
                $use_GS  = 1;
            } else {
                if ($GS_PROG ne "" && -e $GS_PROG) {
                    print "Using $GS_PROG instead.\n";
                    $use_GS = 1;
                } else {
                    $GS_PROG = "";
                    $use_GS  = 0;
                }
            }
        }
        if ($use_GS) {
            $export_menu->entryconfigure(1, -state => 'normal');
            $export_menu->entryconfigure(2, -state => 'normal');
            for ($i=0; $i<=$#animate_ids; $i++) {
                if ($props{$animate_ids[$i]}{meta} =~
                        /^(data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)$/) {
                    $export_menu->entryconfigure(3, -state => 'normal');
                    last;
                }
            }
        } else {
            $export_menu->entryconfigure(1, -state => 'disabled');
            $export_menu->entryconfigure(2, -state => 'disabled');
            $export_menu->entryconfigure(3, -state => 'disabled');
        }
    }

#   Check the FFmpeg path, if present
    if ($ffmp_path ne "") {
        if (lc($ffmp_path) eq "off") {
            $use_FFmpeg = 0;
            $FFmpeg_off = 1;
        } else {
            $ffmp_path = File::Spec->rel2abs($ffmp_path);
            $error = 0;
            if (! -e $ffmp_path) {
                print "The path to FFmpeg specified in w2anim.ini does not exist.\n";
                $error = 1;
            } elsif (-d $ffmp_path) {
                print "The path to FFmpeg specified in w2anim.ini is a directory.\n";
                $error = 1;
            }
            if (! $error) {
                $FFmpeg_PROG = $ffmp_path;
                $use_FFmpeg  = 1;
            } else {
                if ($FFmpeg_PROG ne "" && -e $FFmpeg_PROG) {
                    print "Using $FFmpeg_PROG instead.\n";
                    $use_FFmpeg = 1;
                } else {
                    $FFmpeg_PROG = "";
                    $use_FFmpeg  = 0;
                }
            }
        }
    }
}


sub write_ini_file {
    my (
        $arrow, $canv_color, $dir, $fill, $fill_color, $ini_file,
        $object_color, $select_color, $slant, $smooth, $underline,
       );

#   Ask the user for the directory where the w2anim.ini file will reside
    $dir = Tkx::tk___chooseDirectory(-parent     => $main,
                                     -title      => "Directory for w2anim.ini File",
                                     -initialdir => $ini_path,
                                    );
    return if (! defined($dir) || $dir eq "");
    if (! -e $dir) {
        return &pop_up_error($main, "Directory does not exist.\n$dir");
    } elsif (! -d $dir) {
        return &pop_up_error($main, "Selection is not a directory.\n$dir");
    } elsif (! -r $dir) {
        return &pop_up_error($main, "Directory is not readable.\n$dir");
    } elsif (! -w $dir) {
        return &pop_up_error($main, "Directory is not writeable.\n$dir");
    }

    $ini_file = File::Spec->rel2abs("w2anim.ini", $dir);
    if (-e $ini_file) {
        return if ( lc(&pop_up_question($main, "Overwrite $ini_file?")) eq "no" );
    }

#   Open the w2anim.ini file and write out its contents
    open (OUT, ">", $ini_file) || return &pop_up_error($main, "Unable to open\n$ini_file");

    $canv_color   = &get_rgb_name($canvas_color);
    $select_color = &get_rgb_name($text_select_color);
    $object_color = &get_rgb_name($default_color);
    $fill_color   = &get_rgb_name($default_fillcolor);
    $slant        = ($default_slant)     ? "italic"  : "normal";
    $underline    = ($default_underline) ? "yes"     : "no";
    $smooth       = ($default_smooth)    ? "rounded" : "standard";
    $fill         = ($default_fill)      ? "yes"     : "no";
    $arrow        = $arrow_options[$default_arrow];

    print OUT << "end_of_input";
# W2 Animator initialization file, version $version

==== CANVAS ====
  width:     $canvas_width
  height:    $canvas_height
  color:     $canv_color
  text_slct: $select_color
  snap2grid: $snap2grid
  grid_spac: $grid_spacing
==== END CANVAS ====

==== FONT DEFAULTS ====
  family:    $default_family
  f_size:    $default_size
  f_weight:  $default_weight
  f_slant:   $slant
  f_under:   $underline
  f_angle:   $default_angle
==== END FONT DEFAULTS ====

==== OBJECT DEFAULTS ====
  ob_width:  $default_width
  ob_color:  $object_color
  ob_corner: $smooth
  ob_fill:   $fill
  ob_fcolor: $fill_color
==== END OBJECT DEFAULTS ====

==== ARROW DEFAULTS ====
  arrow:     $arrow
  center:    $default_ahd1
  side:      $default_ahd2
  halfwidth: $default_ahd3
==== END ARROW DEFAULTS ====

==== CONFIG ====
  tmp_path:  $temp_dir
end_of_input

    if ($GS_off && $GS_PROG eq "") {
        print OUT "  gs_path:   off\n";
    } else {
        print OUT "  gs_path:   $GS_PROG\n";
    }
    if ($FFmpeg_off && $FFmpeg_PROG eq "") {
        print OUT "  ffmp_path: off\n";
    } else {
        print OUT "  ffmp_path: $FFmpeg_PROG\n";
    }
    print OUT "==== END CONFIG ====\n";

#   Close the w2anim.ini file
    close (OUT) || return &pop_up_error($main, "Trouble closing\n$ini_file");
    &pop_up_info($main, "Successfully wrote initialization file:\n$ini_file");
}


sub adjust_main_position {
    my ($geom, $main_h, $main_w, $X, $Y);

    Tkx::update_idletasks();
    $geom = $main->g_wm_geometry();
    ($main_w, $main_h, $X, $Y) = split(/x|\+/, $geom);
    if ($X < -8 || $Y < 0 || $X +$main_w > $screen_width -6 || $Y +$main_h > $screen_height -12) {
        $X    = $screen_width  -$main_w -6  if ($X +$main_w > $screen_width  -6);
        $Y    = $screen_height -$main_h -12 if ($Y +$main_h > $screen_height -12);
        $X    = -8 if ($X < -8);
        $Y    =  0 if ($Y <  0);
        $geom = sprintf("%dx%d+%d+%d", $main_w, $main_h, $X, $Y);
        $main->g_wm_geometry($geom);
    }
}


sub adjust_window_position {
    my ($window) = @_;
    my ($geom, $height, $width, $X, $Y);

    Tkx::update_idletasks();
    $geom = $window->g_wm_geometry();
    ($width, $height, $X, $Y) = split(/x|\+/, $geom);
    if ($X < 5 || $Y < 5 || $X +$width > $screen_width -6 || $Y +$height > $screen_height -8) {
        $X    = $screen_width  -$width  -6 if ($X +$width  > $screen_width  -6);
        $Y    = $screen_height -$height -8 if ($Y +$height > $screen_height -8);
        $X    = 5 if ($X < 5);
        $Y    = 5 if ($Y < 5);
        $geom = sprintf("+%d+%d", $X, $Y);
        $window->g_wm_geometry($geom);
    }
}


sub initialize_canvas_scrollbars {
    my ($geom, $X, $Y);

#   This subroutine initializes the canvas scrollbars either when W2Anim first begins
#   or when a saved W2Anim project is loaded.

    $geom = $main->g_wm_geometry();
    (undef, undef, $X, $Y) = split(/x|\+/, $geom);

    if ($canvas_width <= $screen_width && $canvas_height <= $screen_height) {
        $canvas_xscroll->g_grid_remove();
        $canvas_yscroll->g_grid_remove();
        $max_main_width  = $canvas_width  +6;
        $max_main_height = $canvas_height +6 +$main_footer_height;

    } elsif ($canvas_width > $screen_width -15 && $canvas_height > $screen_height -15) {
        $canvas_xscroll->g_grid();
        $canvas_yscroll->g_grid();
        $max_main_width  = $screen_width  +6;
        $max_main_height = $screen_height +6 +$main_footer_height;

    } elsif ($canvas_width > $screen_width) {
        $canvas_xscroll->g_grid();
        $canvas_yscroll->g_grid_remove();
        $max_main_width  = $screen_width  +6;
        $max_main_height = $canvas_height +21 +$main_footer_height;

    } elsif ($canvas_height > $screen_height) {
        $canvas_xscroll->g_grid_remove();
        $canvas_yscroll->g_grid();
        $max_main_width  = $canvas_width  +21;
        $max_main_height = $screen_height +6 +$main_footer_height;
    }
    $geom = sprintf("%dx%d+%d+%d", $max_main_width, $max_main_height, $X, $Y);
    $main->g_wm_geometry($geom);
    Tkx::wm_maxsize($main, $max_main_width, $max_main_height);
}


sub manage_canvas_scrollbars {
    my ($widget) = @_;
    return if ($widget ne $main_frame);

    $nconfig_events++;
    return if ($nconfig_events > 1);

    Tkx::after_idle(sub {Tkx::after(100, [\&update_canvas_scrollbars]);});
}


sub update_canvas_scrollbars {
    my ($fh, $fw, $geom, $main_dx, $main_dy, $main_h, $main_w, $X, $xscroll, $Y, $yscroll,
        @grid_kids,
       );

#   This subroutine manages the canvas scrollbars in response to a main window frame resize event.
#   It doesn't work perfectly, due to issues with the GUI updates and window configure events.

    $geom = $main->g_wm_geometry();
    ($main_w, $main_h, $X, $Y) = split(/x|\+/, $geom);

    $geom = $main_frame->g_winfo_geometry();
    ($fw, $fh, undef, undef) = split(/x|\+/, $geom);
    @grid_kids = Tkx::SplitList($main_frame->g_grid_slaves());
    $xscroll = (&list_match($canvas_xscroll, @grid_kids) == -1) ? 0 : 1;
    $yscroll = (&list_match($canvas_yscroll, @grid_kids) == -1) ? 0 : 1;

    $main_dx = $main_dy = 0;
    if ($xscroll && $yscroll) {
        if ($fw >= $canvas_width +21 && $fh >= $canvas_height +21) {
            $canvas_xscroll->g_grid_remove();
            $canvas_yscroll->g_grid_remove();
            $max_main_width  -= 15;
            $max_main_height -= 15;
            $main_dx         -= 15;
            $main_dy         -= 15;
        } elsif ($fw >= $canvas_width +21) {
            $canvas_xscroll->g_grid_remove();
            $max_main_height -= 15;
            $main_dy         -= 15;
            if ($fh >= $canvas_height +6) {
                $canvas_yscroll->g_grid_remove();
                $max_main_width -= 15;
                $main_dx        -= 15;
            }
        } elsif ($fh >= $canvas_height +21) {
            $canvas_yscroll->g_grid_remove();
            $max_main_width -= 15;
            $main_dx        -= 15;
            if ($fw >= $canvas_width +6) {
                $canvas_xscroll->g_grid_remove();
                $max_main_height -= 15;
                $main_dy         -= 15;
            }
        }
    } elsif (! $xscroll && ! $yscroll) {
        if ($fw < $canvas_width +6 && $fh < $canvas_height +6) {
            $canvas_xscroll->g_grid();
            $canvas_yscroll->g_grid();
            $max_main_width  += 15;
            $max_main_height += 15;
            $main_dx         += 15;
            $main_dy         += 15;
        } elsif ($fw < $canvas_width +6) {
            $canvas_xscroll->g_grid();
            $max_main_height += 15;
            $main_dy         += 15;
        } elsif ($fh < $canvas_height +6) {
            $canvas_yscroll->g_grid();
            $max_main_width  += 15;
            $main_dx         += 15;
        }
    } elsif ($xscroll) {
        if ($fw >= $canvas_width +6) {
            $canvas_xscroll->g_grid_remove();
            $max_main_height -= 15;
            $main_dy         -= 15;
        }
        if ($fh < $canvas_height +21) {
            $canvas_yscroll->g_grid();
            $max_main_width  += 15;
            $main_dx         += 15;
        }
    } else {
        if ($fw < $canvas_width +21) {
            $canvas_xscroll->g_grid();
            $max_main_height += 15;
            $main_dy         += 15;
        }
        if ($fh >= $canvas_height +6) {
            $canvas_yscroll->g_grid_remove();
            $max_main_width  -= 15;
            $main_dx         -= 15;
        }
    }
    if ($main_dx != 0 || $main_dy != 0) {
        Tkx::wm_maxsize($main, $max_main_width, $max_main_height);
        $geom = sprintf("%dx%d+%d+%d", $main_w +$main_dx, $main_h +$main_dy, $X, $Y);
        $main->g_wm_geometry($geom);
    }
    $nconfig_events = 0;
}


sub update_scrollable_menu {
    my ($parent_menu, $sc_frame, $sc_canvas, $tag, $vsbar) = @_;
    my ($height, $width, $yscroll,
        @grid_kids,
       );

    @grid_kids = Tkx::SplitList($sc_frame->g_grid_slaves());
    $yscroll   = (&list_match($vsbar, @grid_kids) == -1) ? 0 : 1;

    Tkx::update_idletasks();
    (undef, undef, $width, $height) = Tkx::SplitList($sc_canvas->bbox($tag));

    if ($height <= $screen_height -100) {
        $vsbar->g_grid_remove() if ($yscroll);
    } else {
        $vsbar->g_grid() if (! $yscroll);
    }
    $sc_canvas->configure(-width        => $width,
                          -height       => &min($height, $screen_height-100),
                          -scrollregion => [0, 0, $width, $height],
                         );

    &adjust_window_position($parent_menu);
}


sub update_scrollable_tab {
    my ($parent_menu, $sc_tab, $sc_canvas, $tag, $vsbar) = @_;
    my ($height, $width, $yscroll,
        @grid_kids,
       );

    @grid_kids = Tkx::SplitList($sc_tab->g_grid_slaves());
    $yscroll   = (&list_match($vsbar, @grid_kids) == -1) ? 0 : 1;

    Tkx::update_idletasks();
    (undef, undef, $width, $height) = Tkx::SplitList($sc_canvas->bbox($tag));

    if ($height <= &min(350, $screen_height -200)) {
        $vsbar->g_grid_remove() if ($yscroll);
    } else {
        $vsbar->g_grid() if (! $yscroll);
    }
    $sc_canvas->configure(-width        => $width,
                          -height       => &min($height, &min(350, $screen_height-200)),
                          -scrollregion => [0, 0, $width, $height],
                         );

    &adjust_window_position($parent_menu);
}


sub get_xy {
    my ($canv, $x, $y, $snap) = @_;

    $x = &min(&max(3, $canv->canvasx($x)), $canvas_width  +2);
    $y = &min(&max(3, $canv->canvasy($y)), $canvas_height +2);
    if ($snap && $snap2grid) {
        $x = &min(3+ $grid_spacing * &round_to_int(($x-3) /$grid_spacing), $canvas_width  +2);
        $y = &min(3+ $grid_spacing * &round_to_int(($y-3) /$grid_spacing), $canvas_height +2);
    }
    return ($x, $y);
}


sub show_xypos {
    my ($x, $y, $canv, $simple) = @_;
    my ($got_graph, $i, $id, $ncols, $nrows, $tol, $x1, $x2, $xloc, $xmax,
        $xmin, $y1, $y2, $yloc, $ymax, $ymin,
        @ids, @tags,
       );

    ($x, $y) = &get_xy($canv, $x, $y, $snap2grid);
    if ($snap2grid) {
        $canv->delete("target");
        $canv->create_rectangle($x-2, $y-2, $x+2, $y+2,
                         -outline => "",
                         -width   => 0,
                         -fill    => &get_rgb_code($anchor_select_color),
                         -tags    => "target");
    }
    $status_line = sprintf("X,Y: %d, %d", $x-3, $y-3);
    return if ($simple);

#   If over a graph, show the internal graph coordinates as well
    $got_graph = 0;
    $tol = 4;
    $nrows = $ncols = 1;

    @ids = Tkx::SplitList($canv->find_overlapping($x-$tol, $y-$tol, $x+$tol, $y+$tol));
    for ($i=$#ids; $i>=0; $i--) {
        @tags = Tkx::SplitList($canv->itemcget($ids[$i], -tags));
        next if (&list_match("working",    @tags) > -1);
        next if (&list_match("target",     @tags) > -1);
        next if (&list_match("select_box", @tags) > -1);
        next if (&list_match("select_pts", @tags) > -1);
        next if (&list_match("zoom_bar",   @tags) > -1);
        if (&list_search("^graph", @tags) > -1) {
            $id = $tags[&list_search("^graph", @tags)];
            $id =~ s/^graph//;
            $id =~ s/_.*$//;
            $got_graph = 1;
            last;
        } else {
            last if (&select_item($canv, $ids[$i], $x, $y, $tol));
        }
    }
    if ($got_graph) {
        return if (! defined($gr_props{$id}));
        ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
        if ($x >= $x1 && $x <= $x2 && $y >= $y1 && $y <= $y2) {
            if ($props{$id}{meta} eq "w2_tdmap") {
                if ($gr_props{$id}{date_axis} eq "Y") {
                    $xmin = $gr_props{$id}{dmin};
                    $xmax = $gr_props{$id}{dmax};
                    if ($gr_props{$id}{dflip}) {
                        $xloc = $xmin +($xmax -$xmin) *(1.0 -($x -$x1) /($x2 -$x1));
                    } else {
                        $xloc = $xmin +($xmax -$xmin) *($x -$x1) /($x2 -$x1);
                    }
                    if ($gr_props{$id}{ttype} eq "Date/Time") {
                        $ymin = &datelabel2jdate($gr_props{$id}{tmin});
                        $ymax = &datelabel2jdate($gr_props{$id}{tmax});
                    } else {
                        $ymin = $gr_props{$id}{tmin};
                        $ymax = $gr_props{$id}{tmax};
                    }
                    if ($gr_props{$id}{tflip}) {
                        $yloc = $ymin +($ymax -$ymin) *(1.0 -($y -$y1) /($y2 -$y1));
                    } else {
                        $yloc = $ymin +($ymax -$ymin) *($y -$y1) /($y2 -$y1);
                    }
                    if ($gr_props{$id}{ttype} eq "Date/Time") {
                        $yloc = &jdate2datelabel($yloc, "Mon-DD-YYYY");
                        $status_line .= sprintf("  [%.2f, %s]", $xloc, $yloc);
                    } else {
                        $status_line .= sprintf("  [%.2f, %.2f]", $xloc, $yloc);
                    }
                } else {
                    $ymin = $gr_props{$id}{dmin};
                    $ymax = $gr_props{$id}{dmax};
                    if ($gr_props{$id}{dflip}) {
                        $yloc = $ymin +($ymax -$ymin) *($y -$y1) /($y2 -$y1);
                    } else {
                        $yloc = $ymin +($ymax -$ymin) *(1.0 -($y -$y1) /($y2 -$y1));
                    }
                    if ($gr_props{$id}{ttype} eq "Date/Time") {
                        $xmin = &datelabel2jdate($gr_props{$id}{tmin});
                        $xmax = &datelabel2jdate($gr_props{$id}{tmax});
                    } else {
                        $xmin = $gr_props{$id}{tmin};
                        $xmax = $gr_props{$id}{tmax};
                    }
                    if ($gr_props{$id}{tflip}) {
                        $xloc = $xmin +($xmax -$xmin) *(1.0 -($x -$x1) /($x2 -$x1));
                    } else {
                        $xloc = $xmin +($xmax -$xmin) *($x -$x1) /($x2 -$x1);
                    }
                    if ($gr_props{$id}{ttype} eq "Date/Time") {
                        $xloc = &jdate2datelabel($xloc, "Mon-DD-YYYY");
                        $status_line .= sprintf("  [%s, %.2f]", $xloc, $yloc);
                    } else {
                        $status_line .= sprintf("  [%.2f, %.2f]", $xloc, $yloc);
                    }
                }
            } else {
                if ($props{$id}{meta} eq "w2_profile_matrix") {
                    ($nrows, $ncols) = split(/x/, $gr_props{$id}{matrix});
                }
                $ymin = $gr_props{$id}{ymin};
                $ymax = $gr_props{$id}{ymax};
                if ($props{$id}{meta} =~ /(data_profile|w2_profile|w2_slice|w2_outflow|vert_wd_zone)/
                    && $gr_props{$id}{ytype} eq "Depth") {
                    if ($nrows == 1) {
                        $yloc = $ymax *($y -$y1) /($y2 -$y1);
                    } else {
                        $yloc = $ymax *(($nrows *($y -$y1) /($y2 -$y1))
                                    -int($nrows *($y -$y1) /($y2 -$y1)));
                    }
                } else {
                    if ($nrows == 1) {
                        $yloc = $ymin +($ymax -$ymin) *($y2 -$y) /($y2 -$y1);
                    } else {
                        $yloc = $ymin +($ymax -$ymin) *(($nrows *($y2 -$y) /($y2 -$y1))
                                                    -int($nrows *($y2 -$y) /($y2 -$y1)));
                    }
                }
                if ($props{$id}{meta} =~ /(data_profile_cmap|w2_profile_cmap|time_series)/
                     && (! defined($gr_props{$id}{xtype}) || $gr_props{$id}{xtype} eq "Date/Time")) {
                    $xmin = &datelabel2jdate($gr_props{$id}{xmin});
                    $xmax = &datelabel2jdate($gr_props{$id}{xmax});
                    $xloc = $xmin +($xmax -$xmin) *($x -$x1) /($x2 -$x1);
                    $xloc = &jdate2datelabel($xloc, "Mon-DD-YYYY");
                    $status_line .= sprintf("  [%s, %.2f]", $xloc, $yloc);
                } else {
                    $xmin = $gr_props{$id}{xmin};
                    $xmax = $gr_props{$id}{xmax};
                    if ($props{$id}{meta} =~ /w2_slice|w2_wlevels/ && $gr_props{$id}{xflip}) {
                        $xloc = $xmin +($xmax -$xmin) *(1.0 -($x -$x1) /($x2 -$x1));
                    } else {
                        if ($ncols == 1) {
                            $xloc = $xmin +($xmax -$xmin) *($x -$x1) /($x2 -$x1);
                        } else {
                            $xloc = $xmin +($xmax -$xmin) *(($ncols *($x -$x1) /($x2 -$x1))
                                                        -int($ncols *($x -$x1) /($x2 -$x1)));
                        }
                    }
                    $status_line .= sprintf("  [%.2f, %.2f]", $xloc, $yloc);
                }
            }
        }
    }
}


sub make_crosshair {
    my ($xo, $yo, $canv, $ang) = @_;
    my ($i, $next_id, $top_id, $x1, $x2, $y1, $y2,
        @items, @tags,
       );

    $canv->delete("crosshair");
    $x1 = $xo -10 *cos($ang *pi/180.);
    $y1 = $yo +10 *sin($ang *pi/180.);
    $x2 = $xo +10 *cos($ang *pi/180.);
    $y2 = $yo -10 *sin($ang *pi/180.);
    $canv->create_line($x1, $y1, $x2, $y2,
             -fill  => &get_rgb_code($anchor_select_color),
             -width => 1,
             -tags  => "crosshair");
    $x1 = $xo -10 *cos(($ang +90) *pi/180.);
    $y1 = $yo +10 *sin(($ang +90) *pi/180.);
    $x2 = $xo +10 *cos(($ang +90) *pi/180.);
    $y2 = $yo -10 *sin(($ang +90) *pi/180.);
    $canv->create_line($x1, $y1, $x2, $y2,
             -fill  => &get_rgb_code($anchor_select_color),
             -width => 1,
             -tags  => "crosshair");
    
    @items = Tkx::SplitList($canv->find_overlapping($xo, $yo, $xo, $yo));
    for ($i=$#items; $i>=0; $i--) {
        @tags = Tkx::SplitList($canv->itemcget($items[$i], -tags));
        if ( &list_match("anchor", @tags) > -1 ) {
            $top_id = $canv->find_above($items[$i]);
            if ($top_id ne "") {
                while (($next_id = $canv->find_above($top_id)) ne "") {
                    $top_id = $next_id;
                }
                $canv->raise($items[$i], $top_id);
            }
            last;
        }
    }
}


sub find_rect_from_text_or_image {
    my ($canv, $id) = @_;
    my ($anc, $ang, $ang2, $d, $hh, $hw, $i, $type,
        $x, $x1, $x2, $xo, $y, $y1, $y2, $yo,
        @coords, @new_coords, @xvals, @yvals,
       );

    $type = $props{$id}{type};
    $xo   = $props{$id}{x};
    $yo   = $props{$id}{y};
    $anc  = $props{$id}{anchor};
    $ang  = $props{$id}{angle};

    if ($type eq "text") {
        $canv->itemconfigure($id, -angle => 0) if ($ang != 0);
        ($x1, $y1, $x2, $y2) = Tkx::SplitList($canv->bbox($id));
        $canv->itemconfigure($id, -angle => $ang) if ($ang != 0);
        $hw = abs($x2-$x1)/2.;
        $hh = abs($y2-$y1)/2.;
    } else {
        $hw = ($props{$id}{iw} -1)/2.;
        $hh = ($props{$id}{ih} -1)/2.;
    }

#   Set the encompassing rectangle for an un-rotated object
#   Estimate locations based on anchor (n, ne, e, se, s, sw, w, nw, center)
    if ($anc eq 'nw') {
        @coords = ($xo, $yo, $xo+2*$hw, $yo, $xo+2*$hw, $yo+2*$hh, $xo, $yo+2*$hh);
    } elsif ($anc eq 'n') {
        @coords = ($xo-$hw, $yo, $xo+$hw, $yo, $xo+$hw, $yo+2*$hh, $xo-$hw, $yo+2*$hh);
    } elsif ($anc eq 'ne') {
        @coords = ($xo-2*$hw, $yo, $xo, $yo, $xo, $yo+2*$hh, $xo-2*$hw, $yo+2*$hh);
    } elsif ($anc eq 'e') {
        @coords = ($xo-2*$hw, $yo-$hh, $xo, $yo-$hh, $xo, $yo+$hh, $xo-2*$hw, $yo+$hh);
    } elsif ($anc eq 'se') {
        @coords = ($xo-2*$hw, $yo-2*$hh, $xo, $yo-2*$hh, $xo, $yo, $xo-2*$hw, $yo);
    } elsif ($anc eq 's') {
        @coords = ($xo-$hw, $yo-2*$hh, $xo+$hw, $yo-2*$hh, $xo+$hw, $yo, $xo-$hw, $yo);
    } elsif ($anc eq 'sw') {
        @coords = ($xo, $yo-2*$hh, $xo+2*$hw, $yo-2*$hh, $xo+2*$hw, $yo, $xo, $yo);
    } elsif ($anc eq 'w') {
        @coords = ($xo, $yo-$hh, $xo+2*$hw, $yo-$hh, $xo+2*$hw, $yo+$hh, $xo, $yo+$hh);
    } else {
        @coords = ($xo-$hw, $yo-$hh, $xo+$hw, $yo-$hh, $xo+$hw, $yo+$hh, $xo-$hw, $yo+$hh);
    }

#   Rotate the rectangle, if needed
    if ($ang != 0) {
        @new_coords = ();
        for ($i=0; $i<4; $i++) {
            $x = $coords[2*$i];
            $y = $coords[2*$i+1];
            if ($x == $xo && $y == $yo) {
                push (@new_coords, $x, $y);
                next;
            }
            $d = sqrt(($x-$xo)*($x-$xo) + ($y-$yo)*($y-$yo));
            if ($x == $xo) {
                $ang2 = ($y > $yo) ? 270 : 90;
            } elsif ($y == $yo) {
                $ang2 = ($x > $xo) ? 0 : 180;
            } else {
                $ang2 = (180./pi)*atan2(($yo-$y),($x-$xo));
            }
            $ang2 += 360 if ($ang2 < 0);
            $x = $xo +$d *cos(($ang2 +$ang) *pi/180.);
            $y = $yo -$d *sin(($ang2 +$ang) *pi/180.);
            push (@new_coords, $x, $y);
        }
        @coords = @new_coords;
    }

#   Find the center point
    if ($anc eq 'center') {
        $props{$id}{xc} = $xo;
        $props{$id}{yc} = $yo;
    } else {
        @xvals = @yvals = ();
        for ($i=0; $i<4; $i++) {
            push (@xvals, $coords[2*$i]  );
            push (@yvals, $coords[2*$i+1]);
        }
        $props{$id}{xc} = (&min(@xvals) + &max(@xvals))/2.;
        $props{$id}{yc} = (&min(@yvals) + &max(@yvals))/2.;
    }
    return @coords;
}


sub get_coords {
    my ($canv, $id, $method) = @_;
    my ($type, @coords);

    $method = "bbox" if (! defined($method) || $method ne "pts");
    $type   = $props{$id}{type};
    @coords = @{ $props{$id}{coordlist} } if ($type !~ /^(text|image)$/);

    if ($type eq "text" || $type eq "image") {
        @coords = &find_rect_from_text_or_image($canv, $id);

    } elsif ($type eq "circle" || ($type eq "graph" && $method eq "pts")) {
        push(@coords, $coords[0], $coords[3]);
        splice(@coords, 2, 0, $coords[2], $coords[1]);

    } elsif ($method eq "bbox") {
        if ($type =~ /^(ellipse|diamond)$/) {
            @coords = &find_rect_from_shape(\@coords, $props{$id}{angle});

        } elsif ($type =~ /^(polygon|polyline)$/) {
            @coords = &find_rect_from_poly(\@coords, $props{$id}{angle});

        } elsif ($type eq "graph") {
            @coords = Tkx::SplitList($canv->bbox("graph" . $id));
            push(@coords, $coords[0], $coords[3]);
            splice(@coords, 2, 0, $coords[2], $coords[1]);
        }
    }
    return @coords;
}


sub get_group_type {
    my ($id, @tags) = @_;
    my ($label, $grp);

    if ($props{$id}{meta} eq "data_profile") {
        $label = "Profile Graph";
    } elsif ($props{$id}{meta} eq "data_profile_cmap") {
        $label = "Profile Colormap";
    } elsif ($props{$id}{meta} eq "w2_profile") {
        $label = "W2 Profile Graph";
    } elsif ($props{$id}{meta} eq "w2_profile_cmap") {
        $label = "W2 Profile Colormap";
    } elsif ($props{$id}{meta} eq "w2_profile_matrix") {
        $label = "W2 Profile Matrix";
    } elsif ($props{$id}{meta} eq "w2_slice") {
        $label = "W2 Longitudinal Slice";
    } elsif ($props{$id}{meta} eq "w2_tdmap") {
        $label = "W2 Time/Distance Map";
        if ($props{$id}{map_type} =~ /^(parmdiff|filediff)$/) {
            $label = "W2 Time/Distance Difference Map";
        }
    } elsif ($props{$id}{meta} eq "w2_outflow") {
        $label = "W2 Outflow Profile";
    } elsif ($props{$id}{meta} eq "w2_wlevels") {
        $label = "W2 Water Levels Graph";
    } elsif ($props{$id}{meta} eq "vert_wd_zone") {
        $label = "Wthdrawal Zone Graph";
    } elsif ($props{$id}{meta} eq "linked_time_series") {
        $label = "Linked Time Series Graph";
    } elsif ($props{$id}{meta} eq "time_series") {
        $label = "Time Series Graph";
    } else {
        $label = "";
    }
    ($grp = $tags[&list_search("^graph.*_", @tags)]) =~ s/^graph.*_//;
    if ($grp eq "gtitle") {
        $label .= " - Graph Title";
    } elsif ($grp eq "date") {
        if ($props{$id}{meta} eq "w2_profile_matrix") {
            $label .= " - Graph Date";
        } else {
            $label .= " - Graph Subtitle";
        }
    } elsif ($grp eq "stats") {
        $label .= " - Fit Statistics";
    } elsif ($grp eq "xaxisTitle") {
        $label .= " - X Axis Title";
    } elsif ($grp eq "yaxisTitle") {
        $label .= " - Y Axis Title";
    } elsif ($grp eq "saxisTitle") {
        $label .= " - Segment Axis Title";
    } elsif ($grp eq "xaxis") {
        $label .= " - X Axis";
    } elsif ($grp eq "yaxis") {
        $label .= " - Y Axis";
    } elsif ($grp eq "saxis") {
        $label .= " - Segment Axis";
    } elsif ($grp eq "colorKeyTitle") {
        $label .= " - Color Key Title";
    } elsif ($grp eq "colorKey") {
        $label .= " - Color Key";
    } elsif ($grp eq "legend") {
        $label .= " - Legend";
    }
    $label =~ s/^ - // if ($label =~ /^ - /);
    return $label;
}


sub numeric_entry_only {
    my ($entry, $auto) = @_;
    my ($i, $len, $pos, $tmp);

    $auto = 0 if (! defined($auto) || $auto != 1);

#   An entry of "auto" is okay
    $tmp = $entry->get();
    if ($auto) {
        return if ($tmp eq 'auto');
        if ($tmp =~ /^auto/) {
            $len = length($tmp);
            for ($i=$len-1; $i>=4; $i--) {
                $entry->delete($i,$i+1);
            }
            return;
        }
        if ($tmp eq 'a') {
            $entry->insert(1,'uto');
            return;
        }
        if ($tmp eq 'A') {
            $entry->delete(0,1);
            $entry->insert(0,'auto');
            return;
        }
    }

#   Make sure that if a "-" is present, it is first
    if ($tmp =~ /-/ && length($tmp) > 1) {
        $pos = index($tmp, "-", 1);
        if ($pos > 0) {
            $entry->delete($pos,$pos+1);
        }
    }

#   Remove any characters other than -, 0-9, and .
    $tmp = $entry->get();
    if ($tmp =~ /[^-0-9\.]/) {
        $len = length($tmp);
        for ($i=$len-1; $i>=0; $i--) {
            if (substr($tmp,$i,1) =~ /[^-0-9\.]/) {
                $entry->delete($i,$i+1);
            }
        }
    }

#   Remove any further instances of .
    $tmp = $entry->get();
    if ($tmp =~ /\./) {
        $pos = index($tmp, ".");
        $len = length($tmp);
        for ($i=$len-1; $i>$pos; $i--) {
            if (substr($tmp,$i,1) eq ".") {
                $entry->delete($i,$i+1);
            }
        }
    }
}


sub reset_bindings {
    my ($geom, $X, $Y);

    $canvas->g_bind("<Motion>",               "");
    $canvas->g_bind("<Shift-Motion>",         "");
    $canvas->g_bind("<Control-Motion>",       "");
    $canvas->g_bind("<Control-Shift-Motion>", "");
    $canvas->g_bind("<Button1-Motion>",       "");
    $canvas->g_bind("<Button-1>",             "");
    $canvas->g_bind("<ButtonRelease-1>",      "");
    $canvas->g_bind("<Shift-Button-1>",       "");
    $canvas->g_bind("<Double-Button-1>",      "");
    $canvas->g_bind("<Button-3>",             "");

    $canvas->delete($popmenu) if ($popmenu);

    $canvas->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"), $canvas, "menu" ]);

    $canvas->configure(-cursor => $cursor_norm);
    if (defined($zoom_tb) && Tkx::winfo_exists($zoom_tb)) {
        if ($zoom_tb->g_wm_title() eq "Zoom toolbar") {
            if ($zoom_tip =~ /(Select|Draw)/) {
                $geom = $zoom_tb->g_wm_geometry();
                (undef, $X, $Y) = split(/\+/, $geom);
                &zoom_toolbar($X, $Y);
            }
        }
    }
    $status_line = "";
}


sub altp_popup {
    my ($x, $y, $menuX, $menuY, $canv) = @_;
    my ($i, $id, $tol,
        @ids, @tags,
       );

    ($x, $y) = &get_xy($canv, $x, $y, 0);
    $id  = "";
    $tol = 4;

#   The find method will find a polygon for every point inside that polygon
#   regardless of whether the polygon is filled, so some extra searching is
#   required when polygons are used.  Rectangles, diamonds, polygons, and
#   ellipses are polygons in this program.

    @ids = Tkx::SplitList($canv->find_overlapping($x-$tol, $y-$tol, $x+$tol, $y+$tol));
    for ($i=$#ids; $i>=0; $i--) {
        @tags = Tkx::SplitList($canv->itemcget($ids[$i], -tags));
        next if (&list_match("working",    @tags) > -1);
        next if (&list_match("select_box", @tags) > -1);
        next if (&list_match("select_pts", @tags) > -1);
        next if (&list_match("zoom_bar",   @tags) > -1);
        if (&list_search("^graph", @tags) > -1) {
            $id = $tags[&list_search("^graph", @tags)];
            $id =~ s/^graph//;
            $id =~ s/_.*$//;
            last;

        } elsif (&select_item($canv, $ids[$i], $x, $y, $tol)) {
            $id = $ids[$i];
            last;
        }
    }
    &popup_menu($menuX, $menuY, $canv, $id);
}


sub start_anew {
    my ($answer, $different, $i, $id, $n, $tmp_file, @id_list, @tmp_list);

#   Are any objects on the canvas labeled "keep"?
#   Does the user wish to save them before starting anew?
    @id_list  = Tkx::SplitList($canvas->find_withtag("keep"));
    @tmp_list = @id_list;
    for ($i=0; $i<=$#tmp_list; $i++) {
        $id = $tmp_list[$i];
        if ($props{$id}{type} eq "graph") {
            if (! defined($props{$id}{gnum})) {        # Graph not fully created yet
                $n = &list_match($id, @id_list);
                splice(@id_list, $n, 1) if ($n >= 0);  # Remove from list
            }
        }
    }
    if ($#id_list >= 0) {
        $tmp_file = "";
        if (-e $autosave_file) {
            ($tmp_file = $autosave_file) =~ s/\.w2a$/tmp\.w2a/;
            copy($autosave_file, $tmp_file);
        }
        &save_file($autosave_file, 1);

      # If an autosave file already existed, push it to autosave_file2 if different
        if ($tmp_file ne "") {
            $different = &compare_saved($autosave_file, $tmp_file);
            if ($different) {
                unlink $autosave_file2 if (-e $autosave_file2);
                move($tmp_file, $autosave_file2);
                $autosave_menu->entryconfigure('end', -state => 'normal');
            } else {
                unlink $tmp_file;
            }
        }
        $autosave_menu->entryconfigure(8, -state => 'normal');  # entry 8 is "Revert, recent"

      # Compare current project file to saved file
        if ($savefile ne "" && -e $savefile) {
            $different = &compare_saved($autosave_file, $savefile);
            if ($different) {
                $answer = &pop_up_question($main,
                               "Current project is different than\n"
                             . "saved project file. Do you want to save\n"
                             . "the current project before starting over?");
                return &save_file if (lc($answer) eq "yes");
            }
        } else {
            $answer = &pop_up_question($main,
                           "Current project has not been saved.\n"
                         . "Do you want to save it before starting over?");
            return &save_file if (lc($answer) eq "yes");
        }
    }

#   Delete existing stuff on the canvas
    @id_list = Tkx::SplitList($canvas->find_all());
    for ($i=0; $i<=$#id_list; $i++) {
        $canvas->delete($id_list[$i]);
    }
    undef $ts_datemin;
    undef $ts_datemax;
    undef $cmap_datemin;
    undef $cmap_datemax;
    undef @dates;
    undef @id_list;
    undef %grid;
    undef %props;
    undef %gr_props;
    undef %link_props;
    undef $old_id if (defined($old_id));
    @animate_ids      = ();
    @ind_link_ids     = ();
    @dtis_with_pdata  = ();
    $w2profile_data   =  0;
    $graph_num        = -1;
    $savefile         = "";
    $global_dt_limits =  0;
    $global_dt_begin  = $global_dt_end = "na";
    $anim_tb_status   = "stopped";
    $delay_autosave   =  0;
    $delta_dti        =  1;
    $export_menu->entryconfigure(3, -state => 'disabled');
    $pref_menu->entryconfigure(0,   -state => 'disabled');

#   Kill any open pop-up menus that might be tied to old objects
#   Reset the general and canvas defaults
    &remove_and_restore_menus();

#   Reset canvas to defaults
    $canvas->configure(-background   => &get_rgb_code($default_canvas_color),
                       -width        => $default_canvas_width,
                       -height       => $default_canvas_height,
                       -scrollregion => [0, 0, $default_canvas_width, $default_canvas_height],
                      );
    &initialize_canvas_scrollbars();
    &adjust_main_position();

#   Clear the title bar of any file name
    $main->g_wm_title("W2 Animator");
}


sub remove_and_restore_menus {

    $canvas_width      = $default_canvas_width;
    $canvas_height     = $default_canvas_height;
    $canvas_color      = $default_canvas_color;
    $snap2grid         = $default_snap2grid;
    $grid_spacing      = $default_grid_spacing;
    $text_select_color = $default_text_select_color;

    $default_family    = $save_family;
    $default_size      = $save_size;
    $default_weight    = $save_weight;
    $default_slant     = $save_slant;
    $default_underline = $save_underline;
    $default_angle     = $save_angle;
    $default_width     = $save_width;
    $default_color     = $save_color;
    $default_smooth    = $save_smooth;
    $default_fill      = $save_fill;
    $default_fillcolor = $save_fillcolor;
    $default_arrow     = $save_arrow;
    $default_ahd1      = $save_ahd1;
    $default_ahd2      = $save_ahd2;
    $default_ahd3      = $save_ahd3;

    if (defined($default_props_menu) && Tkx::winfo_exists($default_props_menu)) {
        if ($default_props_menu->g_wm_title() eq "Set Defaults") {
            $default_props_menu->g_destroy();
            undef $default_props_menu;
        }
    }
    if (defined($canvas_props_menu) && Tkx::winfo_exists($canvas_props_menu)) {
        if ($canvas_props_menu->g_wm_title() eq "Canvas Properties") {
            $canvas_props_menu->g_destroy();
            undef $canvas_props_menu;
        }
    }
    if (defined($date_limits_menu) && Tkx::winfo_exists($date_limits_menu)) {
        if ($date_limits_menu->g_wm_title() eq "Global Date Limits") {
            $date_limits_menu->g_destroy();
            undef $date_limits_menu;
        }
    }
    if (defined($animate_tb) && Tkx::winfo_exists($animate_tb)) {
        if ($animate_tb->g_wm_title() eq "Animation toolbar") {
            $animate_tb->g_destroy();
            undef $animate_tb;
        }
    }
    if (defined($zoom_tb) && Tkx::winfo_exists($zoom_tb)) {
        if ($zoom_tb->g_wm_title() eq "Zoom toolbar") {
            $zoom_tb->g_destroy();
            undef $zoom_tb;
        }
    }
    if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
        if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
            $graph_props_menu->g_destroy();
            undef $graph_props_menu;
        }
    }
    if (defined($w2profile_setup_menu) && Tkx::winfo_exists($w2profile_setup_menu)) {
        if ($w2profile_setup_menu->g_wm_title() eq "W2 Profile Setup") {
            $w2profile_setup_menu->g_destroy();
            undef $w2profile_setup_menu;
        }
    }
    if (defined($w2profile_mod_menu) && Tkx::winfo_exists($w2profile_mod_menu)) {
        if ($w2profile_mod_menu->g_wm_title() eq "Modify W2 Profile") {
            $w2profile_mod_menu->g_destroy();
            undef $w2profile_mod_menu;
        }
    }
    if (defined($w2profile_matrix_menu) && Tkx::winfo_exists($w2profile_matrix_menu)) {
        if ($w2profile_matrix_menu->g_wm_title() eq "Add or Edit W2 Profile Matrix") {
            $w2profile_matrix_menu->g_destroy();
            undef $w2profile_matrix_menu;
        }
    }
    if (defined($w2slice_setup_menu) && Tkx::winfo_exists($w2slice_setup_menu)) {
        if ($w2slice_setup_menu->g_wm_title() eq "W2 Longitudinal Slice Setup"
             || $w2slice_setup_menu->g_wm_title() eq "W2 Time/Distance Map Setup"
             || $w2slice_setup_menu->g_wm_title() eq "W2 Water Levels Graph Setup") {
            $w2slice_setup_menu->g_destroy();
            undef $w2slice_setup_menu;
        }
    }
    if (defined($w2slice_mod_menu) && Tkx::winfo_exists($w2slice_mod_menu)) {
        if ($w2slice_mod_menu->g_wm_title() eq "Modify W2 Longitudinal Slice") {
            $w2slice_mod_menu->g_destroy();
            undef $w2slice_mod_menu;
        }
    }
    if (defined($w2tdmap_setup_menu) && Tkx::winfo_exists($w2tdmap_setup_menu)) {
        if ($w2tdmap_setup_menu->g_wm_title() eq "W2 Time/Distance Map Setup") {
            $w2tdmap_setup_menu->g_destroy();
            undef $w2tdmap_setup_menu;
        }
    }
    if (defined($w2tdmap_diff_menu) && Tkx::winfo_exists($w2tdmap_diff_menu)) {
        if ($w2tdmap_diff_menu->g_wm_title() eq "W2 Time/Distance Difference Setup") {
            $w2tdmap_diff_menu->g_destroy();
            undef $w2tdmap_diff_menu;
        }
    }
    if (defined($w2tdmap_mod_menu) && Tkx::winfo_exists($w2tdmap_mod_menu)) {
        if ($w2tdmap_mod_menu->g_wm_title() eq "Modify W2 Time/Distance Map") {
            $w2tdmap_mod_menu->g_destroy();
            undef $w2tdmap_mod_menu;
        }
    }
    if (defined($w2tdmap_undo_menu) && Tkx::winfo_exists($w2tdmap_undo_menu)) {
        if ($w2tdmap_undo_menu->g_wm_title() eq "W2 Time/Distance Map - Undo Difference") {
            $w2tdmap_undo_menu->g_destroy();
            undef $w2tdmap_undo_menu;
        }
    }
    if (defined($w2tdmap_rev_menu) && Tkx::winfo_exists($w2tdmap_rev_menu)) {
        if ($w2tdmap_rev_menu->g_wm_title() eq "W2 Time/Distance Map - Reverse Difference") {
            $w2tdmap_rev_menu->g_destroy();
            undef $w2tdmap_rev_menu;
        }
    }
    if (defined($profile_setup_menu) && Tkx::winfo_exists($profile_setup_menu)) {
        if ($profile_setup_menu->g_wm_title() eq "Profile Setup") {
            $profile_setup_menu->g_destroy();
            undef $profile_setup_menu;
        }
    }
    if (defined($wdzone_setup_menu) && Tkx::winfo_exists($wdzone_setup_menu)) {
        if ($wdzone_setup_menu->g_wm_title() eq "Withdrawal Zone Setup") {
            $wdzone_setup_menu->g_destroy();
            undef $wdzone_setup_menu;
        }
    }
    if (defined($w2outflow_setup_menu) && Tkx::winfo_exists($w2outflow_setup_menu)) {
        if ($w2outflow_setup_menu->g_wm_title() eq "W2 Layer Outflows Setup") {
            $w2outflow_setup_menu->g_destroy();
            undef $w2outflow_setup_menu;
        }
    }
    if (defined($w2levels_setup_menu) && Tkx::winfo_exists($w2levels_setup_menu)) {
        if ($w2levels_setup_menu->g_wm_title() eq "W2 Water Levels Graph Setup"
             || $w2levels_setup_menu->g_wm_title() eq "Modify W2 Water Levels Graph") {
            $w2levels_setup_menu->g_destroy();
            undef $w2levels_setup_menu;
        }
    }
    if (defined($text_props_menu) && Tkx::winfo_exists($text_props_menu)) {
        if ($text_props_menu->g_wm_title() eq "Text Properties") {
            $text_props_menu->g_destroy();
            undef $text_props_menu;
        }
    }
    if (defined($object_props_menu) && Tkx::winfo_exists($object_props_menu)) {
        if ($object_props_menu->g_wm_title() eq "Object Properties") {
            $object_props_menu->g_destroy();
            undef $object_props_menu;
        }
    }
    if (defined($edit_link_menu) && Tkx::winfo_exists($edit_link_menu)) {
        if ($edit_link_menu->g_wm_title() eq "Add or Edit Link") {
            $edit_link_menu->g_destroy();
            undef $edit_link_menu;
        }
    }
    if (defined($edit_stat_link_menu) && Tkx::winfo_exists($edit_stat_link_menu)) {
        if ($edit_stat_link_menu->g_wm_title() eq "Add or Edit Goodness-of-Fit Link") {
            $edit_stat_link_menu->g_destroy();
            undef $edit_stat_link_menu;
        }
    }
    if (defined($edit_matrix_stat_menu) && Tkx::winfo_exists($edit_matrix_stat_menu)) {
        if ($edit_matrix_stat_menu->g_wm_title() eq "Add or Edit Matrix Fit Statistics") {
            $edit_matrix_stat_menu->g_destroy();
            undef $edit_matrix_stat_menu;
        }
    }
    if (defined($edit_ind_link_menu) && Tkx::winfo_exists($edit_ind_link_menu)) {
        if ($edit_ind_link_menu->g_wm_title() eq "Add or Edit Independent Link") {
            $edit_ind_link_menu->g_destroy();
            undef $edit_ind_link_menu;
        }
    }
    if (defined($add_ts_link_menu) && Tkx::winfo_exists($add_ts_link_menu)) {
        if ($add_ts_link_menu->g_wm_title() eq "Add Time Series Link") {
            $add_ts_link_menu->g_destroy();
            undef $add_ts_link_menu;
        }
    }
    if (defined($add_ts_data_menu) && Tkx::winfo_exists($add_ts_data_menu)) {
        if ($add_ts_data_menu->g_wm_title() eq "Add Time Series Data") {
            $add_ts_data_menu->g_destroy();
            undef $add_ts_data_menu;
        }
    }
    if (defined($add_ts_graph_menu) && Tkx::winfo_exists($add_ts_graph_menu)) {
        if ($add_ts_graph_menu->g_wm_title() eq "Add Time Series Graph") {
            $add_ts_graph_menu->g_destroy();
            undef $add_ts_graph_menu;
        }
    }
    if (defined($add_ref_data_menu) && Tkx::winfo_exists($add_ref_data_menu)) {
        if ($add_ref_data_menu->g_wm_title() eq "Add Reference Profile Data") {
            $add_ref_data_menu->g_destroy();
            undef $add_ref_data_menu;
        }
    }
    if (defined($ref_stats_menu) && Tkx::winfo_exists($ref_stats_menu)) {
        if ($ref_stats_menu->g_wm_title() eq "Choose Profile Fit Statistics") {
            $ref_stats_menu->g_destroy();
            undef $ref_stats_menu;
        }
    }
    if (defined($ref_stats_window) && Tkx::winfo_exists($ref_stats_window)) {
        if ($ref_stats_window->g_wm_title() eq "Profile Goodness-of-Fit Statistics") {
            $ref_stats_window->g_destroy();
            undef $ref_stats_window;
        }
    }
    if (defined($ref_stats_interp_window) && Tkx::winfo_exists($ref_stats_interp_window)) {
        if ($ref_stats_interp_window->g_wm_title()
                eq "Profile Goodness-of-Fit Statistics (Vertically Interpolated)") {
            $ref_stats_interp_window->g_destroy();
            undef $ref_stats_interp_window;
        }
    }
    if (defined($convert_diff_menu) && Tkx::winfo_exists($convert_diff_menu)) {
        if ($convert_diff_menu->g_wm_title() eq "Convert to Difference") {
            $convert_diff_menu->g_destroy();
            undef $convert_diff_menu;
        }
    }
    if (defined($undo_diff_menu) && Tkx::winfo_exists($undo_diff_menu)) {
        if ($undo_diff_menu->g_wm_title() eq "Undo Difference") {
            $undo_diff_menu->g_destroy();
            undef $undo_diff_menu;
        }
    }
    if (defined($object_infobox) && Tkx::winfo_exists($object_infobox)) {
        if ($object_infobox->g_wm_title() =~ /Object Info/) {
            $object_infobox->g_destroy();
            undef $object_infobox;
        }
    }
    if (defined($choose_sets_menu) && Tkx::winfo_exists($choose_sets_menu)) {
        if ($choose_sets_menu->g_wm_title() eq "Choose Datasets for Fit Statistics") {
            $choose_sets_menu->g_destroy();
            undef $choose_sets_menu;
        }
    }
    if (defined($ts_stats_window) && Tkx::winfo_exists($ts_stats_window)) {
        if ($ts_stats_window->g_wm_title() eq "TS Goodness-of-Fit Statistics") {
            $ts_stats_window->g_destroy();
            undef $ts_stats_window;
        }
    }
    if (defined($scale_output_menu) && Tkx::winfo_exists($scale_output_menu)) {
        if ($scale_output_menu->g_wm_title() eq "Select and Scale Output") {
            $scale_output_menu->g_destroy();
            undef $scale_output_menu;
        }
    }
    if (defined($configure_helper_menu) && Tkx::winfo_exists($configure_helper_menu)) {
        if ($configure_helper_menu->g_wm_title() eq "Configure Helper Apps") {
            $configure_helper_menu->g_destroy();
            undef $configure_helper_menu;
        }
    }
    if (defined($helper_note_win) && Tkx::winfo_exists($helper_note_win)) {
        if ($helper_note_win->g_wm_title() eq "Helper Program Problem") {
            $helper_note_win->g_destroy();
            undef $helper_note_win;
        }
    }
    if (defined($helper_search_win) && Tkx::winfo_exists($helper_search_win)) {
        if ($helper_search_win->g_wm_title() eq "Helper Program AutoSearch") {
            $helper_search_win->g_destroy();
            undef $helper_search_win;
        }
    }
}


sub create_progress_bar {
    my ($parent, $obj_id, $pbar_length, $pbar_max, $title) = @_;
    my ($geom, $height, $pbar, $pbar_frame, $pbar_window, $width, $X, $x1,
        $x2, $Y, $y1, $y2);

#   Get placement geometry
    $geom = $parent->g_wm_geometry();
    ($width, $height, $X, $Y) = split(/x|\+/, $geom);
    if ($obj_id == 0) {
        $geom = sprintf("+%d+%d", $X+$width/2-($pbar_length/2), $Y+$height/2);
    } else {
        ($x1, $y1, $x2, $y2) = @{ $props{$obj_id}{coordlist} };
        $geom = sprintf("+%d+%d", $X+($x1+$x2)/2-($pbar_length/2), $Y+($y1+$y2)/2);
    }

#   Create progress bar and its toplevel window
    $pbar_window = $parent->new_toplevel();
    $pbar_window->g_wm_transient($parent);
    $pbar_window->g_wm_title($title);
    $pbar_window->g_wm_geometry($geom);
    $pbar_window->configure(-cursor => $cursor_wait);
    $pbar_window->g_focus;

    ($pbar_frame = $pbar_window->new_frame(
                        -borderwidth => 2,
                        -relief      => 'groove',
                   ))->g_pack(-anchor => 'nw', -expand => 1, -fill => 'x');
    ($pbar = $pbar_frame->new_ttk__progressbar(
                        -orient  => 'horizontal',
                        -length  => $pbar_length,
                        -mode    => 'determinate',
                        -value   => 0,
                        -maximum => $pbar_max,
                     ))->g_pack();

#   Initialize status line and place a busy hold on the parent window
    $status_line = $title . " line 1";
    Tkx::tk_busy_hold($parent, -cursor => $cursor_wait);
    Tkx::update();
    Tkx::wm_resizable($pbar_window,0,0);

    return ($pbar_window, $pbar);
}


sub update_progress_bar {
    my ($pbar, $val, $dt) = @_;

    $pbar->configure(-value => $val);
    if (defined($dt)) {
        $status_line =~ s/ \d+$/ $dt/;
    } else {
        $status_line =~ s/ \d+$/ $val/;
    }
    Tkx::update_idletasks();
}


sub reset_progress_bar {
    my ($pbar, $pbar_max, $txt) = @_;

    $pbar->configure(-value   => 0,
                     -maximum => $pbar_max);
    $status_line = $txt;
    Tkx::update_idletasks();
}


sub destroy_progress_bar {
    my ($parent, $pbar_window) = @_;

    $pbar_window->g_destroy();
    $status_line = "";
    Tkx::tk_busy_forget($parent);
    Tkx::update();
}


{
    my ($gif_frames);

    sub create_alt_progress_bar {
        my ($parent, $obj_id, $title) = @_;
        my (
            $geom, $pbar, $pbar_frame, $pbar_img, $pbar_window, $X, $x1, $x2, $Y,
            $y1, $y2,
            );

        $gif_frames = 80;

#       Get placement geometry
        $geom = $parent->g_wm_geometry();
        (undef, $X, $Y) = split(/\+/, $geom);
        ($x1, $y1, $x2, $y2) = @{ $props{$obj_id}{coordlist} };
        $geom = sprintf("+%d+%d", $X+($x1+$x2)/2-175, $Y+($y1+$y2)/2);

#       Create progress bar and its toplevel window
        $pbar_window = $parent->new_toplevel();
        $pbar_window->g_wm_transient($parent);
        $pbar_window->g_wm_title($title);
        $pbar_window->g_wm_geometry($geom);
        $pbar_window->configure(-cursor => $cursor_wait);
        $pbar_window->g_focus;

        ($pbar_frame = $pbar_window->new_frame(
                            -borderwidth => 2,
                            -relief      => 'groove',
                       ))->g_pack(-anchor => 'nw', -expand => 1, -fill => 'x');

        $pbar_img = Tkx::image_create_photo(-file   => "${prog_path}images/pbar.gif",
                                            -format => "gif -index 0");
        $pbar_img = Tkx::widget->new($pbar_img);
        ($pbar = $pbar_frame->new_label(-image => $pbar_img,
                                        ))->g_pack(-side => 'left');

#       Initialize status line and place a busy hold on the parent window
        $status_line = $title . " line 1";
        Tkx::tk_busy_hold($parent, -cursor => $cursor_wait);
        Tkx::update();
        Tkx::wm_resizable($pbar_window,0,0);

        return ($pbar_window, $pbar, $pbar_img);
    }

    sub update_alt_progress_bar {
        my ($img, $val, $nf) = @_;

        $nf = ($nf < $gif_frames-1) ? $nf+1 : 0;
        $img->configure(-format => "gif -index $nf");
        $status_line =~ s/ \d+$/ $val/;
        Tkx::update_idletasks();

        return $nf;
    }
}


################################################################################
#
# Object drawing, moving, and rotation
#
################################################################################

sub draw {
    my ($type, $meta) = @_;

    &forget_drawing('');

    $meta = "" if (! defined($meta));
    $canvas->g_bind("<Motion>",   "");
    $canvas->g_bind("<Motion>",   [ \&show_xypos,    Tkx::Ev("%x","%y"),           $canvas, 0 ]);
    $canvas->g_bind("<Button-1>", [ \&start_drawing, Tkx::Ev("%X","%Y","%x","%y"), $canvas, $type, $meta ]);
    $canvas->g_bind("<Button-3>", [ \&forget_drawing, '' ]);
    if ($type eq "text") {
        $canvas->configure(-cursor => $cursor_text);
    } else {
        $canvas->configure(-cursor => $cursor_draw);
    }
}


sub start_drawing {
    my ($X, $Y, $x, $y, $canv, $type, $meta) = @_;
    my ($id);

    ($x, $y) = &get_xy($canv, $x, $y, $snap2grid);
    $canv->delete("target");

    if ($type eq "line") {
        $id = $canv->create_line($x, $y, $x, $y,
                 -fill       => &get_rgb_code($default_color),
                 -width      => $default_width,
                 -arrow      => $arrow_type[$default_arrow],
                 -arrowshape => [ $default_ahd1, $default_ahd2, $default_ahd3 ],
                 -tags       => "working");
        $props{$id}{type}      = $type;
        $props{$id}{x}         = $x;
        $props{$id}{y}         = $y;
        $props{$id}{xc}        = $x;
        $props{$id}{yc}        = $y;
        $props{$id}{anchor}    = 'point';
        $props{$id}{coordlist} = [$x, $y, $x, $y];
        $props{$id}{color}     = $default_color;
        $props{$id}{width}     = $default_width;
        $props{$id}{arrow}     = $default_arrow;
        $props{$id}{ahd1}      = $default_ahd1;
        $props{$id}{ahd2}      = $default_ahd2;
        $props{$id}{ahd3}      = $default_ahd3;

    } elsif ($type eq "circle") {
        $id = $canv->create_oval($x, $y, $x, $y,
                 -outline => &get_rgb_code($default_color),
                 -width   => $default_width,
                 -tags    => "working");
        if ($default_fill) {
            $canv->itemconfigure($id, -fill => &get_rgb_code($default_fillcolor));
        } else {
            $canv->itemconfigure($id, -fill => "");
        }
        $props{$id}{type}      = $type;
        $props{$id}{x}         = $x;
        $props{$id}{y}         = $y;
        $props{$id}{xc}        = $x;
        $props{$id}{yc}        = $y;
        $props{$id}{anchor}    = 'corner';
        $props{$id}{coordlist} = [$x, $y, $x, $y];
        $props{$id}{color}     = $default_color;
        $props{$id}{width}     = $default_width;
        $props{$id}{fill}      = $default_fill;
        $props{$id}{fillcolor} = $default_fillcolor;

    } elsif ($type eq "ellipse") {
        $id = $canv->create_polygon($x, $y, $x, $y, $x, $y,
                 -outline => &get_rgb_code($default_color),
                 -width   => $default_width,
                 -smooth  => 'false',
                 -tags    => "working");
        if ($default_fill) {
            $canv->itemconfigure($id, -fill => &get_rgb_code($default_fillcolor));
        } else {
            $canv->itemconfigure($id, -fill => "");
        }
        $props{$id}{type}      = $type;
        $props{$id}{x}         = $x;
        $props{$id}{y}         = $y;
        $props{$id}{xc}        = $x;
        $props{$id}{yc}        = $y;
        $props{$id}{anchor}    = 'corner';
        $props{$id}{coordlist} = [$x, $y, $x, $y, $x, $y];
        $props{$id}{color}     = $default_color;
        $props{$id}{width}     = $default_width;
        $props{$id}{fill}      = $default_fill;
        $props{$id}{fillcolor} = $default_fillcolor;
        $props{$id}{angle}     = $default_angle;
        $props{$id}{angle_tmp} = $default_angle;
        $props{$id}{smooth}    = 0;

    } elsif ($type eq "rectangle") {
        $id = $canv->create_polygon($x, $y, $x+1, $y, $x+1, $y+1, $x, $y+1,
                 -outline => &get_rgb_code($default_color),
                 -width   => $default_width,
                 -smooth  => $smooth_type[$default_smooth],
                 -tags    => "working");
        if ($default_fill) {
            $canv->itemconfigure($id, -fill => &get_rgb_code($default_fillcolor));
        } else {
            $canv->itemconfigure($id, -fill => "");
        }
        $props{$id}{type}      = $type;
        $props{$id}{x}         = $x;
        $props{$id}{y}         = $y;
        $props{$id}{xc}        = $x;
        $props{$id}{yc}        = $y;
        $props{$id}{anchor}    = 'corner';
        $props{$id}{coordlist} = [$x, $y, $x+1, $y, $x+1, $y+1, $x, $y+1];
        $props{$id}{color}     = $default_color;
        $props{$id}{width}     = $default_width;
        $props{$id}{fill}      = $default_fill;
        $props{$id}{fillcolor} = $default_fillcolor;
        $props{$id}{angle}     = $default_angle;
        $props{$id}{angle_tmp} = $default_angle;
        $props{$id}{smooth}    = $default_smooth;

    } elsif ($type eq "diamond") {
        $id = $canv->create_polygon($x, $y, $x+1, $y+1, $x, $y+2, $x-1, $y+1,
                 -outline => &get_rgb_code($default_color),
                 -width   => $default_width,
                 -smooth  => $smooth_type[$default_smooth],
                 -tags    => "working");
        if ($default_fill) {
            $canv->itemconfigure($id, -fill => &get_rgb_code($default_fillcolor));
        } else {
            $canv->itemconfigure($id, -fill => "");
        }
        $props{$id}{type}      = $type;
        $props{$id}{x}         = $x;
        $props{$id}{y}         = $y;
        $props{$id}{xc}        = $x;
        $props{$id}{yc}        = $y;
        $props{$id}{anchor}    = 'corner';
        $props{$id}{coordlist} = [$x, $y, $x+1, $y, $x+1, $y+1, $x, $y+1];
        $props{$id}{color}     = $default_color;
        $props{$id}{width}     = $default_width;
        $props{$id}{fill}      = $default_fill;
        $props{$id}{fillcolor} = $default_fillcolor;
        $props{$id}{angle}     = $default_angle;
        $props{$id}{angle_tmp} = $default_angle;
        $props{$id}{smooth}    = $default_smooth;

    } elsif ($type eq "polygon") {
        $id = $canv->create_line($x, $y, $x, $y,
                 -fill  => &get_rgb_code($default_color),
                 -width => $default_width,
                 -arrow => 'none',
                 -tags  => "working");
        $props{$id}{type}      = $type;
        $props{$id}{x}         = $x;
        $props{$id}{y}         = $y;
        $props{$id}{xc}        = $x;
        $props{$id}{yc}        = $y;
        $props{$id}{xc_rot}    = $x;
        $props{$id}{yc_rot}    = $y;
        $props{$id}{anchor}    = 'point';
        $props{$id}{coordlist} = [$x, $y, $x, $y];
        $props{$id}{color}     = $default_color;
        $props{$id}{width}     = $default_width;
        $props{$id}{fill}      = $default_fill;
        $props{$id}{fillcolor} = $default_fillcolor;
        $props{$id}{angle}     = $default_angle;
        $props{$id}{angle_tmp} = $default_angle;

    } elsif ($type eq "polyline") {
        $id = $canv->create_line($x, $y, $x, $y,
                 -fill       => &get_rgb_code($default_color),
                 -width      => $default_width,
                 -arrow      => $arrow_type[$default_arrow],
                 -arrowshape => [ $default_ahd1, $default_ahd2, $default_ahd3 ],
                 -tags       => "working");
        $props{$id}{type}      = $type;
        $props{$id}{x}         = $x;
        $props{$id}{y}         = $y;
        $props{$id}{xc}        = $x;
        $props{$id}{yc}        = $y;
        $props{$id}{xc_rot}    = $x;
        $props{$id}{yc_rot}    = $y;
        $props{$id}{anchor}    = 'point';
        $props{$id}{coordlist} = [$x, $y, $x, $y];
        $props{$id}{color}     = $default_color;
        $props{$id}{width}     = $default_width;
        $props{$id}{arrow}     = $default_arrow;
        $props{$id}{ahd1}      = $default_ahd1;
        $props{$id}{ahd2}      = $default_ahd2;
        $props{$id}{ahd3}      = $default_ahd3;
        $props{$id}{angle}     = $default_angle;
        $props{$id}{angle_tmp} = $default_angle;

    } elsif ($type eq "text") {
        $id = $canv->create_text($x, $y,
                 -anchor => 'w', 
                 -text   => "add text",
                 -fill   => &get_rgb_code($default_color),
                 -angle  => $default_angle,
                 -font   => [-family     => $default_family,
                             -size       => $default_size,
                             -weight     => $default_weight,
                             -slant      => $slant_type[$default_slant],
                             -underline  => $default_underline,
                             -overstrike => 0,
                            ]);
        $props{$id}{type}      = $type;
        $props{$id}{text}      = "add text";
        $props{$id}{x}         = $x;
        $props{$id}{y}         = $y;
        $props{$id}{xc}        = $x;
        $props{$id}{yc}        = $y;
        $props{$id}{anchor}    = 'w';
        $props{$id}{coordlist} = [$x, $y];
        $props{$id}{color}     = $default_color;
        $props{$id}{family}    = $default_family;
        $props{$id}{size}      = $default_size;
        $props{$id}{weight}    = $default_weight;
        $props{$id}{slant}     = $default_slant;
        $props{$id}{underline} = $default_underline;
        $props{$id}{angle}     = $default_angle;
        &reset_bindings;
        &edit_text_props($id, $X, $Y);
        return;

    } elsif ($type eq "graph") {
        $id = $canv->create_rectangle($x, $y, $x, $y,
                 -outline => &get_rgb_code($default_color),
                 -width   => 1,
                 -fill    => "",
                 -tags    => "working");
        $props{$id}{type}      = "graph";
        $props{$id}{meta}      = $meta;
        $props{$id}{x}         = $x;
        $props{$id}{y}         = $y;
        $props{$id}{xc}        = $x;
        $props{$id}{yc}        = $y;
        $props{$id}{anchor}    = 'corner';
        $props{$id}{coordlist} = [$x, $y, $x, $y];
        $props{$id}{color}     = $default_color;
        $props{$id}{width}     = $default_width;
        $props{$id}{fill}      = 0;
        $canv->addtag("graph" . $id, withtag => $id);

    } else {
        &reset_bindings;
        return;
    }

    $canv->create_rectangle($x-2, $y-2, $x+2, $y+2,
                 -outline => &get_rgb_code($anchor_line_color),
                 -width   => 1,
                 -fill    => &get_rgb_code($anchor_select_color),
                 -tags    => "anchor");

    if ($type =~ /^(rectangle|diamond|ellipse)$/) {
        $canv->g_bind("<Shift-Motion>",   [ \&size_rde,    Tkx::Ev("%x","%y"), $canv, $x, $y, $id, 1 ]);
        $canv->g_bind("<Motion>",         [ \&size_rde,    Tkx::Ev("%x","%y"), $canv, $x, $y, $id, 0 ]);
        $canv->g_bind("<Button-1>",       [ \&end_drawing, Tkx::Ev("%x","%y"), $canv, $x, $y, $id ]);

    } elsif ($type =~ /^(polygon|polyline)$/) {
        $canv->g_bind("<Shift-Motion>",   [ \&next_pt,  Tkx::Ev("%x","%y"), $canv, $x, $y, $id, 1 ]);
        $canv->g_bind("<Motion>",         [ \&next_pt,  Tkx::Ev("%x","%y"), $canv, $x, $y, $id, 0 ]);
        $canv->g_bind("<Shift-Button-1>", [ \&add_pt,   Tkx::Ev("%x","%y"), $canv, $x, $y, $id, 1 ]);
        $canv->g_bind("<Button-1>",       [ \&add_pt,   Tkx::Ev("%x","%y"), $canv, $x, $y, $id, 0 ]);
        $canv->g_bind("<Double-Button-1>",[ \&end_poly, Tkx::Ev("%x","%y"), $canv, $id ]);

    } else {
        $canv->g_bind("<Shift-Motion>", [ \&size_object, Tkx::Ev("%x","%y"), $canv, $x, $y, $id, 1 ]);
        $canv->g_bind("<Motion>",       [ \&size_object, Tkx::Ev("%x","%y"), $canv, $x, $y, $id, 0 ]);
        $canv->g_bind("<Button-1>",     [ \&end_drawing, Tkx::Ev("%x","%y"), $canv, $x, $y, $id ]);
    }
    $canv->g_bind("<Button-3>", [ \&forget_drawing, $id ]);
}


sub begin_resize {
    my ($canv, $id) = @_;
    my ($type, $xo, $yo);

    &end_select($canv, $id, 1);

    $type = $props{$id}{type};
    $xo   = $props{$id}{x};
    $yo   = $props{$id}{y};
    $canv->configure(-cursor => $cursor_draw);

    if ($type !~ /^(circle|line|graph)$/) {
        &make_crosshair($xo, $yo, $canv, $props{$id}{angle});
    } elsif ($type eq "graph") {
        $canv->itemconfigure($id, -state => 'normal') if ($props{$id}{meta} eq "w2_profile_matrix");
    }
    $canv->create_rectangle($xo-2, $yo-2, $xo+2, $yo+2,
                 -outline => &get_rgb_code($anchor_line_color),
                 -width   => 1,
                 -fill    => &get_rgb_code($anchor_select_color),
                 -tags    => "anchor");

    if ($type =~ /^(rectangle|diamond|ellipse)$/) {
        $canv->g_bind("<Control-Shift-Motion>",
                                          [ \&size_rde, Tkx::Ev("%x","%y"), $canv, $xo, $yo, $id, 3 ]);
        $canv->g_bind("<Control-Motion>", [ \&size_rde, Tkx::Ev("%x","%y"), $canv, $xo, $yo, $id, 2 ]);
        $canv->g_bind("<Shift-Motion>",   [ \&size_rde, Tkx::Ev("%x","%y"), $canv, $xo, $yo, $id, 1 ]);
        $canv->g_bind("<Motion>",         [ \&size_rde, Tkx::Ev("%x","%y"), $canv, $xo, $yo, $id, 0 ]);

    } elsif ($type =~ /^(polygon|polyline)$/) {
        $canv->g_bind("<Control-Shift-Motion>",
                                          [ \&size_poly, Tkx::Ev("%x","%y"), $canv, $xo, $yo, $id, 3 ]);
        $canv->g_bind("<Control-Motion>", [ \&size_poly, Tkx::Ev("%x","%y"), $canv, $xo, $yo, $id, 2 ]);
        $canv->g_bind("<Shift-Motion>",   [ \&size_poly, Tkx::Ev("%x","%y"), $canv, $xo, $yo, $id, 1 ]);
        $canv->g_bind("<Motion>",         [ \&size_poly, Tkx::Ev("%x","%y"), $canv, $xo, $yo, $id, 0 ]);

    } else {
        $canv->g_bind("<Shift-Motion>", [ \&size_object, Tkx::Ev("%x","%y"), $canv, $xo, $yo, $id, 1 ]);
        $canv->g_bind("<Motion>",       [ \&size_object, Tkx::Ev("%x","%y"), $canv, $xo, $yo, $id, 0 ]);
    }
    $canv->g_bind("<Button-1>",   [ \&end_drawing, Tkx::Ev("%x","%y"), $canv, $xo, $yo, $id ]);
    $canv->g_bind("<Button-3>",   [ \&forget_resize, $canv, $id ]);
}


sub size_rde {         # rde: rectangle, diamond, ellipse
    my ($x, $y, $canv, $xo, $yo, $id, $keys) = @_;
    my ($ang, $ang2, $ang3, $angc, $ctrl, $dx, $dy, $h, $hc, $hh, $hw,
        $shft, $snap, $type, $xc, $xct, $yc, $yct,
        @coords,
       );

    $ctrl = ($keys == 2 || $keys == 3) ? 1 : 0;
    $shft = ($keys == 1 || $keys == 3) ? 1 : 0;
    $type = $props{$id}{type};
    $ang  = $props{$id}{angle};
    $snap = ($ang % 90 == 0 || $ctrl) ? 1 : 0;

    ($x, $y) = &get_xy($canv, $x, $y, $snap);

    if ($ang != 0 && $type =~ /^(ellipse|rectangle|diamond)$/) {
        if ($ctrl) {
            $ang = 0;
            if ($props{$id}{angle_tmp} != 0) {
                $props{$id}{angle_tmp} = 0;
                &make_crosshair($xo, $yo, $canv, $ang);
            }
        } elsif ($props{$id}{angle_tmp} != $props{$id}{angle}) {
            $props{$id}{angle_tmp} = $props{$id}{angle};
            &make_crosshair($xo, $yo, $canv, $ang);
        }
    }

    if ($ang % 90 == 0) {     # mod ok, ang already an integer
        if ($shft) {
            if (abs($x-$xo) < abs($y-$yo)) {
                $y = ($y > $yo) ? $yo + abs($x-$xo) : $yo - abs($x-$xo);
            } else {
                $x = ($x > $xo) ? $xo + abs($y-$yo) : $xo - abs($y-$yo);
            }
        }
        $hw = abs($x - $xo)/2.;
        $hh = abs($y - $yo)/2.;

        if ($props{$id}{anchor} eq 'midpoint') {
            if ($ctrl) {
                $xc = $props{$id}{xc};
                $yc = $props{$id}{yc};
                if ($xc == $xo) {
                    if ($yc == $yo) {
                        $angc = 0;
                    } else {
                        $angc = ($yc > $yo) ? 270 : 90;
                    }
                } elsif ($yc == $yo) {
                    $angc = ($xc > $xo) ? 0 : 180;
                } else {
                    $angc = (180./pi)*atan2(($yo-$yc),($xc-$xo));
                }
                $angc = $angc - $props{$id}{angle} + 360;
                $hc   = sqrt(($xc-$xo)*($xc-$xo)+($yc-$yo)*($yc-$yo));
                $dx   = -$hc *cos($angc *pi/180.);
                $dy   =  $hc *sin($angc *pi/180.);
            } else {
                $dx = $xo - $props{$id}{xc};
                $dy = $yo - $props{$id}{yc};
            }
            if (abs($dx) < abs($dy)) {
                $xc  = $xo;
                $yc  = ($y + $yo)/2.;
                $hw *= 2. if (! $shft);
            } else {
                $xc  = ($x + $xo)/2.;
                $yc  = $yo;
                $hh *= 2. if (! $shft);
            }
        } elsif ($props{$id}{anchor} eq 'center') {
            $xc  = $xo;
            $yc  = $yo;
            $hw *= 2.;
            $hh *= 2.;
        } else {
            $xc = ($x + $xo)/2.;
            $yc = ($y + $yo)/2.;
        }

    } else {
        if ($x == $xo) {
            if ($y == $yo) {
                $ang2 = 0;
            } else {
                $ang2 = ($y > $yo) ? 270 : 90;
            }
        } elsif ($y == $yo) {
            $ang2 = ($x > $xo) ? 0 : 180;
        } else {
            $ang2 = (180./pi)*atan2(($yo-$y),($x-$xo));
        }
        $h  = sqrt(($x-$xo)*($x-$xo)+($y-$yo)*($y-$yo));
        $dx =  $h *cos(($ang2 -$ang) *pi/180.);
        $dy = -$h *sin(($ang2 -$ang) *pi/180.);

        if ($shft) {
            if ($dx != 0. || $dy != 0.) {
                if ($dx == 0.) {
                    $ang3 = (180./pi)*atan2(abs($dy),0.0001);
                    $ang3 = 90 - $ang3 if ($dy > 0);
                } else {
                    $ang3 = (180./pi)*atan2(abs($dy),abs($dx));
                    $ang3 = 90 - $ang3 if ($dx * $dy > 0);
                }
                if (abs($dx) <= abs($dy)) {
                    $dy = abs($dx) * $dy/abs($dy);
                } else {
                    $dx = abs($dy) * $dx/abs($dx);
                }
                $x = $xo +abs($dx) *sqrt(2.) *cos(($ang2 -$ang3 +45) *pi/180.);
                $y = $yo -abs($dx) *sqrt(2.) *sin(($ang2 -$ang3 +45) *pi/180.);
            }
        }
        $hw = abs($dx)/2.;
        $hh = abs($dy)/2.;

        if ($props{$id}{anchor} eq 'midpoint') {
            $xc = $props{$id}{xc};
            $yc = $props{$id}{yc};
            if ($xc == $xo) {
                if ($yc == $yo) {
                    $angc = 0;
                } else {
                    $angc = ($yc > $yo) ? 270 : 90;
                }
            } elsif ($yc == $yo) {
                $angc = ($xc > $xo) ? 0 : 180;
            } else {
                $angc = (180./pi)*atan2(($yo-$yc),($xc-$xo));
            }
            $angc = $angc - $ang + 360;
            $hc   = sqrt(($xc-$xo)*($xc-$xo)+($yc-$yo)*($yc-$yo));
            $xct  = $xo + $hc *cos($angc *pi/180.);
            $yct  = $yo - $hc *sin($angc *pi/180.);

            if (abs($xo - $xct) < abs($yo - $yct)) {
                $xc  = $xo +($dy/2.) *cos(($ang +270) *pi/180.);
                $yc  = $yo -($dy/2.) *sin(($ang +270) *pi/180.);
                $hw *= 2. if (! $shft);
            } else {
                $xc  = $xo +($dx/2.) *cos($ang *pi/180.);
                $yc  = $yo -($dx/2.) *sin($ang *pi/180.);
                $hh *= 2. if (! $shft);
            }
        } elsif ($props{$id}{anchor} eq 'center') {
            $xc  = $xo;
            $yc  = $yo;
            $hw *= 2.;
            $hh *= 2.;
        } else {
            $xc = ($x + $xo)/2.;
            $yc = ($y + $yo)/2.;
        }
    }
    if ($type eq "ellipse") {
        $props{$id}{hw_tmp} = $hw;
        $props{$id}{hh_tmp} = $hh;
    }
    @coords = &make_shape_coords($type, $xc, $yc, $hw, $hh, $ang);
    $canv->coords($id, @coords);
    $status_line = sprintf("X,Y,W,H: %d, %d, %d, %d", $x-3, $y-3, 2*$hw, 2*$hh);
}


sub size_poly {
    my ($x, $y, $canv, $xo, $yo, $id, $keys) = @_;
    my ($ang, $ang2, $ang3, $angc, $ctrl, $dx, $dy, $h, $hc, $shft, $snap,
        $xc, $xct, $xsameside, $xt, $yc, $yct, $ysameside, $yt,
        @coords,
       );

    $ctrl = ($keys == 2 || $keys == 3) ? 1 : 0;
    $shft = ($keys == 1 || $keys == 3) ? 1 : 0;
    $ang  = $props{$id}{angle};
    $snap = ($ang % 90 == 0 || $ctrl) ? 1 : 0;

    ($x, $y) = &get_xy($canv, $x, $y, $snap);

    if ($ang != 0) {
        if ($ctrl) {
            $ang = 0;
            if ($props{$id}{angle_tmp} != 0) {
                $props{$id}{angle_tmp} = 0;
                &make_crosshair($xo, $yo, $canv, $ang);
            }
        } elsif ($props{$id}{angle_tmp} != $props{$id}{angle}) {
            $props{$id}{angle_tmp} = $props{$id}{angle};
            &make_crosshair($xo, $yo, $canv, $ang);
        }
    }

    if ($ang == 0) {
        if ($shft) {
            if (abs($x-$xo) < abs($y-$yo)) {
                $y = ($y > $yo) ? $yo + abs($x-$xo) : $yo - abs($x-$xo);
            } else {
                $x = ($x > $xo) ? $xo + abs($y-$yo) : $xo - abs($y-$yo);
            }
        }
        $dx = $x - $xo;
        $dy = $y - $yo;

        $xc = $props{$id}{xc};
        $yc = $props{$id}{yc};
        if ($ctrl) {
            if ($xc == $xo) {
                if ($yc == $yo) {
                    $angc = 0;
                } else {
                    $angc = ($yc > $yo) ? 270 : 90;
                }
            } elsif ($yc == $yo) {
                $angc = ($xc > $xo) ? 0 : 180;
            } else {
                $angc = (180./pi)*atan2(($yo-$yc),($xc-$xo));
            }
            $angc = $angc - $props{$id}{angle} + 360;
            $hc   = sqrt(($xc-$xo)*($xc-$xo)+($yc-$yo)*($yc-$yo));
            $xct  = $xo +$hc *cos($angc *pi/180.);
            $yct  = $yo -$hc *sin($angc *pi/180.);
        } else {
            $xct = $xc;
            $yct = $yc;
        }
        $xsameside = (($x-$xo)*($xct-$xo) > 0) ? 1 : 0;
        $ysameside = (($y-$yo)*($yct-$yo) > 0) ? 1 : 0;

        if ($props{$id}{anchor} eq 'midpoint') {
            if (abs($xct-$xo) < abs($yct-$yo)) {
                $dx *= 2. if (! $shft);
                $dy *= -1 if (($ysameside && $dy < 0) || (! $ysameside && $dy > 0));
            } else {
                $dy *= 2. if (! $shft);
                $dx *= -1 if (($xsameside && $dx < 0) || (! $xsameside && $dx > 0));
            }
        } elsif ($props{$id}{anchor} =~ /^(center|center_rot)$/) {
            $dx *= 2.;
            $dy *= 2.;
        } else {
            $dx *= -1 if (($xsameside && $dx < 0) || (! $xsameside && $dx > 0));
            $dy *= -1 if (($ysameside && $dy < 0) || (! $ysameside && $dy > 0));
        }

    } else {
        if ($x == $xo) {
            if ($y == $yo) {
                $ang2 = 0;
            } else {
                $ang2 = ($y > $yo) ? 270 : 90;
            }
        } elsif ($y == $yo) {
            $ang2 = ($x > $xo) ? 0 : 180;
        } else {
            $ang2 = (180./pi)*atan2(($yo-$y),($x-$xo));
        }
        $h  = sqrt(($x-$xo)*($x-$xo)+($y-$yo)*($y-$yo));
        $dx =  $h *cos(($ang2 -$ang) *pi/180.);
        $dy = -$h *sin(($ang2 -$ang) *pi/180.);
        $xt = $xo + $dx;
        $yt = $yo + $dy;

        if ($shft) {
            if ($dx != 0. || $dy != 0.) {
                if ($dx == 0.) {
                    $ang3 = (180./pi)*atan2(abs($dy),0.0001);
                    $ang3 = 90 - $ang3 if ($dy > 0);
                } else {
                    $ang3 = (180./pi)*atan2(abs($dy),abs($dx));
                    $ang3 = 90 - $ang3 if ($dx * $dy > 0);
                }
                if (abs($dx) <= abs($dy)) {
                    $dy = abs($dx) * $dy/abs($dy);
                } else {
                    $dx = abs($dy) * $dx/abs($dx);
                }
                $x = $xo +abs($dx) *sqrt(2.) *cos(($ang2 -$ang3 +45) *pi/180.);
                $y = $yo -abs($dx) *sqrt(2.) *sin(($ang2 -$ang3 +45) *pi/180.);
            }
        }

        $xc = $props{$id}{xc};
        $yc = $props{$id}{yc};
        if ($xc == $xo) {
            if ($yc == $yo) {
                $angc = 0;
            } else {
                $angc = ($yc > $yo) ? 270 : 90;
            }
        } elsif ($yc == $yo) {
            $angc = ($xc > $xo) ? 0 : 180;
        } else {
            $angc = (180./pi)*atan2(($yo-$yc),($xc-$xo));
        }
        $angc = $angc - $ang + 360;
        $hc   = sqrt(($xc-$xo)*($xc-$xo)+($yc-$yo)*($yc-$yo));
        $xct  = $xo + $hc *cos($angc *pi/180.);
        $yct  = $yo - $hc *sin($angc *pi/180.);

        $xsameside = (($xt-$xo)*($xct-$xo) > 0) ? 1 : 0;
        $ysameside = (($yt-$yo)*($yct-$yo) > 0) ? 1 : 0;

        if ($props{$id}{anchor} eq 'midpoint') {
            if (abs($xo - $xct) < abs($yo - $yct)) {
                $dx *= 2. if (! $shft);
                $dy *= -1 if (($ysameside && $dy < 0) || (! $ysameside && $dy > 0));
            } else {
                $dy *= 2. if (! $shft);
                $dx *= -1 if (($xsameside && $dx < 0) || (! $xsameside && $dx > 0));
            }
        } elsif ($props{$id}{anchor} =~ /^(center|center_rot)$/) {
            $dx *= 2.;
            $dy *= 2.;
        } else {
            $dx *= -1 if (($xsameside && $dx < 0) || (! $xsameside && $dx > 0));
            $dy *= -1 if (($ysameside && $dy < 0) || (! $ysameside && $dy > 0));
        }
    }
    @coords = @{ $props{$id}{coordlist} };
    @coords = &resize_shape(\@coords, $props{$id}{angle}, $xo, $yo, $dx, $dy, $ang);
    $canv->coords($id, @coords);
    $status_line = sprintf("X,Y,W,H: %d, %d, %d, %d", $x-3, $y-3, abs($dx), abs($dy));
}


sub size_object {
    my ($x, $y, $canv, $xo, $yo, $id, $shift) = @_;
    my ($type, $dx, $dy, $xc, $yc);

    $type = $props{$id}{type};
    if ($type !~ /^(circle|line|graph)$/) {
        &reset_bindings;
        return;
    }
    $shift   = 0 if (! defined($shift) || $shift != 1);
    ($x, $y) = &get_xy($canv, $x, $y, $snap2grid);

    if ($type eq "circle") {
        $dx = abs($x - $xo);
        $dy = abs($y - $yo);
        if ($props{$id}{anchor} eq 'center') {
            if ($dx < $dy) {
                $y = ($y > $yo) ? $yo + $dx : $yo - $dx;
            } else {
                $x = ($x > $xo) ? $xo + $dy : $xo - $dy;
            }
            $xo = $xo - ($x - $xo);
            $yo = $yo - ($y - $yo);

        } elsif ($props{$id}{anchor} eq 'midpoint') {
            $xc = $props{$id}{xc};
            $yc = $props{$id}{yc};
            if (abs($xc-$xo) < abs($yc-$yo)) {  # x midpoint
                $dx *= 2.;
                if ($dx < $dy) {
                    $y = ($y > $yo) ? $yo + $dx : $yo - $dx;
                } else {
                    $x = ($x > $xo) ? $xo + 0.5*$dy : $xo - 0.5*$dy;
                }
                $xo = $xo - ($x - $xo);
            } else {
                $dy *= 2.;
                if ($dx < $dy) {
                    $y = ($y > $yo) ? $yo + 0.5*$dx : $yo - 0.5*$dx;
                } else {
                    $x = ($x > $xo) ? $xo + $dy : $xo - $dy;
                }
                $yo = $yo - ($y - $yo);
            }
        } else {
            if ($dx < $dy) {
                $y = ($y > $yo) ? $yo + $dx : $yo - $dx;
            } else {
                $x = ($x > $xo) ? $xo + $dy : $xo - $dy;
            }
        }
        $status_line = sprintf("X,Y,W,H: %d, %d, %d, %d",
                                         $x-3, $y-3, abs($x-$xo), abs($y-$yo));

    } elsif ($type eq "line") {
        if ($shift) {
            if (abs($x - $xo) <= abs($y - $yo)) {
                $x = $xo;
            } else {
                $y = $yo;
            }
        }
        if ($props{$id}{anchor} eq 'midpoint') {
            $xo = $xo - ($x - $xo);
            $yo = $yo - ($y - $yo);
        }
        $status_line = sprintf("X1,Y1,X2,Y2: %d, %d, %d, %d", $xo-3, $yo-3, $x-3, $y-3);

    } elsif ($type eq "graph") {
        $dx = abs($x - $xo);
        $dy = abs($y - $yo);
        if ($shift) {
            if ($dx < $dy) {
                $y = ($y > $yo) ? $yo + $dx : $yo - $dx;
            } else {
                $x = ($x > $xo) ? $xo + $dy : $xo - $dy;
            }
        }
        if ($props{$id}{anchor} eq 'center') {
            $xo = $xo - ($x - $xo);
            $yo = $yo - ($y - $yo);

        } elsif ($props{$id}{anchor} eq 'midpoint') {
            $xc = $props{$id}{xc};
            $yc = $props{$id}{yc};
            if (abs($xc-$xo) < abs($yc-$yo)) {  # x midpoint
                $dx *= 2.;
                if ($shift) {
                    if ($dx < $dy) {
                        $y = ($y > $yo) ? $yo + $dx : $yo - $dx;
                    } else {
                        $x = ($x > $xo) ? $xo + 0.5*$dy : $xo - 0.5*$dy;
                    }
                }
                $xo = $xo - ($x - $xo);
            } else {
                $dy *= 2.;
                if ($shift) {
                    if ($dx < $dy) {
                        $y = ($y > $yo) ? $yo + 0.5*$dx : $yo - 0.5*$dx;
                    } else {
                        $x = ($x > $xo) ? $xo + $dy : $xo - $dy;
                    }
                }
                $yo = $yo - ($y - $yo);
            }
        }
        $status_line = sprintf("X,Y,W,H: %d, %d, %d, %d",
                                           $x-3, $y-3, abs($x-$xo), abs($y-$yo));
    }
    return if ($x == $xo && $y == $yo);

    $canv->coords($id, $xo, $yo, $x, $y);
}


sub next_pt {
    my ($x, $y, $canv, $sx, $sy, $id, $shift) = @_;
    my ($npts, $type, $xp, $yp,
        @coords,
       );

    ($x, $y) = &get_xy($canv, $x, $y, $snap2grid);

    $shift  = 0 if (! defined($shift) || $shift != 1);
    @coords = Tkx::SplitList($canv->coords($id));
    pop @coords;
    pop @coords;
    if ($shift) {
        $xp = $coords[$#coords-1];
        $yp = $coords[$#coords];
        if (abs($x - $xp) <= abs($y - $yp)) {
            $x = $xp;
        } else {
            $y = $yp;
        }
    }
    $status_line = sprintf("X,Y: %d, %d", $x-3, $y-3);
    return if ($x == $sx && $y == $sy);

    push (@coords, $x, $y);
    $npts = ($#coords + 1) /2;
    $type = $props{$id}{type};
    if ($type eq "polygon" && $npts == 3) {
        delete $props{$id};
        $canv->delete($id);
        $id = $canv->create_polygon(@coords,
                 -outline => &get_rgb_code($default_color),
                 -width   => $default_width,
                 -tags    => "working");
        if ($default_fill) {
            $canv->itemconfigure($id, -fill => &get_rgb_code($default_fillcolor));
        } else {
            $canv->itemconfigure($id, -fill => "");
        }
        $props{$id}{type}      = $type;
        $props{$id}{x}         = $coords[0];
        $props{$id}{y}         = $coords[1];
        $props{$id}{xc}        = $coords[0];
        $props{$id}{yc}        = $coords[1];
        $props{$id}{xc_rot}    = $coords[0];
        $props{$id}{yc_rot}    = $coords[1];
        $props{$id}{anchor}    = 'point';
        $props{$id}{coordlist} = [ @coords ];
        $props{$id}{color}     = $default_color;
        $props{$id}{width}     = $default_width;
        $props{$id}{fill}      = $default_fill;
        $props{$id}{fillcolor} = $default_fillcolor;
        $props{$id}{angle}     = $default_angle;
        $props{$id}{angle_tmp} = $default_angle;
        $canv->g_bind("<Shift-Motion>",   [ \&next_pt,  Tkx::Ev("%x","%y"), $canv, $sx, $sy, $id, 1 ]);
        $canv->g_bind("<Motion>",         [ \&next_pt,  Tkx::Ev("%x","%y"), $canv, $sx, $sy, $id, 0 ]);
        $canv->g_bind("<Shift-Button-1>", [ \&add_pt,   Tkx::Ev("%x","%y"), $canv, $sx, $sy, $id, 1 ]);
        $canv->g_bind("<Button-1>",       [ \&add_pt,   Tkx::Ev("%x","%y"), $canv, $sx, $sy, $id, 0 ]);
        $canv->g_bind("<Double-Button-1>",[ \&end_poly, Tkx::Ev("%x","%y"), $canv, $id ]);
    } else {
        $canv->coords($id, @coords);
    }
}


sub add_pt {
    my ($x, $y, $canv, $sx, $sy, $id, $shift) = @_;
    my ($xp, $yp, @coords);

    ($x, $y) = &get_xy($canv, $x, $y, $snap2grid);

    $shift  = 0 if (! defined($shift) || $shift != 1);
    @coords = Tkx::SplitList($canv->coords($id));
    pop @coords;
    pop @coords;
    if ($shift) {
        $xp = $coords[$#coords-1];
        $yp = $coords[$#coords];
        if (abs($x - $xp) <= abs($y - $yp)) {
            $x = $xp;
        } else {
            $y = $yp;
        }
    }
    $status_line = sprintf("X,Y: %d, %d", $x-3, $y-3);
    return if ($x == $sx && $y == $sy);

    push (@coords, $x, $y, $x, $y);
    $canv->coords($id, @coords);
    $canv->g_bind("<Shift-Motion>",  [ \&next_pt, Tkx::Ev("%x","%y"), $canv, $x, $y, $id, 1 ]);
    $canv->g_bind("<Motion>",        [ \&next_pt, Tkx::Ev("%x","%y"), $canv, $x, $y, $id, 0 ]);
    $canv->g_bind("<Shift-Button-1>",[ \&add_pt,  Tkx::Ev("%x","%y"), $canv, $x, $y, $id, 1 ]);
    $canv->g_bind("<Button-1>",      [ \&add_pt,  Tkx::Ev("%x","%y"), $canv, $x, $y, $id, 0 ]);
}


sub begin_move_pt {
    my ($canv, $id, $insert_pt) = @_;

    $canv->delete($move_delete_menu) if ($move_delete_menu);
    if (defined($old_item)) {
        $canv->delete($old_item);
        undef $old_item;
    }
    $canv->configure(-cursor => $cursor_draw);
    $canv->g_bind("<Motion>",   [ \&move_pt, Tkx::Ev("%x", "%y"), $canv, $id, $insert_pt ]);
    $canv->g_bind("<Button-1>", [ \&show_points,   $canv, $id ]);
    $canv->g_bind("<Button-3>", [ \&exit_edit_pts, $canv, $id ]);
}


sub move_pt {
    my ($x, $y, $canv, $id, $insert_pt) = @_;
    my (@coords);

    ($x, $y) = &get_xy($canv, $x, $y, $snap2grid);
    $status_line = sprintf("X,Y: %d, %d", $x-3, $y-3);

    @coords = Tkx::SplitList($canv->coords($id));
    splice(@coords, $insert_pt, 2, $x, $y);
    $canv->coords($id, @coords);
}


sub delete_pt {
    my ($canv, $id, $insert_pt) = @_;
    my (@coords);

    $canv->delete($move_delete_menu) if ($move_delete_menu);

    @coords = Tkx::SplitList($canv->coords($id));
    splice(@coords, $insert_pt, 2);
    $canv->coords($id, @coords);
    &show_points($canv, $id);
}


sub edit_add_pt {                  # only for polygon or polyline
    my ($x, $y, $canv, $id) = @_;
    my ($dist, $i, $insert_pt, $npts, $selected, $tol, $type,
        $x1, $x2, $y1, $y2,
        @coords,
       );

    $tol      = 4;
    ($x, $y)  = &get_xy($canv, $x, $y, 0);
    $selected = &select_item($canv, $id, $x, $y, $tol, 1);
    return if (! $selected);

    $type   = $props{$id}{type};
    @coords = Tkx::SplitList($canv->coords($id));
    push (@coords, $coords[0], $coords[1]) if ($type eq "polygon");

    $npts      = ($#coords + 1) /2;
    $insert_pt = 0;
    for ($i=0; $i<$npts-1; $i++) {
        $x1 = $coords[2*$i];
        $y1 = $coords[2*$i+1];
        $x2 = $coords[2*$i+2];
        $y2 = $coords[2*$i+3];
        if ( $x >= &min($x1,$x2)-$tol && $x <= &max($x1,$x2)+$tol &&
             $y >= &min($y1,$y2)-$tol && $y <= &max($y1,$y2)+$tol ) {
            if ($x1 == $x2) {
                $insert_pt = 2*$i+2;
                last;
            } else {
                $dist = ($x2 - $x1)
                        * (($y2 - $y1)*($x - $x1)/($x2 - $x1) + $y1 - $y)
                        / sqrt(($x2-$x1)*($x2-$x1) + ($y2-$y1)*($y2-$y1));
                if (abs($dist) <= $tol) {
                    $insert_pt = 2*$i+2;
                    last;
                }
            }
        }
    }
    if ($insert_pt > 0) {
        splice(@coords, -2, 2) if ($type eq "polygon");
        splice(@coords, $insert_pt, 0, $x, $y);
        $canv->coords($id, @coords);
        $canv->g_bind("<Motion>",   [ \&move_pt, Tkx::Ev("%x", "%y"), $canv, $id, $insert_pt ]);
        $canv->g_bind("<Button-1>", [ \&show_points, $canv, $id ]);
    }
}


sub exit_edit_pts {
    my ($canv, $id) = @_;
    my ($diff, $found, $i, $npts, $old_npts, $r, $xc, $yc,
        @coords, @old_coords, @xvals, @yvals,
       );

    @coords = Tkx::SplitList($canv->coords($id));
    $npts   = ($#coords+1)/2;
    $found  = 0;
    for ($i=0; $i<$npts; $i++) {
        if ($coords[2*$i] == $props{$id}{x} && $coords[2*$i+1] == $props{$id}{y}) {
            $found = 1;
            last;
        }
    }
    if (! $found) {
        $props{$id}{x} = $coords[0];
        $props{$id}{y} = $coords[1];
    }
    @old_coords = @{ $props{$id}{coordlist} };
    $old_npts   = ($#old_coords+1)/2;
    $diff       = 0;
    if ($npts != $old_npts) {
        $diff = 1;
    } else {
        for ($i=0; $i<=$#coords; $i++) {
            if ($coords[$i] != $old_coords[$i]) {
                $diff = 1;
                last;
            }
        }
    }
    if ($diff) {
        $props{$id}{coordlist} = [ @coords ];
        ($xc, $yc, $r) = &smallest_circle(@coords);
        $props{$id}{xc_rot} = $xc;
        $props{$id}{yc_rot} = $yc;

        @xvals  = @yvals = ();
        @coords = &find_rect_from_poly(\@coords, $props{$id}{angle});
        $npts   = ($#coords + 1) /2;
        for ($i=0; $i<$npts; $i++) {
            push(@xvals, $coords[2*$i]);
            push(@yvals, $coords[2*$i+1]);
        }
        $props{$id}{xc} = (&min(@xvals) + &max(@xvals))/2.;
        $props{$id}{yc} = (&min(@yvals) + &max(@yvals))/2.;
    }

    undef %pt_props;
    undef $old_item if (defined($old_item));
    $canv->delete("points");
    &reset_bindings;
}


sub end_poly {
    my ($x, $y, $canv, $id) = @_;
    my ($i, $npts, $r, $xo, $yo,
        @coords, @new_coords, @xvals, @yvals,
       );

    @xvals  = @yvals = ();
    @coords = Tkx::SplitList($canv->coords($id));
    $npts   = ($#coords + 1) /2;
    return if ($npts < 3);

    @new_coords = @coords[0,1];
    for ($i=1; $i<$npts; $i++) {
        if ($coords[2*$i]   != $coords[2*$i-2] ||
            $coords[2*$i+1] != $coords[2*$i-1]) {
            push (@new_coords, $coords[2*$i], $coords[2*$i+1]);
        }
    }
    $canv->coords($id, @new_coords);
    $props{$id}{coordlist} = [ @new_coords ];

    ($xo, $yo, $r) = &smallest_circle(@new_coords);
    $props{$id}{xc_rot} = $xo;
    $props{$id}{yc_rot} = $yo;

    @coords = &find_rect_from_poly(\@new_coords, $props{$id}{angle});
    $npts   = ($#coords + 1) /2;
    for ($i=0; $i<$npts; $i++) {
        push(@xvals, $coords[2*$i]);
        push(@yvals, $coords[2*$i+1]);
    }
    $props{$id}{xc} = (&min(@xvals) + &max(@xvals))/2.;
    $props{$id}{yc} = (&min(@yvals) + &max(@yvals))/2.;

    $canv->delete("anchor");
    $canv->dtag("working");
    $canv->itemconfigure($id, -tags => "keep");
    &reset_bindings;
}


sub end_drawing {
    my ($x, $y, $canv, $sx, $sy, $id) = @_;
    my ($i, $npts, $r, $type, $xo, $yo,
        @coords, @xvals, @yvals,
       );

    &end_select($canv, $id, 1);

    @xvals = @yvals = ();
    $type  = $props{$id}{type};

    ($x, $y) = &get_xy($canv, $x, $y, $snap2grid);

    if ($x == $sx && $y == $sy) {
        &pop_up_error($main, "Object has no length or width.\nPlease continue or reset.");
        return;
    } elsif (($x == $sx || $y == $sy) && $type ne "line") {
        &pop_up_error($main, "Object either has no length or width.\nPlease continue or reset.");
        return;
    }

    @coords = Tkx::SplitList($canv->coords($id));
    $props{$id}{coordlist} = [ @coords ];

    if ($type !~ /^(line|circle|graph)$/) {
        $props{$id}{angle} = $props{$id}{angle_tmp};
    }
    if ($type =~ /^(polygon|polyline)$/) {
        ($xo, $yo, $r) = &smallest_circle(@coords);
        $props{$id}{xc_rot} = $xo;
        $props{$id}{yc_rot} = $yo;
    }
    if ($props{$id}{anchor} ne 'center') {
        if ($type =~ /^(polygon|polyline)$/) {
            @coords = &find_rect_from_poly(\@coords, $props{$id}{angle});
        }
        $npts = ($#coords + 1) /2;
        for ($i=0; $i<$npts; $i++) {
            push(@xvals, $coords[2*$i]);
            push(@yvals, $coords[2*$i+1]);
        }
        $props{$id}{xc} = (&min(@xvals) + &max(@xvals))/2.;
        $props{$id}{yc} = (&min(@yvals) + &max(@yvals))/2.;
    }
    if ($type eq "ellipse") {
        $props{$id}{hw} = $props{$id}{hw_tmp};
        $props{$id}{hh} = $props{$id}{hh_tmp};
    }

    $canv->delete("anchor");
    $canv->delete("crosshair");
    $canv->delete("target");
    $canv->dtag("working");
    $canv->addtag("keep", withtag => $id);
    &reset_bindings;

    if ($type eq "graph") {
        if ($props{$id}{meta} =~ /data_profile/) {
            &make_data_profile($canv, $id, 0);
        } elsif ($props{$id}{meta} =~ /w2_profile/) {
            if ($props{$id}{meta} =~ /w2_profile_matrix_/) {
                ($props{$id}{link_id} = $props{$id}{meta}) =~ s/w2_profile_matrix_(\d+)/$1/;
                $props{$id}{meta} = "w2_profile_matrix";
                $canv->itemconfigure($id, -state => 'hidden');
            }
            &make_w2_profile($canv, $id, 0);
        } elsif ($props{$id}{meta} eq "w2_slice") {
            &make_w2_slice($canv, $id, 0);
        } elsif ($props{$id}{meta} eq "w2_tdmap") {
            &make_w2_tdmap($canv, $id, 0);
        } elsif ($props{$id}{meta} eq "w2_outflow") {
            &make_w2_outflow($canv, $id, 0);
        } elsif ($props{$id}{meta} eq "w2_wlevels") {
            &make_w2_wlevels($canv, $id, 0);
        } elsif ($props{$id}{meta} =~ /vert_wd_zone/) {
            &make_wd_zone($canv, $id, 0);
        } elsif ($props{$id}{meta} eq "linked_time_series") {
            &make_ts_graph($canv, $id, 0);
        } elsif ($props{$id}{meta} eq "time_series") {
            if (! defined($props{$id}{data})) {
                &add_ts_graph($canv, $id);
            } else {
                &make_ts_graph($canv, $id, 0);
            }
        }
    }
}


sub forget_drawing {
    my ($id) = @_;

    delete $props{$id} if ($id ne "");
    $canvas->delete("working");
    $canvas->delete("anchor");
    $canvas->delete("target");
    $canvas->delete("zoom_bar");
    &reset_bindings;
}


sub forget_resize {
    my ($canv, $id) = @_;

    $canv->coords($id, $props{$id}{coordlist});
    $canv->delete("anchor");
    $canv->delete("crosshair");
    &reset_bindings;

    if ($props{$id}{type} eq "graph") {
        $canv->itemconfigure($id, -state => 'hidden') if ($props{$id}{meta} eq "w2_profile_matrix");
    }
}


sub begin_move {
    my ($canv, $id, $grp) = @_;
    my ($item, $xo, $yo,
        @items, @coords,
       );

    $grp = "" if (! defined($grp));
    if ($grp eq "group") {
        @items = Tkx::SplitList($canv->find_withtag($id));
        foreach $item (@items) {
            next if (! defined($props{$item}{type}));
            &end_select($canv, $item, 1);
        }
    } else {
        &end_select($canv, $id, 1);
    }
    if ($grp =~ /(Color Key|Legend)/) {
        @coords = @{ $props{$id}{coordlist} };
        $xo = $coords[2] + $gr_props{$id}{xleg_off};
        $yo = $coords[1] + $gr_props{$id}{yleg_off};
    } elsif ($grp =~ /Bulkhead Key/) {
        $xo = $gr_props{$id}{bh_xpos};
        $yo = $gr_props{$id}{bh_ypos};
    } elsif ($grp eq "group") {
        $props{$id}{type} = "group";
        @coords = Tkx::SplitList($canv->bbox($id));
        $xo = $props{$id}{x} = $coords[0];
        $yo = $props{$id}{y} = $coords[1];
    } else {
        $xo = $props{$id}{x};
        $yo = $props{$id}{y};
    }
    if ($snap2grid) {
        $canv->create_rectangle($xo-2, $yo-2, $xo+2, $yo+2,
                     -outline => &get_rgb_code($anchor_line_color),
                     -width   => 1,
                     -fill    => &get_rgb_code($anchor_select_color),
                     -tags    => "anchor");
    }
    $canv->configure(-cursor => $cursor_move);
    $canv->g_bind("<Shift-Motion>", [ \&move_object, Tkx::Ev("%x","%y"), $canv, $id, $xo, $yo, $grp, 1 ]);
    $canv->g_bind("<Motion>",       [ \&move_object, Tkx::Ev("%x","%y"), $canv, $id, $xo, $yo, $grp, 0 ]);
    $canv->g_bind("<Button-1>",     [ \&end_move_object, $canv, $id, $grp ]);
    $canv->g_bind("<Button-3>",     [ \&forget_move_object, $canv, $id, $xo, $yo, $grp ]);
}


sub move_object {
    my ($x, $y, $canv, $id, $xo, $yo, $grp, $shft) = @_;
    my ($ch, $cw, $dx, $dy, $gs, $gtag, $i, $item, $npts, $type, $x1, $x2,
        $xmove, $xoffset, $xp, $y1, $y2, $ymove, $yoffset, $yp,
        @coords, @items, @xvals, @yvals,
       );

    $shft = 0 if (! defined($shft) || $shft != 1);
    $type = $props{$id}{type};
    $grp  = "" if (! defined($grp));
    if ($type eq "text" || $type eq "image") {
        @coords = &find_rect_from_text_or_image($canv, $id);
    } elsif ($type eq "graph") {
        $gtag   = "graph" . $id;
        $gtag  .= "_colorKey" if ($grp =~ /Color Key/);
        $gtag  .= "_legend"   if ($grp =~ /Legend/);
        $gtag  .= "_openBH"   if ($grp =~ /Bulkhead Key/);
        @coords = Tkx::SplitList($canv->bbox($gtag));
    } elsif ($type eq "group") {
        @coords = Tkx::SplitList($canv->bbox($id));
        @items  = Tkx::SplitList($canv->find_withtag($id));
    } else {
        @coords = Tkx::SplitList($canv->coords($id));
    }
    @xvals = @yvals = ();
    $npts  = ($#coords + 1) /2;
    for ($i=0; $i<$npts; $i++) {
        push(@xvals, $coords[2*$i]);
        push(@yvals, $coords[2*$i+1]);
    }
    $x1 = &min(@xvals);
    $x2 = &max(@xvals);
    $y1 = &min(@yvals);
    $y2 = &max(@yvals);
    $xoffset = ($x2 -$x1)/2.;
    $yoffset = ($y2 -$y1)/2.;

    ($x, $y) = &get_xy($canv, $x, $y, 0);

    $dx = $x -($x1 +$xoffset);
    $dy = $y -($y1 +$yoffset);
    $cw = $canvas_width;
    $ch = $canvas_height;
    if ($snap2grid) {
        if ($grp =~ /(Color Key|Legend)/) {
            @coords = @{ $props{$id}{coordlist} };
            $xp     = $coords[2] +$gr_props{$id}{xleg_off};
            $yp     = $coords[1] +$gr_props{$id}{yleg_off};
        } elsif ($grp =~ /Bulkhead Key/) {
            $xp = $gr_props{$id}{bh_xpos};
            $yp = $gr_props{$id}{bh_ypos};
        } else {
            $xp = $props{$id}{x};
            $yp = $props{$id}{y};
        }
        $gs = $grid_spacing;
        $dx = 3+ $gs * &round_to_int(($xp+$dx)/$gs) - $xp;
        $dy = 3+ $gs * &round_to_int(($yp+$dy)/$gs) - $yp;
        until ($x1 + $dx >= 3)      { $dx += $gs; }
        until ($x2 + $dx <= $cw +2) { $dx -= $gs; }
        until ($y1 + $dy >= 3)      { $dy += $gs; }
        until ($y2 + $dy <= $ch +2) { $dy -= $gs; }
    } else {
        if ($x1 + $dx < 3) {
            $dx = 3 - $x1;
        } elsif ($x2 + $dx > $cw +2) {
            $dx = $cw +2 - $x2;
        }
        if ($y1 + $dy < 3) {
            $dy = 3 - $y1;
        } elsif ($y2 + $dy > $ch +2) {
            $dy = $ch +2 - $y2;
        }
    }
    if ($shft) {
        if ($grp =~ /(Color Key|Legend)/) {
            @coords = @{ $props{$id}{coordlist} };
            $xmove  = $xo -($coords[2] +$gr_props{$id}{xleg_off} +$dx);
            $ymove  = $yo -($coords[1] +$gr_props{$id}{yleg_off} +$dy);
            if (abs($xmove) >= abs($ymove)) {
                $dy = $yo -($coords[1] +$gr_props{$id}{yleg_off});
            } else {
                $dx = $xo -($coords[2] +$gr_props{$id}{xleg_off});
            }
        } elsif ($grp =~ /Bulkhead Key/) {
            $xmove = $xo -($gr_props{$id}{bh_xpos} +$dx);
            $ymove = $yo -($gr_props{$id}{bh_ypos} +$dy);
            if (abs($xmove) >= abs($ymove)) {
                $dy = $yo -$gr_props{$id}{bh_ypos};
            } else {
                $dx = $xo -$gr_props{$id}{bh_xpos};
            }
        } else {
            $xmove = $xo -($props{$id}{x} +$dx);
            $ymove = $yo -($props{$id}{y} +$dy);
            if (abs($xmove) >= abs($ymove)) {
                $dy = $yo -$props{$id}{y};
            } else {
                $dx = $xo -$props{$id}{x};
            }
        }
    }
    if (abs($dx) > 0.0 || abs($dy) > 0.0) {
        if ($type eq "graph") {
            $canv->move($gtag, $dx, $dy);
        } else {
            $canv->move($id, $dx, $dy);
        }
        $canv->move("anchor", $dx, $dy);

        if ($type eq "graph" && $gtag =~ /(_colorKey|_legend)/) {
            $gr_props{$id}{xleg_off} += $dx;
            $gr_props{$id}{yleg_off} += $dy;
            @coords = @{ $props{$id}{coordlist} };
            $xp     = $coords[2] +$gr_props{$id}{xleg_off};
            $yp     = $coords[1] +$gr_props{$id}{yleg_off};
        } elsif ($type eq "graph" && $gtag =~ /_openBH/) {
            $gr_props{$id}{bh_xpos} += $dx;
            $gr_props{$id}{bh_ypos} += $dy;
            $xp = $gr_props{$id}{bh_xpos};
            $yp = $gr_props{$id}{bh_ypos};
        } elsif ($type eq "group") {
            $props{$id}{x} += $dx;
            $props{$id}{y} += $dy;
            foreach $item (@items) {
                next if (! defined($props{$item}{type}));
                $props{$item}{x}  += $dx;
                $props{$item}{y}  += $dy;
                $props{$item}{xc} += $dx;
                $props{$item}{yc} += $dy;
                if ($props{$item}{type} =~ /^(polygon|polyline)$/) {
                    $props{$item}{xc_rot} += $dx;
                    $props{$item}{yc_rot} += $dy;
                }
            }
            $xp = $props{$id}{x};
            $yp = $props{$id}{y};
        } else {
            $props{$id}{x}  += $dx;
            $props{$id}{y}  += $dy;
            $props{$id}{xc} += $dx;
            $props{$id}{yc} += $dy;
            if ($type =~ /^(polygon|polyline)$/) {
                $props{$id}{xc_rot} += $dx;
                $props{$id}{yc_rot} += $dy;
            }
            $xp = $props{$id}{x};
            $yp = $props{$id}{y};
        }
        $status_line = sprintf("X,Y: %d, %d  BBox: %d, %d, %d, %d",
                                $xp-3, $yp-3,
                                $x1+$dx-3, $y1+$dy-3, $x2+$dx-3, $y2+$dy-3);
    }
}


sub move_selected {
    my ($key, $canv) = @_;
    my ($ch, $cw, $default_dx, $default_dy, $dx, $dy, $gs, $gtag,
        $i, $id, $npts, $step, $type, $x1, $x2, $xp, $y1, $y2, $yp,
        @coords, @ids, @xvals, @yvals,
       );

    @ids = ();

#   Find whether any items are selected
    @ids = Tkx::SplitList($canv->find_withtag("select"));
    return if (! @ids || $#ids < 0);

#   Set the amount of movement
    $default_dx = $default_dy = 0;
    $step = ($snap2grid) ? $grid_spacing : 1;
    if ($key == 37) {
        $default_dx = -1 * $step;
    } elsif ($key == 38) {
        $default_dy = -1 * $step;
    } elsif ($key == 39) {
        $default_dx = $step;
    } elsif ($key == 40) {
        $default_dy = $step;
    }
    $cw = $canvas_width;
    $ch = $canvas_height;
    $gs = $grid_spacing;

#   Move each selected object independently
    foreach $id (@ids) {
        &end_select($canv, $id, 1);
        $type = $props{$id}{type};
        if ($type eq "text" || $type eq "image") {
            @coords = &find_rect_from_text_or_image($canv, $id);
        } elsif ($type eq "graph") {
            $gtag   = "graph" . $id;
            @coords = Tkx::SplitList($canv->bbox($gtag));
        } else {
            @coords = Tkx::SplitList($canv->coords($id));
        }
        @xvals = @yvals = ();
        $npts  = ($#coords + 1) /2;
        for ($i=0; $i<$npts; $i++) {
            push(@xvals, $coords[2*$i]);
            push(@yvals, $coords[2*$i+1]);
        }
        $x1 = &min(@xvals);
        $x2 = &max(@xvals);
        $y1 = &min(@yvals);
        $y2 = &max(@yvals);
        $dx = $default_dx;
        $dy = $default_dy;
        if ($snap2grid) {       # Honor the snap2grid mode
            $xp = $props{$id}{x};
            $yp = $props{$id}{y};
            $dx = 3+ $gs * &round_to_int(($xp+$dx)/$gs) - $xp;
            $dy = 3+ $gs * &round_to_int(($yp+$dy)/$gs) - $yp;
            until ($x1 + $dx >= 3)      { $dx += $gs; }
            until ($x2 + $dx <= $cw +2) { $dx -= $gs; }
            until ($y1 + $dy >= 3)      { $dy += $gs; }
            until ($y2 + $dy <= $ch +2) { $dy -= $gs; }
        } else {
            if ($x1 + $dx < 3) {
                $dx = 3 - $x1;
            } elsif ($x2 + $dx > $cw +2) {
                $dx = $cw +2 - $x2;
            }
            if ($y1 + $dy < 3) {
                $dy = 3 - $y1;
            } elsif ($y2 + $dy > $ch +2) {
                $dy = $ch +2 - $y2;
            }
        }
        if (abs($dx) > 0.0 || abs($dy) > 0.0) {
            if ($type eq "graph") {
                $canv->move($gtag, $dx, $dy);
            } else {
                $canv->move($id, $dx, $dy);
            }
            $canv->move("select_" . $type . $id, $dx, $dy);

            $props{$id}{x}  += $dx;
            $props{$id}{y}  += $dy;
            $props{$id}{xc} += $dx;
            $props{$id}{yc} += $dy;
            if ($type =~ /^(polygon|polyline)$/) {
                $props{$id}{xc_rot} += $dx;
                $props{$id}{yc_rot} += $dy;
            }
            $props{$id}{coordlist} = [ Tkx::SplitList($canv->coords($id)) ];
            if ($props{$id}{type} eq "graph") {
                $props{$id}{oldcoords} = $props{$id}{coordlist};
            }
        }
    }
}


sub end_move_object {
    my ($canv, $id, $grp) = @_;
    my ($item, @items);

    &end_select($canv, $id, 1) if ($grp ne "group");

    if ($grp eq "group") {
        @items = Tkx::SplitList($canv->find_withtag($id));
        foreach $item (@items) {
            next if (! defined($props{$item}{type}));
            $props{$item}{coordlist} = [ Tkx::SplitList($canv->coords($item)) ];
            if ($props{$item}{type} eq "graph") {
                $props{$item}{oldcoords} = $props{$item}{coordlist};
            }
        }
    } elsif (! defined($grp) || $grp !~ /(Color Key|Legend|Bulkhead Key)/) {
        $props{$id}{coordlist} = [ Tkx::SplitList($canv->coords($id)) ];
        if ($props{$id}{type} eq "graph") {
            $props{$id}{oldcoords} = $props{$id}{coordlist};
        }
    }
    $canv->delete("anchor");
    &reset_bindings;
}


sub forget_move_object {
    my ($canv, $id, $sx, $sy, $grp) = @_;
    my ($dx, $dy, $gtag, $item, $type,
        @coords, @items,
       );

    &end_select($canv, $id, 1) if ($grp ne "group");

    $type = $props{$id}{type};
    if ($grp eq "group") {
        $dx = $sx -$props{$id}{x};
        $dy = $sy -$props{$id}{y};
        @items = Tkx::SplitList($canv->find_withtag($id));
        foreach $item (@items) {
            next if (! defined($props{$item}{type}));
            if ($props{$item}{type} eq "graph") {
                $gtag = "graph" . $item;
                $canv->move($gtag, $dx, $dy);
            } else {
                $canv->coords($item, $props{$item}{coordlist});
            }
            if ($props{$item}{type} =~ /^(polygon|polyline)$/) {
                $props{$item}{xc_rot} += $dx;
                $props{$item}{yc_rot} += $dy;
            }
            $props{$item}{xc} += $dx;
            $props{$item}{yc} += $dy;
            $props{$item}{x}  += $dx;
            $props{$item}{y}  += $dy;
        }
    } elsif ($grp =~ /(Color Key|Legend)/) {
        @coords = @{ $props{$id}{coordlist} };
        $dx     = $sx -($coords[2] +$gr_props{$id}{xleg_off});
        $dy     = $sy -($coords[1] +$gr_props{$id}{yleg_off});
        $gtag   = "graph" . $id . "_colorKey" if ($grp =~ /Color Key/);
        $gtag   = "graph" . $id . "_legend"   if ($grp =~ /Legend/);
        $canv->move($gtag, $dx, $dy);
        $gr_props{$id}{xleg_off} = $sx -$coords[2];
        $gr_props{$id}{yleg_off} = $sy -$coords[1];
    } elsif ($grp =~ /Bulkhead Key/) {
        $dx   = $sx -$gr_props{$id}{bh_xpos};
        $dy   = $sy -$gr_props{$id}{bh_ypos};
        $gtag = "graph" . $id . "_openBH";
        $canv->move($gtag, $dx, $dy);
        $gr_props{$id}{bh_xpos} = $sx;
        $gr_props{$id}{bh_ypos} = $sy;
    } else {
        $dx = $sx -$props{$id}{x};
        $dy = $sy -$props{$id}{y};
        if ($type eq "graph") {
            $gtag = "graph" . $id;
            $canv->move($gtag, $dx, $dy);
        } else {
            $canv->coords($id, $props{$id}{coordlist});
        }
        if ($type =~ /^(polygon|polyline)$/) {
            $props{$id}{xc_rot} += $dx;
            $props{$id}{yc_rot} += $dy;
        }
        $props{$id}{xc} += $dx;
        $props{$id}{yc} += $dy;
        $props{$id}{x}   = $sx;
        $props{$id}{y}   = $sy;
    }

    $canv->delete("anchor");
    &reset_bindings;
}


sub begin_rotate {
    my ($canv, $id) = @_;
    my ($angle, $type, $xo, $yo);

    &end_select($canv, $id, 1);

    $xo    = $props{$id}{x};
    $yo    = $props{$id}{y};
    $type  = $props{$id}{type};
    $angle = $props{$id}{angle};

    $canv->create_rectangle($xo-2, $yo-2, $xo+2, $yo+2,
                 -outline => &get_rgb_code($anchor_line_color),
                 -width   => 1,
                 -fill    => &get_rgb_code($anchor_select_color),
                 -tags    => "anchor");

    $canv->configure(-cursor => $cursor_hand);
    if ($type eq "image") {
        $canv->g_bind("<Motion>",   [ \&begin_rotate_image, Tkx::Ev("%x","%y"), $canv, $id ]);
        $canv->g_bind("<Button-1>", [ \&end_rotate_image,   Tkx::Ev("%x","%y"), $canv, $id ]);
        $canv->g_bind("<Button-3>", [ \&forget_rotate_image, $canv, $id ]);
    } else {
        $canv->g_bind("<Motion>",   [ \&rotate_object, Tkx::Ev("%x","%y"), $canv, $id ]);
        $canv->g_bind("<Button-1>", [ \&end_rotate_object, $canv, $id ]);
        $canv->g_bind("<Button-3>", [ \&forget_rotate_object, $canv, $id, $angle ]);
    }
}


sub rotate_object {
    my ($x, $y, $canv, $id) = @_;
    my ($ang, $ang_tot, $ang2, $i, $npts, $r, $type, $xi, $xo, $yi, $yo,
        @coords, @new_coords,
       );

    $x  = $canv->canvasx($x);
    $y  = $canv->canvasy($y);
    $xo = $props{$id}{x};
    $yo = $props{$id}{y};
    if ($x == $xo) {
        if ($y == $yo) {
            $ang = 0;
        } else {
            $ang = ($y > $yo) ? 270 : 90;
        }
    } elsif ($y == $yo) {
        $ang = ($x > $xo) ? 0 : 180;
    } else {
        $ang = &round_to_int((180./pi)*atan2(($yo-$y),($x-$xo)));
    }
    $ang += 360 if ($ang < 0);

    $type = $props{$id}{type};
    if ($type eq "text") {
        $canv->itemconfigure($id, -angle => $ang);

    } elsif ($type =~ /^(ellipse|rectangle|diamond|polygon|polyline)$/) {
        @coords = @{ $props{$id}{coordlist} };
        $npts   = ($#coords + 1) /2;
        @new_coords = ();
        for ($i=0; $i<$npts; $i++) {
            $xi = $coords[2*$i];
            $yi = $coords[2*$i+1];
            if ($xi != $xo || $yi != $yo) {
                $r = sqrt(($xi-$xo)*($xi-$xo)+($yi-$yo)*($yi-$yo));
                if ($xi == $xo) {
                    $ang2 = ($yi > $yo) ? 270 : 90;
                } elsif ($yi == $yo) {
                    $ang2 = ($xi > $xo) ? 0 : 180;
                } else {
                    $ang2 = (180./pi)*atan2(($yo-$yi),($xi-$xo));
                }
                $ang2 += 360 if ($ang2 < 0);
                $ang_tot = $ang + $ang2 - $props{$id}{angle};
                $xi = $xo + $r * cos($ang_tot * pi/180.);
                $yi = $yo - $r * sin($ang_tot * pi/180.);
            }
            push (@new_coords, $xi, $yi);
        }
        $canv->coords($id, @new_coords);
        $props{$id}{angle_tmp} = $ang;
    }

    $status_line = sprintf("Rotation: %d", $ang);
}


sub end_rotate_object {
    my ($canv, $id) = @_;
    my ($angle, $i, $npts, $r, $type, $xo, $yo,
        @coords, @xvals, @yvals,
       );

    &end_select($canv, $id, 1);

    @coords = Tkx::SplitList($canv->coords($id));
    $type   = $props{$id}{type};

    if ($type eq "text") {
        $angle = $canv->itemcget($id, -angle);
        $props{$id}{angle} = $angle;

    } elsif ($type =~ /^(ellipse|rectangle|diamond|polygon|polyline)$/) {
        $props{$id}{angle}     = $props{$id}{angle_tmp};
        $props{$id}{coordlist} = [ @coords ];
        if ($props{$id}{anchor} ne 'center_rot' && $type =~ /^(polygon|polyline)$/) {
            ($xo, $yo, $r) = &smallest_circle(@coords);
            $props{$id}{xc_rot} = $xo;
            $props{$id}{yc_rot} = $yo;
        }
        if ($props{$id}{anchor} ne 'center') {
            if ($type =~ /^(polygon|polyline)$/) {
                @coords = &find_rect_from_poly(\@coords, $props{$id}{angle});
            }
            @xvals = @yvals = ();
            $npts  = ($#coords + 1) /2;
            for ($i=0; $i<$npts; $i++) {
                push(@xvals, $coords[2*$i]);
                push(@yvals, $coords[2*$i+1]);
            }
            $props{$id}{xc} = (&min(@xvals) + &max(@xvals))/2.;
            $props{$id}{yc} = (&min(@yvals) + &max(@yvals))/2.;
        }
    }
    $canv->delete("anchor");
    &reset_bindings;
}


sub forget_rotate_object {
    my ($canv, $id, $sa) = @_;
    my ($type);

    &end_select($canv, $id, 1);

    $props{$id}{angle} = $sa;
    $type              = $props{$id}{type};

    if ($type eq "text") {
        $canv->itemconfigure($id, -angle => $sa);

    } elsif ($type =~ /^(ellipse|rectangle|diamond|polygon|polyline)$/) {
        $canv->coords($id, $props{$id}{coordlist});
        $props{$id}{angle_tmp} = $props{$id}{angle};
    }
    $canv->delete("anchor");
    &reset_bindings;
}


sub align_objects {
    my ($canv, $id, $align, $tag) = @_;
    my ($dx, $dy, $i, $item, $np, $type, $xref, $yref,
        @coords, @items, @xvals, @yvals,
       );

#   Reference object
    if ($align eq "center") {
        $xref = $props{$id}{xc};
    } elsif ($align eq "middle") {
        $yref = $props{$id}{yc};
    } elsif ($align eq "xycenters") {
        $xref = $props{$id}{xc};
        $yref = $props{$id}{yc};
    } elsif ($align eq "anchor_x") {
        $xref = $props{$id}{x};
    } elsif ($align eq "anchor_y") {
        $yref = $props{$id}{y};
    } elsif ($align eq "anchor_xy") {
        $xref = $props{$id}{x};
        $yref = $props{$id}{y};
    } else {
        @xvals  = @yvals = ();
        @coords = &get_coords($canv, $id, "pts");
        $np = ($#coords +1)/2;
        for ($i=0; $i<$np; $i++) {
            push (@xvals, $coords[2*$i]);
            push (@yvals, $coords[2*$i+1]);
        }
        if ($align eq "left") {
            $xref = &min(@xvals);
        } elsif ($align eq "right") {
            $xref = &max(@xvals);
        } elsif ($align eq "top") {
            $yref = &min(@yvals);
        } elsif ($align eq "bottom") {
            $yref = &max(@yvals);
        }
    }

#   Objects to align to the reference
    $dx = $dy = 0;
    @items = Tkx::SplitList($canv->find_withtag($tag));
    foreach $item (@items) {
        next if ($item == $id);
        next if (! defined($props{$item}{type}));
        if ($align eq "center") {
            $dx = $xref -$props{$item}{xc};
        } elsif ($align eq "middle") {
            $dy = $yref -$props{$item}{yc};
        } elsif ($align eq "xycenters") {
            $dx = $xref -$props{$item}{xc};
            $dy = $yref -$props{$item}{yc};
        } elsif ($align eq "anchor_x") {
            $dx = $xref -$props{$item}{x};
        } elsif ($align eq "anchor_y") {
            $dy = $yref -$props{$item}{y};
        } elsif ($align eq "anchor_xy") {
            $dx = $xref -$props{$item}{x};
            $dy = $yref -$props{$item}{y};
        } else {
            @xvals  = @yvals = ();
            @coords = &get_coords($canv, $item, "pts");
            $np = ($#coords +1)/2;
            for ($i=0; $i<$np; $i++) {
                push (@xvals, $coords[2*$i]);
                push (@yvals, $coords[2*$i+1]);
            }
            if ($align eq "left") {
                $dx = $xref - &min(@xvals);
            } elsif ($align eq "right") {
                $dx = $xref - &max(@xvals);
            } elsif ($align eq "top") {
                $dy = $yref - &min(@yvals);
            } elsif ($align eq "bottom") {
                $dy = $yref - &max(@yvals);
            }
        }
        $type = $props{$item}{type};
        if ($type eq "graph") {
            $canv->move("graph" . $item, $dx, $dy);
        } else {
            $canv->move($item, $dx, $dy);
        }
        $props{$item}{x}  += $dx;
        $props{$item}{y}  += $dy;
        $props{$item}{xc} += $dx;
        $props{$item}{yc} += $dy;
        if ($type =~ /^(polygon|polyline)$/) {
            $props{$item}{xc_rot} += $dx;
            $props{$item}{yc_rot} += $dy;
        }
        $props{$item}{coordlist} = [ Tkx::SplitList($canv->coords($item)) ];
        if ($type eq "graph") {
            $props{$item}{oldcoords} = $props{$item}{coordlist};
        }
    }
    if ($tag eq "select") {
        &clear_selection_marks($canv);
        &show_group($canv, $tag);
    }
}


sub flip_object {
    my ($canv, $id, $arg) = @_;
    my ($ang, $i, $is_anchor, $left_right, $npts, $r, $type, $x, $xo,
        $y, $yo,
        @coords, @new_coords, @xvals, @yvals,
       );

    &end_select($canv, $id, 1);

    $type   = $props{$id}{type};
    $ang    = $props{$id}{angle} if ($type ne "line");
    @coords = @{ $props{$id}{coordlist} };
    $npts   = ($#coords +1)/2;

    if ($arg =~ /anchor/) {    # use current anchor point
        $xo = $props{$id}{x};
        $yo = $props{$id}{y};
    } else {                   # use geometric center point
        $xo = $props{$id}{xc};
        $yo = $props{$id}{yc};
    }
    $left_right = ($arg =~ /left_right/) ? 1 : 0;
    @new_coords = ();

    for ($i=0; $i<$npts; $i++) {
        $x = $coords[2*$i];
        $y = $coords[2*$i+1];
        $is_anchor = ($x == $props{$id}{x} && $y == $props{$id}{y}) ? 1 : 0;
        if ($left_right) {         # flip left to right
            $x = $xo + ($xo - $x);
            $props{$id}{x} = $x if ($is_anchor);
        } else {                   # flip top to bottom
            $y = $yo + ($yo - $y);
            $props{$id}{y} = $y if ($is_anchor);
        }
        push (@new_coords, $x, $y);
    }
    @coords = @new_coords;
    $canv->coords($id, @coords);
    $props{$id}{coordlist} = [ @coords ];

    if ($type ne "line" && $ang % 90 != 0) {
        $ang = ($left_right) ? -1 * $ang +180 : -1 * $ang;
        $ang = ($ang +360) % 360;
        $props{$id}{angle} = $ang;
    }
    if ($type =~ /^(polygon|polyline)$/) {
        if ($arg !~ /anchor/ || $props{$id}{anchor} ne 'center_rot') {
            ($xo, $yo, $r) = &smallest_circle(@coords);
            $props{$id}{xc_rot} = $xo;
            $props{$id}{yc_rot} = $yo;
        }
    }
    if ($arg =~ /anchor/ && $props{$id}{anchor} ne 'center') {
        if ($type =~ /^(polygon|polyline)$/) {
            @coords = &find_rect_from_poly(\@coords, $props{$id}{angle});
        }
        @xvals = @yvals = ();
        $npts  = ($#coords + 1) /2;
        for ($i=0; $i<$npts; $i++) {
            push(@xvals, $coords[2*$i]);
            push(@yvals, $coords[2*$i+1]);
        }
        $props{$id}{xc} = (&min(@xvals) + &max(@xvals))/2.;
        $props{$id}{yc} = (&min(@yvals) + &max(@yvals))/2.;
    }
}


sub raise_lower {
    my ($canv, $id, $action) = @_;
    my ($bot_id, $item, $next_id, $top_id,
        @ids, @items, @tags,
       );

    @ids = ();
    if ($id =~ /^group_/) {
        @items = Tkx::SplitList($canv->find_withtag($id));
        foreach $item (@items) {
            next if (! defined($props{$item}{type}));
            &end_select($canv, $item, 1);
            push (@ids, $item);
        }
        if ($action eq "bottom") {
            @ids = reverse @ids;
        }
    } else {
        &end_select($canv, $id, 1);
        push (@ids, $id);
    }

    foreach $id (@ids) {
        if ($props{$id}{type} eq "graph" && $action ne "tiptop") {
            $id = "graph" . $id;
        }
        $action = "top" if ($action eq "tiptop");

        if ($action eq "raise") {
            $next_id = $canv->find_above($id);
            @tags    = Tkx::SplitList($canv->itemcget($next_id, -tags));
            if (&list_search("^graph", @tags) > -1) {
                $next_id = $tags[&list_search("^graph", @tags)];
            }
            $canv->raise($id, $next_id) if ($next_id ne "");

        } elsif ($action eq "top") {
            $top_id = $canv->find_above($id);
            if ($top_id ne "") {
                while (($next_id = $canv->find_above($top_id)) ne "") {
                    $top_id = $next_id;
                }
                $canv->raise($id, $top_id);
            }

        } elsif ($action eq "lower") {
            $next_id = $canv->find_below($id);
            @tags    = Tkx::SplitList($canv->itemcget($next_id, -tags));
            if (&list_search("^graph", @tags) > -1) {
                $next_id = $tags[&list_search("^graph", @tags)];
            }
            $canv->lower($id, $next_id) if ($next_id ne "");

        } elsif ($action eq "bottom") {
            $bot_id = $canv->find_below($id);
            if ($bot_id ne "") {
                while (($next_id = $canv->find_below($bot_id)) ne "") {
                    $bot_id = $next_id;
                }
                $canv->lower($id, $bot_id);
            }
        }
    }
}


sub begin_edit {
    my ($X, $Y, $canv, $id) = @_;
    my ($type);

    &end_select($canv, $id, 1);

    $type = $props{$id}{type};
    if ($type eq "text") {
        &edit_text_props($id, $X, $Y);
    } elsif ($type =~ /^(line|polyline|rectangle|diamond|circle|ellipse|polygon)$/) {
        &edit_object_props($id, $X, $Y);
    } elsif ($type eq "graph") {
        &edit_graph_props($id, $X, $Y);
    }
    &reset_bindings;
}


sub duplicate {
    my ($canv, $id) = @_;
    my (
        $ahd1, $ahd2, $ahd3, $anchor, $angle, $arrow, $color, $family,
        $file, $fill, $fillcolor, $flip, $hh, $hw, $i, $ihc, $iho, $img,
        $img_data, $image, $iwc, $iwo, $new_id, $size, $slant, $smooth,
        $text, $type, $underline, $weight, $width, $x, $xc, $y, $yc,

        @coords, @crop,
        %grid_tmp, %profile_tmp,
       );

    &end_select($canv, $id, 1);

    $type   = $props{$id}{type};
    $x      = $props{$id}{x}  +10;
    $y      = $props{$id}{y}  +10;
    $xc     = $props{$id}{xc} +10;
    $yc     = $props{$id}{yc} +10;
    $anchor = $props{$id}{anchor};

    @coords = Tkx::SplitList($canv->coords($id));
    for ($i=0; $i<=$#coords; $i++) {
        $coords[$i] += 10;
    }

    if ($type =~ /^(line|polyline)$/) {
        $color  = $props{$id}{color};
        $width  = $props{$id}{width};
        $arrow  = $props{$id}{arrow};
        $ahd1   = $props{$id}{ahd1};
        $ahd2   = $props{$id}{ahd2};
        $ahd3   = $props{$id}{ahd3};
        $new_id = $canv->create_line(@coords,
                         -fill       => &get_rgb_code($color),
                         -width      => $width,
                         -arrow      => $arrow_type[$arrow],
                         -arrowshape => [ $ahd1, $ahd2, $ahd3 ],
                         -tags       => "keep");
        $props{$new_id}{type}      = $type;
        $props{$new_id}{x}         = $x;
        $props{$new_id}{y}         = $y;
        $props{$new_id}{xc}        = $xc;
        $props{$new_id}{yc}        = $yc;
        $props{$new_id}{anchor}    = $anchor;
        $props{$new_id}{coordlist} = [ @coords ];
        $props{$new_id}{color}     = $color;
        $props{$new_id}{width}     = $width;
        $props{$new_id}{arrow}     = $arrow;
        $props{$new_id}{ahd1}      = $ahd1;
        $props{$new_id}{ahd2}      = $ahd2;
        $props{$new_id}{ahd3}      = $ahd3;
        if ($type eq "polyline") {
            $props{$new_id}{xc_rot}    = $props{$id}{xc_rot} +10;
            $props{$new_id}{yc_rot}    = $props{$id}{yc_rot} +10;
            $props{$new_id}{angle}     = $props{$id}{angle};
            $props{$new_id}{angle_tmp} = $props{$id}{angle};
        }

    } elsif ($type eq "circle") {
        $color     = $props{$id}{color};
        $width     = $props{$id}{width};
        $fill      = $props{$id}{fill};
        $fillcolor = $props{$id}{fillcolor};
        $new_id    = $canv->create_oval(@coords,
                            -outline => &get_rgb_code($color),
                            -width   => $width,
                            -tags    => "keep");
        if ($fill && $fillcolor ne "") {
            $canv->itemconfigure($new_id, -fill => &get_rgb_code($fillcolor));
        } else {
            $canv->itemconfigure($new_id, -fill => "");
        }
        if ($width == 0) {
            $canv->itemconfigure($new_id, -outline => "");
        }
        $props{$new_id}{type}      = $type;
        $props{$new_id}{x}         = $x;
        $props{$new_id}{y}         = $y;
        $props{$new_id}{xc}        = $xc;
        $props{$new_id}{yc}        = $yc;
        $props{$new_id}{anchor}    = $anchor;
        $props{$new_id}{coordlist} = [ @coords ];
        $props{$new_id}{color}     = $color;
        $props{$new_id}{width}     = $width;
        $props{$new_id}{fill}      = $fill;
        $props{$new_id}{fillcolor} = $fillcolor;

    } elsif ($type eq "ellipse") {
        $color     = $props{$id}{color};
        $width     = $props{$id}{width};
        $fill      = $props{$id}{fill};
        $fillcolor = $props{$id}{fillcolor};
        $hw        = $props{$id}{hw};
        $hh        = $props{$id}{hh};
        $angle     = $props{$id}{angle};

        @coords = &make_shape_coords($type, $xc, $yc, $hw, $hh, $angle);
        $new_id = $canv->create_polygon(@coords,
                         -outline => &get_rgb_code($color),
                         -width   => $width,
                         -smooth  => 'false',
                         -tags    => "keep");
        if ($fill && $fillcolor ne "") {
            $canv->itemconfigure($new_id, -fill => &get_rgb_code($fillcolor));
        } else {
            $canv->itemconfigure($new_id, -fill => "");
        }
        if ($width == 0) {
            $canv->itemconfigure($new_id, -outline => "");
        }
        $props{$new_id}{type}      = $type;
        $props{$new_id}{x}         = $x;
        $props{$new_id}{y}         = $y;
        $props{$new_id}{xc}        = $xc;
        $props{$new_id}{yc}        = $yc;
        $props{$new_id}{hw}        = $hw;
        $props{$new_id}{hh}        = $hh;
        $props{$new_id}{anchor}    = $anchor;
        $props{$new_id}{coordlist} = [ @coords ];
        $props{$new_id}{color}     = $color;
        $props{$new_id}{width}     = $width;
        $props{$new_id}{fill}      = $fill;
        $props{$new_id}{fillcolor} = $fillcolor;
        $props{$new_id}{angle}     = $angle;
        $props{$new_id}{angle_tmp} = $angle;
        $props{$new_id}{smooth}    = 0;

    } elsif ($type =~ /^(rectangle|diamond)$/) {
        $color     = $props{$id}{color};
        $width     = $props{$id}{width};
        $fill      = $props{$id}{fill};
        $fillcolor = $props{$id}{fillcolor};
        $smooth    = $props{$id}{smooth};
        $new_id    = $canv->create_polygon(@coords,
                            -outline => &get_rgb_code($color),
                            -width   => $width,
                            -smooth  => $smooth_type[$smooth],
                            -tags    => "keep");
        if ($fill && $fillcolor ne "") {
            $canv->itemconfigure($new_id, -fill => &get_rgb_code($fillcolor));
        } else {
            $canv->itemconfigure($new_id, -fill => "");
        }
        if ($width == 0) {
            $canv->itemconfigure($new_id, -outline => "");
        }
        $props{$new_id}{type}      = $type;
        $props{$new_id}{x}         = $x;
        $props{$new_id}{y}         = $y;
        $props{$new_id}{xc}        = $xc;
        $props{$new_id}{yc}        = $yc;
        $props{$new_id}{anchor}    = $anchor;
        $props{$new_id}{coordlist} = [ @coords ];
        $props{$new_id}{color}     = $color;
        $props{$new_id}{width}     = $width;
        $props{$new_id}{fill}      = $fill;
        $props{$new_id}{fillcolor} = $fillcolor;
        $props{$new_id}{angle}     = $props{$id}{angle};
        $props{$new_id}{angle_tmp} = $props{$id}{angle};
        $props{$new_id}{smooth}    = $smooth;

    } elsif ($type eq "polygon") {
        $color     = $props{$id}{color};
        $width     = $props{$id}{width};
        $fill      = $props{$id}{fill};
        $fillcolor = $props{$id}{fillcolor};
        $new_id    = $canv->create_polygon(@coords,
                            -outline => &get_rgb_code($color),
                            -width   => $width,
                            -tags    => "keep");
        if ($fill && $fillcolor ne "") {
            $canv->itemconfigure($new_id, -fill => &get_rgb_code($fillcolor));
        } else {
            $canv->itemconfigure($new_id, -fill => "");
        }
        if ($width == 0) {
            $canv->itemconfigure($new_id, -outline => "");
        }
        $props{$new_id}{type}      = $type;
        $props{$new_id}{x}         = $x;
        $props{$new_id}{y}         = $y;
        $props{$new_id}{xc}        = $xc;
        $props{$new_id}{yc}        = $yc;
        $props{$new_id}{anchor}    = $anchor;
        $props{$new_id}{coordlist} = [ @coords ];
        $props{$new_id}{color}     = $color;
        $props{$new_id}{width}     = $width;
        $props{$new_id}{fill}      = $fill;
        $props{$new_id}{fillcolor} = $fillcolor;
        $props{$new_id}{angle}     = $props{$id}{angle};
        $props{$new_id}{angle_tmp} = $props{$id}{angle};
        $props{$new_id}{xc_rot}    = $props{$id}{xc_rot} +10;
        $props{$new_id}{yc_rot}    = $props{$id}{yc_rot} +10;

    } elsif ($type eq "text") {
        $text      = $props{$id}{text};
        $color     = $props{$id}{color};
        $angle     = $props{$id}{angle};
        $family    = $props{$id}{family};
        $size      = $props{$id}{size};
        $weight    = $props{$id}{weight};
        $slant     = $props{$id}{slant};
        $underline = $props{$id}{underline};
        $new_id    = $canv->create_text($x, $y,
                            -anchor => $anchor,
                            -text   => $text,
                            -fill   => &get_rgb_code($color),
                            -angle  => $angle,
                            -tags   => "keep",
                            -font   => [-family     => $family,
                                        -size       => $size,
                                        -weight     => $weight,
                                        -slant      => $slant_type[$slant],
                                        -underline  => $underline,
                                        -overstrike => 0,
                                       ]);
        $props{$new_id}{type}      = $type;
        $props{$new_id}{text}      = $text;
        $props{$new_id}{x}         = $x;
        $props{$new_id}{y}         = $y;
        $props{$new_id}{xc}        = $xc;
        $props{$new_id}{yc}        = $yc;
        $props{$new_id}{anchor}    = $anchor;
        $props{$new_id}{coordlist} = [$x, $y];
        $props{$new_id}{color}     = $color;
        $props{$new_id}{family}    = $family;
        $props{$new_id}{size}      = $size;
        $props{$new_id}{weight}    = $weight;
        $props{$new_id}{slant}     = $slant;
        $props{$new_id}{underline} = $underline;
        $props{$new_id}{angle}     = $angle;

        if (&list_match($id, @ind_link_ids) >= 0) {  # id is an independent text link
            push (@ind_link_ids, $new_id);
            $props{$new_id}{src_file}  = $props{$id}{src_file};
            $props{$new_id}{src_type}  = $props{$id}{src_type};
            $props{$new_id}{src_lines} = $props{$id}{src_lines};
            $props{$new_id}{ctype}     = $props{$id}{ctype};
            $props{$new_id}{parm}      = $props{$id}{parm};
            if ($props{$id}{src_type} =~ /^W2 /) {
                $props{$new_id}{byear}     = $props{$id}{byear};
                $props{$new_id}{tz_offset} = $props{$id}{tz_offset};
                $props{$new_id}{seg}       = $props{$id}{seg};
            }
            $props{$new_id}{data_type} = $props{$id}{data_type};
            $props{$new_id}{units}     = $props{$id}{units};
            $props{$new_id}{digits}    = $props{$id}{digits};
            $props{$new_id}{link_tol}  = $props{$id}{link_tol};
            $props{$new_id}{ts_data}   = $props{$id}{ts_data};
        }

    } elsif ($type eq "image") {
        $file  = $props{$id}{file};
        $angle = $props{$id}{angle};
        $flip  = $props{$id}{flip};
        @crop  = @{ $props{$id}{crop} };

        $img = Imager->new;
        $img->read(file => $file) or
                return &pop_up_error($main, "Failed to load $file\n $img->errstr");
        $img = $img->convert(preset => 'addalpha');
        $iwo = $img->getwidth();
        $iho = $img->getheight();
        if ($crop[0] > 0. || $crop[1] > 0. || $crop[2] > 0. || $crop[3] > 0.) {
            $img = $img->crop(left   => &round_to_int($iwo *$crop[0]),
                              right  => &round_to_int($iwo *(1.0 -$crop[1])),
                              top    => &round_to_int($iho *$crop[2]),
                              bottom => &round_to_int($iho *(1.0 -$crop[3])));
        }
        $iwc = $img->getwidth();
        $ihc = $img->getheight();
        if ($iwc != $props{$id}{iw}) {
            $img = $img->scale(xpixels => $props{$id}{iw});
        }
        if ($flip ne "none") {
            $img->flip(dir => $flip);
        }
        $img->write(data => \$img_data, type => 'png');
        $image = Tkx::image_create_photo(-data => $img_data);
        $new_id = $canv->create_image($xc, $yc,
                                      -anchor => 'center',
                                      -image  => $image,
                                      -tags   => "keep",
                                      -state  => 'hidden');
        $props{$new_id}{type}      = $type;
        $props{$new_id}{x}         = $x;
        $props{$new_id}{y}         = $y;
        $props{$new_id}{xc}        = $xc;
        $props{$new_id}{yc}        = $yc;
        $props{$new_id}{anchor}    = $anchor;
        $props{$new_id}{coordlist} = [$xc, $yc];
        $props{$new_id}{iw}        = Tkx::image_width($image);
        $props{$new_id}{ih}        = Tkx::image_height($image);
        $props{$new_id}{iwo}       = $iwo;
        $props{$new_id}{iho}       = $iho;
        $props{$new_id}{iwc}       = $iwc;
        $props{$new_id}{ihc}       = $ihc;
        $props{$new_id}{crop}      = [ @crop ];
        $props{$new_id}{file}      = $file;
        $props{$new_id}{image}     = $image;
        $props{$new_id}{idata}     = $img_data;
        $props{$new_id}{angle}     = $angle;
        $props{$new_id}{flip}      = $flip;
        if ($angle != 0) {
            $img = $img->rotate(degrees => -1 *$angle);
            $img->write(data => \$img_data, type => 'png');
            $image = Tkx::image_create_photo(-data => $img_data);
            $canv->itemconfigure($new_id, -image => $image);
        }
        $canv->itemconfigure($new_id, -state => 'normal');

    } elsif ($type eq "graph") {
        $color  = $props{$id}{color};
        $width  = $props{$id}{width};
        $new_id = $canv->create_rectangle(@coords,
                         -outline => &get_rgb_code($color),
                         -width   => $width,
                         -fill    => "",
                         -tags    => "keep");
        $props{$new_id}{type}      = $type;
        $props{$new_id}{meta}      = $props{$id}{meta};
        $props{$new_id}{x}         = $x;
        $props{$new_id}{y}         = $y;
        $props{$new_id}{xc}        = $xc;
        $props{$new_id}{yc}        = $yc;
        $props{$new_id}{anchor}    = $anchor;
        $props{$new_id}{coordlist} = [ @coords ];
        $props{$new_id}{oldcoords} = [ @coords ];
        $props{$new_id}{color}     = $color;
        $props{$new_id}{width}     = $width;
        $props{$new_id}{fill}      = $props{$id}{fill};
        $props{$new_id}{data}      = 1;
        $props{$new_id}{gnum}      = ++$graph_num;
        $canv->addtag("graph" . $new_id, withtag => $new_id);

        %profile_tmp               = %{ $gr_props{$id} };
        $gr_props{$new_id}         =  { %profile_tmp   };
        $gr_props{$new_id}{redraw} = 1;

        if ($props{$new_id}{meta} =~
              /data_profile|w2_profile|w2_tdmap|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone|time_series/) {
            push (@animate_ids, $new_id);
        }

        if ($props{$new_id}{meta} =~ /data_profile/) {
            $props{$new_id}{files}      = 1;
            $props{$new_id}{src_file}   = $props{$id}{src_file};
            $props{$new_id}{parm}       = $props{$id}{parm};
            $props{$new_id}{parm_units} = $props{$id}{parm_units};
            $props{$new_id}{prof_type}  = $props{$id}{prof_type};
            if ($props{$id}{prof_type} =~ /difference/i) {
                $props{$new_id}{dref_type} = $props{$id}{dref_type};
                if ($props{$id}{dref_type} =~ /Constant/i) {
                    $props{$new_id}{dref_val} = $props{$id}{dref_val};
                } else {
                    $props{$new_id}{dref_file}  = $props{$id}{dref_file};
                    $props{$new_id}{dref_ftype} = $props{$id}{dref_ftype};
                    $props{$new_id}{dref_lines} = $props{$id}{dref_lines};
                    $props{$new_id}{dref_parm}  = $props{$id}{dref_parm};
                    $props{$new_id}{dref_ctype} = $props{$id}{dref_ctype};
                    $props{$new_id}{dref_tol}   = $props{$id}{dref_tol};
                    if ($props{$id}{dref_ftype} =~ /^W2 /) {
                        $props{$new_id}{dref_byear} = $props{$id}{dref_byear};
                        $props{$new_id}{dref_tzoff} = $props{$id}{dref_tzoff};
                    }
                }
            }
            &make_data_profile($canv, $new_id, 1);

        } elsif ($props{$new_id}{meta} =~ /w2_profile/) {
            %grid_tmp                   = %{ $grid{$id} };
            $grid{$new_id}              = { %grid_tmp };
            $props{$new_id}{con_file}   = $props{$id}{con_file};
            $props{$new_id}{bth_file}   = $props{$id}{bth_file};
            $props{$new_id}{src_type}   = $props{$id}{src_type};
            $props{$new_id}{src_file}   = $props{$id}{src_file};
            $props{$new_id}{src_lines}  = $props{$id}{src_lines};
            $props{$new_id}{tplot}      = $props{$id}{tplot};
            $props{$new_id}{parm}       = $props{$id}{parm};
            $props{$new_id}{parm_div}   = $props{$id}{parm_div};
            $props{$new_id}{parm_units} = $props{$id}{parm_units};
            $props{$new_id}{ctype}      = $props{$id}{ctype};
            $props{$new_id}{seg}        = $props{$id}{seg};
            $props{$new_id}{byear}      = $props{$id}{byear};
            $props{$new_id}{tz_offset}  = $props{$id}{tz_offset};
            $props{$new_id}{jd_skip}    = $props{$id}{jd_skip};
            $props{$new_id}{files}      = 1;
            $props{$new_id}{link_id}    = $props{$id}{link_id} if ($props{$id}{meta} eq "w2_profile_matrix");
            if (defined($props{$id}{ref_file})) {
                $props{$new_id}{ref_file}  = $props{$id}{ref_file};
                $props{$new_id}{ref_ctype} = $props{$id}{ref_ctype};
                $props{$new_id}{ref_tol}   = $props{$id}{ref_tol};
                $props{$new_id}{ref_color} = $props{$id}{ref_color};
                $props{$new_id}{ref_size}  = $props{$id}{ref_size};
                $props{$new_id}{ref_linew} = $props{$id}{ref_linew};
                $props{$new_id}{ref_hide}  = $props{$id}{ref_hide};
            }
            &make_w2_profile($canv, $new_id, 1);

        } elsif ($props{$new_id}{meta} =~ /w2_slice/) {
            %grid_tmp                   = %{ $grid{$id} };
            $grid{$new_id}              = { %grid_tmp };
            $props{$new_id}{con_file}   = $props{$id}{con_file};
            $props{$new_id}{src_type}   = $props{$id}{src_type};
            $props{$new_id}{seg_list}   = $props{$id}{seg_list};
            $props{$new_id}{wb_list}    = $props{$id}{wb_list};
            $props{$new_id}{parm}       = $props{$id}{parm};
            $props{$new_id}{parm_div}   = $props{$id}{parm_div};
            $props{$new_id}{parm_units} = $props{$id}{parm_units};
            $props{$new_id}{ctype}      = $props{$id}{ctype};
            $props{$new_id}{byear}      = $props{$id}{byear};
            $props{$new_id}{tz_offset}  = $props{$id}{tz_offset};
            $props{$new_id}{jd_skip}    = $props{$id}{jd_skip};
            $props{$new_id}{dt_limits}  = $props{$id}{dt_limits};
            $props{$new_id}{files}      = 1;
            if ($props{$id}{src_type} =~ /Contour/i) {
                $props{$new_id}{tecplot}   = $props{$id}{tecplot};
                $props{$new_id}{cpl_lines} = $props{$id}{cpl_lines};
                $props{$new_id}{cpl_files} = $props{$id}{cpl_files};
                $props{$new_id}{bth_files} = $props{$id}{bth_files};
            } elsif ($props{$id}{src_type} =~ /Vector/i) {
                $props{$new_id}{w2l_file}  = $props{$id}{w2l_file};
                $props{$new_id}{bth_files} = $props{$id}{bth_files};
            }
            if ($props{$new_id}{dt_limits}) {
                $props{$new_id}{dt_begin}  = $props{$id}{dt_begin};
                $props{$new_id}{dt_end}    = $props{$id}{dt_end};
            }
            &make_w2_slice($canv, $new_id, 1);

        } elsif ($props{$new_id}{meta} =~ /w2_tdmap/) {
            %grid_tmp                   = %{ $grid{$id} };
            $grid{$new_id}              = { %grid_tmp };
            $props{$new_id}{con_file}   = $props{$id}{con_file};
            $props{$new_id}{src_type}   = $props{$id}{src_type};
            $props{$new_id}{seg_list}   = $props{$id}{seg_list};
            $props{$new_id}{wb_list}    = $props{$id}{wb_list};
            $props{$new_id}{map_type}   = $props{$id}{map_type};
            $props{$new_id}{parm}       = $props{$id}{parm};
            $props{$new_id}{parm_sav}   = $props{$id}{parm_sav};
            $props{$new_id}{parm_div}   = $props{$id}{parm_div};
            $props{$new_id}{pdiv_sav}   = $props{$id}{pdiv_sav};
            $props{$new_id}{parm_units} = $props{$id}{parm_units};
            $props{$new_id}{prof_stat}  = $props{$id}{prof_stat};
            $props{$new_id}{ctype}      = $props{$id}{ctype};
            $props{$new_id}{byear}      = $props{$id}{byear};
            $props{$new_id}{tz_offset}  = $props{$id}{tz_offset};
            $props{$new_id}{jd_skip}    = $props{$id}{jd_skip};
            $props{$new_id}{files}      = 1;
            if ($props{$id}{src_type} =~ /Contour/i) {
                $props{$new_id}{tecplot}   = $props{$id}{tecplot};
                $props{$new_id}{cpl_lines} = $props{$id}{cpl_lines};
                $props{$new_id}{cpl_files} = $props{$id}{cpl_files};
                $props{$new_id}{bth_files} = $props{$id}{bth_files};
            } elsif ($props{$id}{src_type} =~ /Vector/i) {
                $props{$new_id}{w2l_file}  = $props{$id}{w2l_file};
                $props{$new_id}{bth_files} = $props{$id}{bth_files};
            } elsif ($props{$id}{src_type} =~ /RiverCon/i) {
                $props{$new_id}{br_list}   = $props{$id}{br_list};
                $props{$new_id}{riv_lines} = $props{$id}{riv_lines};
                $props{$new_id}{riv_files} = $props{$id}{riv_files};
                $props{$new_id}{bth_files} = $props{$id}{bth_files};
            } elsif ($props{$id}{src_type} =~ /SurfTemp|VolTemp|FlowTemp/i) {
                $props{$new_id}{src_file}  = $props{$id}{src_file};
                $props{$new_id}{src_lines} = $props{$id}{src_lines};
                $props{$new_id}{bth_files} = $props{$id}{bth_files};
            }
            if ($props{$id}{map_type} =~ /^(parmdiff|filediff)$/) {
                $props{$new_id}{src_type2} = $props{$id}{src_type2};
                $props{$new_id}{parm2}     = $props{$id}{parm2};
                $props{$new_id}{parm2_sav} = $props{$id}{parm2_sav};
                $props{$new_id}{parm2_div} = $props{$id}{parm2_div};
                $props{$new_id}{pdiv2_sav} = $props{$id}{pdiv2_sav};
                $props{$new_id}{ctype2}    = $props{$id}{ctype2};
                $props{$new_id}{data2}     = 1;
                if ($props{$id}{src_type2} =~ /Contour/i) {
                    $props{$new_id}{tecplot2}   = $props{$id}{tecplot2};
                    $props{$new_id}{cpl_lines2} = $props{$id}{cpl_lines2};
                    $props{$new_id}{cpl_files2} = $props{$id}{cpl_files2};
                } elsif ($props{$id}{src_type2} =~ /Vector/i) {
                    $props{$new_id}{w2l_file2}  = $props{$id}{w2l_file2};
                } elsif ($props{$id}{src_type2} =~ /RiverCon/i) {
                    $props{$new_id}{br_list2}   = $props{$id}{br_list2};
                    $props{$new_id}{riv_lines2} = $props{$id}{riv_lines2};
                    $props{$new_id}{riv_files2} = $props{$id}{riv_files2};
                } elsif ($props{$id}{src_type2} =~ /SurfTemp|VolTemp|FlowTemp/i) {
                    $props{$new_id}{src_file2}  = $props{$id}{src_file2};
                    $props{$new_id}{src_lines2} = $props{$id}{src_lines2};
                }
                if ($props{$id}{map_type} eq "filediff") {
                    $props{$new_id}{match_tol} = $props{$id}{match_tol};
                }
            }
            &make_w2_tdmap($canv, $new_id, 1);

        } elsif ($props{$new_id}{meta} =~ /w2_outflow/) {
            %grid_tmp                   = %{ $grid{$id} };
            $grid{$new_id}              = { %grid_tmp };
            $props{$new_id}{con_file}   = $props{$id}{con_file};
            $props{$new_id}{bth_file}   = $props{$id}{bth_file};
            $props{$new_id}{qla_file}   = $props{$id}{qla_file};
            $props{$new_id}{qla_lines}  = $props{$id}{qla_lines};
            $props{$new_id}{seg}        = $props{$id}{seg};
            $props{$new_id}{byear}      = $props{$id}{byear};
            $props{$new_id}{tz_offset}  = $props{$id}{tz_offset};
            $props{$new_id}{jd_skip}    = $props{$id}{jd_skip};
            $props{$new_id}{add_parm}   = $props{$id}{add_parm};
            $props{$new_id}{files}      = 1;
            if ($props{$id}{add_parm}) {
                $props{$new_id}{src_type}   = $props{$id}{src_type};
                $props{$new_id}{src_file}   = $props{$id}{src_file};
                $props{$new_id}{src_lines}  = $props{$id}{src_lines};
                $props{$new_id}{tplot}      = $props{$id}{tplot};
                $props{$new_id}{parm}       = $props{$id}{parm};
                $props{$new_id}{parm_div}   = $props{$id}{parm_div};
                $props{$new_id}{parm_units} = $props{$id}{parm_units};
                $props{$new_id}{parm_ctype} = $props{$id}{parm_ctype};
                $props{$new_id}{parm_skip}  = $props{$id}{parm_skip};
                $props{$new_id}{match_tol}  = $props{$id}{match_tol};
            }
            &make_w2_outflow($canv, $new_id, 1);

        } elsif ($props{$new_id}{meta} =~ /w2_wlevels/) {
            %grid_tmp                  = %{ $grid{$id} };
            $grid{$new_id}             = { %grid_tmp };
            $props{$new_id}{con_file}  = $props{$id}{con_file};
            $props{$new_id}{src_type}  = $props{$id}{src_type};
            $props{$new_id}{seg_list}  = $props{$id}{seg_list};
            $props{$new_id}{wb_list}   = $props{$id}{wb_list};
            $props{$new_id}{byear}     = $props{$id}{byear};
            $props{$new_id}{tz_offset} = $props{$id}{tz_offset};
            $props{$new_id}{jd_skip}   = $props{$id}{jd_skip};
            $props{$new_id}{extra_chk} = $props{$id}{extra_chk};
            $props{$new_id}{files}     = 1;
            if ($props{$id}{src_type} =~ /Contour/i) {
                $props{$new_id}{tecplot}   = $props{$id}{tecplot};
                $props{$new_id}{cpl_lines} = $props{$id}{cpl_lines};
                $props{$new_id}{cpl_files} = $props{$id}{cpl_files};
                $props{$new_id}{bth_files} = $props{$id}{bth_files};
            } elsif ($props{$id}{src_type} =~ /Vector/i) {
                $props{$new_id}{w2l_file}  = $props{$id}{w2l_file};
                $props{$new_id}{bth_files} = $props{$id}{bth_files};
            } elsif ($props{$id}{src_type} =~ /Water Level/i) {
                $props{$new_id}{wl_file}   = $props{$id}{wl_file};
                $props{$new_id}{wl_lines}  = $props{$id}{wl_lines};
                $props{$new_id}{bth_files} = $props{$id}{bth_files};
            }
            &make_w2_wlevels($canv, $new_id, 1);

        } elsif ($props{$new_id}{meta} eq "vert_wd_zone") {
            $props{$new_id}{files}     = 1;
            $props{$new_id}{wt_file}   = $props{$id}{wt_file};
            $props{$new_id}{wd_alg}    = $props{$id}{wd_alg};
            $props{$new_id}{flow_file} = $props{$id}{flow_file};
            $props{$new_id}{bth_file}  = $props{$id}{bth_file};
            $props{$new_id}{seg}       = $props{$id}{seg};
            $props{$new_id}{elbot}     = $props{$id}{elbot};
            $props{$new_id}{wt_units}  = $props{$id}{wt_units};
            if ($props{$id}{wd_alg} eq "Libby Dam") {
                $props{$new_id}{lbc_file} = $props{$id}{lbc_file};
            }
            &make_wd_zone($canv, $new_id, 1);

        } elsif ($props{$new_id}{meta} eq "linked_time_series") {
            $props{$new_id}{link_id}  = $props{$id}{link_id};
            $props{$new_id}{ts_parms} = $props{$id}{ts_parms};
            if (defined($props{$id}{add_ts_parms})) {
                $props{$new_id}{add_ts_parms} = $props{$id}{add_ts_parms};
            }
            &make_ts_graph($canv, $new_id, 1);

        } elsif ($props{$new_id}{meta} eq "time_series") {
            $props{$new_id}{ts_parms}     = $props{$id}{ts_parms};
            $props{$new_id}{add_ts_parms} = $props{$id}{add_ts_parms};
            &make_ts_graph($canv, $new_id, 1);
        }
    }

#   Take care of links
    if ($type =~ /^(text|circle|ellipse|rectangle|diamond|polygon)$/
              && defined($link_props{$id}{id}) && $link_props{$id}{form} ne "stat") {
        $link_props{$new_id}{id}     = $link_props{$id}{id};
        $link_props{$new_id}{gnum}   = $link_props{$id}{gnum};
        $link_props{$new_id}{type}   = $link_props{$id}{type};
        $link_props{$new_id}{outlet} = $link_props{$id}{outlet};
        $link_props{$new_id}{form}   = $link_props{$id}{form};
        $link_props{$new_id}{units}  = $link_props{$id}{units};
        $link_props{$new_id}{digits} = $link_props{$id}{digits};

        $canv->addtag("link_gr" . $link_props{$id}{id}, withtag => $new_id);
    }
    if ($type eq "text" && defined($link_props{$id}{id})
                        && $link_props{$id}{form} eq "stat") {
        $link_props{$new_id}{id}     = $link_props{$id}{id};
        $link_props{$new_id}{gnum}   = $link_props{$id}{gnum};
        $link_props{$new_id}{type}   = $link_props{$id}{type};
        $link_props{$new_id}{form}   = $link_props{$id}{form};
        $link_props{$new_id}{tol}    = $link_props{$id}{tol};
        $link_props{$new_id}{interp} = $link_props{$id}{interp};
        $link_props{$new_id}{digits} = $link_props{$id}{digits};

        $canv->addtag("link_gr" . $link_props{$id}{id}, withtag => $new_id);
    }

#   Place the duplicate
    &begin_move($canv, $new_id, "");
}


sub object_kill {
    my ($canv, $id) = @_;
    my (
        $datemax, $datemin, $first, $i, $id0, $item, $keep_anim_menu,
        $n, $redo_dates, $ts_present,
        @cpl_files, @items, @mydates, @wbs,
        %pdata,
       );

    if ($props{$id}{type} eq "graph") {
        $canv->delete("graph" . $id);
        if (&list_match($id, @animate_ids) >= 0) {
            splice(@animate_ids, &list_match($id, @animate_ids), 1);
        }
        if ($props{$id}{meta} eq "vert_wd_zone") {
            if ($props{$id}{wd_alg} eq "Libby Dam") {
                if ($gr_props{$id}{bh_show} && ! $gr_props{$id}{bh_docked}) {
                    $canv->delete("graph" . $id . "_openBH");
                }
            }
        }
        delete $gr_props{$id};

#       Delete any associated links
        @items = Tkx::SplitList($canv->find_withtag("link_gr" . $id));
        if ($#items >= 0) {
            foreach $item (@items) {
                delete $props{$item};
                delete $link_props{$item};
            }
            $canv->delete("link_gr" . $id);
        }

#       Delete any associated linked time-series graphs
        @items = Tkx::SplitList($canv->find_withtag("tslink_gr" . $id));
        if ($#items >= 0) {
            foreach $item (@items) {
                $canv->delete("graph" . $item);
                if (&list_match($item, @animate_ids) >= 0) {
                    splice(@animate_ids, &list_match($item, @animate_ids), 1);
                }
                delete $props{$item};
                delete $gr_props{$item};
            }
        }
        if ($use_GS) {
            $keep_anim_menu = 0;
            $export_menu->entryconfigure(3, -state => 'disabled');
            for ($i=0; $i<=$#animate_ids; $i++) {
                if ($props{$animate_ids[$i]}{meta}
                       =~ /^(data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)$/) {
                    $export_menu->entryconfigure(3, -state => 'normal');
                    $keep_anim_menu = 1;
                    last;
                }
            }
            if (! $keep_anim_menu && defined($animate_tb) && Tkx::winfo_exists($animate_tb)) {
                if ($animate_tb->g_wm_title() eq "Animation toolbar") {
                    $animate_tb->g_destroy();
                    undef $animate_tb;
                }
            }
        }

#       Determine whether any animated graphs are present, and adjust the preferences menu
        $pref_menu->entryconfigure(0, -state => 'disabled');
        if (@animate_ids && $#animate_ids >= 0) {
            foreach $item (@animate_ids) {
                if ($props{$item}{meta}
                        =~ /^(data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)$/) {
                    $pref_menu->entryconfigure(0, -state => 'normal');
                    last;
                }
            }
        }

#       Remove the Graph Properties menu, if present
        if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
            if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
                $graph_props_menu->g_destroy();
                undef $graph_props_menu;
            }
        }

#       Remove the Object Information box, if present
        if (defined($object_infobox) && Tkx::winfo_exists($object_infobox)) {
            if ($object_infobox->g_wm_title() =~ /Object Info/) {
                $object_infobox->g_destroy();
                undef $object_infobox;
            }
        }

#       Reconstruct the @dates array, if needed
        if ($props{$id}{meta} =~ /^(data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)$/) {
            $redo_dates = 0;
            $id0 = -1;
            for ($i=0; $i<=$#animate_ids; $i++) {
                if ($props{$animate_ids[$i]}{meta}
                       =~ /^(data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)$/) {
                    $id0 = $animate_ids[$i];
                    last;
                }
            }
            if ($id0 == -1) {        # No animated graphs left.  Remove any vertical datelines.
                @dates = ();
                for ($i=0; $i<=$#animate_ids; $i++) {
                    $id0 = $animate_ids[$i];
                    if ($props{$id0}{meta} =~ /time_series/) {
                        $canv->delete("graph" . $id0 . "_dateline");
                    } elsif ($props{$id0}{meta} =~ /profile_cmap/) {
                        $canv->delete("graph" . $id0 . "_colorMapDateline");
                    }
                }
            } else {
                for ($i=0; $i<=$#animate_ids; $i++) {
                    $item = $animate_ids[$i];
                    next if ($props{$item}{meta}
                                !~ /^(data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)$/);
                    if ($props{$id}{meta} eq "data_profile") {
                        if ($props{$item}{meta} =~ /w2_profile|w2_slice|w2_outflow|w2_wlevels/ ||
                            ($props{$item}{meta} eq "data_profile"
                              && $props{$item}{src_file} ne $props{$id}{src_file}) ||
                            ($props{$item}{meta} eq "vert_wd_zone"
                              && $props{$item}{wt_file} ne $props{$id}{src_file})) {
                            $redo_dates = 1;
                            last;
                        }
                    } elsif ($props{$id}{meta} eq "vert_wd_zone") {
                        if ($props{$item}{meta} =~ /w2_profile|w2_slice|w2_outflow|w2_wlevels/ ||
                            ($props{$item}{meta} eq "vert_wd_zone"
                              && $props{$item}{wt_file} ne $props{$id}{wt_file}) ||
                            ($props{$item}{meta} eq "data_profile"
                              && $props{$item}{src_file} ne $props{$id}{wt_file})) {
                            $redo_dates = 1;
                            last;
                        }
                    } elsif ($props{$id}{meta} eq "w2_profile") {
                        if ($props{$item}{meta} =~ /data_profile|vert_wd_zone|w2_outflow/ ||
                            ($props{$item}{meta} eq "w2_profile"
                              && ($props{$item}{src_file}  ne $props{$id}{src_file}  ||
                                  $props{$item}{byear}     != $props{$id}{byear}     ||
                                  $props{$item}{tz_offset} ne $props{$id}{tz_offset} ||
                                  $props{$item}{jd_skip}   != $props{$id}{jd_skip})) ||
                            ($props{$item}{meta} eq "w2_slice"
                              && $props{$item}{dt_limits})) {
                            $redo_dates = 1;
                            last;
                        }
                        if ($props{$item}{meta} =~ /w2_slice|w2_wlevels/) {
                            if ($props{$item}{src_type}      ne $props{$id}{src_type}
                                 || $props{$item}{byear}     != $props{$id}{byear}
                                 || $props{$item}{tz_offset} ne $props{$id}{tz_offset}
                                 || $props{$item}{jd_skip}   != $props{$id}{jd_skip}) {
                                $redo_dates = 1;
                                last;
                            } elsif ($props{$item}{src_type} =~ /Contour/i) {
                                @wbs        = split(/,/, $props{$item}{wb_list});
                                @cpl_files  = @{ $props{$item}{cpl_files} };
                                $redo_dates = 1;
                                for ($n=0; $n<=$#wbs; $n++) {
                                    if ($cpl_files[$n] eq $props{$id}{src_file}) {
                                        $redo_dates = 0;
                                        last;
                                    }
                                }
                                last if ($redo_dates);
                            } elsif ($props{$item}{src_type} =~ /Vector/i) {
                                if ($props{$item}{w2l_file} ne $props{$id}{src_file}) {
                                    $redo_dates = 1;
                                    last;
                                }
                            }
                            if ($props{$item}{meta} eq "w2_slice") {
                                if ($props{$item}{dt_limits}) {
                                    $redo_dates = 1;
                                    last;
                                }
                            }
                        }
                    } elsif ($props{$id}{meta} =~ /w2_slice|w2_wlevels/) {
                        if ($props{$item}{meta} =~ /data_profile|vert_wd_zone|w2_outflow/) {
                            $redo_dates = 1;
                            last;
                        }
                        if ($props{$id}{meta} eq "w2_slice") {
                            if ($props{$id}{dt_limits}) {
                                $redo_dates = 1;
                                last;
                            }
                        }
                        if ($props{$item}{meta} eq "w2_slice") {
                            if ($props{$item}{dt_limits}) {
                                $redo_dates = 1;
                                last;
                            }
                        }
                        if ($props{$item}{meta} =~ /w2_slice|w2_wlevels/) {
                            if ($props{$item}{con_file}      ne $props{$id}{con_file}
                                 || $props{$item}{src_type}  ne $props{$id}{src_type}
                                 || $props{$item}{byear}     != $props{$id}{byear}
                                 || $props{$item}{tz_offset} ne $props{$id}{tz_offset}
                                 || $props{$item}{jd_skip}   != $props{$id}{jd_skip}) {
                                $redo_dates = 1;
                                last;
                            }
                        } elsif ($props{$item}{meta} eq "w2_profile") {
                            if ($props{$item}{src_type}      ne $props{$id}{src_type}
                                 || $props{$item}{byear}     != $props{$id}{byear}
                                 || $props{$item}{tz_offset} ne $props{$id}{tz_offset}
                                 || $props{$item}{jd_skip}   != $props{$id}{jd_skip}) {
                                $redo_dates = 1;
                                last;
                            } elsif ($props{$item}{src_type} =~ /Contour/i) {
                                @wbs        = split(/,/, $props{$id}{wb_list});
                                @cpl_files  = @{ $props{$id}{cpl_files} };
                                $redo_dates = 1;
                                for ($n=0; $n<=$#wbs; $n++) {
                                    if ($cpl_files[$n] eq $props{$item}{src_file}) {
                                        $redo_dates = 0;
                                        last;
                                    }
                                }
                                last if ($redo_dates);
                            } elsif ($props{$item}{src_type} =~ /Vector/i) {
                                if ($props{$item}{src_file} ne $props{$id}{w2l_file}) {
                                    $redo_dates = 1;
                                    last;
                                }
                            }
                        }
                    } elsif ($props{$id}{meta} eq "w2_outflow") {
                        if ($props{$item}{meta}
                                =~ /data_profile|vert_wd_zone|w2_profile|w2_slice|w2_wlevels/ ||
                            ($props{$item}{meta} eq "w2_outflow"
                              && ($props{$item}{qla_file}  ne $props{$id}{qla_file}  ||
                                  $props{$item}{byear}     != $props{$id}{byear}     ||
                                  $props{$item}{tz_offset} ne $props{$id}{tz_offset} ||
                                  $props{$item}{jd_skip}   != $props{$id}{jd_skip}))) {
                            $redo_dates = 1;
                            last;
                        }
                    }
                }
                &rebuild_datelist if ($redo_dates);
            }
        }

#       Reset the min and max dates for colormaps, if needed
        if ($props{$id}{meta} =~ /data_profile_cmap|w2_profile_cmap|w2_tdmap/) {
            $first = 1;
            for ($i=0; $i<=$#animate_ids; $i++) {
                $item = $animate_ids[$i];
                next if ($props{$item}{meta} !~ /data_profile_cmap|w2_profile_cmap|w2_tdmap/);
                if ($props{$item}{meta} eq "data_profile_cmap") {
                    %pdata = %{ $gr_props{$item}{pdata} };
                } elsif ($props{$item}{meta} eq "w2_profile_cmap") {
                    %pdata = %{ $gr_props{$item}{parm_data} };
                } elsif ($props{$item}{meta} eq "w2_tdmap") {
                    %pdata = %{ $gr_props{$item}{td_data} };
                }
                @mydates = sort keys %pdata;
                $datemin = substr($mydates[0],0,8);
                $datemax = substr($mydates[$#mydates],0,8);
                $cmap_datemin = $datemin if ($first || $datemin < $cmap_datemin);
                $cmap_datemax = $datemax if ($first || $datemax > $cmap_datemax);
                $first = 0;
                undef %pdata;
            }
        }

#       Reset the min and max dates for time-series graphs, if needed
        if ($props{$id}{meta} =~ /time_series/) {
            undef $ts_datemin;
            undef $ts_datemax;
            $ts_present = 0;
            @items = Tkx::SplitList($canv->find_withtag("keep"));
            if ($#items >= 0) {
                $first = 1;
                foreach $item (@items) {
                    next if ($props{$item}{type} ne "graph");
                    next if ($props{$item}{meta} !~ /time_series/);
                    $ts_present = 1;
                    ($datemin, $datemax, undef, undef) = &find_ts_limits($item);
                    if ($datemin != -999) {
                        $ts_datemin = $datemin if ($first || $datemin < $ts_datemin);
                        $ts_datemax = $datemax if ($first || $datemax > $ts_datemax);
                        $first = 0;
                    }
                }
            }

#           Remove the zoom toolbar if no time-series graphs are present
            if (! $ts_present && defined($zoom_tb) && Tkx::winfo_exists($zoom_tb)) {
                if ($zoom_tb->g_wm_title() eq "Zoom toolbar") {
                    $zoom_tb->g_destroy();
                    undef $zoom_tb;
                }
            }
        }

#   Not a graph object
    } else {
        $canv->delete($id);
        delete $link_props{$id} if (defined($link_props{$id}));
        if (@ind_link_ids && &list_match($id, @ind_link_ids) >= 0) {  # independent text link
            splice(@ind_link_ids, &list_match($id, @ind_link_ids), 1);
        }
    }

    $canv->delete("working");
    delete $props{$id};
    undef $old_id if (defined($old_id));
    &reset_bindings;
}


################################################################################
#
# Image placement and rotation
#
################################################################################

sub draw_image {
    my ($file, $id, $ih, $iho, $image, $img, $img_data, $iw, $iwo, $x, $y);

    &forget_drawing('');

    $file = Tkx::tk___getOpenFile(
                 -parent           => $main,
                 -title            => "Open Image File",
                 -initialdir       => abs_path(),
                 -defaultextension => ".png",
                 -filetypes =>
                 [ ['All image formats',
                                 ['.bmp','.gif','.jpg','.jpeg','.png',
                                  '.ppm','.tga','.tif','.tiff']],
                   ['Win32 bitmaps', '.bmp'],
                   ['Graphics Interchange Format files', '.gif'],
                   ['Joint Photographic Experts Group files', ['.jpg','.jpeg']],
                   ['Portable Network Graphics files', '.png'],
                   ['Unix portable pixmaps', '.ppm'],
                   ['Targa images', '.tga'],
                   ['Tagged Image Format files', ['.tif','.tiff']],
                 ],
               );
    if (! defined($file) || $file eq "") {
        &reset_bindings;
        return;
    }
    $file = File::Spec->rel2abs($file);
    $img = Imager->new;
    $img->read(file => $file) or
            return &pop_up_error($main, "Failed to load $file\n $img->errstr");
    $img = $img->convert(preset => 'addalpha');
    $iwo = $img->getwidth();
    $iho = $img->getheight();

#   Resize if original image is larger than canvas
    if ($iwo > $canvas_width || $iho > $canvas_height) {
        if ($iwo /$canvas_width >= $iho /$canvas_height) {
            $img = $img->scale(xpixels => &round_to_int($canvas_width *0.8));
        } else {
            $img = $img->scale(ypixels => &round_to_int($canvas_height *0.8));
        }

#   Otherwise, invoke scale function to help fill in alpha channel
    } else {
        $img = $img->scale(xpixels => $iwo);
    }

    $iw = $img->getwidth();
    $ih = $img->getheight();
    $x  = $canvas_width/2  -$iw/2;
    $y  = $canvas_height/2 -$ih/2;
    $img->write(data => \$img_data, type => 'png');
    $image = Tkx::image_create_photo(-data => $img_data);
    $id = $canvas->create_image($x, $y,
                                -anchor => 'center',
                                -image  => $image,
                                -tags   => "working",
                                -state  => 'hidden');
    $props{$id}{type}   = "image";
    $props{$id}{x}      = $x;
    $props{$id}{y}      = $y;
    $props{$id}{anchor} = 'nw';
    $props{$id}{iw}     = $iw;
    $props{$id}{ih}     = $ih;
    $props{$id}{iwo}    = $iwo;
    $props{$id}{iho}    = $iho;
    $props{$id}{iwc}    = $iwo;
    $props{$id}{ihc}    = $iho;
    $props{$id}{crop}   = [ 0.0, 0.0, 0.0, 0.0 ];
    $props{$id}{file}   = $file;
    $props{$id}{image}  = $image;
    $props{$id}{idata}  = $img_data;
    $props{$id}{angle}  = 0;
    $props{$id}{flip}   = "none";

    &find_rect_from_text_or_image($canvas, $id);  # set xc, yc
    $props{$id}{coordlist} = [$props{$id}{xc}, $props{$id}{yc}];

    $canvas->coords($id, $props{$id}{xc}, $props{$id}{yc});
    $canvas->itemconfigure($id, -state => 'normal');

    $canvas->g_bind("<Shift-Motion>", [ \&move_object, Tkx::Ev("%x","%y"), $canvas, $id, $x, $y, "", 1 ]);
    $canvas->g_bind("<Motion>",       [ \&move_object, Tkx::Ev("%x","%y"), $canvas, $id, $x, $y, "", 0 ]);
    $canvas->g_bind("<Button-1>",     [ \&end_place_image, $canvas, $id ]);
    $canvas->g_bind("<Button-3>",     [ \&forget_drawing, $id ]);
}


sub end_place_image {
    my ($canv, $id) = @_;

    $props{$id}{coordlist} = [ Tkx::SplitList($canv->coords($id)) ];
    $canv->dtag("working");
    $canv->itemconfigure($id, -tags => "keep");
    &reset_bindings;
}


sub begin_resize_image {
    my ($canv, $id) = @_;
    my ($box_id, $xo, $yo,
        @coords,
       );

    &end_select($canv, $id, 1);

    $xo = $props{$id}{x};
    $yo = $props{$id}{y};
    $canv->configure(-cursor => $cursor_draw);

    &make_crosshair($xo, $yo, $canv, $props{$id}{angle});
    $props{$id}{angle_tmp} = $props{$id}{angle};

    $canv->create_rectangle($xo-2, $yo-2, $xo+2, $yo+2,
                 -outline => &get_rgb_code($anchor_line_color),
                 -width   => 1,
                 -fill    => &get_rgb_code($anchor_select_color),
                 -tags    => "anchor");

    @coords = &find_rect_from_text_or_image($canv, $id);
    $box_id = $canv->create_polygon(@coords,
                 -outline => '#000000',
                 -width   => 1,
                 -fill    => "",
                 -tags    => "working");
    $canv->raise($box_id, $id);

    $canv->g_bind("<Control-Motion>", [ \&size_image, Tkx::Ev("%x","%y"), $canv, $box_id, $id, 1 ]);
    $canv->g_bind("<Motion>",         [ \&size_image, Tkx::Ev("%x","%y"), $canv, $box_id, $id, 0 ]);
    $canv->g_bind("<Button-1>",       [ \&end_resize_image,    $canv, $id ]);
    $canv->g_bind("<Button-3>",       [ \&forget_resize_image, $canv ]);
}


sub size_image {
    my ($x, $y, $canv, $box_id, $id, $ctrl) = @_;
    my (
        $anc, $ang, $ang2, $aspr, $dx, $dy, $h, $hh, $hw, $snap, $w, $xc,
        $xo, $xp, $yc, $yo, $yp,
        @coords,
       );

    $aspr = $props{$id}{iw} /$props{$id}{ih};   # aspect ratio: width/height
    $xo   = $props{$id}{x};
    $yo   = $props{$id}{y};
    $ang  = $props{$id}{angle};
    $anc  = $props{$id}{anchor};
    $snap = ($ang % 90 == 0 || $ctrl) ? 1 : 0;
    ($x, $y) = &get_xy($canv, $x, $y, $snap);

#   Modify crosshair, if needed
    if ($ang != 0) {
        if ($ctrl) {
            $ang = 0;
            if ($props{$id}{angle_tmp} != 0) {
                $props{$id}{angle_tmp} = 0;
                &make_crosshair($xo, $yo, $canv, $ang);
            }
        } elsif ($props{$id}{angle_tmp} != $props{$id}{angle}) {
            $props{$id}{angle_tmp} = $props{$id}{angle};
            &make_crosshair($xo, $yo, $canv, $ang);
        }
    }

#   Do calculations in un-rotated space
#   Must calculate half-width (hw), half-height (hh),
#    center point (xc, yc), and mouse pointer (xp, yp)
    if ($ang == 0) {
        $dx = $x -$xo;
        $dy = $y -$yo;
        $xp = $x;
        $yp = $y;
    } else {
        if ($x == $xo) {
            if ($y == $yo) {
                $ang2 = 0;
            } else {
                $ang2 = ($y > $yo) ? 270 : 90;
            }
        } elsif ($y == $yo) {
            $ang2 = ($x > $xo) ? 0 : 180;
        } else {
            $ang2 = (180./pi)*atan2(($yo-$y),($x-$xo));
        }
        $h  = sqrt(($x-$xo)*($x-$xo)+($y-$yo)*($y-$yo));
        $dx =  $h *cos(($ang2 -$ang) *pi/180.);
        $dy = -$h *sin(($ang2 -$ang) *pi/180.);
        $xp = $xo +$dx;
        $yp = $yo +$dy;
    }
    $w  = abs($dx);
    $h  = abs($dy);
    $w *= 2. if ($anc =~ /^(n|s|center)$/);
    $h *= 2. if ($anc =~ /^(w|e|center)$/);
    $h  = 1  if ($h == 0);
    if ($w/$h >= $aspr) {
        $w = $aspr *$h;
        if ($anc =~ /^(n|s|center)$/) {
            $xp = ($xp > $xo) ? $xo +$w/2. : $xo -$w/2.;
            $dx = ($xp > $xo) ? $w/2. : -1 *$w/2.;
        } else {
            $xp = ($xp > $xo) ? $xo +$w : $xo -$w;
            $dx = ($xp > $xo) ? $w : -1 *$w;
        }
    } else {
        $h = $w /$aspr;
        if ($anc =~ /^(w|e|center)$/) {
            $yp = ($yp > $yo) ? $yo +$h/2. : $yo -$h/2.;
            $dy = ($yp > $yo) ? $h/2. : -1 *$h/2.;
        } else {
            $yp = ($yp > $yo) ? $yo +$h : $yo -$h;
            $dy = ($yp > $yo) ? $h : -1 *$h;
        }
    }
    $hw = $w/2.;
    $hh = $h/2.;

#   Assign un-rotated center point and adjust anchors
    if ($anc =~ /^(n|s)$/) {
        $xc = $xo;
        if ($yp < $yo) {
            $yc  = $yo -$hh;
            $anc = 's';
        } else {
            $yc  = $yo +$hh;
            $anc = 'n';
        }
    } elsif ($anc =~ /^(w|e)$/) {
        $yc = $yo;
        if ($xp < $xo) {
            $xc  = $xo -$hw;
            $anc = 'e';
        } else {
            $xc  = $xo +$hw;
            $anc = 'w';
        }
    } elsif ($anc eq 'center') {
        $xc = $xo;
        $yc = $yo;
    } else {
        $xc = ($xp +$xo)/2.;
        $yc = ($yp +$yo)/2.;
        if ($xp > $xo) {
            $anc = ($yp > $yo) ? 'nw' : 'sw';
        } else {
            $anc = ($yp > $yo) ? 'ne' : 'se';
        }
    }

#   Rotate ($xc, $yc) and ($xp, $yp) into position
    if ($ang != 0) {
        if ($anc ne 'center') {
            if ($xc == $xo) {
                if ($yc == $yo) {
                    $ang2 = 0;
                } else {
                    $ang2 = ($yc > $yo) ? 270 : 90;
                }
            } elsif ($yc == $yo) {
                $ang2 = ($xc > $xo) ? 0 : 180;
            } else {
                $ang2 = (180./pi)*atan2(($yo-$yc),($xc-$xo));
            }
            $h  = sqrt(($xc-$xo)*($xc-$xo)+($yc-$yo)*($yc-$yo));
            $xc = $xo + $h *cos(($ang2 +$ang) *pi/180.);
            $yc = $yo - $h *sin(($ang2 +$ang) *pi/180.);
        }
        if ($xp == $xo) {
            if ($yp == $yo) {
                $ang2 = 0;
            } else {
                $ang2 = ($yp > $yo) ? 270 : 90;
            }
        } elsif ($yp == $yo) {
            $ang2 = ($xp > $xo) ? 0 : 180;
        } else {
            $ang2 = (180./pi)*atan2(($yo-$yp),($xp-$xo));
        }
        $h  = sqrt(($xp-$xo)*($xp-$xo)+($yp-$yo)*($yp-$yo));
        $xp = $xo + $h *cos(($ang2 +$ang) *pi/180.);
        $yp = $yo - $h *sin(($ang2 +$ang) *pi/180.);
    }

#   Make some info accessible for final image resize later
    $props{$id}{iw_tmp}     = 2*$hw;
    $props{$id}{ih_tmp}     = 2*$hh;
    $props{$id}{anchor_tmp} = $anc;

    @coords = &make_shape_coords("rectangle", $xc, $yc, $hw, $hh, $ang);
    $canv->coords($box_id, @coords);
    $status_line = sprintf("X,Y,W,H: %d, %d, %d, %d", $xp-3, $yp-3, 2*$hw, 2*$hh);
}


sub end_resize_image {
    my ($canv, $id) = @_;
    my (
        $anc, $ang, $file, $flip, $ih, $iho, $image, $img, $img_data,
        $iw, $iwo,
        @crop,
       );

#   Get size, anchor, and angle
    $iw   = $props{$id}{iw_tmp};
    $ih   = $props{$id}{ih_tmp};
    $iwo  = $props{$id}{iwo};
    $iho  = $props{$id}{iho};
    $anc  = $props{$id}{anchor_tmp};
    $ang  = $props{$id}{angle_tmp};
    $flip = $props{$id}{flip};
    @crop = @{ $props{$id}{crop} };

    if ($iw == 0 || $ih == 0) {
        &pop_up_error($main, "Image either has no width or height.\nPlease continue or abort.");
        return;
    }

#   Use the original file.  Crop and flip as needed.
    $img  = Imager->new;
    $file = $props{$id}{file};
    $img->read(file => $file) or
            return &pop_up_error($main, "Failed to load $file\n $img->errstr");
    $img = $img->convert(preset => 'addalpha');
    if ($crop[0] > 0. || $crop[1] > 0. || $crop[2] > 0. || $crop[3] > 0.) {
        $img = $img->crop(left   => &round_to_int($iwo *$crop[0]),
                          right  => &round_to_int($iwo *(1.0 -$crop[1])),
                          top    => &round_to_int($iho *$crop[2]),
                          bottom => &round_to_int($iho *(1.0 -$crop[3])));
    }
    if ($flip ne "none") {
        $img->flip(dir => $flip);
    }

#   Scale the image.  Preserve the aspect ratio.
    if ($iw != $props{$id}{iwc} || $ih != $props{$id}{ihc}) {
        $img = $img->scale(xpixels => $iw);
    }

#   Write data to PNG format and save Tk photo image
    $img->write(data => \$img_data, type => 'png');
    $image = Tkx::image_create_photo(-data => $img_data);

#   Update the image, scaled, possibly flipped, but un-rotated
    $props{$id}{image}  = $image;
    $props{$id}{idata}  = $img_data;
    $props{$id}{anchor} = $anc;
    $props{$id}{iw}     = Tkx::image_width($image);
    $props{$id}{ih}     = Tkx::image_height($image);
    $props{$id}{angle}  = $ang;

    &find_rect_from_text_or_image($canv, $id);    # update xc, yc
    $canv->itemconfigure($id, -image => $image,
                              -state => 'hidden');
    $canv->coords($id, $props{$id}{xc}, $props{$id}{yc});
    $props{$id}{coordlist} = [ $props{$id}{xc}, $props{$id}{yc} ];

#   Rotate the re-scaled image
    if ($ang != 0) {
        $img = $img->rotate(degrees => -1 *$ang);
        $img->write(data => \$img_data, type => 'png');
        $image = Tkx::image_create_photo(-data => $img_data);
        $canv->itemconfigure($id, -image => $image);
    }
    $canv->itemconfigure($id, -state => 'normal');

    $canv->delete("crosshair");
    $canv->delete("anchor");
    $canv->delete("working");
    &reset_bindings;
}


sub revert_image {
    my ($canv, $id) = @_;
    my ($file, $iho, $image, $img, $img_data, $iwo);

    &end_select($canv, $id, 1);

    $iwo  = $props{$id}{iwo};
    $iho  = $props{$id}{iho};
    $file = $props{$id}{file};

#   Revert to original image size with no rotation, no crop, and no flip
    $img = Imager->new;
    $img->read(file => $file) or
            return &pop_up_error($main, "Failed to load $file\n $img->errstr");
    $img = $img->convert(preset => 'addalpha');

#   Resize if original image is larger than canvas
    if ($iwo > $canvas_width || $iho > $canvas_height) {
        if ($iwo /$canvas_width >= $iho /$canvas_height) {
            $img = $img->scale(xpixels => &round_to_int($canvas_width *0.8));
        } else {
            $img = $img->scale(ypixels => &round_to_int($canvas_height *0.8));
        }

#   Otherwise, invoke scale function to help fill in alpha channel
    } else {
        $img = $img->scale(xpixels => $iwo);
    }

    $img->write(data => \$img_data, type => 'png');
    $image = Tkx::image_create_photo(-data => $img_data);
    $canv->itemconfigure($id, -image => $image,
                              -state => 'hidden');
    $props{$id}{image} = $image;
    $props{$id}{idata} = $img_data;
    $props{$id}{iw}    = Tkx::image_width($image);
    $props{$id}{ih}    = Tkx::image_height($image);
    $props{$id}{iwc}   = $props{$id}{iwo};
    $props{$id}{ihc}   = $props{$id}{iho};
    $props{$id}{crop}  = [ 0.0, 0.0, 0.0, 0.0 ];
    $props{$id}{angle} = 0;
    $props{$id}{flip}  = "none";

    &find_rect_from_text_or_image($canv, $id);
    $props{$id}{coordlist} = [ $props{$id}{xc}, $props{$id}{yc} ];
    $canv->coords($id, $props{$id}{xc}, $props{$id}{yc});
    $canv->itemconfigure($id, -state => 'normal');
}


sub forget_resize_image {
    my ($canv) = @_;

    $canv->delete("crosshair");
    $canv->delete("anchor");
    $canv->delete("working");
    &reset_bindings;
}


sub flip_image {
    my ($canv, $id, $arg) = @_;
    my (
        $anc, $anchor_moved, $dx, $dy, $flip, $img, $img_data, $image,
        $left_right, $original, $use_anchor, $xc, $yc,
       );

    &end_select($canv, $id, 1);

    if ($props{$id}{angle} != 0) {
        &pop_up_error($main, "Unable to flip a rotated image.");
    }
    $flip     = $props{$id}{flip};
    $anc      = $props{$id}{anchor};
    $img_data = $props{$id}{idata};
    
#   Load the image.  Starting point is cropped, scaled, and un-rotated,
#     but possibly flipped image.
    $img = Imager->new;
    $img->read(data => $img_data);
    $img = $img->convert(preset => 'addalpha');
    $img = $img->scale(xpixels => $props{$id}{iw});

#   Interpret the command argument
    $left_right = ($arg =~ /left_right/) ? 1 : 0;
    $use_anchor = ($arg =~ /anchor/    ) ? 1 : 0;
    $original   = ($arg eq "original"  ) ? 1 : 0;

#   Flip the image
    if ($original) {
        $img->flip(dir => $flip) if ($flip ne "none");
    } else {
        if ($left_right) {
            $img->flip(dir => "h");
        } else {
            $img->flip(dir => "v");
        }
    }

#   Sort out the required changes
    if ($original) {
        $flip = "none";
    } else {
        if ($flip eq "none") {
            $flip = ($left_right) ? "h" : "v";
        } elsif ($flip eq "h") {
            $flip = ($left_right) ? "none" : "vh";
        } elsif ($flip eq "v") {
            $flip = ($left_right) ? "vh" : "none";
        } elsif ($flip eq "vh") {
            $flip = ($left_right) ? "v" : "h";
        }
    }
    $anchor_moved = 0;
    if ($use_anchor && $anc ne 'center') {
        $dx = $dy = 0;
        if ($left_right) {
            if ($anc =~ /e/) {
                $anc =~ s/e/w/;
                $dx = 2 *($props{$id}{x} -$props{$id}{xc});
            } elsif ($anc =~ /w/) {
                $anc =~ s/w/e/;
                $dx = 2 *($props{$id}{x} -$props{$id}{xc});
            }
        } else {
            if ($anc =~ /n/) {
                $anc =~ s/n/s/;
                $dy = 2 *($props{$id}{y} -$props{$id}{yc});
            } elsif ($anc =~ /s/) {
                $anc =~ s/s/n/;
                $dy = 2 *($props{$id}{y} -$props{$id}{yc});
            }
        }
        if ($dx != 0 || $dy != 0) {
            $anchor_moved = 1;
            $xc = $props{$id}{xc} +$dx;
            $yc = $props{$id}{yc} +$dy;
        }
    }

#   Update the image and its properties
    $img->write(data => \$img_data, type => 'png');
    $image = Tkx::image_create_photo(-data => $img_data);
    $canv->itemconfigure($id, -image => $image,
                              -state => 'hidden');
    $props{$id}{flip}  = $flip;
    $props{$id}{image} = $image;
    $props{$id}{idata} = $img_data;
    if ($anchor_moved) {
        $props{$id}{anchor}    = $anc;
        $props{$id}{xc}        = $xc;
        $props{$id}{yc}        = $yc;
        $props{$id}{coordlist} = [ $xc, $yc ];
        $canv->coords($id, $xc, $yc);
    }
    $canv->itemconfigure($id, -state => 'normal');
}


sub begin_crop_image {
    my ($canv, $id) = @_;
    my (
        $anc, $angle, $file, $flip, $i, $id2, $ih, $ihc, $iho, $image,
        $img, $img_data, $iw, $iwc, $iwo, $npts, $xi, $xm, $yi, $ym,
        @coords, @crop, @xvals, @yvals,
       );

    &end_select($canv, $id, 1);

    $angle = $props{$id}{angle};
    $flip  = $props{$id}{flip};
    $file  = $props{$id}{file};
    @crop  = @{ $props{$id}{crop} };

#   Make a copy of the image, uncropped
    $img = Imager->new;
    $img->read(file => $file) or
            return &pop_up_error($main, "Failed to load $file\n $img->errstr");
    $img = $img->convert(preset => 'addalpha');
    $iwo = $img->getwidth();
    $iho = $img->getheight();
    if ($crop[0] > 0. || $crop[1] > 0. || $crop[2] > 0. || $crop[3] > 0.) {
        $img = $img->crop(left   => &round_to_int($iwo *$crop[0]),
                          right  => &round_to_int($iwo *(1.0 -$crop[1])),
                          top    => &round_to_int($iho *$crop[2]),
                          bottom => &round_to_int($iho *(1.0 -$crop[3])));
    }
    $iwc = $img->getwidth();
    $ihc = $img->getheight();
    $img = $img->scale(xpixels => $props{$id}{iw});
    $iw  = $img->getwidth();
    $ih  = $img->getheight();
    if ($flip ne "none") {
        $img->flip(dir => $flip);
    }
    $img->write(data => \$img_data, type => 'png');
    $image = Tkx::image_create_photo(-data => $img_data);
    $id2   = $canv->create_image($props{$id}{xc}, $props{$id}{yc},
                                 -anchor => 'center',
                                 -image  => $image,
                                 -tags   => "image_copy",
                                 -state  => 'hidden');
    $props{$id2}{type}      = "image";
    $props{$id2}{x}         = $props{$id}{x};
    $props{$id2}{y}         = $props{$id}{y};
    $props{$id2}{xc}        = $props{$id}{xc};
    $props{$id2}{yc}        = $props{$id}{yc};
    $props{$id2}{coordlist} = [$props{$id}{xc}, $props{$id}{yc}];
    $props{$id2}{anchor}    = $props{$id}{anchor};
    $props{$id2}{iw}        = $iw;
    $props{$id2}{ih}        = $ih;
    $props{$id2}{iwo}       = $iwo;
    $props{$id2}{iho}       = $iho;
    $props{$id2}{iwc}       = $iwc;
    $props{$id2}{ihc}       = $ihc;
    $props{$id2}{crop}      = [ @crop ];
    $props{$id2}{crop_tmp}  = [ @crop ];
    $props{$id2}{file}      = $file;
    $props{$id2}{image}     = $image;
    $props{$id2}{idata}     = $img_data;
    $props{$id2}{flip}      = $flip;
    $props{$id2}{angle}     = $angle;
    if ($angle != 0) {
        $img = $img->rotate(degrees => -1 *$angle);
        $img->write(data => \$img_data, type => 'png');
        $image = Tkx::image_create_photo(-data => $img_data);
        $canv->itemconfigure($id2, -image => $image);
    }
    $canv->itemconfigure($id2, -state => 'normal');

#   Uncrop the image copy, if needed
    if ($crop[0] != 0. || $crop[1] != 0. || $crop[2] != 0. || $crop[3] != 0.) {
        &uncrop_image($canv, $id2);
    }

#   Hide the original image, for now
    $canv->itemconfigure($id, -state => 'hidden');

#   Draw boundary and add markers
    @xvals  = @yvals = ();
    @coords = &find_rect_from_text_or_image($canv, $id);
    $npts   = ($#coords +1) /2;
    for ($i=0; $i<$npts; $i++) {
        push(@xvals, $coords[2*$i]);
        push(@yvals, $coords[2*$i+1]);
    }
    $canv->create_polygon(@coords,
                    -outline => &get_rgb_code($anchor_select_color), 
                    -width   => 1, 
                    -fill    => "",
                    -tags    => "anchor_box");
    for ($i=0; $i<$npts; $i++) {
        $xi  = $xvals[$i];
        $yi  = $yvals[$i];
        $anc = $canv->create_rectangle($xi-2, $yi-2, $xi+2, $yi+2,
                         -outline => &get_rgb_code($anchor_line_color),
                         -width   => 1,
                         -fill    => &get_rgb_code($anchor_select_color),
                         -tags    => "anchor");
        $anc_props{$anc}{x}    = $xi;
        $anc_props{$anc}{y}    = $yi;
        $anc_props{$anc}{type} = $text_anchors[2*$i];
        if ($i < $npts-1) {
            $xm = ($xi +$xvals[$i+1])/2.;
            $ym = ($yi +$yvals[$i+1])/2.;
        } else {
            $xm = ($xi +$xvals[0])/2.;
            $ym = ($yi +$yvals[0])/2.;
        }
        $anc = $canv->create_rectangle($xm-2, $ym-2, $xm+2, $ym+2,
                         -outline => &get_rgb_code($anchor_line_color),
                         -width   => 1,
                         -fill    => &get_rgb_code($anchor_select_color),
                         -tags    => "anchor");
        $anc_props{$anc}{x}    = $xm;
        $anc_props{$anc}{y}    = $ym;
        $anc_props{$anc}{type} = $text_anchors[2*$i+1];
    }

#   Set bindings
    $canv->g_bind("<Motion>",          [ \&highlight_crop_pt, $canv, $id, $id2 ]);
    $canv->g_bind("<Double-Button-1>", [ \&crop_image,        $canv, $id, $id2 ]);
    $canv->g_bind("<Button-3>",        [ \&forget_crop_image, $canv, $id, $id2 ]);

    $status_line = "Adjust crop boundaries by dragging anchors...";
}


sub highlight_crop_pt {
    my ($canv, $id, $id2) = @_;
    my ($anchor_found, $atype, $item, $xo, $yo,
        @tags,
       );

    $anchor_found = 0;

    ($item) = $canv->find_withtag("current");
    if (defined($item) && $item ne "") {
        @tags = Tkx::SplitList($canv->itemcget($item, -tags));
        if (&list_match("anchor", @tags) > -1) {
            $xo = $anc_props{$item}{x};
            $yo = $anc_props{$item}{y};
            $canv->coords($item, $xo-4, $yo-4, $xo+4, $yo+4);
            if (defined($old_item) && $old_item ne $item) {
                $xo = $anc_props{$old_item}{x};
                $yo = $anc_props{$old_item}{y};
                $canv->coords($old_item, $xo-2, $yo-2, $xo+2, $yo+2);
            }
            $anchor_found = 1;
            $old_item = $item;
        }
    }
    if (! $anchor_found && defined($old_item) && $old_item ne "") {
        $xo = $anc_props{$old_item}{x};
        $yo = $anc_props{$old_item}{y};
        $canv->coords($old_item, $xo-2, $yo-2, $xo+2, $yo+2);
        undef $old_item;
    }
    if ($anchor_found) {
        $atype = $anc_props{$item}{type};
        $canv->g_bind("<Button1-Motion>", [ \&adjust_crop, Tkx::Ev("%x","%y"), $canv, $id, $id2, $atype ]);
    } else {
        $canv->g_bind("<Button1-Motion>", "");
    }
    $status_line = "Left-click & drag to move a crop anchor. Double-click to crop. Right-click to abort...";
}


sub adjust_crop {
    my ($x, $y, $canv, $id, $id2, $atype) = @_;
    my (
        $anc, $anc_type, $ang, $ang2, $crop_b, $crop_l, $crop_r, $crop_t, $d,
        $dx, $dy, $flip, $hh, $hw, $i, $ih, $iw, $snap, $xc, $xp, $yc, $yp,
        @anchors, @coords, @crop, @new_coords, @xvals, @yvals,
       );

#   Set some parameters
    $xc      = $props{$id2}{xc};
    $yc      = $props{$id2}{yc};
    $iw      = $props{$id2}{iw};     # uncropped width
    $ih      = $props{$id2}{ih};     # uncropped height
    $ang     = $props{$id2}{angle};
    $flip    = $props{$id2}{flip};
    @crop    = @{ $props{$id2}{crop_tmp} };
    @coords  = Tkx::SplitList($canv->coords("anchor_box"));
    $snap    = ($ang % 90 == 0) ? 1 : 0;
    ($x, $y) = &get_xy($canv, $x, $y, $snap);

#   Compute current crop distances in pixels
    $crop_l = ($flip =~ /h/) ? $iw *$crop[1] : $iw *$crop[0];
    $crop_r = ($flip =~ /h/) ? $iw *$crop[0] : $iw *$crop[1];
    $crop_t = ($flip =~ /v/) ? $ih *$crop[3] : $ih *$crop[2];
    $crop_b = ($flip =~ /v/) ? $ih *$crop[2] : $ih *$crop[3];

#   Un-rotate anchor box so calcs can be done in regular space
    if ($ang != 0) {
        @new_coords = ();
        for ($i=0; $i<4; $i++) {
            $xp = $coords[2*$i];
            $yp = $coords[2*$i+1];
            if ($xp == $xc && $yp == $yc) {
                push (@new_coords, $xp, $yp);
                next;
            }
            $d = sqrt(($xp-$xc)*($xp-$xc) + ($yp-$yc)*($yp-$yc));
            if ($xp == $xc) {
                $ang2 = ($yp > $yc) ? 270 : 90;
            } elsif ($yp == $yc) {
                $ang2 = ($xp > $xc) ? 0 : 180;
            } else {
                $ang2 = (180./pi)*atan2(($yc-$yp),($xp-$xc));
            }
            $ang2 += 360 if ($ang2 < 0);
            $xp = $xc +$d *cos(($ang2 -$ang) *pi/180.);
            $yp = $yc -$d *sin(($ang2 -$ang) *pi/180.);
            push (@new_coords, $xp, $yp);
        }
        @coords = @new_coords;

#       Also, un-rotate the x,y mouse position
        if ($x != $xc || $y != $yc) {
            $d = sqrt(($x-$xc)*($x-$xc) + ($y-$yc)*($y-$yc));
            if ($x == $xc) {
                $ang2 = ($y > $yc) ? 270 : 90;
            } elsif ($y == $yc) {
                $ang2 = ($x > $xc) ? 0 : 180;
            } else {
                $ang2 = (180./pi)*atan2(($yc-$y),($x-$xc));
            }
            $ang2 += 360 if ($ang2 < 0);
            $x = $xc +$d *cos(($ang2 -$ang) *pi/180.);
            $y = $yc -$d *sin(($ang2 -$ang) *pi/180.);
        }
    }
    @xvals = @yvals = ();
    for ($i=0; $i<4; $i++) {
        push (@xvals, $coords[2*$i]  );
        push (@yvals, $coords[2*$i+1]);
    }

#   Determine boundary movement
    if ($atype =~ /^(ne|e|se)$/) {
        $dx = $x - &max(@xvals);
        $dx = $crop_r if ($dx > $crop_r);
        $dx = &max($dx, -1 *($iw -$crop_r -$crop_l -1));
        $crop_r -= $dx;
    } elsif ($atype =~ /^(nw|w|sw)$/) {
        $dx = $x - &min(@xvals);
        $dx = -1 *$crop_l if ($dx < -1 *$crop_l);
        $dx = &min($dx, $iw -$crop_r -$crop_l -1);
        $crop_l += $dx;
    }
    if ($atype =~ /^(nw|n|ne)$/) {
        $dy = $y - &min(@yvals);
        $dy = -1 *$crop_t if ($dy < -1 *$crop_t);
        $dy = &min($dy, $ih -$crop_t -$crop_b -1);
        $crop_t += $dy;
    } elsif ($atype =~ /^(sw|s|se)$/) {
        $dy = $y - &max(@yvals);
        $dy = $crop_b if ($dy > $crop_b);
        $dy = &max($dy, -1 *($ih -$crop_t -$crop_b -1));
        $crop_b -= $dy;
    }

#   Save the temporary crop values
    $crop[0] = ($flip =~ /h/) ? $crop_r /$iw : $crop_l /$iw;
    $crop[1] = ($flip =~ /h/) ? $crop_l /$iw : $crop_r /$iw;
    $crop[2] = ($flip =~ /v/) ? $crop_b /$ih : $crop_t /$ih;
    $crop[3] = ($flip =~ /v/) ? $crop_t /$ih : $crop_b /$ih;
    $props{$id2}{crop_tmp} = [ @crop ];

#   Recompute the coordinates of the box
    $hw = ($iw-1)/2.;
    $hh = ($ih-1)/2.;
    @coords = ($xc-$hw+$crop_l, $yc-$hh+$crop_t, $xc+$hw-$crop_r, $yc-$hh+$crop_t,
               $xc+$hw-$crop_r, $yc+$hh-$crop_b, $xc-$hw+$crop_l, $yc+$hh-$crop_b);

#   Re-rotate the coordinates
    if ($ang != 0) {
        @new_coords = ();
        for ($i=0; $i<4; $i++) {
            $xp = $coords[2*$i];
            $yp = $coords[2*$i+1];
            if ($xp == $xc && $yp == $yc) {
                push (@new_coords, $xp, $yp);
                next;
            }
            $d = sqrt(($xp-$xc)*($xp-$xc) + ($yp-$yc)*($yp-$yc));
            if ($xp == $xc) {
                $ang2 = ($yp > $yc) ? 270 : 90;
            } elsif ($yp == $yc) {
                $ang2 = ($xp > $xc) ? 0 : 180;
            } else {
                $ang2 = (180./pi)*atan2(($yc-$yp),($xp-$xc));
            }
            $ang2 += 360 if ($ang2 < 0);
            $xp = $xc +$d *cos(($ang2 +$ang) *pi/180.);
            $yp = $yc -$d *sin(($ang2 +$ang) *pi/180.);
            push (@new_coords, $xp, $yp);
        }
        @coords = @new_coords;
    }

#   Display a modified box and move any modified anchors
    $canv->coords("anchor_box", @coords);
    @anchors = Tkx::SplitList($canv->find_withtag("anchor"));
    foreach $anc (@anchors) {
        $anc_type = $anc_props{$anc}{type};
        if ($anc_type eq "nw") {
            $xp = $coords[0];
            $yp = $coords[1];
        } elsif ($anc_type eq "n") {
            $xp = ($coords[0] +$coords[2])/2.;
            $yp = ($coords[1] +$coords[3])/2.;
        } elsif ($anc_type eq "ne") {
            $xp = $coords[2];
            $yp = $coords[3];
        } elsif ($anc_type eq "e") {
            $xp = ($coords[2] +$coords[4])/2.;
            $yp = ($coords[3] +$coords[5])/2.;
        } elsif ($anc_type eq "se") {
            $xp = $coords[4];
            $yp = $coords[5];
        } elsif ($anc_type eq "s") {
            $xp = ($coords[4] +$coords[6])/2.;
            $yp = ($coords[5] +$coords[7])/2.;
        } elsif ($anc_type eq "sw") {
            $xp = $coords[6];
            $yp = $coords[7];
        } elsif ($anc_type eq "w") {
            $xp = ($coords[0] +$coords[6])/2.;
            $yp = ($coords[1] +$coords[7])/2.;
        }
        if ($anc_type eq $atype) {
            $canv->coords($anc, $xp-4, $yp-4, $xp+4, $yp+4);
        } else {
            $canv->coords($anc, $xp-2, $yp-2, $xp+2, $yp+2);
        }
        $anc_props{$anc}{x} = $xp;
        $anc_props{$anc}{y} = $yp;
    }
    $status_line = "W,H: " . sprintf("%d", &round_to_int($iw -$crop_l -$crop_r))
                    . ", " . sprintf("%d", &round_to_int($ih -$crop_t -$crop_b));
}


sub crop_image {
    my ($canv, $id, $id2) = @_;
    my (
        $anc, $crop_b, $crop_l, $crop_r, $crop_t, $flip, $i, $ih, $iw,
        $img, $img_data, $image, $xc, $xo, $yc, $yo,
        @anchors, @coords, @crop, @xvals, @yvals,
       );

#   Set some variables
    $flip     = $props{$id2}{flip};
    $iw       = $props{$id2}{iw};     # uncropped width
    $ih       = $props{$id2}{ih};     # uncropped height
    $img_data = $props{$id2}{idata};
    @crop     = @{ $props{$id2}{crop_tmp} };

#   Start with data from uncropped id2, which is already sized and flipped
    $img = Imager->new;
    $img->read(data => $img_data);
    $img = $img->convert(preset => 'addalpha');

#   Compute current crop distances in pixels and recrop image
    $crop_l = ($flip =~ /h/) ? $iw *$crop[1] : $iw *$crop[0];
    $crop_r = ($flip =~ /h/) ? $iw *$crop[0] : $iw *$crop[1];
    $crop_t = ($flip =~ /v/) ? $ih *$crop[3] : $ih *$crop[2];
    $crop_b = ($flip =~ /v/) ? $ih *$crop[2] : $ih *$crop[3];
    if ($crop_l > 0. || $crop_r > 0. || $crop_t > 0. || $crop_b > 0.) {
        $img = $img->crop(left   => &round_to_int($crop_l),
                          right  => &round_to_int($iw -$crop_r),
                          top    => &round_to_int($crop_t),
                          bottom => &round_to_int($ih -$crop_b));
    }
    $img->write(data => \$img_data, type => 'png');
    $image = Tkx::image_create_photo(-data => $img_data);

#   Updated boundaries and anchor position are in image_box and anchors
    @coords = Tkx::SplitList($canv->coords("anchor_box"));
    @xvals  = @yvals = ();
    for ($i=0; $i<4; $i++) {
        push (@xvals, $coords[2*$i]  );
        push (@yvals, $coords[2*$i+1]);
    }
    $xc = (&min(@xvals) + &max(@xvals)) /2.;
    $yc = (&min(@yvals) + &max(@yvals)) /2.;
    if ($props{$id}{anchor} eq 'center') {
        $xo = $xc;
        $yo = $yc;
    } else {
        @anchors = Tkx::SplitList($canv->find_withtag("anchor"));
        foreach $anc (@anchors) {
            if ($anc_props{$anc}{type} eq $props{$id}{anchor}) {
                $xo = $anc_props{$anc}{x};
                $yo = $anc_props{$anc}{y};
                last;
            }
        }
    }
    
#   Update image properties
    $props{$id}{x}         = $xo;
    $props{$id}{y}         = $yo;
    $props{$id}{xc}        = $xc;
    $props{$id}{yc}        = $yc;
    $props{$id}{coordlist} = [ $xc, $yc ];
    $props{$id}{iw}        = $img->getwidth();
    $props{$id}{ih}        = $img->getheight();
    $props{$id}{iwc}       = &round_to_int($props{$id}{iwo} * (1.0 -$crop[0] -$crop[1]));
    $props{$id}{ihc}       = &round_to_int($props{$id}{iho} * (1.0 -$crop[2] -$crop[3]));
    $props{$id}{crop}      = [ @crop ];
    $props{$id}{image}     = $image;
    $props{$id}{idata}     = $img_data;

#   Rotate image if needed and redraw
    if ($props{$id}{angle} != 0) {
        $img = $img->rotate(degrees => -1 *$props{$id}{angle});
        $img->write(data => \$img_data, type => 'png');
        $image = Tkx::image_create_photo(-data => $img_data);
    }
    $canv->itemconfigure($id, -image => $image,
                              -state => 'hidden');
    $canv->coords($id, $xc, $yc);
    $canv->itemconfigure($id, -state => 'normal');

#   Clean up
    $canv->delete("image_copy");
    $canv->delete("anchor_box");
    $canv->delete("anchor");
    delete $props{$id2};
    undef %anc_props;
    undef $old_item if (defined($old_item));
    undef $old_id   if (defined($old_id));
    &reset_bindings;
}


sub uncrop_image {
    my ($canv, $id) = @_;
    my (
        $anc, $ang, $ang2, $crop_b, $crop_l, $crop_r, $crop_t, $file, $flip,
        $h, $ih, $image, $img, $img_data, $iw, $xc, $xo, $xp, $yc, $yo, $yp,
        @crop,
       );

    &end_select($canv, $id, 1);

    $xo   = $props{$id}{x};
    $yo   = $props{$id}{y};
    $xc   = $props{$id}{xc};
    $yc   = $props{$id}{yc};
    $anc  = $props{$id}{anchor};
    $ang  = $props{$id}{angle};
    $flip = $props{$id}{flip};
    $file = $props{$id}{file};
    @crop = @{ $props{$id}{crop} };

#   Start with original file.  Load it, flip it, re-scale it.
    $img = Imager->new;
    $img->read(file => $file) or
            return &pop_up_error($main, "Failed to load $file\n $img->errstr");
    $img = $img->convert(preset => 'addalpha');
    if ($flip ne "none") {
        $img->flip(dir => $flip);
    }
    $img = $img->scaleX(pixels => &round_to_int($props{$id}{iw} *$props{$id}{iwo} /$props{$id}{iwc}));
    $img = $img->scaleY(pixels => &round_to_int($props{$id}{ih} *$props{$id}{iho} /$props{$id}{ihc}));
    $iw  = $img->getwidth();
    $ih  = $img->getheight();

#   Un-rotate the anchor around the cropped center point
    $xp = $xc;  # pivot point is (xp,yp)
    $yp = $yc;
    if ($ang != 0) {
        if ($xo == $xp) {
            if ($yo == $yp) {
                $ang2 = 0;
            } else {
                $ang2 = ($yo > $yp) ? 270 : 90;
            }
        } elsif ($yo == $yp) {
            $ang2 = ($xo > $xp) ? 0 : 180;
        } else {
            $ang2 = (180./pi)*atan2(($yp-$yo),($xo-$xp));
        }
        $h  = sqrt(($xo-$xp)*($xo-$xp)+($yo-$yp)*($yo-$yp));
        $xo = $xp +$h *cos(($ang2 -$ang) *pi/180.);
        $yo = $yp -$h *sin(($ang2 -$ang) *pi/180.);
    }

#   Adjust the center point and anchor location in un-rotated space
    $crop_l = ($flip =~ /h/) ? $iw *$crop[1] : $iw *$crop[0];
    $crop_r = ($flip =~ /h/) ? $iw *$crop[0] : $iw *$crop[1];
    $crop_t = ($flip =~ /v/) ? $ih *$crop[3] : $ih *$crop[2];
    $crop_b = ($flip =~ /v/) ? $ih *$crop[2] : $ih *$crop[3];
    $xc += ($crop_r -$crop_l)/2.;
    $yc += ($crop_b -$crop_t)/2.;
    if ($anc =~ /^(nw|w|sw)$/) {
        $xo -= $crop_l;
    } elsif ($anc =~ /^(ne|e|se)$/) {
        $xo += $crop_r;
    } elsif ($anc =~ /^(n|s|center)$/) {
        $xo += ($crop_r -$crop_l)/2.;
    }
    if ($anc =~ /^(nw|n|ne)$/) {
        $yo -= $crop_t;
    } elsif ($anc =~ /^(sw|s|se)$/) {
        $yo += $crop_b;
    } elsif ($anc =~ /^(w|e|center)$/) {
        $yo += ($crop_b -$crop_t)/2.;
    }

#   Re-rotate anchor and center around the cropped center point (xp,yp)
    if ($ang != 0) {
        if ($xo == $xp) {
            if ($yo == $yp) {
                $ang2 = 0;
            } else {
                $ang2 = ($yo > $yp) ? 270 : 90;
            }
        } elsif ($yo == $yp) {
            $ang2 = ($xo > $xp) ? 0 : 180;
        } else {
            $ang2 = (180./pi)*atan2(($yp-$yo),($xo-$xp));
        }
        $h  = sqrt(($xo-$xp)*($xo-$xp)+($yo-$yp)*($yo-$yp));
        $xo = $xp +$h *cos(($ang2 +$ang) *pi/180.);
        $yo = $yp -$h *sin(($ang2 +$ang) *pi/180.);
        if ($xc == $xp) {
            if ($yc == $yp) {
                $ang2 = 0;
            } else {
                $ang2 = ($yc > $yp) ? 270 : 90;
            }
        } elsif ($yc == $yp) {
            $ang2 = ($xc > $xp) ? 0 : 180;
        } else {
            $ang2 = (180./pi)*atan2(($yp-$yc),($xc-$xp));
        }
        $h  = sqrt(($xc-$xp)*($xc-$xp)+($yc-$yp)*($yc-$yp));
        $xc = $xp +$h *cos(($ang2 +$ang) *pi/180.);
        $yc = $yp -$h *sin(($ang2 +$ang) *pi/180.);
    }

#   Update the image and its properties
    $img->write(data => \$img_data, type => 'png');
    $image = Tkx::image_create_photo(-data => $img_data);

    $props{$id}{image}     = $image;
    $props{$id}{idata}     = $img_data;
    $props{$id}{x}         = $xo;
    $props{$id}{y}         = $yo;
    $props{$id}{xc}        = $xc;
    $props{$id}{yc}        = $yc;
    $props{$id}{iw}        = $iw;
    $props{$id}{ih}        = $ih;
    $props{$id}{iwc}       = $props{$id}{iwo};
    $props{$id}{ihc}       = $props{$id}{iho};
    $props{$id}{crop}      = [ 0.0, 0.0, 0.0, 0.0 ];
    $props{$id}{coordlist} = [ $xc, $yc ];

    $canv->itemconfigure($id, -image => $image,
                              -state => 'hidden');
    $canv->coords($id, $xc, $yc);

#   Rotate the re-scaled image
    if ($ang != 0) {
        $img = $img->rotate(degrees => -1 *$ang);
        $img->write(data => \$img_data, type => 'png');
        $image = Tkx::image_create_photo(-data => $img_data);
        $canv->itemconfigure($id, -image => $image);
    }
    $canv->itemconfigure($id, -state => 'normal');
}


sub forget_crop_image {
    my ($canv, $id, $id2) = @_;

    $canv->delete("image_copy");
    $canv->delete("anchor_box");
    $canv->delete("anchor");
    $canv->itemconfigure($id, -state => 'normal');
    delete $props{$id2};
    undef %anc_props;
    undef $old_item if (defined($old_item));
    undef $old_id   if (defined($old_id));
    &reset_bindings;
}


sub begin_rotate_image {
    my ($x, $y, $canv, $id) = @_;
    my ($xo, $yo, $ang);

    $x  = $canv->canvasx($x);
    $y  = $canv->canvasy($y);
    $xo = $props{$id}{x};
    $yo = $props{$id}{y};
    if ($x == $xo) {
        if ($y == $yo) {
            $ang = 0;
        } else {
            $ang = ($y > $yo) ? 270 : 90;
        }
    } elsif ($y == $yo) {
        $ang = ($x > $xo) ? 0 : 180;
    } else {
        $ang = &round_to_int((180./pi)*atan2(($yo-$y),($x-$xo)));
    }
    $ang += 360 if ($ang < 0);

    &rotate_image($canv, $id, $ang, 1);
}


sub rotate_image {
    my ($canv, $id, $ang, $free_rotate) = @_;
    my (
        $anc, $ang2, $d, $hh, $hw, $i, $ih, $img, $img_data, $image, $iw,
        $rot_img, $x, $xc, $xo, $y, $yc, $yo,
        @coords, @new_coords, @xvals, @yvals,
       );

    &end_select($canv, $id, 1);
    $free_rotate = 0 if (! defined($free_rotate) || $free_rotate != 1);
    if ($free_rotate) {
        $status_line = sprintf("Rotation: %d", $ang);
    }
    $xo       = $props{$id}{x};
    $yo       = $props{$id}{y};
    $anc      = $props{$id}{anchor};
    $iw       = $props{$id}{iw};
    $ih       = $props{$id}{ih};
    $image    = $props{$id}{image};
    $img_data = $props{$id}{idata};
    $ang     += $props{$id}{angle} if (! $free_rotate);
    $ang      = ($ang + 360) % 360;  # $ang is always an integer

#   Set the encompassing rectangle for the un-rotated image
#   Find corners based on anchor (n, ne, e, se, s, sw, w, nw, center)
    $hw = ($iw-1)/2.;
    $hh = ($ih-1)/2.;
    if ($anc eq 'nw') {
        @coords = ($xo, $yo, $xo+2*$hw, $yo, $xo+2*$hw, $yo+2*$hh, $xo, $yo+2*$hh);
        $xc = $xo + $hw;
        $yc = $yo + $hh;
    } elsif ($anc eq 'n') {
        @coords = ($xo-$hw, $yo, $xo+$hw, $yo, $xo+$hw, $yo+2*$hh, $xo-$hw, $yo+2*$hh);
        $xc = $xo;
        $yc = $yo + $hh;
    } elsif ($anc eq 'ne') {
        @coords = ($xo-2*$hw, $yo, $xo, $yo, $xo, $yo+2*$hh, $xo-2*$hw, $yo+2*$hh);
        $xc = $xo - $hw;
        $yc = $yo + $hh;
    } elsif ($anc eq 'e') {
        @coords = ($xo-2*$hw, $yo-$hh, $xo, $yo-$hh, $xo, $yo+$hh, $xo-2*$hw, $yo+$hh);
        $xc = $xo - $hw;
        $yc = $yo;
    } elsif ($anc eq 'se') {
        @coords = ($xo-2*$hw, $yo-2*$hh, $xo, $yo-2*$hh, $xo, $yo, $xo-2*$hw, $yo);
        $xc = $xo - $hw;
        $yc = $yo - $hh;
    } elsif ($anc eq 's') {
        @coords = ($xo-$hw, $yo-2*$hh, $xo+$hw, $yo-2*$hh, $xo+$hw, $yo, $xo-$hw, $yo);
        $xc = $xo;
        $yc = $yo - $hh;
    } elsif ($anc eq 'sw') {
        @coords = ($xo, $yo-2*$hh, $xo+2*$hw, $yo-2*$hh, $xo+2*$hw, $yo, $xo, $yo);
        $xc = $xo + $hw;
        $yc = $yo - $hh;
    } elsif ($anc eq 'w') {
        @coords = ($xo, $yo-$hh, $xo+2*$hw, $yo-$hh, $xo+2*$hw, $yo+$hh, $xo, $yo+$hh);
        $xc = $xo + $hw;
        $yc = $yo;
    } else {
        @coords = ($xo-$hw, $yo-$hh, $xo+$hw, $yo-$hh, $xo+$hw, $yo+$hh, $xo-$hw, $yo+$hh);
        $xc = $xo;
        $yc = $yo;
    }

#   Just show the original image if the angle is zero.
    if ($ang == 0) {
        $canv->itemconfigure($id, -state => 'hidden');
        $canv->coords($id, $xc, $yc);
        $canv->itemconfigure($id, -image => $image,
                                  -state => 'normal');
        return if ($free_rotate);
        $props{$id}{xc}        = $xc;
        $props{$id}{yc}        = $yc;
        $props{$id}{coordlist} = [$xc, $yc];
        $props{$id}{angle}     = $ang;
        return;
    }

#   Find the center point of the rotated bounding rectangle
    if ($ang != 0 && $anc ne 'center') {
        @new_coords = ();
        for ($i=0; $i<4; $i++) {
            $x = $coords[2*$i];
            $y = $coords[2*$i+1];
            if ($x == $xo && $y == $yo) {
                push (@new_coords, $x, $y);
                next;
            }
            $d = sqrt(($x-$xo)*($x-$xo) + ($y-$yo)*($y-$yo));
            if ($x == $xo) {
                $ang2 = ($y > $yo) ? 270 : 90;
            } elsif ($y == $yo) {
                $ang2 = ($x > $xo) ? 0 : 180;
            } else {
                $ang2 = (180./pi)*atan2(($yo-$y),($x-$xo));
            }
            $ang2 += 360 if ($ang2 < 0);
            $x = $xo +$d *cos(($ang2 +$ang) *pi/180.);
            $y = $yo -$d *sin(($ang2 +$ang) *pi/180.);
            push (@new_coords, $x, $y);
        }
        @coords = @new_coords;
        @xvals  = @yvals = ();
        for ($i=0; $i<4; $i++) {
            push (@xvals, $coords[2*$i]  );
            push (@yvals, $coords[2*$i+1]);
        }
        $xc = (&min(@xvals) + &max(@xvals))/2.;
        $yc = (&min(@yvals) + &max(@yvals))/2.;
    }

#   Prepare for a delay due to image processing
    $canv->configure(-cursor => $cursor_wait);
    Tkx::update_idletasks();

#   Rotate the image.  Use the scale function to ensure alpha data for transparency.
    $img = Imager->new;
    $img->read(data => $img_data);
    $img = $img->convert(preset => 'addalpha');
    $img = $img->scale(xpixels => $props{$id}{iw});
    $rot_img = $img->rotate(degrees => -1 *$ang);
    $rot_img->write(data => \$img_data, type => 'png');
    $image = Tkx::image_create_photo(-data => $img_data);

#   Update the item
    $canv->itemconfigure($id, -state => 'hidden');
    $canv->coords($id, $xc, $yc);
    $canv->itemconfigure($id, -image => $image,
                              -state => 'normal');
    if ($free_rotate) {
        $canv->configure(-cursor => $cursor_hand);
        return;
    }
    $props{$id}{xc}        = $xc;
    $props{$id}{yc}        = $yc;
    $props{$id}{coordlist} = [$xc, $yc];
    $props{$id}{angle}     = $ang;
    $canv->configure(-cursor => $cursor_norm);
    return;
}


sub end_rotate_image {
    my ($x, $y, $canv, $id) = @_;
    my ($xo, $yo, $ang);

    $x  = $canv->canvasx($x);
    $y  = $canv->canvasy($y);
    $xo = $props{$id}{x};
    $yo = $props{$id}{y};
    if ($x == $xo) {
        if ($y == $yo) {
            $ang = 0;
        } else {
            $ang = ($y > $yo) ? 270 : 90;
        }
    } elsif ($y == $yo) {
        $ang = ($x > $xo) ? 0 : 180;
    } else {
        $ang = &round_to_int((180./pi)*atan2(($yo-$y),($x-$xo)));
    }
    $ang += 360 if ($ang < 0);
    $ang -= $props{$id}{angle};

    &rotate_image($canv, $id, $ang, 0);

    $canv->delete("anchor");
    &reset_bindings;
}


sub forget_rotate_image {
    my ($canv, $id) = @_;

    &rotate_image($canv, $id, 0, 0);

    $canv->delete("anchor");
    &reset_bindings;
}


################################################################################
#
# Object selection
#
################################################################################

sub object_select {
    my ($x, $y, $canv, $action) = @_;
    my (
        $box_id, $code, $fg, $geom, $grp, $i, $id, $item_selected, $ncols,
        $nrows, $tol, $type, $x1, $x2, $xloc, $xmax, $xmin, $xp, $y1, $y2,
        $yloc, $ymax, $ymin, $yp,

        @coords, @ids, @tags,
       );

    ($x, $y) = &get_xy($canv, $x, $y, 0);
    $status_line = sprintf("X,Y: %d, %d", $x-3, $y-3);

    $tol = 4;
    $item_selected  = 0;
    $nrows = $ncols = 1;

#   The find method will find a polygon for every point inside that polygon
#   regardless of whether the polygon is filled, so some extra searching is
#   required when polygons are used.  Rectangles, diamonds, polygons, and
#   ellipses are polygons in this program.

    @ids = Tkx::SplitList($canv->find_overlapping($x-$tol, $y-$tol, $x+$tol, $y+$tol));
    for ($i=$#ids; $i>=0; $i--) {
        @tags = Tkx::SplitList($canv->itemcget($ids[$i], -tags));
        next if (&list_match("working",    @tags) > -1);
        next if (&list_match("select_box", @tags) > -1);
        next if (&list_match("select_pts", @tags) > -1);
        next if (&list_match("zoom_bar",   @tags) > -1);
        if (&list_search("^graph", @tags) > -1) {
            $id   = $tags[&list_search("^graph", @tags)];
            $id   =~ s/^graph//;
            $id   =~ s/_.*$//;
            $type = $props{$id}{type};
            $item_selected = 1;
            last;
        } else {
            $item_selected = &select_item($canv, $ids[$i], $x, $y, $tol);
            if ($item_selected) {
                $id   = $ids[$i];
                $type = $props{$id}{type};
                last;
            }
        }
    }

    if ($item_selected) {
        if ($type eq "graph") {
            $grp = &get_group_type($id, @tags);
            $status_line .= "  " . $grp;
            if (! defined($gr_props{$id})) {
                if ($props{$id}{meta} eq "vert_wd_zone") {
                    $status_line .= " (incomplete)";
                }
                return;
            }
            ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
            if ($x >= $x1 && $x <= $x2 && $y >= $y1 && $y <= $y2) {
                if ($props{$id}{meta} eq "w2_tdmap") {
                    if ($gr_props{$id}{date_axis} eq "Y") {
                        $xmin = $gr_props{$id}{dmin};
                        $xmax = $gr_props{$id}{dmax};
                        if ($gr_props{$id}{dflip}) {
                            $xloc = $xmin +($xmax -$xmin) *(1.0 -($x -$x1) /($x2 -$x1));
                        } else {
                            $xloc = $xmin +($xmax -$xmin) *($x -$x1) /($x2 -$x1);
                        }
                        if ($gr_props{$id}{ttype} eq "Date/Time") {
                            $ymin = &datelabel2jdate($gr_props{$id}{tmin});
                            $ymax = &datelabel2jdate($gr_props{$id}{tmax});
                        } else {
                            $ymin = $gr_props{$id}{tmin};
                            $ymax = $gr_props{$id}{tmax};
                        }
                        if ($gr_props{$id}{tflip}) {
                            $yloc = $ymin +($ymax -$ymin) *(1.0 -($y -$y1) /($y2 -$y1));
                        } else {
                            $yloc = $ymin +($ymax -$ymin) *($y -$y1) /($y2 -$y1);
                        }
                        if ($gr_props{$id}{ttype} eq "Date/Time") {
                            $yloc = &jdate2datelabel($yloc, "Mon-DD-YYYY");
                            $status_line .= sprintf("  [%.2f, %s]", $xloc, $yloc);
                        } else {
                            $status_line .= sprintf("  [%.2f, %.2f]", $xloc, $yloc);
                        }
                    } else {
                        $ymin = $gr_props{$id}{dmin};
                        $ymax = $gr_props{$id}{dmax};
                        if ($gr_props{$id}{dflip}) {
                            $yloc = $ymin +($ymax -$ymin) *($y -$y1) /($y2 -$y1);
                        } else {
                            $yloc = $ymin +($ymax -$ymin) *(1.0 -($y -$y1) /($y2 -$y1));
                        }
                        if ($gr_props{$id}{ttype} eq "Date/Time") {
                            $xmin = &datelabel2jdate($gr_props{$id}{tmin});
                            $xmax = &datelabel2jdate($gr_props{$id}{tmax});
                        } else {
                            $xmin = $gr_props{$id}{tmin};
                            $xmax = $gr_props{$id}{tmax};
                        }
                        if ($gr_props{$id}{tflip}) {
                            $xloc = $xmin +($xmax -$xmin) *(1.0 -($x -$x1) /($x2 -$x1));
                        } else {
                            $xloc = $xmin +($xmax -$xmin) *($x -$x1) /($x2 -$x1);
                        }
                        if ($gr_props{$id}{ttype} eq "Date/Time") {
                            $xloc = &jdate2datelabel($xloc, "Mon-DD-YYYY");
                            $status_line .= sprintf("  [%s, %.2f]", $xloc, $yloc);
                        } else {
                            $status_line .= sprintf("  [%.2f, %.2f]", $xloc, $yloc);
                        }
                    }
                } else {
                    if ($props{$id}{meta} eq "w2_profile_matrix") {
                        ($nrows, $ncols) = split(/x/, $gr_props{$id}{matrix});
                    }
                    $ymin = $gr_props{$id}{ymin};
                    $ymax = $gr_props{$id}{ymax};
                    if ($props{$id}{meta} =~ /(data_profile|w2_profile|w2_slice|w2_outflow|vert_wd_zone)/
                         && $gr_props{$id}{ytype} eq "Depth") {
                        if ($nrows == 1) {
                            $yloc = $ymax *($y -$y1) /($y2 -$y1);
                        } else {
                            $yloc = $ymax *(($nrows *($y -$y1) /($y2 -$y1))
                                        -int($nrows *($y -$y1) /($y2 -$y1)));
                        }
                    } else {
                        if ($nrows == 1) {
                            $yloc = $ymin +($ymax -$ymin) *($y2 -$y) /($y2 -$y1);
                        } else {
                            $yloc = $ymin +($ymax -$ymin) *(($nrows *($y2 -$y) /($y2 -$y1))
                                                        -int($nrows *($y2 -$y) /($y2 -$y1)));
                        }
                    }
                    if ($props{$id}{meta} =~ /(data_profile_cmap|w2_profile_cmap|time_series)/
                         && (! defined($gr_props{$id}{xtype}) || $gr_props{$id}{xtype} eq "Date/Time")) {
                        $xmin = &datelabel2jdate($gr_props{$id}{xmin});
                        $xmax = &datelabel2jdate($gr_props{$id}{xmax});
                        $xloc = $xmin +($xmax -$xmin) *($x -$x1) /($x2 -$x1);
                        $xloc = &jdate2datelabel($xloc, "Mon-DD-YYYY");
                        $status_line .= sprintf("  [%s, %.2f]", $xloc, $yloc);
                    } else {
                        $xmin = $gr_props{$id}{xmin};
                        $xmax = $gr_props{$id}{xmax};
                        if ($props{$id}{meta} =~ /w2_slice|w2_wlevels/ && $gr_props{$id}{xflip}) {
                            $xloc = $xmin +($xmax -$xmin) *(1.0 -($x -$x1) /($x2 -$x1));
                        } else {
                            if ($ncols == 1) {
                                $xloc = $xmin +($xmax -$xmin) *($x -$x1) /($x2 -$x1);
                            } else {
                                $xloc = $xmin +($xmax -$xmin) *(($ncols *($x -$x1) /($x2 -$x1))
                                                            -int($ncols *($x -$x1) /($x2 -$x1)));
                            }
                        }
                        $status_line .= sprintf("  [%.2f, %.2f]", $xloc, $yloc);
                    }
                }
            }

        } else {
            $grp = "";
            $status_line .= "  " . ucfirst($type);
            if (($type =~ /^(text|circle|ellipse|rectangle|diamond|polygon)$/
                 && defined($link_props{$id}{id})) ||
                ($type eq "text" && &list_match($id, @ind_link_ids) >= 0)) {
                $status_line .= " Link";
            }
        }
        if (! defined($old_id) || $id != $old_id) {
            &end_select($canv, $old_id) if (defined($old_id));
            $code = &get_rgb_code($canvas_color);
            if ($type eq "image") {
                $fg = &get_rgb_code("black");
                if ($code eq $fg) {
                    if ($code =~ /^\#[0-9a-f]/i) {
                        $fg = &get_rgb_code(&get_bw_contrast($code));
                    }
                }
                @coords = &find_rect_from_text_or_image($canv, $id);
                $box_id = $canv->create_polygon(@coords, -width   => 2,
                                               -outline => $fg,
                                               -fill    => "",
                                               -smooth  => 'false',
                                               -tags    => "working");
                $canv->raise($box_id, $id);

            } elsif ($type eq "text") {
                $canv->itemconfigure($id, -fill => &get_rgb_code($text_select_color));

            } elsif ($type eq "graph") {
                if ($props{$id}{meta} eq "w2_profile_matrix") {
                    $canv->itemconfigure("graph" . $id . "_frame",
                                              -width => 2,
                                            -outline => &get_rgb_code($text_select_color));
                } else {
                    $canv->itemconfigure($id, -width => $props{$id}{width} +1,
                                            -outline => &get_rgb_code($text_select_color));
                }

            } else {
                if ($props{$id}{width} == 0) {
                    $canv->itemconfigure($id, -width => 1,
                                            -outline => &get_rgb_code($props{$id}{color}));
                } else {
                    $canv->itemconfigure($id, -width => $props{$id}{width} +1);
                }
                if ($code eq &get_rgb_code($props{$id}{color})) {
                    if ($code =~ /^\#[0-9a-f]/i) {
                        $fg = &get_rgb_code(&get_bw_contrast($code));
                        if ($type eq "line" || $type eq "polyline") {
                            $canv->itemconfigure($id, -fill => $fg);
                        } else {
                            $canv->itemconfigure($id, -outline => $fg);
                        }
                    }
                }
            }
        }
        if ($action eq "move") {
            $canv->g_bind("<Button-1>", [ \&begin_move, $canv, $id, $grp ]);
        } elsif ($action eq "edit") {
            $canv->g_bind("<Button-1>", [ \&begin_edit, Tkx::Ev("%X","%Y"), $canv, $id ]);
        } elsif ($action eq "duplicate") {
            $canv->g_bind("<Button-1>", [ \&duplicate, $canv, $id ]);
        } elsif ($action eq "kill") {
            $canv->g_bind("<Button-1>", [ \&object_kill, $canv, $id ]);
        } elsif ($action eq "menu") {
            $canv->configure(-cursor => $cursor_select);
            $canv->g_bind("<Shift-Button-1>", [ \&add_selection, $canv, $id, 0 ]);
            $canv->g_bind("<Button-1>",       [ \&add_selection, $canv, $id, 1 ]);
            $canv->g_bind("<Button-3>",       [ \&popup_menu, Tkx::Ev("%X","%Y"), $canv, $id ]);
        } elsif ($action =~ /zoom/ && $type eq "graph" && $props{$id}{meta} =~ /time_series/) {
            if ($action =~ /zoom_in/) {
                $canv->delete("zoom_bar");
                if ($action =~ /^(zoom_in|zoom_in_X)$/) {
                    $x = $x1 if ($x < $x1);
                    $x = $x2 if ($x > $x2);
                    $canv->create_rectangle($x, $y2, $x, $y2+4,
                           -outline => "",
                           -width   => 0,
                           -fill    => &get_rgb_code($text_select_color),
                           -tags    => "zoom_bar");
                }
                if ($action =~ /^(zoom_in|zoom_in_Y)$/) {
                    $y = $y1 if ($y < $y1);
                    $y = $y2 if ($y > $y2);
                    $canv->create_rectangle($x1-4, $y, $x1, $y,
                           -outline => "",
                           -width   => 0,
                           -fill    => &get_rgb_code($text_select_color),
                           -tags    => "zoom_bar");
                }
                $canv->g_bind("<Button-1>", [ \&begin_zoom_box, Tkx::Ev("%x","%y"), $canv, $id, $action ]);
            } elsif ($action eq "zoom_out") {
                $canv->g_bind("<Button-1>", [ \&zoom_out, $canv, $id ]);
            } elsif ($action eq "zoom_out_X") {
                $canv->g_bind("<Button-1>", [ \&zoom_out_X, $canv, $id ]);
            } elsif ($action eq "zoom_out_Y") {
                $canv->g_bind("<Button-1>", [ \&zoom_out_Y, $canv, $id ]);
            } elsif ($action eq "zoom_full") {
                $canv->g_bind("<Button-1>", [ \&zoom_full, $canv, $id ]);
            } elsif ($action eq "zoom_full_X") {
                $canv->g_bind("<Button-1>", [ \&zoom_full_X, $canv, $id ]);
            } elsif ($action eq "zoom_full_Y") {
                $canv->g_bind("<Button-1>", [ \&zoom_full_Y, $canv, $id ]);
            }
        }
        $old_id = $id;

    } else {
        &end_select($canv, $id)     if (defined($id) && $id ne "");
        &end_select($canv, $old_id) if (defined($old_id));
        undef $old_id               if (defined($old_id));
        $canv->g_bind("<Button-1>",       "");
        $canv->g_bind("<Shift-Button-1>", "");
        if ($action eq "menu") {
            $canv->configure(-cursor => $cursor_norm);
            $canv->g_bind("<Button-1>", [ \&begin_select_box, Tkx::Ev("%x","%y"), $canv ]);
            $canv->g_bind("<Button-3>", [ \&popup_menu,       Tkx::Ev("%X","%Y"), $canv ]);
        }
    }
}


sub add_selection {
    my ($canv, $id, $start) = @_;
    my ($i, $np, $tag, $type, $xp, $yp,
        @coords, @tags,
       );

    &clear_selection($canv) if ($start);
    &end_select($canv, $id, 1);

#   Deselect and return if already selected
    $type = $props{$id}{type};
    @tags = Tkx::SplitList($canv->itemcget($id, -tags));
    if (&list_match("select", @tags) > -1) {
        $canv->dtag($id, "select");
        $canv->delete("select_" . $type . $id);
        return;
    }

#   Tag the object and provide selection markers
    $canv->addtag("select", withtag => $id);
    $tag    = "select_box" . " " . "select_" . $type . $id;
    @coords = &get_coords($canv, $id, "bbox");
    $canv->create_polygon(@coords,
                            -outline => &get_rgb_code("gray50"),
                            -width   => 2,
                            -fill    => "",
                            -tags    => $tag);
    $np  = ($#coords +1)/2.;
    $tag = "select_pts" . " " . "select_" . $type . $id;
    for ($i=0; $i<$np; $i++) {
        $xp = $coords[2*$i];
        $yp = $coords[2*$i+1];
        $canv->create_rectangle($xp-2, $yp-2, $xp+2, $yp+2,
                            -outline => &get_rgb_code("gray50"),
                            -width   => 1,
                            -fill    => &get_rgb_code("gray70"),
                            -tags    => $tag);
    }
    $canv->raise("select_" . $type . $id, $id);
}


sub group_items {
    my ($canv, @items) = @_;
    my ($rnum, $group_tag, $id, $type);

    $rnum      = &get_random_number();
    $group_tag = "group_" . $rnum;
    foreach $id (@items) {
        $type = $props{$id}{type};
        if ($type ne "graph") {
            $canv->addtag($group_tag, withtag => $id);
        } else {
            $canv->addtag($group_tag, withtag => "graph" . $id);
        }
    }
    &clear_selection($canv);
    return $group_tag;
}


sub ungroup_items {
    my ($canv, $tag) = @_;

    &clear_selection($canv);
    $canv->dtag($tag);
    delete $props{$tag};
}


sub show_group {
    my ($canv, $tag) = @_;
    my ($i, $item, $np, $type, $xp, $yp,
        @coords, @items,
       );

    @items = Tkx::SplitList($canv->find_withtag($tag));
    foreach $item (@items) {
        next if (! defined($props{$item}{type}));
        $canv->addtag("select", withtag => $item);
        $type   = $props{$item}{type};
        $tag    = "select_box" . " " . "select_" . $type . $item;
        @coords = &get_coords($canv, $item, "bbox");
        $canv->create_polygon(@coords,
                                -outline => &get_rgb_code("gray50"),
                                -width   => 2,
                                -fill    => "",
                                -tags    => $tag);
        $np  = ($#coords +1)/2.;
        $tag = "select_pts" . " " . "select_" . $type . $item;
        for ($i=0; $i<$np; $i++) {
            $xp = $coords[2*$i];
            $yp = $coords[2*$i+1];
            $canv->create_rectangle($xp-2, $yp-2, $xp+2, $yp+2,
                                -outline => &get_rgb_code("gray50"),
                                -width   => 1,
                                -fill    => &get_rgb_code("gray70"),
                                -tags    => $tag);
        }
        $canv->raise("select_" . $type . $item, $item);
    }
}


sub group_kill {
    my ($canv, $tag) = @_;
    my ($item, @items);

    @items = Tkx::SplitList($canv->find_withtag($tag));
    foreach $item (@items) {
        next if (! defined($props{$item}));
        next if (! defined($props{$item}{type}));
        &object_kill($canv, $item);
    }
}


sub clear_selection_marks {
    my ($canv) = @_;

    $canv->delete("select_box");
    $canv->delete("select_pts");
}


sub clear_selection {
    my ($canv) = @_;

    $canv->dtag("select");
    &clear_selection_marks($canv);
}


sub begin_select_box {
    my ($x, $y, $canv) = @_;
    my ($box_id);

    &clear_selection($canv);

    ($x, $y) = &get_xy($canv, $x, $y, 0);
    $box_id = $canv->create_rectangle($x, $y, $x, $y,
                     -outline => &get_rgb_code("gray50"),
                     -width   => 1,
                     -fill    => "",
                     -tags    => "working");

    $canv->g_bind("<Motion>",          [ \&draw_select_box, Tkx::Ev("%x","%y"), $canv, $box_id, $x, $y ]);
    $canv->g_bind("<ButtonRelease-1>", [ \&end_select_box,  Tkx::Ev("%x","%y"), $canv, $box_id, $x, $y ]);
}


sub draw_select_box {
    my ($x, $y, $canv, $box_id, $xo, $yo) = @_;

    ($x, $y) = &get_xy($canv, $x, $y, 0);
    $canv->coords($box_id, $xo, $yo, $x, $y);
    $status_line = sprintf("Selection X,Y,W,H: %d, %d, %d, %d", $x-3, $y-3, abs($x-$xo), abs($y-$yo));
}


sub end_select_box {
    my ($x, $y, $canv, $box_id, $xo, $yo) = @_;
    my ($id, @ids);

    ($x, $y) = &get_xy($canv, $x, $y, 0);
    @ids = Tkx::SplitList($canv->find_enclosed($x, $y, $xo, $yo));
    foreach $id (@ids) {
        next if (! defined($props{$id}{type}));
        &add_selection($canv, $id, 0);
    }
    $canv->delete($box_id);
    &reset_bindings;
}


sub select_item {
    my ($canv, $id, $x, $y, $tol, $edge_only) = @_;
    my ($ang, $ang2, $d, $dist, $i, $npts, $r, $selected, $type,
        $x1, $x2, $xo, $y1, $y2, $yo,
        @coords, @xvals, @yvals,
       );

    $selected  = 0;
    $type      = $props{$id}{type};
    $edge_only = 0 if (! defined($edge_only) || $edge_only != 1);

    if ($type eq "text" || $type eq "image") {
        @coords = &find_rect_from_text_or_image($canv, $id);
        @xvals  = @yvals = ();
        for ($i=0; $i<4; $i++) {
            push(@xvals, $coords[2*$i]);
            push(@yvals, $coords[2*$i+1]);
        }
        $ang = $props{$id}{angle};

#       Rotate rectangle around x,y if angle not zero
        if ($ang != 0) {
            for ($i=0; $i<4; $i++) {
                $x1 = $xvals[$i];
                $y1 = $yvals[$i];
                next if ($x1 == $x && $y1 == $y);
                $d = sqrt(($x1-$x)*($x1-$x) + ($y1-$y)*($y1-$y));
                if ($x1 == $x) {
                    $ang2 = ($y1 > $y) ? 270 : 90;
                } elsif ($y1 == $y) {
                    $ang2 = ($x1 > $x) ? 0 : 180;
                } else {
                    $ang2 = (180./pi)*atan2(($y-$y1),($x1-$x));
                }
                $ang2 += 360 if ($ang2 < 0);
                $xvals[$i] = $x +$d *cos(($ang2 -$ang) *pi/180.);
                $yvals[$i] = $y -$d *sin(($ang2 -$ang) *pi/180.);
            }
        }

#       Selected if x,y is inside the rectangle, within tol
        if ( $x >= &min(@xvals) - $tol && $x <= &max(@xvals) + $tol &&
             $y >= &min(@yvals) - $tol && $y <= &max(@yvals) + $tol ) {
            $selected = 1;
        }

    } elsif ($type eq "line") {
        ($x1, $y1, $x2, $y2) = Tkx::SplitList($canv->coords($id));
        if ($x1 == $x2) {
            $selected = 1;
        } else {
            $dist = ($x2 - $x1) * (($y2 - $y1)*($x - $x1)/($x2 - $x1) + $y1 - $y)
                                / sqrt(($x2-$x1)*($x2-$x1) + ($y2-$y1)*($y2-$y1));
            $selected = 1 if (abs($dist) <= $tol);
        }

    } elsif ($type eq "circle") {
        ($x1, $y1, $x2, $y2) = Tkx::SplitList($canv->bbox($id));

        $xo   = ($x2 + $x1) / 2.0;
        $yo   = ($y2 + $y1) / 2.0;
        $r    = abs($xo - $x1);
        $dist = sqrt(($x - $xo)*($x - $xo) + ($y - $yo)*($y - $yo));

        if (abs($dist - $r) <= $tol || ($props{$id}{fill} && $dist <= $r)) {
            $selected = 1;
        }

    } elsif ($type =~ /^(rectangle|diamond|polygon|ellipse)$/) {
        return 1 if ($props{$id}{fill} && ! $edge_only);

        @coords = Tkx::SplitList($canv->coords($id));
        push (@coords, $coords[0], $coords[1]);
        $npts = ($#coords + 1)/2;
        for ($i=0; $i<$npts-1; $i++) {
            $x1 = $coords[2*$i];
            $y1 = $coords[2*$i+1];
            $x2 = $coords[2*$i+2];
            $y2 = $coords[2*$i+3];
            if ( $x >= &min($x1,$x2)-$tol && $x <= &max($x1,$x2)+$tol &&
                 $y >= &min($y1,$y2)-$tol && $y <= &max($y1,$y2)+$tol ) {
                if ($x1 == $x2) {
                    $selected = 1;
                    last;
                } else {
                    $dist = ($x2 - $x1)
                            * (($y2 - $y1)*($x - $x1)/($x2 - $x1) + $y1 - $y)
                            / sqrt(($x2-$x1)*($x2-$x1) + ($y2-$y1)*($y2-$y1));
                    if (abs($dist) <= $tol) {
                        $selected = 1;
                        last;
                    }
                }
            }
        }

    } elsif ($type eq "polyline") {
        @coords = Tkx::SplitList($canv->coords($id));
        $npts   = ($#coords + 1)/2;
        for ($i=0; $i<$npts-1; $i++) {
            $x1 = $coords[2*$i];
            $y1 = $coords[2*$i+1];
            $x2 = $coords[2*$i+2];
            $y2 = $coords[2*$i+3];
            if ( $x >= &min($x1,$x2)-$tol && $x <= &max($x1,$x2)+$tol &&
                 $y >= &min($y1,$y2)-$tol && $y <= &max($y1,$y2)+$tol ) {
                if ($x1 == $x2) {
                    $selected = 1;
                    last;
                } else {
                    $dist = ($x2 - $x1)
                            * (($y2 - $y1)*($x - $x1)/($x2 - $x1) + $y1 - $y)
                            / sqrt(($x2-$x1)*($x2-$x1) + ($y2-$y1)*($y2-$y1));
                    if (abs($dist) <= $tol) {
                        $selected = 1;
                        last;
                    }
                }
            }
        }
    }
    return $selected;
}


sub end_select {
    my ($canv, $id, $flag) = @_;
    my ($code, $type);

    $type = $props{$id}{type};
    $code = &get_rgb_code($props{$id}{color}) if ($type ne "image");

    if ($type eq "image") {
        $canv->delete("working");

    } elsif ($type eq "text") {
        $canv->itemconfigure($id, -fill => $code);

    } elsif ($type eq "line" || $type eq "polyline") {
        $canv->itemconfigure($id, -width => $props{$id}{width},
                                  -fill  => $code);

    } elsif ($type eq "graph") {
        if ($props{$id}{meta} eq "w2_profile_matrix") {
            $canv->itemconfigure("graph" . $id . "_frame",
                                      -width   => 1,
                                      -outline => $code);
            $canv->itemconfigure($id, -state   => 'hidden');
        } else {
            $canv->itemconfigure($id, -width   => $props{$id}{width},
                                      -outline => $code);
        }

    } elsif ($type =~ /^(circle|ellipse|rectangle|diamond|polygon)$/) {
        if ($props{$id}{width} == 0) {
            $canv->itemconfigure($id, -width   => 0,
                                      -outline => "");
        } else {
            $canv->itemconfigure($id, -width   => $props{$id}{width},
                                      -outline => $code);
        }
    }
    undef $old_id if ($flag && defined($old_id));
}


sub show_points {
    my ($canv, $id) = @_;
    my ($i, $npts, $pt, $xi, $yi,
        @coords,
       );

    end_select($canv, $id);
    undef %pt_props;
    undef $old_item if (defined($old_item));
    $canv->delete("points");

    @coords = Tkx::SplitList($canv->coords($id));
    $npts   = ($#coords + 1) /2;
    for ($i=0; $i<$npts; $i++) {
        $xi = $coords[2*$i];
        $yi = $coords[2*$i+1];
        $pt = $canv->create_rectangle($xi-2, $yi-2, $xi+2, $yi+2,
                     -outline => &get_rgb_code($anchor_line_color),
                     -width   => 1,
                     -fill    => &get_rgb_code($anchor_fill_color),
                     -tags    => "points");
        $pt_props{$pt}{x} = $xi;
        $pt_props{$pt}{y} = $yi;
    }

    $canv->g_bind("<Motion>",   [ \&highlight_pt, Tkx::Ev("%x", "%y"), $canv, $id ]);
    $canv->g_bind("<Button-1>", [ \&edit_add_pt,  Tkx::Ev("%x", "%y"), $canv, $id ]);
    $canv->g_bind("<Button-3>", [ \&exit_edit_pts, $canv, $id ]);
}


sub highlight_pt {
    my ($x, $y, $canv, $id) = @_;
    my ($i, $insert_pt, $item, $npts, $point_found, $selected, $tol, $xo, $yo,
        @coords, @tags,
       );

    ($x, $y) = &get_xy($canv, $x, $y, 0);
    $status_line = sprintf("X,Y: %d, %d", $x-3, $y-3);

    $point_found = 0;

    ($item) = $canv->find_withtag("current");
    if (defined($item) && $item ne "") {
        @tags = Tkx::SplitList($canv->itemcget($item, -tags));
        if (&list_match("points", @tags) > -1) {
            $xo = $pt_props{$item}{x};
            $yo = $pt_props{$item}{y};
            $canv->coords($item, $xo-4, $yo-4, $xo+4, $yo+4);
            if (defined($old_item) && $old_item ne $item) {
                $xo = $pt_props{$old_item}{x};
                $yo = $pt_props{$old_item}{y};
                $canv->coords($old_item, $xo-2, $yo-2, $xo+2, $yo+2);
            }
            $point_found = 1;
            $old_item = $item;
        }
    }
    if (! $point_found && defined($old_item) && $old_item ne "") {
        $xo = $pt_props{$old_item}{x};
        $yo = $pt_props{$old_item}{y};
        $canv->coords($old_item, $xo-2, $yo-2, $xo+2, $yo+2);
        undef $old_item;
    }
    if ($point_found) {
        @coords    = Tkx::SplitList($canv->coords($id));
        $npts      = ($#coords + 1) /2;
        $insert_pt = 0;
        for ($i=0; $i<$npts; $i++) {
            $xo = $coords[2*$i];
            $yo = $coords[2*$i+1];
            if ( $xo == $pt_props{$item}{x} && $yo == $pt_props{$item}{y}) {
                $insert_pt = 2*$i;
                last;
            }
        }
        $canv->configure(-cursor => $cursor_select);
        $status_line = sprintf("X,Y: %d, %d  %s", $x-3, $y-3, "Right click to move or delete...");
        $canv->g_bind("<Button-3>", [ \&edit_pts_menu, Tkx::Ev("%X", "%Y"), $canv, $id, $insert_pt ]);

    } else {
        $tol      = 4;
        $selected = &select_item($canv, $id, $x, $y, $tol, 1);
        if ($selected) {
            $canv->configure(-cursor => $cursor_draw);
            $status_line = sprintf("X,Y: %d, %d  %s", $x-3, $y-3, "Click to add point...");
        } else {
            $canv->configure(-cursor => $cursor_norm);
        }
        $canv->g_bind("<Button-3>", [ \&exit_edit_pts, $canv, $id ]);
    }
}


sub show_anchors {
    my ($canv, $id, $choice) = @_;
    my ($anc, $i, $npts, $type, $xi, $xm, $yi, $ym,
        @coords, @xvals, @yvals,
       );

    @xvals  = @yvals = ();
    $type   = $props{$id}{type};
    @coords = @{ $props{$id}{coordlist} } if ($type !~ /^(text|image)$/);

    if ($type eq "ellipse" || $type eq "diamond") {
        @coords = &find_rect_from_shape(\@coords, $props{$id}{angle});
    } elsif ($type =~ /^(polygon|polyline)$/ && $choice eq "bbox") {
        @coords = &find_rect_from_poly(\@coords, $props{$id}{angle});
    } elsif ($type eq "text" || $type eq "image") {
        @coords = &find_rect_from_text_or_image($canv, $id);
        &end_select($canv, $id, 1);
    } elsif ($type eq "circle" || $type eq "graph") {
        push(@coords, $coords[0], $coords[3]);
        splice(@coords, 2, 0, $coords[2], $coords[1]);
    }
    $npts = ($#coords + 1) /2;
    for ($i=0; $i<$npts; $i++) {
        push(@xvals, $coords[2*$i]);
        push(@yvals, $coords[2*$i+1]);
    }

    if ($type =~ /^(rectangle|diamond|ellipse|circle|text|image|line|graph)$/ ||
        ($type =~ /^(polygon|polyline)$/ && $choice eq "bbox")) {
        for ($i=0; $i<$npts; $i++) {
            $xi  = $xvals[$i];
            $yi  = $yvals[$i];
            $anc = $canv->create_rectangle($xi-2, $yi-2, $xi+2, $yi+2,
                         -outline => &get_rgb_code($anchor_line_color),
                         -width   => 1,
                         -fill    => &get_rgb_code($anchor_fill_color),
                         -tags    => "anchor");
            if (abs($xi - $props{$id}{x}) < 0.01 && abs($yi - $props{$id}{y}) < 0.01) {
                $canv->itemconfigure($anc, -fill => &get_rgb_code($anchor_select_color));
            }
            $anc_props{$anc}{x} = $xi;
            $anc_props{$anc}{y} = $yi;
            if ($type eq "text" || $type eq "image") {
                $anc_props{$anc}{type} = $text_anchors[2*$i];
            } elsif ($type eq "line") {
                $anc_props{$anc}{type} = 'point';
            } else {
                $anc_props{$anc}{type} = 'corner';
            }

            if ($i < $npts-1) {
                $xm = ($xi + $xvals[$i+1])/2.;
                $ym = ($yi + $yvals[$i+1])/2.;
            } else {
                $xm = ($xi + $xvals[0])/2.;
                $ym = ($yi + $yvals[0])/2.;
            }
            $anc = $canv->create_rectangle($xm-2, $ym-2, $xm+2, $ym+2,
                         -outline => &get_rgb_code($anchor_line_color),
                         -width   => 1,
                         -fill    => &get_rgb_code($anchor_fill_color),
                         -tags    => "anchor");
            if (abs($xm - $props{$id}{x}) < 0.01 && abs($ym - $props{$id}{y}) < 0.01) {
                $canv->itemconfigure($anc, -fill => &get_rgb_code($anchor_select_color));
            }
            $anc_props{$anc}{x} = $xm;
            $anc_props{$anc}{y} = $ym;
            if ($type eq "text" || $type eq "image") {
                $anc_props{$anc}{type} = $text_anchors[2*$i+1];
            } else {
                $anc_props{$anc}{type} = 'midpoint';
            }
        }
        if ($type ne "line") {
            $xm  = $props{$id}{xc};
            $ym  = $props{$id}{yc};
            $anc = $canv->create_rectangle($xm-2, $ym-2, $xm+2, $ym+2,
                         -outline => &get_rgb_code($anchor_line_color),
                         -width   => 1,
                         -fill    => &get_rgb_code($anchor_fill_color),
                         -tags    => "anchor");
            if (abs($xm - $props{$id}{x}) < 0.01 && abs($ym - $props{$id}{y}) < 0.01) {
                $canv->itemconfigure($anc, -fill => &get_rgb_code($anchor_select_color));
            }
            $anc_props{$anc}{x}    = $xm;
            $anc_props{$anc}{y}    = $ym;
            $anc_props{$anc}{type} = 'center';
        }
    }
    if ($type =~ /^(polygon|polyline)$/ && $choice eq "pts") {
        for ($i=0; $i<$npts; $i++) {
            $xi  = $xvals[$i];
            $yi  = $yvals[$i];
            $anc = $canv->create_rectangle($xi-2, $yi-2, $xi+2, $yi+2,
                         -outline => &get_rgb_code($anchor_line_color),
                         -width   => 1,
                         -fill    => &get_rgb_code($anchor_fill_color),
                         -tags    => "anchor");
            if (abs($xi - $props{$id}{x}) < 0.01 && abs($yi - $props{$id}{y}) < 0.01) {
                $canv->itemconfigure($anc, -fill => &get_rgb_code($anchor_select_color));
            }
            $anc_props{$anc}{x}    = $xi;
            $anc_props{$anc}{y}    = $yi;
            $anc_props{$anc}{type} = 'point';
        }
        $xm  = $props{$id}{xc_rot};
        $ym  = $props{$id}{yc_rot};
        $anc = $canv->create_rectangle($xm-2, $ym-2, $xm+2, $ym+2,
                     -outline => &get_rgb_code($anchor_line_color),
                     -width   => 1,
                     -fill    => &get_rgb_code($anchor_fill_color),
                     -tags    => "anchor");
        if (abs($xm - $props{$id}{x}) < 0.01 && abs($ym - $props{$id}{y}) < 0.01) {
            $canv->itemconfigure($anc, -fill => &get_rgb_code($anchor_select_color));
        }
        $anc_props{$anc}{x}    = $xm;
        $anc_props{$anc}{y}    = $ym;
        $anc_props{$anc}{type} = 'center_rot';
    }

    $canv->g_bind("<Motion>",   [ \&highlight_anchor,  $canv, $id ]);
    $canv->g_bind("<Button-1>", [ \&set_anchor,        $canv, $id ]);
    $canv->g_bind("<Button-3>", [ \&forget_set_anchor, $canv, $id ]);

    $status_line = "Select anchor point...";
}


sub highlight_anchor {
    my ($canv, $id) = @_;
    my ($anchor_found, $item, $xo, $yo,
        @tags,
       );

    $anchor_found = 0;

    ($item) = $canv->find_withtag("current");
    if (defined($item) && $item ne "") {
        @tags = Tkx::SplitList($canv->itemcget($item, -tags));
        if (&list_match("anchor", @tags) > -1) {
            $xo = $anc_props{$item}{x};
            $yo = $anc_props{$item}{y};
            $canv->coords($item, $xo-4, $yo-4, $xo+4, $yo+4);
            if (defined($old_item) && $old_item ne $item) {
                $xo = $anc_props{$old_item}{x};
                $yo = $anc_props{$old_item}{y};
                $canv->coords($old_item, $xo-2, $yo-2, $xo+2, $yo+2);
            }
            $anchor_found = 1;
            $old_item = $item;
        }
    }
    if (! $anchor_found && defined($old_item) && $old_item ne "") {
        $xo = $anc_props{$old_item}{x};
        $yo = $anc_props{$old_item}{y};
        $canv->coords($old_item, $xo-2, $yo-2, $xo+2, $yo+2);
        undef $old_item;
    }
}


sub set_anchor {
    my ($canv, $id) = @_;
    my ($anc, $anchor_found, $i, $item, $xo, $yo,
        @items, @tags,
       );

    $anchor_found = 0;

    ($item) = $canv->find_withtag("current");
    if (defined($item) && $item ne "") {
        @tags = Tkx::SplitList($canv->itemcget($item, -tags));
        if (&list_match("anchor", @tags) > -1) {
            $xo                 = $anc_props{$item}{x};
            $yo                 = $anc_props{$item}{y};
            $props{$id}{x}      = $xo;
            $props{$id}{y}      = $yo;
            $props{$id}{anchor} = $anc_props{$item}{type};
            $canv->itemconfigure($item, -fill => &get_rgb_code($anchor_select_color));
            $anchor_found = 1;
            if ($props{$id}{type} eq "text") {
                $anc = $canv->itemcget($id, -anchor);
                if ($anc ne $props{$id}{anchor}) {
                    $canv->coords($id, $xo, $yo);
                    $canv->itemconfigure($id, -anchor => $props{$id}{anchor});
                }
            }

        }
    }
    if ($anchor_found) {
        @items = Tkx::SplitList($canv->find_withtag("anchor"));
        for ($i=0; $i<=$#items; $i++) {
            next if ($xo == $anc_props{$items[$i]}{x} && $yo == $anc_props{$items[$i]}{y});
            $canv->itemconfigure($items[$i], -fill => &get_rgb_code($anchor_fill_color));
        }
        Tkx::update_idletasks();
        sleep 1;
        $canv->delete("anchor");
        &reset_bindings;

    } elsif (defined($old_item) && $old_item ne "") {
        $xo = $anc_props{$old_item}{x};
        $yo = $anc_props{$old_item}{y};
        $canv->coords($old_item, $xo-2, $yo-2, $xo+2, $yo+2);
    }
    undef $old_item if (defined($old_item));
}


sub forget_set_anchor {
    my ($canv, $id) = @_;

    undef %anc_props;
    undef $old_item if (defined($old_item));
    end_select($canv, $id);
    $canv->delete("anchor");
    &reset_bindings;
}


################################################################################
#
# Show or edit object properties
#
################################################################################

sub edit_text_props {
    my ($id, $X, $Y) = @_;
    my (
        $code, $color, $color_btn, $f, $family, $fg, $fontfamily_cb,
        $fontsize_cb, $frame, $geom, $linked, $size, $slant, $text,
        $text_entry, $underline, $weight,
       );

#   Get current text properties and a window placement.
    $color     = $props{$id}{color};
    $family    = $props{$id}{family};
    $size      = $props{$id}{size};
    $weight    = $props{$id}{weight};
    $slant     = $props{$id}{slant};
    $underline = $props{$id}{underline};
    $text      = $canvas->itemcget($id, -text);
    $geom      = sprintf("+%d+%d", $X, $Y+7);

#   Determine whether the text object is a link
    $linked = (defined($link_props{$id}{id}) || &list_match($id, @ind_link_ids) >= 0) ? 1 : 0;

#   Create a new menu each time, because the old one was tied to
#   the previous text item, and it's too much hassle to clean that up.

    if (defined($text_props_menu) && Tkx::winfo_exists($text_props_menu)) {
        if ($text_props_menu->g_wm_title() eq "Text Properties") {
            $text_props_menu->g_destroy();
            undef $text_props_menu;
        }
    }

    $text_props_menu = $main->new_toplevel();
    $text_props_menu->g_wm_transient($main);
    $text_props_menu->g_wm_title("Text Properties");
    $text_props_menu->configure(-cursor => $cursor_norm);
    $text_props_menu->g_wm_geometry($geom);

    $frame = $text_props_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    $frame->new_button(
            -text    => "OK",
            -command => sub { \&set_text_props($id, $text, $color,
                                  $family, $size, $weight, $slant,
                                  $underline, "OK");
                            }
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Apply",
            -command => sub { \&set_text_props($id, $text, $color,
                                  $family, $size, $weight, $slant,
                                  $underline, "Apply");
                            }
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text => "Cancel",
            -command => sub { my (@tags);
                              @tags = Tkx::SplitList($canvas->itemcget($id, -tags));
                              if (&list_match("keep", @tags) == -1) {
                                  $canvas->dtag("working");
                                  $canvas->delete($id);
                                  delete $props{$id};
                                  undef $old_id if (defined($old_id));
                              }
                              $text_props_menu->g_destroy();
                              undef $text_props_menu;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

    $f = $text_props_menu->new_frame();
    $f->g_pack(-side => 'top');

    $f->new_label(-text => "Family:")->g_pack(-side => 'left');
    $fontfamily_cb = $f->new_ttk__combobox(
                         -textvariable => \$family,
                         -values       => [ sort @available_fonts ],
                         -state        => 'readonly',
                         );
    $fontfamily_cb->g_pack(-fill => 'x', -side => 'left');
    $fontfamily_cb->g_bind("<<ComboboxSelected>>",
                    sub { $text_entry->configure(
                          -font => [-family     => $family,
                                    -size       => $size,
                                    -weight     => $weight,
                                    -slant      => $slant_type[$slant],
                                    -underline  => $underline,
                                    -overstrike => 0,
                                   ]) }
                    );

    $f->new_label(-text => "Size:")->g_pack(-side => 'left');
    $fontsize_cb = $f->new_ttk__combobox(
                       -textvariable => \$size,
                       -values       => [(5 .. 32)],
                       -width        => 2,
                       -state        => 'readonly',
                       );
    $fontsize_cb->g_pack(-side => 'left');
    $fontsize_cb->g_bind("<<ComboboxSelected>>",
                  sub { $text_entry->configure(
                        -font => [-family     => $family,
                                  -size       => $size,
                                  -weight     => $weight,
                                  -slant      => $slant_type[$slant],
                                  -underline  => $underline,
                                  -overstrike => 0,
                                 ]) }
                  );

    $f->new_checkbutton(
               -text     => 'Weight',
               -variable => \$weight,
               -onvalue  => 'bold',
               -offvalue => 'normal',
               -command  => sub { $text_entry->configure(
                                  -font => [-family     => $family,
                                            -size       => $size,
                                            -weight     => $weight,
                                            -slant      => $slant_type[$slant],
                                            -underline  => $underline,
                                            -overstrike => 0,
                                           ]) }
               )->g_pack(-side => 'left');

    $f->new_checkbutton(
               -text     => 'Slant',
               -variable => \$slant,
               -onvalue  => 1,
               -offvalue => 0,
               -command  => sub { $text_entry->configure(
                                  -font => [-family     => $family,
                                            -size       => $size,
                                            -weight     => $weight,
                                            -slant      => $slant_type[$slant],
                                            -underline  => $underline,
                                            -overstrike => 0,
                                           ]) }
               )->g_pack(-side => 'left');

    $f->new_checkbutton(
               -text     => 'Underline',
               -variable => \$underline,
               -command  => sub { $text_entry->configure(
                                  -font => [-family     => $family,
                                            -size       => $size,
                                            -weight     => $weight,
                                            -slant      => $slant_type[$slant],
                                            -underline  => $underline,
                                            -overstrike => 0,
                                           ]) }
               )->g_pack(-side => 'left');

    $f->new_label( -text => "Color:",
                   -font => 'default',
                 )->g_pack(-side => 'left');

    $code  = &get_rgb_code($color);
    $color = &get_rgb_name($code);
    $fg    = &get_rgb_code("black");
    if ($code =~ /^\#[0-9a-f]/i) {
        $fg = &get_rgb_code(&get_bw_contrast($code));
    }
    $color_btn = $f->new_button(
               -textvariable => \$color,
               -background   => $code,
               -foreground   => $fg,
               -width        => -7,
               -command => sub {
                              my ($newc, $code, $fg);
                              $code = &get_rgb_code($color);
                              $newc = Tkx::tk___chooseColor(
                                         -initialcolor => $code,
                                         -parent       => $text_props_menu);
                              if ($newc) {
                                $code  = &get_rgb_code($newc);
                                $color = &get_rgb_name($code);
                                $fg    = &get_rgb_code("black");
                                if ($code =~ /^\#[0-9a-f]/i) {
                                    $fg = &get_rgb_code(&get_bw_contrast($code));
                                }
                                $color_btn->configure(-foreground => $fg,
                                                      -background => $code);
                                $text_entry->configure(-foreground => $code,
                                                       -background => $fg);
                              }
                            }
               );
    $color_btn->g_pack(-side => 'left', -padx => 2, -pady => 2);

    $text_entry = $text_props_menu->new_entry(
                -textvariable => \$text,
                -foreground   => $color,
                -background   => $fg,
                -font => [-family     => $family,
                          -size       => $size,
                          -weight     => $weight,
                          -slant      => $slant_type[$slant],
                          -underline  => $underline,
                          -overstrike => 0,
                         ],
                );
    $text_entry->g_pack(-fill => 'x');

    if ($linked) {
        $text_entry->configure(-state => 'readonly');
    }
    Tkx::wm_resizable($text_props_menu,0,0);
    &adjust_window_position($text_props_menu);
    $text_props_menu->g_focus;
}


sub set_text_props {
    my ($id, $text, $col, $fam, $siz, $wei, $sla, $und, $action) = @_;

    if ($text eq "") {
        &pop_up_error($main, "Text string is empty.\nPlease add some text.");
        $text_props_menu->g_raise();
        $text_props_menu->g_focus;
        return;
    }
    $canvas->itemconfigure($id,
                           -text => $text,
                           -fill => &get_rgb_code($col),
                           -font => [-family     => $fam,
                                     -size       => $siz,
                                     -weight     => $wei,
                                     -slant      => $slant_type[$sla],
                                     -underline  => $und,
                                     -overstrike => 0,
                                    ],
                          );
    $canvas->addtag("keep", withtag => $id);

    $props{$id}{text}      = $text;
    $props{$id}{color}     = $col;
    $props{$id}{family}    = $fam;
    $props{$id}{size}      = $siz;
    $props{$id}{weight}    = $wei;
    $props{$id}{slant}     = $sla;
    $props{$id}{underline} = $und;

    if ($action eq "OK") {
        $text_props_menu->g_destroy();
        undef $text_props_menu;
    }
}


sub edit_object_props {
    my ($id, $X, $Y) = @_;
    my ($ahd1, $ahd2, $ahd3, $amenu, $arrow, $arrow_opt, $code, $color,
        $color_btn, $f, $f_bot, $fc_btn, $fc_ck, $fcfg, $fcode, $fcolor,
        $fg, $fill, $frame, $geom, $is_link, $old_width, $ph, $preview, $pid,
        $pw, $row, $smenu, $smooth, $smooth_opt, $txt, $type, $width, $wmenu,
       );

    $geom = sprintf("+%d+%d", $X, $Y);

#   Get current properties of object.
    $type  = $props{$id}{type};
    $color = $props{$id}{color};
    $width = $props{$id}{width};
    if ($type eq "line" || $type eq "polyline") {
        $arrow = $props{$id}{arrow};
        $ahd1  = $props{$id}{ahd1};
        $ahd2  = $props{$id}{ahd2};
        $ahd3  = $props{$id}{ahd3};
    } else {
        $fill   = $props{$id}{fill};
        $fcolor = $props{$id}{fillcolor};
        $smooth = $props{$id}{smooth} if ($type =~ /^(rectangle|diamond)$/);
    }
    $is_link = (defined($link_props{$id}{id})) ? 1 : 0;

#   Create a new menu each time, because the old one was tied to
#   the previous object, and it's too much hassle to clean that up.

    if (defined($object_props_menu) && Tkx::winfo_exists($object_props_menu)) {
        if ($object_props_menu->g_wm_title() eq "Object Properties") {
            $object_props_menu->g_destroy();
            undef $object_props_menu;
        }
    }
    $object_props_menu = $main->new_toplevel();
    $object_props_menu->g_wm_transient($main);
    $object_props_menu->g_wm_title("Object Properties");
    $object_props_menu->configure(-cursor => $cursor_norm);
    $object_props_menu->g_wm_geometry($geom);

    $frame = $object_props_menu->new_frame();
    $frame->g_pack(-side => 'bottom');

    $frame->new_button(
            -text    => "OK",
            -command => sub { &set_object_props($id, $color, $width,
                                     $fill, $fcolor, $smooth,
                                     $arrow, $ahd1, $ahd2, $ahd3,
                                     "OK") },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Apply",
            -command => sub { &set_object_props($id, $color, $width,
                                     $fill, $fcolor, $smooth,
                                     $arrow, $ahd1, $ahd2, $ahd3,
                                     "Apply") },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Preview",
            -command => sub { &preview_object_props($id, $color, $width,
                                     $fill, $fcolor, $smooth,
                                     $arrow, $ahd1, $ahd2, $ahd3) },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { &restore_object_props($id) },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

    $f = $object_props_menu->new_frame();
    $f->g_pack(-side => 'top');

    $pw = 220;
    $ph = 80;
    $preview = $f->new_canvas(
            -background  => &get_rgb_code($canvas_color),
            -width       => $pw,
            -height      => $ph,
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $preview->g_pack(-side => 'top', -fill => 'x', -expand => 1);

    if ($type eq "rectangle") {
        $pid = $preview->create_polygon($pw*0.2 + 3, $ph*0.2 + 3,
                                        $pw*0.8 + 3, $ph*0.2 + 3,
                                        $pw*0.8 + 3, $ph*0.8 + 3,
                                        $pw*0.2 + 3, $ph*0.8 + 3,
                 -outline => &get_rgb_code($color),
                 -smooth  => $smooth_type[$smooth],
                 -width   => $width);
        if (! $fill || ($is_link && $fcolor eq "")) {
            $preview->itemconfigure($pid, -fill => "");
        } else {
            $preview->itemconfigure($pid, -fill => &get_rgb_code($fcolor));
        }
    } elsif ($type eq "diamond") {
        $pid = $preview->create_polygon($pw*0.5 + 3, $ph*0.2 + 3,
                                        $pw*0.8 + 3, $ph*0.5 + 3,
                                        $pw*0.5 + 3, $ph*0.8 + 3,
                                        $pw*0.2 + 3, $ph*0.5 + 3,
                 -outline => &get_rgb_code($color),
                 -smooth  => $smooth_type[$smooth],
                 -width   => $width);
        if (! $fill || ($is_link && $fcolor eq "")) {
            $preview->itemconfigure($pid, -fill => "");
        } else {
            $preview->itemconfigure($pid, -fill => &get_rgb_code($fcolor));
        }
    } elsif ($type eq "polygon") {
        $pid = $preview->create_polygon($pw*0.25 + 3, $ph*0.2 + 3,
                                        $pw*0.75 + 3, $ph*0.2 + 3,
                                        $pw*0.80 + 3, $ph*0.8 + 3,
                                        $pw*0.20 + 3, $ph*0.8 + 3,
                 -outline => &get_rgb_code($color),
                 -width   => $width);
        if (! $fill || ($is_link && $fcolor eq "")) {
            $preview->itemconfigure($pid, -fill => "");
        } else {
            $preview->itemconfigure($pid, -fill => &get_rgb_code($fcolor));
        }
    } elsif ($type eq "circle") {
        $pid = $preview->create_oval($pw*0.5 - $ph*0.3 + 3, $ph*0.2 + 3,
                                     $pw*0.5 + $ph*0.3 + 3, $ph*0.8 + 3,
                 -outline => &get_rgb_code($color),
                 -width   => $width);
        if (! $fill || ($is_link && $fcolor eq "")) {
            $preview->itemconfigure($pid, -fill => "");
        } else {
            $preview->itemconfigure($pid, -fill => &get_rgb_code($fcolor));
        }
    } elsif ($type eq "ellipse") {
        $pid = $preview->create_oval($pw*0.2 + 3, $ph*0.2 + 3,
                                     $pw*0.8 + 3, $ph*0.8 + 3,
                 -outline => &get_rgb_code($color),
                 -width   => $width);
        if (! $fill || ($is_link && $fcolor eq "")) {
            $preview->itemconfigure($pid, -fill => "");
        } else {
            $preview->itemconfigure($pid, -fill => &get_rgb_code($fcolor));
        }
    } elsif ($type eq "line" || $type eq "polyline") {
        $pid = $preview->create_line($pw*0.2 + 3, $ph*0.5 + 3,
                                     $pw*0.8 + 3, $ph*0.5 + 3,
                 -fill  => &get_rgb_code($color),
                 -width => $width,
                 -arrow => $arrow_type[$arrow],
            -arrowshape => [ $ahd1, $ahd2, $ahd3 ]);
    }

    $f_bot = $f->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f_bot->g_pack(-side => 'bottom', -fill => 'x', -expand => 1);

    $row = 0;
    if ($type eq "line" || $type eq "polyline") {
        $f_bot->new_label(
                -text => "Outline Width: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $wmenu = &native_optionmenu(
                $f_bot, 
                \$width,
                $width - 1,
                [ sub { $preview->itemconfigure($pid, -width => $width); } ],
                (1 .. 10),
                );
    } else {
        $f_bot->new_label(
                -text => "Outline Width: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $wmenu = &native_optionmenu(
                $f_bot, 
                \$width,
                $width,
                [ sub { my ($oc);
                        if ($width == 0) {
                            $preview->itemconfigure($pid, -outline => "");
                            $color_btn->configure(-state => 'disabled');
                        } elsif ($old_width == 0) {
                            $oc = $color_btn->cget(-background);
                            $preview->itemconfigure($pid, -width => $width,
                                                        -outline => &get_rgb_code($oc));
                            $color_btn->configure(-state => 'normal');
                        } else {
                            $preview->itemconfigure($pid, -width => $width);
                        }
                        $old_width = $width;
                      } ],
                (0 .. 10),
                );
        $old_width = $width;
    }
    $wmenu->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    if ($type =~ /^(rectangle|diamond)$/) {
        $row++;
        $f_bot->new_label(
                -text => "Corners: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $smooth_opt = $smooth_options[$smooth];
        $smenu = &native_optionmenu(
                $f_bot, 
                \$smooth_opt,
                $smooth,
                [ sub { my $s = &list_match($smooth_opt, @smooth_options);
                        if ($s >= 0) {
                          $smooth = $s;
                          $preview->itemconfigure($pid,
                                      -smooth => $smooth_type[$smooth]);
                        }
                      } ],
                @smooth_options,
                );
        $smenu->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    }

    $row++;
    $txt = "Outline Color: ";
    $txt = "Line Color: " if ($type eq "line" || $type eq "polyline");
    $f_bot->new_label(
            -text => $txt,
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);

    $code  = &get_rgb_code($color);
    $color = &get_rgb_name($code);
    $fg    = &get_rgb_code("black");
    if ($code =~ /^\#[0-9a-f]/i) {
        $fg = &get_rgb_code(&get_bw_contrast($code));
    }
    $color_btn = $f_bot->new_button(
            -textvariable => \$color,
            -background   => $code,
            -foreground   => $fg,
            -width        => -7,
            -command => sub {
                          my ($newc, $code, $fg);
                          $code = &get_rgb_code($color);
                          $newc = Tkx::tk___chooseColor(
                                        -initialcolor => $code,
                                        -parent       => $object_props_menu);
                          if ($newc) {
                            $code  = &get_rgb_code($newc);
                            $color = &get_rgb_name($code);
                            $fg    = &get_rgb_code("black");
                            if ($code =~ /^\#[0-9a-f]/i) {
                                $fg = &get_rgb_code(&get_bw_contrast($code));
                            }
                            $color_btn->configure(-foreground => $fg,
                                                  -background => $code);
                            if ($type ne "line" && $type ne "polyline") {
                                $preview->itemconfigure($pid, -outline => $code);
                            } else {
                                $preview->itemconfigure($pid, -fill => $code);
                            }
                          }
                        }
            );
    $color_btn->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);

    if ($type ne "line" && $type ne "polyline") {
        $row++;
        if ($is_link && $fcolor eq "") {
            $fcode = &get_rgb_code($canvas_color);
        } else {
            $fcode  = &get_rgb_code($fcolor);
            $fcolor = &get_rgb_name($fcode);
        }
        $fcfg = &get_rgb_code("black");
        if ($fcode =~ /^\#[0-9a-f]/i) {
            $fcfg = &get_rgb_code(&get_bw_contrast($fcode));
        }
        $fc_btn = $f_bot->new_button(
                -textvariable => \$fcolor,
                -background   => $fcode,
                -foreground   => $fcfg,
                -command => sub {
                              my ($newc, $code, $fg);
                              $code = &get_rgb_code($fcolor);
                              $newc = Tkx::tk___chooseColor(
                                            -initialcolor => $code,
                                            -parent       => $object_props_menu);
                              if ($newc) {
                                $code   = &get_rgb_code($newc);
                                $fcolor = &get_rgb_name($code);
                                $fg     = &get_rgb_code("black");
                                if ($code =~ /^#?[0-9a-f]/i) {
                                    $fg = &get_rgb_code(&get_bw_contrast($code));
                                }
                                $fc_btn->configure(-foreground => $fg,
                                                   -background => $code);
                                $preview->itemconfigure($pid, -fill => $code);
                              }
                            }
                );
        $fc_btn->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
        ($fc_ck = $f_bot->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "Fill with Color: ",
                -font     => 'default',
                -variable => \$fill,
                -command  => sub { 
                              if ($fill) {
                                $preview->itemconfigure($pid, -fill => &get_rgb_code($fcolor));
                                $fc_btn->configure(-state => 'normal');
                              } else {
                                $preview->itemconfigure($pid, -fill => "");
                                $fc_btn->configure(-state => 'disabled');
                              }
                             }
                ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        if ($is_link) {
            $fc_btn->configure(-state => 'disabled');
            $fc_ck->configure(-state => 'disabled');
        } elsif ($fill) {
            $fc_btn->configure(-state => 'normal');
        } else {
            $fc_btn->configure(-state => 'disabled');
        }
        if ($width == 0) {
            $color_btn->configure(-state => 'disabled');
        }

    } else {  # object is a line or polyline
        $row++;
        $f_bot->new_label(
                -text => "Arrowheads: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $arrow_opt = $arrow_options[$arrow];
        $amenu = &native_optionmenu(
                $f_bot, 
                \$arrow_opt,
                $arrow,
                [ sub { my $a = &list_match($arrow_opt, @arrow_options);
                        if ($a >= 0) {
                          $arrow = $a;
                          $preview->itemconfigure($pid,
                                      -arrow => $arrow_type[$arrow]);
                        }
                      } ],
                @arrow_options,
                );
        $amenu->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);

        $row++;
        $f_bot->new_label(
                -text    => "Arrowhead  \nCenter Length: ",
                -justify => 'right',
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'se', -pady => 2);
        $f_bot->new_scale(
                -orient   => 'horizontal',
                -from     => 6,
                -to       => 100,
                -variable => \$ahd1,
                -width    => 10,
                -sliderlength => 20,
                -takefocus    => 1,
                -command  => sub { $preview->itemconfigure($pid,
                                      -arrowshape => [ $ahd1, $ahd2, $ahd3 ]);
                                 },
                )->g_grid(-row => $row, -column => 1,
                                        -sticky => 'ew', -pady => 2);
        $row++;
        $f_bot->new_label(
                -text    => "Arrowhead  \nSide Length: ",
                -justify => 'right',
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'se', -pady => 2);
        $f_bot->new_scale(
                -orient   => 'horizontal',
                -from     => 10,
                -to       => 100,
                -variable => \$ahd2,
                -width    => 10,
                -sliderlength => 20,
                -takefocus    => 1,
                -command  => sub { $preview->itemconfigure($pid,
                                      -arrowshape => [ $ahd1, $ahd2, $ahd3 ]);
                                 },
                )->g_grid(-row => $row, -column => 1,
                                        -sticky => 'ew', -pady => 2);
        $row++;
        $f_bot->new_label(
                -text    => "Arrowhead  \nHalf Width: ",
                -justify => 'right',
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'se', -pady => 2);
        $f_bot->new_scale(
                -orient   => 'horizontal',
                -from     => 3,
                -to       => 40,
                -variable => \$ahd3,
                -width    => 10,
                -sliderlength => 20,
                -takefocus    => 1,
                -command  => sub { $preview->itemconfigure($pid,
                                      -arrowshape => [ $ahd1, $ahd2, $ahd3 ]);
                                 },
                )->g_grid(-row => $row, -column => 1,
                                        -sticky => 'ew', -pady => 2);
    }

    Tkx::wm_resizable($object_props_menu,0,0);
    &adjust_window_position($object_props_menu);
    $object_props_menu->g_focus;
}


sub set_object_props {
    my ($id, $color, $width, $fill, $fcolor, $smooth,
        $arrow, $ahd1, $ahd2, $ahd3, $action) = @_;
    my ($type);

    $props{$id}{color} = $color;
    $props{$id}{width} = $width;
    $type              = $props{$id}{type};

    if ($type =~ /^(circle|ellipse|rectangle|diamond|polygon)$/) {
        $props{$id}{fill}      = $fill;
        $props{$id}{fillcolor} = $fcolor;
        if ($fill && $fcolor ne "") {
            $canvas->itemconfigure($id, -fill => &get_rgb_code($fcolor));
        } else {
            $canvas->itemconfigure($id, -fill => "");
        }
        if ($type =~ /^(rectangle|diamond)$/) {
            $props{$id}{smooth} = $smooth;
            $canvas->itemconfigure($id, -smooth => $smooth_type[$smooth]);
        }
        if ($width == 0) {
            $canvas->itemconfigure($id, -outline => "");
        } else {
            $canvas->itemconfigure($id, -outline => &get_rgb_code($color),
                                        -width   => $width);
        }

    } elsif ($type eq "line" || $type eq "polyline") {
        $props{$id}{arrow} = $arrow;
        $props{$id}{ahd1}  = $ahd1;
        $props{$id}{ahd2}  = $ahd2;
        $props{$id}{ahd3}  = $ahd3;
        $canvas->itemconfigure($id, -fill  => &get_rgb_code($color),
                                    -width => $width,
                                    -arrow => $arrow_type[$arrow],
                               -arrowshape => [ $ahd1, $ahd2, $ahd3 ]);
    }
    if ($action eq "OK") {
        $object_props_menu->g_destroy();
        undef $object_props_menu;
    }
}


sub preview_object_props {
    my ($id, $color, $width, $fill, $fcolor, $smooth,
        $arrow, $ahd1, $ahd2, $ahd3) = @_;
    my ($type);

    $type = $props{$id}{type};

    if ($type =~ /^(circle|ellipse|rectangle|diamond|polygon)$/) {
        if ($fill && $fcolor ne "") {
            $canvas->itemconfigure($id, -fill => &get_rgb_code($fcolor));
        } else {
            $canvas->itemconfigure($id, -fill => "");
        }
        if ($type =~ /^(rectangle|diamond)$/) {
            $canvas->itemconfigure($id, -smooth => $smooth_type[$smooth]);
        }
        if ($width == 0) {
            $canvas->itemconfigure($id, -outline => "");
        } else {
            $canvas->itemconfigure($id, -outline => &get_rgb_code($color),
                                        -width   => $width);
        }

    } elsif ($type eq "line" || $type eq "polyline") {
        $canvas->itemconfigure($id, -fill  => &get_rgb_code($color),
                                    -width => $width,
                                    -arrow => $arrow_type[$arrow],
                               -arrowshape => [ $ahd1, $ahd2, $ahd3 ]);
    }
}


sub restore_object_props {
    my ($id) = @_;
    my ($ahd1, $ahd2, $ahd3, $arrow, $color, $fcolor, $fill, $smooth, $type, $width);

    $type  = $props{$id}{type};
    $color = $props{$id}{color};
    $width = $props{$id}{width};

    if ($type =~ /^(circle|ellipse|rectangle|diamond|polygon)$/) {
        $fill   = $props{$id}{fill};
        $fcolor = $props{$id}{fillcolor};
        if ($fill && $fcolor ne "") {
            $canvas->itemconfigure($id, -fill => &get_rgb_code($fcolor));
        } else {
            $canvas->itemconfigure($id, -fill => "");
        }
        if ($type =~ /^(rectangle|diamond)$/) {
            $smooth = $props{$id}{smooth};
            $canvas->itemconfigure($id, -smooth => $smooth_type[$smooth]);
        }
        if ($width == 0) {
            $canvas->itemconfigure($id, -outline => "");
        } else {
            $canvas->itemconfigure($id, -outline => &get_rgb_code($color),
                                        -width   => $width);
        }

    } elsif ($type eq "line" || $type eq "polyline") {
        $arrow = $props{$id}{arrow};
        $ahd1  = $props{$id}{ahd1};
        $ahd2  = $props{$id}{ahd2};
        $ahd3  = $props{$id}{ahd3};
        $canvas->itemconfigure($id, -fill  => &get_rgb_code($color),
                                    -width => $width,
                                    -arrow => $arrow_type[$arrow],
                               -arrowshape => [ $ahd1, $ahd2, $ahd3 ]);
    }
    $object_props_menu->g_destroy();
    undef $object_props_menu;
}


sub edit_graph_props {
    my ($id, $X, $Y, $tabid) = @_;
    my (

        $anc, $bgrid, $bgrid_ck, $bgrid_col, $bgrid_col_btn, $bh_bcellh,
        $bh_bcellh_entry, $bh_bcellh_label, $bh_bcellh_label2, $bh_bcellw,
        $bh_bcolor, $bh_bcolor_btn, $bh_bwidth, $bh_docked, $bh_font,
        $bh_font_cb, $bh_frame, $bh_show, $bh_size, $bh_size_cb, $bh_status,
        $bh_status_cb, $bh_status_opt, $bh_tcolor, $bh_tcolor_btn,
        $bh_weight, $bh_weight_cb, $bulkhead_box, $bulkhead_tab,
        $bulkhead_txt, $byear, $byear_cb, $byear_frame, $byear_label,
        $code, $color_btn, $cs_height, $cs_link, $cs_major, $cs_max,
        $cs_min, $cs_rev, $cs_status, $cs_width, $csinc_entry, $cslink_cb,
        $cslink_opt, $csmajor_entry, $csmax_entry, $csmin_entry, $cstatus_cb,
        $cstatus_opt, $dateline, $dateline_ok, $datelinec, $datelinec_btn,
        $down_img, $elev_base, $f, $fg, $fmt, $fmt_w, $frame, $gap_tol,
        $gaptol_frame, $gaptol_entry, $geom, $grid_frame, $grid_tab,
        $gridcolor, $gridcolor_btn, $gridwidth, $gridwidth_sb, $gridx,
        $gridy, $gs_bg_box, $gs_color, $gs_color_btn, $gs_edge, $gs_edgec,
        $gs_edgec_btn, $gs_fill, $gs_fillc, $gs_fillc_btn, $gs_fmt, $gs_pos,
        $gs_size, $gs_size_cb, $gs_weight, $gs_weight_cb, $gstitle,
        $gsub_box, $gsubtitle_txt, $gt_size, $gt_size_cb, $gt_weight,
        $gt_weight_cb, $gtfont, $gtfont_cb, $gtitle, $gtitle_frame,
        $gtitle_tab, $gtitle_txt, $i, $indx, $jd_max, $jd_min, $keyfont,
        $keyfont_cb, $keynum_txt, $keytxt_frame, $keytxt_tab, $keytitle,
        $keytitle_txt, $kn_digits, $kn_size, $kn_size_cb, $kn_weight,
        $kn_weight_cb, $kt_size, $kt_size_cb, $kt_weight, $kt_weight_cb,
        $label_txt, $le_edge, $le_edgec, $le_edgec_btn, $le_fill,
        $le_fillc, $le_fillc_btn, $le_size, $le_size_cb, $le_weight,
        $le_weight_cb, $legend_box, $legend_frame, $legend_line, $legend_tab,
        $legend_txt, $legfont, $legfont_cb, $legtitle, $legtitle_txt,
        $link_id, $lt_size, $lt_size_cb, $lt_weight, $lt_weight_cb, $n,
        $ncolors, $ncolors_cb, $old_ref_size, $old_stic_loc, $old_wl_style,
        $old_xunits, $old_yaxis_type, $old_yunits, $outlet_frame, $pc_style,
        $pc_style_cb, $ph, $pix, $pr_linec, $pr_linec_btn, $pr_linew,
        $pr_style, $pr_style_cb, $pre_color, $pre_width, $preview_bh,
        $preview_grid, $preview_gtitle, $preview_keytxt, $preview_legend,
        $preview_levels, $preview_profile, $preview_saxis, $preview_scheme,
        $preview_tsdata, $preview_xaxis_txt, $preview_yaxis_txt,
        $profile_frame, $profile_tab, $pw, $qaxis_units, $ref_color,
        $ref_color_btn, $ref_linew, $ref_size, $ref_size_cb, $reverse_cb,
        $reverse_opt, $row, $row2, $saxis_frame, $saxis_opt, $saxis_tab,
        $sc_canv, $sc_fr, $scheme_tab, $scheme_frame, $scheme1, $scheme2,
        $scheme1_cb, $scheme2_cb, $scroll_frame, $sfont, $sfont_cb, $sgrid,
        $sgrid_ck, $sgrid_col, $sgrid_col_btn, $sl_size, $sl_size_cb,
        $sl_weight, $sl_weight_cb, $smajor, $smajor_entry, $sop_tics,
        $sop_tics_cb, $spr_tics, $spr_tics_cb, $st_size, $st_size_cb,
        $st_weight, $st_weight_cb, $stic_dx, $stic_loc, $stic_loc_cb,
        $stitle, $stitle_entry, $stitle_txt, $stype, $stype_cb, $sub_txt,
        $swapsets, $ts_type, $tsdata_frame, $tsdata_line, $tsdata_tab,
        $tsdata_txt, $tsxmin, $up_img, $vscroll, $wl_color, $wl_frame,
        $wl_grid, $wl_gridc, $wl_gridc_btn, $wl_style, $wlcolor_btn,
        $wlevel_frame, $wlevel_tab, $wlstyle_cb, $wt_oldunits, $wt_units,
        $wt_units_cb, $x1, $x2, $xaxis_flip, $xaxis_frame, $xaxis_tab,
        $xaxis_type, $xaxis_type_cb, $xaxis_units, $xbase, $xbase_entry,
        $xfirst, $xfirst_entry, $xfont, $xfont_cb, $xformat, $xformat_cb,
        $xformat_label, $xgrid_line1, $xgrid_line2, $xgrid_line3,
        $xl_size, $xl_size_cb, $xl_weight, $xl_weight_cb, $xmaj_auto,
        $xmajor, $xmajor_entry, $xmax, $xmax_auto, $xmax_cb, $xmax_entry,
        $xmax_frame, $xmin, $xmin_cb, $xmin_entry, $xop_tics, $xp,
        $xpr_tics, $xt_size, $xt_size_cb, $xt_weight, $xt_weight_cb,
        $xtick_auto_cb, $xtick_int_sb, $xtick_frame, $xticklabel_txt,
        $xtitle, $xtitle_entry, $xtitle_frame, $xtitle_label,
        $xtitle_txt, $xtype_frame, $xtype_old, $xtype_sav, $xunits_cb,
        $xunits_frame, $yaxis_flip, $yaxis_frame, $yaxis_tab, $yaxis_type,
        $yaxis_type_cb, $yaxis_units, $yaxis_units_cb, $yaxis_units_label,
        $ybase, $ybase_entry, $yfirst, $yfirst_entry, $yfont, $yfont_cb,
        $yformat, $yformat_cb, $yformat_label, $ygrid_line1, $ygrid_line2,
        $yl_size, $yl_size_cb, $yl_weight, $yl_weight_cb, $ymaj_auto,
        $ymajor, $ymajor_entry, $ymajor_label, $ymax, $ymax_auto,
        $ymax_cb, $ymax_entry, $ymax_frame, $ymax_label, $ymin, $ymin_cb,
        $ymin_entry, $ymin_label, $yop_tics, $yp, $ypr_tics, $yr_max,
        $yr_min, $yt_size, $yt_size_cb, $yt_weight, $yt_weight_cb,
        $ytick_auto_cb, $ytick_frame, $ytick_int_sb, $yticklabel_txt,
        $ytitle, $ytitle_entry, $ytitle_frame, $ytitle_label, $ytitle_txt,
        $ytype_frame, $ytype_old, $ytype_sav, $yunits_cb, $yunits_frame,

        @add_ts_byear, @add_ts_color, @add_ts_ctype, @add_ts_delete,
        @add_ts_file, @add_ts_ftype, @add_ts_limits, @add_ts_lines,
        @add_ts_param, @add_ts_seg, @add_ts_setnum, @add_ts_show,
        @add_ts_text, @add_ts_tsdata, @add_ts_tzoff, @add_ts_width,
        @bh_status_opts, @color_btns, @colors, @coords, @cslink_opts,
        @date_axis_choices, @datelist1, @datelist2, @down_btn, @names,
        @ref_pts, @saxis_opts, @saxis_types, @tic_opts, @ts_color,
        @ts_color_btns, @ts_show, @ts_text_entry, @ts_width, @ts_width_sbs,
        @up_btn, @width_sbs,

        %add_ts_parms, %parms,
       );

    $tabid = 0 if (! defined($tabid));
    $geom  = sprintf("+%d+%d", $X, $Y);

    if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
        if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
            $graph_props_menu->g_destroy();
            undef $graph_props_menu;
        }
    }
    $graph_props_menu = $main->new_toplevel();
    $graph_props_menu->g_wm_transient($main);
    $graph_props_menu->g_wm_title("Graph Properties, ID $id");
    $graph_props_menu->configure(-cursor => $cursor_norm);
    $graph_props_menu->g_wm_geometry($geom);

    $xfirst = $yfirst = $xbase = $ybase = "";
    if ($props{$id}{meta} eq "w2_tdmap") {
        if ($gr_props{$id}{date_axis} eq "X") {
            $xfont     = $gr_props{$id}{tfont};
            $xt_size   = $gr_props{$id}{tt_size};
            $xt_weight = $gr_props{$id}{tt_weight};
            $xl_size   = $gr_props{$id}{tl_size};
            $xl_weight = $gr_props{$id}{tl_weight};
            $xmin      = $gr_props{$id}{tmin};
            $xmax      = $gr_props{$id}{tmax};
            $xmajor    = $gr_props{$id}{tmajor};
            $xpr_tics  = $gr_props{$id}{tpr_tics};
            $xop_tics  = $gr_props{$id}{top_tics};
            $xtitle    = $gr_props{$id}{ttitle};
            $yfont     = $gr_props{$id}{dfont};
            $yt_size   = $gr_props{$id}{dt_size};
            $yt_weight = $gr_props{$id}{dt_weight};
            $yl_size   = $gr_props{$id}{dl_size};
            $yl_weight = $gr_props{$id}{dl_weight};
            $ybase     = $gr_props{$id}{dbase};
            $ymin      = $gr_props{$id}{dmin};
            $ymax      = $gr_props{$id}{dmax};
            $yfirst    = $gr_props{$id}{dfirst};
            $ymajor    = $gr_props{$id}{dmajor};
            $ypr_tics  = $gr_props{$id}{dpr_tics};
            $yop_tics  = $gr_props{$id}{dop_tics};
            $ytitle    = $gr_props{$id}{dtitle};
        } else {
            $xfont     = $gr_props{$id}{dfont};
            $xt_size   = $gr_props{$id}{dt_size};
            $xt_weight = $gr_props{$id}{dt_weight};
            $xl_size   = $gr_props{$id}{dl_size};
            $xl_weight = $gr_props{$id}{dl_weight};
            $xbase     = $gr_props{$id}{dbase};
            $xmin      = $gr_props{$id}{dmin};
            $xmax      = $gr_props{$id}{dmax};
            $xfirst    = $gr_props{$id}{dfirst};
            $xmajor    = $gr_props{$id}{dmajor};
            $xpr_tics  = $gr_props{$id}{dpr_tics};
            $xop_tics  = $gr_props{$id}{dop_tics};
            $xtitle    = $gr_props{$id}{dtitle};
            $yfont     = $gr_props{$id}{tfont};
            $yt_size   = $gr_props{$id}{tt_size};
            $yt_weight = $gr_props{$id}{tt_weight};
            $yl_size   = $gr_props{$id}{tl_size};
            $yl_weight = $gr_props{$id}{tl_weight};
            $ymin      = $gr_props{$id}{tmin};
            $ymax      = $gr_props{$id}{tmax};
            $ymajor    = $gr_props{$id}{tmajor};
            $ypr_tics  = $gr_props{$id}{tpr_tics};
            $yop_tics  = $gr_props{$id}{top_tics};
            $ytitle    = $gr_props{$id}{ttitle};
        }
    } else {
        $xfont     = $gr_props{$id}{xfont};
        $xt_size   = $gr_props{$id}{xt_size};
        $xt_weight = $gr_props{$id}{xt_weight};
        $xl_size   = $gr_props{$id}{xl_size};
        $xl_weight = $gr_props{$id}{xl_weight};
        $xmin      = $gr_props{$id}{xmin};
        $xmax      = $gr_props{$id}{xmax};
        $xmajor    = $gr_props{$id}{xmajor};
        $xpr_tics  = $gr_props{$id}{xpr_tics};
        $xop_tics  = $gr_props{$id}{xop_tics};
        $xtitle    = $gr_props{$id}{xtitle};
        $yfont     = $gr_props{$id}{yfont};
        $yt_size   = $gr_props{$id}{yt_size};
        $yt_weight = $gr_props{$id}{yt_weight};
        $yl_size   = $gr_props{$id}{yl_size};
        $yl_weight = $gr_props{$id}{yl_weight};
        $ymin      = $gr_props{$id}{ymin};
        $ymax      = $gr_props{$id}{ymax};
        $ymajor    = $gr_props{$id}{ymajor};
        $ypr_tics  = $gr_props{$id}{ypr_tics};
        $yop_tics  = $gr_props{$id}{yop_tics};
        $ytitle    = $gr_props{$id}{ytitle};
    }
    if ($props{$id}{meta} =~ /w2_slice|w2_wlevels/) {
        $xbase     = $gr_props{$id}{xbase};
        $xfirst    = $gr_props{$id}{xfirst};
        $stype     = $gr_props{$id}{stype};
        $sfont     = $gr_props{$id}{sfont};
        $st_size   = $gr_props{$id}{st_size};
        $st_weight = $gr_props{$id}{st_weight};
        $sl_size   = $gr_props{$id}{sl_size};
        $sl_weight = $gr_props{$id}{sl_weight};
        $smajor    = $gr_props{$id}{smajor};
        $stic_loc  = $gr_props{$id}{stic_loc};
        $sgrid     = $gr_props{$id}{sgrid};
        $sgrid_col = $gr_props{$id}{sgrid_col};
        $bgrid     = $gr_props{$id}{bgrid};
        $bgrid_col = $gr_props{$id}{bgrid_col};
        $stitle    = $gr_props{$id}{stitle};
        $spr_tics  = $gr_props{$id}{spr_tics};
        $sop_tics  = $gr_props{$id}{sop_tics};
    } else {
        $stype    = $sfont    = $st_size = $st_weight = $sl_size = $sl_weight = "";
        $smajor   = $stic_loc = $sgrid   = $sgrid_col = $bgrid   = $bgrid_col = $stitle = "";
        $spr_tics = $sop_tics = "";
    }
    $gtfont    = $gr_props{$id}{gtfont};
    $gt_size   = $gr_props{$id}{gt_size};
    $gt_weight = $gr_props{$id}{gt_weight};
    $gtitle    = $gr_props{$id}{gtitle};
    $swapsets  = 0;
    $bh_status = 0;
    $gap_tol   = $wl_color = $wl_style  = $wl_grid  = $wl_gridc = $dateline = $datelinec = "";
    $le_edge   = $le_edgec = $le_fill   = $le_fillc = "";
    $pr_style  = $pr_linec = $pr_linew  = $pc_style = "";
    $ref_color = $ref_size = $ref_linew = "";
    @tic_opts  = ("outside", "inside", "cross", "none");

    if ($props{$id}{meta} =~ /data_profile|w2_profile|w2_slice|w2_outflow|vert_wd_zone/) {
        $yaxis_type     = $gr_props{$id}{ytype};
        $old_yaxis_type = $yaxis_type;
        $yaxis_units    = $gr_props{$id}{yunits};
        $elev_base      = -999;
        $qaxis_units    = $wt_units   = $wt_oldunits = "";
        $xaxis_units    = $xaxis_flip = "";
        $xmax_auto      = 0;
        if ($props{$id}{meta} eq "vert_wd_zone") {
            $qaxis_units = $gr_props{$id}{qunits};
            $wt_units    = $props{$id}{wt_units};
            $wt_oldunits = $wt_units;
            $xmin        = 0;
        }
        if ($props{$id}{meta} =~ /data_profile|w2_profile/ && $props{$id}{parm} eq "Temperature") {
            $wt_units    = $props{$id}{parm_units};
            $wt_oldunits = $wt_units;
        }
        if ($props{$id}{meta} eq "w2_slice") {
            $xaxis_units = $gr_props{$id}{xunits};
            $xaxis_flip  = $gr_props{$id}{xflip};
            $xmax_auto   = $gr_props{$id}{xmax_auto};
            $old_xunits  = $xaxis_units;
            if ($props{$id}{parm} eq "Temperature") {
                $wt_units    = $props{$id}{parm_units};
                $wt_oldunits = $wt_units;
            }
        }
        if ($props{$id}{meta} eq "w2_outflow") {
            if ($props{$id}{add_parm} && $props{$id}{parm} eq "Temperature") {
                $wt_units    = $props{$id}{parm_units};
                $wt_oldunits = $wt_units;
            }
            $qaxis_units = $gr_props{$id}{qunits};
            $xmin        = 0;
        }
    } else {
        $yaxis_type  = $yaxis_units = $qaxis_units = $wt_units = "";
        $xaxis_units = $xaxis_flip  = $old_xunits  = "";
        $xmax_auto   = $ymax_auto   = 0;
        if ($props{$id}{meta} eq "w2_tdmap") {
            if ($gr_props{$id}{date_axis} eq "X") {
                $yaxis_flip  = $gr_props{$id}{dflip};
                $yaxis_units = $gr_props{$id}{dunits};
                $ymax_auto   = $gr_props{$id}{dmax_auto};
                $old_yunits  = $yaxis_units;
            } else {
                $xaxis_flip  = $gr_props{$id}{dflip};
                $xaxis_units = $gr_props{$id}{dunits};
                $xmax_auto   = $gr_props{$id}{dmax_auto};
                $old_xunits  = $xaxis_units;
            }
            if ($props{$id}{parm} eq "Temperature") {
                $wt_units    = $props{$id}{parm_units};
                $wt_oldunits = $wt_units;
            }
        } elsif ($props{$id}{meta} eq "w2_wlevels") {
            $yaxis_type  = "Elevation";
            $yaxis_units = $gr_props{$id}{yunits};
            $xaxis_units = $gr_props{$id}{xunits};
            $xaxis_flip  = $gr_props{$id}{xflip};
            $xmax_auto   = $gr_props{$id}{xmax_auto};
            $old_xunits  = $xaxis_units;
        }
    }
    if ($props{$id}{meta} =~ /(data_profile_cmap|w2_profile_cmap|w2_tdmap|time_series)/) {
        if ($props{$id}{meta} eq "w2_tdmap") {
            if ($gr_props{$id}{date_axis} eq "X") {
                $xaxis_type = $gr_props{$id}{ttype};
                $xaxis_flip = $gr_props{$id}{tflip};
                $xformat    = $gr_props{$id}{datefmt};
                $xtype_sav  = $xtype_old = $xaxis_type;
                $xmaj_auto  = ($xmajor eq "auto" || $xformat eq "Month") ? 1 : 0;
                $xmajor     = 10 if ($xmajor eq "auto");
            } else {
                $yaxis_type = $gr_props{$id}{ttype};
                $yaxis_flip = $gr_props{$id}{tflip};
                $yformat    = $gr_props{$id}{datefmt};
                $ytype_sav  = $ytype_old = $yaxis_type;
                $ymaj_auto  = ($ymajor eq "auto" || $yformat eq "Month") ? 1 : 0;
                $ymajor     = 10 if ($ymajor eq "auto");
            }
        } else {
            $xaxis_type = (defined($gr_props{$id}{xtype})) ? $gr_props{$id}{xtype} : "Date/Time";
            $xtype_sav  = $xtype_old = $xaxis_type;
            $xformat    = $gr_props{$id}{datefmt};
            $xmaj_auto  = ($xmajor eq "auto" || $xformat eq "Month") ? 1 : 0;
            $xmajor     = 10 if ($xmajor eq "auto");
            $xaxis_flip = 0;
            $dateline   = $gr_props{$id}{dateline};
            $datelinec  = $gr_props{$id}{datelinec};
        }
        $gs_size = $gs_weight = $gs_pos  = $gs_fmt   = $gstitle  = "";
        $gs_edge = $gs_edgec  = $gs_fill = $gs_fillc = $gs_color = "";
        $yr_max  = (localtime(time))[5] +1900;
        $yr_min  = $yr_max -25;
        $byear   = $yr_max;
        if (defined($gr_props{$id}{base_yr})) {
            $byear  = $gr_props{$id}{base_yr};
            $yr_min = $byear -10 if ($byear <= $yr_min);
            $yr_max = $byear +10 if ($byear >  $yr_max);
        }
        if ($props{$id}{meta} eq "linked_time_series") {
            ($jd_min, $jd_max) = &dates2jdates($dates[0], $dates[$#dates]);
        } elsif ($props{$id}{meta} eq "time_series") {
            if (defined($ts_datemin)) {
                ($jd_min, $jd_max) = &dates2jdates($ts_datemin, $ts_datemax);
            } else {
                $jd_min = &datelabel2jdate($xmin);   # fallback option
                $jd_max = &datelabel2jdate($xmax);
            }
        } else {
            ($jd_min, $jd_max) = &dates2jdates($cmap_datemin, $cmap_datemax);
        }
        $jd_min    = &floor($jd_min +0.0000001);
        $jd_max    = &floor($jd_max +1.0000001);
        @datelist1 = &jdates2datelabels("Mon-DD-YYYY", ($jd_min .. $jd_max));
        @datelist2 = @datelist1;
        pop   @datelist1;               # remove last  entry from list 1
        shift @datelist2;               # remove first entry from list 2
        $xmin = $datelist1[0]           if ($xmin eq "first");
        $xmax = $datelist2[$#datelist2] if ($xmax eq "last");
        @date_axis_choices = ("Year", "Month", "Mon-DD", "Mon-DD-YYYY");
        shift @date_axis_choices if ($jd_max -$jd_min <= 365 *2);
    } else {
        $xformat   = "";
        $gstitle   = "";
        $gs_size   = $gr_props{$id}{gs_size};
        $gs_weight = $gr_props{$id}{gs_weight};
        $gs_pos    = $gs_fmt = $gs_edge = $gs_edgec = $gs_fill = $gs_fillc = $gs_color = "";
        if ($props{$id}{meta} eq "w2_profile_matrix") {
            $gs_pos   = $gr_props{$id}{gs_pos};
            $gs_fmt   = $gr_props{$id}{gs_fmt};
            $gs_color = $gr_props{$id}{gs_color};
            $gs_edge  = $gr_props{$id}{gs_edge};
            $gs_edgec = $gr_props{$id}{gs_edgec};
            $gs_fill  = $gr_props{$id}{gs_fill};
            $gs_fillc = $gr_props{$id}{gs_fillc};
        }
        if ($props{$id}{meta} =~ /^(w2_profile|w2_profile_matrix)$/ && defined($props{$id}{ref_file})) {
            $ref_color = $props{$id}{ref_color};
            $ref_size  = $props{$id}{ref_size};
            $ref_linew = $props{$id}{ref_linew};
        }
    }
    if ($props{$id}{meta} eq "w2_tdmap") {
        $gs_size   = $gr_props{$id}{gs_size};
        $gs_weight = $gr_props{$id}{gs_weight};
        $gstitle   = $gr_props{$id}{gstitle};
    }
    @ts_color = @ts_show = @ts_width = ();
    @add_ts_color = @add_ts_setnum = @add_ts_show = @add_ts_text = @add_ts_width = ();

    $frame = $graph_props_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    $frame->new_button(
            -text    => "OK",
            -command => sub { &update_graph_props($id,
                               $xfont, $xt_size, $xt_weight, $xl_size, $xl_weight, $xbase, $xmin, $xmax,
                               $xfirst, $xmajor, $xmaj_auto, $xformat, $xtitle, $xpr_tics, $xop_tics,
                               $xaxis_type, $xaxis_units, $xaxis_flip, $xmax_auto, $byear,
                               $yfont, $yt_size, $yt_weight, $yl_size, $yl_weight, $ybase, $ymin, $ymax,
                               $yfirst, $ymajor, $ymaj_auto, $yformat, $ytitle, $ypr_tics, $yop_tics,
                               $yaxis_type, $yaxis_units, $yaxis_flip, $ymax_auto, $qaxis_units, $wt_units,
                               $stype, $sfont, $st_size, $st_weight, $sl_size, $sl_weight, $stic_loc,
                               $smajor, $sgrid, $sgrid_col, $bgrid, $bgrid_col, $stitle, $spr_tics, $sop_tics,
                               $gtfont, $gt_size, $gt_weight, $gs_size, $gs_weight, $gs_pos, $gs_fmt,
                               $gs_color, $gs_edge, $gs_edgec, $gs_fill, $gs_fillc, $gtitle, $gstitle,
                               $cs_status, $cs_link, $scheme1, $scheme2, $ncolors, $cs_rev,
                               $cs_min, $cs_max, $cs_major, $cs_width, $cs_height,
                               $keyfont, $keytitle, $kt_size, $kt_weight,
                               $kn_size, $kn_weight, $kn_digits, $pr_style, $pr_linec, $pr_linew, $pc_style,
                               $bh_status, $bh_font, $bh_size, $bh_weight, $bh_tcolor,
                               $bh_bwidth, $bh_bcolor, $bh_bcellw, $bh_bcellh,
                               $legfont, $lt_size, $lt_weight, $le_size, $le_weight,
                               $le_edge, $le_edgec, $le_fill, $le_fillc, $gap_tol,
                               $gridx, $gridy, $gridwidth, $gridcolor, $dateline, $datelinec,
                               $ref_color, $ref_size, $ref_linew,
                               $wl_color, $wl_style, $wl_grid, $wl_gridc,
                               \@ts_show, \@ts_color, \@ts_width, $legtitle, $swapsets,
                               \@add_ts_show, \@add_ts_setnum, \@add_ts_color, \@add_ts_width,
                               \@add_ts_text, \@add_ts_delete, \@add_ts_file, \@add_ts_ftype,
                               \@add_ts_lines, \@add_ts_param, \@add_ts_byear, \@add_ts_tzoff,
                               \@add_ts_seg, \@add_ts_ctype, \@add_ts_limits, \@add_ts_tsdata,
                               "OK");
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Apply",
            -command => sub { my $tabid = $grprops_notebook->index('current');
                              my $geom  = $graph_props_menu->g_wm_geometry();
                              (undef, $X, $Y) = split(/\+/, $geom);
                              &update_graph_props($id,
                               $xfont, $xt_size, $xt_weight, $xl_size, $xl_weight, $xbase, $xmin, $xmax,
                               $xfirst, $xmajor, $xmaj_auto, $xformat, $xtitle, $xpr_tics, $xop_tics,
                               $xaxis_type, $xaxis_units, $xaxis_flip, $xmax_auto, $byear,
                               $yfont, $yt_size, $yt_weight, $yl_size, $yl_weight, $ybase, $ymin, $ymax,
                               $yfirst, $ymajor, $ymaj_auto, $yformat, $ytitle, $ypr_tics, $yop_tics,
                               $yaxis_type, $yaxis_units, $yaxis_flip, $ymax_auto, $qaxis_units, $wt_units,
                               $stype, $sfont, $st_size, $st_weight, $sl_size, $sl_weight, $stic_loc,
                               $smajor, $sgrid, $sgrid_col, $bgrid, $bgrid_col, $stitle, $spr_tics, $sop_tics,
                               $gtfont, $gt_size, $gt_weight, $gs_size, $gs_weight, $gs_pos, $gs_fmt,
                               $gs_color, $gs_edge, $gs_edgec, $gs_fill, $gs_fillc, $gtitle, $gstitle,
                               $cs_status, $cs_link, $scheme1, $scheme2, $ncolors, $cs_rev,
                               $cs_min, $cs_max, $cs_major, $cs_width, $cs_height,
                               $keyfont, $keytitle, $kt_size, $kt_weight,
                               $kn_size, $kn_weight, $kn_digits, $pr_style, $pr_linec, $pr_linew, $pc_style,
                               $bh_status, $bh_font, $bh_size, $bh_weight, $bh_tcolor,
                               $bh_bwidth, $bh_bcolor, $bh_bcellw, $bh_bcellh,
                               $legfont, $lt_size, $lt_weight, $le_size, $le_weight,
                               $le_edge, $le_edgec, $le_fill, $le_fillc, $gap_tol,
                               $gridx, $gridy, $gridwidth, $gridcolor, $dateline, $datelinec,
                               $ref_color, $ref_size, $ref_linew,
                               $wl_color, $wl_style, $wl_grid, $wl_gridc,
                               \@ts_show, \@ts_color, \@ts_width, $legtitle, $swapsets,
                               \@add_ts_show, \@add_ts_setnum, \@add_ts_color, \@add_ts_width,
                               \@add_ts_text, \@add_ts_delete, \@add_ts_file, \@add_ts_ftype,
                               \@add_ts_lines, \@add_ts_param, \@add_ts_byear, \@add_ts_tzoff,
                               \@add_ts_seg, \@add_ts_ctype, \@add_ts_limits, \@add_ts_tsdata,
                               "Apply", $X, $Y, $tabid);
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $graph_props_menu->g_destroy();
                              undef $graph_props_menu; },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

    $f = $graph_props_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f->g_pack(-side => 'top');

#   Create tabbed notebook
    $grprops_notebook = $f->new_ttk__notebook();
    $grprops_notebook->g_pack();
    $pw = 270;
    $ph = 45;

#   X axis tab
    $xaxis_tab = $grprops_notebook->new_frame();
    $grprops_notebook->add($xaxis_tab,
            -text      => "X Axis",
            -underline => 0,
            -sticky    => 'nsew',
            );

    $preview_xaxis_txt = $xaxis_tab->new_canvas(
            -background  => &get_rgb_code($canvas_color),
            -width       => $pw,
            -height      => $ph,
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $preview_xaxis_txt->g_grid(-row => 0, -column => 0, -sticky => 'wne');

    $xtitle_txt = $preview_xaxis_txt->create_text($pw*0.3 +3, $ph*0.5 +3,
            -anchor => 'center', 
            -text   => "Axis Title",
            -fill   => "#000000",
            -angle  => 0,
            -font   => [-family     => $xfont,
                        -size       => $xt_size,
                        -weight     => $xt_weight,
                        -slant      => 'roman',
                        -underline  => 0,
                        -overstrike => 0,
                       ]);
    $xticklabel_txt = $preview_xaxis_txt->create_text($pw*0.7 +3, $ph*0.5 +3,
            -anchor => 'center', 
            -text   => "Tick Label",
            -fill   => "#000000",
            -angle  => 0,
            -font   => [-family     => $xfont,
                        -size       => $xl_size,
                        -weight     => $xl_weight,
                        -slant      => 'roman',
                        -underline  => 0,
                        -overstrike => 0,
                       ]);

    $xaxis_frame = $xaxis_tab->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $xaxis_frame->g_grid(-row => 1, -column => 0, -sticky => 'wnes');

    $row = 0;
    $xaxis_frame->new_label(
            -text => "X Axis Font: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($xfont_cb = $xaxis_frame->new_ttk__combobox(
            -textvariable => \$xfont,
            -values       => [ sort @available_fonts ],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
    $xfont_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_xaxis_txt->itemconfigure($xtitle_txt,
                          -font => [ -family     => $xfont,
                                     -size       => $xt_size,
                                     -weight     => $xt_weight,
                                     -slant      => 'roman',
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                    $preview_xaxis_txt->itemconfigure($xticklabel_txt,
                          -font => [ -family     => $xfont,
                                     -size       => $xl_size,
                                     -weight     => $xl_weight,
                                     -slant      => 'roman',
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                  });
    $row++;
    $xaxis_frame->new_label(
            -text => "X Title/Label Size: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($xt_size_cb = $xaxis_frame->new_ttk__combobox(
            -textvariable => \$xt_size,
            -values       => [(5 .. 24)],
            -width        => 5,
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
    $xt_size_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_xaxis_txt->itemconfigure($xtitle_txt,
                          -font => [ -family     => $xfont,
                                     -size       => $xt_size,
                                     -weight     => $xt_weight,
                                     -slant      => 'roman',
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                  });
    ($xl_size_cb = $xaxis_frame->new_ttk__combobox(
            -textvariable => \$xl_size,
            -values       => [(5 .. 24)],
            -width        => 5,
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 2, -sticky => 'ew', -pady => 2);
    $xl_size_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_xaxis_txt->itemconfigure($xticklabel_txt,
                          -font => [ -family     => $xfont,
                                     -size       => $xl_size,
                                     -weight     => $xl_weight,
                                     -slant      => 'roman',
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                  });
    $row++;
    $xaxis_frame->new_label(
            -text => "X Title/Label Weight: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($xt_weight_cb = $xaxis_frame->new_ttk__combobox(
            -textvariable => \$xt_weight,
            -values       => [("normal", "bold")],
            -width        => 5,
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
    $xt_weight_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_xaxis_txt->itemconfigure($xtitle_txt,
                          -font => [ -family     => $xfont,
                                     -size       => $xt_size,
                                     -weight     => $xt_weight,
                                     -slant      => 'roman',
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                  });
    ($xl_weight_cb = $xaxis_frame->new_ttk__combobox(
            -textvariable => \$xl_weight,
            -values       => [("normal", "bold")],
            -width        => 5,
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 2, -sticky => 'ew', -pady => 2);
    $xl_weight_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_xaxis_txt->itemconfigure($xticklabel_txt,
                          -font => [ -family     => $xfont,
                                     -size       => $xl_size,
                                     -weight     => $xl_weight,
                                     -slant      => 'roman',
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                  });

    if ($props{$id}{meta} =~ /(data_profile_cmap|w2_profile_cmap|time_series)/
          || ($props{$id}{meta} eq "w2_tdmap" && $gr_props{$id}{date_axis} eq "X")) {
        $row++;
        $xaxis_frame->new_label(
                -text => "X Axis Type: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        if ($props{$id}{meta} eq "w2_tdmap") {
            ($xtype_frame = $xaxis_frame->new_frame(
                    -borderwidth => 0,
                    -relief      => 'flat',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew');
            ($xaxis_type_cb = $xtype_frame->new_ttk__combobox(
                    -textvariable => \$xaxis_type,
                    -values       => [ ("Date/Time", "Julian Date") ],
                    -state        => 'readonly',
                    -width        => 11,
                    ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
            $xtype_frame->new_checkbutton(
                    -onvalue  => 1,
                    -offvalue => 0,
                    -text     => "Flip?",
                    -font     => 'default',
                    -variable => \$xaxis_flip,
                    )->g_pack(-side => 'left', -anchor => 'w');
        } else {
            ($xaxis_type_cb = $xaxis_frame->new_ttk__combobox(
                    -textvariable => \$xaxis_type,
                    -values       => [ ("Date/Time", "Julian Date") ],
                    -state        => 'readonly',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        }
        $xaxis_type_cb->g_bind("<<ComboboxSelected>>",
                                sub { my ($base_jd);
                                      return if ($xaxis_type eq $xtype_old);
                                      $xtype_old = $xaxis_type;
                                      $base_jd   = &date2jdate(sprintf("%04d%02d%02d", $byear, 1, 1));
                                      if ($xaxis_type eq "Date/Time") {
                                          $xmin_entry->g_grid_remove();
                                          $xmax_entry->g_grid_remove();
                                          $xmajor_entry->g_grid_remove();
                                          $byear_label->g_grid_remove();
                                          $byear_frame->g_grid_remove();
                                          $xtitle_label->g_grid_remove();
                                          $xtitle_entry->g_grid_remove();
                                          $xformat_label->g_grid();
                                          $xformat_cb->g_grid();
                                          $xmin_cb->g_grid();
                                          $xmax_cb->g_grid();
                                          $xtick_frame->g_grid();

                                          $xmajor = &max(1, &min(500, &round_to_int($xmajor)));
                                          $xmin  += $base_jd -1;
                                          $xmax  += $base_jd -1;
                                          if ($xmin >= $jd_min && $xmin <= $jd_max) {
                                              $xmin = &jdate2datelabel($xmin, "Mon-DD-YYYY");
                                          } else {
                                              $xmin = $datelist1[0];
                                          }
                                          if ($xmax >= $jd_min && $xmax <= $jd_max) {
                                              $xmax = &jdate2datelabel($xmax, "Mon-DD-YYYY");
                                          } else {
                                              $xmax = $datelist2[$#datelist2];
                                          }
                                          if (&datelabel2jdate($xmax) - &datelabel2jdate($xmin) > 365 *2) {
                                              if ($#date_axis_choices == 2) {
                                                  unshift (@date_axis_choices, "Year");
                                                  $xformat_cb->configure(-values => [ @date_axis_choices ]);
                                              }
                                          } elsif ($#date_axis_choices == 3) {
                                              shift @date_axis_choices;
                                              $xformat_cb->configure(-values => [ @date_axis_choices ]);
                                              if ($xformat eq "Year") {
                                                  $xformat = "Month";
                                                  Tkx::event_generate($xformat_cb, "<<ComboboxSelected>>");
                                              }
                                          }
                                      } else {
                                          $xformat_label->g_grid_remove();
                                          $xformat_cb->g_grid_remove();
                                          $xmin_cb->g_grid_remove();
                                          $xmax_cb->g_grid_remove();
                                          $xtick_frame->g_grid_remove();
                                          $byear_label->g_grid();
                                          $byear_frame->g_grid();
                                          $xmin_entry->g_grid();
                                          $xmax_entry->g_grid();
                                          $xmajor_entry->g_grid();
                                          $xtitle_label->g_grid();
                                          $xtitle_entry->g_grid();

                                          $xmin = &datelabel2jdate($xmin) -$base_jd +1;
                                          $xmax = &datelabel2jdate($xmax) -$base_jd +1;
                                          if ($xmin < 1 || $xmax <= $xmin || $xmax <= 1) {
                                              if ($xtype_sav eq "Date/Time") {
                                                  $xmin = 1 if ($xmin < 1);
                                                  if ($xmax <= $xmin || $xmax <= 1) {
                                                      $xmax = ($xmin < 366) ? 366 : $xmin +365;
                                                  }
                                              } else {
                                                  $xmin = $gr_props{$id}{xmin};
                                                  $xmax = $gr_props{$id}{xmax};
                                              }
                                          }
                                      }
                                    });

        $row++;
        ($byear_label = $xaxis_frame->new_label(
                -text => "Base Year: ",
                -font => 'default',
                ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($byear_frame = $xaxis_frame->new_frame(
                -borderwidth => 0,
                -relief      => 'flat',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew');
        ($byear_cb = $byear_frame->new_ttk__combobox(
                -textvariable => \$byear,
                -values       => [ reverse($yr_min .. $yr_max) ],
                -state        => 'readonly',
                -width        => 5,
                ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        $byear_cb->g_bind("<<ComboboxSelected>>",
                          sub { if ($byear == $yr_min) {
                                    $yr_min -= 10;
                                    $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                }
                              }
                         );
        $byear_frame->new_label(
                -text   => " for JDAY = 1",
                -anchor => 'w',
                -font   => 'default',
                )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);

        $row++;
        ($xformat_label = $xaxis_frame->new_label(
                -text => "X Ticklabel Format: ",
                -font => 'default',
                ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($xformat_cb = $xaxis_frame->new_ttk__combobox(
                -textvariable => \$xformat,
                -values       => [ @date_axis_choices ],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $xformat_cb->g_bind("<<ComboboxSelected>>",
                  sub { if ($xformat =~ /Year|Mon-DD/) {
                            $xtick_int_sb->configure(-state => ($xmaj_auto) ? 'disabled' : 'normal');
                            $xtick_auto_cb->configure(-state => 'normal');
                        } else {
                            $xtick_int_sb->configure(-state => 'disabled');
                            $xtick_auto_cb->configure(-state => 'disabled');
                        }
                      });

        $row++;
        $xaxis_frame->new_label(
                -text    => "X Axis Minimum: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($xmin_entry = $xaxis_frame->new_entry(
                -textvariable => \$xmin,
                -font         => 'default',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $xmin_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($xmin_entry);
                                                  if ($xmin ne "" && $xmin ne "." && $xmin ne "-") {
                                                      my $tmp = &round_to_int(1000.*$xmin)/1000.;
                                                      $xmin = $tmp if ($xmin != $tmp);
                                                  }
                                                });
        $xmin_entry->g_grid_remove();
        ($xmin_cb = $xaxis_frame->new_ttk__combobox(
                -textvariable => \$xmin,
                -values       => [ @datelist1 ],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $xmin_cb->g_bind("<<ComboboxSelected>>",
                          sub { if (&datelabel2jdate($xmax) - &datelabel2jdate($xmin) > 365 *2) {
                                    if ($#date_axis_choices == 2) {
                                        unshift (@date_axis_choices, "Year");
                                        $xformat_cb->configure(-values => [ @date_axis_choices ]);
                                    }
                                } elsif ($#date_axis_choices == 3) {
                                    shift @date_axis_choices;
                                    $xformat_cb->configure(-values => [ @date_axis_choices ]);
                                    if ($xformat eq "Year") {
                                        $xformat = "Month";
                                        Tkx::event_generate($xformat_cb, "<<ComboboxSelected>>");
                                    }
                                }
                              }
                        );

        $row++;
        $xaxis_frame->new_label(
                -text    => "X Axis Maximum: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($xmax_entry = $xaxis_frame->new_entry(
                -textvariable => \$xmax,
                -font         => 'default',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $xmax_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($xmax_entry);
                                                  if ($xmax ne "" && $xmax ne "." && $xmax ne "-") {
                                                      my $tmp = &round_to_int(1000.*$xmax)/1000.;
                                                      $xmax = $tmp if ($xmax != $tmp);
                                                  }
                                                });
        $xmax_entry->g_grid_remove();
        ($xmax_cb = $xaxis_frame->new_ttk__combobox(
                -textvariable => \$xmax,
                -values       => [ @datelist2 ],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $xmax_cb->g_bind("<<ComboboxSelected>>",
                          sub { if (&datelabel2jdate($xmax) - &datelabel2jdate($xmin) > 365 *2) {
                                    if ($#date_axis_choices == 2) {
                                        unshift (@date_axis_choices, "Year");
                                        $xformat_cb->configure(-values => [ @date_axis_choices ]);
                                    }
                                } elsif ($#date_axis_choices == 3) {
                                    shift @date_axis_choices;
                                    $xformat_cb->configure(-values => [ @date_axis_choices ]);
                                    if ($xformat eq "Year") {
                                        $xformat = "Month";
                                        Tkx::event_generate($xformat_cb, "<<ComboboxSelected>>");
                                    }
                                }
                              }
                        );

        $row++;
        $xaxis_frame->new_label(
                -text    => "X Tick Interval: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($xmajor_entry = $xaxis_frame->new_entry(
                -textvariable => \$xmajor,
                -font         => 'default',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $xmajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($xmajor_entry, 1);
                                                    $xmajor =~ s/^-//;
                                                  });
        $xmajor_entry->g_grid_remove();
        ($xtick_frame = $xaxis_frame->new_frame(
                -borderwidth => 0,
                -relief      => 'flat',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew');
        ($xtick_int_sb = $xtick_frame->new_spinbox(
                -textvariable => \$xmajor,
                -state        => 'normal',
                -font         => 'default',
                -from         => 1,
                -to           => 5000,
                -increment    => 1,
                -width        => 5,
                ))->g_pack(-side => 'left', -anchor => 'w', -pady => 0);
        $xtick_int_sb->g_bind("<KeyRelease>", sub { &numeric_entry_only($xtick_int_sb);
                                                    $xmajor =~ s/^-//;
                                                    $xmajor = 1 if ($xmajor eq "" || $xmajor == 0);
                                                    $xmajor = &round_to_int(abs($xmajor));
                                                  });
        ($xtick_auto_cb = $xtick_frame->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "Auto",
                -font     => 'default',
                -variable => \$xmaj_auto,
                -command  => sub { $xtick_int_sb->configure(-state => ($xmaj_auto) ? 'disabled' : 'normal');
                                 },
                ))->g_pack(-side => 'left', -anchor => 'w', -pady => 0);
        $xtick_auto_cb->configure(-state => ($xformat eq "Month") ? 'disabled' : 'normal');
        $xtick_int_sb->configure(-state => ($xformat eq "Month" || $xmaj_auto) ? 'disabled' : 'normal');

        $row++;
        $xaxis_frame->new_label(
                -text    => "X Primary Ticks: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $xaxis_frame->new_ttk__combobox(
                -textvariable => \$xpr_tics,
                -values       => [ @tic_opts ],
                -state        => 'readonly',
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

        $row++;
        $xaxis_frame->new_label(
                -text    => "X Opposite Ticks: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $xaxis_frame->new_ttk__combobox(
                -textvariable => \$xop_tics,
                -values       => [ @tic_opts ],
                -state        => 'readonly',
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

        if ($props{$id}{meta} =~ /profile_cmap|time_series/) {
            $dateline_ok = 0;
            for ($i=0; $i<=$#animate_ids; $i++) {
                next if ($id == $animate_ids[$i]);
                if ($props{$animate_ids[$i]}{meta}
                       =~ /^(data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)$/) {
                    $dateline_ok = 1;
                    last;
                }
            }
            if ($dateline_ok) {
                $row++;
                $xaxis_frame->new_label(
                        -text    => "Animation Dateline: ",
                        -font    => 'default',
                        )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
                $xaxis_frame->new_checkbutton(
                        -onvalue  => 1,
                        -offvalue => 0,
                        -text     => "Show",
                        -font     => 'default',
                        -variable => \$dateline,
                        -command  => sub { my $status = ($dateline) ? 'normal' : 'disabled';
                                           $datelinec_btn->configure(-state => $status);
                                         },
                        )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
                $code      = &get_rgb_code($datelinec);
                $datelinec = &get_rgb_name($code);
                $fg        = &get_rgb_code("black");
                if ($code =~ /^\#[0-9a-f]/i) {
                    $fg = &get_rgb_code(&get_bw_contrast($code));
                }
                ($datelinec_btn = $xaxis_frame->new_button(
                                -textvariable => \$datelinec,
                                -background   => $code,
                                -foreground   => $fg,
                                -width        => -7,
                                -command => sub { my ($newc, $code, $fg);
                                                  $code = &get_rgb_code($datelinec);
                                                  $newc = Tkx::tk___chooseColor(
                                                             -initialcolor => $code,
                                                             -parent       => $graph_props_menu);
                                                  if ($newc) {
                                                      $code      = &get_rgb_code($newc);
                                                      $datelinec = &get_rgb_name($code);
                                                      $fg        = &get_rgb_code("black");
                                                      if ($code =~ /^#?[0-9a-f]/i) {
                                                          $fg = &get_rgb_code(&get_bw_contrast($code));
                                                      }
                                                      $datelinec_btn->configure(-foreground => $fg,
                                                                                -background => $code);
                                                  }
                                                }
                                ))->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);
                if (! $dateline) {
                    $datelinec_btn->configure(-state => 'disabled');
                }
            }
        }

        $row++;
        ($xtitle_label = $xaxis_frame->new_label(
                -text => "X Axis Title: ",
                -font => 'default',
                ))->g_grid(-row => $row, -column => 0, -sticky => 'w', -pady => 2);
        $row++;
        ($xtitle_entry = $xaxis_frame->new_entry(
                -textvariable => \$xtitle,
                -font         => 'default',
                ))->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew', -pady => 2);

        if ($xaxis_type eq "Date/Time") {
            $xmin_entry->g_grid_remove();
            $xmax_entry->g_grid_remove();
            $xmajor_entry->g_grid_remove();
            $byear_label->g_grid_remove();
            $byear_frame->g_grid_remove();
            $xtitle_label->g_grid_remove();
            $xtitle_entry->g_grid_remove();
            $xformat_label->g_grid();
            $xformat_cb->g_grid();
            $xmin_cb->g_grid();
            $xmax_cb->g_grid();
            $xtick_frame->g_grid();
        } else {
            $xformat_label->g_grid_remove();
            $xformat_cb->g_grid_remove();
            $xmin_cb->g_grid_remove();
            $xmax_cb->g_grid_remove();
            $xtick_frame->g_grid_remove();
            $byear_label->g_grid();
            $byear_frame->g_grid();
            $xmin_entry->g_grid();
            $xmax_entry->g_grid();
            $xmajor_entry->g_grid();
            $xtitle_label->g_grid();
            $xtitle_entry->g_grid();
        }
        $xaxis_frame->g_grid_columnconfigure(0, -weight => 2);

    } else {
        if ($props{$id}{meta} =~ /w2_slice|w2_wlevels|w2_tdmap/) {
            $row++;
            $xaxis_frame->new_label(
                    -text    => "X Axis Base: ",
                    -font    => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($xbase_entry = $xaxis_frame->new_entry(
                    -textvariable => \$xbase,
                    -font         => 'default',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
            $xbase_entry->g_bind("<KeyRelease>",
                                  sub { my ($mult);
                                        &numeric_entry_only($xbase_entry);
                                        if ($xbase ne "" && $xbase ne "." && $xbase ne "-") {
                                            my $tmp = &round_to_int(1000.*$xbase)/1000.;
                                            $xbase = $tmp if ($xbase != $tmp);
                                            if ($xmax_auto) {
                                                $mult = ($xaxis_units eq "miles") ? 3280.84/5280. : 1.0;
                                                if ($props{$id}{meta} =~ /w2_slice|w2_wlevels/) {
                                                    $xmax = $xbase +$gr_props{$id}{x_km} *$mult;
                                                } else {
                                                    $xmax = $xbase +$gr_props{$id}{d_km} *$mult;
                                                }
                                                $xmax = &round_to_int(1000.*$xmax)/1000.;
                                            }
                                        } elsif ($xbase eq "" || $xbase eq ".") {
                                            if ($xmax_auto) {
                                                $mult = ($xaxis_units eq "miles") ? 3280.84/5280. : 1.0;
                                                if ($props{$id}{meta} =~ /w2_slice|w2_wlevels/) {
                                                    $xmax = $gr_props{$id}{x_km} *$mult;
                                                } else {
                                                    $xmax = $gr_props{$id}{d_km} *$mult;
                                                }
                                                $xmax = &round_to_int(1000.*$xmax)/1000.;
                                            }
                                        }
                                      });
        }

        if ($props{$id}{meta} !~ /vert_wd_zone|w2_outflow/) {
            $row++;
            $xaxis_frame->new_label(
                    -text    => "X Axis Minimum: ",
                    -font    => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($xmin_entry = $xaxis_frame->new_entry(
                    -textvariable => \$xmin,
                    -font         => 'default',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
            $xmin_entry->g_bind("<KeyRelease>",
                                 sub { &numeric_entry_only($xmin_entry);
                                       if ($xmin ne "" && $xmin ne "." && $xmin ne "-") {
                                           my $tmp = &round_to_int(1000.*$xmin)/1000.;
                                           $xmin = $tmp if ($xmin != $tmp);
                                           if ($props{$id}{meta} =~ /w2_slice|w2_wlevels|w2_tdmap/) {
                                               if ($xfirst ne "" && $xfirst ne "."
                                                                 && $xfirst ne "-" && $xfirst < $xmin) {
                                                   if (&ceil($xmin) != $xmin) {
                                                       $xfirst = &ceil($xmin);
                                                   } else {
                                                       $xfirst = $xmin;
                                                   }
                                               }
                                           }
                                       }
                                     });
        }

        if ($props{$id}{meta} =~ /w2_slice|w2_wlevels|w2_tdmap/) {
            $row++;
            $xaxis_frame->new_label(
                    -text    => "X Axis First Label: ",
                    -font    => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($xfirst_entry = $xaxis_frame->new_entry(
                    -textvariable => \$xfirst,
                    -font         => 'default',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
            $xfirst_entry->g_bind("<KeyRelease>",
                                   sub { &numeric_entry_only($xfirst_entry);
                                         if ($xfirst ne "" && $xfirst ne "." && $xfirst ne "-") {
                                             my $tmp = &round_to_int(1000.*$xfirst)/1000.;
                                             $xfirst = $tmp if ($xfirst != $tmp);
                                         }
                                       });

            $row++;
            $xaxis_frame->new_label(
                    -text    => "X Axis Maximum: ",
                    -font    => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($xmax_frame = $xaxis_frame->new_frame(
                    -borderwidth => 0,
                    -relief      => 'flat',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew');
            ($xmax_entry = $xmax_frame->new_entry(
                    -textvariable => \$xmax,
                    -font         => 'default',
                    -width        => 10,
                    ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
            $xmax_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($xmax_entry);
                                                      $xmax =~ s/^-//;
                                                      if ($xmax ne "" && $xmax ne ".") {
                                                          my $tmp = &round_to_int(1000.*$xmax)/1000.;
                                                          $xmax = $tmp if ($xmax != $tmp);
                                                      }
                                                    });
            $xmax_frame->new_checkbutton(
                    -onvalue  => 1,
                    -offvalue => 0,
                    -text     => "Auto",
                    -font     => 'default',
                    -variable => \$xmax_auto,
                    -command  => sub { my ($mult);
                                       if ($xmax_auto) {
                                           if ($xbase ne "" && $xbase ne "." && $xbase ne "-") {
                                               $mult = ($xaxis_units eq "miles") ? 3280.84/5280. : 1.0;
                                               if ($props{$id}{meta} =~ /w2_slice|w2_wlevels/) {
                                                   $xmax = $xbase +$gr_props{$id}{x_km} *$mult;
                                               } else {
                                                   $xmax = $xbase +$gr_props{$id}{d_km} *$mult;
                                               }
                                               $xmax = &round_to_int(1000.*$xmax)/1000.;
                                           } elsif ($xbase eq "" || $xbase eq ".") {
                                               $mult = ($xaxis_units eq "miles") ? 3280.84/5280. : 1.0;
                                               if ($props{$id}{meta} =~ /w2_slice|w2_wlevels/) {
                                                   $xmax = $gr_props{$id}{x_km} *$mult;
                                               } else {
                                                   $xmax = $gr_props{$id}{d_km} *$mult;
                                               }
                                               $xmax = &round_to_int(1000.*$xmax)/1000.;
                                           }
                                           $xmax_entry->configure(-state => 'disabled');
                                       } else {
                                           $xmax_entry->configure(-state => 'normal');
                                       }
                                     }
                    )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
            $xmax_entry->configure(-state => ($xmax_auto) ? 'disabled' : 'normal');

        } else {
            $row++;
            $xaxis_frame->new_label(
                    -text    => "X Axis Maximum: ",
                    -font    => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($xmax_entry = $xaxis_frame->new_entry(
                    -textvariable => \$xmax,
                    -font         => 'default',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
            $xmax_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($xmax_entry);
                                                      if ($props{$id}{meta} =~ /vert_wd_zone|w2_outflow/) {
                                                          $xmax =~ s/^-//;
                                                      }
                                                      if ($xmax ne "" && $xmax ne "." && $xmax ne "-") {
                                                          my $tmp = &round_to_int(1000.*$xmax)/1000.;
                                                          $xmax = $tmp if ($xmax != $tmp);
                                                      }
                                                    });
        }

        $row++;
        $xaxis_frame->new_label(
                -text    => "X Tick Interval: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($xmajor_entry = $xaxis_frame->new_entry(
                -textvariable => \$xmajor,
                -font         => 'default',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $xmajor_entry->g_bind("<KeyRelease>",
                               sub { &numeric_entry_only($xmajor_entry, 1);
                                     if ($props{$id}{meta}
                                             =~ /w2_slice|w2_wlevels|w2_tdmap|vert_wd_zone|w2_outflow/) {
                                         $xmajor =~ s/^-//;
                                     }
                                   });

        $row++;
        $xaxis_frame->new_label(
                -text    => "X Primary Ticks: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $xaxis_frame->new_ttk__combobox(
                -textvariable => \$xpr_tics,
                -values       => [ @tic_opts ],
                -state        => 'readonly',
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

        $row++;
        $xaxis_frame->new_label(
                -text    => "X Opposite Ticks: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $xaxis_frame->new_ttk__combobox(
                -textvariable => \$xop_tics,
                -values       => [ @tic_opts ],
                -state        => 'readonly',
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

        if ($props{$id}{meta} =~ /vert_wd_zone|w2_outflow/) {
            $row++;
            $xaxis_frame->new_label(
                    -text => "X Axis Units: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($xunits_cb = $xaxis_frame->new_ttk__combobox(
                    -textvariable => \$qaxis_units,
                    -values       => [ ("cfs/ft", "cms/m", "ft/s", "m/s") ],
                    -state        => 'readonly',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
            $xunits_cb->g_bind("<<ComboboxSelected>>",
                                sub { if ($qaxis_units eq "cfs/ft") {
                                          $xtitle = "Release Rate, in cfs/(vert. ft)";
                                      } elsif ($qaxis_units eq "cms/m") {
                                          $xtitle = "Release Rate, in cms/(vert. m)";
                                      } elsif ($qaxis_units eq "ft/s") {
                                          $xtitle = "Velocity, in ft/s";
                                      } else {
                                          $xtitle = "Velocity, in m/s";
                                      }
                                    });

        } elsif ($props{$id}{meta} =~ /w2_slice|w2_wlevels|w2_tdmap/) {
            $row++;
            $xaxis_frame->new_label(
                    -text => "X Axis Units: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($xunits_frame = $xaxis_frame->new_frame(
                    -borderwidth => 0,
                    -relief      => 'flat',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew');
            ($xunits_cb = $xunits_frame->new_ttk__combobox(
                    -textvariable => \$xaxis_units,
                    -values       => [ ("miles", "kilometers") ],
                    -state        => 'readonly',
                    -width        => 10,
                    ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
            $xunits_cb->g_bind("<<ComboboxSelected>>",
                                sub { return if ($xaxis_units eq $old_xunits);
                                      if ($xaxis_units eq "miles") {
                                          if ($xbase ne "" && $xbase ne "." && $xbase ne "-") {
                                              $xbase *= 3280.84/5280.;
                                              $xbase = &round_to_int(1000.*$xbase)/1000.;
                                          }
                                          if ($xmin ne "" && $xmin ne "." && $xmin ne "-") {
                                              $xmin *= 3280.84/5280.;
                                              $xmin = &round_to_int(1000.*$xmin)/1000.;
                                          }
                                          if ($xfirst ne "" && $xfirst ne "." && $xfirst ne "-") {
                                              $xfirst *= 3280.84/5280.;
                                              $xfirst = &round_to_int(1000.*$xfirst)/1000.;
                                          }
                                          if ($xmax ne "" && $xmax ne "." && $xmax ne "-") {
                                              $xmax *= 3280.84/5280.;
                                              $xmax = &round_to_int(1000.*$xmax)/1000.;
                                          }
                                          $xtitle =~ s/kilometer/mile/;
                                          $xtitle =~ s/Kilometer/Mile/;
                                          $xtitle =~ s/KILOMETER/MILE/;
                                      } else {
                                          if ($xbase ne "" && $xbase ne "." && $xbase ne "-") {
                                              $xbase *= 5280./3280.84;
                                              $xbase = &round_to_int(1000.*$xbase)/1000.;
                                          }
                                          if ($xmin ne "" && $xmin ne "." && $xmin ne "-") {
                                              $xmin *= 5280./3280.84;
                                              $xmin = &round_to_int(1000.*$xmin)/1000.;
                                          }
                                          if ($xfirst ne "" && $xfirst ne "." && $xfirst ne "-") {
                                              $xfirst *= 5280./3280.84;
                                              $xfirst = &round_to_int(1000.*$xfirst)/1000.;
                                          }
                                          if ($xmax ne "" && $xmax ne "." && $xmax ne "-") {
                                              $xmax *= 5280./3280.84;
                                              $xmax = &round_to_int(1000.*$xmax)/1000.;
                                          }
                                          $xtitle =~ s/mile/kilometer/;
                                          $xtitle =~ s/Mile/Kilometer/;
                                          $xtitle =~ s/MILE/KILOMETER/;
                                      }
                                      $old_xunits = $xaxis_units;
                                    });
            $xunits_frame->new_checkbutton(
                    -onvalue  => 1,
                    -offvalue => 0,
                    -text     => "Flip?",
                    -font     => 'default',
                    -variable => \$xaxis_flip,
                    )->g_pack(-side => 'left', -anchor => 'w');

        } elsif (($props{$id}{meta} eq "data_profile" ||
                  $props{$id}{meta} =~ /^(w2_profile|w2_profile_matrix)$/)
                  && $props{$id}{parm} eq "Temperature") {
            $row++;
            $xaxis_frame->new_label(
                    -text => "X Axis Units: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($wt_units_cb = $xaxis_frame->new_ttk__combobox(
                    -textvariable => \$wt_units,
                    -values       => [ ("Celsius", "Fahrenheit") ],
                    -state        => 'readonly',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
            $wt_units_cb->g_bind("<<ComboboxSelected>>",
                                 sub { my ($diff);
                                       if ($props{$id}{meta} eq "data_profile"
                                            && $props{$id}{prof_type} eq "difference") {
                                           $diff = 0;
                                       } else {
                                           $diff = 32;
                                       }
                                       if ($wt_units eq "Celsius"
                                            && $wt_oldunits eq "Fahrenheit") {
                                           $xtitle   =~ s/Fahrenheit/Celsius/;
                                           $keytitle =~ s/Fahrenheit/Celsius/;
                                           if ($xmin ne "" && $xmin ne "." && $xmin ne "-") {
                                               $xmin = &floor(($xmin -$diff) /1.8);
                                           }
                                           if ($xmax ne "" && $xmax ne "." && $xmax ne "-") {
                                               $xmax = &ceil(($xmax -$diff) /1.8);
                                           }
                                           if ($xmajor ne "" && $xmajor ne "." && $xmajor ne "-") {
                                               $xmajor = &round_to_int($xmajor /1.8);
                                           }
                                           if ($cs_min ne "" && $cs_min ne "." && $cs_min ne "-") {
                                               $cs_min = &floor(($cs_min -$diff) /1.8);
                                           }
                                           if ($cs_max ne "" && $cs_max ne "." && $cs_max ne "-") {
                                               $cs_max = &ceil(($cs_max -$diff) /1.8);
                                           }
                                           if ($cs_major ne "" && $cs_major ne "." && $cs_major ne "auto") {
                                               $cs_major = sprintf("%.4f", $cs_major/1.8);
                                               $cs_major =~ s/0+$//;
                                           }
                                       } elsif ($wt_units eq "Fahrenheit"
                                            && $wt_oldunits eq "Celsius") {
                                           $xtitle   =~ s/Celsius/Fahrenheit/;
                                           $keytitle =~ s/Celsius/Fahrenheit/;
                                           if ($xmin ne "" && $xmin ne "." && $xmin ne "-") {
                                               $xmin = &floor($xmin *1.8 +$diff);
                                           }
                                           if ($xmax ne "" && $xmax ne "." && $xmax ne "-") {
                                               $xmax = &ceil($xmax *1.8 +$diff);
                                           }
                                           if ($xmajor ne "" && $xmajor ne "." && $xmajor ne "-") {
                                               $xmajor = &round_to_int($xmajor *1.8);
                                           }
                                           if ($cs_min ne "" && $cs_min ne "." && $cs_min ne "-") {
                                               $cs_min = &floor($cs_min *1.8 +$diff);
                                           }
                                           if ($cs_max ne "" && $cs_max ne "." && $cs_max ne "-") {
                                               $cs_max = &ceil($cs_max *1.8 +$diff);
                                           }
                                           if ($cs_major ne "" && $cs_major ne "." && $cs_major ne "auto") {
                                               $cs_major = sprintf("%.4f", $cs_major*1.8);
                                               $cs_major =~ s/0+$//;
                                           }
                                       }
                                       $wt_oldunits = $wt_units;
                                     });
        }

        if ($props{$id}{meta} =~ /w2_slice|w2_wlevels|w2_tdmap/) {
            $row++;
            ($xtitle_frame = $xaxis_frame->new_frame(
                    -borderwidth => 0,
                    -relief      => 'flat',
                    ))->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew');
            $xtitle_frame->new_label(
                    -text => "X Axis Title: ",
                    -font => 'default',
                    )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
            $xtitle_frame->new_entry(
                    -textvariable => \$xtitle,
                    -font         => 'default',
                    )->g_pack(-side => 'left', -anchor => 'w', -expand => 1, -fill => 'x', -pady => 2);
        } else {
            $row++;
            $xaxis_frame->new_label(
                    -text => "X Axis Title: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'w', -pady => 2);
            $row++;
            $xaxis_frame->new_entry(
                    -textvariable => \$xtitle,
                    -font         => 'default',
                    )->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew', -pady => 2);
        }
    }
    $xaxis_frame->g_grid_columnconfigure(0, -weight => 2);

#   Y axis tab
    $yaxis_tab = $grprops_notebook->new_frame();
    $grprops_notebook->add($yaxis_tab,
            -text      => "Y Axis",
            -underline => 0,
            -sticky    => 'nsew',
            );

    $preview_yaxis_txt = $yaxis_tab->new_canvas(
            -background  => &get_rgb_code($canvas_color),
            -width       => $pw,
            -height      => $ph,
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $preview_yaxis_txt->g_grid(-row => 0, -column => 0, -sticky => 'wne');

    $ytitle_txt = $preview_yaxis_txt->create_text($pw*0.3 +3, $ph*0.5 +3,
            -anchor => 'center', 
            -text   => "Axis Title",
            -fill   => "#000000",
            -angle  => 0,
            -font   => [-family     => $yfont,
                        -size       => $yt_size,
                        -weight     => $yt_weight,
                        -slant      => 'roman',
                        -underline  => 0,
                        -overstrike => 0,
                       ]);
    $yticklabel_txt = $preview_yaxis_txt->create_text($pw*0.7 +3, $ph*0.5 +3,
            -anchor => 'center', 
            -text   => "Tick Label",
            -fill   => "#000000",
            -angle  => 0,
            -font   => [-family     => $yfont,
                        -size       => $yl_size,
                        -weight     => $yl_weight,
                        -slant      => 'roman',
                        -underline  => 0,
                        -overstrike => 0,
                       ]);

    $yaxis_frame = $yaxis_tab->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $yaxis_frame->g_grid(-row => 1, -column => 0, -sticky => 'wnes');

    $row = 0;
    $yaxis_frame->new_label(
            -text => "Y Axis Font: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($yfont_cb = $yaxis_frame->new_ttk__combobox(
            -textvariable => \$yfont,
            -values       => [ sort @available_fonts ],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
    $yfont_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_yaxis_txt->itemconfigure($ytitle_txt,
                          -font => [ -family     => $yfont,
                                     -size       => $yt_size,
                                     -weight     => $yt_weight,
                                     -slant      => 'roman',
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                    $preview_yaxis_txt->itemconfigure($yticklabel_txt,
                          -font => [ -family     => $yfont,
                                     -size       => $yl_size,
                                     -weight     => $yl_weight,
                                     -slant      => 'roman',
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                  });
    $row++;
    $yaxis_frame->new_label(
            -text => "Y Title/Label Size: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($yt_size_cb = $yaxis_frame->new_ttk__combobox(
            -textvariable => \$yt_size,
            -values       => [(5 .. 24)],
            -width        => 5,
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
    $yt_size_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_yaxis_txt->itemconfigure($ytitle_txt,
                          -font => [ -family     => $yfont,
                                     -size       => $yt_size,
                                     -weight     => $yt_weight,
                                     -slant      => 'roman',
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                  });
    ($yl_size_cb = $yaxis_frame->new_ttk__combobox(
            -textvariable => \$yl_size,
            -values       => [(5 .. 24)],
            -width        => 5,
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 2, -sticky => 'ew', -pady => 2);
    $yl_size_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_yaxis_txt->itemconfigure($yticklabel_txt,
                          -font => [ -family     => $yfont,
                                     -size       => $yl_size,
                                     -weight     => $yl_weight,
                                     -slant      => 'roman',
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                  });
    $row++;
    $yaxis_frame->new_label(
            -text => "Y Title/Label Weight: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($yt_weight_cb = $yaxis_frame->new_ttk__combobox(
            -textvariable => \$yt_weight,
            -values       => [("normal", "bold")],
            -state        => 'readonly',
            -width        => 5,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
    $yt_weight_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_yaxis_txt->itemconfigure($ytitle_txt,
                          -font => [ -family     => $yfont,
                                     -size       => $yt_size,
                                     -weight     => $yt_weight,
                                     -slant      => 'roman',
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                  });
    ($yl_weight_cb = $yaxis_frame->new_ttk__combobox(
            -textvariable => \$yl_weight,
            -values       => [("normal", "bold")],
            -state        => 'readonly',
            -width        => 5,
            ))->g_grid(-row => $row, -column => 2, -sticky => 'ew', -pady => 2);
    $yl_weight_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_yaxis_txt->itemconfigure($yticklabel_txt,
                          -font => [ -family     => $yfont,
                                     -size       => $yl_size,
                                     -weight     => $yl_weight,
                                     -slant      => 'roman',
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                  });

    if ($props{$id}{meta} =~ /data_profile|w2_profile|w2_slice|w2_outflow|vert_wd_zone/) {
        $row++;
        $yaxis_frame->new_label(
                -text => "Y Axis Type: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($yaxis_type_cb = $yaxis_frame->new_ttk__combobox(
                -textvariable => \$yaxis_type,
                -values       => [ ("Elevation", "Depth") ],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $yaxis_type_cb->g_bind("<<ComboboxSelected>>",
                               sub { return if ($yaxis_type eq $old_yaxis_type);
                                     if ($yaxis_type eq "Elevation") {
                                         $ymin_label->g_grid();
                                         $ymin_entry->g_grid();
                                         $ymax_label->configure(-text => "Elevation Max: ");
                                         $ymajor_label->configure(-text => "Elevation Major: ");
                                         $yaxis_units_label->configure(-text => "Elevation Units: ");
                                         if ($elev_base != -999 && $ymax ne "") {
                                             $ymin  = $elev_base;
                                             $ymax += $elev_base;
                                         } else {
                                             $ymin = "";
                                         }
                                         $ytitle =~ s/Depth/Elevation/;
                                         $ytitle =~ s/depth/elevation/;
                                         $ytitle =~ s/DEPTH/ELEVATION/;
                                     } else {
                                         $ymin_label->g_grid_remove();
                                         $ymin_entry->g_grid_remove();
                                         $ymax_label->configure(-text => "Depth Max: ");
                                         $ymajor_label->configure(-text => "Depth Major: ");
                                         $yaxis_units_label->configure(-text => "Depth Units: ");
                                         if ($ymax ne "" && $ymin ne "" && $ymax -$ymin != 0) {
                                             $elev_base = &min($ymin, $ymax);
                                             $ymax      = abs($ymax -$ymin);
                                         } else {
                                             $ymax = "";
                                         }
                                         $ymin   = 0;
                                         $ytitle =~ s/Elevation/Depth/;
                                         $ytitle =~ s/elevation/depth/;
                                         $ytitle =~ s/ELEVATION/DEPTH/;
                                     }
                                     $old_yaxis_type = $yaxis_type;
                                   }
                              );
    }

    if ($props{$id}{meta} ne "w2_tdmap") {
        $row++;
        ($ymin_label = $yaxis_frame->new_label(
                -text    => "Y Axis Minimum: ",
                -font    => 'default',
                ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($ymin_entry = $yaxis_frame->new_entry(
                -textvariable => \$ymin,
                -font         => 'default',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $ymin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $ymin_entry ]);

        $row++;
        ($ymax_label = $yaxis_frame->new_label(
                -text    => "Y Axis Maximum: ",
                -font    => 'default',
                ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($ymax_entry = $yaxis_frame->new_entry(
                -textvariable => \$ymax,
                -font         => 'default',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $ymax_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($ymax_entry);
                                                  $ymax =~ s/^-// if ($yaxis_type eq "Depth");
                                                });

        $row++;
        ($ymajor_label = $yaxis_frame->new_label(
                -text    => "Y Tick Interval: ",
                -font    => 'default',
                ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($ymajor_entry = $yaxis_frame->new_entry(
                -textvariable => \$ymajor,
                -font         => 'default',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $ymajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($ymajor_entry, 1);
                                                    $ymajor =~ s/^-//;
                                                  });

        $row++;
        $yaxis_frame->new_label(
                -text    => "Y Primary Ticks: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $yaxis_frame->new_ttk__combobox(
                -textvariable => \$ypr_tics,
                -values       => [ @tic_opts ],
                -state        => 'readonly',
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

        $row++;
        $yaxis_frame->new_label(
                -text    => "Y Opposite Ticks: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $yaxis_frame->new_ttk__combobox(
                -textvariable => \$yop_tics,
                -values       => [ @tic_opts ],
                -state        => 'readonly',
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

        if ($props{$id}{meta} =~ /data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone/) {
            $row++;
            ($yaxis_units_label = $yaxis_frame->new_label(
                    -text => "Elevation Units: ",
                    -font => 'default',
                    ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($yaxis_units_cb = $yaxis_frame->new_ttk__combobox(
                    -textvariable => \$yaxis_units,
                    -values       => [ ("feet", "meters") ],
                    -state        => 'readonly',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
            $yaxis_units_cb->g_bind("<<ComboboxSelected>>",
                                     sub { if ($yaxis_units eq "feet") {
                                               $ytitle =~ s/meters/feet/;
                                               $ytitle =~ s/Meters/Feet/;
                                               $ytitle =~ s/METERS/FEET/;
                                           } else {
                                               $ytitle =~ s/feet/meters/;
                                               $ytitle =~ s/Feet/Meters/;
                                               $ytitle =~ s/FEET/METERS/;
                                           }
                                         });

            $ymin_label->configure(-text => "Elevation Min: ");
            if ($yaxis_type eq "Elevation") {
                $ymax_label->configure(-text => "Elevation Max: ");
                $ymajor_label->configure(-text => "Elevation Major: ");
                $yaxis_units_label->configure(-text => "Elevation Units: ");
            } else {
                $ymin_label->g_grid_remove();
                $ymin_entry->g_grid_remove();
                $ymax_label->configure(-text => "Depth Max: ");
                $ymajor_label->configure(-text => "Depth Major: ");
                $yaxis_units_label->configure(-text => "Depth Units: ");
            }
        }

        $row++;
        $yaxis_frame->new_label(
                -text    => "Y Axis Title: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'w', -pady => 2);
        $row++;
        $yaxis_frame->new_entry(
                -textvariable => \$ytitle,
                -font         => 'default',
                )->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew', -pady => 2);

        $yaxis_frame->g_grid_columnconfigure(0, -weight => 2);

    } else {                                      # w2_tdmap
        if ($gr_props{$id}{date_axis} eq "Y") {
            $row++;
            $yaxis_frame->new_label(
                    -text => "Y Axis Type: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($ytype_frame = $yaxis_frame->new_frame(
                    -borderwidth => 0,
                    -relief      => 'flat',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew');
            ($yaxis_type_cb = $ytype_frame->new_ttk__combobox(
                    -textvariable => \$yaxis_type,
                    -values       => [ ("Date/Time", "Julian Date") ],
                    -state        => 'readonly',
                    -width        => 11,
                    ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
            $yaxis_type_cb->g_bind("<<ComboboxSelected>>",
                                    sub { my ($base_jd);
                                          return if ($yaxis_type eq $ytype_old);
                                          $ytype_old = $yaxis_type;
                                          $base_jd   = &date2jdate(sprintf("%04d%02d%02d", $byear, 1, 1));
                                          if ($yaxis_type eq "Date/Time") {
                                              $ymin_entry->g_grid_remove();
                                              $ymax_entry->g_grid_remove();
                                              $ymajor_entry->g_grid_remove();
                                              $byear_label->g_grid_remove();
                                              $byear_frame->g_grid_remove();
                                              $ytitle_label->g_grid_remove();
                                              $ytitle_entry->g_grid_remove();
                                              $yformat_label->g_grid();
                                              $yformat_cb->g_grid();
                                              $ymin_cb->g_grid();
                                              $ymax_cb->g_grid();
                                              $ytick_frame->g_grid();

                                              $ymajor = &max(1, &min(500, &round_to_int($ymajor)));
                                              $ymin  += $base_jd -1;
                                              $ymax  += $base_jd -1;
                                              if ($ymin >= $jd_min && $ymin <= $jd_max) {
                                                  $ymin = &jdate2datelabel($ymin, "Mon-DD-YYYY");
                                              } else {
                                                  $ymin = $datelist1[0];
                                              }
                                              if ($ymax >= $jd_min && $ymax <= $jd_max) {
                                                  $ymax = &jdate2datelabel($ymax, "Mon-DD-YYYY");
                                              } else {
                                                  $ymax = $datelist2[$#datelist2];
                                              }
                                              if (&datelabel2jdate($ymax) - &datelabel2jdate($ymin) >365*2) {
                                                  if ($#date_axis_choices == 2) {
                                                      unshift (@date_axis_choices, "Year");
                                                      $yformat_cb->configure(-values=>[ @date_axis_choices ]);
                                                  }
                                              } elsif ($#date_axis_choices == 3) {
                                                  shift @date_axis_choices;
                                                  $yformat_cb->configure(-values => [ @date_axis_choices ]);
                                                  if ($yformat eq "Year") {
                                                      $yformat = "Month";
                                                      Tkx::event_generate($yformat_cb,"<<ComboboxSelected>>");
                                                  }
                                              }
                                          } else {
                                              $yformat_label->g_grid_remove();
                                              $yformat_cb->g_grid_remove();
                                              $ymin_cb->g_grid_remove();
                                              $ymax_cb->g_grid_remove();
                                              $ytick_frame->g_grid_remove();
                                              $byear_label->g_grid();
                                              $byear_frame->g_grid();
                                              $ymin_entry->g_grid();
                                              $ymax_entry->g_grid();
                                              $ymajor_entry->g_grid();
                                              $ytitle_label->g_grid();
                                              $ytitle_entry->g_grid();

                                              $ymin = &datelabel2jdate($ymin) -$base_jd +1;
                                              $ymax = &datelabel2jdate($ymax) -$base_jd +1;
                                              if ($ymin < 1 || $ymax <= $ymin || $ymax <= 1) {
                                                  if ($ytype_sav eq "Date/Time") {
                                                      $ymin = 1 if ($ymin < 1);
                                                      if ($ymax <= $ymin || $ymax <= 1) {
                                                          $ymax = ($ymin < 366) ? 366 : $ymin +365;
                                                      }
                                                  } else {
                                                      $ymin = $gr_props{$id}{ymin};
                                                      $ymax = $gr_props{$id}{ymax};
                                                  }
                                              }
                                          }
                                        });
            $ytype_frame->new_checkbutton(
                    -onvalue  => 1,
                    -offvalue => 0,
                    -text     => "Flip?",
                    -font     => 'default',
                    -variable => \$yaxis_flip,
                    )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);

            $row++;
            ($byear_label = $yaxis_frame->new_label(
                    -text => "Base Year: ",
                    -font => 'default',
                    ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($byear_frame = $yaxis_frame->new_frame(
                    -borderwidth => 0,
                    -relief      => 'flat',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew');
            ($byear_cb = $byear_frame->new_ttk__combobox(
                    -textvariable => \$byear,
                    -values       => [ reverse($yr_min .. $yr_max) ],
                    -state        => 'readonly',
                    -width        => 5,
                    ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
            $byear_cb->g_bind("<<ComboboxSelected>>",
                              sub { if ($byear == $yr_min) {
                                        $yr_min -= 10;
                                        $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                    }
                                  }
                             );
            $byear_frame->new_label(
                    -text   => " for JDAY = 1",
                    -anchor => 'w',
                    -font   => 'default',
                    )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);

            $row++;
            ($yformat_label = $yaxis_frame->new_label(
                    -text => "Y Ticklabel Format: ",
                    -font => 'default',
                    ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($yformat_cb = $yaxis_frame->new_ttk__combobox(
                    -textvariable => \$yformat,
                    -values       => [ @date_axis_choices ],
                    -state        => 'readonly',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
            $yformat_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($yformat =~ /Year|Mon-DD/) {
                                $ytick_int_sb->configure(-state => ($ymaj_auto) ? 'disabled' : 'normal');
                                $ytick_auto_cb->configure(-state => 'normal');
                            } else {
                                $ytick_int_sb->configure(-state => 'disabled');
                                $ytick_auto_cb->configure(-state => 'disabled');
                            }
                          });

            $row++;
            $yaxis_frame->new_label(
                    -text    => "Y Axis Minimum: ",
                    -font    => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($ymin_entry = $yaxis_frame->new_entry(
                    -textvariable => \$ymin,
                    -font         => 'default',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
            $ymin_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($ymin_entry);
                                                      if ($ymin ne "" && $ymin ne "." && $ymin ne "-") {
                                                          my $tmp = &round_to_int(1000.*$ymin)/1000.;
                                                          $ymin = $tmp if ($ymin != $tmp);
                                                      }
                                                    });
            $ymin_entry->g_grid_remove();
            ($ymin_cb = $yaxis_frame->new_ttk__combobox(
                    -textvariable => \$ymin,
                    -values       => [ @datelist1 ],
                    -state        => 'readonly',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
            $ymin_cb->g_bind("<<ComboboxSelected>>",
                              sub { if (&datelabel2jdate($ymax) - &datelabel2jdate($ymin) > 365 *2) {
                                        if ($#date_axis_choices == 2) {
                                            unshift (@date_axis_choices, "Year");
                                            $yformat_cb->configure(-values => [ @date_axis_choices ]);
                                        }
                                    } elsif ($#date_axis_choices == 3) {
                                        shift @date_axis_choices;
                                        $yformat_cb->configure(-values => [ @date_axis_choices ]);
                                        if ($yformat eq "Year") {
                                            $yformat = "Month";
                                            Tkx::event_generate($yformat_cb, "<<ComboboxSelected>>");
                                        }
                                    }
                                  }
                            );

            $row++;
            $yaxis_frame->new_label(
                    -text    => "Y Axis Maximum: ",
                    -font    => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($ymax_entry = $yaxis_frame->new_entry(
                    -textvariable => \$ymax,
                    -font         => 'default',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
            $ymax_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($ymax_entry);
                                                      if ($ymax ne "" && $ymax ne "." && $ymax ne "-") {
                                                          my $tmp = &round_to_int(1000.*$ymax)/1000.;
                                                          $ymax = $tmp if ($ymax != $tmp);
                                                      }
                                                    });
            $ymax_entry->g_grid_remove();
            ($ymax_cb = $yaxis_frame->new_ttk__combobox(
                    -textvariable => \$ymax,
                    -values       => [ @datelist2 ],
                    -state        => 'readonly',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
            $ymax_cb->g_bind("<<ComboboxSelected>>",
                              sub { if (&datelabel2jdate($ymax) - &datelabel2jdate($ymin) > 365 *2) {
                                        if ($#date_axis_choices == 2) {
                                            unshift (@date_axis_choices, "Year");
                                            $yformat_cb->configure(-values => [ @date_axis_choices ]);
                                        }
                                    } elsif ($#date_axis_choices == 3) {
                                        shift @date_axis_choices;
                                        $yformat_cb->configure(-values => [ @date_axis_choices ]);
                                        if ($yformat eq "Year") {
                                            $yformat = "Month";
                                            Tkx::event_generate($yformat_cb, "<<ComboboxSelected>>");
                                        }
                                    }
                                  }
                            );

            $row++;
            $yaxis_frame->new_label(
                    -text    => "Y Tick Interval: ",
                    -font    => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($ymajor_entry = $yaxis_frame->new_entry(
                    -textvariable => \$ymajor,
                    -font         => 'default',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
            $ymajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($ymajor_entry, 1);
                                                        $ymajor =~ s/^-//;
                                                  });
            $ymajor_entry->g_grid_remove();
            ($ytick_frame = $yaxis_frame->new_frame(
                    -borderwidth => 0,
                    -relief      => 'flat',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew');
            ($ytick_int_sb = $ytick_frame->new_spinbox(
                    -textvariable => \$ymajor,
                    -state        => 'normal',
                    -font         => 'default',
                    -from         => 1,
                    -to           => 5000,
                    -increment    => 1,
                    -width        => 5,
                    ))->g_pack(-side => 'left', -anchor => 'w', -pady => 0);
            $ytick_int_sb->g_bind("<KeyRelease>", sub { &numeric_entry_only($ytick_int_sb);
                                                        $ymajor =~ s/^-//;
                                                        $ymajor = 1 if ($ymajor eq "" || $ymajor == 0);
                                                        $ymajor = &round_to_int(abs($ymajor));
                                                      });
            ($ytick_auto_cb = $ytick_frame->new_checkbutton(
                    -onvalue  => 1,
                    -offvalue => 0,
                    -text     => "Auto",
                    -font     => 'default',
                    -variable => \$ymaj_auto,
                    -command  => sub { $ytick_int_sb->configure(-state => ($ymaj_auto) ? 'disabled':'normal');
                                     },
                    ))->g_pack(-side => 'left', -anchor => 'w', -pady => 0);
            $ytick_auto_cb->configure(-state => ($yformat eq "Month") ? 'disabled' : 'normal');
            $ytick_int_sb->configure(-state => ($yformat eq "Month" || $ymaj_auto) ? 'disabled' : 'normal');

            $row++;
            $yaxis_frame->new_label(
                    -text    => "Y Primary Ticks: ",
                    -font    => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            $yaxis_frame->new_ttk__combobox(
                    -textvariable => \$ypr_tics,
                    -values       => [ @tic_opts ],
                    -state        => 'readonly',
                    )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

            $row++;
            $yaxis_frame->new_label(
                    -text    => "Y Opposite Ticks: ",
                    -font    => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            $yaxis_frame->new_ttk__combobox(
                    -textvariable => \$yop_tics,
                    -values       => [ @tic_opts ],
                    -state        => 'readonly',
                    )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

            $row++;
            ($ytitle_label = $yaxis_frame->new_label(
                    -text => "Y Axis Title: ",
                    -font => 'default',
                    ))->g_grid(-row => $row, -column => 0, -sticky => 'w', -pady => 2);
            $row++;
            ($ytitle_entry = $yaxis_frame->new_entry(
                    -textvariable => \$ytitle,
                    -font         => 'default',
                    ))->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew', -pady => 2);

            if ($yaxis_type eq "Date/Time") {
                $ymin_entry->g_grid_remove();
                $ymax_entry->g_grid_remove();
                $ymajor_entry->g_grid_remove();
                $byear_label->g_grid_remove();
                $byear_frame->g_grid_remove();
                $ytitle_label->g_grid_remove();
                $ytitle_entry->g_grid_remove();
                $yformat_label->g_grid();
                $yformat_cb->g_grid();
                $ymin_cb->g_grid();
                $ymax_cb->g_grid();
                $ytick_frame->g_grid();
            } else {
                $yformat_label->g_grid_remove();
                $yformat_cb->g_grid_remove();
                $ymin_cb->g_grid_remove();
                $ymax_cb->g_grid_remove();
                $ytick_frame->g_grid_remove();
                $byear_label->g_grid();
                $byear_frame->g_grid();
                $ymin_entry->g_grid();
                $ymax_entry->g_grid();
                $ymajor_entry->g_grid();
                $ytitle_label->g_grid();
                $ytitle_entry->g_grid();
            }
            $yaxis_frame->g_grid_columnconfigure(2, -weight => 2);

        } else {
            $row++;
            $yaxis_frame->new_label(
                    -text    => "Y Axis Base: ",
                    -font    => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($ybase_entry = $yaxis_frame->new_entry(
                    -textvariable => \$ybase,
                    -font         => 'default',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
            $ybase_entry->g_bind("<KeyRelease>",
                                  sub { my ($mult);
                                        &numeric_entry_only($ybase_entry);
                                        if ($ybase ne "" && $ybase ne "." && $ybase ne "-") {
                                            my $tmp = &round_to_int(1000.*$ybase)/1000.;
                                            $ybase = $tmp if ($ybase != $tmp);
                                            if ($ymax_auto) {
                                                $mult = ($yaxis_units eq "miles") ? 3280.84/5280. : 1.0;
                                                $ymax = $ybase +$gr_props{$id}{d_km} *$mult;
                                                $ymax = &round_to_int(1000.*$ymax)/1000.;
                                            }
                                        } elsif ($ybase eq "" || $ybase eq ".") {
                                            if ($ymax_auto) {
                                                $mult = ($yaxis_units eq "miles") ? 3280.84/5280. : 1.0;
                                                $ymax = $gr_props{$id}{d_km} *$mult;
                                                $ymax = &round_to_int(1000.*$ymax)/1000.;
                                            }
                                        }
                                      });

            $row++;
            $yaxis_frame->new_label(
                    -text    => "Y Axis Minimum: ",
                    -font    => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($ymin_entry = $yaxis_frame->new_entry(
                    -textvariable => \$ymin,
                    -font         => 'default',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
            $ymin_entry->g_bind("<KeyRelease>",
                                 sub { &numeric_entry_only($ymin_entry);
                                       if ($ymin ne "" && $ymin ne "." && $ymin ne "-") {
                                           my $tmp = &round_to_int(1000.*$ymin)/1000.;
                                           $ymin = $tmp if ($ymin != $tmp);
                                           if ($yfirst ne "" && $yfirst ne "."
                                                             && $yfirst ne "-" && $yfirst < $ymin) {
                                               if (&ceil($ymin) != $ymin) {
                                                   $yfirst = &ceil($ymin);
                                               } else {
                                                   $yfirst = $ymin;
                                               }
                                           }
                                       }
                                     });

            $row++;
            $yaxis_frame->new_label(
                    -text    => "Y Axis First Label: ",
                    -font    => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($yfirst_entry = $yaxis_frame->new_entry(
                    -textvariable => \$yfirst,
                    -font         => 'default',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
            $yfirst_entry->g_bind("<KeyRelease>",
                                   sub { &numeric_entry_only($yfirst_entry);
                                         if ($yfirst ne "" && $yfirst ne "." && $yfirst ne "-") {
                                             my $tmp = &round_to_int(1000.*$yfirst)/1000.;
                                             $yfirst = $tmp if ($yfirst != $tmp);
                                         }
                                       });

            $row++;
            $yaxis_frame->new_label(
                    -text    => "Y Axis Maximum: ",
                    -font    => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($ymax_frame = $yaxis_frame->new_frame(
                    -borderwidth => 0,
                    -relief      => 'flat',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew');
            ($ymax_entry = $ymax_frame->new_entry(
                    -textvariable => \$ymax,
                    -font         => 'default',
                    -width        => 10,
                    ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
            $ymax_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($ymax_entry);
                                                      $ymax =~ s/^-//;
                                                      if ($ymax ne "" && $ymax ne ".") {
                                                          my $tmp = &round_to_int(1000.*$ymax)/1000.;
                                                          $ymax = $tmp if ($ymax != $tmp);
                                                      }
                                                    });
            $ymax_frame->new_checkbutton(
                    -onvalue  => 1,
                    -offvalue => 0,
                    -text     => "Auto",
                    -font     => 'default',
                    -variable => \$ymax_auto,
                    -command  => sub { my ($mult);
                                       if ($ymax_auto) {
                                           $mult = ($gr_props{$id}{dunits} eq "miles") ? 3280.84/5280. : 1.0;
                                           if ($ybase ne "" && $ybase ne "." && $ybase ne "-") {
                                               $ymax = $ybase + $gr_props{$id}{d_km} *$mult;
                                               $ymax = &round_to_int(1000.*$ymax)/1000.;
                                           } elsif ($ybase eq "" || $ybase eq ".") {
                                               $ymax = $gr_props{$id}{d_km} *$mult;
                                               $ymax = &round_to_int(1000.*$ymax)/1000.;
                                           }
                                           $ymax_entry->configure(-state => 'disabled');
                                       } else {
                                           $ymax_entry->configure(-state => 'normal');
                                       }
                                     }
                    )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
            $ymax_entry->configure(-state => ($ymax_auto) ? 'disabled' : 'normal');

            $row++;
            $yaxis_frame->new_label(
                    -text    => "Y Tick Interval: ",
                    -font    => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($ymajor_entry = $yaxis_frame->new_entry(
                    -textvariable => \$ymajor,
                    -font         => 'default',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
            $ymajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($ymajor_entry, 1);
                                                        $ymajor =~ s/^-//;
                                                      });

            $row++;
            $yaxis_frame->new_label(
                    -text    => "Y Primary Ticks: ",
                    -font    => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            $yaxis_frame->new_ttk__combobox(
                    -textvariable => \$ypr_tics,
                    -values       => [ @tic_opts ],
                    -state        => 'readonly',
                    )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

            $row++;
            $yaxis_frame->new_label(
                    -text    => "Y Opposite Ticks: ",
                    -font    => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            $yaxis_frame->new_ttk__combobox(
                    -textvariable => \$yop_tics,
                    -values       => [ @tic_opts ],
                    -state        => 'readonly',
                    )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

            $row++;
            $yaxis_frame->new_label(
                    -text => "Y Axis Units: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($yunits_frame = $yaxis_frame->new_frame(
                    -borderwidth => 0,
                    -relief      => 'flat',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew');
            ($yunits_cb = $yunits_frame->new_ttk__combobox(
                    -textvariable => \$yaxis_units,
                    -values       => [ ("miles", "kilometers") ],
                    -state        => 'readonly',
                    -width        => 10,
                    ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
            $yunits_cb->g_bind("<<ComboboxSelected>>",
                                sub { return if ($yaxis_units eq $old_yunits);
                                      if ($yaxis_units eq "miles") {
                                          if ($ybase ne "" && $ybase ne "." && $ybase ne "-") {
                                              $ybase *= 3280.84/5280.;
                                              $ybase = &round_to_int(1000.*$ybase)/1000.;
                                          }
                                          if ($ymin ne "" && $ymin ne "." && $ymin ne "-") {
                                              $ymin *= 3280.84/5280.;
                                              $ymin = &round_to_int(1000.*$ymin)/1000.;
                                          }
                                          if ($yfirst ne "" && $yfirst ne "." && $yfirst ne "-") {
                                              $yfirst *= 3280.84/5280.;
                                              $yfirst = &round_to_int(1000.*$yfirst)/1000.;
                                          }
                                          if ($ymax ne "" && $ymax ne "." && $ymax ne "-") {
                                              $ymax *= 3280.84/5280.;
                                              $ymax = &round_to_int(1000.*$ymax)/1000.;
                                          }
                                          $ytitle =~ s/kilometer/mile/;
                                          $ytitle =~ s/Kilometer/Mile/;
                                          $ytitle =~ s/KILOMETER/MILE/;
                                      } else {
                                          if ($ybase ne "" && $ybase ne "." && $ybase ne "-") {
                                              $ybase *= 5280./3280.84;
                                              $ybase = &round_to_int(1000.*$ybase)/1000.;
                                          }
                                          if ($ymin ne "" && $ymin ne "." && $ymin ne "-") {
                                              $ymin *= 5280./3280.84;
                                              $ymin = &round_to_int(1000.*$ymin)/1000.;
                                          }
                                          if ($yfirst ne "" && $yfirst ne "." && $yfirst ne "-") {
                                              $yfirst *= 5280./3280.84;
                                              $yfirst = &round_to_int(1000.*$yfirst)/1000.;
                                          }
                                          if ($ymax ne "" && $ymax ne "." && $ymax ne "-") {
                                              $ymax *= 5280./3280.84;
                                              $ymax = &round_to_int(1000.*$ymax)/1000.;
                                          }
                                          $ytitle =~ s/mile/kilometer/;
                                          $ytitle =~ s/Mile/Kilometer/;
                                          $ytitle =~ s/MILE/KILOMETER/;
                                      }
                                      $old_yunits = $yaxis_units;
                                    });
            $yunits_frame->new_checkbutton(
                    -onvalue  => 1,
                    -offvalue => 0,
                    -text     => "Flip?",
                    -font     => 'default',
                    -variable => \$yaxis_flip,
                    )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);

            $row++;
            ($ytitle_frame = $yaxis_frame->new_frame(
                    -borderwidth => 0,
                    -relief      => 'flat',
                    ))->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew');
            $ytitle_frame->new_label(
                    -text => "Y Axis Title: ",
                    -font => 'default',
                    )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
            $ytitle_frame->new_entry(
                    -textvariable => \$ytitle,
                    -font         => 'default',
                    )->g_pack(-side => 'left', -anchor => 'w', -expand => 1, -fill => 'x', -pady => 2);
        }
        $yaxis_frame->g_grid_columnconfigure(0, -weight => 2);
    }

#   Segment axis tab
    if ($props{$id}{meta} =~ /w2_slice|w2_wlevels/) {
        @saxis_opts  = ("None", "Above X Axis", "Below X Axis", "Replace X Axis");
        @saxis_types = ("none", "above", "below", "replace");
        if (&list_match($stype, @saxis_types) >= 0) {
            $saxis_opt = $saxis_opts[&list_match($stype, @saxis_types)]; 
        } else {
            $stype     = "none";
            $saxis_opt = "None";
        }
        $old_stic_loc = $stic_loc;
        $stic_dx = 0;
        $anc = 'n';
        if ($stic_loc =~ /^down/) {
            $stic_dx = 0.05*$pw;
            $anc = 'ne';
        } elsif ($stic_loc =~ /^up/) {
            $stic_dx = -0.05*$pw;
            $anc = 'nw';
        }

        $saxis_tab = $grprops_notebook->new_frame();
        $grprops_notebook->add($saxis_tab,
                -text      => "S Axis",
                -underline => 0,
                -sticky    => 'nsew',
                );

        $preview_saxis = $saxis_tab->new_canvas(
                -background  => &get_rgb_code($canvas_color),
                -width       => $pw,
                -height      => $ph,
                -borderwidth => 1,
                -relief      => 'groove',
                );
        $preview_saxis->g_grid(-row => 0, -column => 0, -sticky => 'wne');

        $stitle_txt = $preview_saxis->create_text($pw*0.3 +3, $ph*0.5 +3,
                -anchor => 'center', 
                -text   => "Axis Title",
                -fill   => "#000000",
                -angle  => 0,
                -font   => [-family     => $sfont,
                            -size       => $st_size,
                            -weight     => $st_weight,
                            -slant      => 'roman',
                            -underline  => 0,
                            -overstrike => 0,
                           ]);
        $preview_saxis->create_rectangle($pw*0.6, $ph*0.15, $pw*0.7, $ph*0.35,
                                         -outline => "#000000",
                                         -width   => 1,
                                         -fill    => "#C0C0C0",
                                         -tags    => "saxis_box",
                                        );
        $preview_saxis->create_rectangle($pw*0.7, $ph*0.15, $pw*0.8, $ph*0.35,
                                         -outline => "#000000",
                                         -width   => 1,
                                         -fill    => "#C0C0C0",
                                         -tags    => "saxis_box",
                                        );
        $preview_saxis->create_rectangle($pw*0.8, $ph*0.15, $pw*0.9, $ph*0.35,
                                         -outline => "#000000",
                                         -width   => 1,
                                         -fill    => "#C0C0C0",
                                         -tags    => "saxis_box",
                                        );
        $preview_saxis->create_line($pw*0.65+$stic_dx, $ph*0.35, $pw*0.65+$stic_dx, $ph*0.5,
                                    -width => 1,
                                    -fill  => "#000000",
                                    -arrow => 'none',
                                    -tags  => "stic_line",
                                   );
        $preview_saxis->create_line($pw*0.75+$stic_dx, $ph*0.35, $pw*0.75+$stic_dx, $ph*0.5,
                                    -width => 1,
                                    -fill  => "#000000",
                                    -arrow => 'none',
                                    -tags  => "stic_line",
                                   );
        $preview_saxis->create_line($pw*0.85+$stic_dx, $ph*0.35, $pw*0.85+$stic_dx, $ph*0.5,
                                    -width => 1,
                                    -fill  => "#000000",
                                    -arrow => 'none',
                                    -tags  => "stic_line",
                                   );
        $preview_saxis->create_text($pw*0.65+$stic_dx, $ph*0.5,
                -anchor => $anc, 
                -text   => "2",
                -fill   => "#000000",
                -angle  => 0,
                -tags   => "stic_txt",
                -font   => [-family     => $sfont,
                            -size       => $sl_size,
                            -weight     => $sl_weight,
                            -slant      => 'roman',
                            -underline  => 0,
                            -overstrike => 0,
                           ]);
        $preview_saxis->create_text($pw*0.75+$stic_dx, $ph*0.5,
                -anchor => $anc, 
                -text   => "3",
                -fill   => "#000000",
                -angle  => 0,
                -tags   => "stic_txt",
                -font   => [-family     => $sfont,
                            -size       => $sl_size,
                            -weight     => $sl_weight,
                            -slant      => 'roman',
                            -underline  => 0,
                            -overstrike => 0,
                           ]);
        $preview_saxis->create_text($pw*0.85+$stic_dx, $ph*0.5,
                -anchor => $anc, 
                -text   => "4",
                -fill   => "#000000",
                -angle  => 0,
                -tags   => "stic_txt",
                -font   => [-family     => $sfont,
                            -size       => $sl_size,
                            -weight     => $sl_weight,
                            -slant      => 'roman',
                            -underline  => 0,
                            -overstrike => 0,
                           ]);

        $saxis_frame = $saxis_tab->new_frame(
                -borderwidth => 1,
                -relief      => 'groove',
                );
        $saxis_frame->g_grid(-row => 1, -column => 0, -sticky => 'wnes');

        $row = 0;
        $saxis_frame->new_label(
                -text => "Segment Axis: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($stype_cb = $saxis_frame->new_ttk__combobox(
                -textvariable => \$saxis_opt,
                -values       => [ ("None", "Below X Axis", "Above X Axis", "Replace X Axis") ],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $stype_cb->g_bind("<<ComboboxSelected>>",
                          sub { $stype = $saxis_types[&list_match($saxis_opt, @saxis_opts)];
                                if ($stype eq "none") {
                                    $sfont_cb->configure(-state => 'disabled');
                                    $st_size_cb->configure(-state => 'disabled');
                                    $st_weight_cb->configure(-state => 'disabled');
                                    $sl_size_cb->configure(-state => 'disabled');
                                    $sl_weight_cb->configure(-state => 'disabled');
                                    $stic_loc_cb->configure(-state => 'disabled');
                                    $smajor_entry->configure(-state => 'disabled');
                                    $sgrid_ck->configure(-state => 'disabled');
                                    $sgrid_col_btn->configure(-state => 'disabled');
                                    $bgrid_ck->configure(-state => 'disabled');
                                    $bgrid_col_btn->configure(-state => 'disabled');
                                    $stitle_entry->configure(-state => 'disabled');
                                } else {
                                    $sfont_cb->configure(-state => 'readonly');
                                    $st_size_cb->configure(-state => 'readonly');
                                    $st_weight_cb->configure(-state => 'readonly');
                                    $sl_size_cb->configure(-state => 'readonly');
                                    $sl_weight_cb->configure(-state => 'readonly');
                                    $stic_loc_cb->configure(-state => 'readonly');
                                    $smajor_entry->configure(-state => 'normal');
                                    $sgrid_ck->configure(-state => 'normal');
                                    $sgrid_col_btn->configure(-state => 'normal') if ($sgrid);
                                    $bgrid_ck->configure(-state => 'normal');
                                    $bgrid_col_btn->configure(-state => 'normal') if ($bgrid);
                                    $stitle_entry->configure(-state => 'normal');
                                }
                              });

        $row++;
        $saxis_frame->new_label(
                -text => "S Axis Font: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($sfont_cb = $saxis_frame->new_ttk__combobox(
                -textvariable => \$sfont,
                -values       => [ sort @available_fonts ],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
        $sfont_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_saxis->itemconfigure($stitle_txt,
                              -font => [ -family     => $sfont,
                                         -size       => $st_size,
                                         -weight     => $st_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                        $preview_saxis->itemconfigure("stic_txt",
                              -font => [ -family     => $sfont,
                                         -size       => $sl_size,
                                         -weight     => $sl_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });
        $row++;
        $saxis_frame->new_label(
                -text => "S Title/Label Size: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($st_size_cb = $saxis_frame->new_ttk__combobox(
                -textvariable => \$st_size,
                -values       => [(5 .. 24)],
                -width        => 5,
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
        $st_size_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_saxis->itemconfigure($stitle_txt,
                              -font => [ -family     => $sfont,
                                         -size       => $st_size,
                                         -weight     => $st_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });
        ($sl_size_cb = $saxis_frame->new_ttk__combobox(
                -textvariable => \$sl_size,
                -values       => [(5 .. 24)],
                -width        => 5,
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 2, -sticky => 'ew', -pady => 2);
        $sl_size_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_saxis->itemconfigure("stic_txt",
                              -font => [ -family     => $sfont,
                                         -size       => $sl_size,
                                         -weight     => $sl_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });
        $row++;
        $saxis_frame->new_label(
                -text => "S Title/Label Weight: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($st_weight_cb = $saxis_frame->new_ttk__combobox(
                -textvariable => \$st_weight,
                -values       => [("normal", "bold")],
                -width        => 5,
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
        $st_weight_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_saxis->itemconfigure($stitle_txt,
                              -font => [ -family     => $sfont,
                                         -size       => $st_size,
                                         -weight     => $st_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });
        ($sl_weight_cb = $saxis_frame->new_ttk__combobox(
                -textvariable => \$sl_weight,
                -values       => [("normal", "bold")],
                -width        => 5,
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 2, -sticky => 'ew', -pady => 2);
        $sl_weight_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_saxis->itemconfigure("stic_txt",
                              -font => [ -family     => $sfont,
                                         -size       => $sl_size,
                                         -weight     => $sl_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });

        $row++;
        $saxis_frame->new_label(
                -text => "S Tick Placement: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($stic_loc_cb = $saxis_frame->new_ttk__combobox(
                -textvariable => \$stic_loc,
                -values       => [("upstream edge", "center", "downstream edge")],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $stic_loc_cb->g_bind("<<ComboboxSelected>>",
                  sub { return if ($stic_loc eq $old_stic_loc);
                        if ($old_stic_loc eq "center") {
                            $stic_dx = ($stic_loc =~ /down/) ? 0.05*$pw : -0.05*$pw;
                        } elsif ($old_stic_loc =~ /down/) {
                            $stic_dx = ($stic_loc eq "center") ? -0.05*$pw : -0.1*$pw;
                        } else {
                            $stic_dx = ($stic_loc eq "center") ? 0.05*$pw : 0.1*$pw;
                        }
                        $anc = 'n';
                        if ($stic_loc =~ /down/) {
                            $anc = 'ne';
                        } elsif ($stic_loc =~ /up/) {
                            $anc = 'nw';
                        }
                        $preview_saxis->move("stic_line", $stic_dx, 0);
                        $preview_saxis->move("stic_txt", $stic_dx, 0);
                        $preview_saxis->itemconfigure("stic_txt", -anchor => $anc);
                        $old_stic_loc = $stic_loc;
                      });

        $row++;
        $saxis_frame->new_label(
                -text => "S Major Interval: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($smajor_entry = $saxis_frame->new_entry(
                -textvariable => \$smajor,
                -font         => 'default',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $smajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($smajor_entry, 1);
                                                    $smajor =~ s/^-//;
                                                    if ($smajor ne "auto" and $smajor ne "") {
                                                        $smajor = int($smajor);
                                                    }
                                                  });

        $row++;
        $saxis_frame->new_label(
                -text    => "S Primary Ticks: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $saxis_frame->new_ttk__combobox(
                -textvariable => \$spr_tics,
                -values       => [ @tic_opts ],
                -state        => 'readonly',
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

        $row++;
        $saxis_frame->new_label(
                -text    => "S Opposite Ticks: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $saxis_frame->new_ttk__combobox(
                -textvariable => \$sop_tics,
                -values       => [ @tic_opts ],
                -state        => 'readonly',
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

        $row++;
        $saxis_frame->new_label(
                -text => "S Grid Lines: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($sgrid_ck = $saxis_frame->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "Show",
                -font     => 'default',
                -variable => \$sgrid,
                -command  => sub { my $status = ($sgrid) ? 'normal' : 'disabled';
                                   $sgrid_col_btn->configure(-state => $status);
                                 },
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $code      = &get_rgb_code($sgrid_col);
        $sgrid_col = &get_rgb_name($code);
        $fg        = &get_rgb_code("black");
        if ($code =~ /^\#[0-9a-f]/i) {
            $fg = &get_rgb_code(&get_bw_contrast($code));
        }
        ($sgrid_col_btn = $saxis_frame->new_button(
                        -textvariable => \$sgrid_col,
                        -background   => $code,
                        -foreground   => $fg,
                        -width        => -7,
                        -command => sub { my ($newc, $code, $fg);
                                          $code = &get_rgb_code($sgrid_col);
                                          $newc = Tkx::tk___chooseColor(
                                                     -initialcolor => $code,
                                                     -parent       => $graph_props_menu);
                                          if ($newc) {
                                              $code      = &get_rgb_code($newc);
                                              $sgrid_col = &get_rgb_name($code);
                                              $fg        = &get_rgb_code("black");
                                              if ($code =~ /^#?[0-9a-f]/i) {
                                                  $fg = &get_rgb_code(&get_bw_contrast($code));
                                              }
                                              $sgrid_col_btn->configure(-foreground => $fg,
                                                                        -background => $code);
                                          }
                                        }
                        ))->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

        $row++;
        $saxis_frame->new_label(
                -text => "Branch Edge Grid: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($bgrid_ck = $saxis_frame->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "Show",
                -font     => 'default',
                -variable => \$bgrid,
                -command  => sub { my $status = ($bgrid) ? 'normal' : 'disabled';
                                   $bgrid_col_btn->configure(-state => $status);
                                 },
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $code      = &get_rgb_code($bgrid_col);
        $bgrid_col = &get_rgb_name($code);
        $fg        = &get_rgb_code("black");
        if ($code =~ /^\#[0-9a-f]/i) {
            $fg = &get_rgb_code(&get_bw_contrast($code));
        }
        ($bgrid_col_btn = $saxis_frame->new_button(
                        -textvariable => \$bgrid_col,
                        -background   => $code,
                        -foreground   => $fg,
                        -width        => -7,
                        -command => sub { my ($newc, $code, $fg);
                                          $code = &get_rgb_code($bgrid_col);
                                          $newc = Tkx::tk___chooseColor(
                                                     -initialcolor => $code,
                                                     -parent       => $graph_props_menu);
                                          if ($newc) {
                                              $code      = &get_rgb_code($newc);
                                              $bgrid_col = &get_rgb_name($code);
                                              $fg        = &get_rgb_code("black");
                                              if ($code =~ /^#?[0-9a-f]/i) {
                                                  $fg = &get_rgb_code(&get_bw_contrast($code));
                                              }
                                              $bgrid_col_btn->configure(-foreground => $fg,
                                                                        -background => $code);
                                          }
                                        }
                        ))->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

        $row++;
        $saxis_frame->new_label(
                -text => "S Axis Title: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'w', -pady => 2);
        $row++;
        ($stitle_entry = $saxis_frame->new_entry(
                -textvariable => \$stitle,
                -font         => 'default',
                ))->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew', -pady => 2);

        if ($stype eq "none") {
            $sfont_cb->configure(-state => 'disabled');
            $st_size_cb->configure(-state => 'disabled');
            $st_weight_cb->configure(-state => 'disabled');
            $sl_size_cb->configure(-state => 'disabled');
            $sl_weight_cb->configure(-state => 'disabled');
            $stic_loc_cb->configure(-state => 'disabled');
            $smajor_entry->configure(-state => 'disabled');
            $sgrid_ck->configure(-state => 'disabled');
            $sgrid_col_btn->configure(-state => 'disabled');
            $bgrid_ck->configure(-state => 'disabled');
            $bgrid_col_btn->configure(-state => 'disabled');
            $stitle_entry->configure(-state => 'disabled');
        }
        $saxis_frame->g_grid_columnconfigure(0, -weight => 2);
    }

#   Graph title tab
    $gtitle_tab = $grprops_notebook->new_frame();
    $grprops_notebook->add($gtitle_tab,
            -text      => "Title",
            -underline => 0,
            -sticky    => 'nsew',
            );

    $preview_gtitle = $gtitle_tab->new_canvas(
            -background  => &get_rgb_code($canvas_color),
            -width       => $pw,
            -height      => $ph,
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $preview_gtitle->g_grid(-row => 0, -column => 0, -sticky => 'wne');

    if ($props{$id}{meta} =~ /(data_profile_cmap|w2_profile_cmap|time_series)/) {
        $gtitle_txt = $preview_gtitle->create_text($pw*0.5 +3, $ph*0.5 +3,
                -anchor => 'center', 
                -text   => "Graph Title",
                -fill   => "#000000",
                -angle  => 0,
                -font   => [-family     => $gtfont,
                            -size       => $gt_size,
                            -weight     => $gt_weight,
                            -slant      => 'roman',
                            -underline  => 0,
                            -overstrike => 0,
                           ]);
    } else {
        $preview_gtitle->configure(-height => 2 *$ph);
        $gtitle_txt = $preview_gtitle->create_text($pw*0.5 +3, $ph*0.6 +3,
                -anchor => 'center', 
                -text   => "Graph Title",
                -fill   => "#000000",
                -angle  => 0,
                -font   => [-family     => $gtfont,
                            -size       => $gt_size,
                            -weight     => $gt_weight,
                            -slant      => 'roman',
                            -underline  => 0,
                            -overstrike => 0,
                           ]);
        $sub_txt = ($props{$id}{meta} eq "w2_profile_matrix") ? "Graph Date" : "Graph Subtitle";
        $gsubtitle_txt = $preview_gtitle->create_text($pw*0.5 +3, $ph*1.4 +3,
                -anchor => 'center', 
                -text   => $sub_txt,
                -fill   => "#000000",
                -angle  => 0,
                -font   => [-family     => $gtfont,
                            -size       => $gs_size,
                            -weight     => $gs_weight,
                            -slant      => 'roman',
                            -underline  => 0,
                            -overstrike => 0,
                           ]);
        if ($props{$id}{meta} eq "w2_profile_matrix") {
            @coords = Tkx::SplitList($preview_gtitle->bbox($gsubtitle_txt));
            $coords[0] -= 5;
            $coords[1] -= 4;
            $coords[2] += 5;
            $coords[3] += 4;
            $gsub_box = $preview_gtitle->create_rectangle(@coords,
                            -outline => "",
                            -width   => 0,
                            -fill    => "");
            if ($gs_fill && $gs_fillc ne "") {
                $preview_gtitle->itemconfigure($gsub_box, -fill => &get_rgb_code($gs_fillc));
            }
            if ($gs_edge && $gs_edgec ne "") {
                $preview_gtitle->itemconfigure($gsub_box, -width => 1, -outline => &get_rgb_code($gs_edgec));
            }
            $preview_gtitle->lower($gsub_box, $gsubtitle_txt);
            $gs_bg_box = $preview_gtitle->create_rectangle(0, $ph+3, $pw, $ph*2,
                                                           -outline => "",
                                                           -width   => 0,
                                                           -fill    => &get_rgb_code("black"),
                                                           -state   => 'hidden');
            $preview_gtitle->lower($gs_bg_box, $gsub_box);
            if ((! $gs_fill && &get_rgb_code($gs_color) eq &get_rgb_code($canvas_color)) ||
                  ($gs_fill && &get_rgb_code($gs_fillc) eq &get_rgb_code($canvas_color))) {
                $preview_gtitle->itemconfigure($gs_bg_box, -state => 'normal');
            }
        }
    }

    $gtitle_frame = $gtitle_tab->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $gtitle_frame->g_grid(-row => 1, -column => 0, -sticky => 'wnes');

    $row = 0;
    $gtitle_frame->new_label(
            -text => "Title Font: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($gtfont_cb = $gtitle_frame->new_ttk__combobox(
            -textvariable => \$gtfont,
            -values       => [ sort @available_fonts ],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
    $gtfont_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_gtitle->itemconfigure($gtitle_txt,
                          -font => [ -family     => $gtfont,
                                     -size       => $gt_size,
                                     -weight     => $gt_weight,
                                     -slant      => 'roman',
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                    if ($props{$id}{meta} !~ /(data_profile_cmap|w2_profile_cmap|time_series)/) {
                        $preview_gtitle->itemconfigure($gsubtitle_txt,
                              -font => [ -family     => $gtfont,
                                         -size       => $gs_size,
                                         -weight     => $gs_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                        if ($props{$id}{meta} eq "w2_profile_matrix") {
                            @coords = Tkx::SplitList($preview_gtitle->bbox($gsubtitle_txt));
                            $coords[0] -= 5;
                            $coords[1] -= 4;
                            $coords[2] += 5;
                            $coords[3] += 4;
                            $preview_gtitle->coords($gsub_box, @coords);
                        }
                    }
                  });

    if ($props{$id}{meta} eq "w2_profile_matrix") {
        $row++;
        $gtitle_frame->new_label(
                -text => "Title/Date Size: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($gt_size_cb = $gtitle_frame->new_ttk__combobox(
                -textvariable => \$gt_size,
                -values       => [(5 .. 24)],
                -width        => 5,
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
        $gt_size_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_gtitle->itemconfigure($gtitle_txt,
                              -font => [ -family     => $gtfont,
                                         -size       => $gt_size,
                                         -weight     => $gt_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });
        ($gs_size_cb = $gtitle_frame->new_ttk__combobox(
                -textvariable => \$gs_size,
                -values       => [(5 .. 24)],
                -width        => 5,
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 2, -sticky => 'ew', -pady => 2);
        $gs_size_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_gtitle->itemconfigure($gsubtitle_txt,
                              -font => [ -family     => $gtfont,
                                         -size       => $gs_size,
                                         -weight     => $gs_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                        @coords = Tkx::SplitList($preview_gtitle->bbox($gsubtitle_txt));
                        $coords[0] -= 5;
                        $coords[1] -= 4;
                        $coords[2] += 5;
                        $coords[3] += 4;
                        $preview_gtitle->coords($gsub_box, @coords);
                      });
        $row++;
        $gtitle_frame->new_label(
                -text => "Title/Date Weight: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($gt_weight_cb = $gtitle_frame->new_ttk__combobox(
                -textvariable => \$gt_weight,
                -values       => [("normal", "bold")],
                -width        => 5,
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
        $gt_weight_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_gtitle->itemconfigure($gtitle_txt,
                              -font => [ -family     => $gtfont,
                                         -size       => $gt_size,
                                         -weight     => $gt_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });
        ($gs_weight_cb = $gtitle_frame->new_ttk__combobox(
                -textvariable => \$gs_weight,
                -values       => [("normal", "bold")],
                -width        => 5,
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 2, -sticky => 'ew', -pady => 2);
        $gs_weight_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_gtitle->itemconfigure($gsubtitle_txt,
                              -font => [ -family     => $gtfont,
                                         -size       => $gs_size,
                                         -weight     => $gs_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                        @coords = Tkx::SplitList($preview_gtitle->bbox($gsubtitle_txt));
                        $coords[0] -= 5;
                        $coords[1] -= 4;
                        $coords[2] += 5;
                        $coords[3] += 4;
                        $preview_gtitle->coords($gsub_box, @coords);
                      });
    } else {
        $row++;
        $gtitle_frame->new_label(
                -text => "Title Size: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($gt_size_cb = $gtitle_frame->new_ttk__combobox(
                -textvariable => \$gt_size,
                -values       => [(5 .. 24)],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
        $gt_size_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_gtitle->itemconfigure($gtitle_txt,
                              -font => [ -family     => $gtfont,
                                         -size       => $gt_size,
                                         -weight     => $gt_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });
        $row++;
        $gtitle_frame->new_label(
                -text => "Title Weight: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($gt_weight_cb = $gtitle_frame->new_ttk__combobox(
                -textvariable => \$gt_weight,
                -values       => [("normal", "bold")],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
        $gt_weight_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_gtitle->itemconfigure($gtitle_txt,
                              -font => [ -family     => $gtfont,
                                         -size       => $gt_size,
                                         -weight     => $gt_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });
        if ($props{$id}{meta} !~ /(data_profile_cmap|w2_profile_cmap|time_series)/) {
            $row++;
            $gtitle_frame->new_label(
                    -text => "Subtitle Size: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($gs_size_cb = $gtitle_frame->new_ttk__combobox(
                    -textvariable => \$gs_size,
                    -values       => [(5 .. 24)],
                    -state        => 'readonly',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
            $gs_size_cb->g_bind("<<ComboboxSelected>>",
                      sub { $preview_gtitle->itemconfigure($gsubtitle_txt,
                                  -font => [ -family     => $gtfont,
                                             -size       => $gs_size,
                                             -weight     => $gs_weight,
                                             -slant      => 'roman',
                                             -underline  => 0,
                                             -overstrike => 0,
                                           ]);
                          });
            $row++;
            $gtitle_frame->new_label(
                    -text => "Subtitle Weight: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($gs_weight_cb = $gtitle_frame->new_ttk__combobox(
                    -textvariable => \$gs_weight,
                    -values       => [("normal", "bold")],
                    -state        => 'readonly',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
            $gs_weight_cb->g_bind("<<ComboboxSelected>>",
                      sub { $preview_gtitle->itemconfigure($gsubtitle_txt,
                                  -font => [ -family     => $gtfont,
                                             -size       => $gs_size,
                                             -weight     => $gs_weight,
                                             -slant      => 'roman',
                                             -underline  => 0,
                                             -overstrike => 0,
                                           ]);
                          });
        }
    }

    if ($props{$id}{meta} eq "w2_profile_matrix") {
        $row++;
        $gtitle_frame->new_label(
                -text => "Date Position: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $gtitle_frame->new_ttk__combobox(
                -textvariable => \$gs_pos,
                -values       => [ ("Top Left", "Top Center", "Top Right", "Middle Left", "Middle Right",
                                    "Bottom Left", "Bottom Center", "Bottom Right") ],
                -state        => 'readonly',
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);

        $row++;
        $gtitle_frame->new_label(
                -text => "Date Format: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $gtitle_frame->new_ttk__combobox(
                -textvariable => \$gs_fmt,
                -values       => [ ("DD-Mon-YYYY HH:mm",
                                    "DD Mon, YYYY HH:mm",
                                    "Mon DD, YYYY HH:mm",
                                    "MM/DD/YYYY HH:mm",
                                    "MM-DD-YYYY HH:mm") ],
                -width        => 21,
                -state        => 'readonly',
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);

        $row++;
        $gtitle_frame->new_label(
                -text => "Date Text Color: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $code     = &get_rgb_code($gs_color);
        $gs_color = &get_rgb_name($code);
        $fg       = &get_rgb_code("black");
        if ($code =~ /^\#[0-9a-f]/i) {
            $fg = &get_rgb_code(&get_bw_contrast($code));
        }
        ($gs_color_btn = $gtitle_frame->new_button(
                -textvariable => \$gs_color,
                -background   => $code,
                -foreground   => $fg,
                -width        => -7,
                -command => sub { my ($newc, $code, $code2, $fg);
                                  $code = &get_rgb_code($gs_color);
                                  $newc = Tkx::tk___chooseColor(
                                             -initialcolor => $code,
                                             -parent       => $graph_props_menu);
                                  if ($newc) {
                                      $code     = &get_rgb_code($newc);
                                      $gs_color = &get_rgb_name($code);
                                      $fg       = &get_rgb_code("black");
                                      if ($code =~ /^#?[0-9a-f]/i) {
                                          $fg = &get_rgb_code(&get_bw_contrast($code));
                                      }
                                      $gs_color_btn->configure(-foreground => $fg,
                                                               -background => $code);
                                      $preview_gtitle->itemconfigure($gsubtitle_txt, -fill => $code);
                                      $code2 = &get_rgb_code($gs_fillc);
                                      if ((! $gs_fill && $code  eq &get_rgb_code($canvas_color)) ||
                                            ($gs_fill && $code2 eq &get_rgb_code($canvas_color))) {
                                          $preview_gtitle->itemconfigure($gs_bg_box, -state => 'normal');
                                      } else {
                                          $preview_gtitle->itemconfigure($gs_bg_box, -state => 'hidden');
                                      }
                                  }
                                }
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

        $row++;
        $gtitle_frame->new_label(
                -text => "Date Box Outline: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $gtitle_frame->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "Show",
                -font     => 'default',
                -variable => \$gs_edge,
                -command  => sub { if ($gs_edge) {
                                       $gs_edgec_btn->configure(-state => 'normal');
                                       $preview_gtitle->itemconfigure($gsub_box, -width => 1,
                                                          -outline => &get_rgb_code($gs_edgec));
                                   } else {
                                       $gs_edgec_btn->configure(-state => 'disabled');
                                       $preview_gtitle->itemconfigure($gsub_box,
                                                          -width => 0, -outline => "");
                                   }
                                 },
                )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

        $code     = &get_rgb_code($gs_edgec);
        $gs_edgec = &get_rgb_name($code);
        $fg       = &get_rgb_code("black");
        if ($code =~ /^\#[0-9a-f]/i) {
            $fg = &get_rgb_code(&get_bw_contrast($code));
        }
        ($gs_edgec_btn = $gtitle_frame->new_button(
                -textvariable => \$gs_edgec,
                -background   => $code,
                -foreground   => $fg,
                -width        => -7,
                -command => sub { my ($newc, $code, $fg);
                                  $code = &get_rgb_code($gs_edgec);
                                  $newc = Tkx::tk___chooseColor(
                                             -initialcolor => $code,
                                             -parent       => $graph_props_menu);
                                  if ($newc) {
                                      $code     = &get_rgb_code($newc);
                                      $gs_edgec = &get_rgb_name($code);
                                      $fg       = &get_rgb_code("black");
                                      if ($code =~ /^#?[0-9a-f]/i) {
                                          $fg = &get_rgb_code(&get_bw_contrast($code));
                                      }
                                      $gs_edgec_btn->configure(-foreground => $fg,
                                                               -background => $code);
                                      $preview_gtitle->itemconfigure($gsub_box, -outline => $code);
                                  }
                                }
                ))->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);
        if (! $gs_edge) {
            $gs_edgec_btn->configure(-state => 'disabled');
        }

        $row++;
        $gtitle_frame->new_label(
                -text => "Date Box Fill: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $gtitle_frame->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "Show",
                -font     => 'default',
                -variable => \$gs_fill,
                -command  => sub { my ($code2);
                                   $code = &get_rgb_code($gs_fillc);
                                   if ($gs_fill) {
                                       $gs_fillc_btn->configure(-state => 'normal');
                                       $preview_gtitle->itemconfigure($gsub_box, -fill => $code);
                                   } else {
                                       $gs_fillc_btn->configure(-state => 'disabled');
                                       $preview_gtitle->itemconfigure($gsub_box, -fill => "");
                                   }
                                   $code2 = &get_rgb_code($gs_color);
                                   if ((! $gs_fill && $code2 eq &get_rgb_code($canvas_color)) ||
                                         ($gs_fill && $code  eq &get_rgb_code($canvas_color))) {
                                       $preview_gtitle->itemconfigure($gs_bg_box, -state => 'normal');
                                   } else {
                                       $preview_gtitle->itemconfigure($gs_bg_box, -state => 'hidden');
                                   }
                                 },
                )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

        $code     = &get_rgb_code($gs_fillc);
        $gs_fillc = &get_rgb_name($code);
        $fg       = &get_rgb_code("black");
        if ($code =~ /^\#[0-9a-f]/i) {
            $fg = &get_rgb_code(&get_bw_contrast($code));
        }
        ($gs_fillc_btn = $gtitle_frame->new_button(
                -textvariable => \$gs_fillc,
                -background   => $code,
                -foreground   => $fg,
                -width        => -7,
                -command => sub { my ($newc, $code, $code2, $fg);
                                  $code = &get_rgb_code($gs_fillc);
                                  $newc = Tkx::tk___chooseColor(
                                             -initialcolor => $code,
                                             -parent       => $graph_props_menu);
                                  if ($newc) {
                                      $code     = &get_rgb_code($newc);
                                      $gs_fillc = &get_rgb_name($code);
                                      $fg       = &get_rgb_code("black");
                                      if ($code =~ /^#?[0-9a-f]/i) {
                                          $fg = &get_rgb_code(&get_bw_contrast($code));
                                      }
                                      $gs_fillc_btn->configure(-foreground => $fg,
                                                               -background => $code);
                                      $preview_gtitle->itemconfigure($gsub_box, -fill => $code);
                                      $code2 = &get_rgb_code($gs_color);
                                      if ((! $gs_fill && $code2 eq &get_rgb_code($canvas_color)) ||
                                            ($gs_fill && $code  eq &get_rgb_code($canvas_color))) {
                                          $preview_gtitle->itemconfigure($gs_bg_box, -state => 'normal');
                                      } else {
                                          $preview_gtitle->itemconfigure($gs_bg_box, -state => 'hidden');
                                      }
                                  }
                                }
                ))->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);
        if (! $gs_fill) {
            $gs_fillc_btn->configure(-state => 'disabled');
        }
    }

    $row++;
    $gtitle_frame->new_label(
            -text    => "Graph Title: ",
            -font    => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'w', -pady => 2);
    $row++;
    $gtitle_frame->new_entry(
            -textvariable => \$gtitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew', -pady => 2);

    if ($props{$id}{meta} eq "w2_tdmap") {
        $row++;
        $gtitle_frame->new_label(
                -text    => "Graph Subtitle: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'w', -pady => 2);
        $row++;
        $gtitle_frame->new_entry(
                -textvariable => \$gstitle,
                -font         => 'default',
                )->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew', -pady => 2);
    }
    $gtitle_frame->g_grid_columnconfigure(0, -weight => 2);

#   Water Levels tab
    if ($props{$id}{meta} eq "w2_wlevels") {
        $wl_color     = $gr_props{$id}{wl_color};
        $wl_style     = $gr_props{$id}{wl_style};
        $wl_grid      = $gr_props{$id}{wl_grid};
        $wl_gridc     = $gr_props{$id}{wl_gridc};
        $old_wl_style = $wl_style;

        $wlevel_tab = $grprops_notebook->new_frame();
        $grprops_notebook->add($wlevel_tab,
                -text      => "Levels",
                -underline => 0,
                -sticky    => 'nsew',
                );

        $preview_levels = $wlevel_tab->new_canvas(
                -background  => &get_rgb_code($canvas_color),
                -width       => $pw,
                -height      => $ph,
                -borderwidth => 1,
                -relief      => 'groove',
                );
        $preview_levels->g_grid(-row => 0, -column => 0, -sticky => 'wne');

        $preview_levels->create_line($pw*0.20, $ph*0.70, $pw*0.25, $ph*0.70,
                                     $pw*0.35, $ph*0.80, $pw*0.45, $ph*0.60,
                                     $pw*0.55, $ph*0.45, $pw*0.65, $ph*0.30,
                                     $pw*0.75, $ph*0.40, $pw*0.80, $ph*0.40,
                                     -width => 1,
                                     -fill  => "#000000",
                                     -arrow => 'none',
                                     -tags  => "_interp_line",
                                    );
        $preview_levels->create_line($pw*0.20, $ph*0.70, $pw*0.30, $ph*0.70,
                                     $pw*0.30, $ph*0.80, $pw*0.40, $ph*0.80,
                                     $pw*0.40, $ph*0.60, $pw*0.50, $ph*0.60,
                                     $pw*0.50, $ph*0.45, $pw*0.60, $ph*0.45,
                                     $pw*0.60, $ph*0.30, $pw*0.70, $ph*0.30,
                                     $pw*0.70, $ph*0.40, $pw*0.80, $ph*0.40,
                                     -width => 1,
                                     -fill  => "#000000",
                                     -arrow => 'none',
                                     -tags  => "_flat_line",
                                    );
        $preview_levels->create_line($pw*0.20, $ph*0.74, $pw*0.30, $ph*0.66,
                                     $pw*0.30, $ph*0.84, $pw*0.40, $ph*0.76,
                                     $pw*0.40, $ph*0.64, $pw*0.50, $ph*0.56,
                                     $pw*0.50, $ph*0.49, $pw*0.60, $ph*0.41,
                                     $pw*0.60, $ph*0.34, $pw*0.70, $ph*0.26,
                                     $pw*0.70, $ph*0.44, $pw*0.80, $ph*0.36,
                                     -width => 1,
                                     -fill  => "#000000",
                                     -arrow => 'none',
                                     -tags  => "_sloped_line",
                                    );
        if ($wl_style =~ /Interpolate/i) {
            $wl_style = "Interpolate";
            $preview_levels->itemconfigure("_flat_line",   -fill => "#C9C9C9");
            $preview_levels->itemconfigure("_interp_line", -fill => &get_rgb_code($wl_color));
            $preview_levels->itemconfigure("_sloped_line", -fill => "#C9C9C9");
            $preview_levels->raise("_interp_line", "_sloped_line");
        } elsif ($wl_style =~ /Branch slope/i) {
            $wl_style = "Branch slope";
            $preview_levels->itemconfigure("_flat_line",   -fill => "#C9C9C9");
            $preview_levels->itemconfigure("_interp_line", -fill => "#C9C9C9");
            $preview_levels->itemconfigure("_sloped_line", -fill => &get_rgb_code($wl_color));
        } else {
            $wl_style = "Flat surface";
            $preview_levels->itemconfigure("_flat_line",   -fill => &get_rgb_code($wl_color));
            $preview_levels->itemconfigure("_interp_line", -fill => "#C9C9C9");
            $preview_levels->itemconfigure("_sloped_line", -fill => "#C9C9C9");
            $preview_levels->raise("_flat_line", "_sloped_line");
        }

        ($wlevel_frame = $wlevel_tab->new_frame(
                -borderwidth => 1,
                -relief      => 'groove',
                ))->g_grid(-row => 1, -column => 0, -sticky => 'wnes');

        $row = 0;
        $wlevel_frame->new_label(
                -text => "Level Line Style: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($wlstyle_cb = $wlevel_frame->new_ttk__combobox(
                -textvariable => \$wl_style,
                -values       => [("Flat surface", "Interpolate", "Branch slope")],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $wlstyle_cb->g_bind("<<ComboboxSelected>>",
                sub { my ($above_id);
                      return if ($wl_style eq $old_wl_style);
                      if ($wl_style =~ /Interpolate/i) {
                          $wl_style = "Interpolate";
                          $preview_levels->itemconfigure("_flat_line",   -fill => "#C9C9C9");
                          $preview_levels->itemconfigure("_interp_line", -fill => &get_rgb_code($wl_color));
                          $preview_levels->itemconfigure("_sloped_line", -fill => "#C9C9C9");
                          while (($above_id = $preview_levels->find_above("_interp_line")) ne "") {
                              $preview_levels->raise("_interp_line", $above_id);
                          }
                      } elsif ($wl_style =~ /Branch slope/i) {
                          $wl_style = "Branch slope";
                          $preview_levels->itemconfigure("_flat_line",   -fill => "#C9C9C9");
                          $preview_levels->itemconfigure("_interp_line", -fill => "#C9C9C9");
                          $preview_levels->itemconfigure("_sloped_line", -fill => &get_rgb_code($wl_color));
                          while (($above_id = $preview_levels->find_above("_sloped_line")) ne "") {
                              $preview_levels->raise("_sloped_line", $above_id);
                          }
                      } else {
                          $wl_style = "Flat surface";
                          $preview_levels->itemconfigure("_flat_line",   -fill => &get_rgb_code($wl_color));
                          $preview_levels->itemconfigure("_interp_line", -fill => "#C9C9C9");
                          $preview_levels->itemconfigure("_sloped_line", -fill => "#C9C9C9");
                          while (($above_id = $preview_levels->find_above("_flat_line")) ne "") {
                              $preview_levels->raise("_flat_line", $above_id);
                          }
                      }
                      $old_wl_style = $wl_style;
                    });

        $row++;
        $wlevel_frame->new_label(
                -text => "Level Line Color: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);

        $code     = &get_rgb_code($wl_color);
        $wl_color = &get_rgb_name($code);
        $fg       = &get_rgb_code("White");
        if ($code =~ /^\#[0-9a-f]/i) {
            $fg = &get_rgb_code(&get_bw_contrast($code));
        }
        ($wlcolor_btn = $wlevel_frame->new_button(
                -textvariable => \$wl_color,
                -background   => $code,
                -foreground   => $fg,
                -width        => -7,
                -command => sub { my ($newc);
                                  $code = &get_rgb_code($wl_color);
                                  $newc = Tkx::tk___chooseColor(
                                             -initialcolor => $code,
                                             -parent       => $graph_props_menu);
                                  if ($newc) {
                                      $code     = &get_rgb_code($newc);
                                      $wl_color = &get_rgb_name($code);
                                      $fg       = &get_rgb_code("black");
                                      if ($code =~ /^#?[0-9a-f]/i) {
                                          $fg = &get_rgb_code(&get_bw_contrast($code));
                                      }
                                      $wlcolor_btn->configure(-foreground => $fg,
                                                              -background => $code);
                                      if ($wl_style =~ /Interpolate/i) {
                                          $preview_levels->itemconfigure("_interp_line",
                                                              -fill => &get_rgb_code($wl_color));
                                      } elsif ($wl_style =~ /Branch slope/i) {
                                          $preview_levels->itemconfigure("_sloped_line",
                                                              -fill => &get_rgb_code($wl_color));
                                      } else {
                                          $preview_levels->itemconfigure("_flat_line",
                                                              -fill => &get_rgb_code($wl_color));
                                      }
                                  }
                                }
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

        $row++;
        $wlevel_frame->new_label(
                -text => "Show Grid Layers: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $wlevel_frame->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "",
                -font     => 'default',
                -variable => \$wl_grid,
                -command  => sub { my $status = ($wl_grid) ? 'normal' : 'disabled';
                                   $wl_gridc_btn->configure(-state => $status);
                                 },
                )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

        $row++;
        $wlevel_frame->new_label(
                -text => "Grid Line Color: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);

        $code     = &get_rgb_code($wl_gridc);
        $wl_gridc = &get_rgb_name($code);
        $fg       = &get_rgb_code("black");
        if ($code =~ /^\#[0-9a-f]/i) {
            $fg = &get_rgb_code(&get_bw_contrast($code));
        }
        ($wl_gridc_btn = $wlevel_frame->new_button(
                -textvariable => \$wl_gridc,
                -background   => $code,
                -foreground   => $fg,
                -width        => -7,
                -command => sub { my ($newc);
                                  $code = &get_rgb_code($wl_gridc);
                                  $newc = Tkx::tk___chooseColor(
                                             -initialcolor => $code,
                                             -parent       => $graph_props_menu);
                                  if ($newc) {
                                      $code     = &get_rgb_code($newc);
                                      $wl_gridc = &get_rgb_name($code);
                                      $fg       = &get_rgb_code("black");
                                      if ($code =~ /^#?[0-9a-f]/i) {
                                          $fg = &get_rgb_code(&get_bw_contrast($code));
                                      }
                                      $wl_gridc_btn->configure(-foreground => $fg,
                                                               -background => $code);
                                  }
                                }
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        if (! $wl_grid) {
            $wl_gridc_btn->configure(-state => 'disabled');
        }

        $wlevel_frame->g_grid_columnconfigure(0, -weight => 2);
    }

#   Color key tabs
    if (defined($gr_props{$id}{add_cs})) {
        $scheme1     = $gr_props{$id}{cscheme1};
        $scheme2     = $gr_props{$id}{cscheme2};
        $ncolors     = $gr_props{$id}{ncolors};
        $cs_rev      = $gr_props{$id}{cs_rev};
        $cs_min      = $gr_props{$id}{cs_min};
        $cs_max      = $gr_props{$id}{cs_max};
        $cs_major    = $gr_props{$id}{cs_major};
        $cs_width    = $gr_props{$id}{cs_width};
        $cs_height   = $gr_props{$id}{cs_height};
        @colors      = @{ $gr_props{$id}{colors} };
        $reverse_opt = ("no", "yes")[$cs_rev];

        $keyfont     = $gr_props{$id}{keyfont};
        $keytitle    = $gr_props{$id}{keytitle};
        $kt_size     = $gr_props{$id}{kt_size};
        $kt_weight   = $gr_props{$id}{kt_weight};
        $kn_size     = $gr_props{$id}{kn_size};
        $kn_weight   = $gr_props{$id}{kn_weight};
        $kn_digits   = $gr_props{$id}{kn_digits};

        $cs_link     = $gr_props{$id}{cs_link};
        @cslink_opts = ("No links", "Linked, same source", "Linked, same parameter");
        $cslink_opt  = $cslink_opts[$cs_link];

        if (&list_match($scheme1, @full_color_schemes) >= 0) {
            $ncolors = &max($valid_nc_alt[0], &min($ncolors, $valid_nc_alt[$#valid_nc_alt]));
            $scheme2 = "None";
        } else {
            $ncolors = &max($valid_nc[0], &min($ncolors, $valid_nc[$#valid_nc]));
            if (&list_match($ncolors, @valid_nc) == -1) {
                for ($i=0; $i<$#valid_nc; $i++) {
                    if ($ncolors > $valid_nc[$i] && $ncolors < $valid_nc[$i+1]) {
                        if (abs($ncolors -$valid_nc[$i]) <=
                            abs($ncolors -$valid_nc[$i+1])) {
                            $ncolors = $valid_nc[$i];
                        } else {
                            $ncolors = $valid_nc[$i+1];
                        }
                        last;
                    }
                }
            }
        }

        $fmt_w = length(int(abs($cs_max)));
        $fmt_w++ if ($cs_max < 0);
        if ($kn_digits > 0) {
            $fmt_w += $kn_digits +1;
            $fmt = "%${fmt_w}.${kn_digits}f";
        } else {
            $fmt = "%${fmt_w}d";
        }

        if ($props{$id}{meta} =~ /^(data_profile|w2_profile|w2_profile_matrix|w2_outflow|vert_wd_zone)$/) {
            $cs_status   = $gr_props{$id}{add_cs};
            $cs_status   = 2 if ($cs_status > 0 && $gr_props{$id}{cs_hide});
            $cstatus_opt = ("Inactive", "Key visible", "Key hidden")[$cs_status];

        } elsif ($props{$id}{meta} =~ /data_profile_cmap|w2_profile_cmap|w2_slice|w2_tdmap/) {
            $cs_status   = $gr_props{$id}{cs_hide};
            $cstatus_opt = ("Key visible", "Key hidden")[$cs_status];
        }

        $scheme_tab = $grprops_notebook->new_frame();
        $grprops_notebook->add($scheme_tab,
                -text      => "Color Key",
                -underline => 0,
                -sticky    => 'nsew',
                );

        $preview_scheme = $scheme_tab->new_canvas(
                -background  => &get_rgb_code($canvas_color),
                -width       => $pw,
                -height      => $ph,
                -borderwidth => 1,
                -relief      => 'groove',
                );
        $preview_scheme->g_grid(-row => 0, -column => 0, -sticky => 'wne');

        for ($i=0; $i<=$#colors; $i++) {
            $x1 = $pw*(0.05 + 0.9* $i   /($#colors+1));
            $x2 = $pw*(0.05 + 0.9*($i+1)/($#colors+1));
            $preview_scheme->create_rectangle($x1 +3, $ph*0.2 +3, $x2 +3, $ph*0.8 +3,
                                -outline => "",
                                -width   => 0,
                                -fill    => $colors[$i],
                                );
        }

        $scheme_frame = $scheme_tab->new_frame(
                -borderwidth => 1,
                -relief      => 'groove',
                );
        $scheme_frame->g_grid(-row => 1, -column => 0, -sticky => 'wnes');

        $row = 0;
        $scheme_frame->new_label(
                -text => "Status: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        if ($props{$id}{meta} =~ /^(data_profile|w2_profile|w2_profile_matrix|w2_outflow|vert_wd_zone)$/) {
            ($cstatus_cb = $scheme_frame->new_ttk__combobox(
                    -textvariable => \$cstatus_opt,
                    -values       => [("Key visible", "Key hidden", "Inactive")],
                    -state        => 'readonly',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2,
                               -sticky => 'ew', -pady => 2);
            $cstatus_cb->g_bind("<<ComboboxSelected>>",
                      sub { my $s = &list_match($cstatus_opt, ("Inactive", "Key visible", "Key hidden"));
                            return if ($s < 0);
                            $cs_status = $s;
                            if ($props{$id}{meta} =~ /^(w2_profile|w2_profile_matrix|w2_outflow)$/) {
                                &color_profile_menu($preview_profile, $pw, $ph,
                                                    $cstatus_opt, $pc_style, @colors);
                                $pc_style_cb->configure(-state => ($cs_status == 0) ? 'disabled':'readonly');
                            }
                          });
        } elsif ($props{$id}{meta} =~ /data_profile_cmap|w2_profile_cmap|w2_slice|w2_tdmap/) {
            ($cstatus_cb = $scheme_frame->new_ttk__combobox(
                    -textvariable => \$cstatus_opt,
                    -values       => [("Key visible", "Key hidden")],
                    -state        => 'readonly',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2,
                               -sticky => 'ew', -pady => 2);
            $cstatus_cb->g_bind("<<ComboboxSelected>>",
                      sub { my $s = &list_match($cstatus_opt, ("Key visible", "Key hidden"));
                            return if ($s < 0);
                            $cs_status = $s;
                          });
        }

        $row++;
        $scheme_frame->new_label(
                -text => "Links: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($cslink_cb = $scheme_frame->new_ttk__combobox(
                -textvariable => \$cslink_opt,
                -values       => [ @cslink_opts ],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2,
                           -sticky => 'ew', -pady => 2);
        $cslink_cb->g_bind("<<ComboboxSelected>>",
                  sub { my $s = &list_match($cslink_opt, @cslink_opts);
                        return if ($s < 0);
                        $cs_link = $s;
                      });

        $row++;
        $scheme_frame->new_label(
                -text => "Color Scheme 1: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($scheme1_cb = $scheme_frame->new_ttk__combobox(
                -textvariable => \$scheme1,
                -values       => [ @color_scheme_names ],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
        $scheme1_cb->g_bind("<<ComboboxSelected>>",
                  sub { my ($i, $x1, $x2, @colors);
                        if (&list_match($scheme1, @color_scheme_names) == -1) {
                            &pop_up_error($main, "Color scheme $scheme1 not found.");
                            return;
                        }
                        $preview_scheme->delete("all");
                        if (&list_match($scheme1, @full_color_schemes) >= 0) {
                            $scheme2 = "None";
                            $scheme2_cb->configure(-state  => 'disabled');
                            $ncolors_cb->configure(-values => [ @valid_nc_alt ]);
                        } else {
                            $scheme2_cb->configure(-state  => 'readonly');
                            $ncolors_cb->configure(-values => [ @valid_nc ]);
                            $ncolors = &max($valid_nc[0], &min($ncolors, $valid_nc[$#valid_nc]));
                            if (&list_match($ncolors, @valid_nc) == -1) {
                                for ($i=0; $i<$#valid_nc; $i++) {
                                    if ($ncolors > $valid_nc[$i] && $ncolors < $valid_nc[$i+1]) {
                                        if (abs($ncolors -$valid_nc[$i]) <=
                                            abs($ncolors -$valid_nc[$i+1])) {
                                            $ncolors = $valid_nc[$i];
                                        } else {
                                            $ncolors = $valid_nc[$i+1];
                                        }
                                        last;
                                    }
                                }
                            }
                        }
                        @colors = &make_color_scheme($ncolors, $cs_rev, $scheme1, $scheme2);
                        for ($i=0; $i<=$#colors; $i++) {
                            $x1 = $pw*(0.05 + 0.9* $i   /($#colors+1));
                            $x2 = $pw*(0.05 + 0.9*($i+1)/($#colors+1));
                            $preview_scheme->create_rectangle($x1 +3, $ph*0.2 +3,
                                                              $x2 +3, $ph*0.8 +3,
                                                -outline => "",
                                                -width   => 0,
                                                -fill    => $colors[$i],
                                                );
                        }
                        if ($props{$id}{meta} =~ /w2_profile|w2_slice|w2_outflow/) {
                            &color_profile_menu($preview_profile, $pw, $ph,
                                                $cstatus_opt, $pc_style, @colors);
                        }
                      });
        $row++;
        $scheme_frame->new_label(
                -text => "Color Scheme 2: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($scheme2_cb = $scheme_frame->new_ttk__combobox(
                -textvariable => \$scheme2,
                -values       => [ @color_scheme_names2 ],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
        $scheme2_cb->g_bind("<<ComboboxSelected>>",
                  sub { my ($i, $x1, $x2, @colors);
                        if (&list_match($scheme2, @color_scheme_names2) == -1) {
                            &pop_up_error($main, "Color scheme $scheme2 not found.");
                            return;
                        }
                        $preview_scheme->delete("all");
                        @colors = &make_color_scheme($ncolors, $cs_rev, $scheme1, $scheme2);
                        for ($i=0; $i<=$#colors; $i++) {
                            $x1 = $pw*(0.05 + 0.9* $i   /($#colors+1));
                            $x2 = $pw*(0.05 + 0.9*($i+1)/($#colors+1));
                            $preview_scheme->create_rectangle($x1 +3, $ph*0.2 +3,
                                                              $x2 +3, $ph*0.8 +3,
                                                -outline => "",
                                                -width   => 0,
                                                -fill    => $colors[$i],
                                                );
                        }
                        if ($props{$id}{meta} =~ /w2_profile|w2_slice|w2_outflow/) {
                            &color_profile_menu($preview_profile, $pw, $ph,
                                                $cstatus_opt, $pc_style, @colors);
                        }
                      });

        $row++;
        $scheme_frame->new_label(
                -text => "Steps per Scheme: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($ncolors_cb = $scheme_frame->new_ttk__combobox(
                -textvariable => \$ncolors,
                -values       => [ @valid_nc ],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
        $ncolors_cb->g_bind("<<ComboboxSelected>>",
                  sub { my ($i, $x1, $x2, @colors);
                        $preview_scheme->delete("all");
                        @colors = &make_color_scheme($ncolors, $cs_rev, $scheme1, $scheme2);
                        for ($i=0; $i<=$#colors; $i++) {
                            $x1 = $pw*(0.05 + 0.9* $i   /($#colors+1));
                            $x2 = $pw*(0.05 + 0.9*($i+1)/($#colors+1));
                            $preview_scheme->create_rectangle($x1 +3, $ph*0.2 +3,
                                                              $x2 +3, $ph*0.8 +3,
                                                -outline => "",
                                                -width   => 0,
                                                -fill    => $colors[$i],
                                                );
                        }
                        if ($props{$id}{meta} =~ /w2_profile|w2_slice|w2_outflow/) {
                            &color_profile_menu($preview_profile, $pw, $ph,
                                                $cstatus_opt, $pc_style, @colors);
                        }
                      });

        if (&list_match($scheme1, @full_color_schemes) >= 0) {
            $scheme2_cb->configure(-state  => 'disabled');
            $ncolors_cb->configure(-values => [ @valid_nc_alt ]);
        }

        $row++;
        $scheme_frame->new_label(
                -text => "Reverse Colors: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($reverse_cb = $scheme_frame->new_ttk__combobox(
                -textvariable => \$reverse_opt,
                -values       => [("no", "yes")],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
        $reverse_cb->g_bind("<<ComboboxSelected>>",
                  sub { my ($r, $i, $x1, $x2, @colors);
                        $r = &list_match($reverse_opt, ("no", "yes"));
                        return if ($r < 0);
                        $cs_rev = $r;
                        $preview_scheme->delete("all");
                        @colors = &make_color_scheme($ncolors, $cs_rev, $scheme1, $scheme2);
                        for ($i=0; $i<=$#colors; $i++) {
                            $x1 = $pw*(0.05 + 0.9* $i   /($#colors+1));
                            $x2 = $pw*(0.05 + 0.9*($i+1)/($#colors+1));
                            $preview_scheme->create_rectangle($x1 +3, $ph*0.2 +3,
                                                              $x2 +3, $ph*0.8 +3,
                                                -outline => "",
                                                -width   => 0,
                                                -fill    => $colors[$i],
                                                );
                        }
                        if ($props{$id}{meta} =~ /w2_profile|w2_slice|w2_outflow/) {
                            &color_profile_menu($preview_profile, $pw, $ph,
                                                $cstatus_opt, $pc_style, @colors);
                        }
                      });

        $row++;
        $scheme_frame->new_label(
                -text    => "Scale Minimum: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($csmin_entry = $scheme_frame->new_entry(
                -textvariable => \$cs_min,
                -font         => 'default',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
        $csmin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $csmin_entry ]);

        $row++;
        $scheme_frame->new_label(
                -text    => "Scale Maximum: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($csmax_entry = $scheme_frame->new_entry(
                -textvariable => \$cs_max,
                -font         => 'default',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
        $csmax_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $csmax_entry ]);

        $row++;
        $scheme_frame->new_label(
                -text    => "Scale Increment: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($csmajor_entry = $scheme_frame->new_entry(
                -textvariable => \$cs_major,
                -font         => 'default',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
        $csmajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($csmajor_entry, 1);
                                                     $cs_major =~ s/^-//;
                                                   });

        if ($props{$id}{meta} eq "vert_wd_zone"
                || ($props{$id}{meta} =~ /data_profile_cmap|w2_profile_cmap|w2_slice|w2_tdmap|w2_outflow/
                    && $props{$id}{parm} eq "Temperature")) {
            $row++;
            $scheme_frame->new_label(
                    -text => "Scale Units: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($wt_units_cb = $scheme_frame->new_ttk__combobox(
                    -textvariable => \$wt_units,
                    -values       => [ ("Celsius", "Fahrenheit") ],
                    -state        => 'readonly',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
            $wt_units_cb->g_bind("<<ComboboxSelected>>",
                                 sub { my ($diff);
                                       if (($props{$id}{meta} eq "data_profile_cmap"
                                             && $props{$id}{prof_type} eq "difference") ||
                                           ($props{$id}{meta} eq "w2_tdmap"
                                             && $props{$id}{map_type} =~ /^(parmdiff|filediff)$/)) {
                                           $diff = 0;
                                       } else {
                                           $diff = 32;
                                       }
                                       if ($wt_units eq "Celsius"
                                            && $wt_oldunits eq "Fahrenheit") {
                                           $keytitle =~ s/Fahrenheit/Celsius/;
                                           if ($cs_min ne "") {
                                               $cs_min = &floor(($cs_min -$diff) /1.8);
                                           }
                                           if ($cs_max ne "") {
                                               $cs_max = &ceil(($cs_max -$diff) /1.8);
                                           }
                                           if ($cs_major ne "" && $cs_major ne "." && $cs_major ne "auto") {
                                               $cs_major = sprintf("%.4f", $cs_major/1.8);
                                               $cs_major =~ s/0+$//;
                                           }
                                       } elsif ($wt_units eq "Fahrenheit"
                                            && $wt_oldunits eq "Celsius") {
                                           $keytitle =~ s/Celsius/Fahrenheit/;
                                           if ($cs_min ne "") {
                                               $cs_min = &floor($cs_min *1.8 +$diff);
                                           }
                                           if ($cs_max ne "") {
                                               $cs_max = &ceil($cs_max *1.8 +$diff);
                                           }
                                           if ($cs_major ne "" && $cs_major ne "." && $cs_major ne "auto") {
                                               $cs_major = sprintf("%.4f", $cs_major*1.8);
                                               $cs_major =~ s/0+$//;
                                           }
                                       }
                                       $wt_oldunits = $wt_units;
                                     });
        }

        $row++;
        $scheme_frame->new_label(
                -text    => "Cell Width: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $scheme_frame->new_spinbox(
                -textvariable => \$cs_width,
                -state        => 'readonly',
                -font         => 'default',
                -from         => 10,
                -to           => 35,
                -increment    => 1,
                -width        => 3,
                )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $scheme_frame->new_label(
                -text    => "pixels wide",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

        $row++;
        $scheme_frame->new_label(
                -text    => "Cell Height: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $scheme_frame->new_spinbox(
                -textvariable => \$cs_height,
                -state        => 'readonly',
                -font         => 'default',
                -from         =>  2,
                -to           => 30,
                -increment    => 1,
                -width        => 3,
                )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $scheme_frame->new_label(
                -text    => "pixels high",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);
        $scheme_frame->g_grid_columnconfigure(2, -weight => 1);

#       Color key text tab
        $keytxt_tab = $grprops_notebook->new_frame();
        $grprops_notebook->add($keytxt_tab,
                -text      => "Key Text",
                -underline => 0,
                -sticky    => 'nsew',
                );

        $preview_keytxt = $keytxt_tab->new_canvas(
                -background  => &get_rgb_code($canvas_color),
                -width       => $pw,
                -height      => $ph,
                -borderwidth => 1,
                -relief      => 'groove',
                );
        $preview_keytxt->g_grid(-row => 0, -column => 0, -sticky => 'wne');

        $keytitle_txt = $preview_keytxt->create_text($pw*0.3 +3, $ph*0.5 +3,
                -anchor => 'center', 
                -text   => "Key Title",
                -fill   => "#000000",
                -angle  => 0,
                -font   => [-family     => $keyfont,
                            -size       => $kt_size,
                            -weight     => $kt_weight,
                            -slant      => 'roman',
                            -underline  => 0,
                            -overstrike => 0,
                           ]);
        $keynum_txt = $preview_keytxt->create_text($pw*0.7 +3, $ph*0.5 +3,
                -anchor => 'center', 
                -text   => sprintf($fmt, $cs_max),
                -fill   => "#000000",
                -angle  => 0,
                -font   => [-family     => $keyfont,
                            -size       => $kn_size,
                            -weight     => $kn_weight,
                            -slant      => 'roman',
                            -underline  => 0,
                            -overstrike => 0,
                           ]);

        $keytxt_frame = $keytxt_tab->new_frame(
                -borderwidth => 1,
                -relief      => 'groove',
                );
        $keytxt_frame->g_grid(-row => 1, -column => 0, -sticky => 'wnes');

        $row = 0;
        $keytxt_frame->new_label(
                -text => "Color Key Font: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($keyfont_cb = $keytxt_frame->new_ttk__combobox(
                -textvariable => \$keyfont,
                -values       => [ sort @available_fonts ],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $keyfont_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_keytxt->itemconfigure($keytitle_txt,
                              -font => [ -family     => $keyfont,
                                         -size       => $kt_size,
                                         -weight     => $kt_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                        $preview_keytxt->itemconfigure($keynum_txt,
                              -font => [ -family     => $keyfont,
                                         -size       => $kn_size,
                                         -weight     => $kn_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });
        $row++;
        $keytxt_frame->new_label(
                -text => "Key Title Size: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($kt_size_cb = $keytxt_frame->new_ttk__combobox(
                -textvariable => \$kt_size,
                -values       => [(5 .. 24)],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $kt_size_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_keytxt->itemconfigure($keytitle_txt,
                              -font => [ -family     => $keyfont,
                                         -size       => $kt_size,
                                         -weight     => $kt_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });
        $row++;
        $keytxt_frame->new_label(
                -text => "Key Title Weight: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($kt_weight_cb = $keytxt_frame->new_ttk__combobox(
                -textvariable => \$kt_weight,
                -values       => [("normal", "bold")],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $kt_weight_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_keytxt->itemconfigure($keytitle_txt,
                              -font => [ -family     => $keyfont,
                                         -size       => $kt_size,
                                         -weight     => $kt_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });
        $row++;
        $keytxt_frame->new_label(
                -text => "Key Scale Size: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($kn_size_cb = $keytxt_frame->new_ttk__combobox(
                -textvariable => \$kn_size,
                -values       => [(5 .. 24)],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $kn_size_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_keytxt->itemconfigure($keynum_txt,
                              -font => [ -family     => $keyfont,
                                         -size       => $kn_size,
                                         -weight     => $kn_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });
        $row++;
        $keytxt_frame->new_label(
                -text => "Key Scale Weight: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($kn_weight_cb = $keytxt_frame->new_ttk__combobox(
                -textvariable => \$kn_weight,
                -values       => [("normal", "bold")],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $kn_weight_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_keytxt->itemconfigure($keynum_txt,
                              -font => [ -family     => $keyfont,
                                         -size       => $kn_size,
                                         -weight     => $kn_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });
        $row++;
        $keytxt_frame->new_label(
                -text    => "Decimal Digits: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $keytxt_frame->new_spinbox(
                -textvariable => \$kn_digits,
                -state        => 'readonly',
                -font         => 'default',
                -from         => 0,
                -to           => 6,
                -increment    => 1,
                -width        => 3,
                -command      => sub { my ($fmt_w, $fmt);
                                       $fmt_w = length(int(abs($cs_max)));
                                       $fmt_w++ if ($cs_max < 0);
                                       if ($kn_digits > 0) {
                                           $fmt_w += $kn_digits +1;
                                           $fmt = "%${fmt_w}.${kn_digits}f";
                                       } else {
                                           $fmt = "%${fmt_w}d";
                                       }
                                       $preview_keytxt->itemconfigure($keynum_txt,
                                               -text => sprintf($fmt, $cs_max));
                                     },
                )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $row++;
        $keytxt_frame->new_label(
                -text    => "Color Key Title: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'w', -pady => 2);
        $row++;
        $keytxt_frame->new_entry(
                -textvariable => \$keytitle,
                -font         => 'default',
                )->g_grid(-row => $row, -column => 0, -columnspan => 2, -sticky => 'ew', -pady => 2);

        $keytxt_frame->g_grid_columnconfigure(0, -weight => 2);
    }

#   Profile tab. For W2 profile, W2 profile colormap, W2 slice, and W2 outflow graphs.
    if (defined($gr_props{$id}{add_cs}) && $props{$id}{meta} =~ /w2_profile|w2_slice|w2_outflow/) {
        if ($props{$id}{meta} =~ /^(w2_profile|w2_profile_matrix)$/) {
            $pr_style = $gr_props{$id}{pr_style};
            $pr_linec = $gr_props{$id}{pr_linec};
            $pr_linew = $gr_props{$id}{pr_linew};
            $pc_style = $gr_props{$id}{pc_style};
        } else {
            $pc_style = $gr_props{$id}{pc_style};
            $pr_style = ($pc_style =~ /by layer/i) ? "Stairstep" : "Interpolated";
            $pr_linec = "black";
            $pr_linew = 1;
        }

        $profile_tab = $grprops_notebook->new_frame();
        $grprops_notebook->add($profile_tab,
                -text      => "Profile",
                -underline => 0,
                -sticky    => 'nsew',
                );

#       Preview area
        $preview_profile = $profile_tab->new_canvas(
                -background  => &get_rgb_code($canvas_color),
                -width       => $pw,
                -height      => $ph *3,
                -borderwidth => 1,
                -relief      => 'groove',
                );
        $preview_profile->g_grid(-row => 0, -column => 0, -sticky => 'wne');

#       Layer boundary lines
        for ($i=0; $i<=9; $i++) {
            $preview_profile->create_line($pw*0.1 +3, $ph*($i*0.3+0.15) +3,
                                          $pw*0.9 +3, $ph*($i*0.3+0.15) +3,
                                -width => 1,
                                -fill  => '#C0C0C0',
                                -arrow => 'none',
                                -tags  => "pr_grid");
        }

#       Sample color profile, using current color scheme.
#       This is a subroutine so that actions affecting the color scheme can modify the sample profile.
        &color_profile_menu($preview_profile, $pw, $ph, $cstatus_opt, $pc_style, @colors);

#       A sample profile
        $preview_profile->create_line($pw*0.75 +3, $ph*0.15 +3, $pw*0.75 +3, $ph*0.45 +3,
                                      $pw*0.74 +3, $ph*0.45 +3, $pw*0.74 +3, $ph*0.75 +3,
                                      $pw*0.70 +3, $ph*0.75 +3, $pw*0.70 +3, $ph*1.05 +3,
                                      $pw*0.65 +3, $ph*1.05 +3, $pw*0.65 +3, $ph*1.35 +3,
                                      $pw*0.55 +3, $ph*1.35 +3, $pw*0.55 +3, $ph*1.65 +3,
                                      $pw*0.42 +3, $ph*1.65 +3, $pw*0.42 +3, $ph*1.95 +3,
                                      $pw*0.32 +3, $ph*1.95 +3, $pw*0.32 +3, $ph*2.25 +3,
                                      $pw*0.27 +3, $ph*2.25 +3, $pw*0.27 +3, $ph*2.55 +3,
                                      $pw*0.25 +3, $ph*2.55 +3, $pw*0.25 +3, $ph*2.85 +3,
                            -width => $pr_linew,
                            -fill  => &get_rgb_code($pr_linec),
                            -arrow => 'none',
                            -tags  => "pr_stairs",
                            -state => ($pr_style =~ /stairstep/i) ? 'normal' : 'hidden');
        $preview_profile->create_line($pw*0.75 +3, $ph*0.15 +3, $pw*0.75 +3, $ph*0.30 +3,
                                      $pw*0.74 +3, $ph*0.60 +3,
                                      $pw*0.70 +3, $ph*0.90 +3,
                                      $pw*0.65 +3, $ph*1.20 +3,
                                      $pw*0.55 +3, $ph*1.50 +3,
                                      $pw*0.42 +3, $ph*1.80 +3,
                                      $pw*0.32 +3, $ph*2.10 +3,
                                      $pw*0.27 +3, $ph*2.40 +3,
                                      $pw*0.25 +3, $ph*2.70 +3, $pw*0.25 +3, $ph*2.85 +3,
                            -width => $pr_linew,
                            -fill  => &get_rgb_code($pr_linec),
                            -arrow => 'none',
                            -tags  => "pr_interp",
                            -state => ($pr_style =~ /interp/i) ? 'normal' : 'hidden');

        $profile_frame = $profile_tab->new_frame(
                -borderwidth => 1,
                -relief      => 'groove',
                );
        $profile_frame->g_grid(-row => 1, -column => 0, -sticky => 'wnes');

        $row = 0;
        $profile_frame->new_label(
                -text => "Color Scheme Style: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($pc_style_cb = $profile_frame->new_ttk__combobox(
                -textvariable => \$pc_style,
                -values       => [("By Layer", "Interpolated", "Max Interpolated")],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
        $pc_style_cb->g_bind("<<ComboboxSelected>>",
                  sub { if ($cstatus_opt =~ /inactive/i) {
                            $preview_profile->itemconfigure('pc_layers',    -state => 'hidden');
                            $preview_profile->itemconfigure('pc_interp',    -state => 'hidden');
                            $preview_profile->itemconfigure('pc_maxinterp', -state => 'hidden');
                        } elsif ($pc_style =~ /by layer/i) {
                            $preview_profile->itemconfigure('pc_layers',    -state => 'normal');
                            $preview_profile->itemconfigure('pc_interp',    -state => 'hidden');
                            $preview_profile->itemconfigure('pc_maxinterp', -state => 'hidden');
                        } elsif ($pc_style =~ /max interp/i) {
                            $preview_profile->itemconfigure('pc_layers',    -state => 'hidden');
                            $preview_profile->itemconfigure('pc_interp',    -state => 'hidden');
                            $preview_profile->itemconfigure('pc_maxinterp', -state => 'normal');
                        } else {
                            $preview_profile->itemconfigure('pc_layers',    -state => 'hidden');
                            $preview_profile->itemconfigure('pc_interp',    -state => 'normal');
                            $preview_profile->itemconfigure('pc_maxinterp', -state => 'hidden');
                        }
                        if ($props{$id}{meta} =~ /w2_profile_cmap|w2_slice|w2_outflow/) {
                            $pr_style = ($pc_style =~ /by layer/i) ? "Stairstep" : "Interpolated";
                            if ($cstatus_opt =~ /inactive/i) {
                                $preview_profile->itemconfigure("pr_stairs", -state => 'hidden');
                                $preview_profile->itemconfigure("pr_interp", -state => 'hidden');
                            } elsif ($pc_style =~ /by layer/i) {
                                $preview_profile->itemconfigure("pr_stairs", -state => 'normal');
                                $preview_profile->itemconfigure("pr_interp", -state => 'hidden');
                            } else {
                                $preview_profile->itemconfigure("pr_stairs", -state => 'hidden');
                                $preview_profile->itemconfigure("pr_interp", -state => 'normal');
                            }
                        }
                      });
        if (! defined($gr_props{$id}{add_cs}) || ! $gr_props{$id}{add_cs}) {
            $pc_style_cb->configure(-state => 'disabled');
        }

        if ($props{$id}{meta} =~ /^(w2_profile|w2_profile_matrix)$/) {
            $row++;
            $profile_frame->new_label(
                    -text => "Model Line Style: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($pr_style_cb = $profile_frame->new_ttk__combobox(
                    -textvariable => \$pr_style,
                    -values       => [("Stairstep", "Interpolated")],
                    -state        => 'readonly',
                    ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
            $pr_style_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($pr_style =~ /stairstep/i) {
                                $preview_profile->itemconfigure("pr_stairs", -state => 'normal');
                                $preview_profile->itemconfigure("pr_interp", -state => 'hidden');
                            } else {
                                $preview_profile->itemconfigure("pr_stairs", -state => 'hidden');
                                $preview_profile->itemconfigure("pr_interp", -state => 'normal');
                            }
                          });

            $row++;
            $profile_frame->new_label(
                    -text => "Model Line Color: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            $code     = &get_rgb_code($pr_linec);
            $pr_linec = &get_rgb_name($code);
            $fg       = &get_rgb_code("black");
            if ($code =~ /^\#[0-9a-f]/i) {
                $fg = &get_rgb_code(&get_bw_contrast($code));
            }
            ($pr_linec_btn = $profile_frame->new_button(
                    -textvariable => \$pr_linec,
                    -background   => $code,
                    -foreground   => $fg,
                    -width        => -7,
                    -command => sub { my ($newc, $code, $fg);
                                      $code = &get_rgb_code($pr_linec);
                                      $newc = Tkx::tk___chooseColor(
                                                 -initialcolor => $code,
                                                 -parent       => $graph_props_menu);
                                      if ($newc) {
                                          $code     = &get_rgb_code($newc);
                                          $pr_linec = &get_rgb_name($code);
                                          $fg       = &get_rgb_code("black");
                                          if ($code =~ /^#?[0-9a-f]/i) {
                                              $fg = &get_rgb_code(&get_bw_contrast($code));
                                          }
                                          $pr_linec_btn->configure(-foreground => $fg,
                                                                   -background => $code);
                                          $preview_profile->itemconfigure("pr_stairs", -fill => $code);
                                          $preview_profile->itemconfigure("pr_interp", -fill => $code);
                                      }
                                    }
                    ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

            $row++;
            $profile_frame->new_label(
                    -text => "Model Line Width: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            $profile_frame->new_spinbox(
                    -textvariable => \$pr_linew,
                    -state        => 'readonly',
                    -font         => 'default',
                    -from         => 1,
                    -to           => 2,
                    -increment    => 1,
                    -width        => 3,
                    -command      => sub { $preview_profile->itemconfigure("pr_stairs", -width => $pr_linew);
                                           $preview_profile->itemconfigure("pr_interp", -width => $pr_linew);
                                         },
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

            if (defined($props{$id}{ref_file}) && ! $props{$id}{ref_hide}) {
                @ref_pts = ($pw*0.72+3, $ph*0.3+3,
                            $pw*0.72+3, $ph*0.6+3,
                            $pw*0.71+3, $ph*0.9+3,
                            $pw*0.69+3, $ph*1.2+3,
                            $pw*0.59+3, $ph*1.5+3,
                            $pw*0.48+3, $ph*1.8+3,
                            $pw*0.29+3, $ph*2.1+3,
                            $pw*0.24+3, $ph*2.4+3,
                            $pw*0.22+3, $ph*2.7+3);

                $preview_profile->create_line(@ref_pts,
                                    -width => $ref_linew,
                                    -fill  => &get_rgb_code($ref_color),
                                    -arrow => 'none',
                                    -tags  => "ref_profile");
                $pix = ($ref_size eq "Small") ? 2 : ($ref_size eq "Large") ? 4 : 3;
                for ($n=0; $n<=$#ref_pts; $n+=2) {
                    $xp = $ref_pts[$n];
                    $yp = $ref_pts[$n+1];
                    $preview_profile->create_oval($xp-$pix, $yp-$pix, $xp+$pix, $yp+$pix,
                                        -outline => &get_rgb_code($ref_color),
                                        -width   => 1,
                                        -fill    => &get_rgb_code("white"),
                                        -tags    => "ref_pts" . $n);
                }

                $row++;
                $old_ref_size = $ref_size;
                $profile_frame->new_label(
                        -text => "Ref. Dot Size: ",
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
                ($ref_size_cb = $profile_frame->new_ttk__combobox(
                        -textvariable => \$ref_size,
                        -values       => [("Small", "Medium", "Large", "Extra Large")],
                        -state        => 'readonly',
                        ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
                $ref_size_cb->g_bind("<<ComboboxSelected>>",
                                      sub { return if ($ref_size eq $old_ref_size);
                                            if ($ref_size eq "Small") {
                                                $pix = 2;
                                            } elsif ($ref_size eq "Large") {
                                                $pix = 4;
                                            } elsif ($ref_size eq "Extra Large") {
                                                $pix = 5;
                                            } else {
                                                $pix = 3;
                                            }
                                            for ($n=0; $n<=$#ref_pts; $n+=2) {
                                                $xp = $ref_pts[$n];
                                                $yp = $ref_pts[$n+1];
                                                $preview_profile->coords("ref_pts" . $n,
                                                                    $xp-$pix, $yp-$pix, $xp+$pix, $yp+$pix);
                                            }
                                            $old_ref_size = $ref_size;
                                          });

                $row++;
                $profile_frame->new_label(
                        -text => "Ref. Line Color: ",
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
                $code      = &get_rgb_code($ref_color);
                $ref_color = &get_rgb_name($code);
                $fg        = &get_rgb_code("black");
                if ($code =~ /^\#[0-9a-f]/i) {
                    $fg = &get_rgb_code(&get_bw_contrast($code));
                }
                ($ref_color_btn = $profile_frame->new_button(
                        -textvariable => \$ref_color,
                        -background   => $code,
                        -foreground   => $fg,
                        -width        => -7,
                        -command => sub { my ($newc, $code, $fg);
                                          $code = &get_rgb_code($ref_color);
                                          $newc = Tkx::tk___chooseColor(
                                                     -initialcolor => $code,
                                                     -parent       => $graph_props_menu);
                                          if ($newc) {
                                              $code      = &get_rgb_code($newc);
                                              $ref_color = &get_rgb_name($code);
                                              $fg        = &get_rgb_code("black");
                                              if ($code =~ /^#?[0-9a-f]/i) {
                                                  $fg = &get_rgb_code(&get_bw_contrast($code));
                                              }
                                              $ref_color_btn->configure(-foreground => $fg,
                                                                        -background => $code);
                                              $preview_profile->itemconfigure("ref_profile", -fill => $code);
                                              for ($n=0; $n<=$#ref_pts; $n+=2) {
                                                  $preview_profile->itemconfigure("ref_pts" . $n,
                                                                                  -outline => $code);
                                            }
                                          }
                                        }
                        ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

                $row++;
                $profile_frame->new_label(
                        -text => "Ref. Line Width: ",
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
                $profile_frame->new_spinbox(
                        -textvariable => \$ref_linew,
                        -state        => 'readonly',
                        -font         => 'default',
                        -from         => 1,
                        -to           => 2,
                        -increment    => 1,
                        -width        => 3,
                        -command      => sub { $preview_profile->itemconfigure("ref_profile",
                                                                               -width => $ref_linew);
                                             },
                        )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
            }
        }

        $profile_frame->g_grid_columnconfigure(0, -weight => 2);

        if ($props{$id}{meta} eq "w2_slice") {
            if ($tabid == 6) {
                $grprops_notebook->tab($xaxis_tab, -text => "X");
            } else {
                $grprops_notebook->tab($profile_tab, -text => "Pr");
            }
            $grprops_notebook->tab($scheme_tab, -text => "ColorKey");
            $grprops_notebook->tab($keytxt_tab, -text => "KeyText");
            $grprops_notebook->g_bind("<<NotebookTabChanged>>",
                                      sub { my ($tabid);
                                            $tabid = $grprops_notebook->index('current');
                                            if ($tabid == 0) {
                                                $grprops_notebook->tab($xaxis_tab,   -text => "X Axis");
                                                $grprops_notebook->tab($profile_tab, -text => "Pr");
                                            } elsif ($tabid == 6) {
                                                $grprops_notebook->tab($xaxis_tab,   -text => "X");
                                                $grprops_notebook->tab($profile_tab, -text => "Profile");
                                            }
                                          });
        }
    }

#   Legend tab
    if ($props{$id}{meta} =~ /time_series/) {
        $legtitle  = $gr_props{$id}{legtitle};
        $legfont   = $gr_props{$id}{legfont};
        $lt_size   = $gr_props{$id}{lt_size};
        $lt_weight = $gr_props{$id}{lt_weight};
        $le_size   = $gr_props{$id}{le_size};
        $le_weight = $gr_props{$id}{le_weight};
        $le_edge   = $gr_props{$id}{le_edge};
        $le_edgec  = $gr_props{$id}{le_edgec};
        $le_fill   = $gr_props{$id}{le_fill};
        $le_fillc  = $gr_props{$id}{le_fillc};

        if ($props{$id}{meta} eq "linked_time_series") {
            $link_id  = $props{$id}{link_id};
            %parms    = %{ $props{$id}{ts_parms} };
            $ts_type  = $parms{ts_type};
            @ts_show  = @{ $parms{show}  };
            @ts_width = @{ $parms{width} };
            @ts_color = @{ $parms{color} };
            if ($ts_type eq "Water Surface Elevation") {
                $label_txt = "WS Elev";
                $pre_width = $ts_width[0];
                $pre_color = $ts_color[0];
            } elsif ($ts_type eq "Release Rate") {
                if ($props{$link_id}{meta} eq "vert_wd_zone") {
                    @names = @{ $gr_props{$link_id}{names} };
                    push (@names, "All Outlets");
                } elsif ($props{$link_id}{meta} eq "w2_outflow") {
                    @names = ("All Outlets");
                }
                $i = &max(0, &list_match("1", @ts_show));
                $label_txt = ($#names > 0) ? $names[$i] : $ts_type;
                $pre_width = $ts_width[$i];
                $pre_color = $ts_color[$i];
            } else {
                @names = @{ $gr_props{$link_id}{names} };
                push (@names, "All Outlets");
                $i = &max(0, &list_match("1", @ts_show));
                $label_txt = $names[$i];
                $pre_width = $ts_width[$i];
                $pre_color = $ts_color[$i];
            }
        } else {
            $label_txt = "legend entry";
            $pre_width = 1;
            $pre_color = "black";
        }

        $legend_tab = $grprops_notebook->new_frame();
        $grprops_notebook->add($legend_tab,
                -text      => "Legend",
                -underline => 0,
                -sticky    => 'nsew',
                );

        $preview_legend = $legend_tab->new_canvas(
                -background  => &get_rgb_code($canvas_color),
                -width       => $pw,
                -height      => $ph,
                -borderwidth => 1,
                -relief      => 'groove',
                );
        $preview_legend->g_grid(-row => 0, -column => 0, -sticky => 'wne');

        $legtitle_txt = $preview_legend->create_text($pw*0.25 +3, $ph*0.5 +3,
                -anchor => 'center', 
                -text   => "Title",
                -fill   => "#000000",
                -angle  => 0,
                -font   => [-family     => $legfont,
                            -size       => $lt_size,
                            -weight     => $lt_weight,
                            -slant      => 'roman',
                            -underline  => 0,
                            -overstrike => 0,
                           ]);
        $legend_line = $preview_legend->create_line($pw*0.6  -3, $ph*0.5 +3,
                                                    $pw*0.6 -23, $ph*0.5 +3,
                            -width => $pre_width,
                            -fill  => &get_rgb_code($pre_color),
                            -arrow => 'none');
        $legend_txt = $preview_legend->create_text($pw*0.6 +3, $ph*0.5 +3,
                -anchor => 'w', 
                -text   => $label_txt,
                -fill   => "#000000",
                -angle  => 0,
                -font   => [-family     => $legfont,
                            -size       => $le_size,
                            -weight     => $le_weight,
                            -slant      => 'roman',
                            -underline  => 0,
                            -overstrike => 0,
                           ]);

        @coords = Tkx::SplitList($preview_legend->bbox($legend_txt));
        $coords[0] -= 31;
        $coords[1] -=  4;
        $coords[2] +=  5;
        $coords[3] +=  4;
        if ($le_fill && $le_fillc ne "") {
            $legend_box = $preview_legend->create_rectangle(@coords,
                            -outline => "",
                            -width   => 0,
                            -fill    => &get_rgb_code($le_fillc));
        } else {
            $legend_box = $preview_legend->create_rectangle(@coords,
                            -outline => "",
                            -width   => 0,
                            -fill    => "");
        }
        if ($le_edge) {
            $preview_legend->itemconfigure($legend_box,
                            -width   => 1,
                            -outline => &get_rgb_code($le_edgec));
        }
        $preview_legend->lower($legend_box, $legend_line);

        $legend_frame = $legend_tab->new_frame(
                -borderwidth => 1,
                -relief      => 'groove',
                );
        $legend_frame->g_grid(-row => 1, -column => 0, -sticky => 'wnes');

        $row = 0;
        $legend_frame->new_label(
                -text => "Legend Font: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($legfont_cb = $legend_frame->new_ttk__combobox(
                -textvariable => \$legfont,
                -values       => [ sort @available_fonts ],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
        $legfont_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_legend->itemconfigure($legtitle_txt,
                              -font => [ -family     => $legfont,
                                         -size       => $lt_size,
                                         -weight     => $lt_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                        $preview_legend->itemconfigure($legend_txt,
                              -font => [ -family     => $legfont,
                                         -size       => $le_size,
                                         -weight     => $le_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                        if (defined($props{$id}{add_ts_parms})) {
                            if ($#add_ts_setnum >= 0) {
                                $preview_tsdata->itemconfigure($tsdata_txt,
                                      -font => [ -family     => $legfont,
                                                 -size       => $le_size,
                                                 -weight     => $le_weight,
                                                 -slant      => 'roman',
                                                 -underline  => 0,
                                                 -overstrike => 0,
                                               ]);
                                @coords = Tkx::SplitList($preview_tsdata->bbox($tsdata_txt));
                                $preview_tsdata->coords($tsdata_line,
                                                        $coords[0]  -6, $ph*0.5 +3,
                                                        $coords[0] -26, $ph*0.5 +3);
                            }
                        }
                        @coords = Tkx::SplitList($preview_legend->bbox($legend_txt));
                        $preview_legend->coords($legend_box,
                                                $coords[0] -31, $coords[1] -4,
                                                $coords[2] + 5, $coords[3] +4);
                      });
        $row++;
        $legend_frame->new_label(
                -text => "Title/Entry Size: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($lt_size_cb = $legend_frame->new_ttk__combobox(
                -textvariable => \$lt_size,
                -values       => [(5 .. 24)],
                -width        => 5,
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
        $lt_size_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_legend->itemconfigure($legtitle_txt,
                              -font => [ -family     => $legfont,
                                         -size       => $lt_size,
                                         -weight     => $lt_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });
        ($le_size_cb = $legend_frame->new_ttk__combobox(
                -textvariable => \$le_size,
                -values       => [(5 .. 24)],
                -width        => 5,
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 2, -sticky => 'ew', -pady => 2);
        $le_size_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_legend->itemconfigure($legend_txt,
                              -font => [ -family     => $legfont,
                                         -size       => $le_size,
                                         -weight     => $le_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                        if (defined($props{$id}{add_ts_parms})) {
                            if ($#add_ts_setnum >= 0) {
                                $preview_tsdata->itemconfigure($tsdata_txt,
                                      -font => [ -family     => $legfont,
                                                 -size       => $le_size,
                                                 -weight     => $le_weight,
                                                 -slant      => 'roman',
                                                 -underline  => 0,
                                                 -overstrike => 0,
                                               ]);
                                @coords = Tkx::SplitList($preview_tsdata->bbox($tsdata_txt));
                                $preview_tsdata->coords($tsdata_line,
                                                        $coords[0]  -6, $ph*0.5 +3,
                                                        $coords[0] -26, $ph*0.5 +3);
                            }
                        }
                        @coords = Tkx::SplitList($preview_legend->bbox($legend_txt));
                        $preview_legend->coords($legend_box,
                                                $coords[0] -31, $coords[1] -4,
                                                $coords[2] + 5, $coords[3] +4);
                      });

        $row++;
        $legend_frame->new_label(
                -text => "Title/Entry Weight: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($lt_weight_cb = $legend_frame->new_ttk__combobox(
                -textvariable => \$lt_weight,
                -values       => [("normal", "bold")],
                -width        => 5,
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
        $lt_weight_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_legend->itemconfigure($legtitle_txt,
                              -font => [ -family     => $legfont,
                                         -size       => $lt_size,
                                         -weight     => $lt_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });
        ($le_weight_cb = $legend_frame->new_ttk__combobox(
                -textvariable => \$le_weight,
                -values       => [("normal", "bold")],
                -width        => 5,
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 2, -sticky => 'ew', -pady => 2);
        $le_weight_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_legend->itemconfigure($legend_txt,
                              -font => [ -family     => $legfont,
                                         -size       => $le_size,
                                         -weight     => $le_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                        if (defined($props{$id}{add_ts_parms})) {
                            if ($#add_ts_setnum >= 0) {
                                $preview_tsdata->itemconfigure($tsdata_txt,
                                      -font => [ -family     => $legfont,
                                                 -size       => $le_size,
                                                 -weight     => $le_weight,
                                                 -slant      => 'roman',
                                                 -underline  => 0,
                                                 -overstrike => 0,
                                               ]);
                                @coords = Tkx::SplitList($preview_tsdata->bbox($tsdata_txt));
                                $preview_tsdata->coords($tsdata_line,
                                                        $coords[0]  -6, $ph*0.5 +3,
                                                        $coords[0] -26, $ph*0.5 +3);
                            }
                        }
                        @coords = Tkx::SplitList($preview_legend->bbox($legend_txt));
                        $preview_legend->coords($legend_box,
                                                $coords[0] -31, $coords[1] -4,
                                                $coords[2] + 5, $coords[3] +4);
                      });

        $row++;
        $legend_frame->new_label(
                -text => "Legend Box Outline: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $legend_frame->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "Show",
                -font     => 'default',
                -variable => \$le_edge,
                -command  => sub { if ($le_edge) {
                                       $le_edgec_btn->configure(-state => 'normal');
                                       $preview_legend->itemconfigure($legend_box, -width => 1,
                                                        -outline => &get_rgb_code($le_edgec));
                                   } else {
                                       $le_edgec_btn->configure(-state => 'disabled');
                                       $preview_legend->itemconfigure($legend_box,
                                                        -width => 0, -outline => "");
                                   }
                                 },
                )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

        $code     = &get_rgb_code($le_edgec);
        $le_edgec = &get_rgb_name($code);
        $fg       = &get_rgb_code("black");
        if ($code =~ /^\#[0-9a-f]/i) {
            $fg = &get_rgb_code(&get_bw_contrast($code));
        }
        ($le_edgec_btn = $legend_frame->new_button(
                -textvariable => \$le_edgec,
                -background   => $code,
                -foreground   => $fg,
                -width        => -7,
                -command => sub { my ($newc, $code, $fg);
                                  $code = &get_rgb_code($le_edgec);
                                  $newc = Tkx::tk___chooseColor(
                                             -initialcolor => $code,
                                             -parent       => $graph_props_menu);
                                  if ($newc) {
                                      $code     = &get_rgb_code($newc);
                                      $le_edgec = &get_rgb_name($code);
                                      $fg       = &get_rgb_code("black");
                                      if ($code =~ /^#?[0-9a-f]/i) {
                                          $fg = &get_rgb_code(&get_bw_contrast($code));
                                      }
                                      $le_edgec_btn->configure(-foreground => $fg,
                                                               -background => $code);
                                      $preview_legend->itemconfigure($legend_box, -outline => $code);
                                  }
                                }
                ))->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);
        if (! $le_edge) {
            $le_edgec_btn->configure(-state => 'disabled');
        }

        $row++;
        $legend_frame->new_label(
                -text => "Legend Box Fill: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $legend_frame->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "Show",
                -font     => 'default',
                -variable => \$le_fill,
                -command  => sub { if ($le_fill) {
                                       $le_fillc_btn->configure(-state => 'normal');
                                       $preview_legend->itemconfigure($legend_box,
                                                        -fill => &get_rgb_code($le_fillc));
                                   } else {
                                       $le_fillc_btn->configure(-state => 'disabled');
                                       $preview_legend->itemconfigure($legend_box, -fill => "");
                                   }
                                 },
                )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

        $code     = &get_rgb_code($le_fillc);
        $le_fillc = &get_rgb_name($code);
        $fg       = &get_rgb_code("black");
        if ($code =~ /^\#[0-9a-f]/i) {
            $fg = &get_rgb_code(&get_bw_contrast($code));
        }
        ($le_fillc_btn = $legend_frame->new_button(
                -textvariable => \$le_fillc,
                -background   => $code,
                -foreground   => $fg,
                -width        => -7,
                -command => sub { my ($newc, $code, $fg);
                                  $code = &get_rgb_code($le_fillc);
                                  $newc = Tkx::tk___chooseColor(
                                             -initialcolor => $code,
                                             -parent       => $graph_props_menu);
                                  if ($newc) {
                                      $code     = &get_rgb_code($newc);
                                      $le_fillc = &get_rgb_name($code);
                                      $fg       = &get_rgb_code("black");
                                      if ($code =~ /^#?[0-9a-f]/i) {
                                          $fg = &get_rgb_code(&get_bw_contrast($code));
                                      }
                                      $le_fillc_btn->configure(-foreground => $fg,
                                                               -background => $code);
                                      $preview_legend->itemconfigure($legend_box, -fill => $code);
                                  }
                                }
                ))->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);
        if (! $le_fill) {
            $le_fillc_btn->configure(-state => 'disabled');
        }

        if ($props{$id}{meta} eq "linked_time_series") {
            if ($ts_type eq "Water Surface Elevation" || ($ts_type eq "Release Rate" &&
                                                          $props{$link_id}{meta} eq "w2_outflow")) {
                $row++;
                $legend_frame->new_label(
                        -text => "Line Width: ",
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
                $legend_frame->new_spinbox(
                        -textvariable => \$ts_width[0],
                        -state        => 'readonly',
                        -font         => 'default',
                        -from         => 1,
                        -to           => 10,
                        -increment    => 1,
                        -width        => 3,
                        -command      => sub { $preview_legend->itemconfigure($legend_line,
                                                     -width => $ts_width[0]);
                                             }
                        )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

                $row++;
                $legend_frame->new_label(
                        -text => "Line Color: ",
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);

                $code        = &get_rgb_code($ts_color[0]);
                $ts_color[0] = &get_rgb_name($code);
                $fg          = &get_rgb_code("black");
                if ($code =~ /^\#[0-9a-f]/i) {
                    $fg = &get_rgb_code(&get_bw_contrast($code));
                }
                ($color_btn = $legend_frame->new_button(
                        -textvariable => \$ts_color[0],
                        -background   => $code,
                        -foreground   => $fg,
                        -width        => -7,
                        -command => sub { my ($newc, $code, $fg);
                                          $code = &get_rgb_code($ts_color[0]);
                                          $newc = Tkx::tk___chooseColor(
                                                     -initialcolor => $code,
                                                     -parent       => $graph_props_menu);
                                          if ($newc) {
                                              $code        = &get_rgb_code($newc);
                                              $ts_color[0] = &get_rgb_name($code);
                                              $fg          = &get_rgb_code("black");
                                              if ($code =~ /^#?[0-9a-f]/i) {
                                                  $fg = &get_rgb_code(&get_bw_contrast($code));
                                              }
                                              $color_btn->configure(-foreground => $fg,
                                                                    -background => $code);
                                              $preview_legend->itemconfigure($legend_line,
                                                                    -fill => $code);
                                          }
                                        }
                        ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

            } else {
                $row++;
                ($outlet_frame = $legend_frame->new_frame(
                        -borderwidth => 1,
                        -relief      => 'groove',
                        ))->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew', -pady => 2);

                $row2 = 0;
                $outlet_frame->new_label(
                        -text => "Outlet",
                        -font => 'default',
                        )->g_grid(-row => $row2, -column => 0, -sticky => 'ew', -pady => 2);
                $outlet_frame->new_label(
                        -text => "Width  ",
                        -font => 'default',
                        )->g_grid(-row => $row2, -column => 1, -sticky => 'ew', -pady => 2);
                $outlet_frame->new_label(
                        -text => "  Color  ",
                        -font => 'default',
                        )->g_grid(-row => $row2, -column => 2, -sticky => 'ew', -pady => 2);
        
                for ($n=0; $n<=$#names; $n++) {
                    $row2++;
                    $outlet_frame->new_checkbutton(
                        -onvalue  => 1,
                        -offvalue => 0,
                        -text     => $names[$n],
                        -font     => 'default',
                        -variable => \$ts_show[$n],
                        -command  => [ sub { my ($nn) = @_;
                                             my ($i);
                                             if ($ts_show[$nn]) {
                                                 $width_sbs[$nn]->configure(-state  => 'normal');
                                                 $color_btns[$nn]->configure(-state => 'normal');
                                             } else {
                                                 $width_sbs[$nn]->configure(-state  => 'disabled');
                                                 $color_btns[$nn]->configure(-state => 'disabled');
                                             }
                                             for ($i=0; $i<=$#names; $i++) {
                                                 if ($ts_show[$i]) {
                                                     $preview_legend->itemconfigure($legend_line,
                                                             -width => $ts_width[$i],
                                                             -fill  => &get_rgb_code($ts_color[$i]));
                                                     $preview_legend->itemconfigure($legend_txt,
                                                             -text => $names[$i]);
                                                     last;
                                                 }
                                             }
                                           }, $n ]
                            )->g_grid(-row => $row2, -column => 0, -sticky => 'w', -pady => 2);
                    ($width_sbs[$n] = $outlet_frame->new_spinbox(
                        -textvariable => \$ts_width[$n],
                        -state        => 'readonly',
                        -font         => 'default',
                        -from         => 1,
                        -to           => 10,
                        -increment    => 1,
                        -width        => 3,
                        -command      => [ sub { my ($nn) = @_;
                                                 my ($i);
                                                 for ($i=0; $i<=$#names; $i++) {
                                                     if ($ts_show[$i]) {
                                                         if ($i == $nn) {
                                                             $preview_legend->itemconfigure($legend_line,
                                                                     -width => $ts_width[$i]);
                                                         }
                                                         last;
                                                     }
                                                 }
                                               }, $n ]
                            ))->g_grid(-row => $row2, -column => 1, -sticky => 'w', -padx => 4, -pady => 2);
        
                    $code         = &get_rgb_code($ts_color[$n]);
                    $ts_color[$n] = &get_rgb_name($code);
                    $fg           = &get_rgb_code("black");
                    if ($code =~ /^\#[0-9a-f]/i) {
                        $fg = &get_rgb_code(&get_bw_contrast($code));
                    }
                    ($color_btns[$n] = $outlet_frame->new_button(
                        -textvariable => \$ts_color[$n],
                        -background   => $code,
                        -foreground   => $fg,
                        -width        => -7,
                        -command => [ sub { my ($nn) = @_;
                                            my ($newc, $code, $fg, $i);
                                            $code = &get_rgb_code($ts_color[$nn]);
                                            $newc = Tkx::tk___chooseColor(
                                                       -initialcolor => $code,
                                                       -parent       => $graph_props_menu);
                                            if ($newc) {
                                                $code          = &get_rgb_code($newc);
                                                $ts_color[$nn] = &get_rgb_name($code);
                                                $fg            = &get_rgb_code("black");
                                                if ($code =~ /^#?[0-9a-f]/i) {
                                                    $fg = &get_rgb_code(&get_bw_contrast($code));
                                                }
                                                $color_btns[$nn]->configure(-foreground => $fg,
                                                                            -background => $code);
                                                for ($i=0; $i<=$#names; $i++) {
                                                    if ($ts_show[$i]) {
                                                        if ($i == $nn) {
                                                            $preview_legend->itemconfigure($legend_line,
                                                                -fill => &get_rgb_code($ts_color[$i]));
                                                        }
                                                        last;
                                                    }
                                                }
                                            }
                                          }, $n ]
                            ))->g_grid(-row => $row2, -column => 2, -sticky => 'ew', -pady => 0);
                    if ($ts_show[$n]) {
                        $width_sbs[$n]->configure(-state  => 'normal');
                        $color_btns[$n]->configure(-state => 'normal');
                    } else {
                        $width_sbs[$n]->configure(-state  => 'disabled');
                        $color_btns[$n]->configure(-state => 'disabled');
                    }
                }
            }
        }

        $row++;
        $legend_frame->new_label(
                -text    => "Optional Legend Title: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'w', -pady => 2);
        $row++;
        $legend_frame->new_entry(
                -textvariable => \$legtitle,
                -font         => 'default',
                )->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew', -pady => 2);

        $legend_frame->g_grid_columnconfigure(0, -weight => 2);
    }

#   Additional time-series dataset tab
    if (defined($props{$id}{add_ts_parms})) {
        %add_ts_parms  = %{ $props{$id}{add_ts_parms} };
        @add_ts_setnum = @{ $add_ts_parms{ts_setnum}  };
        @add_ts_show   = @{ $add_ts_parms{ts_show}    };
        @add_ts_width  = @{ $add_ts_parms{ts_width}   };
        @add_ts_color  = @{ $add_ts_parms{ts_color}   };
        @add_ts_text   = @{ $add_ts_parms{ts_text}    };
        @add_ts_file   = @{ $add_ts_parms{ts_file}    };
        @add_ts_ftype  = @{ $add_ts_parms{ts_ftype}   };
        @add_ts_lines  = @{ $add_ts_parms{ts_lines}   };
        @add_ts_param  = @{ $add_ts_parms{ts_param}   };
        @add_ts_byear  = @{ $add_ts_parms{ts_byear}   };
        @add_ts_tzoff  = @{ $add_ts_parms{ts_tzoff}   };
        @add_ts_seg    = @{ $add_ts_parms{ts_seg}     };
        @add_ts_ctype  = @{ $add_ts_parms{ts_ctype}   };
        @add_ts_limits = @{ $add_ts_parms{ts_limits}  };
        @add_ts_tsdata = @{ $add_ts_parms{ts_data}    };
        @add_ts_delete = (0) x @add_ts_setnum;
        $gap_tol       = $gr_props{$id}{gap_tol};

        if ($#add_ts_setnum >= 0) {
            $indx     = &max(0, &list_match("1", @add_ts_show));
            $up_img   = Tkx::image_create_photo(-file => "${prog_path}images/up.png");
            $down_img = Tkx::image_create_photo(-file => "${prog_path}images/down.png");

            $tsdata_tab = $grprops_notebook->new_frame();
            $grprops_notebook->add($tsdata_tab,
                    -text      => "TS Data",
                    -underline => 0,
                    -sticky    => 'nsew',
                    );

            $preview_tsdata = $tsdata_tab->new_canvas(
                    -background  => &get_rgb_code($canvas_color),
                    -width       => $pw,
                    -height      => $ph,
                    -borderwidth => 1,
                    -relief      => 'groove',
                    );
            $preview_tsdata->g_grid(-row => 0, -column => 0, -sticky => 'wne');

            $tsdata_txt = $preview_tsdata->create_text($pw*0.55 +3, $ph*0.5 +3,
                                -anchor => 'center', 
                                -text   => $add_ts_text[$indx],
                                -fill   => "#000000",
                                -angle  => 0,
                                -font   => [-family     => $legfont,
                                            -size       => $le_size,
                                            -weight     => $le_weight,
                                            -slant      => 'roman',
                                            -underline  => 0,
                                            -overstrike => 0,
                                           ]);
            ($tsxmin, undef, undef, undef) = Tkx::SplitList($preview_tsdata->bbox($tsdata_txt));
            $tsdata_line = $preview_tsdata->create_line($tsxmin  -6, $ph*0.5 +3,
                                                        $tsxmin -26, $ph*0.5 +3,
                                -width => $add_ts_width[$indx],
                                -fill  => &get_rgb_code($add_ts_color[$indx]),
                                -arrow => 'none');

            $tsdata_frame = $tsdata_tab->new_frame(
                    -borderwidth => 1,
                    -relief      => 'groove',
                    );
            $tsdata_frame->g_grid(-row => 1, -column => 0, -sticky => 'wnes');

            if ($props{$id}{meta} eq "linked_time_series") {
                $tsdata_frame->new_label(
                        -text   => "Additional Time-Series Datasets:",
                        -anchor => 'w',
                        -font   => 'default',
                        )->g_grid(-row => 0, -column => 0, -sticky => 'ew', -pady => 2);
            } else {
                $tsdata_frame->new_label(
                        -text   => "Time-Series Datasets:",
                        -anchor => 'w',
                        -font   => 'default',
                        )->g_grid(-row => 0, -column => 0, -sticky => 'ew', -pady => 2);
            }

          # Need a scrollable container, and a canvas is about the only container that works.
          # Create a parent frame (sc_fr) for the canvas (sc_canv) and scrollbar (vscroll).
          # Put a frame inside the canvas (scroll_frame) as a widget window to hold other menu items.
            ($sc_fr = $tsdata_frame->new_frame(
                    -borderwidth => 0,
                    -relief      => 'flat',
                    ))->g_grid(-row => 1, -column => 0, -sticky => 'wnes');
            ($vscroll = $sc_fr->new_scrollbar(
                    -orient => 'vertical',
                    -width  => 15,
                    ))->g_grid(-row => 0, -column => 1, -sticky => 'nse');
            ($sc_canv = $sc_fr->new_tk__canvas(
                    -highlightthickness => 0,
                    -yscrollcommand => [$vscroll, 'set'],
                    ))->g_grid(-row => 0, -column => 0, -sticky => 'nsew');
            $vscroll->configure(-command => [$sc_canv, 'yview']);
        
            $scroll_frame = $sc_canv->new_frame(
                    -borderwidth => 0,
                    -relief      => 'flat',
                    );

            $row = 0;
            $scroll_frame->new_label(
                    -text => "Set",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'ew', -pady => 2);
            $scroll_frame->new_label(
                    -text => "Width ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
            $scroll_frame->new_label(
                    -text => "  Color  ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 2, -sticky => 'ew', -pady => 2);
            $scroll_frame->new_label(
                    -text => "Delete",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 3, -sticky => 'ew', -pady => 2);
            $scroll_frame->new_label(
                    -text => "Order",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 4, -columnspan => 2, -sticky => 'ew', -pady => 2);

            for ($i=0; $i<=$#add_ts_setnum; $i++) {
                $row++;
                $scroll_frame->new_checkbutton(
                        -onvalue  => 1,
                        -offvalue => 0,
                        -text     => $add_ts_setnum[$i],
                        -font     => 'default',
                        -variable => \$add_ts_show[$i],
                        -command  => [ sub { my ($n) = @_;
                                             my ($indx);
                                             if ($add_ts_show[$n]) {
                                                 $ts_width_sbs[$n]->configure(-state  => 'readonly');
                                                 $ts_color_btns[$n]->configure(-state => 'normal');
                                                 $ts_text_entry[$n]->configure(-state => 'normal');
                                             } else {
                                                 $ts_width_sbs[$n]->configure(-state  => 'disabled');
                                                 $ts_color_btns[$n]->configure(-state => 'disabled');
                                                 $ts_text_entry[$n]->configure(-state => 'disabled');
                                             }
                                             $indx = &max(0, &list_match("1", @add_ts_show));
                                             $preview_tsdata->itemconfigure($tsdata_line,
                                                         -width => $add_ts_width[$indx],
                                                         -fill  => &get_rgb_code($add_ts_color[$indx]));
                                             $preview_tsdata->itemconfigure($tsdata_txt,
                                                         -text  => $add_ts_text[$indx]);
                                             @coords = Tkx::SplitList($preview_tsdata->bbox($tsdata_txt));
                                             $preview_tsdata->coords($tsdata_line,
                                                                     $coords[0]  -6, $ph*0.5 +3,
                                                                     $coords[0] -26, $ph*0.5 +3);
                                           }, $i ]
                        )->g_grid(-row => $row, -rowspan => 2, -column => 0, -sticky => 'e', -pady => 2);
                ($ts_width_sbs[$i] = $scroll_frame->new_spinbox(
                        -textvariable => \$add_ts_width[$i],
                        -state        => 'readonly',
                        -font         => 'default',
                        -from         => 1,
                        -to           => 10,
                        -increment    => 1,
                        -width        => 3,
                        -command      => [ sub { my ($n) = @_;
                                                 if ($n == &max(0, &list_match("1", @add_ts_show))) {
                                                     $preview_tsdata->itemconfigure($tsdata_line,
                                                             -width => $add_ts_width[$n]);
                                                 }
                                               }, $i ]
                        ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -padx => 4, -pady => 2);

                $code             = &get_rgb_code($add_ts_color[$i]);
                $add_ts_color[$i] = &get_rgb_name($code);
                $fg               = &get_rgb_code("black");
                if ($code =~ /^\#[0-9a-f]/i) {
                    $fg = &get_rgb_code(&get_bw_contrast($code));
                }
                ($ts_color_btns[$i] = $scroll_frame->new_button(
                        -textvariable => \$add_ts_color[$i],
                        -background   => $code,
                        -foreground   => $fg,
                        -width        => -7,
                        -command => [ sub { my ($n) = @_;
                                            my ($newc, $code, $fg);
                                            $code = &get_rgb_code($add_ts_color[$n]);
                                            $newc = Tkx::tk___chooseColor(
                                                       -initialcolor => $code,
                                                       -parent       => $graph_props_menu);
                                            if ($newc) {
                                                $code             = &get_rgb_code($newc);
                                                $add_ts_color[$n] = &get_rgb_name($code);
                                                $fg               = &get_rgb_code("black");
                                                if ($code =~ /^#?[0-9a-f]/i) {
                                                    $fg = &get_rgb_code(&get_bw_contrast($code));
                                                }
                                                $ts_color_btns[$n]->configure(-foreground => $fg,
                                                                              -background => $code);
                                                if ($n == &max(0, &list_match("1", @add_ts_show))) {
                                                    $preview_tsdata->itemconfigure($tsdata_line,
                                                            -fill => &get_rgb_code($add_ts_color[$n]));
                                                }
                                            }
                                          }, $i ]
                        ))->g_grid(-row => $row, -column => 2, -sticky => 'ew', -pady => 0);

                $scroll_frame->new_checkbutton(
                        -onvalue  => 1,
                        -offvalue => 0,
                        -text     => "Delete",
                        -font     => 'default',
                        -variable => \$add_ts_delete[$i],
                        )->g_grid(-row => $row, -column => 3, -sticky => 'e', -pady => 2);

                ($down_btn[$i] = $scroll_frame->new_button(
                        -repeatdelay    => 10000,
                        -repeatinterval => 10000,
                        -image   => $down_img,
                        -command => [ sub { my ($n) = @_;
                                            my ($code, $fg, $nn, $state);
                                            $swapsets = 1;

                                            @add_ts_show[$n,$n+1]   = @add_ts_show[$n+1,$n];
                                            @add_ts_width[$n,$n+1]  = @add_ts_width[$n+1,$n];
                                            @add_ts_color[$n,$n+1]  = @add_ts_color[$n+1,$n];
                                            @add_ts_delete[$n,$n+1] = @add_ts_delete[$n+1,$n];
                                            @add_ts_text[$n,$n+1]   = @add_ts_text[$n+1,$n];
                                            @add_ts_file[$n,$n+1]   = @add_ts_file[$n+1,$n];
                                            @add_ts_ftype[$n,$n+1]  = @add_ts_ftype[$n+1,$n];
                                            @add_ts_lines[$n,$n+1]  = @add_ts_lines[$n+1,$n];
                                            @add_ts_param[$n,$n+1]  = @add_ts_param[$n+1,$n];
                                            @add_ts_byear[$n,$n+1]  = @add_ts_byear[$n+1,$n];
                                            @add_ts_tzoff[$n,$n+1]  = @add_ts_tzoff[$n+1,$n];
                                            @add_ts_seg[$n,$n+1]    = @add_ts_seg[$n+1,$n];
                                            @add_ts_ctype[$n,$n+1]  = @add_ts_ctype[$n+1,$n];
                                            @add_ts_limits[$n,$n+1] = @add_ts_limits[$n+1,$n];
                                            @add_ts_tsdata[$n,$n+1] = @add_ts_tsdata[$n+1,$n];

                                            $code = &get_rgb_code($add_ts_color[$n]);
                                            $fg   = &get_rgb_code("black");
                                            if ($code =~ /^#?[0-9a-f]/i) {
                                                $fg = &get_rgb_code(&get_bw_contrast($code));
                                            }
                                            $ts_color_btns[$n]->configure(-foreground => $fg,
                                                                          -background => $code);
                                            $code = &get_rgb_code($add_ts_color[$n+1]);
                                            $fg   = &get_rgb_code("black");
                                            if ($code =~ /^#?[0-9a-f]/i) {
                                                $fg = &get_rgb_code(&get_bw_contrast($code));
                                            }
                                            $ts_color_btns[$n+1]->configure(-foreground => $fg,
                                                                            -background => $code);
                                            for ($nn=$n; $nn<=$n+1; $nn++) {
                                                $state = ($add_ts_show[$nn]) ? 'readonly' : 'disabled';
                                                $ts_width_sbs[$nn]->configure(-state  => $state);
                                                $state = ($add_ts_show[$nn]) ? 'normal' : 'disabled';
                                                $ts_color_btns[$nn]->configure(-state => $state);
                                                $ts_text_entry[$nn]->configure(-state => $state);
                                            }
                                            $n = &max(0, &list_match("1", @add_ts_show));
                                            $preview_tsdata->itemconfigure($tsdata_line,
                                                        -fill => &get_rgb_code($add_ts_color[$n]));
                                            $preview_tsdata->itemconfigure($tsdata_txt,
                                                                      -text => $add_ts_text[$n]);
                                            @coords = Tkx::SplitList($preview_tsdata->bbox($tsdata_txt));
                                            $preview_tsdata->coords($tsdata_line,
                                                                    $coords[0]  -6, $ph*0.5 +3,
                                                                    $coords[0] -26, $ph*0.5 +3);
                                          }, $i ]
                        ))->g_grid(-row => $row, -column => 4, -sticky => 'e', -pady => 2);
                ($up_btn[$i] = $scroll_frame->new_button(
                        -repeatdelay    => 10000,
                        -repeatinterval => 10000,
                        -image   => $up_img,
                        -command => [ sub { my ($n) = @_;
                                            my ($code, $fg, $nn, $state);
                                            $swapsets = 1;

                                            @add_ts_show[$n,$n-1]   = @add_ts_show[$n-1,$n];
                                            @add_ts_width[$n,$n-1]  = @add_ts_width[$n-1,$n];
                                            @add_ts_color[$n,$n-1]  = @add_ts_color[$n-1,$n];
                                            @add_ts_delete[$n,$n-1] = @add_ts_delete[$n-1,$n];
                                            @add_ts_text[$n,$n-1]   = @add_ts_text[$n-1,$n];
                                            @add_ts_file[$n,$n-1]   = @add_ts_file[$n-1,$n];
                                            @add_ts_ftype[$n,$n-1]  = @add_ts_ftype[$n-1,$n];
                                            @add_ts_lines[$n,$n-1]  = @add_ts_lines[$n-1,$n];
                                            @add_ts_param[$n,$n-1]  = @add_ts_param[$n-1,$n];
                                            @add_ts_byear[$n,$n-1]  = @add_ts_byear[$n-1,$n];
                                            @add_ts_tzoff[$n,$n-1]  = @add_ts_tzoff[$n-1,$n];
                                            @add_ts_seg[$n,$n-1]    = @add_ts_seg[$n-1,$n];
                                            @add_ts_ctype[$n,$n-1]  = @add_ts_ctype[$n-1,$n];
                                            @add_ts_limits[$n,$n-1] = @add_ts_limits[$n-1,$n];
                                            @add_ts_tsdata[$n,$n-1] = @add_ts_tsdata[$n-1,$n];

                                            $code = &get_rgb_code($add_ts_color[$n]);
                                            $fg   = &get_rgb_code("black");
                                            if ($code =~ /^#?[0-9a-f]/i) {
                                                $fg = &get_rgb_code(&get_bw_contrast($code));
                                            }
                                            $ts_color_btns[$n]->configure(-foreground => $fg,
                                                                          -background => $code);
                                            $code = &get_rgb_code($add_ts_color[$n-1]);
                                            $fg   = &get_rgb_code("black");
                                            if ($code =~ /^#?[0-9a-f]/i) {
                                                $fg = &get_rgb_code(&get_bw_contrast($code));
                                            }
                                            $ts_color_btns[$n-1]->configure(-foreground => $fg,
                                                                            -background => $code);
                                            for ($nn=$n-1; $nn<=$n; $nn++) {
                                                $state = ($add_ts_show[$nn]) ? 'readonly' : 'disabled';
                                                $ts_width_sbs[$nn]->configure(-state  => $state);
                                                $state = ($add_ts_show[$nn]) ? 'normal' : 'disabled';
                                                $ts_color_btns[$nn]->configure(-state => $state);
                                                $ts_text_entry[$nn]->configure(-state => $state);
                                            }
                                            $n = &max(0, &list_match("1", @add_ts_show));
                                            $preview_tsdata->itemconfigure($tsdata_line,
                                                        -fill => &get_rgb_code($add_ts_color[$n]));
                                            $preview_tsdata->itemconfigure($tsdata_txt,
                                                                      -text => $add_ts_text[$n]);
                                            @coords = Tkx::SplitList($preview_tsdata->bbox($tsdata_txt));
                                            $preview_tsdata->coords($tsdata_line,
                                                                    $coords[0]  -6, $ph*0.5 +3,
                                                                    $coords[0] -26, $ph*0.5 +3);
                                          }, $i ]
                        ))->g_grid(-row => $row, -column => 5, -sticky => 'e', -pady => 2);

                $row++;
                ($ts_text_entry[$i] = $scroll_frame->new_entry(
                        -textvariable => \$add_ts_text[$i],
                        -font         => 'default',
                        ))->g_grid(-row => $row, -column => 1, -columnspan => 5, -sticky => 'ew', -pady => 2);
                $ts_text_entry[$i]->g_bind("<KeyRelease>",
                                     [ sub { my ($n) = @_;
                                             if ($n == &max(0, &list_match("1", @add_ts_show))) {
                                                 $preview_tsdata->itemconfigure($tsdata_txt,
                                                                      -text => $add_ts_text[$n]);
                                                 @coords = Tkx::SplitList($preview_tsdata->bbox($tsdata_txt));
                                                 $preview_tsdata->coords($tsdata_line,
                                                                         $coords[0]  -6, $ph*0.5 +3,
                                                                         $coords[0] -26, $ph*0.5 +3);
                                             }
                                           }, $i ]);

                if ($add_ts_show[$i]) {
                    $ts_width_sbs[$i]->configure(-state  => 'readonly');
                    $ts_color_btns[$i]->configure(-state => 'normal');
                    $ts_text_entry[$i]->configure(-state => 'normal');
                } else {
                    $ts_width_sbs[$i]->configure(-state  => 'disabled');
                    $ts_color_btns[$i]->configure(-state => 'disabled');
                    $ts_text_entry[$i]->configure(-state => 'disabled');
                }
            }
            $scroll_frame->g_grid_columnconfigure(4, -weight => 2);
            $up_btn[0]->configure(-state => 'disabled');
            $down_btn[$#add_ts_setnum]->configure(-state => 'disabled');

            ($gaptol_frame = $tsdata_frame->new_frame(
                    -borderwidth => 1,
                    -relief      => 'groove',
                    ))->g_grid(-row => 2, -column => 0, -sticky => 'ew', -pady => 2);
            $gaptol_frame->new_label(
                    -text => "Gap Tolerance: ",
                    -font => 'default',
                    )->g_pack(-side => 'left', -pady => 2);
            ($gaptol_entry = $gaptol_frame->new_entry(
                    -textvariable => \$gap_tol,
                    -font         => 'default',
                    -width        => 10,
                    ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
            $gaptol_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($gaptol_entry);
                                                        $gap_tol =~ s/^-//;
                                                      });
            $gaptol_frame->new_label(
                    -text => " days",
                    -font => 'default',
                    )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);

            $sc_canv->create_window(0, 0,
                    -anchor => 'nw',
                    -window => $scroll_frame,
                    -tags   => 'scrollable',
                    );
            &update_scrollable_tab($graph_props_menu, $sc_fr, $sc_canv, 'scrollable', $vscroll);
            $sc_fr->g_grid_columnconfigure(0, -weight => 1);
        }
    }

#   Grid tab for time-series graphs
    if ($props{$id}{meta} =~ /time_series/) {
        if (defined($gr_props{$id}{gridx})) {
            $gridx     = $gr_props{$id}{gridx};
            $gridy     = $gr_props{$id}{gridy};
            $gridcolor = $gr_props{$id}{gridcolor};
            $gridwidth = $gr_props{$id}{gridwidth};
        } else {
            $gridx     = $gridy = 0;
            $gridcolor = '#C0C0C0';
            $gridwidth = 1;
        }

        $grid_tab = $grprops_notebook->new_frame();
        $grprops_notebook->add($grid_tab,
                -text      => "Grid",
                -underline => 0,
                -sticky    => 'nsew',
                );

        $preview_grid = $grid_tab->new_canvas(
                -background  => &get_rgb_code($canvas_color),
                -width       => $pw,
                -height      => $ph,
                -borderwidth => 1,
                -relief      => 'groove',
                );
        $preview_grid->g_grid(-row => 0, -column => 0, -sticky => 'wne');

        $xgrid_line1 = $preview_grid->create_line($pw*0.25 +3, $ph*0.1 +3,
                                                  $pw*0.25 +3, $ph*0.9 +3,
                                      -width => $gridwidth,
                                      -fill  => &get_rgb_code($gridcolor),
                                      -arrow => 'none',
                                      -state => ($gridx) ? 'normal' : 'hidden');
        $xgrid_line2 = $preview_grid->create_line($pw*0.5 +3, $ph*0.1 +3,
                                                  $pw*0.5 +3, $ph*0.9 +3,
                                      -width => $gridwidth,
                                      -fill  => &get_rgb_code($gridcolor),
                                      -arrow => 'none',
                                      -state => ($gridx) ? 'normal' : 'hidden');
        $xgrid_line3 = $preview_grid->create_line($pw*0.75 +3, $ph*0.1 +3,
                                                  $pw*0.75 +3, $ph*0.9 +3,
                                      -width => $gridwidth,
                                      -fill  => &get_rgb_code($gridcolor),
                                      -arrow => 'none',
                                      -state => ($gridx) ? 'normal' : 'hidden');
        $ygrid_line1 = $preview_grid->create_line($pw*0.1 +3, $ph*0.33 +3,
                                                  $pw*0.9 +3, $ph*0.33 +3,
                                      -width => $gridwidth,
                                      -fill  => &get_rgb_code($gridcolor),
                                      -arrow => 'none',
                                      -state => ($gridy) ? 'normal' : 'hidden');
        $ygrid_line2 = $preview_grid->create_line($pw*0.1 +3, $ph*0.67 +3,
                                                  $pw*0.9 +3, $ph*0.67 +3,
                                      -width => $gridwidth,
                                      -fill  => &get_rgb_code($gridcolor),
                                      -arrow => 'none',
                                      -state => ($gridy) ? 'normal' : 'hidden');

        $grid_frame = $grid_tab->new_frame(
                -borderwidth => 1,
                -relief      => 'groove',
                );
        $grid_frame->g_grid(-row => 1, -column => 0, -sticky => 'wnes');

        $row = 0;
        $grid_frame->new_label(
                -text   => "Time-Series Grid Lines:",
                -anchor => 'w',
                -font   => 'default',
                )->g_grid(-row => $row, -column => 0, -columnspan => 2, -sticky => 'ew', -pady => 2);

        $row++;
        $grid_frame->new_label(
                -text => "Vertical: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $grid_frame->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "Show",
                -font     => 'default',
                -variable => \$gridx,
                -command  => sub { my $status = ($gridx) ? 'normal' : 'hidden';
                                   $preview_grid->itemconfigure($xgrid_line1, -state => $status);
                                   $preview_grid->itemconfigure($xgrid_line2, -state => $status);
                                   $preview_grid->itemconfigure($xgrid_line3, -state => $status);
                                 },
                )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

        $row++;
        $grid_frame->new_label(
                -text => "Horizontal: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $grid_frame->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "Show",
                -font     => 'default',
                -variable => \$gridy,
                -command  => sub { my $status = ($gridy) ? 'normal' : 'hidden';
                                   $preview_grid->itemconfigure($ygrid_line1, -state => $status);
                                   $preview_grid->itemconfigure($ygrid_line2, -state => $status);
                                 },
                )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

        $row++;
        $grid_frame->new_label(
                -text => "Width: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($gridwidth_sb = $grid_frame->new_spinbox(
                -textvariable => \$gridwidth,
                -state        => 'readonly',
                -font         => 'default',
                -from         => 1,
                -to           => 10,
                -increment    => 1,
                -width        => 3,
                -command      => sub { $preview_grid->itemconfigure($xgrid_line1, -width => $gridwidth);
                                       $preview_grid->itemconfigure($xgrid_line2, -width => $gridwidth);
                                       $preview_grid->itemconfigure($xgrid_line3, -width => $gridwidth);
                                       $preview_grid->itemconfigure($ygrid_line1, -width => $gridwidth);
                                       $preview_grid->itemconfigure($ygrid_line2, -width => $gridwidth);
                                     },
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

        $row++;
        $grid_frame->new_label(
                -text => "Color: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $code       = &get_rgb_code($gridcolor);
        $gridcolor = &get_rgb_name($code);
        $fg         = &get_rgb_code("black");
        if ($code =~ /^\#[0-9a-f]/i) {
            $fg = &get_rgb_code(&get_bw_contrast($code));
        }
        ($gridcolor_btn = $grid_frame->new_button(
                -textvariable => \$gridcolor,
                -background   => $code,
                -foreground   => $fg,
                -width        => -7,
                -command => sub { my ($newc, $code, $fg);
                                  $code = &get_rgb_code($gridcolor);
                                  $newc = Tkx::tk___chooseColor(
                                             -initialcolor => $code,
                                             -parent       => $graph_props_menu);
                                  if ($newc) {
                                      $code      = &get_rgb_code($newc);
                                      $gridcolor = &get_rgb_name($code);
                                      $fg        = &get_rgb_code("black");
                                      if ($code =~ /^#?[0-9a-f]/i) {
                                          $fg = &get_rgb_code(&get_bw_contrast($code));
                                      }
                                      $gridcolor_btn->configure(-foreground => $fg,
                                                                -background => $code);
                                      $preview_grid->itemconfigure($xgrid_line1, -fill => $code);
                                      $preview_grid->itemconfigure($xgrid_line2, -fill => $code);
                                      $preview_grid->itemconfigure($xgrid_line3, -fill => $code);
                                      $preview_grid->itemconfigure($ygrid_line1, -fill => $code);
                                      $preview_grid->itemconfigure($ygrid_line2, -fill => $code);
                                  }
                                },
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 0);
    }

#   Bulkhead configuration tab
    if ($props{$id}{meta} eq "vert_wd_zone" && $props{$id}{wd_alg} eq "Libby Dam") {
        $bh_show   = $gr_props{$id}{bh_show};
        $bh_docked = $gr_props{$id}{bh_docked};
        $bh_font   = $gr_props{$id}{bh_font};
        $bh_size   = $gr_props{$id}{bh_size};
        $bh_weight = $gr_props{$id}{bh_weight};
        $bh_tcolor = $gr_props{$id}{bh_tcolor};
        $bh_bwidth = $gr_props{$id}{bh_bwidth};
        $bh_bcolor = $gr_props{$id}{bh_bcolor};
        $bh_bcellw = $gr_props{$id}{bh_bcellw};
        $bh_bcellh = $gr_props{$id}{bh_bcellh};
        if ($bh_bcellh -int($bh_bcellh) != 0.0) {
            $bh_bcellh = sprintf("%.6f", $bh_bcellh);
            $bh_bcellh =~ s/0+$//;
        }

        @bh_status_opts = ("Do not show", "Show, docked", "Show, undocked");
        if ($bh_show) {
            $bh_status = ($bh_docked) ? 1 : 2;
        } else {
            $bh_status = 0;
        }
        $bh_status_opt = $bh_status_opts[$bh_status];

        $bulkhead_tab = $grprops_notebook->new_frame();
        $grprops_notebook->add($bulkhead_tab,
                -text      => "Bulkheads",
                -underline => 0,
                -sticky    => 'nsew',
                );

        $preview_bh = $bulkhead_tab->new_canvas(
                -background  => &get_rgb_code($canvas_color),
                -width       => $pw,
                -height      => $ph,
                -borderwidth => 1,
                -relief      => 'groove',
                );
        $preview_bh->g_grid(-row => 0, -column => 0, -sticky => 'wne');

        $bulkhead_box = $preview_bh->create_rectangle($pw*0.5 -$bh_bcellw/2 +3, $ph*0.2 +3,
                                                      $pw*0.5 +$bh_bcellw/2 +3, $ph*0.8 +3,
                                -outline => &get_rgb_code($bh_bcolor),
                                -width   => $bh_bwidth,
                                -fill    => "",
                                );
        $bulkhead_txt = $preview_bh->create_text($pw*0.5 +3, $ph*0.5 +3,
                -anchor => 'center', 
                -text   => "3",
                -fill   => &get_rgb_code($bh_tcolor),
                -angle  => 0,
                -font   => [-family     => $bh_font,
                            -size       => $bh_size,
                            -weight     => $bh_weight,
                            -slant      => 'roman',
                            -underline  => 0,
                            -overstrike => 0,
                           ]);

        $bh_frame = $bulkhead_tab->new_frame(
                -borderwidth => 1,
                -relief      => 'groove',
                );
        $bh_frame->g_grid(-row => 1, -column => 0, -sticky => 'wnes');

        $row = 0;
        $bh_frame->new_label(
                -text => "Status: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($bh_status_cb = $bh_frame->new_ttk__combobox(
                -textvariable => \$bh_status_opt,
                -values       => [ @bh_status_opts ],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $bh_status_cb->g_bind("<<ComboboxSelected>>",
                  sub { my $s = &list_match($bh_status_opt, @bh_status_opts);
                        return if ($s < 0);
                        if ($s < 2 && $bh_status == 2) {
                            $bh_bcellh_label->g_grid_remove();
                            $bh_bcellh_entry->g_grid_remove();
                            $bh_bcellh_label2->g_grid_remove();
                        } elsif ($s == 2 && $bh_status != 2) {
                            $bh_bcellh_label->g_grid();
                            $bh_bcellh_entry->g_grid();
                            $bh_bcellh_label2->g_grid();
                            $bh_bcellh = $gr_props{$id}{bh_bcellh};
                            if ($bh_bcellh -int($bh_bcellh) != 0.0) {
                                $bh_bcellh = sprintf("%.6f", $bh_bcellh);
                                $bh_bcellh =~ s/0+$//;
                            }
                        }
                        $bh_status = $s;
                      });
        $row++;
        $bh_frame->new_label(
                -text => "Bulkhead Text Font: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($bh_font_cb = $bh_frame->new_ttk__combobox(
                -textvariable => \$bh_font,
                -values       => [ sort @available_fonts ],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $bh_font_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_bh->itemconfigure($bulkhead_txt,
                              -font => [ -family     => $bh_font,
                                         -size       => $bh_size,
                                         -weight     => $bh_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });
        $row++;
        $bh_frame->new_label(
                -text => "Bulkhead Text Size: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($bh_size_cb = $bh_frame->new_ttk__combobox(
                -textvariable => \$bh_size,
                -values       => [(5 .. 24)],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $bh_size_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_bh->itemconfigure($bulkhead_txt,
                              -font => [ -family     => $bh_font,
                                         -size       => $bh_size,
                                         -weight     => $bh_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });
        $row++;
        $bh_frame->new_label(
                -text => "Bulkhead Text Weight: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($bh_weight_cb = $bh_frame->new_ttk__combobox(
                -textvariable => \$bh_weight,
                -values       => [("normal", "bold")],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $bh_weight_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_bh->itemconfigure($bulkhead_txt,
                              -font => [ -family     => $bh_font,
                                         -size       => $bh_size,
                                         -weight     => $bh_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });
        $row++;
        $code      = &get_rgb_code($bh_tcolor);
        $bh_tcolor = &get_rgb_name($code);
        $fg        = &get_rgb_code("black");
        if ($code =~ /^\#[0-9a-f]/i) {
            $fg = &get_rgb_code(&get_bw_contrast($code));
        }
        $bh_frame->new_label(
                -text => "BH Text Color: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($bh_tcolor_btn = $bh_frame->new_button(
                -textvariable => \$bh_tcolor,
                -background   => $code,
                -foreground   => $fg,
                -width        => -7,
                -command => sub { my ($newc, $code, $fg);
                                  $code = &get_rgb_code($bh_tcolor);
                                  $newc = Tkx::tk___chooseColor(
                                             -initialcolor => $code,
                                             -parent       => $graph_props_menu);
                                  if ($newc) {
                                      $code      = &get_rgb_code($newc);
                                      $bh_tcolor = &get_rgb_name($code);
                                      $fg        = &get_rgb_code("black");
                                      if ($code =~ /^\#[0-9a-f]/i) {
                                          $fg = &get_rgb_code(&get_bw_contrast($code));
                                      }
                                      $bh_tcolor_btn->configure(-foreground => $fg,
                                                                -background => $code);
                                      $preview_bh->itemconfigure($bulkhead_txt,
                                                       -fill => &get_rgb_code($bh_tcolor));
                                  }
                                }
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
        $row++;
        $bh_frame->new_label(
                -text => "Box Outline Width: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $bh_frame->new_spinbox(
                -textvariable => \$bh_bwidth,
                -state        => 'readonly',
                -font         => 'default',
                -from         => 1,
                -to           => 10,
                -increment    => 1,
                -width        => 3,
                -command      => sub { $preview_bh->itemconfigure($bulkhead_box,
                                             -width => $bh_bwidth);
                                     }
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $row++;
        $code      = &get_rgb_code($bh_bcolor);
        $bh_bcolor = &get_rgb_name($code);
        $fg        = &get_rgb_code("black");
        if ($code =~ /^\#[0-9a-f]/i) {
            $fg = &get_rgb_code(&get_bw_contrast($code));
        }
        $bh_frame->new_label(
                -text => "Box Outline Color: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($bh_bcolor_btn = $bh_frame->new_button(
                -textvariable => \$bh_bcolor,
                -background   => $code,
                -foreground   => $fg,
                -width        => -7,
                -command => sub { my ($newc, $code, $fg);
                                  $code = &get_rgb_code($bh_bcolor);
                                  $newc = Tkx::tk___chooseColor(
                                             -initialcolor => $code,
                                             -parent       => $graph_props_menu);
                                  if ($newc) {
                                      $code      = &get_rgb_code($newc);
                                      $bh_bcolor = &get_rgb_name($code);
                                      $fg        = &get_rgb_code("black");
                                      if ($code =~ /^\#[0-9a-f]/i) {
                                          $fg = &get_rgb_code(&get_bw_contrast($code));
                                      }
                                      $bh_bcolor_btn->configure(-foreground => $fg,
                                                                -background => $code);
                                      $preview_bh->itemconfigure($bulkhead_box,
                                                       -outline => &get_rgb_code($bh_bcolor));
                                  }
                                }
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
        $row++;
        $bh_frame->new_label(
                -text => "Box Cell Width: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $bh_frame->new_spinbox(
                -textvariable => \$bh_bcellw,
                -state        => 'readonly',
                -font         => 'default',
                -from         => 10,
                -to           => 30,
                -increment    => 1,
                -width        => 3,
                -command      => sub { $preview_bh->coords($bulkhead_box,
                                                    $pw*0.5 -$bh_bcellw/2 +3, $ph*0.2 +3,
                                                    $pw*0.5 +$bh_bcellw/2 +3, $ph*0.8 +3);
                                     }
                )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $bh_frame->new_label(
                -text => "pixels",
                -font => 'default',
                )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);
        $bh_frame->g_grid_columnconfigure(2, -weight => 2);
        $row++;
        ($bh_bcellh_label = $bh_frame->new_label(
                -text => "Box Cell Height: ",
                -font => 'default',
                ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($bh_bcellh_entry = $bh_frame->new_entry(
                -textvariable => \$bh_bcellh,
                -font         => 'default',
                -width        => 10,
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        ($bh_bcellh_label2 = $bh_frame->new_label(
                -text => "pixels",
                -font => 'default',
                ))->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);
        $bh_bcellh_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $bh_bcellh_entry ]);
        if ($bh_status < 2) {
            $bh_bcellh_label->g_grid_remove();
            $bh_bcellh_entry->g_grid_remove();
            $bh_bcellh_label2->g_grid_remove();
        }
    }

    Tkx::ttk__notebook__enableTraversal($grprops_notebook);
    Tkx::wm_resizable($graph_props_menu,0,0);
    &adjust_window_position($graph_props_menu);
    $grprops_notebook->select(&min($tabid, $grprops_notebook->index('end')-1));
    $graph_props_menu->g_focus;
}


sub color_profile_menu {
    my ($preview_profile, $pw, $ph, $cstatus_opt, $pc_style, @colors) = @_;
    my ($i, $n, $n1, $n2, $pr_color, $pr_val, $yp1, $yp2,
        @pr_stair_vals,
       );

    @pr_stair_vals = (0.75, 0.74, 0.70, 0.65, 0.55, 0.42, 0.32, 0.27, 0.25);

    $preview_profile->delete("pc_layers");
    $preview_profile->delete("pc_interp");
    $preview_profile->delete("pc_maxinterp");

    for ($i=0; $i<=8; $i++) {
        $n        = &round_to_int(($#colors+1) *(($pr_stair_vals[$i]-0.25)/0.5*0.8+0.1))-1;
        $pr_color = $colors[&max(0, &min($#colors, $n))];
        $preview_profile->create_rectangle($pw*0.15 +3, $ph*($i*0.3+0.15) +3,
                                           $pw*0.85 +3, $ph*(($i+1)*0.3+0.15) +3,
                            -outline => "",
                            -width   => 0,
                            -fill    => &get_rgb_code($pr_color),
                            -tags    => "pc_layers");
        if ($i==0) {
            $preview_profile->create_rectangle($pw*0.15 +3, $ph*0.15  +3,
                                               $pw*0.85 +3, $ph*0.375 +3,
                                -outline => "",
                                -width   => 0,
                                -fill    => &get_rgb_code($pr_color),
                                -tags    => "pc_interp");
            $preview_profile->create_rectangle($pw*0.15 +3, $ph*0.15 +3,
                                               $pw*0.85 +3, $ph*0.30 +3,
                                -outline => "",
                                -width   => 0,
                                -fill    => &get_rgb_code($pr_color),
                                -tags    => "pc_maxinterp");
            $pr_val   = 0.5*($pr_stair_vals[$i] +$pr_stair_vals[$i+1]);
            $n        = &round_to_int(($#colors+1) *(($pr_val-0.25)/0.5*0.8+0.1))-1;
            $pr_color = $colors[&max(0, &min($#colors, $n))];
            $preview_profile->create_rectangle($pw*0.15 +3, $ph*0.375 +3,
                                               $pw*0.85 +3, $ph*0.525 +3,
                                -outline => "",
                                -width   => 0,
                                -fill    => &get_rgb_code($pr_color),
                                -tags    => "pc_interp");
        } elsif ($i==8) {
            $preview_profile->create_rectangle($pw*0.15 +3, $ph*($i*0.3+0.225) +3,
                                               $pw*0.85 +3, $ph*(($i+1)*0.3+0.15) +3,
                                -outline => "",
                                -width   => 0,
                                -fill    => &get_rgb_code($pr_color),
                                -tags    => "pc_interp");
            $preview_profile->create_rectangle($pw*0.15 +3, $ph*($i*0.3+0.3) +3,
                                               $pw*0.85 +3, $ph*(($i+1)*0.3+0.15) +3,
                                -outline => "",
                                -width   => 0,
                                -fill    => &get_rgb_code($pr_color),
                                -tags    => "pc_maxinterp");
        } else {
            $preview_profile->create_rectangle($pw*0.15 +3, $ph*($i*0.3+0.225) +3,
                                               $pw*0.85 +3, $ph*($i*0.3+0.375) +3,
                                -outline => "",
                                -width   => 0,
                                -fill    => &get_rgb_code($pr_color),
                                -tags    => "pc_interp");
            $pr_val   = 0.5*($pr_stair_vals[$i] +$pr_stair_vals[$i+1]);
            $n        = &round_to_int(($#colors+1) *(($pr_val-0.25)/0.5*0.8+0.1))-1;
            $pr_color = $colors[&max(0, &min($#colors, $n))];
            $preview_profile->create_rectangle($pw*0.15 +3, $ph*($i*0.3+0.375) +3,
                                               $pw*0.85 +3, $ph*($i*0.3+0.525) +3,
                                -outline => "",
                                -width   => 0,
                                -fill    => &get_rgb_code($pr_color),
                                -tags    => "pc_interp");
        }
    }
    $n1 = &round_to_int(($#colors+1) *(($pr_stair_vals[0]-0.25)/0.5*0.8+0.1))-1;
    $n2 = &round_to_int(($#colors+1) *(($pr_stair_vals[8]-0.25)/0.5*0.8+0.1))-1;
    $n1 = &max(0, &min($#colors, $n1));
    $n2 = &max(0, &min($#colors, $n2));
    $yp1 = 0.3;
    for ($n=$n1; $n>=$n2; $n--) {
        $pr_val = (($n+1-0.5)/($#colors+1)-0.1)*0.5/0.8+0.25;
        $yp2 = 0.3;
        for ($i=1; $i<=8; $i++) {
            if ($pr_val < $pr_stair_vals[$i]) {
                $yp2 = ($i+1)*0.3;
                next;
            }
            $yp2 += 0.3*($pr_stair_vals[$i-1] -$pr_val)/($pr_stair_vals[$i-1] -$pr_stair_vals[$i]);
            last;
        }
        $yp2 = &min(2.7, $yp2);
        $preview_profile->create_rectangle($pw*0.15 +3, $ph*$yp1 +3,
                                           $pw*0.85 +3, $ph*$yp2 +3,
                            -outline => "",
                            -width   => 0,
                            -fill    => &get_rgb_code($colors[$n]),
                            -tags    => "pc_maxinterp");
        $yp1 = $yp2;
    }
    $preview_profile->raise("pc_layers",    "pr_grid");
    $preview_profile->raise("pc_interp",    "pc_layers");
    $preview_profile->raise("pc_maxinterp", "pc_interp");
    if ($cstatus_opt =~ /inactive/i) {
        $preview_profile->itemconfigure("pc_layers",    -state => 'hidden');
        $preview_profile->itemconfigure("pc_interp",    -state => 'hidden');
        $preview_profile->itemconfigure("pc_maxinterp", -state => 'hidden');
    } elsif ($pc_style =~ /by layer/i) {
        $preview_profile->itemconfigure("pc_layers",    -state => 'normal');
        $preview_profile->itemconfigure("pc_interp",    -state => 'hidden');
        $preview_profile->itemconfigure("pc_maxinterp", -state => 'hidden');
    } elsif ($pc_style =~ /max interp/i) {
        $preview_profile->itemconfigure("pc_layers",    -state => 'hidden');
        $preview_profile->itemconfigure("pc_interp",    -state => 'hidden');
        $preview_profile->itemconfigure("pc_maxinterp", -state => 'normal');
    } else {
        $preview_profile->itemconfigure("pc_layers",    -state => 'hidden');
        $preview_profile->itemconfigure("pc_interp",    -state => 'normal');
        $preview_profile->itemconfigure("pc_maxinterp", -state => 'hidden');
    }
}


sub update_graph_props {
    my ($id, $xfont, $xt_size, $xt_weight, $xl_size, $xl_weight, $xbase, $xmin, $xmax,
             $xfirst, $xmajor, $xmaj_auto, $datefmt, $xtitle, $xpr_tics, $xop_tics,
             $xaxis_type, $xaxis_units, $xaxis_flip, $xmax_auto, $byear,
             $yfont, $yt_size, $yt_weight, $yl_size, $yl_weight, $ybase, $ymin, $ymax,
             $yfirst, $ymajor, $ymaj_auto, $yformat, $ytitle, $ypr_tics, $yop_tics,
             $yaxis_type, $yaxis_units, $yaxis_flip, $ymax_auto, $qaxis_units, $wt_units,
             $stype, $sfont, $st_size, $st_weight, $sl_size, $sl_weight, $stic_loc,
             $smajor, $sgrid, $sgrid_col, $bgrid, $bgrid_col, $stitle, $spr_tics, $sop_tics,
             $gtfont, $gt_size, $gt_weight, $gs_size, $gs_weight, $gs_pos, $gs_fmt,
             $gs_color, $gs_edge, $gs_edgec, $gs_fill, $gs_fillc, $gtitle, $gstitle,
             $status, $cs_link, $cs1, $cs2, $nc, $rev, $cs_min, $cs_max, $cs_major, $cs_width, $cs_height,
             $keyfont, $keytitle, $kt_size, $kt_weight, $kn_size, $kn_weight, $kn_digits,
             $pr_style, $pr_linec, $pr_linew, $pc_style,
             $bh_status, $bh_font, $bh_size, $bh_weight, $bh_tcolor,
             $bh_bwidth, $bh_bcolor, $bh_bcellw, $bh_bcellh,
             $legfont, $lt_size, $lt_weight, $le_size, $le_weight,
             $le_edge, $le_edgec, $le_fill, $le_fillc, $gap_tol,
             $gridx, $gridy, $gridwidth, $gridcolor, $dateline, $datelinec,
             $ref_color, $ref_size, $ref_linew,
             $wl_color, $wl_style, $wl_grid, $wl_gridc,
             $ts_show_ref, $ts_color_ref, $ts_width_ref, $legtitle, $sets_swapped,
             $add_ts_show_ref, $add_ts_setnum_ref, $add_ts_color_ref, $add_ts_width_ref,
             $add_ts_text_ref, $add_ts_delete_ref, $add_ts_file_ref, $add_ts_ftype_ref,
             $add_ts_lines_ref, $add_ts_param_ref, $add_ts_byear_ref, $add_ts_tzoff_ref,
             $add_ts_seg_ref, $add_ts_ctype_ref, $add_ts_limits_ref, $add_ts_tsdata_ref,
        $action, $X, $Y, $tabid) = @_;
    my (
        $base_jd, $datemax, $datemin, $dist1, $dist2, $geom, $gtag, $i,
        $ii, $item, $jd_max, $jd_max_old, $jd_min, $jd_min_old, $match,
        $move_mcursor, $n, $ncolors, $new_tag, $old_tag, $refresh_info,
        $refresh_menu, $update_cs, $x1, $x2, $y1, $y2,

        @add_ts_byear, @add_ts_color, @add_ts_ctype, @add_ts_delete,
        @add_ts_file, @add_ts_ftype, @add_ts_limits, @add_ts_lines,
        @add_ts_param, @add_ts_seg, @add_ts_setnum, @add_ts_show,
        @add_ts_text, @add_ts_tsdata, @add_ts_tzoff, @add_ts_width,
        @cpl_files, @ts_color, @ts_show, @ts_width, @wbs,

        %add_ts_parms, %parms,
       );

    $refresh_menu = $refresh_info = 0;
    ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };

    if (defined($gr_props{$id}{add_cs})) {
        if ($cs_min >= $cs_max) {
            return &pop_up_error($graph_props_menu,
                                 "The scale minimum must be\nless than the scale maximum.");
        }
        if ($cs_major ne "auto") {
            if ($cs_major > $cs_max -$cs_min) {
                return &pop_up_error($graph_props_menu,
                                     "The color scale increment is\nlarger than the scale range.");
            } elsif ($cs_major <= 0) {
                return &pop_up_error($graph_props_menu,
                                     "The color scale increment\nmust be greater than zero.");
            }
        }
    }
    if ($props{$id}{meta} eq "w2_tdmap") {
        if ($gr_props{$id}{date_axis} eq "X") {              # X: date/time, Y: distance
            $xmaj_auto = 0 if ($xaxis_type eq "Julian Date");
            if (! $xmaj_auto) {
                $xmajor = "auto" if (! defined($xmajor) || $xmajor eq "");
                if ($xmajor ne "auto") {
                    $xmajor = "auto" if ($xmajor+0 <= 0);
                }
            }
            if ($xaxis_type eq "Date/Time") {
                $jd_min = &datelabel2jdate($xmin);
                $jd_max = &datelabel2jdate($xmax);
                if ($jd_min >= $jd_max) {
                    return &pop_up_error($graph_props_menu,
                                         "The X axis minimum must be\nless than the X axis maximum.");
                }
            } else {
                if (! defined($xmin) || $xmin eq "" || ! defined($xmax) || $xmax eq "" || $xmin >= $xmax) {
                    return &pop_up_error($graph_props_menu,
                                         "The X axis minimum must be\nless than the X axis maximum.");
                }
            }
            $ymajor = "auto" if (! defined($ymajor) || $ymajor eq "");
            if ($ymajor ne "auto") {
                $ymajor = "auto" if ($ymajor+0 <= 0);
            }
            if (! $ymax_auto && (! defined($ymin) || $ymin eq "" ||
                                 ! defined($ymax) || $ymax eq "" || $ymin >= $ymax)) {
                return &pop_up_error($graph_props_menu,
                                     "The Y axis minimum must be\nless than the Y axis maximum.");
            }
            if ($yfirst ne "" && (($ymin ne "" && $yfirst < $ymin) || ($ymin eq "" && $yfirst < 0.))) {
                return &pop_up_error($graph_props_menu,
                                     "The first Y axis label should not\nbe less than the Y axis minimum.");
            }
            $ymin  = 0     if (! defined($ymin)  || $ymin  eq "");
            $ybase = $ymin if (! defined($ybase) || $ybase eq "");
            if ($ymax_auto) {
                if ($yaxis_units eq "miles") {
                    $dist2 = $gr_props{$id}{d_km} *3280.4/5280. +$ybase;
                } else {
                    $dist2 = $gr_props{$id}{d_km} +$ybase;
                }
                if ($dist2 <= $ymin) {
                    return &pop_up_error($graph_props_menu, "The Y axis minimum must be less\n"
                                                          . "than the automatic Y axis maximum.");
                }
            }
        } else {                                             # Y: date/time, X: distance
            $ymaj_auto = 0 if ($yaxis_type eq "Julian Date");
            if (! $ymaj_auto) {
                $ymajor = "auto" if (! defined($ymajor) || $ymajor eq "");
                if ($ymajor ne "auto") {
                    $ymajor = "auto" if ($ymajor+0 <= 0);
                }
            }
            if ($yaxis_type eq "Date/Time") {
                $jd_min = &datelabel2jdate($ymin);
                $jd_max = &datelabel2jdate($ymax);
                if ($jd_min >= $jd_max) {
                    return &pop_up_error($graph_props_menu,
                                         "The Y axis minimum must be\nless than the Y axis maximum.");
                }
            } else {
                if (! defined($ymin) || $ymin eq "" || ! defined($ymax) || $ymax eq "" || $ymin >= $ymax) {
                    return &pop_up_error($graph_props_menu,
                                         "The Y axis minimum must be\nless than the Y axis maximum.");
                }
            }
            $xmajor = "auto" if (! defined($xmajor) || $xmajor eq "");
            if ($xmajor ne "auto") {
                $xmajor = "auto" if ($xmajor+0 <= 0);
            }
            if (! $xmax_auto && (! defined($xmin) || $xmin eq "" ||
                                 ! defined($xmax) || $xmax eq "" || $xmin >= $xmax)) {
                return &pop_up_error($graph_props_menu,
                                     "The X axis minimum must be\nless than the X axis maximum.");
            }
            if ($xfirst ne "" && (($xmin ne "" && $xfirst < $xmin) || ($xmin eq "" && $xfirst < 0.))) {
                return &pop_up_error($graph_props_menu,
                                     "The first X axis label should not\nbe less than the X axis minimum.");
            }
            $xmin  = 0     if (! defined($xmin)  || $xmin  eq "");
            $xbase = $xmin if (! defined($xbase) || $xbase eq "");
            if ($xmax_auto) {
                if ($xaxis_units eq "miles") {
                    $dist2 = $gr_props{$id}{d_km} *3280.4/5280. +$xbase;
                } else {
                    $dist2 = $gr_props{$id}{d_km} +$xbase;
                }
                if ($dist2 <= $xmin) {
                    return &pop_up_error($graph_props_menu, "The X axis minimum must be less\n"
                                                          . "than the automatic X axis maximum.");
                }
            }
        }
    } else {
        if ($props{$id}{meta} =~ /data_profile_cmap|w2_profile_cmap|time_series/) {
            $xmaj_auto = 0 if ($xaxis_type eq "Julian Date");
            if (! $xmaj_auto) {
                $xmajor = "auto" if (! defined($xmajor) || $xmajor eq "");
                if ($xmajor ne "auto") {
                    $xmajor = "auto" if ($xmajor+0 <= 0);
                }
            }
        } else {
            $xmajor = "auto" if (! defined($xmajor) || $xmajor eq "");
            if ($xmajor ne "auto") {
                $xmajor = "auto" if ($xmajor+0 <= 0);
            }
        }
        if ($props{$id}{meta} =~ /(data_profile_cmap|w2_profile_cmap|time_series)/
               && $xaxis_type eq "Date/Time") {
            $jd_min = &datelabel2jdate($xmin);
            $jd_max = &datelabel2jdate($xmax);
            if ($jd_min >= $jd_max) {
                return &pop_up_error($graph_props_menu,
                                     "The X axis minimum must be\nless than the X axis maximum.");
            }
        } else {
            if (! $xmax_auto && (! defined($xmin) || $xmin eq "" ||
                                 ! defined($xmax) || $xmax eq "" || $xmin >= $xmax)) {
                return &pop_up_error($graph_props_menu,
                                     "The X axis minimum must be\nless than the X axis maximum.");
            }
            if ($props{$id}{meta} =~ /w2_slice|w2_wlevels/) {
                if ($xfirst ne "" && (($xmin ne "" && $xfirst < $xmin) || ($xmin eq "" && $xfirst < 0.))) {
                    return &pop_up_error($graph_props_menu, "The first X axis label should not\n"
                                                          . "be less than the X axis minimum.");
                }
                $xmin  = 0     if (! defined($xmin)  || $xmin  eq "");
                $xbase = $xmin if (! defined($xbase) || $xbase eq "");
                if ($xmax_auto) {
                    if ($xaxis_units eq "miles") {
                        $dist2 = $gr_props{$id}{x_km} *3280.4/5280. +$xbase;
                    } else {
                        $dist2 = $gr_props{$id}{x_km} +$xbase;
                    }
                    if ($dist2 <= $xmin) {
                        return &pop_up_error($graph_props_menu, "The X axis minimum must be less\n"
                                                              . "than the automatic X axis maximum.");
                    }
                }
            }
        }
        if (! defined($ymin) || ! defined($ymax) || $ymin eq "" || $ymax eq "" || $ymin >= $ymax) {
            return &pop_up_error($graph_props_menu,
                                 "The Y axis minimum must be\nless than the Y axis maximum.");
        }
        $ymajor = "auto" if (! defined($ymajor) || $ymajor eq "");
        if ($ymajor ne "auto") {
            $ymajor = "auto" if ($ymajor+0 <= 0);
        }
    }

    $gr_props{$id}{redraw} = 0;
    if ($props{$id}{meta} =~ /data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone/) {
        if ($props{$id}{meta} ne "w2_wlevels" && $gr_props{$id}{ytype} ne $yaxis_type) {
            $gr_props{$id}{redraw} = 1;
        } elsif ($gr_props{$id}{yunits} ne $yaxis_units) {
            if ($yaxis_units eq "feet") {
                if (abs($gr_props{$id}{ymax} *3.28084 -$ymax) > 0.1 ||
                    abs($gr_props{$id}{ymin} *3.28084 -$ymin) > 0.1) {
                    $gr_props{$id}{redraw} = 1;
                }
            } else {
                if (abs($gr_props{$id}{ymax} -3.28084 *$ymax) > 0.1 ||
                    abs($gr_props{$id}{ymin} -3.28084 *$ymin) > 0.1) {
                    $gr_props{$id}{redraw} = 1;
                }
            }
            if (! $gr_props{$id}{redraw}) {
                $gr_props{$id}{ymin} = $ymin;  # prevent later comparison from setting redraw
                $gr_props{$id}{ymax} = $ymax;
            }
        }
        $refresh_info = 1 if ($gr_props{$id}{yunits} ne $yaxis_units);
        $gr_props{$id}{ytype}  = $yaxis_type if ($props{$id}{meta} ne "w2_wlevels");
        $gr_props{$id}{yunits} = $yaxis_units;
    }
    if ($props{$id}{meta} =~ /^(data_profile|w2_profile|w2_profile_matrix|vert_wd_zone)$/) {
        if (($status == 0 &&   $gr_props{$id}{add_cs}) ||
            ($status  > 0 && ! $gr_props{$id}{add_cs})) {
            $gr_props{$id}{redraw} = 1;
        }
        $gr_props{$id}{add_cs}    = ($status  > 0) ? 1 : 0;
        $gr_props{$id}{cs_hide}   = ($status == 2) ? 1 : 0;
        $gr_props{$id}{gs_size}   = $gs_size;
        $gr_props{$id}{gs_weight} = $gs_weight;
        if ($props{$id}{meta} eq "w2_profile_matrix") {
            $gr_props{$id}{gs_pos}   = $gs_pos;
            $gr_props{$id}{gs_fmt}   = $gs_fmt;
            $gr_props{$id}{gs_color} = $gs_color;
            $gr_props{$id}{gs_edge}  = $gs_edge;
            $gr_props{$id}{gs_edgec} = $gs_edgec;
            $gr_props{$id}{gs_fill}  = $gs_fill;
            $gr_props{$id}{gs_fillc} = $gs_fillc;
        }
        if ($props{$id}{meta} eq "vert_wd_zone") {
            $gr_props{$id}{redraw} = 1 if ($gr_props{$id}{qunits} ne $qaxis_units);
            $refresh_info          = 1 if ($gr_props{$id}{qunits} ne $qaxis_units);
            $gr_props{$id}{qunits} = $qaxis_units;
            $gr_props{$id}{redraw} = 1 if ($props{$id}{wt_units} ne $wt_units);
            $refresh_info          = 1 if ($props{$id}{wt_units} ne $wt_units);
            $props{$id}{wt_units}  = $wt_units;

        } elsif ($props{$id}{meta} =~ /^(data_profile|w2_profile|w2_profile_matrix)$/
                 && $props{$id}{parm} eq "Temperature") {
            $gr_props{$id}{redraw}  = 1 if ($props{$id}{parm_units} ne $wt_units);
            $refresh_info           = 1 if ($props{$id}{parm_units} ne $wt_units);
            $props{$id}{parm_units} = $wt_units;
        }
        if ($props{$id}{meta} =~ /w2_profile/) {
            $gr_props{$id}{redraw}   = 1 if ($gr_props{$id}{pr_style} ne $pr_style ||
                                             $gr_props{$id}{pr_linec} ne $pr_linec ||
                                             $gr_props{$id}{pr_linew} != $pr_linew);
            $gr_props{$id}{pr_style} = $pr_style;
            $gr_props{$id}{pr_linec} = $pr_linec;
            $gr_props{$id}{pr_linew} = $pr_linew;
            if ($gr_props{$id}{add_cs}) {
                $gr_props{$id}{redraw}   = 1 if ($gr_props{$id}{pc_style} ne $pc_style);
                $gr_props{$id}{pc_style} = $pc_style;
            }
            if ($props{$id}{meta} =~ /^(w2_profile|w2_profile_matrix)$/ && defined($props{$id}{ref_file})) {
                $gr_props{$id}{redraw} = 1 if ($props{$id}{ref_color} ne $ref_color ||
                                               $props{$id}{ref_size}  ne $ref_size  ||
                                               $props{$id}{ref_linew} != $ref_linew);
                $props{$id}{ref_color} = $ref_color;
                $props{$id}{ref_size}  = $ref_size;
                $props{$id}{ref_linew} = $ref_linew;
            }
        }

    } elsif ($props{$id}{meta} eq "w2_outflow") {
        if ($props{$id}{add_parm}) {
            if (($status == 0 &&   $gr_props{$id}{add_cs}) ||
                ($status  > 0 && ! $gr_props{$id}{add_cs})) {
                $gr_props{$id}{redraw} = 1;
            }
            $gr_props{$id}{add_cs}    = ($status  > 0) ? 1 : 0;
            $gr_props{$id}{cs_hide}   = ($status == 2) ? 1 : 0;
            $gr_props{$id}{gs_size}   = $gs_size;
            $gr_props{$id}{gs_weight} = $gs_weight;
            if ($props{$id}{parm} eq "Temperature") {
                $gr_props{$id}{redraw}  = 1 if ($props{$id}{parm_units} ne $wt_units);
                $refresh_info           = 1 if ($props{$id}{parm_units} ne $wt_units);
                $props{$id}{parm_units} = $wt_units;
            }
            if ($gr_props{$id}{add_cs}) {
                $gr_props{$id}{redraw}   = 1 if ($gr_props{$id}{pc_style} ne $pc_style);
                $gr_props{$id}{pc_style} = $pc_style;
            }
        }
        $gr_props{$id}{redraw} = 1 if ($gr_props{$id}{qunits} ne $qaxis_units);
        $refresh_info          = 1 if ($gr_props{$id}{qunits} ne $qaxis_units);
        $gr_props{$id}{qunits} = $qaxis_units;

    } elsif ($props{$id}{meta} =~ /w2_slice|w2_wlevels/) {
        if ($props{$id}{meta} eq "w2_slice") {
            if ($props{$id}{parm} eq "Temperature") {
                $gr_props{$id}{redraw}  = 1 if ($props{$id}{parm_units} ne $wt_units);
                $refresh_info           = 1 if ($props{$id}{parm_units} ne $wt_units);
                $props{$id}{parm_units} = $wt_units;
            }
            $gr_props{$id}{cs_hide}   = $status;
            $gr_props{$id}{xflip_img} = ($gr_props{$id}{xflip} != $xaxis_flip) ? 1 : 0;
            $gr_props{$id}{redraw}    = 1 if ($gr_props{$id}{pc_style} ne $pc_style);
            $gr_props{$id}{pc_style}  = $pc_style;
        } else {
            $gr_props{$id}{redraw}    = 1 if ($gr_props{$id}{xflip}    != $xaxis_flip ||
                                              $gr_props{$id}{wl_color} ne $wl_color   ||
                                              $gr_props{$id}{wl_style} ne $wl_style   ||
                                              $gr_props{$id}{wl_grid}  != $wl_grid    ||
                                              $gr_props{$id}{wl_gridc} ne $wl_gridc);
            $gr_props{$id}{wl_color}  = $wl_color;
            $gr_props{$id}{wl_style}  = $wl_style;
            $gr_props{$id}{wl_grid}   = $wl_grid;
            $gr_props{$id}{wl_gridc}  = $wl_gridc;
        }
        if (! $gr_props{$id}{redraw}) {
            $dist1  = $gr_props{$id}{xmin} -$gr_props{$id}{xbase};
            $dist1 *= 5280./3280.84 if ($gr_props{$id}{xunits} eq "miles");
            $dist2  = $xmin -$xbase;
            $dist2 *= 5280./3280.84 if ($xaxis_units eq "miles");
            if (abs($dist1 -$dist2) > 0.002) {
                $gr_props{$id}{redraw} = 1;
            } else {
                $dist1  = $gr_props{$id}{xmax} -$gr_props{$id}{xmin};
                $dist1 *= 5280./3280.84 if ($gr_props{$id}{xunits} eq "miles");
                if (! $xmax_auto) {
                    $dist2  = $xmax -$xmin;
                    $dist2 *= 5280./3280.84 if ($xaxis_units eq "miles");
                } else {
                    if ($xaxis_units eq "miles") {
                        $dist2 = $gr_props{$id}{x_km} -($xmin -$xbase) *5280./3280.84;
                    } else {
                        $dist2 = $gr_props{$id}{x_km} -($xmin -$xbase);
                    }
                }
                $gr_props{$id}{redraw} = 1 if (abs($dist1 -$dist2) > 0.002);
            }
        }
        $refresh_info = 1 if ($gr_props{$id}{xunits} ne $xaxis_units);
        $gr_props{$id}{xunits}    = $xaxis_units;
        $gr_props{$id}{xbase}     = $xbase;
        $gr_props{$id}{xfirst}    = $xfirst;
        $gr_props{$id}{xflip}     = $xaxis_flip;
        $gr_props{$id}{xmax_auto} = $xmax_auto;
        $gr_props{$id}{gs_size}   = $gs_size;
        $gr_props{$id}{gs_weight} = $gs_weight;

        $smajor = "auto" if (! defined($smajor) || $smajor eq "");
        if ($smajor ne "auto") {
            $smajor = "auto" if ($smajor+0 <= 0);
        }
        $gr_props{$id}{stype}     = $stype;
        $gr_props{$id}{sfont}     = $sfont;
        $gr_props{$id}{st_size}   = $st_size;
        $gr_props{$id}{st_weight} = $st_weight;
        $gr_props{$id}{sl_size}   = $sl_size;
        $gr_props{$id}{sl_weight} = $sl_weight;
        $gr_props{$id}{stic_loc}  = $stic_loc;
        $gr_props{$id}{smajor}    = $smajor;
        $gr_props{$id}{spr_tics}  = $spr_tics;
        $gr_props{$id}{sop_tics}  = $sop_tics;
        $gr_props{$id}{sgrid}     = $sgrid;
        $gr_props{$id}{sgrid_col} = $sgrid_col;
        $gr_props{$id}{bgrid}     = $bgrid;
        $gr_props{$id}{bgrid_col} = $bgrid_col;
        $gr_props{$id}{stitle}    = $stitle;

    } elsif ($props{$id}{meta} eq "w2_tdmap") {
        $gr_props{$id}{cs_hide}   = $status;
        $gr_props{$id}{gstitle}   = $gstitle;
        $gr_props{$id}{gs_size}   = $gs_size;
        $gr_props{$id}{gs_weight} = $gs_weight;
        if ($props{$id}{parm} eq "Temperature") {
            $gr_props{$id}{redraw}  = 1 if ($props{$id}{parm_units} ne $wt_units);
            $refresh_info           = 1 if ($props{$id}{parm_units} ne $wt_units);
            $props{$id}{parm_units} = $wt_units;
        }
        if ($gr_props{$id}{date_axis} eq "X") {     # X: date/time, Y: distance
            $gr_props{$id}{datefmt} = $datefmt;
            if ($gr_props{$id}{ttype} ne $xaxis_type) {
                if ($xaxis_type eq "Date/Time") {
                    $base_jd = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
                    $datemin = &jdate2datelabel($gr_props{$id}{tmin} +$base_jd -1, "Mon-DD-YYYY");
                    $datemax = &jdate2datelabel($gr_props{$id}{tmax} +$base_jd -1, "Mon-DD-YYYY");
                    if ($xmin ne $datemin || $xmax ne $datemax) {
                        $gr_props{$id}{redraw} = 1;
                    } else {
                        $gr_props{$id}{tmin} = $xmin;
                        $gr_props{$id}{tmax} = $xmax;
                    }
                } else {
                    $base_jd = &date2jdate(sprintf("%04d%02d%02d", $byear, 1, 1));
                    $datemin = &jdate2datelabel($xmin +$base_jd -1, "Mon-DD-YYYY");
                    $datemax = &jdate2datelabel($xmax +$base_jd -1, "Mon-DD-YYYY");
                    if ($gr_props{$id}{tmin} ne $datemin || $gr_props{$id}{tmax} ne $datemax) {
                        $gr_props{$id}{redraw} = 1;
                    } else {
                        $gr_props{$id}{tmin} = $xmin;
                        $gr_props{$id}{tmax} = $xmax;
                    }
                }
            } elsif ($xaxis_type eq "Julian Date") {
                $base_jd    = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
                $jd_min_old = $gr_props{$id}{tmin} + $base_jd -1;
                $jd_max_old = $gr_props{$id}{tmax} + $base_jd -1;
                $base_jd    = &date2jdate(sprintf("%04d%02d%02d", $byear, 1, 1));
                $jd_min     = $xmin + $base_jd -1;
                $jd_max     = $xmax + $base_jd -1;
                if ($jd_min != $jd_min_old || $jd_max != $jd_max_old) {
                    $gr_props{$id}{redraw} = 1;
                } else {
                    $gr_props{$id}{tmin} = $xmin;
                    $gr_props{$id}{tmax} = $xmax;
                }
            }
            $gr_props{$id}{ttype}     = $xaxis_type;
            $gr_props{$id}{base_yr}   = $byear;
            $gr_props{$id}{tflip_img} = ($gr_props{$id}{tflip} != $xaxis_flip) ? 1 : 0;
            $gr_props{$id}{tflip}     = $xaxis_flip;
            $xmajor = "auto" if ($xmaj_auto);

            if (! $gr_props{$id}{redraw}) {
                $dist1  = $gr_props{$id}{dmin} -$gr_props{$id}{dbase};
                $dist1 *= 5280./3280.84 if ($gr_props{$id}{dunits} eq "miles");
                $dist2  = $ymin -$ybase;
                $dist2 *= 5280./3280.84 if ($yaxis_units eq "miles");
                if (abs($dist1 -$dist2) > 0.002) {
                    $gr_props{$id}{redraw} = 1;
                } else {
                    $dist1  = $gr_props{$id}{dmax} -$gr_props{$id}{dmin};
                    $dist1 *= 5280./3280.84 if ($gr_props{$id}{dunits} eq "miles");
                    if (! $ymax_auto) {
                        $dist2  = $ymax -$ymin;
                        $dist2 *= 5280./3280.84 if ($yaxis_units eq "miles");
                    } else {
                        if ($yaxis_units eq "miles") {
                            $dist2 = $gr_props{$id}{d_km} -($ymin -$ybase) *5280./3280.84;
                        } else {
                            $dist2 = $gr_props{$id}{d_km} -($ymin -$ybase);
                        }
                    }
                    $gr_props{$id}{redraw} = 1 if (abs($dist1 -$dist2) > 0.002);
                }
            }
            $refresh_info = 1 if ($gr_props{$id}{dunits} ne $yaxis_units);

        } else {                                    # Y: date/time, X: distance
            $gr_props{$id}{datefmt} = $yformat;
            if ($gr_props{$id}{ttype} ne $yaxis_type) {
                if ($yaxis_type eq "Date/Time") {
                    $base_jd = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
                    $datemin = &jdate2datelabel($gr_props{$id}{tmin} +$base_jd -1, "Mon-DD-YYYY");
                    $datemax = &jdate2datelabel($gr_props{$id}{tmax} +$base_jd -1, "Mon-DD-YYYY");
                    if ($ymin ne $datemin || $ymax ne $datemax) {
                        $gr_props{$id}{redraw} = 1;
                    } else {
                        $gr_props{$id}{tmin} = $ymin;
                        $gr_props{$id}{tmax} = $ymax;
                    }
                } else {
                    $base_jd = &date2jdate(sprintf("%04d%02d%02d", $byear, 1, 1));
                    $datemin = &jdate2datelabel($ymin +$base_jd -1, "Mon-DD-YYYY");
                    $datemax = &jdate2datelabel($ymax +$base_jd -1, "Mon-DD-YYYY");
                    if ($gr_props{$id}{tmin} ne $datemin || $gr_props{$id}{tmax} ne $datemax) {
                        $gr_props{$id}{redraw} = 1;
                    } else {
                        $gr_props{$id}{tmin} = $ymin;
                        $gr_props{$id}{tmax} = $ymax;
                    }
                }
            } elsif ($yaxis_type eq "Julian Date") {
                $base_jd    = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
                $jd_min_old = $gr_props{$id}{tmin} + $base_jd -1;
                $jd_max_old = $gr_props{$id}{tmax} + $base_jd -1;
                $base_jd    = &date2jdate(sprintf("%04d%02d%02d", $byear, 1, 1));
                $jd_min     = $ymin + $base_jd -1;
                $jd_max     = $ymax + $base_jd -1;
                if ($jd_min != $jd_min_old || $jd_max != $jd_max_old) {
                    $gr_props{$id}{redraw} = 1;
                } else {
                    $gr_props{$id}{tmin} = $ymin;
                    $gr_props{$id}{tmax} = $ymax;
                }
            }
            $gr_props{$id}{ttype}     = $yaxis_type;
            $gr_props{$id}{base_yr}   = $byear;
            $gr_props{$id}{tflip_img} = ($gr_props{$id}{tflip} != $yaxis_flip) ? 1 : 0;
            $gr_props{$id}{tflip}     = $yaxis_flip;
            $ymajor = "auto" if ($ymaj_auto);

            if (! $gr_props{$id}{redraw}) {
                $dist1  = $gr_props{$id}{dmin} -$gr_props{$id}{dbase};
                $dist1 *= 5280./3280.84 if ($gr_props{$id}{dunits} eq "miles");
                $dist2  = $xmin -$xbase;
                $dist2 *= 5280./3280.84 if ($xaxis_units eq "miles");
                if (abs($dist1 -$dist2) > 0.002) {
                    $gr_props{$id}{redraw} = 1;
                } else {
                    $dist1  = $gr_props{$id}{dmax} -$gr_props{$id}{dmin};
                    $dist1 *= 5280./3280.84 if ($gr_props{$id}{dunits} eq "miles");
                    if (! $xmax_auto) {
                        $dist2  = $xmax -$xmin;
                        $dist2 *= 5280./3280.84 if ($xaxis_units eq "miles");
                    } else {
                        if ($xaxis_units eq "miles") {
                            $dist2 = $gr_props{$id}{d_km} -($xmin -$xbase) *5280./3280.84;
                        } else {
                            $dist2 = $gr_props{$id}{d_km} -($xmin -$xbase);
                        }
                    }
                    $gr_props{$id}{redraw} = 1 if (abs($dist1 -$dist2) > 0.002);
                }
            }
            $refresh_info = 1 if ($gr_props{$id}{dunits} ne $xaxis_units);
        }

    } elsif ($props{$id}{meta} =~ /data_profile_cmap|w2_profile_cmap/) {
        $gr_props{$id}{datefmt} = $datefmt;
        $gr_props{$id}{cs_hide} = $status;
        if ($gr_props{$id}{xtype} ne $xaxis_type) {
            if ($xaxis_type eq "Date/Time") {
                $base_jd = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
                $datemin = &jdate2datelabel($gr_props{$id}{xmin} +$base_jd -1, "Mon-DD-YYYY");
                $datemax = &jdate2datelabel($gr_props{$id}{xmax} +$base_jd -1, "Mon-DD-YYYY");
                if ($xmin ne $datemin || $xmax ne $datemax) {
                    $gr_props{$id}{redraw} = 1;
                } else {
                    $gr_props{$id}{xmin} = $xmin;
                    $gr_props{$id}{xmax} = $xmax;
                }
            } else {
                $base_jd = &date2jdate(sprintf("%04d%02d%02d", $byear, 1, 1));
                $datemin = &jdate2datelabel($xmin +$base_jd -1, "Mon-DD-YYYY");
                $datemax = &jdate2datelabel($xmax +$base_jd -1, "Mon-DD-YYYY");
                if ($gr_props{$id}{xmin} ne $datemin || $gr_props{$id}{xmax} ne $datemax) {
                    $gr_props{$id}{redraw} = 1;
                } else {
                    $gr_props{$id}{xmin} = $xmin;
                    $gr_props{$id}{xmax} = $xmax;
                }
            }
        } elsif ($xaxis_type eq "Julian Date") {
            $base_jd    = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
            $jd_min_old = $gr_props{$id}{xmin} + $base_jd -1;
            $jd_max_old = $gr_props{$id}{xmax} + $base_jd -1;
            $base_jd    = &date2jdate(sprintf("%04d%02d%02d", $byear, 1, 1));
            $jd_min     = $xmin + $base_jd -1;
            $jd_max     = $xmax + $base_jd -1;
            if ($jd_min != $jd_min_old || $jd_max != $jd_max_old) {
                $gr_props{$id}{redraw} = 1;
            } else {
                $gr_props{$id}{xmin} = $xmin;
                $gr_props{$id}{xmax} = $xmax;
            }
        }
        $gr_props{$id}{xtype}     = $xaxis_type;
        $gr_props{$id}{base_yr}   = $byear;
        $gr_props{$id}{dateline}  = $dateline;
        $gr_props{$id}{datelinec} = $datelinec;
        if ($props{$id}{parm} eq "Temperature") {
            $gr_props{$id}{redraw}  = 1 if ($props{$id}{parm_units} ne $wt_units);
            $refresh_info           = 1 if ($props{$id}{parm_units} ne $wt_units);
            $props{$id}{parm_units} = $wt_units;
        }
        $xmajor = "auto" if ($xmaj_auto);
        if ($props{$id}{meta} eq "w2_profile_cmap") {
            $gr_props{$id}{redraw}   = 1 if ($gr_props{$id}{pc_style} ne $pc_style);
            $gr_props{$id}{pc_style} = $pc_style;
        }

    } elsif ($props{$id}{meta} =~ /time_series/) {
        $xmajor = "auto" if ($xmaj_auto);
        $gr_props{$id}{datefmt}   = $datefmt;
        $gr_props{$id}{legtitle}  = $legtitle;
        $gr_props{$id}{legfont}   = $legfont;
        $gr_props{$id}{lt_size}   = $lt_size;
        $gr_props{$id}{lt_weight} = $lt_weight;
        $gr_props{$id}{le_size}   = $le_size;
        $gr_props{$id}{le_weight} = $le_weight;
        $gr_props{$id}{le_edge}   = $le_edge;
        $gr_props{$id}{le_edgec}  = $le_edgec;
        $gr_props{$id}{le_fill}   = $le_fill;
        $gr_props{$id}{le_fillc}  = $le_fillc;
        $gr_props{$id}{gridx}     = $gridx;
        $gr_props{$id}{gridy}     = $gridy;
        $gr_props{$id}{gridwidth} = $gridwidth;
        $gr_props{$id}{gridcolor} = $gridcolor;
        if ($gr_props{$id}{xtype} ne $xaxis_type) {
            if ($xaxis_type eq "Date/Time") {
                $base_jd = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
                $datemin = &jdate2datelabel($gr_props{$id}{xmin} +$base_jd -1, "Mon-DD-YYYY");
                $datemax = &jdate2datelabel($gr_props{$id}{xmax} +$base_jd -1, "Mon-DD-YYYY");
                if ($xmin ne $datemin || $xmax ne $datemax) {
                    $gr_props{$id}{redraw} = 1;
                } else {
                    $gr_props{$id}{xmin} = $xmin;
                    $gr_props{$id}{xmax} = $xmax;
                }
            } else {
                $base_jd = &date2jdate(sprintf("%04d%02d%02d", $byear, 1, 1));
                $datemin = &jdate2datelabel($xmin +$base_jd -1, "Mon-DD-YYYY");
                $datemax = &jdate2datelabel($xmax +$base_jd -1, "Mon-DD-YYYY");
                if ($gr_props{$id}{xmin} ne $datemin || $gr_props{$id}{xmax} ne $datemax) {
                    $gr_props{$id}{redraw} = 1;
                } else {
                    $gr_props{$id}{xmin} = $xmin;
                    $gr_props{$id}{xmax} = $xmax;
                }
            }
        } elsif ($xaxis_type eq "Julian Date") {
            $base_jd    = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
            $jd_min_old = $gr_props{$id}{xmin} + $base_jd -1;
            $jd_max_old = $gr_props{$id}{xmax} + $base_jd -1;
            $base_jd    = &date2jdate(sprintf("%04d%02d%02d", $byear, 1, 1));
            $jd_min     = $xmin + $base_jd -1;
            $jd_max     = $xmax + $base_jd -1;
            if ($jd_min != $jd_min_old || $jd_max != $jd_max_old) {
                $gr_props{$id}{redraw} = 1;
            } else {
                $gr_props{$id}{xmin} = $xmin;
                $gr_props{$id}{xmax} = $xmax;
            }
        }
        $gr_props{$id}{xtype}     = $xaxis_type;
        $gr_props{$id}{base_yr}   = $byear;
        $gr_props{$id}{dateline}  = $dateline;
        $gr_props{$id}{datelinec} = $datelinec;

        if ($props{$id}{meta} eq "linked_time_series") {
            %parms                = %{ $props{$id}{ts_parms} };
            @ts_show              = @{ $ts_show_ref  };
            @ts_width             = @{ $ts_width_ref };
            @ts_color             = @{ $ts_color_ref };
            $parms{show}          = [ @ts_show  ];
            $parms{width}         = [ @ts_width ];
            $parms{color}         = [ @ts_color ];
            $props{$id}{ts_parms} = { %parms };
        }

        if (defined($props{$id}{add_ts_parms})) {
            @add_ts_show   = @{ $add_ts_show_ref   };
            @add_ts_setnum = @{ $add_ts_setnum_ref };
            @add_ts_width  = @{ $add_ts_width_ref  };
            @add_ts_color  = @{ $add_ts_color_ref  };
            @add_ts_text   = @{ $add_ts_text_ref   };
            @add_ts_file   = @{ $add_ts_file_ref   };
            @add_ts_ftype  = @{ $add_ts_ftype_ref  };
            @add_ts_lines  = @{ $add_ts_lines_ref  };
            @add_ts_param  = @{ $add_ts_param_ref  };
            @add_ts_byear  = @{ $add_ts_byear_ref  };
            @add_ts_tzoff  = @{ $add_ts_tzoff_ref  };
            @add_ts_seg    = @{ $add_ts_seg_ref    };
            @add_ts_ctype  = @{ $add_ts_ctype_ref  };
            @add_ts_limits = @{ $add_ts_limits_ref };
            @add_ts_tsdata = @{ $add_ts_tsdata_ref };
            @add_ts_delete = @{ $add_ts_delete_ref };

#           Delete any datasets marked for deletion, and re-order the others
            $gtag = "graph" . $id;
            for ($i=$#add_ts_delete; $i>=0; $i--) {
                if ($add_ts_delete[$i]) {
                    $refresh_menu = 1;
                    $refresh_info = 1;
                    $canvas->delete($gtag . "_dataset" . $add_ts_setnum[$i]);
                    splice (@add_ts_show,   $i, 1);
                    splice (@add_ts_setnum, $i, 1);
                    splice (@add_ts_width,  $i, 1);
                    splice (@add_ts_color,  $i, 1);
                    splice (@add_ts_text,   $i, 1);
                    splice (@add_ts_file,   $i, 1);
                    splice (@add_ts_ftype,  $i, 1);
                    splice (@add_ts_lines,  $i, 1);
                    splice (@add_ts_param,  $i, 1);
                    splice (@add_ts_byear,  $i, 1);
                    splice (@add_ts_tzoff,  $i, 1);
                    splice (@add_ts_seg,    $i, 1);
                    splice (@add_ts_ctype,  $i, 1);
                    splice (@add_ts_limits, $i, 1);
                    splice (@add_ts_tsdata, $i, 1);
                    for ($ii=$i; $ii<=$#add_ts_show; $ii++) {
                        $old_tag = $gtag . "_dataset" . $add_ts_setnum[$ii];
                        $add_ts_setnum[$ii]--;
                        $new_tag = $gtag . "_dataset" . $add_ts_setnum[$ii];
                        $canvas->addtag($new_tag, withtag => $old_tag);
                        $canvas->dtag($old_tag);
                    }
                }
            }
            %add_ts_parms             = ();
            $add_ts_parms{ts_setnum}  = [ @add_ts_setnum ];
            $add_ts_parms{ts_show}    = [ @add_ts_show   ];
            $add_ts_parms{ts_width}   = [ @add_ts_width  ];
            $add_ts_parms{ts_color}   = [ @add_ts_color  ];
            $add_ts_parms{ts_text}    = [ @add_ts_text   ];
            $add_ts_parms{ts_file}    = [ @add_ts_file   ];
            $add_ts_parms{ts_ftype}   = [ @add_ts_ftype  ];
            $add_ts_parms{ts_lines}   = [ @add_ts_lines  ];
            $add_ts_parms{ts_param}   = [ @add_ts_param  ];
            $add_ts_parms{ts_byear}   = [ @add_ts_byear  ];
            $add_ts_parms{ts_tzoff}   = [ @add_ts_tzoff  ];
            $add_ts_parms{ts_seg}     = [ @add_ts_seg    ];
            $add_ts_parms{ts_ctype}   = [ @add_ts_ctype  ];
            $add_ts_parms{ts_limits}  = [ @add_ts_limits ];
            $add_ts_parms{ts_data}    = [ @add_ts_tsdata ];
            $props{$id}{add_ts_parms} = { %add_ts_parms  };

            $gr_props{$id}{redraw} = 1 if ($sets_swapped && $#add_ts_setnum > 0);
            if ($#add_ts_setnum >= 0) {
                $gr_props{$id}{redraw}  = 1 if ($gap_tol != $gr_props{$id}{gap_tol});
                $gr_props{$id}{gap_tol} = $gap_tol;
            }
        }
    }
    if (defined($gr_props{$id}{add_cs}) && $gr_props{$id}{add_cs}) {
        $gr_props{$id}{redraw} = 1 if ($gr_props{$id}{cscheme1} ne $cs1    ||
                                       $gr_props{$id}{cscheme2} ne $cs2    ||
                                       $gr_props{$id}{ncolors}  != $nc     ||
                                       $gr_props{$id}{cs_rev}   != $rev    ||
                                       $gr_props{$id}{cs_min}   != $cs_min ||
                                       $gr_props{$id}{cs_max}   != $cs_max
                                      );
    }
    if ($props{$id}{meta} =~ /w2_slice|w2_wlevels/) {
        $gr_props{$id}{redraw} = 1 if ($gr_props{$id}{ymin} != $ymin ||
                                       $gr_props{$id}{ymax} != $ymax
                                      );
    } elsif ($props{$id}{meta} eq "w2_tdmap") {
        if ($gr_props{$id}{date_axis} eq "X") {
            $gr_props{$id}{redraw} = 1 if ( $gr_props{$id}{tmin} ne $xmin ||
                                            $gr_props{$id}{tmax} ne $xmax );
        } else {
            $gr_props{$id}{redraw} = 1 if ( $gr_props{$id}{tmin} ne $ymin ||
                                            $gr_props{$id}{tmax} ne $ymax );
        }
    } elsif ($props{$id}{meta} =~ /(data_profile_cmap|w2_profile_cmap|time_series)/) {
        $gr_props{$id}{redraw} = 1 if ($gr_props{$id}{xmin} ne $xmin ||
                                       $gr_props{$id}{xmax} ne $xmax ||
                                       $gr_props{$id}{ymin} != $ymin ||
                                       $gr_props{$id}{ymax} != $ymax
                                      );
    } else {
        $gr_props{$id}{redraw} = 1 if ($gr_props{$id}{xmin} != $xmin ||
                                       $gr_props{$id}{xmax} != $xmax ||
                                       $gr_props{$id}{ymin} != $ymin ||
                                       $gr_props{$id}{ymax} != $ymax
                                      );
    }

    if (defined($gr_props{$id}{add_cs})) {
        $gr_props{$id}{cs_link}   = $cs_link;
        $gr_props{$id}{cscheme1}  = $cs1;
        $gr_props{$id}{cscheme2}  = $cs2;
        $gr_props{$id}{ncolors}   = $nc;
        $gr_props{$id}{cs_rev}    = $rev;
        $gr_props{$id}{cs_min}    = $cs_min;
        $gr_props{$id}{cs_max}    = $cs_max;
        $gr_props{$id}{cs_major}  = $cs_major;
        $gr_props{$id}{cs_width}  = $cs_width;
        $gr_props{$id}{cs_height} = $cs_height;

        $gr_props{$id}{keytitle}  = $keytitle;
        $gr_props{$id}{keyfont}   = $keyfont;
        $gr_props{$id}{kt_size}   = $kt_size;
        $gr_props{$id}{kt_weight} = $kt_weight;
        $gr_props{$id}{kn_size}   = $kn_size;
        $gr_props{$id}{kn_weight} = $kn_weight;
        $gr_props{$id}{kn_digits} = $kn_digits;

#       Update the consistency of color-scheme linkages
#       Don't check for links unless color scheme is active
        if ($props{$id}{meta} =~ /data_profile|w2_profile|w2_slice|w2_tdmap|w2_outflow|vert_wd_zone/) {
            foreach $item (@animate_ids) {
                next if ($item == $id);
                next if ($props{$item}{meta} =~ /time_series|w2_wlevels/);
                $gr_props{$item}{redraw} = 0;
            }
        }
        if ($props{$id}{meta} =~ /data_profile|w2_profile|w2_slice|w2_tdmap|w2_outflow|vert_wd_zone/
              && $gr_props{$id}{add_cs}) {
            foreach $item (@animate_ids) {
                next if ($item == $id);
                next if ($props{$item}{meta} =~ /time_series|w2_wlevels/);
                $update_cs = 0;

#               Test for same parameter and same units
                if ($cs_link == 2) {
                    if ($props{$item}{meta} =~ /w2_profile|w2_slice|w2_outflow/) {
                        if ($props{$id}{meta} =~ /w2_profile|w2_slice|w2_outflow/
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$item}{parm_div}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                        } elsif ($props{$id}{meta} eq "w2_tdmap"
                             && $props{$id}{map_type}     eq "standard"
                             && $props{$item}{parm}       eq $props{$id}{parm_sav}
                             && $props{$item}{parm_div}   eq $props{$id}{pdiv_sav}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                        } elsif ($props{$id}{meta} =~ /data_profile/
                             && $props{$id}{prof_type}    eq "standard"
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$item}{parm_div}   eq "None"
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                        } elsif ($props{$id}{meta} =~ /vert_wd_zone/
                             && $props{$item}{parm}       eq "Temperature"
                             && $props{$item}{parm_div}   eq "None"
                             && $props{$item}{parm_units} eq $props{$id}{wt_units}) {
                            $update_cs = 1;
                        }
                    } elsif ($props{$item}{meta} eq "w2_tdmap") {
                        if ($props{$id}{meta} =~ /w2_profile|w2_slice|w2_outflow/
                             && $props{$item}{map_type}   eq "standard"
                             && $props{$item}{parm_sav}   eq $props{$id}{parm}
                             && $props{$item}{pdiv_sav}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                        } elsif ($props{$id}{meta} eq "w2_tdmap"
                             && $props{$item}{map_type}   eq $props{$id}{map_type}
                             && $props{$item}{parm_sav}   eq $props{$id}{parm_sav}
                             && $props{$item}{pdiv_sav}   eq $props{$id}{pdiv_sav}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}
                             && ($props{$id}{map_type} eq "standard"
                                || ($props{$item}{parm2_sav} eq $props{$id}{parm2_sav}
                                 && $props{$item}{pdiv2_sav} eq $props{$id}{pdiv2_sav}))) {
                            $update_cs = 1;
                        } elsif ($props{$id}{meta} =~ /data_profile/
                             && $props{$item}{map_type}   eq "standard"
                             && $props{$id}{prof_type}    eq "standard"
                             && $props{$item}{parm_sav}   eq $props{$id}{parm}
                             && $props{$item}{pdiv_sav}   eq "None"
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                        } elsif ($props{$id}{meta} =~ /vert_wd_zone/
                             && $props{$item}{map_type}   eq "standard"
                             && $props{$item}{parm_sav}   eq "Temperature"
                             && $props{$item}{pdiv_sav}   eq "None"
                             && $props{$item}{parm_units} eq $props{$id}{wt_units}) {
                            $update_cs = 1;
                        }
                    } elsif ($props{$item}{meta} =~ /data_profile/) {
                        if ($props{$id}{meta} =~ /data_profile/
                             && $props{$item}{prof_type}  eq $props{$id}{prof_type}
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                        } elsif ($props{$id}{meta} =~ /w2_profile|w2_slice|w2_outflow/
                             && $props{$item}{prof_type}  eq "standard"
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$id}{parm_div}     eq "None"
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                        } elsif ($props{$id}{meta} eq "w2_tdmap"
                             && $props{$id}{map_type}     eq "standard"
                             && $props{$item}{prof_type}  eq "standard"
                             && $props{$item}{parm}       eq $props{$id}{parm_sav}
                             && $props{$id}{pdiv_sav}     eq "None"
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                        } elsif ($props{$id}{meta} =~ /vert_wd_zone/
                             && $props{$item}{prof_type}  eq "standard"
                             && $props{$item}{parm}       eq "Temperature"
                             && $props{$item}{parm_units} eq $props{$id}{wt_units}) {
                            $update_cs = 1;
                        }
                    } elsif ($props{$item}{meta} =~ /vert_wd_zone/) {
                        if ($props{$id}{meta} =~ /data_profile/
                             && $props{$id}{prof_type}  eq "standard"
                             && $props{$id}{parm}       eq "Temperature"
                             && $props{$item}{wt_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                        } elsif ($props{$id}{meta} =~ /w2_profile|w2_slice|w2_outflow/
                             && $props{$id}{parm}       eq "Temperature"
                             && $props{$id}{parm_div}   eq "None"
                             && $props{$item}{wt_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                        } elsif ($props{$id}{meta} eq "w2_tdmap"
                             && $props{$id}{map_type}   eq "standard"
                             && $props{$id}{parm_sav}   eq "Temperature"
                             && $props{$id}{pdiv_sav}   eq "None"
                             && $props{$item}{wt_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                        } elsif ($props{$id}{meta} =~ /vert_wd_zone/
                             && $props{$item}{wt_units} eq $props{$id}{wt_units}) {
                            $update_cs = 1;
                        }
                    }

#               Test for same source in addition to same parameter and same units
                } elsif ($cs_link == 1) {
                    if ($props{$item}{meta} =~ /w2_profile|w2_outflow/) {
                        if ($props{$id}{meta} =~ /w2_profile|w2_outflow/
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$item}{parm_div}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            if ($props{$item}{src_file} eq $props{$id}{src_file}) {
                                $update_cs = 1;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        } elsif (($props{$id}{meta} =~ /w2_slice/
                                  && $props{$item}{parm}       eq $props{$id}{parm}
                                  && $props{$item}{parm_div}   eq $props{$id}{parm_div}
                                  && $props{$item}{parm_units} eq $props{$id}{parm_units})
                              || ($props{$id}{meta} eq "w2_tdmap"
                                  && $props{$id}{map_type}     eq "standard"
                                  && $props{$item}{parm}       eq $props{$id}{parm_sav}
                                  && $props{$item}{parm_div}   eq $props{$id}{pdiv_sav}
                                  && $props{$item}{parm_units} eq $props{$id}{parm_units})) {
                            if ($props{$id}{src_type} =~ /Contour/i) {
                                @wbs       = split(/,/, $props{$id}{wb_list});
                                @cpl_files = @{ $props{$id}{cpl_files} };
                                for ($n=0; $n<=$#wbs; $n++) {
                                    if ($cpl_files[$n] eq $props{$item}{src_file}) {
                                        $update_cs = 1;
                                        last;
                                    }
                                }
                            } elsif ($props{$id}{src_type} =~ /Vector/i) {
                                $update_cs = 1 if ($props{$id}{w2l_file} eq $props{$item}{src_file});
                            }
                            if (! $update_cs && $gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        }
                    } elsif ($props{$item}{meta} =~ /w2_slice/) {
                        if ($props{$id}{meta} =~ /w2_slice/
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$item}{parm_div}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            if ($props{$item}{con_file} eq $props{$id}{con_file}
                                 && $props{$item}{src_type} eq $props{$id}{src_type}) {
                                $update_cs = 1;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        } elsif ($props{$id}{meta} eq "w2_tdmap"
                             && $props{$id}{map_type}     eq "standard"
                             && $props{$item}{parm}       eq $props{$id}{parm_sav}
                             && $props{$item}{parm_div}   eq $props{$id}{pdiv_sav}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            if ($props{$item}{con_file} eq $props{$id}{con_file}
                                 && $props{$item}{src_type} eq $props{$id}{src_type}) {
                                $update_cs = 1;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        } elsif ($props{$id}{meta} =~ /w2_profile|w2_outflow/
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$item}{parm_div}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            if ($props{$item}{src_type} =~ /Contour/i) {
                                @wbs       = split(/,/, $props{$item}{wb_list});
                                @cpl_files = @{ $props{$item}{cpl_files} };
                                for ($n=0; $n<=$#wbs; $n++) {
                                    if ($cpl_files[$n] eq $props{$id}{src_file}) {
                                        $update_cs = 1;
                                        last;
                                    }
                                }
                            } elsif ($props{$item}{src_type} =~ /Vector/i) {
                                $update_cs = 1 if ($props{$item}{w2l_file} eq $props{$id}{src_file});
                            }
                            if (! $update_cs && $gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        }
                    } elsif ($props{$item}{meta} eq "w2_tdmap") {
                        if ($props{$id}{meta} =~ /w2_slice/
                             && $props{$item}{map_type}   eq "standard"
                             && $props{$item}{parm_sav}   eq $props{$id}{parm}
                             && $props{$item}{pdiv_sav}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            if ($props{$item}{con_file} eq $props{$id}{con_file}
                                 && $props{$item}{src_type} eq $props{$id}{src_type}) {
                                $update_cs = 1;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        } elsif ($props{$id}{meta} eq "w2_tdmap"
                             && $props{$item}{map_type}   eq $props{$id}{map_type}
                             && $props{$item}{parm_sav}   eq $props{$id}{parm_sav}
                             && $props{$item}{pdiv_sav}   eq $props{$id}{pdiv_sav}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}
                             && ($props{$id}{map_type} eq "standard"
                                || ($props{$item}{parm2_sav} eq $props{$id}{parm2_sav}
                                 && $props{$item}{pdiv2_sav} eq $props{$id}{pdiv2_sav}))) {
                            if ($props{$item}{con_file} eq $props{$id}{con_file}
                                 && $props{$item}{src_type} eq $props{$id}{src_type}
                                 && ($props{$id}{map_type} eq "standard"
                                     || $props{$item}{src_type2} eq $props{$id}{src_type2})) {
                                $update_cs = 1;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        } elsif ($props{$id}{meta} =~ /w2_profile|w2_outflow/
                             && $props{$item}{map_type}   eq "standard"
                             && $props{$item}{parm_sav}   eq $props{$id}{parm}
                             && $props{$item}{pdiv_sav}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            if ($props{$item}{src_type} =~ /Contour/i) {
                                @wbs       = split(/,/, $props{$item}{wb_list});
                                @cpl_files = @{ $props{$item}{cpl_files} };
                                for ($n=0; $n<=$#wbs; $n++) {
                                    if ($cpl_files[$n] eq $props{$id}{src_file}) {
                                        $update_cs = 1;
                                        last;
                                    }
                                }
                            } elsif ($props{$item}{src_type} =~ /Vector/i) {
                                $update_cs = 1 if ($props{$item}{w2l_file} eq $props{$id}{src_file});
                            }
                            if (! $update_cs && $gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        }
                    } elsif ($props{$item}{meta} =~ /data_profile/) {
                        if ($props{$id}{meta} =~ /data_profile/
                             && $props{$item}{prof_type}  eq $props{$id}{prof_type}
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            if ($props{$item}{src_file} eq $props{$id}{src_file}) {
                                $update_cs = 1;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        } elsif ($props{$id}{meta} =~ /vert_wd_zone/
                             && $props{$item}{prof_type}  eq "standard"
                             && $props{$item}{parm}       eq "Temperature"
                             && $props{$item}{parm_units} eq $props{$id}{wt_units}) {
                            if ($props{$item}{src_file} eq $props{$id}{wt_file}) {
                                $update_cs = 1;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        }
                    } elsif ($props{$item}{meta} =~ /vert_wd_zone/) {
                        if ($props{$id}{meta} =~ /vert_wd_zone/
                             && $props{$item}{wt_units} eq $props{$id}{wt_units}) {
                            if ($props{$item}{wt_file} eq $props{$id}{wt_file}) {
                                $update_cs = 1;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        } elsif ($props{$id}{meta} =~ /data_profile/
                             && $props{$id}{prof_type}  eq "standard"
                             && $props{$id}{parm}       eq "Temperature"
                             && $props{$item}{wt_units} eq $props{$id}{parm_units}) {
                            if ($props{$item}{wt_file} eq $props{$id}{src_file}) {
                                $update_cs = 1;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        }
                    }

#               Test for no links
                } elsif ($cs_link == 0) {
                    if ($props{$item}{meta} =~ /w2_profile|w2_outflow/) {
                        if ($props{$id}{meta} =~ /w2_profile|w2_outflow/
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$item}{parm_div}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            if ($props{$item}{src_file} eq $props{$id}{src_file}
                                 && $gr_props{$item}{cs_link} > 0) {
                                $gr_props{$item}{cs_link} = 0;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        } elsif (($props{$id}{meta} =~ /w2_slice/
                                  && $props{$item}{parm}       eq $props{$id}{parm}
                                  && $props{$item}{parm_div}   eq $props{$id}{parm_div}
                                  && $props{$item}{parm_units} eq $props{$id}{parm_units})
                              || ($props{$id}{meta} eq "w2_tdmap"
                                  && $props{$id}{map_type}     eq "standard"
                                  && $props{$item}{parm}       eq $props{$id}{parm_sav}
                                  && $props{$item}{parm_div}   eq $props{$id}{pdiv_sav}
                                  && $props{$item}{parm_units} eq $props{$id}{parm_units})) {
                            $match = 0;
                            if ($props{$id}{src_type} =~ /Contour/i) {
                                @wbs       = split(/,/, $props{$id}{wb_list});
                                @cpl_files = @{ $props{$id}{cpl_files} };
                                for ($n=0; $n<=$#wbs; $n++) {
                                    if ($cpl_files[$n] eq $props{$item}{src_file}) {
                                        $match = 1;
                                        last;
                                    }
                                }
                            } elsif ($props{$id}{src_type} =~ /Vector/i) {
                                $match = 1 if ($props{$id}{w2l_file} eq $props{$item}{src_file});
                            }
                            if ($match && $gr_props{$item}{cs_link} > 0) {
                                $gr_props{$item}{cs_link} = 0;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        }
                    } elsif ($props{$item}{meta} =~ /w2_slice/) {
                        if ($props{$id}{meta} =~ /w2_slice/
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$item}{parm_div}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            if ($props{$item}{con_file} eq $props{$id}{con_file}
                                 && $props{$item}{src_type} eq $props{$id}{src_type}
                                 && $gr_props{$item}{cs_link} > 0) {
                                $gr_props{$item}{cs_link} = 0;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        } elsif ($props{$id}{meta} eq "w2_tdmap"
                             && $props{$id}{map_type}     eq "standard"
                             && $props{$item}{parm}       eq $props{$id}{parm_sav}
                             && $props{$item}{parm_div}   eq $props{$id}{pdiv_sav}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            if ($props{$item}{con_file} eq $props{$id}{con_file}
                                 && $props{$item}{src_type} eq $props{$id}{src_type}
                                 && $gr_props{$item}{cs_link} > 0) {
                                $gr_props{$item}{cs_link} = 0;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        } elsif ($props{$id}{meta} =~ /w2_profile|w2_outflow/
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$item}{parm_div}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            $match = 0;
                            if ($props{$item}{src_type} =~ /Contour/i) {
                                @wbs       = split(/,/, $props{$item}{wb_list});
                                @cpl_files = @{ $props{$item}{cpl_files} };
                                for ($n=0; $n<=$#wbs; $n++) {
                                    if ($cpl_files[$n] eq $props{$id}{src_file}) {
                                        $match = 1;
                                        last;
                                    }
                                }
                            } elsif ($props{$item}{src_type} =~ /Vector/i) {
                                $match = 1 if ($props{$item}{w2l_file} eq $props{$id}{src_file});
                            }
                            if ($match && $gr_props{$item}{cs_link} > 0) {
                                $gr_props{$item}{cs_link} = 0;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        }
                    } elsif ($props{$item}{meta} eq "w2_tdmap") {
                        if ($props{$id}{meta} =~ /w2_slice/
                             && $props{$item}{map_type}   eq "standard"
                             && $props{$item}{parm_sav}   eq $props{$id}{parm}
                             && $props{$item}{pdiv_sav}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            if ($props{$item}{con_file} eq $props{$id}{con_file}
                                 && $props{$item}{src_type} eq $props{$id}{src_type}
                                 && $gr_props{$item}{cs_link} > 0) {
                                $gr_props{$item}{cs_link} = 0;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        } elsif ($props{$id}{meta} eq "w2_tdmap"
                             && $props{$item}{map_type}   eq $props{$id}{map_type}
                             && $props{$item}{parm_sav}   eq $props{$id}{parm_sav}
                             && $props{$item}{pdiv_sav}   eq $props{$id}{pdiv_sav}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            if ($props{$item}{con_file} eq $props{$id}{con_file}
                                 && $props{$item}{src_type} eq $props{$id}{src_type}
                                 && ($props{$id}{map_type} eq "standard"
                                     || $props{$item}{src_type2} eq $props{$id}{src_type2})
                                 && $gr_props{$item}{cs_link} > 0) {
                                $gr_props{$item}{cs_link} = 0;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        } elsif ($props{$id}{meta} =~ /w2_profile|w2_outflow/
                             && $props{$item}{map_type}   eq "standard"
                             && $props{$item}{parm_sav}   eq $props{$id}{parm}
                             && $props{$item}{pdiv_sav}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            $match = 0;
                            if ($props{$item}{src_type} =~ /Contour/i) {
                                @wbs       = split(/,/, $props{$item}{wb_list});
                                @cpl_files = @{ $props{$item}{cpl_files} };
                                for ($n=0; $n<=$#wbs; $n++) {
                                    if ($cpl_files[$n] eq $props{$id}{src_file}) {
                                        $match = 1;
                                        last;
                                    }
                                }
                            } elsif ($props{$item}{src_type} =~ /Vector/i) {
                                $match = 1 if ($props{$item}{w2l_file} eq $props{$id}{src_file});
                            }
                            if ($match && $gr_props{$item}{cs_link} > 0) {
                                $gr_props{$item}{cs_link} = 0;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        }
                    } elsif ($props{$item}{meta} =~ /data_profile/) {
                        if ($props{$id}{meta} =~ /data_profile/
                             && $props{$item}{prof_type}  eq $props{$id}{prof_type}
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            if ($props{$item}{src_file} eq $props{$id}{src_file}
                                 && $gr_props{$item}{cs_link} > 0) {
                                $gr_props{$item}{cs_link} = 0;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        } elsif ($props{$id}{meta} =~ /vert_wd_zone/
                             && $props{$item}{prof_type}  eq "standard"
                             && $props{$item}{parm}       eq "Temperature"
                             && $props{$item}{parm_units} eq $props{$id}{wt_units}) {
                            if ($props{$item}{src_file} eq $props{$id}{wt_file}
                                 && $gr_props{$item}{cs_link} > 0) {
                                $gr_props{$item}{cs_link} = 0;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        }
                    } elsif ($props{$item}{meta} =~ /vert_wd_zone/) {
                        if ($props{$id}{meta} =~ /vert_wd_zone/
                             && $props{$item}{wt_units} eq $props{$id}{wt_units}) {
                            if ($props{$item}{wt_file} eq $props{$id}{wt_file}
                                 && $gr_props{$item}{cs_link} > 0) {
                                $gr_props{$item}{cs_link} = 0;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        } elsif ($props{$id}{meta} =~ /data_profile/
                             && $props{$id}{prof_type}  eq "standard"
                             && $props{$id}{parm}       eq "Temperature"
                             && $props{$item}{wt_units} eq $props{$id}{parm_units}) {
                            if ($props{$item}{wt_file} eq $props{$id}{src_file}
                                 && $gr_props{$item}{cs_link} > 0) {
                                $gr_props{$item}{cs_link} = 0;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        }
                    }
                }
                next if (! $update_cs);
                if ($gr_props{$item}{add_cs}) {
                    $gr_props{$item}{redraw} = 1 if ($gr_props{$item}{cscheme1} ne $cs1    ||
                                                     $gr_props{$item}{cscheme2} ne $cs2    ||
                                                     $gr_props{$item}{ncolors}  != $nc     ||
                                                     $gr_props{$item}{cs_rev}   != $rev    ||
                                                     $gr_props{$item}{cs_min}   != $cs_min ||
                                                     $gr_props{$item}{cs_max}   != $cs_max
                                                    );
                }
                $ncolors                   = $gr_props{$item}{ncolors};
                $gr_props{$item}{cscheme1} = $cs1;
                $gr_props{$item}{cscheme2} = $cs2;
                $gr_props{$item}{ncolors}  = $nc;
                $gr_props{$item}{cs_rev}   = $rev;
                $gr_props{$item}{cs_min}   = $cs_min;
                $gr_props{$item}{cs_max}   = $cs_max;
                $gr_props{$item}{cs_major} = $cs_major;
                if ($ncolors != $nc) {
                    $gr_props{$item}{cs_height}
                        = &max(2, &min(30, &round_to_int($gr_props{$item}{cs_height} *$ncolors /$nc)));
                }
            }
        }
    }

    if ($props{$id}{meta} eq "w2_tdmap") {
        if ($gr_props{$id}{date_axis} eq "X") {
            $gr_props{$id}{ttitle}    = $xtitle;
            $gr_props{$id}{tfont}     = $xfont;
            $gr_props{$id}{tt_size}   = $xt_size;
            $gr_props{$id}{tt_weight} = $xt_weight;
            $gr_props{$id}{tl_size}   = $xl_size;
            $gr_props{$id}{tl_weight} = $xl_weight;
            $gr_props{$id}{tmin}      = $xmin;
            $gr_props{$id}{tmax}      = $xmax;
            $gr_props{$id}{tmajor}    = $xmajor;
            $gr_props{$id}{tpr_tics}  = $xpr_tics;
            $gr_props{$id}{top_tics}  = $xop_tics;
            $gr_props{$id}{dtitle}    = $ytitle;
            $gr_props{$id}{dfont}     = $yfont;
            $gr_props{$id}{dt_size}   = $yt_size;
            $gr_props{$id}{dt_weight} = $yt_weight;
            $gr_props{$id}{dl_size}   = $yl_size;
            $gr_props{$id}{dl_weight} = $yl_weight;
            $gr_props{$id}{dunits}    = $yaxis_units;
            $gr_props{$id}{dbase}     = $ybase;
            $gr_props{$id}{dmin}      = $ymin;
            $gr_props{$id}{dmax}      = $ymax;
            $gr_props{$id}{dfirst}    = $yfirst;
            $gr_props{$id}{dmajor}    = $ymajor;
            $gr_props{$id}{dpr_tics}  = $ypr_tics;
            $gr_props{$id}{dop_tics}  = $yop_tics;
            $gr_props{$id}{dmax_auto} = $ymax_auto;
            $gr_props{$id}{dflip_img} = ($gr_props{$id}{dflip} != $yaxis_flip) ? 1 : 0;
            $gr_props{$id}{dflip}     = $yaxis_flip;
        } else {
            $gr_props{$id}{dtitle}    = $xtitle;
            $gr_props{$id}{dfont}     = $xfont;
            $gr_props{$id}{dt_size}   = $xt_size;
            $gr_props{$id}{dt_weight} = $xt_weight;
            $gr_props{$id}{dl_size}   = $xl_size;
            $gr_props{$id}{dl_weight} = $xl_weight;
            $gr_props{$id}{dunits}    = $xaxis_units;
            $gr_props{$id}{dbase}     = $xbase;
            $gr_props{$id}{dmin}      = $xmin;
            $gr_props{$id}{dmax}      = $xmax;
            $gr_props{$id}{dfirst}    = $xfirst;
            $gr_props{$id}{dmajor}    = $xmajor;
            $gr_props{$id}{dpr_tics}  = $xpr_tics;
            $gr_props{$id}{dop_tics}  = $xop_tics;
            $gr_props{$id}{dmax_auto} = $xmax_auto;
            $gr_props{$id}{dflip_img} = ($gr_props{$id}{dflip} != $xaxis_flip) ? 1 : 0;
            $gr_props{$id}{dflip}     = $xaxis_flip;
            $gr_props{$id}{ttitle}    = $ytitle;
            $gr_props{$id}{tfont}     = $yfont;
            $gr_props{$id}{tt_size}   = $yt_size;
            $gr_props{$id}{tt_weight} = $yt_weight;
            $gr_props{$id}{tl_size}   = $yl_size;
            $gr_props{$id}{tl_weight} = $yl_weight;
            $gr_props{$id}{tmin}      = $ymin;
            $gr_props{$id}{tmax}      = $ymax;
            $gr_props{$id}{tmajor}    = $ymajor;
            $gr_props{$id}{tpr_tics}  = $ypr_tics;
            $gr_props{$id}{top_tics}  = $yop_tics;
        }
    } else {
        $gr_props{$id}{xtitle}    = $xtitle;
        $gr_props{$id}{xfont}     = $xfont;
        $gr_props{$id}{xt_size}   = $xt_size;
        $gr_props{$id}{xt_weight} = $xt_weight;
        $gr_props{$id}{xl_size}   = $xl_size;
        $gr_props{$id}{xl_weight} = $xl_weight;
        $gr_props{$id}{xmin}      = $xmin;
        $gr_props{$id}{xmax}      = $xmax;
        $gr_props{$id}{xmajor}    = $xmajor;
        $gr_props{$id}{xpr_tics}  = $xpr_tics;
        $gr_props{$id}{xop_tics}  = $xop_tics;
        $gr_props{$id}{ytitle}    = $ytitle;
        $gr_props{$id}{yfont}     = $yfont;
        $gr_props{$id}{yt_size}   = $yt_size;
        $gr_props{$id}{yt_weight} = $yt_weight;
        $gr_props{$id}{yl_size}   = $yl_size;
        $gr_props{$id}{yl_weight} = $yl_weight;
        $gr_props{$id}{ymin}      = $ymin;
        $gr_props{$id}{ymax}      = $ymax;
        $gr_props{$id}{ymajor}    = $ymajor;
        $gr_props{$id}{ypr_tics}  = $ypr_tics;
        $gr_props{$id}{yop_tics}  = $yop_tics;
    }

    $gr_props{$id}{gtitle}    = $gtitle;
    $gr_props{$id}{gtfont}    = $gtfont;
    $gr_props{$id}{gt_size}   = $gt_size;
    $gr_props{$id}{gt_weight} = $gt_weight;

    if ($props{$id}{meta} eq "vert_wd_zone" && $props{$id}{wd_alg} eq "Libby Dam") {
        if ($bh_status > 0) {
            $gr_props{$id}{bh_docked} = ($bh_status == 1) ? 1 : 0;
        }
        $gr_props{$id}{bh_show}   = ($bh_status > 0) ? 1 : 0;
        $gr_props{$id}{bh_font}   = $bh_font;
        $gr_props{$id}{bh_size}   = $bh_size;
        $gr_props{$id}{bh_weight} = $bh_weight;
        $gr_props{$id}{bh_tcolor} = $bh_tcolor;
        $gr_props{$id}{bh_bwidth} = $bh_bwidth;
        $gr_props{$id}{bh_bcolor} = $bh_bcolor;
        $gr_props{$id}{bh_bcellw} = $bh_bcellw;
        $gr_props{$id}{bh_bcellh} = $bh_bcellh;
    }

    if ($action eq "OK") {
        $graph_props_menu->g_destroy();
        undef $graph_props_menu;

#       When closing the graph properties menu window, if the mouse cursor is outside of the
#       main window, then a subsequent busy hold command won't change the mouse cursor shape.
#       Test for this condition, and move the mouse cursor if necessary.
        $move_mcursor = 0;
        if ($props{$id}{meta}
                =~ /(data_profile|w2_profile|w2_tdmap|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)/) {
            foreach $item (@animate_ids) {
                if (($props{$item}{meta} =~ /data_profile_cmap|w2_tdmap|w2_profile_cmap/
                       && $gr_props{$item}{redraw})
                   || ($props{$item}{meta} eq "w2_slice"
                       && ($gr_props{$item}{redraw} || $gr_props{$id}{xflip_img}))) {
                    $move_mcursor = 1;
                    last;
                }
            }
        }
        if ($move_mcursor) {
            if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
                $canvas->g_bind("<Motion>", "");
                Tkx::event_generate($main, "<Motion>", -warp => 1, -x => ($x1+$x2)/2, -y => ($y1+$y2)/2);
                $canvas->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"), $canvas, "menu" ]);
            }
        }
    } elsif ($action eq "Apply" && $refresh_menu) {
        &edit_graph_props($id, $X, $Y, $tabid);
    }
    &end_select($canvas, $id, 1);

    if ($props{$id}{meta}
            =~ /(data_profile|w2_profile|w2_tdmap|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)/) {
        foreach $item (@animate_ids) {
            next if ($props{$item}{meta} =~ /time_series/);
            if ($item == $id || $gr_props{$item}{redraw}) {
                if ($action eq "Apply" && defined($graph_props_menu)
                       && $props{$item}{meta} =~ /data_profile_cmap|w2_profile_cmap|w2_tdmap|w2_slice/) {
                    Tkx::tk_busy_hold($graph_props_menu, -cursor => $cursor_wait);
                    Tkx::update();
                }
                if ($props{$item}{meta} =~ /data_profile/) {
                    &make_data_profile($canvas, $item, 1);
                } elsif ($props{$item}{meta} =~ /w2_profile/) {
                    &make_w2_profile($canvas, $item, 1);
                } elsif ($props{$item}{meta} =~ /w2_slice/) {
                    &make_w2_slice($canvas, $item, 1);
                } elsif ($props{$item}{meta} =~ /w2_tdmap/) {
                    &make_w2_tdmap($canvas, $item, 1);
                } elsif ($props{$item}{meta} =~ /w2_outflow/) {
                    &make_w2_outflow($canvas, $item, 1);
                } elsif ($props{$item}{meta} =~ /w2_wlevels/) {
                    &make_w2_wlevels($canvas, $item, 1);
                } elsif ($props{$item}{meta} =~ /vert_wd_zone/) {
                    &make_wd_zone($canvas, $item, 1);
                }
                if ($action eq "Apply" && defined($graph_props_menu)
                       && $props{$item}{meta} =~ /data_profile_cmap|w2_profile_cmap|w2_tdmap|w2_slice/) {
                    Tkx::tk_busy_forget($graph_props_menu);
                }
            }
        }

    } elsif ($props{$id}{meta} =~ /time_series/) {
        &make_ts_graph($canvas, $id, 1);

    } else {   # some other type of graph -- future placeholder

    }

#   Refresh the Object Information box, if present
    if ($refresh_info && defined($object_infobox) && Tkx::winfo_exists($object_infobox)) {
        if ($object_infobox->g_wm_title() =~ /Object Info/) {
            $geom = $object_infobox->g_wm_geometry();
            (undef, $X, $Y) = split(/\+/, $geom);
            &show_info($canvas, $id, $X, $Y);
        }
    }

#   Refresh the Choose Datasets menu, if present
    if (defined($choose_sets_menu) && Tkx::winfo_exists($choose_sets_menu)) {
        if ($choose_sets_menu->g_wm_title() eq "Choose Datasets for Fit Statistics") {
            $geom = $choose_sets_menu->g_wm_geometry();
            (undef, $X, $Y) = split(/\+/, $geom);
            &choose_datasets($canvas, $id, $X, $Y);
        }
    }
}


sub edit_link {
    my ($canv, $id, $X, $Y, $link_id) = @_;
    my (
        $btn_txt, $code, $color, $color_btn, $color_label, $digits,
        $digits_label, $digits_sb, $f, $fg, $fmt, $font, $font_cb,
        $font_label, $form, $form_cb, $frame, $geom, $link_frame,
        $link_txt, $outlet, $outlet_cb, $outlet_label, $ph, $preview_canv,
        $preview_oval, $preview_poly, $preview_txt, $pw, $row, $size,
        $size_cb, $size_label, $slant, $slant_cb, $slant_label, $slant_opt,
        $type, $type_cb, $units, $units_cb, $units_label, $v, $weight,
        $weight_cb, $weight_label, $width, $width_label, $width_sb,

        @link_forms, @link_types, @names, @unit_opts,

        %form_coords,
       );

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($edit_link_menu) && Tkx::winfo_exists($edit_link_menu)) {
        if ($edit_link_menu->g_wm_title() eq "Add or Edit Link") {
            $edit_link_menu->g_destroy();
            undef $edit_link_menu;
        }
    }
    $edit_link_menu = $main->new_toplevel();
    $edit_link_menu->g_wm_transient($main);
    $edit_link_menu->g_wm_title("Add or Edit Link");
    $edit_link_menu->configure(-cursor => $cursor_norm);
    $edit_link_menu->g_wm_geometry($geom);

    if ($props{$id}{meta} eq "vert_wd_zone") {
        @link_types = ("Release Rate", "Temperature", "Water Surface Elevation");
        $type  = "Release Rate";
        $units = "cms";
        @names = @{ $gr_props{$id}{names} };
        push (@names, "All Outlets");
    } elsif ($props{$id}{meta} eq "w2_outflow") {
        @link_types = ("Release Rate", "Water Surface Elevation");
        $type  = "Release Rate";
        $units = "cms";
        @names = ("All Outlets");
    } else {
        @link_types = ("Water Surface Elevation");
        $type  = "Water Surface Elevation";
        $units = "m";
        @names = ("All Outlets");
    }

    $outlet = "All Outlets";
    $form   = "Text";
    $digits = 0;
    $font   = $default_family;
    $weight = $default_weight;
    $size   = $default_size;
    $slant  = $default_slant;
    $width  = $default_width;
    $color  = $default_color;
    if ($link_id != 0) {
        $type   = $link_props{$link_id}{type};
        $outlet = $link_props{$link_id}{outlet};
        $form   = $link_props{$link_id}{form};
        $units  = $link_props{$link_id}{units};
        $digits = $link_props{$link_id}{digits};
        $font   = $props{$link_id}{family} if (defined($props{$link_id}{family}));
        $size   = $props{$link_id}{size}   if (defined($props{$link_id}{size}));
        $weight = $props{$link_id}{weight} if (defined($props{$link_id}{weight}));
        $slant  = $props{$link_id}{slant}  if (defined($props{$link_id}{slant}));
        $width  = $props{$link_id}{width}  if (defined($props{$link_id}{width}));
        $color  = $props{$link_id}{color};
    } else {
        &end_select($canv, $id, 1);
    }
    $form      = "Text" if (! $gr_props{$id}{add_cs});
    $btn_txt   = ($link_id == 0) ? "Create" : "Modify";
    $slant_opt = $slant_options[$slant];

    $fmt = "%.${digits}f";
    if ($type eq "Release Rate") {
        @unit_opts = ("cms", "cfs");
        $v         = ($units eq "cfs") ? 1000 : 50;
        $link_txt  = sprintf($fmt, $v) . " " . $units;
    } elsif ($type eq "Water Surface Elevation") {
        @unit_opts = ("m", "ft");
        $v         = ($units eq "ft") ? 1500 : 450;
        $link_txt  = sprintf($fmt, $v) . " " . $units;
    } else {
        @unit_opts = ("Celsius", "Fahrenheit");
        $v         = ($units eq "Celsius") ? 13 : 55;
        $link_txt  = sprintf($fmt, $v) . " " . "\N{U+00B0}" . substr($units,0,1);
    }

    $pw = 270;
    $ph = 45;
    @link_forms  = ("Text", "Circle", "Ellipse", "Rectangle", "Diamond", "Polygon");
    %form_coords = ("Circle",    [ $pw*0.5 -$ph*0.3 +3, $ph*0.2 +3,
                                   $pw*0.5 +$ph*0.3 +3, $ph*0.8 +3  ],
                    "Ellipse",   [ $pw*0.2 +3, $ph*0.2 +3,
                                   $pw*0.8 +3, $ph*0.8 +3  ],
                    "Rectangle", [ $pw*0.2 +3, $ph*0.2 +3, $pw*0.8 +3, $ph*0.2 +3,
                                   $pw*0.8 +3, $ph*0.8 +3, $pw*0.2 +3, $ph*0.8 +3, ],
                    "Diamond",   [ $pw*0.5 +3, $ph*0.2 +3, $pw*0.8 +3, $ph*0.5 +3,
                                   $pw*0.5 +3, $ph*0.8 +3, $pw*0.2 +3, $ph*0.5 +3, ],
                    "Polygon",   [ $pw*0.25 +3, $ph*0.2 +3, $pw*0.6 +3, $ph*0.2 +3,
                                   $pw*0.75 +3, $ph*0.5 +3, $pw*0.6 +3, $ph*0.8 +3,
                                   $pw*0.25 +3, $ph*0.8 +3, ],
                   );

    $frame = $edit_link_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    $frame->new_button(
            -text    => $btn_txt,
            -command => sub { &set_link($canv, $id, $link_id, $type, $form, $units,
                                        $digits, $outlet, $font, $weight, $size, $slant,
                                        $width, $color,
                                        );
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $edit_link_menu->g_destroy();
                              undef $edit_link_menu; },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

    ($f = $edit_link_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_pack(-side => 'top');

    ($preview_canv = $f->new_canvas(
            -background  => &get_rgb_code($canvas_color),
            -width       => $pw,
            -height      => $ph,
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_grid(-row => 0, -column => 0, -sticky => 'wne');

    $preview_txt = $preview_canv->create_text($pw*0.5 +3, $ph*0.5 +3,
            -anchor => 'center', 
            -text   => $link_txt,
            -fill   => "#000000",
            -angle  => 0,
            -font   => [-family     => $font,
                        -size       => $size,
                        -weight     => $weight,
                        -slant      => $slant_type[$slant],
                        -underline  => 0,
                        -overstrike => 0,
                       ]);
    $preview_poly = $preview_canv->create_polygon( @{ $form_coords{"Rectangle"} },
                       -width   => 1,
                       -outline => &get_rgb_code("black"),
                       -fill    => &get_rgb_code("yellow"),
                       -smooth  => 'false',
                       );
    $preview_oval = $preview_canv->create_oval( @{ $form_coords{"Circle"} },
                       -width   => 1,
                       -outline => &get_rgb_code("black"),
                       -fill    => &get_rgb_code("yellow"),
                       );

    if ($form eq "Text") {
        $preview_canv->itemconfigure($preview_poly, -state => 'hidden');
        $preview_canv->itemconfigure($preview_oval, -state => 'hidden');

    } elsif ($form =~ /^(Circle|Ellipse)$/) {
        $preview_canv->itemconfigure($preview_txt,  -state => 'hidden');
        $preview_canv->itemconfigure($preview_poly, -state => 'hidden');
        if ($form eq "Ellipse") {
            $preview_canv->coords($preview_oval, @{ $form_coords{"Ellipse"} });
        }
    } elsif ($form =~ /^(Rectangle|Diamond|Polygon)$/) {
        $preview_canv->itemconfigure($preview_txt,  -state => 'hidden');
        $preview_canv->itemconfigure($preview_oval, -state => 'hidden');
        if ($form =~ /^(Diamond|Polygon)$/) {
            $preview_canv->coords($preview_poly, @{ $form_coords{$form} });
        }
    }

    ($link_frame = $f->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_grid(-row => 1, -column => 0, -sticky => 'wnes');

    $row = 0;
    $link_frame->new_label(
            -text => "Link Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($type_cb = $link_frame->new_ttk__combobox(
            -textvariable => \$type,
            -values       => [ @link_types ],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
    $type_cb->g_bind("<<ComboboxSelected>>",
              sub { my ($add, $v);
                    if ($type eq "Release Rate") {
                        @unit_opts = ("cms", "cfs");
                        $units = "cms" if ($units !~ /^(cfs|cms)$/);
                        $v     = ($units eq "cfs") ? 1000 : 50;
                        $add   = " " . $units;
                        $form  = "Text";
                        $form_cb->configure(-state => 'disabled');
                        $outlet_label->g_grid();
                        $outlet_cb->g_grid();
                        if ($props{$id}{meta} =~ /w2_profile|w2_outflow/) {
                            $outlet_cb->configure(-state => 'disabled');
                        }
                    } elsif ($type eq "Water Surface Elevation") {
                        @unit_opts = ("m", "ft");
                        $units = "m" if ($units !~ /^(ft|m)$/);
                        $v     = ($units eq "ft") ? 1500 : 450;
                        $add   = " " . $units;
                        $form  = "Text";
                        $form_cb->configure(-state => 'disabled');
                        $outlet_label->g_grid_remove();
                        $outlet_cb->g_grid_remove();
                    } else {
                        @unit_opts = ("Celsius", "Fahrenheit");
                        $units = "Celsius" if ($units !~ /^(Celsius|Fahrenheit)$/);
                        $v     = ($units eq "Celsius") ? 13 : 55;
                        $add   = "\N{U+00B0}" . substr($units,0,1);
                        if ($gr_props{$id}{add_cs}) {
                            $form_cb->configure(-state => 'readonly');
                        }
                        $outlet_label->g_grid();
                        $outlet_cb->g_grid();
                    }
                    $units_cb->configure(-values => [ @unit_opts ]);
                    $preview_canv->itemconfigure($preview_txt,
                                       -state => 'normal',
                                       -text  => sprintf("%.${digits}f", $v) . $add);
                    $preview_canv->itemconfigure($preview_poly, -state => 'hidden');
                    $preview_canv->itemconfigure($preview_oval, -state => 'hidden');
                    $width_label->g_grid_remove();
                    $width_sb->g_grid_remove();
                    $color_label->g_grid_remove();
                    $color_btn->g_grid_remove();
                    $units_label->g_grid();
                    $units_cb->g_grid();
                    $digits_label->g_grid();
                    $digits_sb->g_grid();
                    $font_label->g_grid();
                    $font_cb->g_grid();
                    $size_label->g_grid();
                    $size_cb->g_grid();
                    $weight_label->g_grid();
                    $weight_cb->g_grid();
                    $slant_label->g_grid();
                    $slant_cb->g_grid();
                  });

    $row++;
    ($outlet_label = $link_frame->new_label(
            -text => "Link Outlet: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($outlet_cb = $link_frame->new_ttk__combobox(
            -textvariable => \$outlet,
            -values       => [ @names ],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
    if ($type eq "Water Surface Elevation") {
        $outlet_label->g_grid_remove();
        $outlet_cb->g_grid_remove();
    } elsif ($type eq "Release Rate" && $props{$id}{meta} =~ /w2_profile|w2_outflow/) {
        $outlet_cb->configure(-state => 'disabled');
    }

    $row++;
    $link_frame->new_label(
            -text => "Link Form: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($form_cb = $link_frame->new_ttk__combobox(
            -textvariable => \$form,
            -values       => [ @link_forms ],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
    $form_cb->g_bind("<<ComboboxSelected>>",
              sub { my ($add, $v);
                    if ($form eq "Text") {
                        if ($type eq "Release Rate") {
                            @unit_opts = ("cms", "cfs");
                            $units = "cms" if ($units !~ /^(cfs|cms)$/);
                            $v     = ($units eq "cfs") ? 1000 : 50;
                            $add   = " " . $units;
                        } elsif ($type eq "Water Surface Elevation") {
                            @unit_opts = ("m", "ft");
                            $units = "m" if ($units !~ /^(ft|m)$/);
                            $v     = ($units eq "ft") ? 1500 : 450;
                            $add   = " " . $units;
                        } else {
                            @unit_opts = ("Celsius", "Fahrenheit");
                            $units = "Celsius" if ($units =~ /^(cfs|cms)$/);
                            $v     = ($units eq "Celsius") ? 13 : 55;
                            $add   = "\N{U+00B0}" . substr($units,0,1);
                        }
                        $units_cb->configure(-values => [ @unit_opts ]);
                        $preview_canv->itemconfigure($preview_txt,
                                       -state => 'normal',
                                       -text  => sprintf("%.${digits}f", $v) . $add);
                        $preview_canv->itemconfigure($preview_poly, -state => 'hidden');
                        $preview_canv->itemconfigure($preview_oval, -state => 'hidden');
                        $width_label->g_grid_remove();
                        $width_sb->g_grid_remove();
                        $color_label->g_grid_remove();
                        $color_btn->g_grid_remove();
                        $units_label->g_grid();
                        $units_cb->g_grid();
                        $digits_label->g_grid();
                        $digits_sb->g_grid();
                        $font_label->g_grid();
                        $font_cb->g_grid();
                        $size_label->g_grid();
                        $size_cb->g_grid();
                        $weight_label->g_grid();
                        $weight_cb->g_grid();
                        $slant_label->g_grid();
                        $slant_cb->g_grid();
                    } else {
                        $preview_canv->itemconfigure($preview_txt,  -state => 'hidden');
                        if ($form =~ /^(Circle|Ellipse)$/) {
                            $preview_canv->itemconfigure($preview_poly, -state => 'hidden');
                            $preview_canv->itemconfigure($preview_oval, -state => 'normal');
                            $preview_canv->coords($preview_oval, @{ $form_coords{$form} });
                        } else {
                            $preview_canv->itemconfigure($preview_oval, -state => 'hidden');
                            $preview_canv->itemconfigure($preview_poly, -state => 'normal');
                            $preview_canv->coords($preview_poly, @{ $form_coords{$form} });
                        }
                        $units_label->g_grid_remove();
                        $units_cb->g_grid_remove();
                        $digits_label->g_grid_remove();
                        $digits_sb->g_grid_remove();
                        $font_label->g_grid_remove();
                        $font_cb->g_grid_remove();
                        $size_label->g_grid_remove();
                        $size_cb->g_grid_remove();
                        $weight_label->g_grid_remove();
                        $weight_cb->g_grid_remove();
                        $slant_label->g_grid_remove();
                        $slant_cb->g_grid_remove();
                        $width_label->g_grid();
                        $width_sb->g_grid();
                        $color_label->g_grid();
                        $color_btn->g_grid();
                    }
                  });
    if ($type =~ /^(Release Rate|Water Surface Elevation)$/ || ! $gr_props{$id}{add_cs}) {
        $form = "Text";
        $form_cb->configure(-state => 'disabled');
    }

    $row++;
    ($units_label = $link_frame->new_label(
            -text => "Link Units: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($units_cb = $link_frame->new_ttk__combobox(
            -textvariable => \$units,
            -values       => [ @unit_opts ],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
    $units_cb->g_bind("<<ComboboxSelected>>",
              sub { my ($add, $v);
                    if ($type eq "Release Rate") {
                        $v   = ($units eq "cfs") ? 1000 : 50;
                        $add = " " . $units;
                    } elsif ($type eq "Water Surface Elevation") {
                        $v   = ($units eq "ft") ? 1500 : 450;
                        $add = " " . $units;
                    } else {
                        $v   = ($units eq "Celsius") ? 13 : 55;
                        $add = "\N{U+00B0}" . substr($units,0,1);
                    }
                    $preview_canv->itemconfigure($preview_txt,
                                   -text => sprintf("%.${digits}f", $v) . $add);
                  });

    $row++;
    ($digits_label = $link_frame->new_label(
            -text => "Decimal Digits: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($digits_sb = $link_frame->new_spinbox(
            -textvariable => \$digits,
            -state        => 'readonly',
            -font         => 'default',
            -from         => 0,
            -to           => 5,
            -increment    => 1,
            -width        => 3,
            -command      => sub { my ($add, $v);
                                   if ($type eq "Release Rate") {
                                       $v   = ($units eq "cfs") ? 1000 : 50;
                                       $add = " " . $units;
                                   } elsif ($type eq "Water Surface Elevation") {
                                       $v   = ($units eq "ft") ? 1500 : 450;
                                       $add = " " . $units;
                                   } else {
                                       $v   = ($units eq "Celsius") ? 13 : 55;
                                       $add = "\N{U+00B0}" . substr($units,0,1);
                                   }
                                   $preview_canv->itemconfigure($preview_txt,
                                                  -text => sprintf("%.${digits}f", $v) . $add);
                                 },
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    $row++;
    ($font_label = $link_frame->new_label(
            -text => "Link Text Font: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($font_cb = $link_frame->new_ttk__combobox(
            -textvariable => \$font,
            -values       => [ sort @available_fonts ],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
    $font_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_canv->itemconfigure($preview_txt,
                          -font => [ -family     => $font,
                                     -size       => $size,
                                     -weight     => $weight,
                                     -slant      => $slant_type[$slant],
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                  });
    $row++;
    ($size_label = $link_frame->new_label(
            -text => "Link Text Size: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($size_cb = $link_frame->new_ttk__combobox(
            -textvariable => \$size,
            -values       => [(5 .. 24)],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
    $size_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_canv->itemconfigure($preview_txt,
                          -font => [ -family     => $font,
                                     -size       => $size,
                                     -weight     => $weight,
                                     -slant      => $slant_type[$slant],
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                  });
    $row++;
    ($weight_label = $link_frame->new_label(
            -text => "Link Text Weight: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($weight_cb = $link_frame->new_ttk__combobox(
            -textvariable => \$weight,
            -values       => [("normal", "bold")],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
    $weight_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_canv->itemconfigure($preview_txt,
                          -font => [ -family     => $font,
                                     -size       => $size,
                                     -weight     => $weight,
                                     -slant      => $slant_type[$slant],
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                  });
    $row++;
    ($slant_label = $link_frame->new_label(
            -text => "Link Text Slant: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($slant_cb = $link_frame->new_ttk__combobox(
            -textvariable => \$slant_opt,
            -values       => [ @slant_options ],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
    $slant_cb->g_bind("<<ComboboxSelected>>",
              sub { my $s = &list_match($slant_opt, @slant_options);
                    return if ($s < 0);
                    $slant = $s;
                    $preview_canv->itemconfigure($preview_txt,
                          -font => [ -family     => $font,
                                     -size       => $size,
                                     -weight     => $weight,
                                     -slant      => $slant_type[$slant],
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                  });

    $row++;
    ($width_label = $link_frame->new_label(
            -text => "Outline Width: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($width_sb = $link_frame->new_spinbox(
            -textvariable => \$width,
            -state        => 'readonly',
            -font         => 'default',
            -from         => 0,
            -to           => 10,
            -increment    => 1,
            -width        => 3,
            -command      => sub { if ($width > 0) {
                                       $preview_canv->itemconfigure($preview_poly,
                                                      -outline => &get_rgb_code($color),
                                                      -width   => $width);
                                       $preview_canv->itemconfigure($preview_oval,
                                                      -outline => &get_rgb_code($color),
                                                      -width   => $width);
                                       $color_btn->configure(-state => 'normal');
                                   } else {
                                       $preview_canv->itemconfigure($preview_poly,
                                                      -outline => "",
                                                      -width   => $width);
                                       $preview_canv->itemconfigure($preview_oval,
                                                      -outline => "",
                                                      -width   => $width);
                                       $color_btn->configure(-state => 'disabled');
                                   }
                                 },
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    $row++;
    ($color_label = $link_frame->new_label(
            -text => "Outline Color: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);

    $code  = &get_rgb_code($color);
    $color = &get_rgb_name($code);
    $fg    = &get_rgb_code("black");
    if ($code =~ /^\#[0-9a-f]/i) {
        $fg = &get_rgb_code(&get_bw_contrast($code));
    }
    ($color_btn = $link_frame->new_button(
            -textvariable => \$color,
            -background   => $code,
            -foreground   => $fg,
            -width        => -7,
            -command => sub {
                          my ($newc, $code, $fg);
                          $code = &get_rgb_code($color);
                          $newc = Tkx::tk___chooseColor(
                                     -initialcolor => $code,
                                     -parent       => $edit_link_menu);
                          if ($newc) {
                            $code  = &get_rgb_code($newc);
                            $color = &get_rgb_name($code);
                            $fg    = &get_rgb_code("black");
                            if ($code =~ /^#?[0-9a-f]/i) {
                                $fg = &get_rgb_code(&get_bw_contrast($code));
                            }
                            $color_btn->configure(-foreground => $fg,
                                                  -background => $code);
                            if ($width > 0) {
                                $preview_canv->itemconfigure($preview_poly, -outline => $code);
                                $preview_canv->itemconfigure($preview_oval, -outline => $code);
                            } else {
                                $preview_canv->itemconfigure($preview_poly, -outline => "");
                                $preview_canv->itemconfigure($preview_oval, -outline => "");
                            }
                          }
                        }
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    if ($width == 0) {
        $preview_canv->itemconfigure($preview_poly, -outline => "", -width => 0);
        $preview_canv->itemconfigure($preview_oval, -outline => "", -width => 0);
        $color_btn->configure(-state => 'disabled');
    }

    if ($form ne "Text") {
        $units_label->g_grid_remove();
        $units_cb->g_grid_remove();
        $digits_label->g_grid_remove();
        $digits_sb->g_grid_remove();
        $font_label->g_grid_remove();
        $font_cb->g_grid_remove();
        $size_label->g_grid_remove();
        $size_cb->g_grid_remove();
        $weight_label->g_grid_remove();
        $weight_cb->g_grid_remove();
        $slant_label->g_grid_remove();
        $slant_cb->g_grid_remove();
    } else {
        $width_label->g_grid_remove();
        $width_sb->g_grid_remove();
        $color_label->g_grid_remove();
        $color_btn->g_grid_remove();
    }
    $link_frame->g_grid_columnconfigure(1, -weight => 2);

    Tkx::wm_resizable($edit_link_menu,0,0);
    &adjust_window_position($edit_link_menu);
    $edit_link_menu->g_focus;
}


sub set_link {
    my ($canv, $id, $link_id, $type, $form, $units, $digits,
        $outlet, $font, $weight, $size, $slant, $width, $color) = @_;
    my (
        $ang, $cs_max, $cs_min, $dt, $dt2, $fmt, $i, $link_txt, $mi, $qsum,
        $r, $save_id, $shade, $wt, $x1, $x2, $xo, $y1, $y2, $yo, $ws_elev,

        @colors, @coords, @flows, @names, @qstr, @tstr,

        %elev_data, %qdata, %tdata, %wsurf,
       );

    $dt    = $dates[$dti-1];
    $shade = "";
    $fmt   = "%.${digits}f";
    ($x1, $y1, $x2, $y2) = Tkx::SplitList($canv->coords($id));

    if ($type eq "Water Surface Elevation") {
        if ($props{$id}{meta} =~ /^(data_profile|vert_wd_zone)$/) {
            %wsurf = %{ $gr_props{$id}{ws_elev} };

#           Adjust dt, if needed
            if (length($dt) == 12) {
                if ($gr_props{$id}{daily}) {
                    $dt = substr($dt,0,8);
                } elsif (! defined($wsurf{$dt})) {
                    for ($mi=1; $mi<=10; $mi++) {
                        $dt2 = &adjust_dt($dt, $mi);
                        if (defined($wsurf{$dt2})) {
                            $dt = $dt2;
                            last;
                        }
                        $dt2 = &adjust_dt($dt, -1 *$mi);
                        if (defined($wsurf{$dt2})) {
                            $dt = $dt2;
                            last;
                        }
                    }
                }
            }
            if (defined($wsurf{$dt}) && $wsurf{$dt} ne "na") {
                $ws_elev  = $wsurf{$dt};
                $ws_elev *= 3.28084 if ($units eq "ft");
                $link_txt = sprintf($fmt, $ws_elev) . " " . $units;
            } else {
                $link_txt = "na " . $units;
            }
            undef %wsurf;

        } elsif ($props{$id}{meta} eq "w2_profile") {
            %elev_data = %{ $gr_props{$id}{elev_data} };
            if (! defined($elev_data{$dt})) {
                for ($mi=1; $mi<=10; $mi++) {
                    $dt2 = &adjust_dt($dt, $mi);
                    if (defined($elev_data{$dt2})) {
                        $dt = $dt2;
                        last;
                    }
                    $dt2 = &adjust_dt($dt, -1 *$mi);
                    if (defined($elev_data{$dt2})) {
                        $dt = $dt2;
                        last;
                    }
                }
            }
            if (defined($elev_data{$dt})) {
                $ws_elev  = $elev_data{$dt};
                $ws_elev *= 3.28084 if ($units eq "ft");
                $link_txt = sprintf($fmt, $ws_elev) . " " . $units;
            } else {
                $link_txt = "na " . $units;
            }
            undef %elev_data;

        } elsif ($props{$id}{meta} eq "w2_outflow") {
            %qdata = %{ $gr_props{$id}{qdata} };
            if (! defined($qdata{$dt})) {
                for ($mi=1; $mi<=10; $mi++) {
                    $dt2 = &adjust_dt($dt, $mi);
                    if (defined($qdata{$dt2})) {
                        $dt = $dt2;
                        last;
                    }
                    $dt2 = &adjust_dt($dt, -1 *$mi);
                    if (defined($qdata{$dt2})) {
                        $dt = $dt2;
                        last;
                    }
                }
            }
            if (defined($qdata{$dt})) {
                @flows    = @{ $qdata{$dt} };
                $ws_elev  = $flows[1];
                $ws_elev *= 3.28084 if ($units eq "ft");
                $link_txt = sprintf($fmt, $ws_elev) . " " . $units;
            } else {
                $link_txt = "na " . $units;
            }
            undef %qdata;
            undef @flows;
        }

    } elsif ($type eq "Release Rate") {
        if ($props{$id}{meta} eq "vert_wd_zone") {
            %qdata = %{ $gr_props{$id}{qdata} };

#           Adjust dt, if needed
            if (length($dt) == 12) {
                if ($gr_props{$id}{daily}) {
                    $dt = substr($dt,0,8);
                } elsif (! defined($qdata{$dt})) {
                    for ($mi=1; $mi<=10; $mi++) {
                        $dt2 = &adjust_dt($dt, $mi);
                        if (defined($qdata{$dt2})) {
                            $dt = $dt2;
                            last;
                        }
                        $dt2 = &adjust_dt($dt, -1 *$mi);
                        if (defined($qdata{$dt2})) {
                            $dt = $dt2;
                            last;
                        }
                    }
                }
            }
            if (defined($qdata{$dt})) {
                $qsum  = 0;
                @names = @{ $gr_props{$id}{names} };
                @qstr  = @{ $qdata{$dt} };
                for ($i=0; $i<=$#qstr; $i++) {
                    if ($outlet eq "All Outlets") {
                        $qsum += $qstr[$i];
                    } elsif ($outlet eq $names[$i]) {
                        $qsum = $qstr[$i];
                        last;
                    }
                }
                $qsum *= 35.31467 if ($units eq "cfs");
                $link_txt = sprintf($fmt, $qsum) . " " . $units;
            } else {
                $link_txt = "na " . $units;
            }
            undef %qdata;

        } elsif ($props{$id}{meta} eq "w2_outflow") {
            %qdata = %{ $gr_props{$id}{qdata} };
            if (! defined($qdata{$dt})) {
                for ($mi=1; $mi<=10; $mi++) {
                    $dt2 = &adjust_dt($dt, $mi);
                    if (defined($qdata{$dt2})) {
                        $dt = $dt2;
                        last;
                    }
                    $dt2 = &adjust_dt($dt, -1 *$mi);
                    if (defined($qdata{$dt2})) {
                        $dt = $dt2;
                        last;
                    }
                }
            }
            if (defined($qdata{$dt})) {
                @flows  = @{ $qdata{$dt} };
                $qsum   = $flows[0];
                $qsum  *= 35.31467 if ($units eq "cfs");
                $link_txt = sprintf($fmt, $qsum) . " " . $units;
            } else {
                $link_txt = "na " . $units;
            }
            undef %qdata;
            undef @flows;
        }

    } elsif ($type eq "Temperature") {
        if ($props{$id}{meta} eq "vert_wd_zone") {
            %qdata = %{ $gr_props{$id}{qdata} };

#           Adjust dt, if needed
            if (length($dt) == 12) {
                if ($gr_props{$id}{daily}) {
                    $dt = substr($dt,0,8);
                } elsif (! defined($qdata{$dt})) {
                    for ($mi=1; $mi<=10; $mi++) {
                        $dt2 = &adjust_dt($dt, $mi);
                        if (defined($qdata{$dt2})) {
                            $dt = $dt2;
                            last;
                        }
                        $dt2 = &adjust_dt($dt, -1 *$mi);
                        if (defined($qdata{$dt2})) {
                            $dt = $dt2;
                            last;
                        }
                    }
                }
            }
            if (defined($qdata{$dt})) {
                if (defined($gr_props{$id}{tdata})) {
                    %tdata = %{ $gr_props{$id}{tdata} };  # Celsius
                }
                if (defined($tdata{$dt})) {
                    @names = @{ $gr_props{$id}{names} };
                    @tstr  = @{ $tdata{$dt} };
                    if ($outlet eq "All Outlets") {
                        $wt = $tstr[-1];
                    } else {
                        $i  = &list_match($outlet, @names);
                        $wt = $tstr[$i];
                    }
                    if ($wt > -99) {
                        if ($form ne "Text") {
                            @colors = @{ $gr_props{$id}{colors} };
                            $cs_min = $gr_props{$id}{cs_min};
                            $cs_max = $gr_props{$id}{cs_max};
                            if ($props{$id}{wt_units} eq "Fahrenheit") {
                                $i = int(($#colors+1) *(($wt *1.8 +32)-$cs_min)/($cs_max-$cs_min));
                            } else {
                                $i = int(($#colors+1) *($wt-$cs_min)/($cs_max-$cs_min));
                            }
                            $i     = &max(0, &min($#colors, $i));
                            $shade = $colors[$i];
                        }
                        $wt = 1.8 *$wt +32 if ($units eq "Fahrenheit");
                        $link_txt = sprintf($fmt, $wt) . "\N{U+00B0}" . substr($units,0,1);
                    } else {
                        $link_txt = "na " . "\N{U+00B0}" . substr($units,0,1);
                    }
                } else {
                    $link_txt = "na " . "\N{U+00B0}" . substr($units,0,1);
                }
                undef %tdata if (defined($gr_props{$id}{tdata}));
            } else {
                $link_txt = "na " . "\N{U+00B0}" . substr($units,0,1);
            }
            undef %qdata;
        }
    }

#   New link
    if ($link_id == 0) {
        $xo = ($x1+$x2)/2;
        $yo = ($y1+$y2)/2;
        if ($form eq "Text") {
            $link_id = $canv->create_text($xo, $yo,
                              -anchor => 'e', 
                              -fill   => '#000000',
                              -angle  => 0,
                              -text   => $link_txt,
                              -tags   => "keep" . " link_gr" . $id,
                              -font   => [ -family     => $font,
                                           -size       => $size,
                                           -weight     => $weight,
                                           -slant      => $slant_type[$slant],
                                           -underline  => 0,
                                           -overstrike => 0,
                                         ]);
            $props{$link_id}{type}      = lc($form);
            $props{$link_id}{text}      = $link_txt;
            $props{$link_id}{x}         = $xo;
            $props{$link_id}{y}         = $yo;
            $props{$link_id}{anchor}    = 'e';
            $props{$link_id}{coordlist} = [$xo, $yo];
            $props{$link_id}{color}     = "black";
            $props{$link_id}{family}    = $font;
            $props{$link_id}{size}      = $size;
            $props{$link_id}{weight}    = $weight;
            $props{$link_id}{slant}     = $slant;
            $props{$link_id}{underline} = 0;
            $props{$link_id}{angle}     = 0;
            &find_rect_from_text_or_image($canv, $link_id);

        } elsif ($form eq "Circle") {
            $link_id = $canv->create_oval($xo-10, $yo-10, $xo+10, $yo+10,
                              -outline => &get_rgb_code($color),
                              -width   => $width,
                              -fill    => $shade,
                              -tags    => "keep" . " link_gr" . $id);
            if ($width == 0) {
                $canv->itemconfigure($link_id, -outline => "");
            }
            $props{$link_id}{type}      = lc($form);
            $props{$link_id}{x}         = $xo;
            $props{$link_id}{y}         = $yo;
            $props{$link_id}{xc}        = $xo;
            $props{$link_id}{yc}        = $yo;
            $props{$link_id}{anchor}    = 'center';
            $props{$link_id}{coordlist} = [$xo-10, $yo-10, $xo+10, $yo+10];
            $props{$link_id}{color}     = $color;
            $props{$link_id}{width}     = $width;
            $props{$link_id}{fill}      = 1;
            $props{$link_id}{fillcolor} = $shade;

        } else {
            if ($form eq "Ellipse") {
                @coords = &make_shape_coords("ellipse", $xo, $yo, 20, 10, 0);
            } elsif ($form eq "Rectangle") {
                @coords = ($xo-20, $yo-10, $xo+20, $yo-10,
                           $xo+20, $yo+10, $xo-20, $yo+10);
            } elsif ($form eq "Diamond") {
                @coords = ($xo-20, $yo, $xo, $yo-10,
                           $xo+20, $yo, $xo, $yo+10);
            } else {
                @coords = ($xo-20, $yo-10, $xo+10, $yo-10, $xo+20, $yo,
                           $xo+10, $yo+10, $xo-20, $yo+10);
            }
            $link_id = $canv->create_polygon(@coords,
                              -outline => &get_rgb_code($color),
                              -width   => $width,
                              -fill    => $shade,
                              -smooth  => 'false',
                              -tags    => "keep" . " link_gr" . $id);
            if ($width == 0) {
                $canv->itemconfigure($link_id, -outline => "");
            }
            $props{$link_id}{type}      = lc($form);
            $props{$link_id}{x}         = $xo;
            $props{$link_id}{y}         = $yo;
            $props{$link_id}{xc}        = $xo;
            $props{$link_id}{yc}        = $yo;
            $props{$link_id}{anchor}    = 'center';
            $props{$link_id}{coordlist} = [ @coords ];
            $props{$link_id}{color}     = $color;
            $props{$link_id}{width}     = $width;
            $props{$link_id}{fill}      = 1;
            $props{$link_id}{fillcolor} = $shade;
            $props{$link_id}{angle}     = 0;
            $props{$link_id}{angle_tmp} = 0;
            $props{$link_id}{smooth}    = 0;
            if ($form eq "Ellipse") {
                $props{$link_id}{hw}    = 20;
                $props{$link_id}{hh}    = 10;
            } elsif ($form eq "Polygon") {
                ($xo, $yo, $r) = &smallest_circle(@coords);
                $props{$link_id}{xc_rot} = $xo;
                $props{$link_id}{yc_rot} = $yo;
            }
        }
        $canv->g_bind("<Motion>",   [ \&move_object, Tkx::Ev("%x","%y"), $canv, $link_id, $xo, $yo, "", 0 ]);
        $canv->g_bind("<Button-1>", [ \&end_move_object, $canv, $link_id, "" ]);
        $canv->g_bind("<Button-3>", [ \&forget_link, $canv, $link_id ]);

#   Existing link
    } else {
        $save_id = $link_id;
        if ($form eq "Text") {
            if ($link_props{$link_id}{form} eq "Text") {
                $props{$link_id}{text}   = $link_txt;
                $props{$link_id}{family} = $font;
                $props{$link_id}{size}   = $size;
                $props{$link_id}{weight} = $weight;
                $props{$link_id}{slant}  = $slant;
                $canv->itemconfigure($link_id,
                              -text => $link_txt,
                              -font => [ -family     => $font,
                                         -size       => $size,
                                         -weight     => $weight,
                                         -slant      => $slant_type[$slant],
                                         -underline  => $props{$link_id}{underline},
                                         -overstrike => 0,
                                       ]);
                &find_rect_from_text_or_image($canv, $link_id);
            } else {
                $xo  = $props{$save_id}{x};
                $yo  = $props{$save_id}{y};
                $ang = (defined($props{$save_id}{angle})) ? $props{$save_id}{angle} : 0;
                $link_id = $canv->create_text($xo, $yo,
                              -anchor => 'e', 
                              -fill   => &get_rgb_code($props{$save_id}{color}),
                              -angle  => $ang,
                              -text   => $link_txt,
                              -tags   => "keep" . " link_gr" . $id,
                              -font   => [ -family     => $font,
                                           -size       => $size,
                                           -weight     => $weight,
                                           -slant      => $slant_type[$slant],
                                           -underline  => 0,
                                           -overstrike => 0,
                                         ]);
                $props{$link_id}{type}      = lc($form);
                $props{$link_id}{text}      = $link_txt;
                $props{$link_id}{x}         = $xo;
                $props{$link_id}{y}         = $yo;
                $props{$link_id}{anchor}    = 'e';
                $props{$link_id}{coordlist} = [$xo, $yo];
                $props{$link_id}{color}     = $props{$save_id}{color};
                $props{$link_id}{family}    = $font;
                $props{$link_id}{size}      = $size;
                $props{$link_id}{weight}    = $weight;
                $props{$link_id}{slant}     = $slant;
                $props{$link_id}{underline} = 0;
                $props{$link_id}{angle}     = $ang;
                &find_rect_from_text_or_image($canv, $link_id);

                $canv->lower($link_id, $save_id);
                $canv->delete($save_id);
                delete $props{$save_id};
                delete $link_props{$save_id};
                undef $old_id if (defined($old_id));
            }
        } elsif ($form eq "Circle") {
            if ($link_props{$link_id}{form} eq "Circle") {
                $props{$link_id}{width} = $width;
                $props{$link_id}{color} = $color;
                $canv->itemconfigure($link_id,
                              -outline => &get_rgb_code($color),
                              -width   => $width);
                if ($width == 0) {
                    $canv->itemconfigure($link_id, -outline => "");
                }
            } else {
                if ($link_props{$link_id}{form} eq "Text") {
                    $xo = $props{$save_id}{x};
                    $yo = $props{$save_id}{y};
                } else {
                    $xo = $props{$save_id}{xc};
                    $yo = $props{$save_id}{yc};
                }
                $link_id = $canv->create_oval($xo-10, $yo-10, $xo+10, $yo+10,
                              -outline => &get_rgb_code($color),
                              -width   => $width,
                              -fill    => $shade,
                              -tags    => "keep" . " link_gr" . $id);
                if ($width == 0) {
                    $canv->itemconfigure($link_id, -outline => "");
                }
                $props{$link_id}{type}      = lc($form);
                $props{$link_id}{x}         = $xo;
                $props{$link_id}{y}         = $yo;
                $props{$link_id}{xc}        = $xo;
                $props{$link_id}{yc}        = $yo;
                $props{$link_id}{anchor}    = 'center';
                $props{$link_id}{coordlist} = [$xo-10, $yo-10, $xo+10, $yo+10];
                $props{$link_id}{color}     = $color;
                $props{$link_id}{width}     = $width;
                $props{$link_id}{fill}      = 1;
                $props{$link_id}{fillcolor} = $shade;

                $canv->lower($link_id, $save_id);
                $canv->delete($save_id);
                delete $props{$save_id};
                delete $link_props{$save_id};
                undef $old_id if (defined($old_id));
            }
        } else {
            if ($link_props{$link_id}{form} =~ /^(Ellipse|Rectangle|Diamond|Polygon)$/) {
                if ($form ne $link_props{$link_id}{form}) {
                    $xo  = $props{$link_id}{xc};
                    $yo  = $props{$link_id}{yc};
                    $ang = $props{$link_id}{angle};
                    if ($form eq "Ellipse") {
                        @coords = &make_shape_coords("ellipse", $xo, $yo, 20, 10, $ang);
                    } elsif ($form eq "Rectangle") {
                        @coords = &make_shape_coords("rectangle", $xo, $yo, 20, 10, $ang);
                        $props{$link_id}{smooth} = 0 if ($link_props{$link_id}{form} ne "Diamond");
                    } elsif ($form eq "Diamond") {
                        @coords = &make_shape_coords("diamond", $xo, $yo, 20, 10, $ang);
                        $props{$link_id}{smooth} = 0 if ($link_props{$link_id}{form} ne "Rectangle");
                    } else {
                        @coords = ($xo-20, $yo-10, $xo+10, $yo-10, $xo+20, $yo,
                                   $xo+10, $yo+10, $xo-20, $yo+10);
                        if ($ang != 0) {
                            @coords = &resize_shape(\@coords, 0, $xo, $yo, 40, 20, $ang);
                        }
                    }
                    $canv->coords($link_id, @coords);
                    $props{$link_id}{type}      = lc($form);
                    $props{$link_id}{coordlist} = [ @coords ];
                    if ($form eq "Ellipse") {
                        $props{$link_id}{hw}    = 20;
                        $props{$link_id}{hh}    = 10;
                    } elsif ($form eq "Polygon") {
                        ($xo, $yo, $r) = &smallest_circle(@coords);
                        $props{$link_id}{xc_rot} = $xo;
                        $props{$link_id}{yc_rot} = $yo;
                    }
                }
                $canv->itemconfigure($link_id,
                              -outline => &get_rgb_code($color),
                              -width   => $width);
                if ($width == 0) {
                    $canv->itemconfigure($link_id, -outline => "");
                }
                $props{$link_id}{width} = $width;
                $props{$link_id}{color} = $color;
            } else {
                if ($link_props{$link_id}{form} eq "Text") {
                    $xo  = $props{$save_id}{x};
                    $yo  = $props{$save_id}{y};
                    $ang = $props{$save_id}{angle};
                } else {
                    $xo  = $props{$save_id}{xc};
                    $yo  = $props{$save_id}{yc};
                    $ang = 0;
                }
                if ($form eq "Ellipse") {
                    @coords = &make_shape_coords("ellipse", $xo, $yo, 20, 10, $ang);
                } elsif ($form eq "Rectangle") {
                    @coords = &make_shape_coords("rectangle", $xo, $yo, 20, 10, $ang);
                } elsif ($form eq "Diamond") {
                    @coords = &make_shape_coords("diamond", $xo, $yo, 20, 10, $ang);
                } else {
                    @coords = ($xo-20, $yo-10, $xo+10, $yo-10, $xo+20, $yo,
                               $xo+10, $yo+10, $xo-20, $yo+10);
                    if ($ang != 0) {
                        @coords = &resize_shape(\@coords, 0, $xo, $yo, 40, 20, $ang);
                    }
                }
                $link_id = $canv->create_polygon(@coords,
                              -outline => &get_rgb_code($color),
                              -width   => $width,
                              -fill    => $shade,
                              -smooth  => 'false',
                              -tags    => "keep" . " link_gr" . $id);
                if ($width == 0) {
                    $canv->itemconfigure($link_id, -outline => "");
                }
                $props{$link_id}{type}      = lc($form);
                $props{$link_id}{x}         = $xo;
                $props{$link_id}{y}         = $yo;
                $props{$link_id}{xc}        = $xo;
                $props{$link_id}{yc}        = $yo;
                $props{$link_id}{anchor}    = 'center';
                $props{$link_id}{coordlist} = [ @coords ];
                $props{$link_id}{color}     = $color;
                $props{$link_id}{width}     = $width;
                $props{$link_id}{fill}      = 1;
                $props{$link_id}{fillcolor} = $shade;
                $props{$link_id}{angle}     = $ang;
                $props{$link_id}{angle_tmp} = $ang;
                $props{$link_id}{smooth}    = 0;
                if ($form eq "Ellipse") {
                    $props{$link_id}{hw}    = 20;
                    $props{$link_id}{hh}    = 10;
                } elsif ($form eq "Polygon") {
                    ($xo, $yo, $r) = &smallest_circle(@coords);
                    $props{$link_id}{xc_rot} = $xo;
                    $props{$link_id}{yc_rot} = $yo;
                }

                $canv->lower($link_id, $save_id);
                $canv->delete($save_id);
                delete $props{$save_id};
                delete $link_props{$save_id};
                undef $old_id if (defined($old_id));
            }
        }
    }

    $link_props{$link_id}{id}     = $id;
    $link_props{$link_id}{gnum}   = $props{$id}{gnum};
    $link_props{$link_id}{type}   = $type;
    $link_props{$link_id}{outlet} = $outlet;
    $link_props{$link_id}{form}   = $form;
    $link_props{$link_id}{units}  = $units;
    $link_props{$link_id}{digits} = $digits;

    $edit_link_menu->g_destroy();
    undef $edit_link_menu;
}


sub update_links {
    my ($canv, $id, $dt) = @_;
    my (
        $cs_max, $cs_min, $digits, $dt2, $fmt, $form, $i, $item, $link_txt,
        $mi, $outlet, $qsum, $shade, $type, $units, $ws_elev, $wt,

        @colors, @flows, @items, @names, @qstr, @tstr,

        %elev_data, %qdata, %tdata, %wsurf,
       );

    @items = Tkx::SplitList($canv->find_withtag("link_gr" . $id));
    return if ($#items < 0);

    foreach $item ( @items ) {
        next if ($link_props{$item}{id} != $id);

        $form = $link_props{$item}{form};
        if ($form eq "stat") {
            &update_stat_link($canv, $item, $dt);
            next;
        }
        if ($form ne "Text" && ! $gr_props{$id}{add_cs}) {
            $canv->itemconfigure($item, -fill => "");
            $props{$item}{fillcolor} = "";
            next;
        }
        $type   = $link_props{$item}{type};
        $units  = $link_props{$item}{units};
        $digits = $link_props{$item}{digits};
        $shade  = "";
        $fmt    = "%.${digits}f";

        if ($type eq "Water Surface Elevation") {
            if ($props{$id}{meta} =~ /^(data_profile|vert_wd_zone)$/) {
                %wsurf = %{ $gr_props{$id}{ws_elev} };
                if (length($dt) == 12) {
                    if ($gr_props{$id}{daily}) {
                        $dt = substr($dt,0,8);
                    } elsif (! defined($wsurf{$dt})) {
                        for ($mi=1; $mi<=10; $mi++) {
                            $dt2 = &adjust_dt($dt, $mi);
                            if (defined($wsurf{$dt2})) {
                                $dt = $dt2;
                                last;
                            }
                            $dt2 = &adjust_dt($dt, -1 *$mi);
                            if (defined($wsurf{$dt2})) {
                                $dt = $dt2;
                                last;
                            }
                        }
                    }
                }
                if (defined($wsurf{$dt}) && $wsurf{$dt} ne "na") {
                    $ws_elev  = $wsurf{$dt};
                    $ws_elev *= 3.28084 if ($units eq "ft");
                    $link_txt = sprintf($fmt, $ws_elev) . " " . $units;
                } else {
                    $link_txt = "na " . $units;
                }
                undef %wsurf;

            } elsif ($props{$id}{meta} eq "w2_profile") {
                %elev_data = %{ $gr_props{$id}{elev_data} };
                if (! defined($elev_data{$dt})) {
                    for ($mi=1; $mi<=10; $mi++) {
                        $dt2 = &adjust_dt($dt, $mi);
                        if (defined($elev_data{$dt2})) {
                            $dt = $dt2;
                            last;
                        }
                        $dt2 = &adjust_dt($dt, -1 *$mi);
                        if (defined($elev_data{$dt2})) {
                            $dt = $dt2;
                            last;
                        }
                    }
                }
                if (defined($elev_data{$dt})) {
                    $ws_elev  = $elev_data{$dt};
                    $ws_elev *= 3.28084 if ($units eq "ft");
                    $link_txt = sprintf($fmt, $ws_elev) . " " . $units;
                } else {
                    $link_txt = "na " . $units;
                }
                undef %elev_data;

            } elsif ($props{$id}{meta} eq "w2_outflow") {
                %qdata = %{ $gr_props{$id}{qdata} };
                if (! defined($qdata{$dt})) {
                    for ($mi=1; $mi<=10; $mi++) {
                        $dt2 = &adjust_dt($dt, $mi);
                        if (defined($qdata{$dt2})) {
                            $dt = $dt2;
                            last;
                        }
                        $dt2 = &adjust_dt($dt, -1 *$mi);
                        if (defined($qdata{$dt2})) {
                            $dt = $dt2;
                            last;
                        }
                    }
                }
                if (defined($qdata{$dt})) {
                    @flows    = @{ $qdata{$dt} };
                    $ws_elev  = $flows[1];
                    $ws_elev *= 3.28084 if ($units eq "ft");
                    $link_txt = sprintf($fmt, $ws_elev) . " " . $units;
                } else {
                    $link_txt = "na " . $units;
                }
                undef %qdata;
                undef @flows;
            }

        } elsif ($type eq "Release Rate") {
            if ($props{$id}{meta} eq "vert_wd_zone") {
                %qdata = %{ $gr_props{$id}{qdata} };

#               Adjust dt, if needed
                if (length($dt) == 12) {
                    if ($gr_props{$id}{daily}) {
                        $dt = substr($dt,0,8);
                    } elsif (! defined($qdata{$dt})) {
                        for ($mi=1; $mi<=10; $mi++) {
                            $dt2 = &adjust_dt($dt, $mi);
                            if (defined($qdata{$dt2})) {
                                $dt = $dt2;
                                last;
                            }
                            $dt2 = &adjust_dt($dt, -1 *$mi);
                            if (defined($qdata{$dt2})) {
                                $dt = $dt2;
                                last;
                            }
                        }
                    }
                }
                if (defined($qdata{$dt})) {
                    $qsum   = 0;
                    $outlet = $link_props{$item}{outlet};
                    @names  = @{ $gr_props{$id}{names} };
                    @qstr   = @{ $qdata{$dt} };
                    for ($i=0; $i<=$#qstr; $i++) {
                        if ($outlet eq "All Outlets") {
                            $qsum += $qstr[$i];
                        } elsif ($outlet eq $names[$i]) {
                            $qsum = $qstr[$i];
                            last;
                        }
                    }
                    $qsum *= 35.31467 if ($units eq "cfs");
                    $link_txt = sprintf($fmt, $qsum) . " " . $units;
                } else {
                    $link_txt = "na " . $units;
                }
                undef %qdata;

            } elsif ($props{$id}{meta} eq "w2_outflow") {
                %qdata = %{ $gr_props{$id}{qdata} };
                if (! defined($qdata{$dt})) {
                    for ($mi=1; $mi<=10; $mi++) {
                        $dt2 = &adjust_dt($dt, $mi);
                        if (defined($qdata{$dt2})) {
                            $dt = $dt2;
                            last;
                        }
                        $dt2 = &adjust_dt($dt, -1 *$mi);
                        if (defined($qdata{$dt2})) {
                            $dt = $dt2;
                            last;
                        }
                    }
                }
                if (defined($qdata{$dt})) {
                    @flows  = @{ $qdata{$dt} };
                    $qsum   = $flows[0];
                    $qsum  *= 35.31467 if ($units eq "cfs");
                    $link_txt = sprintf($fmt, $qsum) . " " . $units;
                } else {
                    $link_txt = "na " . $units;
                }
                undef %qdata;
                undef @flows;
            }

        } elsif ($type eq "Temperature") {
            if ($props{$id}{meta} eq "vert_wd_zone") {
                %qdata = %{ $gr_props{$id}{qdata} };

#               Adjust dt, if needed
                if (length($dt) == 12) {
                    if ($gr_props{$id}{daily}) {
                        $dt = substr($dt,0,8);
                    } elsif (! defined($qdata{$dt})) {
                        for ($mi=1; $mi<=10; $mi++) {
                            $dt2 = &adjust_dt($dt, $mi);
                            if (defined($qdata{$dt2})) {
                                $dt = $dt2;
                                last;
                            }
                            $dt2 = &adjust_dt($dt, -1 *$mi);
                            if (defined($qdata{$dt2})) {
                                $dt = $dt2;
                                last;
                            }
                        }
                    }
                }
                if (defined($qdata{$dt})) {
                    if (defined($gr_props{$id}{tdata})) {
                        %tdata = %{ $gr_props{$id}{tdata} };  # Celsius
                    }
                    if (defined($tdata{$dt})) {
                        $outlet = $link_props{$item}{outlet};
                        @names  = @{ $gr_props{$id}{names} };
                        @tstr   = @{ $tdata{$dt} };
                        if ($outlet eq "All Outlets") {
                            $wt = $tstr[-1];
                        } else {
                            $i  = &list_match($outlet, @names);
                            $wt = $tstr[$i];
                        }
                        if ($wt > -99) {
                            if ($form ne "Text" && $gr_props{$id}{add_cs}) {
                                @colors = @{ $gr_props{$id}{colors} };
                                $cs_min = $gr_props{$id}{cs_min};
                                $cs_max = $gr_props{$id}{cs_max};
                                if ($props{$id}{wt_units} eq "Fahrenheit") {
                                    $i = int(($#colors+1) *(($wt *1.8 +32)-$cs_min)/($cs_max-$cs_min));
                                } else {
                                    $i = int(($#colors+1) *($wt-$cs_min)/($cs_max-$cs_min));
                                }
                                $i     = &max(0, &min($#colors, $i));
                                $shade = $colors[$i];
                            }
                            $wt = 1.8 *$wt +32 if ($units eq "Fahrenheit");
                            $link_txt = sprintf($fmt, $wt) . "\N{U+00B0}" . substr($units,0,1);
                        } else {
                            $link_txt = "na " . "\N{U+00B0}" . substr($units,0,1);
                        }
                    } else {
                        $link_txt = "na " . "\N{U+00B0}" . substr($units,0,1);
                    }
                    undef %tdata if (defined($gr_props{$id}{tdata}));
                } else {
                    $link_txt = "na " . "\N{U+00B0}" . substr($units,0,1);
                }
                undef %qdata;
            }
        }

        if ($form eq "Text") {
            $canv->itemconfigure($item, -text => $link_txt);
            $props{$item}{text} = $link_txt;
        } else {
            $canv->itemconfigure($item, -fill => $shade);
            $props{$item}{fillcolor} = $shade;
        }
    }
}


sub edit_stat_link {
    my ($canv, $id, $X, $Y, $link_id) = @_;
    my (
        $btn_txt, $code, $color, $color_btn, $digits, $digits_sb,
        $digits_tmp, $f, $fg, $font, $font_cb, $frame, $geom, $interp,
        $link_frame, $link_txt, $ph, $preview_canv, $preview_txt, $pw,
        $row, $size, $size_cb, $slant, $tol, $tol_frame, $type, $type_cb,
        $units, $weight, $weight_cb,

        @link_types,
       );

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($edit_stat_link_menu) && Tkx::winfo_exists($edit_stat_link_menu)) {
        if ($edit_stat_link_menu->g_wm_title() eq "Add or Edit Goodness-of-Fit Link") {
            $edit_stat_link_menu->g_destroy();
            undef $edit_stat_link_menu;
        }
    }
    $edit_stat_link_menu = $main->new_toplevel();
    $edit_stat_link_menu->g_wm_transient($main);
    $edit_stat_link_menu->g_wm_title("Add or Edit Goodness-of-Fit Link");
    $edit_stat_link_menu->configure(-cursor => $cursor_norm);
    $edit_stat_link_menu->g_wm_geometry($geom);

    if ($link_id != 0) {
        @link_types = ("Number of Points", "Mean Error", "Mean Absolute Error", "Root Mean Square Error");
        $type    = $link_props{$link_id}{type};
        $digits  = $link_props{$link_id}{digits};
        $interp  = $link_props{$link_id}{interp};
        $tol     = $link_props{$link_id}{tol};
        $font    = $props{$link_id}{family};
        $size    = $props{$link_id}{size};
        $weight  = $props{$link_id}{weight};
        $color   = $props{$link_id}{color};
        $slant   = $slant_type[$props{$link_id}{slant}];
        $btn_txt = "Modify";
        if ($type eq "n") {
            $type     = "Number of Points";
            $link_txt = "N: 15";
        } else {
            $link_txt = uc($type) . ": " . sprintf("%.${digits}f", "1.234");
            if ($type eq "me") {
                $type = "Mean Error";
            } elsif ($type eq "mae") {
                $type = "Mean Absolute Error";
            } elsif ($type eq "rmse") {
                $type = "Root Mean Square Error";
            }
        }
    } else {
        @link_types = ("Mean Error", "Mean Absolute Error", "Root Mean Square Error", "Stats Table");
        $type     = "Mean Absolute Error";
        $font     = $default_family;
        $size     = $default_size;
        $weight   = $default_weight;
        $color    = $default_color;
        $slant    = $slant_type[$default_slant];
        $digits   = 2;
        $interp   = 0;
        $tol      = 10;
        $link_txt = "MAE: " . sprintf("%.${digits}f", "1.234");
        $btn_txt  = "Create";
        &end_select($canv, $id, 1);
    }
    $digits_tmp = $digits;

    if ($props{$id}{parm} eq "Temperature") {
        $units = "\N{U+00B0}" . substr($props{$id}{parm_units},0,1);
    } else {
        $units = $props{$id}{parm_units};
        $units = " " . $units if ($units ne "");
    }
    $link_txt .= $units if ($type ne "Number of Points");

    $pw = 260;
    $ph =  45;

    $frame = $edit_stat_link_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    $frame->new_button(
            -text    => $btn_txt,
            -command => sub { $edit_stat_link_menu->g_destroy();
                              undef $edit_stat_link_menu;
                              &set_stat_link($canv, $id, $link_id, $type, $digits,
                                             $font, $weight, $size, $color, $tol, $interp);
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $edit_stat_link_menu->g_destroy();
                              undef $edit_stat_link_menu; },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

    $f = $edit_stat_link_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f->g_pack(-side => 'top');

    ($preview_canv = $f->new_canvas(
            -background  => &get_rgb_code($canvas_color),
            -width       => $pw,
            -height      => $ph,
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_grid(-row => 0, -column => 0, -sticky => 'wne');

    $preview_txt = $preview_canv->create_text($pw*0.5 +3, $ph*0.5 +3,
            -anchor => 'center', 
            -text   => $link_txt,
            -fill   => &get_rgb_code($color),
            -angle  => 0,
            -font   => [-family     => $font,
                        -size       => $size,
                        -weight     => $weight,
                        -slant      => $slant,
                        -underline  => ($link_id != 0) ? $props{$link_id}{underline} : 0,
                        -overstrike => 0,
                       ]);
    if (&get_rgb_code($color) eq &get_rgb_code($canvas_color)) {
        $code = &get_rgb_code(&get_bw_contrast(&get_rgb_code($color)));
        $preview_canv->configure(-background => $code);
    }

    ($link_frame = $f->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_grid(-row => 1, -column => 0, -sticky => 'wnes');

    $row = 0;
    $link_frame->new_label(
            -text => "Link Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($type_cb = $link_frame->new_ttk__combobox(
            -textvariable => \$type,
            -values       => [ @link_types ],
            -width        => 22,
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $type_cb->g_bind("<<ComboboxSelected>>",
              sub { my ($txt);
                    if ($type eq "Number of Points") {
                        $link_txt   = "N: 15";
                        $digits_tmp = $digits;
                        $digits     = 0;
                        $digits_sb->configure(-state => 'disabled');
                    } else {
                        if ($type eq "Mean Error") {
                            $txt = "ME: ";
                        } elsif ($type eq "Mean Absolute Error") {
                            $txt = "MAE: ";
                        } elsif ($type eq "Root Mean Square Error") {
                            $txt = "RMSE: ";
                        } elsif ($type eq "Stats Table") {
                            $txt = "Stat: ";
                        }
                        $digits_sb->configure(-state => 'readonly');
                        $digits   = $digits_tmp;
                        $link_txt = $txt . sprintf("%.${digits}f", "1.234") . $units;
                    }
                    $preview_canv->itemconfigure($preview_txt, -text => $link_txt);
                  });

    $row++;
    $link_frame->new_label(
            -text => "Decimal Digits: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($digits_sb = $link_frame->new_spinbox(
            -textvariable => \$digits,
            -state        => 'readonly',
            -font         => 'default',
            -from         => 0,
            -to           => 5,
            -increment    => 1,
            -width        => 3,
            -command      => sub { my ($txt);
                                   if ($type eq "Mean Error") {
                                       $txt = "ME: ";
                                   } elsif ($type eq "Mean Absolute Error") {
                                       $txt = "MAE: ";
                                   } elsif ($type eq "Root Mean Square Error") {
                                       $txt = "RMSE: ";
                                   } elsif ($type eq "Stats Table") {
                                       $txt = "Stat: ";
                                   }
                                   $digits_tmp = $digits;
                                   $link_txt   = $txt . sprintf("%.${digits}f", "1.234") . $units;
                                   $preview_canv->itemconfigure($preview_txt, -text => $link_txt);
                                 },
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    if ($link_id == 0) {  # new stat link
        $row++;
        $link_frame->new_label(
                -text => "Link Text Font: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($font_cb = $link_frame->new_ttk__combobox(
                -textvariable => \$font,
                -values       => [ sort @available_fonts ],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
        $font_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_canv->itemconfigure($preview_txt,
                              -font => [ -family     => $font,
                                         -size       => $size,
                                         -weight     => $weight,
                                         -slant      => $slant,
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });
        $row++;
        $link_frame->new_label(
                -text => "Link Text Size: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($size_cb = $link_frame->new_ttk__combobox(
                -textvariable => \$size,
                -values       => [(5 .. 24)],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
        $size_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_canv->itemconfigure($preview_txt,
                              -font => [ -family     => $font,
                                         -size       => $size,
                                         -weight     => $weight,
                                         -slant      => $slant,
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });
        $row++;
        $link_frame->new_label(
                -text => "Link Text Weight: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($weight_cb = $link_frame->new_ttk__combobox(
                -textvariable => \$weight,
                -values       => [("normal", "bold")],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
        $weight_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_canv->itemconfigure($preview_txt,
                              -font => [ -family     => $font,
                                         -size       => $size,
                                         -weight     => $weight,
                                         -slant      => $slant,
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });
        $row++;
        $link_frame->new_label(
                -text => "Link Text Color: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $code  = &get_rgb_code($color);
        $color = &get_rgb_name($code);
        $fg    = &get_rgb_code("black");
        if ($code =~ /^\#[0-9a-f]/i) {
            $fg = &get_rgb_code(&get_bw_contrast($code));
        }
        ($color_btn = $link_frame->new_button(
                -textvariable => \$color,
                -background   => $code,
                -foreground   => $fg,
                -width        => -7,
                -command => sub {
                              my ($newc, $code, $fg);
                              $code = &get_rgb_code($color);
                              $newc = Tkx::tk___chooseColor(
                                         -initialcolor => $code,
                                         -parent       => $edit_stat_link_menu);
                              if ($newc) {
                                $code  = &get_rgb_code($newc);
                                $color = &get_rgb_name($code);
                                $fg    = &get_rgb_code("black");
                                if ($code =~ /^#?[0-9a-f]/i) {
                                    $fg = &get_rgb_code(&get_bw_contrast($code));
                                }
                                $color_btn->configure(-foreground => $fg,
                                                      -background => $code);
                                $preview_canv->itemconfigure($preview_txt, -fill => $code);
                                if ($code eq &get_rgb_code($canvas_color)) {
                                    $code = &get_rgb_code(&get_bw_contrast(&get_rgb_code($color)));
                                    $preview_canv->configure(-background => $code);
                                } else {
                                    $preview_canv->configure(-background => &get_rgb_code($canvas_color));
                                }
                              }
                            }
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    }

    $row++;
    $link_frame->new_label(
            -text => "Match Tolerance: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($tol_frame = $link_frame->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w');
    $tol_frame->new_spinbox(
            -textvariable => \$tol,
            -state        => 'readonly',
            -font         => 'default',
            -from         => 0,
            -to           => 180,
            -increment    => 1,
            -width        => 4,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $tol_frame->new_label(
            -text => " minutes",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');

    $row++;
    $link_frame->new_checkbutton(
            -onvalue  => 1,
            -offvalue => 0,
            -text     => "Interpolate model profile vertically",
            -font     => 'default',
            -variable => \$interp,
            )->g_grid(-row => $row, -column => 0, -columnspan => 2, -sticky => 'e', -pady => 2);

    if ($type eq "Number of Points") {
        $digits_sb->configure(-state => 'disabled');
    }
    Tkx::wm_resizable($edit_stat_link_menu,0,0);
    &adjust_window_position($edit_stat_link_menu);
    $edit_stat_link_menu->g_focus;
}


sub set_stat_link {
    my ($canv, $id, $link_id, $type, $digits, $font, $weight, $size, $color, $tol, $interp) = @_;
    my (
        $dt, $group_tag, $link_txt, $seg, $stat, $stat_type, $units, $x1,
        $x2, $xo, $y1, $y2, $yo,

        @coords, @items,

        %elev_data, %parm_data, %ref_data, %stats,
        );

    ($x1, $y1, $x2, $y2) = Tkx::SplitList($canv->coords($id));
    $xo = ($x1+$x2)/2;
    $yo = ($y1+$y2)/2;

    if ($props{$id}{parm} eq "Temperature") {
        $units = "\N{U+00B0}" . substr($props{$id}{parm_units},0,1);
    } else {
        $units = $props{$id}{parm_units};
        $units = " " . $units if ($units ne "");
    }
    $dt        = $dates[$dti-1];
    $seg       = $props{$id}{seg};
    %elev_data = %{ $gr_props{$id}{elev_data} };
    %parm_data = %{ $gr_props{$id}{parm_data} };
    %ref_data  = %{ $gr_props{$id}{ref_data}  };

#   Compute the stats for date/time dt
    %stats = &get_stats_single_profile($id, $dt, $seg, $tol, $interp,
                                       \%elev_data, \%parm_data, \%ref_data);
    undef %elev_data;
    undef %parm_data;
    undef %ref_data;

#   Create a new stats table with N, ME, MAE, RMSE
    if ($type eq "Stats Table" && $link_id == 0) {
        @items = ();
        foreach $stat_type ("n", "me", "mae", "rmse") {
            $stat = $stats{$stat_type};
            if ($stat eq "na" || $stat_type eq "n") {
                $link_txt = uc($stat_type) . ": " . $stat;
                if ($stat_type ne "n") {
                    if ($units =~ /^ /) {
                        $link_txt .= $units;
                    } else {
                        $link_txt .= " " . $units;
                    }
                }
            } else {
                if ($props{$id}{parm} eq "Temperature" && $props{$id}{parm_units} eq "Fahrenheit") {
                    $stat *= 1.8;
                }
                $link_txt = uc($stat_type) . ": " . sprintf("%.${digits}f", $stat) . $units;
            }
            $link_id = $canv->create_text($xo, $yo,
                                  -anchor => 'e', 
                                  -fill   => &get_rgb_code($color),
                                  -angle  => 0,
                                  -text   => $link_txt,
                                  -tags   => "keep" . " link_gr" . $id,
                                  -font   => [ -family     => $font,
                                               -size       => $size,
                                               -weight     => $weight,
                                               -slant      => $slant_type[$default_slant],
                                               -underline  => 0,
                                               -overstrike => 0,
                                             ]);
            $props{$link_id}{type}      = "text";
            $props{$link_id}{text}      = $link_txt;
            $props{$link_id}{x}         = $xo;
            $props{$link_id}{y}         = $yo;
            $props{$link_id}{anchor}    = 'e';
            $props{$link_id}{coordlist} = [$xo, $yo];
            $props{$link_id}{color}     = $color;
            $props{$link_id}{family}    = $font;
            $props{$link_id}{size}      = $size;
            $props{$link_id}{weight}    = $weight;
            $props{$link_id}{slant}     = $default_slant;
            $props{$link_id}{underline} = 0;
            $props{$link_id}{angle}     = 0;
            &find_rect_from_text_or_image($canv, $link_id);

            push (@items, $link_id);

            $link_props{$link_id}{id}     = $id;
            $link_props{$link_id}{gnum}   = $props{$id}{gnum};
            $link_props{$link_id}{form}   = "stat";
            $link_props{$link_id}{type}   = $stat_type;
            $link_props{$link_id}{tol}    = $tol;
            $link_props{$link_id}{interp} = $interp;
            if ($stat_type eq "n") {
                $link_props{$link_id}{digits} = 0;
            } else {
                $link_props{$link_id}{digits} = $digits;
            }
            @coords = Tkx::SplitList($canv->bbox($link_id));
            $yo    += &max(10, abs($coords[3] - $coords[1])) +2;
        }
        $group_tag = &group_items($canv, @items);
        &begin_move($canv, $group_tag, "group");

#   Create or edit a single stat link
    } else {
        if ($type eq "Number of Points" || $type eq "n") {
            $stat_type = "n";
        } elsif ($type eq "Mean Error" || $type eq "me") {
            $stat_type = "me";
        } elsif ($type eq "Mean Absolute Error" || $type eq "mae") {
            $stat_type = "mae";
        } elsif ($type eq "Root Mean Square Error" || $type eq "rmse") {
            $stat_type = "rmse";
        }
        $stat = $stats{$stat_type};
        if ($stat eq "na" || $type eq "Number of Points" || $type eq "n") {
            $link_txt = uc($stat_type) . ": " . $stat;
            if ($type ne "Number of Points" && $type ne "n") {
                if ($units =~ /^ /) {
                    $link_txt .= $units;
                } else {
                    $link_txt .= " " . $units;
                }
            }
        } else {
            if ($props{$id}{parm} eq "Temperature" && $props{$id}{parm_units} eq "Fahrenheit") {
                $stat *= 1.8;
            }
            $link_txt = uc($stat_type) . ": " . sprintf("%.${digits}f", $stat) . $units;
        }

#       Existing stat link
        if ($link_id != 0) {
            $link_props{$link_id}{type}   = $stat_type;
            $link_props{$link_id}{digits} = $digits;
            $link_props{$link_id}{interp} = $interp;
            $link_props{$link_id}{tol}    = $tol;
            $props{$link_id}{text}        = $link_txt;
            $props{$link_id}{family}      = $font;
            $props{$link_id}{size}        = $size;
            $props{$link_id}{weight}      = $weight;
            $props{$link_id}{color}       = $color;

            $canv->itemconfigure($link_id,
                                  -text => $link_txt,
                                  -fill => &get_rgb_code($color),
                                  -font => [ -family     => $font,
                                             -size       => $size,
                                             -weight     => $weight,
                                             -slant      => $slant_type[$props{$link_id}{slant}],
                                             -underline  => $props{$link_id}{underline},
                                             -overstrike => 0,
                                           ]);

#       New stat link
        } else {
            $link_id = $canv->create_text($xo, $yo,
                                  -anchor => 'e', 
                                  -fill   => &get_rgb_code($color),
                                  -angle  => 0,
                                  -text   => $link_txt,
                                  -tags   => "keep" . " link_gr" . $id,
                                  -font   => [ -family     => $font,
                                               -size       => $size,
                                               -weight     => $weight,
                                               -slant      => $slant_type[$default_slant],
                                               -underline  => 0,
                                               -overstrike => 0,
                                             ]);
            $props{$link_id}{type}      = "text";
            $props{$link_id}{text}      = $link_txt;
            $props{$link_id}{x}         = $xo;
            $props{$link_id}{y}         = $yo;
            $props{$link_id}{anchor}    = 'e';
            $props{$link_id}{coordlist} = [$xo, $yo];
            $props{$link_id}{color}     = $color;
            $props{$link_id}{family}    = $font;
            $props{$link_id}{size}      = $size;
            $props{$link_id}{weight}    = $weight;
            $props{$link_id}{slant}     = $default_slant;
            $props{$link_id}{underline} = 0;
            $props{$link_id}{angle}     = 0;
            &find_rect_from_text_or_image($canv, $link_id);

            $link_props{$link_id}{id}     = $id;
            $link_props{$link_id}{gnum}   = $props{$id}{gnum};
            $link_props{$link_id}{form}   = "stat";
            $link_props{$link_id}{type}   = $stat_type;
            $link_props{$link_id}{tol}    = $tol;
            $link_props{$link_id}{interp} = $interp;
            $link_props{$link_id}{digits} = $digits;

            $canv->g_bind("<Motion>",   [ \&move_object, Tkx::Ev("%x","%y"), $canv, $link_id,
                                                         $xo, $yo, "", 0 ]);
            $canv->g_bind("<Button-1>", [ \&end_move_object, $canv, $link_id, "" ]);
            $canv->g_bind("<Button-3>", [ \&forget_link, $canv, $link_id ]);
        }
    }
}


sub update_stat_link {
    my ($canv, $link_id, $dt) = @_;
    my (
        $digits, $id, $interp, $link_txt, $seg, $stat, $tol, $txt, $type,
        $units,

        %elev_data, %parm_data, %ref_data, %stats,
       );

    $id     = $link_props{$link_id}{id};
    $type   = $link_props{$link_id}{type};
    $tol    = $link_props{$link_id}{tol};
    $interp = $link_props{$link_id}{interp};
    $digits = $link_props{$link_id}{digits};

    if ($props{$id}{parm} eq "Temperature") {
        $units = "\N{U+00B0}" . substr($props{$id}{parm_units},0,1);
    } else {
        $units = $props{$id}{parm_units};
        $units = " " . $units if ($units ne "");
    }
    if ($type eq "n") {
        $txt  = "N: ";
    } elsif ($type eq "me") {
        $txt  = "ME: ";
    } elsif ($type eq "mae") {
        $txt  = "MAE: ";
    } elsif ($type eq "rmse") {
        $txt  = "RMSE: ";
    }
    if ($props{$id}{ref_hide} || ! defined($props{$id}{ref_file})) {
        $link_txt = $txt . "na";
        if ($type ne "n") {
            if ($units =~ /^ /) {
                $link_txt .= $units;
            } else {
                $link_txt .= " " . $units;
            }
        }
        $canv->itemconfigure($link_id, -text => $link_txt);
        $props{$link_id}{text} = $link_txt;
        return;
    }

    $seg       = $props{$id}{seg};
    %elev_data = %{ $gr_props{$id}{elev_data} };
    %parm_data = %{ $gr_props{$id}{parm_data} };
    %ref_data  = %{ $gr_props{$id}{ref_data}  };

    %stats = &get_stats_single_profile($id, $dt, $seg, $tol, $interp,
                                       \%elev_data, \%parm_data, \%ref_data);
    undef %elev_data;
    undef %parm_data;
    undef %ref_data;

    $stat = $stats{$type};
    if ($stat eq "na" || $type eq "n") {
        $link_txt = $txt . $stat;
        if ($type ne "n") {
            if ($units =~ /^ /) {
                $link_txt .= $units;
            } else {
                $link_txt .= " " . $units;
            }
        }
    } else {
        if ($props{$id}{parm} eq "Temperature" && $props{$id}{parm_units} eq "Fahrenheit") {
            $stat *= 1.8;
        }
        $link_txt = $txt . sprintf("%.${digits}f", $stat) . $units;
    }
    $canv->itemconfigure($link_id, -text => $link_txt);
    $props{$link_id}{text} = $link_txt;
}


sub edit_matrix_fit_stats {
    my ($canv, $id, $X, $Y) = @_;
    my (
        $code, $color, $color_btn, $digits, $digits_sb, $edge, $edgec,
        $edgec_btn, $f, $fill, $fillc, $fillc_btn, $fg, $fmt, $font,
        $font_cb, $frame, $geom, $interp, $ph, $pos, $preview_canv,
        $preview_txt, $pw, $row, $size, $size_cb, $slant, $slant_cb,
        $slant_opt, $stat_box, $stat_frame, $stat_txt, $stats, $status,
        $type_mae, $type_me, $type_n, $type_rmse, $types, $units, $weight,
        $weight_cb,

        @coords,
       );

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($edit_matrix_stat_menu) && Tkx::winfo_exists($edit_matrix_stat_menu)) {
        if ($edit_matrix_stat_menu->g_wm_title() eq "Add or Edit Matrix Fit Statistics") {
            $edit_matrix_stat_menu->g_destroy();
            undef $edit_matrix_stat_menu;
        }
    }
    $edit_matrix_stat_menu = $main->new_toplevel();
    $edit_matrix_stat_menu->g_wm_transient($main);
    $edit_matrix_stat_menu->g_wm_title("Add or Edit Matrix Fit Statistics");
    $edit_matrix_stat_menu->configure(-cursor => $cursor_norm);
    $edit_matrix_stat_menu->g_wm_geometry($geom);

    &end_select($canv, $id, 1);

    if (defined($gr_props{$id}{ms_stats})) {
        $stats  = $gr_props{$id}{ms_stats};
        $types  = $gr_props{$id}{ms_types};
        $digits = $gr_props{$id}{ms_digits};
        $interp = $gr_props{$id}{ms_interp};
        $font   = $gr_props{$id}{ms_font};
        $size   = $gr_props{$id}{ms_size};
        $weight = $gr_props{$id}{ms_weight};
        $slant  = $gr_props{$id}{ms_slant};
        $color  = $gr_props{$id}{ms_color};
        $edge   = $gr_props{$id}{ms_edge};
        $edgec  = $gr_props{$id}{ms_edgec};
        $fill   = $gr_props{$id}{ms_fill};
        $fillc  = $gr_props{$id}{ms_fillc};
        $pos    = $gr_props{$id}{ms_pos};
    } else {
        $stats  = 1;
        $types  = "N ME MAE RMSE";
        $digits = 2;
        $interp = 1;
        $font   = $default_family;
        $size   = $default_size -2;
        $weight = $default_weight;
        $slant  = $default_slant;
        $color  = $default_color;
        $edge   = 0;
        $edgec  = "black";
        $fill   = 0;
        $fillc  = "white";
        $pos    = "Bottom Right";
    }
    $fmt       = "%.${digits}f";
    $types     = "MAE" if ($types eq "");
    $type_n    = ($types =~ /^N/)   ? 1 : 0;
    $type_me   = ($types =~ /ME/)   ? 1 : 0;
    $type_mae  = ($types =~ /MAE/)  ? 1 : 0;
    $type_rmse = ($types =~ /RMSE/) ? 1 : 0;
    $slant_opt = $slant_options[$slant];

    if ($props{$id}{parm} eq "Temperature") {
        $units = "\N{U+00B0}" . substr($props{$id}{parm_units},0,1);
    } else {
        $units = $props{$id}{parm_units};
        $units = " " . $units if ($units ne "");
    }
    $stat_txt = "";
    $stat_txt .= "N: 9" if ($type_n);
    if ($type_me) {
        $stat_txt .= "\n" if ($stat_txt ne "");
        $stat_txt .= "ME: " . sprintf($fmt, "0.1523") . $units;
    }
    if ($type_mae) {
        $stat_txt .= "\n" if ($stat_txt ne "");
        $stat_txt .= "MAE: " . sprintf($fmt, "0.6743") . $units;
    }
    if ($type_rmse) {
        $stat_txt .= "\n" if ($stat_txt ne "");
        $stat_txt .= "RMSE: " . sprintf($fmt, "1.1432") . $units;
    }
    $pw = 260;
    $ph = 110;

    $frame = $edit_matrix_stat_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    $frame->new_button(
            -text    => "OK",
            -command => sub { if ($types eq "") {
                                  return &pop_up_error($edit_matrix_stat_menu,
                                                       "No fit statistics specified. Please\n"
                                                     . "choose at least one goodness-of-fit\n"
                                                     . "statistic and try again.");
                              }
                              $gr_props{$id}{ms_stats}  = 1;
                              $gr_props{$id}{ms_types}  = $types;
                              $gr_props{$id}{ms_digits} = $digits;
                              $gr_props{$id}{ms_interp} = $interp;
                              $gr_props{$id}{ms_font}   = $font;
                              $gr_props{$id}{ms_size}   = $size;
                              $gr_props{$id}{ms_weight} = $weight;
                              $gr_props{$id}{ms_slant}  = $slant;
                              $gr_props{$id}{ms_color}  = $color;
                              $gr_props{$id}{ms_edge}   = $edge;
                              $gr_props{$id}{ms_edgec}  = $edgec;
                              $gr_props{$id}{ms_fill}   = $fill;
                              $gr_props{$id}{ms_fillc}  = $fillc;
                              $gr_props{$id}{ms_pos}    = $pos;

                              $edit_matrix_stat_menu->g_destroy();
                              undef $edit_matrix_stat_menu;

                              &set_matrix_stats($canv, $id);
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Apply",
            -command => sub { if ($types eq "") {
                                  return &pop_up_error($edit_matrix_stat_menu,
                                                       "No fit statistics specified. Please\n"
                                                     . "choose at least one goodness-of-fit\n"
                                                     . "statistic and try again.");
                              }
                              $gr_props{$id}{ms_stats}  = 1;
                              $gr_props{$id}{ms_types}  = $types;
                              $gr_props{$id}{ms_digits} = $digits;
                              $gr_props{$id}{ms_interp} = $interp;
                              $gr_props{$id}{ms_font}   = $font;
                              $gr_props{$id}{ms_size}   = $size;
                              $gr_props{$id}{ms_weight} = $weight;
                              $gr_props{$id}{ms_slant}  = $slant;
                              $gr_props{$id}{ms_color}  = $color;
                              $gr_props{$id}{ms_edge}   = $edge;
                              $gr_props{$id}{ms_edgec}  = $edgec;
                              $gr_props{$id}{ms_fill}   = $fill;
                              $gr_props{$id}{ms_fillc}  = $fillc;
                              $gr_props{$id}{ms_pos}    = $pos;

                              &set_matrix_stats($canv, $id);
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $edit_matrix_stat_menu->g_destroy();
                              undef $edit_matrix_stat_menu; },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

    $f = $edit_matrix_stat_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f->g_pack(-side => 'top');

    ($preview_canv = $f->new_canvas(
            -background  => &get_rgb_code($canvas_color),
            -width       => $pw,
            -height      => $ph,
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_grid(-row => 0, -column => 0, -sticky => 'wne');

    $preview_txt = $preview_canv->create_text($pw*0.6 +3, $ph*0.5 +3,
            -anchor  => 'center', 
            -text    => $stat_txt,
            -fill    => &get_rgb_code($color),
            -angle   => 0,
            -justify => 'right',
            -font    => [-family     => $font,
                         -size       => $size,
                         -weight     => $weight,
                         -slant      => $slant_type[$slant],
                         -underline  => 0,
                         -overstrike => 0,
                        ]);
    @coords = Tkx::SplitList($preview_canv->bbox($preview_txt));
    $coords[0] -= 5;
    $coords[1] -= 4;
    $coords[2] += 5;
    $coords[3] += 4;
    $stat_box = $preview_canv->create_rectangle(@coords,
                    -outline => "",
                    -width   => 0,
                    -fill    => "");
    if ($fill && $fillc ne "") {
        $preview_canv->itemconfigure($stat_box, -fill => &get_rgb_code($fillc));
    }
    if ($edge && $edgec ne "") {
        $preview_canv->itemconfigure($stat_box, -width => 1, -outline => &get_rgb_code($edgec));
    }
    $preview_canv->lower($stat_box, $preview_txt);

    if (! $fill && &get_rgb_code($color) eq &get_rgb_code($canvas_color)) {
        $code = &get_rgb_code(&get_bw_contrast(&get_rgb_code($color)));
        $preview_canv->configure(-background => $code);
    } elsif ($fill && &get_rgb_code($fillc) eq &get_rgb_code($canvas_color)) {
        $code = &get_rgb_code(&get_bw_contrast(&get_rgb_code($fillc)));
        $preview_canv->configure(-background => $code);
    }

    ($stat_frame = $f->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_grid(-row => 1, -column => 0, -sticky => 'wnes');

    $row = 0;
    $stat_frame->new_label(
            -text => "Stat Types: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $stat_frame->new_checkbutton(
            -variable => \$type_n,
            -text     => "N: Number of Points",
            -onvalue  => 1,
            -offvalue => 0,
            -font     => 'default',
            -command  => sub { $stat_txt  = $types = "";
                               $stat_txt .= "N: 9" if ($type_n);
                               $types    .= "N"    if ($type_n);
                               if ($type_me) {
                                   $stat_txt .= "\n" if ($stat_txt ne "");
                                   $stat_txt .= "ME: " . sprintf($fmt, "0.1523") . $units;
                                   $types    .= " " if ($types ne "");
                                   $types    .= "ME";
                               }
                               if ($type_mae) {
                                   $stat_txt .= "\n" if ($stat_txt ne "");
                                   $stat_txt .= "MAE: " . sprintf($fmt, "0.6743") . $units;
                                   $types    .= " " if ($types ne "");
                                   $types    .= "MAE";
                               }
                               if ($type_rmse) {
                                   $stat_txt .= "\n" if ($stat_txt ne "");
                                   $stat_txt .= "RMSE: " . sprintf($fmt, "1.1432") . $units;
                                   $types    .= " " if ($types ne "");
                                   $types    .= "RMSE";
                               }
                               $status = ($types eq "N" || $types eq "") ? 'disabled' : 'readonly';
                               $digits_sb->configure(-state => $status);
                               $preview_canv->itemconfigure($preview_txt, -text => $stat_txt);
                               @coords = Tkx::SplitList($preview_canv->bbox($preview_txt));
                               $coords[0] -= 5;
                               $coords[1] -= 4;
                               $coords[2] += 5;
                               $coords[3] += 4;
                               $preview_canv->coords($stat_box, @coords);
                             },
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $row++;
    $stat_frame->new_checkbutton(
            -variable => \$type_me,
            -text     => "ME: Mean Error",
            -onvalue  => 1,
            -offvalue => 0,
            -font     => 'default',
            -command  => sub { $stat_txt  = $types = "";
                               $stat_txt .= "N: 9" if ($type_n);
                               $types    .= "N"    if ($type_n);
                               if ($type_me) {
                                   $stat_txt .= "\n" if ($stat_txt ne "");
                                   $stat_txt .= "ME: " . sprintf($fmt, "0.1523") . $units;
                                   $types    .= " " if ($types ne "");
                                   $types    .= "ME";
                               }
                               if ($type_mae) {
                                   $stat_txt .= "\n" if ($stat_txt ne "");
                                   $stat_txt .= "MAE: " . sprintf($fmt, "0.6743") . $units;
                                   $types    .= " " if ($types ne "");
                                   $types    .= "MAE";
                               }
                               if ($type_rmse) {
                                   $stat_txt .= "\n" if ($stat_txt ne "");
                                   $stat_txt .= "RMSE: " . sprintf($fmt, "1.1432") . $units;
                                   $types    .= " " if ($types ne "");
                                   $types    .= "RMSE";
                               }
                               $status = ($types eq "N" || $types eq "") ? 'disabled' : 'readonly';
                               $digits_sb->configure(-state => $status);
                               $preview_canv->itemconfigure($preview_txt, -text => $stat_txt);
                               @coords = Tkx::SplitList($preview_canv->bbox($preview_txt));
                               $coords[0] -= 5;
                               $coords[1] -= 4;
                               $coords[2] += 5;
                               $coords[3] += 4;
                               $preview_canv->coords($stat_box, @coords);
                             },
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $row++;
    $stat_frame->new_checkbutton(
            -variable => \$type_mae,
            -text     => "MAE: Mean Absolute Error",
            -onvalue  => 1,
            -offvalue => 0,
            -font     => 'default',
            -command  => sub { $stat_txt  = $types = "";
                               $stat_txt .= "N: 9" if ($type_n);
                               $types    .= "N"    if ($type_n);
                               if ($type_me) {
                                   $stat_txt .= "\n" if ($stat_txt ne "");
                                   $stat_txt .= "ME: " . sprintf($fmt, "0.1523") . $units;
                                   $types    .= " " if ($types ne "");
                                   $types    .= "ME";
                               }
                               if ($type_mae) {
                                   $stat_txt .= "\n" if ($stat_txt ne "");
                                   $stat_txt .= "MAE: " . sprintf($fmt, "0.6743") . $units;
                                   $types    .= " " if ($types ne "");
                                   $types    .= "MAE";
                               }
                               if ($type_rmse) {
                                   $stat_txt .= "\n" if ($stat_txt ne "");
                                   $stat_txt .= "RMSE: " . sprintf($fmt, "1.1432") . $units;
                                   $types    .= " " if ($types ne "");
                                   $types    .= "RMSE";
                               }
                               $status = ($types eq "N" || $types eq "") ? 'disabled' : 'readonly';
                               $digits_sb->configure(-state => $status);
                               $preview_canv->itemconfigure($preview_txt, -text => $stat_txt);
                               @coords = Tkx::SplitList($preview_canv->bbox($preview_txt));
                               $coords[0] -= 5;
                               $coords[1] -= 4;
                               $coords[2] += 5;
                               $coords[3] += 4;
                               $preview_canv->coords($stat_box, @coords);
                             },
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $row++;
    $stat_frame->new_checkbutton(
            -variable => \$type_rmse,
            -text     => "RMSE: Root Mean Square Error",
            -onvalue  => 1,
            -offvalue => 0,
            -font     => 'default',
            -command  => sub { $stat_txt  = $types = "";
                               $stat_txt .= "N: 9" if ($type_n);
                               $types    .= "N"    if ($type_n);
                               if ($type_me) {
                                   $stat_txt .= "\n" if ($stat_txt ne "");
                                   $stat_txt .= "ME: " . sprintf($fmt, "0.1523") . $units;
                                   $types    .= " " if ($types ne "");
                                   $types    .= "ME";
                               }
                               if ($type_mae) {
                                   $stat_txt .= "\n" if ($stat_txt ne "");
                                   $stat_txt .= "MAE: " . sprintf($fmt, "0.6743") . $units;
                                   $types    .= " " if ($types ne "");
                                   $types    .= "MAE";
                               }
                               if ($type_rmse) {
                                   $stat_txt .= "\n" if ($stat_txt ne "");
                                   $stat_txt .= "RMSE: " . sprintf($fmt, "1.1432") . $units;
                                   $types    .= " " if ($types ne "");
                                   $types    .= "RMSE";
                               }
                               $status = ($types eq "N" || $types eq "") ? 'disabled' : 'readonly';
                               $digits_sb->configure(-state => $status);
                               $preview_canv->itemconfigure($preview_txt, -text => $stat_txt);
                               @coords = Tkx::SplitList($preview_canv->bbox($preview_txt));
                               $coords[0] -= 5;
                               $coords[1] -= 4;
                               $coords[2] += 5;
                               $coords[3] += 4;
                               $preview_canv->coords($stat_box, @coords);
                             },
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');

    $row++;
    $stat_frame->new_label(
            -text => "Decimal Digits: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($digits_sb = $stat_frame->new_spinbox(
            -textvariable => \$digits,
            -state        => 'readonly',
            -font         => 'default',
            -from         => 0,
            -to           => 5,
            -increment    => 1,
            -width        => 3,
            -command      => sub { $fmt = "%.${digits}f";
                                   $stat_txt  = "";
                                   $stat_txt .= "N: 9" if ($type_n);
                                   if ($type_me) {
                                       $stat_txt .= "\n" if ($stat_txt ne "");
                                       $stat_txt .= "ME: " . sprintf($fmt, "0.1523") . $units;
                                   }
                                   if ($type_mae) {
                                       $stat_txt .= "\n" if ($stat_txt ne "");
                                       $stat_txt .= "MAE: " . sprintf($fmt, "0.6743") . $units;
                                   }
                                   if ($type_rmse) {
                                       $stat_txt .= "\n" if ($stat_txt ne "");
                                       $stat_txt .= "RMSE: " . sprintf($fmt, "1.1432") . $units;
                                   }
                                   $preview_canv->itemconfigure($preview_txt, -text => $stat_txt);
                                   @coords = Tkx::SplitList($preview_canv->bbox($preview_txt));
                                   $coords[0] -= 5;
                                   $coords[1] -= 4;
                                   $coords[2] += 5;
                                   $coords[3] += 4;
                                   $preview_canv->coords($stat_box, @coords);
                                 },
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    $row++;
    $stat_frame->new_label(
            -text => "Font: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($font_cb = $stat_frame->new_ttk__combobox(
            -textvariable => \$font,
            -values       => [ sort @available_fonts ],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
    $font_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_canv->itemconfigure($preview_txt,
                          -font => [ -family     => $font,
                                     -size       => $size,
                                     -weight     => $weight,
                                     -slant      => $slant_type[$slant],
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                    @coords = Tkx::SplitList($preview_canv->bbox($preview_txt));
                    $coords[0] -= 5;
                    $coords[1] -= 4;
                    $coords[2] += 5;
                    $coords[3] += 4;
                    $preview_canv->coords($stat_box, @coords);
                  });
    $row++;
    $stat_frame->new_label(
            -text => "Text Size: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($size_cb = $stat_frame->new_ttk__combobox(
            -textvariable => \$size,
            -values       => [(5 .. 24)],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
    $size_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_canv->itemconfigure($preview_txt,
                          -font => [ -family     => $font,
                                     -size       => $size,
                                     -weight     => $weight,
                                     -slant      => $slant_type[$slant],
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                    @coords = Tkx::SplitList($preview_canv->bbox($preview_txt));
                    $coords[0] -= 5;
                    $coords[1] -= 4;
                    $coords[2] += 5;
                    $coords[3] += 4;
                    $preview_canv->coords($stat_box, @coords);
                  });
    $row++;
    $stat_frame->new_label(
            -text => "Text Weight: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($weight_cb = $stat_frame->new_ttk__combobox(
            -textvariable => \$weight,
            -values       => [("normal", "bold")],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
    $weight_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_canv->itemconfigure($preview_txt,
                          -font => [ -family     => $font,
                                     -size       => $size,
                                     -weight     => $weight,
                                     -slant      => $slant_type[$slant],
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                    @coords = Tkx::SplitList($preview_canv->bbox($preview_txt));
                    $coords[0] -= 5;
                    $coords[1] -= 4;
                    $coords[2] += 5;
                    $coords[3] += 4;
                    $preview_canv->coords($stat_box, @coords);
                  });
    $row++;
    $stat_frame->new_label(
            -text => "Text Slant: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($slant_cb = $stat_frame->new_ttk__combobox(
            -textvariable => \$slant_opt,
            -values       => [ @slant_options ],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
    $slant_cb->g_bind("<<ComboboxSelected>>",
              sub { my $s = &list_match($slant_opt, @slant_options);
                    return if ($s < 0);
                    $slant = $s;
                    $preview_canv->itemconfigure($preview_txt,
                          -font => [ -family     => $font,
                                     -size       => $size,
                                     -weight     => $weight,
                                     -slant      => $slant_type[$slant],
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                    @coords = Tkx::SplitList($preview_canv->bbox($preview_txt));
                    $coords[0] -= 5;
                    $coords[1] -= 4;
                    $coords[2] += 5;
                    $coords[3] += 4;
                    $preview_canv->coords($stat_box, @coords);
                  });
    $row++;
    $stat_frame->new_label(
            -text => "Text Color: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $code  = &get_rgb_code($color);
    $color = &get_rgb_name($code);
    $fg    = &get_rgb_code("black");
    if ($code =~ /^\#[0-9a-f]/i) {
        $fg = &get_rgb_code(&get_bw_contrast($code));
    }
    ($color_btn = $stat_frame->new_button(
            -textvariable => \$color,
            -background   => $code,
            -foreground   => $fg,
            -width        => -7,
            -command => sub {
                          my ($newc, $code, $fg);
                          $code = &get_rgb_code($color);
                          $newc = Tkx::tk___chooseColor(
                                     -initialcolor => $code,
                                     -parent       => $edit_matrix_stat_menu);
                          if ($newc) {
                            $code  = &get_rgb_code($newc);
                            $color = &get_rgb_name($code);
                            $fg    = &get_rgb_code("black");
                            if ($code =~ /^#?[0-9a-f]/i) {
                                $fg = &get_rgb_code(&get_bw_contrast($code));
                            }
                            $color_btn->configure(-foreground => $fg,
                                                  -background => $code);
                            $preview_canv->itemconfigure($preview_txt, -fill => $code);
                            if (! $fill && $code eq &get_rgb_code($canvas_color)) {
                                $code = &get_rgb_code(&get_bw_contrast(&get_rgb_code($color)));
                                $preview_canv->configure(-background => $code);
                            } elsif ($fill && &get_rgb_code($fillc) eq &get_rgb_code($canvas_color)) {
                                $code = &get_rgb_code(&get_bw_contrast(&get_rgb_code($fillc)));
                                $preview_canv->configure(-background => $code);
                            } else {
                                $preview_canv->configure(-background => &get_rgb_code($canvas_color));
                            }
                          }
                        }
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    $row++;
    $stat_frame->new_label(
            -text => "Box Outline: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $stat_frame->new_checkbutton(
            -onvalue  => 1,
            -offvalue => 0,
            -text     => "Show",
            -font     => 'default',
            -variable => \$edge,
            -command  => sub { if ($edge) {
                                   $edgec_btn->configure(-state => 'normal');
                                   $preview_canv->itemconfigure($stat_box, -width => 1,
                                                      -outline => &get_rgb_code($edgec));
                               } else {
                                   $edgec_btn->configure(-state => 'disabled');
                                   $preview_canv->itemconfigure($stat_box,
                                                      -width => 0, -outline => "");
                               }
                             },
            )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    $code  = &get_rgb_code($edgec);
    $edgec = &get_rgb_name($code);
    $fg    = &get_rgb_code("black");
    if ($code =~ /^\#[0-9a-f]/i) {
        $fg = &get_rgb_code(&get_bw_contrast($code));
    }
    ($edgec_btn = $stat_frame->new_button(
            -textvariable => \$edgec,
            -background   => $code,
            -foreground   => $fg,
            -width        => -7,
            -command => sub { my ($newc, $code, $fg);
                              $code = &get_rgb_code($edgec);
                              $newc = Tkx::tk___chooseColor(
                                         -initialcolor => $code,
                                         -parent       => $edit_matrix_stat_menu);
                              if ($newc) {
                                  $code  = &get_rgb_code($newc);
                                  $edgec = &get_rgb_name($code);
                                  $fg    = &get_rgb_code("black");
                                  if ($code =~ /^#?[0-9a-f]/i) {
                                      $fg = &get_rgb_code(&get_bw_contrast($code));
                                  }
                                  $edgec_btn->configure(-foreground => $fg,
                                                        -background => $code);
                                  $preview_canv->itemconfigure($stat_box, -outline => $code);
                              }
                            }
            ))->g_grid(-row => $row, -column => 2, -sticky => 'w', -padx => 2, -pady => 2);
    if (! $edge) {
        $edgec_btn->configure(-state => 'disabled');
    }

    $row++;
    $stat_frame->new_label(
            -text => "Box Fill: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $stat_frame->new_checkbutton(
            -onvalue  => 1,
            -offvalue => 0,
            -text     => "Show",
            -font     => 'default',
            -variable => \$fill,
            -command  => sub { $code = &get_rgb_code($fillc);
                               if ($fill) {
                                   $fillc_btn->configure(-state => 'normal');
                                   $preview_canv->itemconfigure($stat_box, -fill => $code);
                               } else {
                                   $fillc_btn->configure(-state => 'disabled');
                                   $preview_canv->itemconfigure($stat_box, -fill => "");
                               }
                               if (! $fill && &get_rgb_code($color) eq &get_rgb_code($canvas_color)) {
                                   $code = &get_rgb_code(&get_bw_contrast(&get_rgb_code($color)));
                                   $preview_canv->configure(-background => $code);
                               } elsif ($fill && $code eq &get_rgb_code($canvas_color)) {
                                   $code = &get_rgb_code(&get_bw_contrast($code));
                                   $preview_canv->configure(-background => $code);
                               } else {
                                   $preview_canv->configure(-background => &get_rgb_code($canvas_color));
                               }
                             },
            )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    $code  = &get_rgb_code($fillc);
    $fillc = &get_rgb_name($code);
    $fg    = &get_rgb_code("black");
    if ($code =~ /^\#[0-9a-f]/i) {
        $fg = &get_rgb_code(&get_bw_contrast($code));
    }
    ($fillc_btn = $stat_frame->new_button(
            -textvariable => \$fillc,
            -background   => $code,
            -foreground   => $fg,
            -width        => -7,
            -command => sub { my ($newc, $code, $fg);
                              $code = &get_rgb_code($fillc);
                              $newc = Tkx::tk___chooseColor(
                                         -initialcolor => $code,
                                         -parent       => $edit_matrix_stat_menu);
                              if ($newc) {
                                  $code  = &get_rgb_code($newc);
                                  $fillc = &get_rgb_name($code);
                                  $fg    = &get_rgb_code("black");
                                  if ($code =~ /^#?[0-9a-f]/i) {
                                      $fg = &get_rgb_code(&get_bw_contrast($code));
                                  }
                                  $fillc_btn->configure(-foreground => $fg,
                                                        -background => $code);
                                  $preview_canv->itemconfigure($stat_box, -fill => $code);
                                  if ($code eq &get_rgb_code($canvas_color)) {
                                      $code = &get_rgb_code(&get_bw_contrast($code));
                                      $preview_canv->configure(-background => $code);
                                  } else {
                                      $preview_canv->configure(-background => &get_rgb_code($canvas_color));
                                  }
                              }
                            }
            ))->g_grid(-row => $row, -column => 2, -sticky => 'w', -padx => 2, -pady => 2);
    if (! $fill) {
        $fillc_btn->configure(-state => 'disabled');
    }

    $row++;
    $stat_frame->new_label(
            -text => "Stats Position: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $stat_frame->new_ttk__combobox(
            -textvariable => \$pos,
            -values       => [ ("Top Left", "Top Center", "Top Right", "Middle Left", "Middle Right",
                                "Bottom Left", "Bottom Center", "Bottom Right") ],
            -state        => 'readonly',
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);

    $row++;
    $stat_frame->new_checkbutton(
            -onvalue  => 1,
            -offvalue => 0,
            -text     => "Interpolate model profile vertically",
            -font     => 'default',
            -variable => \$interp,
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

    $status = ($types eq "N" || $types eq "") ? 'disabled' : 'readonly';
    $digits_sb->configure(-state => $status);

    $stat_frame->g_grid_columnconfigure(2, -weight => 2);

    Tkx::wm_resizable($edit_matrix_stat_menu,0,0);
    &adjust_window_position($edit_matrix_stat_menu);
    $edit_matrix_stat_menu->g_focus;
}


sub set_matrix_stats {
    my ($canv, $id) = @_;
    my (
        $anc, $box_id, $color, $digits, $dt, $edge, $edgec, $fill, $fillc,
        $fmt, $font, $geom, $gs_pos, $interp, $nb, $nc, $ncols, $nr, $nrows,
        $pos, $refresh_menu, $seg, $size, $slant, $stat_id, $stat_txt,
        $sumb, $tol, $types, $units, $weight, $X, $x1, $x2, $xp, $xp1,
        $xp2, $Y, $y1, $y2, $yp, $yp1, $yp2,

        @blanks, @chosen_dates, @matrix_coords,

        %elev_data, %parm_data, %ref_data, %stat_anchor, %stats,
       );

    $canv->delete("graph" . $id . "_stats");
    return if (! $gr_props{$id}{ms_stats});

    $types     = $gr_props{$id}{ms_types};
    $digits    = $gr_props{$id}{ms_digits};
    $interp    = $gr_props{$id}{ms_interp};
    $font      = $gr_props{$id}{ms_font};
    $size      = $gr_props{$id}{ms_size};
    $weight    = $gr_props{$id}{ms_weight};
    $slant     = $gr_props{$id}{ms_slant};
    $color     = $gr_props{$id}{ms_color};
    $edge      = $gr_props{$id}{ms_edge};
    $edgec     = $gr_props{$id}{ms_edgec};
    $fill      = $gr_props{$id}{ms_fill};
    $fillc     = $gr_props{$id}{ms_fillc};
    $pos       = $gr_props{$id}{ms_pos};    # position for the stats
    $gs_pos    = $gr_props{$id}{gs_pos};    # position for the date
    $tol       = $props{$id}{ref_tol};
    $seg       = $props{$id}{seg};
    %elev_data = %{ $gr_props{$id}{elev_data} };
    %parm_data = %{ $gr_props{$id}{parm_data} };
    %ref_data  = %{ $gr_props{$id}{ref_data}  };

    $refresh_menu = 0;
    if (! $gr_props{$id}{add_cs} && $color eq "white" && ! $fill) {
        $color = $gr_props{$id}{ms_color} = "black";
        $refresh_menu = 1;
    }

    ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
    ($x1, $x2) = sort numerically ($x1, $x2);
    ($y1, $y2) = sort numerically ($y1, $y2);
    ($nrows, $ncols) = split(/x/, $gr_props{$id}{matrix});
    @chosen_dates    = @{ $gr_props{$id}{pdates} };
    @blanks          = @{ $gr_props{$id}{blanks} };
    @matrix_coords   = ();
    $sumb = 0;
    for ($nr=0; $nr<$nrows; $nr++) {
        for ($nc=0; $nc<$ncols; $nc++) {
            $nb = $nr *$ncols +$nc;
            if ($blanks[$nb]) {
                $sumb++;
            } elsif ($nb <= $#chosen_dates +$sumb) {
                $xp1 = $x1 + &round_to_int($nc    *($x2 -$x1)/$ncols);
                $xp2 = $x1 + &round_to_int(($nc+1)*($x2 -$x1)/$ncols);
                $yp1 = $y1 + &round_to_int($nr    *($y2 -$y1)/$nrows);
                $yp2 = $y1 + &round_to_int(($nr+1)*($y2 -$y1)/$nrows);
                $matrix_coords[$nb-$sumb] = [ ($xp1, $yp1, $xp2, $yp2) ];
            }
        }
    }

    %stat_anchor = ("Top Left",    'nw', "Top Center",    'n', "Top Right",    'ne',
                    "Middle Left", 'w',  "Middle Right",  'e',
                    "Bottom Left", 'sw', "Bottom Center", 's', "Bottom Right", 'se',
                   );

    if ($props{$id}{parm} eq "Temperature") {
        $units = "\N{U+00B0}" . substr($props{$id}{parm_units},0,1);
    } else {
        $units = $props{$id}{parm_units};
        $units = " " . $units if ($units ne "");
    }
    $fmt  = "%.${digits}f";
    $sumb = 0;
    for ($nr=0; $nr<$nrows; $nr++) {
        for ($nc=0; $nc<$ncols; $nc++) {
            $nb = $nr *$ncols +$nc;
            $sumb++ if ($blanks[$nb]);
            next if ($blanks[$nb] || $nb > $#chosen_dates +$sumb);

            $dt    = $chosen_dates[$nb-$sumb];
            %stats = &get_stats_single_profile($id, $dt, $seg, $tol, $interp,
                                               \%elev_data, \%parm_data, \%ref_data);
            $stat_txt = "";
            $stat_txt .= "N: " . $stats{"n"} if ($types =~ /^N/);
            if ($types =~ /ME/) {
                $stat_txt .= "\n" if ($stat_txt ne "");
                $stat_txt .= "ME: " . sprintf($fmt, $stats{"me"}) . $units;
            }
            if ($types =~ /MAE/) {
                $stat_txt .= "\n" if ($stat_txt ne "");
                $stat_txt .= "MAE: " . sprintf($fmt, $stats{"mae"}) . $units;
            }
            if ($types =~ /RMSE/) {
                $stat_txt .= "\n" if ($stat_txt ne "");
                $stat_txt .= "RMSE: " . sprintf($fmt, $stats{"rmse"}) . $units;
            }

            ($x1, $y1, $x2, $y2) = @{ $matrix_coords[$nb-$sumb] };
            if ($pos =~ /Left/) {
                $xp = ($gr_props{$id}{ypr_tics} =~ /inside|cross/) ? $x1+15 : $x1+8;
            } elsif ($pos =~ /Right/) {
                $xp = ($gr_props{$id}{ypr_tics} =~ /inside|cross/) ? $x2-15 : $x2-8;
            } else {
                $xp = ($x1+$x2)/2;
            }
            if ($pos =~ /Top/) {
                $yp = ($gr_props{$id}{xop_tics} =~ /inside|cross/) ? $y1+12 : $y1+8;
            } elsif ($pos =~ /Bottom/) {
                $yp = ($gr_props{$id}{xop_tics} =~ /inside|cross/) ? $y2-12 : $y2-8;
            } else {
                $yp = ($y1+$y2)/2;
            }
            $anc = $stat_anchor{$pos};
            if (($pos =~ /Top/    && $gs_pos =~ /Top/) ||
                ($pos =~ /Middle/ && $gs_pos =~ /Middle/) ||
                ($pos =~ /Bottom/ && $gs_pos =~ /Bottom/)) {
                ($x1, $y1, $x2, $y2) = Tkx::SplitList($canv->bbox("graph" . $id . "_date" . $nb));
                if ($pos =~ /Top/) {
                    $yp = $y2+5;
                } elsif ($pos =~ /Bottom/) {
                    $yp = $y1-5;
                } else {
                    $yp  = $y2+5;
                    $anc = 'ne';
                }
            }
            $stat_id = $canv->create_text($xp, $yp,
                               -anchor  => $anc,
                               -text    => $stat_txt,
                               -fill    => &get_rgb_code($color),
                               -angle   => 0,
                               -justify => 'right',
                               -tags    => "graph" . $id . " graph" . $id . "_stats",
                               -font    => [-family     => $font,
                                            -size       => $size,
                                            -weight     => $weight,
                                            -slant      => $slant_type[$slant],
                                            -underline  => 0,
                                            -overstrike => 0,
                                           ]);
            if (($edge && $edgec ne "") || ($fill && $fillc ne "")) {
                ($xp1, $yp1, $xp2, $yp2) = Tkx::SplitList($canv->bbox($stat_id));
                $box_id = $canv->create_rectangle($xp1-3, $yp1-3, $xp2+3, $yp2+3,
                                             -outline => "",
                                             -width   => 0,
                                             -fill    => &get_rgb_code("white"),
                                             -tags    => "graph" . $id . " graph" . $id . "_stats");
                $canv->lower($box_id, $stat_id);
                if ($edge && $edgec ne "") {
                    $canv->itemconfigure($box_id, -outline => &get_rgb_code($edgec), -width => 1);
                }
                if ($fill && $fillc ne "") {
                    $canv->itemconfigure($box_id, -fill => &get_rgb_code($fillc));
                } else {
                    $canv->itemconfigure($box_id, -fill => "");
                }
            }

        }
    }
    undef %elev_data;
    undef %parm_data;
    undef %ref_data;

    if ($refresh_menu) {
        if (defined($edit_matrix_stat_menu) && Tkx::winfo_exists($edit_matrix_stat_menu)) {
            if ($edit_matrix_stat_menu->g_wm_title() eq "Add or Edit Matrix Fit Statistics") {
                $geom  = $edit_matrix_stat_menu->g_wm_geometry();
                (undef, $X, $Y) = split(/\+/, $geom);
                &edit_matrix_fit_stats($canv, $id, $X, $Y);
            }
        }
    }
}


# Add or edit an independent linked text object tied to a file time series
sub edit_ind_link {
    my ($canv, $id, $X, $Y) = @_;
    my (
        $btn_txt, $byear, $byear_cb, $byear_frame, $byear_label, $code,
        $color, $color_btn, $conv_add, $conv_add_entry, $conv_mult,
        $conv_mult_entry, $conv_type, $conv_type_cb, $custom_frame,
        $data_type, $data_type_cb, $digits, $f, $fg, $file_fmt, $fmt,
        $font, $font_cb, $frame, $geom, $i, $id2, $link_txt, $no_anim,
        $offset_frame, $ok_btn, $old_conv_type, $old_parm, $parm, $parm_cb,
        $parm_chars, $parm_label, $ph, $preview_canv, $preview_txt, $pw,
        $row, $segnum, $segnum_cb, $segnum_label, $size, $size_cb, $slant,
        $slant_cb, $slant_opt, $src_file, $src_lines, $tol, $tzoff,
        $tzoff_label, $units, $units_cb, $units_entry, $v, $weight,
        $weight_cb, $yr_max, $yr_min,

        @parmlist, @segs, @type_opts, @unit_opts,
       );

    if ($X == 0) {
        (undef, $X, $Y) = split(/\+/, $main->g_wm_geometry());
        $X += 100;
        $Y += 100;
    }
    $geom = sprintf("+%d+%d", $X, $Y);

#   Remove an existing menu, if necessary
    if (defined($edit_ind_link_menu) && Tkx::winfo_exists($edit_ind_link_menu)) {
        if ($edit_ind_link_menu->g_wm_title() eq "Add or Edit Independent Link") {
            $edit_ind_link_menu->g_destroy();
            undef $edit_ind_link_menu;
        }
    }

#   Ensure that at least one animated graph exists. If not, return with error message.
    $no_anim = 1;
    if (@animate_ids && $#animate_ids >= 0) {
        for ($i=0; $i<=$#animate_ids; $i++) {
            $id2 = $animate_ids[$i];
            if ($props{$id2}{meta}
                           =~ /^(data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)$/) {
                $no_anim = 0;
                last;
            }
        }
    }
    if ($no_anim) {
        if ($id == 0) {
            return &pop_up_error($main,
                                 "No animated graphs exist on the canvas.\n"
                               . "An independent time-series text link\n"
                               . "cannot be created yet.");
        } else {
            return &pop_up_info($main,
                                 "No animated graphs exist on the canvas.\n"
                               . "An independent time-series text link\n"
                               . "cannot be edited at this time.",
                                 "No Animated Graphs Present");
        }
    }

#   Create a new menu window
    $edit_ind_link_menu = $main->new_toplevel();
    $edit_ind_link_menu->g_wm_transient($main);
    $edit_ind_link_menu->g_wm_title("Add or Edit Independent Link");
    $edit_ind_link_menu->configure(-cursor => $cursor_norm);
    $edit_ind_link_menu->g_wm_geometry($geom);

#   Defaults and properties
    $yr_max = (localtime(time))[5] +1900;
    $yr_min = $yr_max -25;
    $byear  = $yr_max;
    $tzoff  = "+00:00";
    $segnum = "";

    if ($id != 0) {
        $src_file  = $props{$id}{src_file};
        $src_lines = $props{$id}{src_lines};
        $file_fmt  = $props{$id}{src_type};
        $conv_type = $props{$id}{ctype};
        $parm      = $props{$id}{parm};
        if ($file_fmt =~ /^W2 /) {
            $byear  = $props{$id}{byear};
            $tzoff  = $props{$id}{tz_offset};
            $segnum = ($file_fmt =~ /^W2 [HDSW]/) ? $props{$id}{seg} : "";
        }
        $data_type = $props{$id}{data_type};
        $units     = $props{$id}{units};
        $digits    = $props{$id}{digits};
        $font      = $props{$id}{family};
        $weight    = $props{$id}{weight};
        $size      = $props{$id}{size};
        $slant     = $props{$id}{slant};
        $color     = $props{$id}{color};
        $tol       = $props{$id}{link_tol};
    } else {
        $src_file  = "";
        $src_lines = 0;
        $file_fmt  = "Undetermined";
        $conv_type = $conv_types[0];
        $parm      = "Unknown";
        $data_type = "Other";
        $units     = "";
        $digits    = 0;
        $font      = $default_family;
        $weight    = $default_weight;
        $size      = $default_size;
        $slant     = $default_slant;
        $color     = $default_color;
        $tol       = 10;
    }
    if ($conv_type =~ /Custom/) {
        ($conv_type, $conv_mult, $conv_add) = split(/,/, $conv_type);
    } else {
        $conv_mult = 1.0;
        $conv_add  = 0.0;
    }
    $old_conv_type = $conv_type;
    $slant_opt     = $slant_options[$slant];

    @type_opts = ("Elevation", "Flow", "Temperature", "Concentration", "Other");
    $btn_txt   = ($id == 0)    ? "Create" : "Modify";
    $fmt       = "%.${digits}f";
    if ($data_type eq "Elevation") {
        @unit_opts = ("m", "ft");
        $v         = ($units eq "ft") ? 1500 : 450;
        $link_txt  = sprintf($fmt, $v) . " " . $units;
    } elsif ($data_type eq "Flow") {
        @unit_opts = ("cms", "cfs", "kcfs");
        $v         = ($units eq "cms") ? 50 : ($units eq "cfs") ? 1500 : 1.5;
        $link_txt  = sprintf($fmt, $v) . " " . $units;
    } elsif ($data_type eq "Temperature") {
        @unit_opts = ("Celsius", "Fahrenheit");
        $v         = ($units eq "Celsius") ? 13 : 55;
        $link_txt  = sprintf($fmt, $v) . " " . "\N{U+00B0}" . substr($units,0,1);
    } elsif ($data_type eq "Concentration") {
        @unit_opts = ("mg/L", "ug/L", "g/m3", "ppt");
        $v         = 68.92;
        $link_txt  = sprintf($fmt, $v) . " " . $units;
    } else {
        @unit_opts = ();
        $v         = 68.92;
        $link_txt  = sprintf($fmt, $v) . " " . $units;
    }

    @parmlist    = ();
    $parmlist[0] = $parm;
    $parm_chars  = length($parm) +2;
    $old_parm    = $parm;
    @segs        = ();

    $frame = $edit_ind_link_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => $btn_txt,
            -state   => ($id != 0) ? 'normal' : 'disabled',
            -command => sub { my (%parms);
                              %parms = ();
                              $parms{src_file}  = $src_file;
                              $parms{src_type}  = $file_fmt;
                              $parms{src_lines} = $src_lines;
                              $parms{ctype}     = $conv_type;
                              $parms{parm}      = $parm;
                              $parms{byear}     = $byear;
                              $parms{tz_offset} = $tzoff;
                              $parms{seg}       = $segnum;
                              $parms{data_type} = $data_type;
                              $parms{units}     = $units;
                              $parms{digits}    = $digits;
                              $parms{family}    = $font;
                              $parms{weight}    = $weight;
                              $parms{size}      = $size;
                              $parms{slant}     = $slant;
                              $parms{color}     = $color;
                              $parms{link_tol}  = $tol;

                              $edit_ind_link_menu->g_destroy();
                              undef $edit_ind_link_menu;

                              &set_ind_link($canv, $id, %parms);
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $edit_ind_link_menu->g_destroy();
                              undef $edit_ind_link_menu; },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

    ($f = $edit_ind_link_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "Time-Series File: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $f->new_label(
            -textvariable => \$src_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew');
    $f->new_button(
            -text    => "Browse",
            -command => sub { my ($file, $i, $old_data_type, $segwidth, $segmax);
                              $old_data_type = $data_type;
                              $file = Tkx::tk___getOpenFile(
                                      -parent     => $edit_ind_link_menu,
                                      -title      => "Select File",
                                    # -initialdir => abs_path(),
                                      -filetypes  => [ ['All Files',  '*'],
                                                       ['CSV (comma delimited)', '.csv'],
                                                     ],
                                      );
                              if ( $^O =~ /MSWin32/i ) {
                                  if (defined($file) && $file ne "") {
                                      $file =~ s/\//\\/g;
                                  }
                              }
                              if (defined($file) && $file ne "") {
                                  $src_file = $file;
                                  ($file_fmt, $src_lines, @parmlist)
                                      = &determine_ts_type($edit_ind_link_menu, $file);
                                  if ($file_fmt eq "") {
                                      $file_fmt    = "Undetermined";
                                      $parm        = "Unknown";
                                      @parmlist    = ();
                                      $parmlist[0] = $parm;
                                      $src_lines   = 0;
                                      $src_file    = "";
                                  } else {
                                      $parm = $parmlist[0];
                                      $ok_btn->configure(-state => 'normal');
                                  }
                                  $old_parm   = $parm;
                                  $parm_chars = length($parmlist[0]);
                                  for ($i=1; $i<=$#parmlist; $i++) {
                                      if (length($parmlist[$i]) > $parm_chars) {
                                          $parm_chars = length($parmlist[$i]);
                                      }
                                  }
                                  $parm_chars += 2;
                                  $parm_cb->configure(-values => [ @parmlist ],
                                                      -width  => $parm_chars);
                                  if ($file_fmt !~ /^W2 /) {
                                      $byear_label->g_grid_remove();
                                      $byear_frame->g_grid_remove();
                                      $tzoff_label->g_grid_remove();
                                      $offset_frame->g_grid_remove();
                                      $segnum_label->g_grid_remove();
                                      $segnum_cb->g_grid_remove();
                                      $parm_label->g_grid_remove();
                                      $parm_cb->g_grid();
                                  } else {
                                      $byear_label->g_grid();
                                      $byear_frame->g_grid();
                                      $tzoff_label->g_grid();
                                      $offset_frame->g_grid();
                                      if ($file_fmt eq "W2 Heat Fluxes format"
                                            || $file_fmt eq "W2 Water Level (wl) format"
                                            || $file_fmt =~ /^W2 .*daily .*Temp2?\.dat format$/i) {
                                          $segnum_label->g_grid();
                                          $segnum_cb->g_grid();
                                      } else {
                                          $segnum_label->g_grid_remove();
                                          $segnum_cb->g_grid_remove();
                                      }
                                      if ($file_fmt eq "W2 Heat Fluxes format"
                                            || $file_fmt =~ /^W2 .*daily .*Temp2?\.dat format$/i) {
                                          ($segmax, @segs) = &scan_w2_file4segs($edit_ind_link_menu,
                                                                                $src_file, $file_fmt);
                                          $segwidth = 5;
                                          if ($#segs >= 0 && $segmax > 0) {
                                              $segwidth = &max(5, length($segmax));
                                          }
                                          $segnum_cb->configure(-values => [ @segs ],
                                                                -width  => $segwidth);
                                          if (&list_match($segnum, @segs) == -1) {
                                              $segnum = $segs[0];
                                          }
                                      }
                                      if ($file_fmt eq "W2 Water Level (wl) format") {
                                          @segs = @parmlist;
                                          $segnum_cb->configure(-values => [ @segs ],
                                                                -width  => $parm_chars);
                                          if (&list_match($segnum, @segs) == -1) {
                                              $segnum = $segs[0];
                                          }
                                          $parm_cb->g_grid_remove();
                                          $parm_label->g_grid();
                                          $parm = "Water Level";
                                      } else {
                                          $parm_label->g_grid_remove();
                                          $parm_cb->g_grid();
                                      }
                                  }
                                  if ($parm =~ /temperature/i || $parm eq "T2(C)" || $parm eq "Tvolavg(C)"
                                                              || $parm =~ /Temp-Water/) {
                                      $data_type = "Temperature";
                                      $units = "Fahrenheit" if ($parm =~ /(degF|Fahren)/);
                                  } elsif ($parm =~ /(flow|discharge)/i || $parm eq "Q(m3s-1)"
                                                                        || $parm eq "QWD(m3s-1)") {
                                      $data_type = "Flow";
                                  } elsif ($parm =~ /elevation/i || $parm eq "ELWS(m)"
                                                                 || $parm eq "Water Level") {
                                      $data_type = "Elevation";
                                  } elsif ($parm =~ /(tracer|oxygen|tds|phos|nitrate|ammonia|no3|nh4|nh3)/i) {
                                      $data_type = "Concentration";
                                  } else {
                                      $data_type = "Other";
                                  }
                                  if ($data_type ne $old_data_type) {
                                      Tkx::event_generate($data_type_cb, "<<ComboboxSelected>>");
                                  }
                              } else {
                                  $ok_btn->configure(-state => 'disabled');
                              }
                            },
            )->g_grid(-row => $row, -column => 4, -sticky => 'ew', -padx => 2);

    $row++;
    $f->new_label(
            -text => "File Format: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$file_fmt,
            -anchor       => 'w',
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    ($segnum_label = $f->new_label(
            -text => "Segment: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($segnum_cb = $f->new_ttk__combobox(
            -textvariable => \$segnum,
            -values       => [ @segs ],
            -state        => 'readonly',
            -width        => 5,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Parameter: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($parm_label = $f->new_label(
            -text => "Water Level",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $parm_label->g_grid_remove();
    ($parm_cb = $f->new_ttk__combobox(
            -textvariable => \$parm,
            -values       => [ @parmlist ],
            -state        => 'readonly',
            -width        => $parm_chars,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $parm_cb->g_bind("<<ComboboxSelected>>",
                      sub { return if ($parm eq $old_parm);
                            my $old_data_type = $data_type;
                            if ($parm =~ /temperature/i || $parm eq "T2(C)" || $parm eq "Tvolavg(C)"
                                                        || $parm =~ /Temp-Water/) {
                                $data_type = "Temperature";
                                $units = "Fahrenheit" if ($parm =~ /(degF|Fahren)/);
                            } elsif ($parm =~ /(flow|discharge)/i || $parm eq "Q(m3s-1)") {
                                $data_type = "Flow";
                            } elsif ($parm =~ /elevation/i || $parm eq "ELWS(m)"
                                                           || $parm eq "Water Level") {
                                $data_type = "Elevation";
                            } elsif ($parm =~ /(tracer|oxygen|tds|phos|nitrate|ammonia|no3|nh4|nh3)/i) {
                                $data_type = "Concentration";
                            } else {
                                $data_type = "Other";
                            }
                            if ($data_type ne $old_data_type) {
                                Tkx::event_generate($data_type_cb, "<<ComboboxSelected>>");
                            }
                            $old_parm = $parm;
                          });

    $row++;
    $f->new_label(
            -text => "Conversion: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($conv_type_cb = $f->new_ttk__combobox(
            -textvariable => \$conv_type,
            -values       => [ @conv_types ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $conv_type_cb->g_bind("<<ComboboxSelected>>",
                      sub { return if ($conv_type eq $old_conv_type);
                            my $old_units = $units;
                            if ($conv_type eq "Custom") {
                                $custom_frame->g_grid();
                            } else {
                                $custom_frame->g_grid_remove();
                            }
                            if ($data_type eq "Flow") {
                                if ($conv_type eq "cms to cfs") {
                                    $units = "cfs";
                                } elsif ($conv_type eq "cfs to cms" || $conv_type eq "None") {
                                    $units = "cms";
                                } elsif ($conv_type eq "cfs to kcfs") {
                                    $units = "kcfs";
                                }
                            } elsif ($data_type eq "Temperature") {
                                if ($conv_type eq "degC to degF") {
                                    $units = "Fahrenheit";
                                } elsif ($conv_type eq "degF to degC" || $conv_type eq "None") {
                                    $units = "Celsius";
                                }
                            } elsif ($data_type eq "Elevation") {
                                if ($conv_type eq "ft to m" || $conv_type eq "None") {
                                    $units = "m";
                                } elsif ($conv_type eq "m to ft") {
                                    $units = "ft";
                                }
                            } elsif ($data_type eq "Concentration") {
                                if ($conv_type eq "mg/L to ug/L") {
                                    $units = "ug/L";
                                } elsif ($conv_type eq "ug/L to mg/L" || $conv_type eq "None") {
                                    $units = "mg/L";
                                }
                            }
                            if ($units ne $old_units) {
                                Tkx::event_generate($units_cb, "<<ComboboxSelected>>");
                            }
                            $old_conv_type = $conv_type;
                          });
    $row++;
    ($custom_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    $custom_frame->new_label(
            -text => "Multiply by: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_mult_entry = $custom_frame->new_entry(
            -textvariable => \$conv_mult,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_mult_entry->g_bind("<KeyRelease>",
                              sub { &numeric_entry_only($conv_mult_entry);
                                    my $chars = &max(7, length($conv_mult));
                                    $conv_mult_entry->configure(-width => $chars);
                                  });
    $custom_frame->new_label(
            -text => "  Then add: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_add_entry = $custom_frame->new_entry(
            -textvariable => \$conv_add,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_add_entry->g_bind("<KeyRelease>",
                             sub { &numeric_entry_only($conv_add_entry);
                                   my $chars = &max(7, length($conv_add));
                                   $conv_add_entry->configure(-width => $chars);
                                 });

    $row++;
    ($byear_label = $f->new_label(
            -text => "Base Year: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($byear_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    ($byear_cb = $byear_frame->new_ttk__combobox(
            -textvariable => \$byear,
            -values       => [ reverse($yr_min .. $yr_max) ],
            -state        => 'readonly',
            -width        => 5,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $byear_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($byear == $yr_min) {
                                $yr_min -= 10;
                                $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                            }
                          }
                     );
    $byear_frame->new_label(
            -text   => " for JDAY = 1.0",
            -anchor => 'w',
            -font   => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');

    $row++;
    ($tzoff_label = $f->new_label(
            -text => "Time Offset: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($offset_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    $offset_frame->new_ttk__combobox(
            -textvariable => \$tzoff,
            -values       => [ @tz_offsets ],
            -justify      => 'right',
            -state        => 'readonly',
            -width        => 6,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $offset_frame->new_label(
            -text   => " time zone adjustment ",
            -anchor => 'w',
            -font   => 'default',
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $offset_frame->new_button(
            -text    => "Help",
            -command => sub { &pop_up_info($edit_ind_link_menu,
                                    "The time offset allows the user to add or subtract a time\n"
                                  . "offset if the W2 model was run with a non-local time zone.\n\n"
                                  . "For example, if W2 was run in UTC but the local time zone\n"
                                  . "is PST, an offset of -08:00 would convert the model date/time\n"
                                  . "to a local standard time of PST. This offset does not make\n"
                                  . "any adjustments related to daylight saving time. In general,\n"
                                  . "W2 is best run in the local standard time.\n\n"
                                  . "Leave the time offset at +00:00 for no adjustment.",
                                    "Time Offset Notice");
                            },
            )->g_pack(-side => 'left', -anchor => 'w', -padx => 2);

    $row++;
    $f->new_label(
            -text => "Data Category: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($data_type_cb = $f->new_ttk__combobox(
            -textvariable => \$data_type,
            -values       => [ @type_opts ],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $data_type_cb->g_bind("<<ComboboxSelected>>",
              sub { my ($add, $v);
                    if ($data_type eq "Elevation") {
                        @unit_opts = ("m", "ft");
                        $units = "m" if ($units !~ /^(ft|m)$/);
                        $v     = ($units eq "ft") ? 1500 : 450;
                        $add   = " " . $units;
                    } elsif ($data_type eq "Flow") {
                        @unit_opts = ("cms", "cfs", "kcfs");
                        $units = "cms" if ($units !~ /^(cfs|cms|kcfs)$/);
                        $v     = ($units eq "cms") ? 50 : ($units eq "cfs") ? 1500 : 1.5;
                        $add   = " " . $units;
                    } elsif ($data_type eq "Temperature") {
                        @unit_opts = ("Celsius", "Fahrenheit");
                        $units = "Celsius" if ($units !~ /^(Celsius|Fahrenheit)$/);
                        $v     = ($units eq "Celsius") ? 13 : 55;
                        $add   = "\N{U+00B0}" . substr($units,0,1);
                    } elsif ($data_type eq "Concentration") {
                        @unit_opts = ("mg/L", "ug/L", "g/m3", "ppt");
                        $units = "mg/L" if ($units !~ /^(mg\/L|ug\/L|g\/m3|ppt)$/);
                        $v     = 68.92;
                        $add   = " " . $units;
                    } else {
                        @unit_opts = ();
                        $units = "";
                        $v     = 68.92;
                        $add   = " " . $units;
                    }
                    if ($data_type eq "Other") {
                        $units_entry->g_grid();
                        $units_cb->g_grid_remove();
                    } else {
                        $units_entry->g_grid_remove();
                        $units_cb->g_grid();
                        $units_cb->configure(-values => [ @unit_opts ]);
                    }
                    $preview_canv->itemconfigure($preview_txt,
                                                 -text => sprintf("%.${digits}f", $v) . $add);
                  });

    $row++;
    $f->new_label(
            -text => "Units: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($units_entry = $f->new_entry(
            -textvariable => \$units,
            -font         => 'default',
            -width        => 8,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $units_entry->g_bind("<KeyRelease>",
                         sub { my ($add, $chars, $v);
                               $chars = &max(8, length($units));
                               $units_entry->configure(-width => $chars);
                               $v   = 68.92;
                               $add = " " . $units;
                               $preview_canv->itemconfigure($preview_txt,
                                                            -text => sprintf("%.${digits}f", $v) . $add);
                             });
    $units_entry->g_grid_remove();
    ($units_cb = $f->new_ttk__combobox(
            -textvariable => \$units,
            -values       => [ @unit_opts ],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $units_cb->g_bind("<<ComboboxSelected>>",
              sub { my ($add, $v);
                    if ($data_type eq "Elevation") {
                        $v   = ($units eq "ft") ? 1500 : 450;
                        $add = " " . $units;
                    } elsif ($data_type eq "Flow") {
                        $v   = ($units eq "cms") ? 50 : ($units eq "cfs") ? 1500 : 1.5;
                        $add = " " . $units;
                    } elsif ($data_type eq "Temperature") {
                        $v   = ($units eq "Celsius") ? 13 : 55;
                        $add = "\N{U+00B0}" . substr($units,0,1);
                    } else {
                        $v   = 68.92;
                        $add = " " . $units;
                    }
                    $preview_canv->itemconfigure($preview_txt,
                                                 -text => sprintf("%.${digits}f", $v) . $add);
                  });

    $row++;
    $f->new_label(
            -text => "Decimal Digits: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_spinbox(
            -textvariable => \$digits,
            -state        => 'readonly',
            -font         => 'default',
            -from         => 0,
            -to           => 4,
            -increment    => 1,
            -width        => 3,
            -command      => sub { my ($add, $v);
                                   if ($data_type eq "Elevation") {
                                       $v   = ($units eq "ft") ? 1500 : 450;
                                       $add = " " . $units;
                                   } elsif ($data_type eq "Flow") {
                                       $v   = ($units eq "cms") ? 50 : ($units eq "cfs") ? 1500 : 1.5;
                                       $add = " " . $units;
                                   } elsif ($data_type eq "Temperature") {
                                       $v   = ($units eq "Celsius") ? 13 : 55;
                                       $add = "\N{U+00B0}" . substr($units,0,1);
                                   } else {
                                       $v   = 68.92;
                                       $add = " " . $units;
                                   }
                                   $preview_canv->itemconfigure($preview_txt,
                                                                -text => sprintf("%.${digits}f", $v) . $add);
                                 },
            )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Text Font: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($font_cb = $f->new_ttk__combobox(
            -textvariable => \$font,
            -values       => [ sort @available_fonts ],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $font_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_canv->itemconfigure($preview_txt,
                          -font => [ -family     => $font,
                                     -size       => $size,
                                     -weight     => $weight,
                                     -slant      => $slant_type[$slant],
                                     -underline  => ($id != 0) ? $props{$id}{underline} : 0,
                                     -overstrike => 0,
                                   ]);
                  });
    $pw = 125;
    $ph =  47;
    ($preview_canv = $f->new_canvas(
            -background  => &get_rgb_code($canvas_color),
            -width       => $pw,
            -height      => $ph,
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_grid(-row => $row, -rowspan => 3, -column => 2, -sticky => 'wne');

    $preview_txt = $preview_canv->create_text($pw*0.5 +3, $ph*0.5 +3,
            -anchor => 'center',
            -text   => $link_txt,
            -fill   => &get_rgb_code($color),
            -angle  => 0,
            -font   => [-family     => $font,
                        -size       => $size,
                        -weight     => $weight,
                        -slant      => $slant_type[$slant],
                        -underline  => ($id != 0) ? $props{$id}{underline} : 0,
                        -overstrike => 0,
                       ]);

    $row++;
    $f->new_label(
            -text => "Text Size: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($size_cb = $f->new_ttk__combobox(
            -textvariable => \$size,
            -values       => [(5 .. 24)],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $size_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_canv->itemconfigure($preview_txt,
                          -font => [ -family     => $font,
                                     -size       => $size,
                                     -weight     => $weight,
                                     -slant      => $slant_type[$slant],
                                     -underline  => ($id != 0) ? $props{$id}{underline} : 0,
                                     -overstrike => 0,
                                   ]);
                  });
    $row++;
    $f->new_label(
            -text => "Text Weight: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($weight_cb = $f->new_ttk__combobox(
            -textvariable => \$weight,
            -values       => [("normal", "bold")],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $weight_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_canv->itemconfigure($preview_txt,
                          -font => [ -family     => $font,
                                     -size       => $size,
                                     -weight     => $weight,
                                     -slant      => $slant_type[$slant],
                                     -underline  => ($id != 0) ? $props{$id}{underline} : 0,
                                     -overstrike => 0,
                                   ]);
                  });
    $row++;
    $f->new_label(
            -text => "Text Slant: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($slant_cb = $f->new_ttk__combobox(
            -textvariable => \$slant_opt,
            -values       => [ @slant_options ],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $slant_cb->g_bind("<<ComboboxSelected>>",
              sub { my $s = &list_match($slant_opt, @slant_options);
                    return if ($s < 0);
                    $slant = $s;
                    $preview_canv->itemconfigure($preview_txt,
                          -font => [ -family     => $font,
                                     -size       => $size,
                                     -weight     => $weight,
                                     -slant      => $slant_type[$slant],
                                     -underline  => ($id != 0) ? $props{$id}{underline} : 0,
                                     -overstrike => 0,
                                   ]);
                  });

    $row++;
    $f->new_label(
            -text => "Text Color: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);

    $code  = &get_rgb_code($color);
    $color = &get_rgb_name($code);
    $fg    = &get_rgb_code("black");
    if ($code =~ /^\#[0-9a-f]/i) {
        $fg = &get_rgb_code(&get_bw_contrast($code));
    }
    ($color_btn = $f->new_button(
            -textvariable => \$color,
            -background   => $code,
            -foreground   => $fg,
            -width        => -7,
            -command => sub {
                          my ($newc, $code, $fg);
                          $code = &get_rgb_code($color);
                          $newc = Tkx::tk___chooseColor(
                                     -initialcolor => $code,
                                     -parent       => $edit_ind_link_menu);
                          if ($newc) {
                            $code  = &get_rgb_code($newc);
                            $color = &get_rgb_name($code);
                            $fg    = &get_rgb_code("black");
                            if ($code =~ /^#?[0-9a-f]/i) {
                                $fg = &get_rgb_code(&get_bw_contrast($code));
                            }
                            $color_btn->configure(-foreground => $fg,
                                                  -background => $code);
                            $preview_canv->itemconfigure($preview_txt, -fill => $code);
                          }
                        }
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Match Tolerance: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_spinbox(
            -textvariable => \$tol,
            -state        => 'readonly',
            -font         => 'default',
            -from         => 0,
            -to           => 180,
            -increment    => 1,
            -width        => 4,
            )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    if ($file_fmt !~ /^W2 /) {
        $byear_label->g_grid_remove();
        $byear_frame->g_grid_remove();
        $tzoff_label->g_grid_remove();
        $offset_frame->g_grid_remove();
    }
    if ($file_fmt ne "W2 Heat Fluxes format" && $file_fmt ne "W2 Water Level (wl) format"
                                             && $file_fmt !~ /^W2 .*daily .*Temp2?\.dat format$/i) {
        $segnum_label->g_grid_remove();
        $segnum_cb->g_grid_remove();
    }
    if ($file_fmt eq "W2 Water Level (wl) format") {
        $parm_cb->g_grid_remove();
        $parm_label->g_grid();
    }
    if ($conv_type ne "Custom") {
        $custom_frame->g_grid_remove();
    }
    if ($data_type eq "Other") {
        $units_cb->g_grid_remove();
        $units_entry->g_grid();
    }
    $f->g_grid_columnconfigure(3, -weight => 2);

    Tkx::wm_resizable($edit_ind_link_menu,0,0);
    &adjust_window_position($edit_ind_link_menu);
    $edit_ind_link_menu->g_focus;
}


sub set_ind_link {
    my ($canv, $id, %parms) = @_;
    my (
        $byear, $color, $conv_type, $data_type, $digits, $dt, $dt2,
        $dt_daily, $fmt, $font, $from_menu, $link_txt, $mi, $parm, $pbar,
        $pbar_win, $read_file, $segnum, $size, $slant, $src_file, $src_type,
        $src_lines, $tol, $ts_daily, $ts_dt, $tzoff, $units, $weight,
        $xo, $yo,

        @fmt_group1, @fmt_group2, @ts_keys,

        %ts_data,
       );

    $dt   = $dates[$dti-1];
    $pbar = "";
    %ts_data   = ();
    $from_menu = (defined($parms{src_file})) ? 1 : 0;

#   Read the parms hash.  This is populated only when coming from the create/edit menu.
    if ($from_menu) {
        $src_file  = $parms{src_file};
        $src_type  = $parms{src_type};
        $src_lines = $parms{src_lines};
        $conv_type = $parms{ctype};
        $parm      = $parms{parm};
        if ($src_type =~ /^W2 /) {
            $byear  = $parms{byear};
            $tzoff  = $parms{tz_offset};
            $segnum = ($src_type =~ /^W2 [HDSW]/) ? $parms{seg} : "n/a";
        }
        $data_type = $parms{data_type};
        $units     = $parms{units};
        $digits    = $parms{digits};
        $font      = $parms{family};
        $weight    = $parms{weight};
        $size      = $parms{size};
        $slant     = $parms{slant};
        $color     = $parms{color};
        $tol       = $parms{link_tol};

        if ($id == 0) {
            $read_file = 1;
        } else {
            $read_file = 0;
            if (! defined($props{$id}{ts_data})) {
                $read_file = 1;
            } else {
                if ($src_file  ne $props{$id}{src_file}  || $src_type  ne $props{$id}{src_type} ||
                    $src_lines != $props{$id}{src_lines} || $conv_type ne $props{$id}{ctype}    ||
                    $parm      ne $props{$id}{parm}) {
                    $read_file = 1; 
                } elsif ($src_type =~ /^W2 /) {
                    if ($byear != $props{$id}{byear} || $tzoff ne $props{$id}{tz_offset} ||
                        ($src_type =~ /^W2 [HDSW]/ && $segnum ne $props{$id}{seg})) {
                        $read_file = 1; 
                    }
                }
            }
            if (! $read_file) {
                %ts_data = %{ $props{$id}{ts_data} };
            }
        }
        undef %parms;

#   Or, the value of the text link is simply being updated.
    } else {
        $units     = $props{$id}{units};
        $digits    = $props{$id}{digits};
        $tol       = $props{$id}{link_tol};
        if (! defined($props{$id}{ts_data})) {
            $read_file = 1;
            $src_file  = $props{$id}{src_file};
            $src_type  = $props{$id}{src_type};
            $src_lines = $props{$id}{src_lines};
            $conv_type = $props{$id}{ctype};
            $parm      = $props{$id}{parm};
            if ($src_type =~ /^W2 /) {
                $byear  = $props{$id}{byear};
                $tzoff  = $props{$id}{tz_offset};
                $segnum = ($src_type =~ /^W2 [HDSW]/) ? $props{$id}{seg} : "n/a";
            }
        } else {
            $read_file = 0;
            %ts_data   = %{ $props{$id}{ts_data} };
        }
    }
    $fmt = "%.${digits}f";

#   Read the time-series data if this is a new text link or if opening a new project file.
    if ($id == 0 || $read_file) {
        @fmt_group1 = ("USGS getData format",
                       "Aquarius Time-Series format",
                       "Dataquery format",
                       "USGS Water Services format",
                       "USGS Data Grapher format",
                       "CSV format",
                      );
        @fmt_group2 = ("W2 TSR format",
                       "W2 Outflow CSV format",
                       "W2 Layer Outflow CSV format",
                       "W2 CSV format",
                       "W2 column format",
                      );
        if ($src_lines > 4000) {
            ($pbar_win, $pbar) = &create_progress_bar($main, 0, 300, $src_lines,
                                                      "Reading time-series file...");
        }
        if (&list_match($src_type, @fmt_group1) >= 0) {
            %ts_data = &read_timeseries($main, $src_file, $src_type, $parm, $pbar);

        } elsif (&list_match($src_type, @fmt_group2) >= 0) {
            %ts_data = &read_w2_timeseries($main, $src_file, $src_type, $parm, $byear, $tzoff, $pbar);

        } elsif ($src_type eq "W2 Heat Fluxes format") {
            %ts_data = &read_w2_heatfluxes($main, $src_file, $parm, $byear, $tzoff, $segnum, $pbar);

        } elsif ($src_type =~ /W2 .*aily .*Temp2?\.dat format/) {
            %ts_data = &read_w2_flowtemp($main, $src_file, $parm, $byear, $tzoff, $segnum, $pbar);

        } elsif ($src_type eq "W2 Water Level (wl) format") {
            %ts_data = &read_w2_wlevel($main, $id, $src_file, $byear, $tzoff, $segnum, 0, 0, $pbar);
        }
        if ($src_lines > 4000) {
            &destroy_progress_bar($main, $pbar_win);
        }
        if (&list_match($conv_type, @conv_types) > 0 || $conv_type =~ /^Custom,/) {
            %ts_data = &convert_timeseries($main, $conv_type, 0, %ts_data);
        }
    }

#   Adjust dt, if needed
    @ts_keys  = keys %ts_data;
    $ts_daily = (length($ts_keys[0]) == 12) ? 0 : 1;
    $dt_daily = (length($dt)         == 12) ? 0 : 1;
    $ts_dt    = $dt;
    if ($dt_daily != $ts_daily) {
        if ($ts_daily) {
            $dt2 = &nearest_daily_dt($dt);
            if (defined($ts_data{$dt2}) && &get_dt_diff($dt, 10000*$dt2) <= $tol) {
                $ts_dt = $dt2;
            }
        } else {
            $ts_dt .= "0000";
        }
    }
    if (! defined($ts_data{$ts_dt}) && $tol > 0 && ! $dt_daily && ! $ts_daily) { 
        for ($mi=1; $mi<=$tol; $mi++) {
            $dt2 = &adjust_dt($ts_dt, $mi);
            if (defined($ts_data{$dt2})) {
                $ts_dt = $dt2;
                last;
            }
            $dt2 = &adjust_dt($ts_dt, -1 *$mi);
            if (defined($ts_data{$dt2})) {
                $ts_dt = $dt2;
                last;
            }
        }
    }

#   Create or update link text
    if (defined($ts_data{$ts_dt})) {
        if ($units =~ /^(Celsius|Fahrenheit)$/) {
            $link_txt = sprintf($fmt, $ts_data{$ts_dt}) . "\N{U+00B0}" . substr($units,0,1);
        } else {
            $link_txt = sprintf($fmt, $ts_data{$ts_dt}) . " " . $units;
        }
    } else {
        if ($units =~ /^(Celsius|Fahrenheit)$/) {
            $link_txt = "na " . "\N{U+00B0}" . substr($units,0,1);
        } else {
            $link_txt = "na " . $units;
        }
    }

#   Create new text object, if necessary
    if ($id == 0) {
        ($xo, $yo, undef, undef) = split(/x|\+/, $main->g_wm_geometry());
        $xo /= 2;
        $yo /= 2;
        $id = $canv->create_text($xo, $yo,
                              -anchor => 'e',
                              -fill   => &get_rgb_code($color),
                              -angle  => 0,
                              -text   => $link_txt,
                              -tags   => "keep",
                              -font   => [ -family     => $font,
                                           -size       => $size,
                                           -weight     => $weight,
                                           -slant      => $slant_type[$slant],
                                           -underline  => 0,
                                           -overstrike => 0,
                                         ]);
        $props{$id}{type}      = "text";
        $props{$id}{text}      = $link_txt;
        $props{$id}{x}         = $xo;
        $props{$id}{y}         = $yo;
        $props{$id}{anchor}    = 'e';
        $props{$id}{coordlist} = [$xo, $yo];
        $props{$id}{color}     = $color;
        $props{$id}{family}    = $font;
        $props{$id}{size}      = $size;
        $props{$id}{weight}    = $weight;
        $props{$id}{slant}     = $slant;
        $props{$id}{underline} = 0;
        $props{$id}{angle}     = 0;
        &find_rect_from_text_or_image($canv, $id);

        if (! @ind_link_ids || &list_match($id, @ind_link_ids) == -1) {
            push (@ind_link_ids, $id);
        }
        $props{$id}{src_file}  = $src_file;
        $props{$id}{src_type}  = $src_type;
        $props{$id}{src_lines} = $src_lines;
        $props{$id}{ctype}     = $conv_type;
        $props{$id}{parm}      = $parm;
        if ($src_type =~ /^W2 /) {
            $props{$id}{byear}     = $byear;
            $props{$id}{tz_offset} = $tzoff;
            $props{$id}{seg}       = $segnum;
        }
        $props{$id}{data_type} = $data_type;
        $props{$id}{units}     = $units;
        $props{$id}{digits}    = $digits;
        $props{$id}{link_tol}  = $tol;
        $props{$id}{ts_data}   = { %ts_data };

        $canv->g_bind("<Motion>",   [ \&move_object, Tkx::Ev("%x","%y"), $canv, $id, $xo, $yo, "", 0 ]);
        $canv->g_bind("<Button-1>", [ \&end_move_object, $canv, $id, "" ]);
        $canv->g_bind("<Button-3>", [ \&forget_ind_link, $canv, $id ]);

#   Update text of existing linked object
    } else {
        $props{$id}{text}    = $link_txt;
        $props{$id}{ts_data} = { %ts_data } if ($read_file);
        if ($from_menu) {
            $canv->itemconfigure($id, -text => $link_txt,
                                      -fill => &get_rgb_code($color),
                                      -font => [ -family     => $font,
                                                 -size       => $size,
                                                 -weight     => $weight,
                                                 -slant      => $slant_type[$slant],
                                                 -underline  => $props{$id}{underline},
                                                 -overstrike => 0,
                                               ]);
            $props{$id}{color}     = $color;
            $props{$id}{family}    = $font;
            $props{$id}{size}      = $size;
            $props{$id}{weight}    = $weight;
            $props{$id}{slant}     = $slant;
            $props{$id}{src_file}  = $src_file;
            $props{$id}{src_type}  = $src_type;
            $props{$id}{src_lines} = $src_lines;
            $props{$id}{ctype}     = $conv_type;
            $props{$id}{parm}      = $parm;
            if ($src_type =~ /^W2 /) {
                $props{$id}{byear}     = $byear;
                $props{$id}{tz_offset} = $tzoff;
                $props{$id}{seg}       = $segnum;
            }
            $props{$id}{data_type} = $data_type;
            $props{$id}{units}     = $units;
            $props{$id}{digits}    = $digits;
            $props{$id}{link_tol}  = $tol;
        } else {
            $canv->itemconfigure($id, -text => $link_txt);
        }
    }
    undef %ts_data;
    undef @ts_keys;
}


sub update_ind_links {
    my ($canv) = @_;
    my ($i, %parms);

    return if (! @ind_link_ids || $#ind_link_ids < 0);

#   Loop over the @ind_link_ids array to update each link.
    %parms = ();
    for ($i=0; $i<=$#ind_link_ids; $i++) {
        &set_ind_link($canv, $ind_link_ids[$i], %parms);
    }
}


sub forget_ind_link {
    my ($canv, $id) = @_;

    $canv->delete($id);
    delete $props{$id};
    if (&list_match($id, @ind_link_ids) >= 0) {
        splice(@ind_link_ids, &list_match($id, @ind_link_ids), 1);
    }
    &reset_bindings;
}


sub forget_link {
    my ($canv, $link_id) = @_;

    $canv->delete($link_id);
    delete $props{$link_id};
    delete $link_props{$link_id};
    &reset_bindings;
}


sub add_ts_link {
    my ($canv, $id, $X, $Y) = @_;
    my (
        $code, $color, $color_btn, $color_label, $fg, $frame, $geom,
        $jd_max, $jd_min, $n, $outlet_frame, $row, $row2, $ts_frame,
        $ts_type, $ts_type_cb, $units, $units_cb, $width, $width_label,
        $width_sb, $xmax, $xmin,

        @color, @color_btns, @datelist1, @datelist2, @def_colors,
        @link_types, @names, @show, @unit_opts, @width, @width_sbs,
       );

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($add_ts_link_menu) && Tkx::winfo_exists($add_ts_link_menu)) {
        if ($add_ts_link_menu->g_wm_title() eq "Add Time Series Link") {
            $add_ts_link_menu->g_destroy();
            undef $add_ts_link_menu;
        }
    }
    $add_ts_link_menu = $main->new_toplevel();
    $add_ts_link_menu->g_wm_transient($main);
    $add_ts_link_menu->g_wm_title("Add Time Series Link");
    $add_ts_link_menu->configure(-cursor => $cursor_norm);
    $add_ts_link_menu->g_wm_geometry($geom);

    if ($props{$id}{meta} eq "vert_wd_zone") {
        @link_types = ("Release Rate", "Temperature", "Water Surface Elevation");
        $ts_type = "Release Rate";
        $units   = "cms";
        @names   = @{ $gr_props{$id}{names} };
        push (@names, "All Outlets");
    } elsif ($props{$id}{meta} eq "w2_outflow") {
        @link_types = ("Release Rate", "Water Surface Elevation");
        $ts_type = "Release Rate";
        $units   = "cms";
        @names   = ("All Outlets");
    } else {
        @link_types = ("Water Surface Elevation");
        $ts_type = "Water Surface Elevation";
        $units   = "m";
        @names   = ("All Outlets");
    }

    @def_colors = ("#000000", "#CC0000", "#0000FF", "#00E6FF", "#9900CC",
                   "#008B00", "#FF9900", "#990033", "#999999", "#FF00FF");
    for ($n=0; $n<=$#names; $n++) {
        $show[$n]  = 0;
        $width[$n] = $default_width;
        $color[$n] = $def_colors[$n % 10];
    }
    $show[-1] = 1;

    &end_select($canv, $id, 1);

    if ($ts_type eq "Release Rate") {
        @unit_opts = ("cms", "cfs");
    } elsif ($ts_type eq "Water Surface Elevation") {
        @unit_opts = ("m", "ft");
    } else {
        @unit_opts = ("Celsius", "Fahrenheit");
    }

#   Get date lists for start and end dates
    ($jd_min, $jd_max) = &dates2jdates($dates[0], $dates[$#dates]);
    $jd_min    = &floor($jd_min +0.0000001);
    $jd_max    = &floor($jd_max +1.0000001);
    @datelist1 = &jdates2datelabels("Mon-DD-YYYY", ($jd_min .. $jd_max));
    @datelist2 = @datelist1;
    pop   @datelist1;        # remove last  entry from list 1
    shift @datelist2;        # remove first entry from list 2
    $xmin = $datelist1[0];
    $xmax = $datelist2[-1];

    $frame = $add_ts_link_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    $frame->new_button(
            -text    => "Create",
            -command => sub { &set_ts_link($canv, $id, $ts_type, $units, \@show,
                                           \@width, \@color, $xmin, $xmax,
                                           );
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $add_ts_link_menu->g_destroy();
                              undef $add_ts_link_menu; },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

    ($ts_frame = $add_ts_link_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_pack(-side => 'top');

    $row = 0;
    $ts_frame->new_label(
            -text => "Link Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ts_type_cb = $ts_frame->new_ttk__combobox(
            -textvariable => \$ts_type,
            -values       => [ @link_types ],
            -state        => 'readonly',
            -width        => 23,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
    $ts_type_cb->g_bind("<<ComboboxSelected>>",
              sub { if ($ts_type eq "Release Rate") {
                        @unit_opts = ("cms", "cfs");
                        $units = "cms" if ($units !~ /^(cfs|cms)$/);
                        if ($props{$id}{meta} eq "w2_outflow") {
                            $outlet_frame->g_grid_remove();
                            $width_label->g_grid();
                            $width_sb->g_grid();
                            $color_label->g_grid();
                            $color_btn->g_grid();
                        } else {
                            $outlet_frame->g_grid();
                            $width_label->g_grid_remove();
                            $width_sb->g_grid_remove();
                            $color_label->g_grid_remove();
                            $color_btn->g_grid_remove();
                        }
                    } elsif ($ts_type eq "Water Surface Elevation") {
                        @unit_opts = ("m", "ft");
                        $units = "m" if ($units !~ /^(ft|m)$/);
                        $outlet_frame->g_grid_remove();
                        $width_label->g_grid();
                        $width_sb->g_grid();
                        $color_label->g_grid();
                        $color_btn->g_grid();
                    } else {
                        @unit_opts = ("Celsius", "Fahrenheit");
                        $units = "Celsius" if ($units !~ /^(Celsius|Fahrenheit)$/);
                        $outlet_frame->g_grid();
                        $width_label->g_grid_remove();
                        $width_sb->g_grid_remove();
                        $color_label->g_grid_remove();
                        $color_btn->g_grid_remove();
                    }
                    $units_cb->configure(-values => [ @unit_opts ]);
                  });

    $row++;
    $ts_frame->new_label(
            -text => "Link Units: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($units_cb = $ts_frame->new_ttk__combobox(
            -textvariable => \$units,
            -values       => [ @unit_opts ],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);

    $row++;
    ($outlet_frame = $ts_frame->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_grid(-row => $row, -column => 0, -columnspan => 2, -sticky => 'ew', -pady => 2);

    $row2 = 0;
    $outlet_frame->new_label(
            -text => "Outlet",
            -font => 'default',
            )->g_grid(-row => $row2, -column => 1, -sticky => 'ew', -pady => 2);
    $outlet_frame->new_label(
            -text => "  Width  ",
            -font => 'default',
            )->g_grid(-row => $row2, -column => 2, -sticky => 'ew', -pady => 2);
    $outlet_frame->new_label(
            -text => "  Color  ",
            -font => 'default',
            )->g_grid(-row => $row2, -column => 3, -sticky => 'ew', -pady => 2);

    for ($n=0; $n<=$#names; $n++) {
        $row2++;
        $outlet_frame->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "",
                -font     => 'default',
                -variable => \$show[$n],
                -command  => [ sub { my ($nn) = @_;
                                     if ($show[$nn]) {
                                         $width_sbs[$nn]->configure(-state  => 'normal');
                                         $color_btns[$nn]->configure(-state => 'normal');
                                     } else {
                                         $width_sbs[$nn]->configure(-state  => 'disabled');
                                         $color_btns[$nn]->configure(-state => 'disabled');
                                     }
                                   }, $n ]
                )->g_grid(-row => $row2, -column => 0, -sticky => 'e', -pady => 2);
        $outlet_frame->new_label(
                -text => $names[$n],
                -font => 'default',
                )->g_grid(-row => $row2, -column => 1, -sticky => 'w', -pady => 2);
        ($width_sbs[$n] = $outlet_frame->new_spinbox(
                -textvariable => \$width[$n],
                -state        => 'readonly',
                -font         => 'default',
                -from         => 1,
                -to           => 10,
                -increment    => 1,
                -width        => 3,
                ))->g_grid(-row => $row2, -column => 2, -sticky => 'w', -padx => 4, -pady => 2);

        $code      = &get_rgb_code($color[$n]);
        $color[$n] = &get_rgb_name($code);
        $fg        = &get_rgb_code("black");
        if ($code =~ /^\#[0-9a-f]/i) {
            $fg = &get_rgb_code(&get_bw_contrast($code));
        }
        ($color_btns[$n] = $outlet_frame->new_button(
                -textvariable => \$color[$n],
                -background   => $code,
                -foreground   => $fg,
                -width        => -7,
                -command => [ sub { my ($nn) = @_;
                                    my ($newc, $code, $fg);
                                    $code = &get_rgb_code($color[$nn]);
                                    $newc = Tkx::tk___chooseColor(
                                               -initialcolor => $code,
                                               -parent       => $add_ts_link_menu);
                                    if ($newc) {
                                        $code       = &get_rgb_code($newc);
                                        $color[$nn] = &get_rgb_name($code);
                                        $fg         = &get_rgb_code("black");
                                        if ($code =~ /^#?[0-9a-f]/i) {
                                            $fg = &get_rgb_code(&get_bw_contrast($code));
                                        }
                                        $color_btns[$nn]->configure(-foreground => $fg,
                                                                    -background => $code);
                                        if ($nn == 0) {
                                            $color_btn->configure(-foreground => $fg,
                                                                  -background => $code);
                                        }
                                    }
                                  }, $n ]
                ))->g_grid(-row => $row2, -column => 3, -sticky => 'ew', -pady => 0);
        if ($show[$n]) {
            $width_sbs[$n]->configure(-state  => 'normal');
            $color_btns[$n]->configure(-state => 'normal');
        } else {
            $width_sbs[$n]->configure(-state  => 'disabled');
            $color_btns[$n]->configure(-state => 'disabled');
        }
    }

    $row++;
    ($width_label = $ts_frame->new_label(
            -text => "Outline Width: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($width_sb = $ts_frame->new_spinbox(
            -textvariable => \$width[0],
            -state        => 'readonly',
            -font         => 'default',
            -from         => 1,
            -to           => 10,
            -increment    => 1,
            -width        => 3,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    $row++;
    ($color_label = $ts_frame->new_label(
            -text => "Outline Color: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);

    $code     = &get_rgb_code($color[0]);
    $color[0] = &get_rgb_name($code);
    $fg       = &get_rgb_code("black");
    if ($code =~ /^\#[0-9a-f]/i) {
        $fg = &get_rgb_code(&get_bw_contrast($code));
    }
    ($color_btn = $ts_frame->new_button(
            -textvariable => \$color[0],
            -background   => $code,
            -foreground   => $fg,
            -width        => -7,
            -command => sub { my ($newc, $code, $fg);
                              $code = &get_rgb_code($color[0]);
                              $newc = Tkx::tk___chooseColor(
                                         -initialcolor => $code,
                                         -parent       => $add_ts_link_menu);
                              if ($newc) {
                                  $code     = &get_rgb_code($newc);
                                  $color[0] = &get_rgb_name($code);
                                  $fg       = &get_rgb_code("black");
                                  if ($code =~ /^#?[0-9a-f]/i) {
                                      $fg = &get_rgb_code(&get_bw_contrast($code));
                                  }
                                  $color_btn->configure(-foreground => $fg,
                                                        -background => $code);
                                  $color_btns[0]->configure(-foreground => $fg,
                                                            -background => $code);
                              }
                            }
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    if ($ts_type eq "Water Surface Elevation" || ($props{$id}{meta} eq "w2_outflow" &&
                                                  $ts_type eq "Release Rate")) {
        $outlet_frame->g_grid_remove();
    } else {
        $width_label->g_grid_remove();
        $width_sb->g_grid_remove();
        $color_label->g_grid_remove();
        $color_btn->g_grid_remove();
    }

    $row++;
    $ts_frame->new_label(
            -text    => "Start Date: ",
            -font    => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $ts_frame->new_ttk__combobox(
            -textvariable => \$xmin,
            -values       => [ @datelist1 ],
            -state        => 'readonly',
            )->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
    $row++;
    $ts_frame->new_label(
            -text    => "End Date: ",
            -font    => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $ts_frame->new_ttk__combobox(
            -textvariable => \$xmax,
            -values       => [ @datelist2 ],
            -state        => 'readonly',
            )->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);

    $ts_frame->g_grid_columnconfigure(1, -weight => 2);

    Tkx::wm_resizable($add_ts_link_menu,0,0);
    &adjust_window_position($add_ts_link_menu);
    $add_ts_link_menu->g_focus;
}


sub set_ts_link {
    my ($canv, $id, $ts_type, $units, $show_ref, $width_ref, $color_ref, $xmin, $xmax) = @_;
    my ($date, $flow, $jd, $jd_max, $jd_min, $max, $n,
        @color, @names, @qstr, @show, @width,
        %parms, %qdata,
       );

    @show  = @{ $show_ref  };
    @width = @{ $width_ref };
    @color = @{ $color_ref };

#   Ensure that xmin is less than xmax
    $jd_min = &datelabel2jdate($xmin);
    $jd_max = &datelabel2jdate($xmax);
    if ($jd_min >= $jd_max) {
        return &pop_up_error($add_ts_link_menu,
                             "The start date must be prior to the end date.");
    }
    if ($ts_type ne "Water Surface Elevation") {
        if (&list_search("1", @show) == -1) {
            return &pop_up_error($add_ts_link_menu,
                                 "At least one outlet must be chosen.\nPlease try again.");
        }
    }

    $parms{ts_type} = $ts_type;
    $parms{units}   = $units;
    $parms{show}    = [ @show  ];
    $parms{width}   = [ @width ];
    $parms{color}   = [ @color ];
    $parms{xmin}    = $xmin;
    $parms{xmax}    = $xmax;
    if ($ts_type eq "Water Surface Elevation") {
        $parms{ymin} = $gr_props{$id}{ymin};
        $parms{ymax} = $gr_props{$id}{ymax};
        if ($units eq "ft" && $gr_props{$id}{yunits} ne "feet") {
            $parms{ymin} =  int($parms{ymin} *3.28084 /100)     *100;
            $parms{ymax} = (int($parms{ymax} *3.28084 /100) +1) *100;
        } elsif ($units eq "m" && $gr_props{$id}{yunits} eq "feet") {
            $parms{ymin} =  int($parms{ymin} /3.28084 /100)     *100;
            $parms{ymax} = (int($parms{ymax} /3.28084 /100) +1) *100;
        }
    } elsif ($ts_type eq "Release Rate") {
        if ($props{$id}{meta} eq "vert_wd_zone") {
            %qdata = %{ $gr_props{$id}{qdata} };
            @names = @{ $gr_props{$id}{names} };
            push (@names, "All Outlets");
            $max = 0;
            for ($n=0; $n<=$#names; $n++) {
                next if (! $show[$n]);
                foreach $date (@dates) {
                    $jd = &date2jdate($date);
                    next if ($jd < $jd_min);
                    last if ($jd > $jd_max);
                    if (defined($qdata{$date})) {
                        @qstr = @{ $qdata{$date} };
                        if ($names[$n] eq "All Outlets") {
                            $flow = &sum(@qstr);
                        } else {
                            $flow = $qstr[$n];
                        }
                        $max = $flow if ($flow > $max);
                    }
                }
            }
        } elsif ($props{$id}{meta} eq "w2_outflow") {
            %qdata = %{ $gr_props{$id}{qdata} };
            @names = ("All Outlets");
            $max   = 0;
            foreach $date (@dates) {
                $jd = &date2jdate($date);
                next if ($jd < $jd_min);
                last if ($jd > $jd_max);
                if (defined($qdata{$date})) {
                    @qstr = @{ $qdata{$date} };
                    $max  = $qstr[0] if ($qstr[0] > $max);
                }
            }
        }
        undef %qdata;
        $parms{ymin} = 0;
        $parms{ymax} = (int($max /10.) +1) *10;
        if ($units eq "cfs") {
            $parms{ymax} = (int($parms{ymax} *35.31467 /100.) +1) *100;
        }
    } elsif ($ts_type eq "Temperature") {
        if ($gr_props{$id}{add_cs}) {
            if ($props{$id}{wt_units} eq "Fahrenheit") {
                $parms{ymin} = ($gr_props{$id}{cs_min} -32) /1.8;
                $parms{ymax} = ($gr_props{$id}{cs_max} -32) /1.8;
            } else {
                $parms{ymin} = $gr_props{$id}{cs_min};
                $parms{ymax} = $gr_props{$id}{cs_max};
            }
        } else {
            $parms{ymin} =  0;
            $parms{ymax} = 24;
        }
        if ($units eq "Fahrenheit") {
            $parms{ymin} = 1.8 *$parms{ymin} +32;
            $parms{ymax} = 1.8 *$parms{ymax} +32;
        }
    }

    $canv->g_bind("<Motion>",   [ \&show_xypos,     Tkx::Ev("%x","%y"), $canv, 1 ]);
    $canv->g_bind("<Button-1>", [ \&start_ts_graph, Tkx::Ev("%x","%y"), $canv, $id, %parms ]);
    $canv->g_bind("<Button-3>", [ \&forget_drawing, '' ]);
    $canv->configure(-cursor => $cursor_draw);

    $add_ts_link_menu->g_destroy();
    undef $add_ts_link_menu;
}


sub start_ts_graph {
    my ($x, $y, $canv, $link_id, %parms) = @_;
    my ($id);

    ($x, $y) = &get_xy($canv, $x, $y, $snap2grid);
    $canv->delete("target");

    $id = $canv->create_rectangle($x, $y, $x, $y,
                 -outline => &get_rgb_code($default_color),
                 -width   => 1,
                 -fill    => "",
                 -tags    => "working");
    $props{$id}{type}      = "graph";
    $props{$id}{meta}      = "linked_time_series";
    $props{$id}{x}         = $x;
    $props{$id}{y}         = $y;
    $props{$id}{xc}        = $x;
    $props{$id}{yc}        = $y;
    $props{$id}{anchor}    = 'corner';
    $props{$id}{coordlist} = [$x, $y, $x, $y];
    $props{$id}{color}     = $default_color;
    $props{$id}{width}     = $default_width;
    $props{$id}{fill}      = 0;
    $props{$id}{link_id}   = $link_id;
    $props{$id}{ts_parms}  = { %parms };
    $canv->addtag("graph" . $id, withtag => $id);

    $canv->create_rectangle($x-2, $y-2, $x+2, $y+2,
                 -outline => &get_rgb_code($anchor_line_color),
                 -width   => 1,
                 -fill    => &get_rgb_code($anchor_select_color),
                 -tags    => "anchor");

    $canv->g_bind("<Shift-Motion>", [ \&size_object, Tkx::Ev("%x","%y"), $canv, $x, $y, $id, 1 ]);
    $canv->g_bind("<Motion>",       [ \&size_object, Tkx::Ev("%x","%y"), $canv, $x, $y, $id, 0 ]);
    $canv->g_bind("<Button-1>",     [ \&end_drawing, Tkx::Ev("%x","%y"), $canv, $x, $y, $id ]);
    $canv->g_bind("<Button-3>",     [ \&forget_drawing, $id ]);
}


sub show_info {
    my ($canv, $id, $X, $Y) = @_;
    my (
        $coordlist, $croplist, $diff, $dist_txt, $dpth_txt, $dt_txt,
        $dtmax, $dtmin, $elev_txt, $f, $flip, $flow_txt, $frame, $geom,
        $i, $npts, $obj_type, $parm_txt, $pmax, $pmin, $ptxt, $row, $scale,
        $tmp_frame, $txt, $type, $xmax, $xmin, $ymax, $ymin,

        @bfiles, @cfiles, @coords, @crop, @xvals, @yvals,
        %parms,
       );

    &end_select($canvas, $id, 1);

    $geom = sprintf("+%d+%d", $X, $Y);
    $type = $props{$id}{type};

    if (defined($object_infobox) && Tkx::winfo_exists($object_infobox)) {
        if ($object_infobox->g_wm_title() =~ /Object Info/) {
            $object_infobox->g_destroy();
            undef $object_infobox;
        }
    }
    $object_infobox = $main->new_toplevel();
    $object_infobox->g_wm_transient($main);
    $object_infobox->g_wm_title("Object Info, ID $id");
    $object_infobox->configure(-cursor => $cursor_norm);
    $object_infobox->g_wm_geometry($geom);

    $frame = $object_infobox->new_frame();
    $frame->g_pack(-side => 'bottom');
    $frame->new_button(
            -text    => "OK",
            -command => sub { $object_infobox->g_destroy();
                              undef $object_infobox; },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

    $f = $object_infobox->new_frame(
                -borderwidth => 1,
                -relief => 'groove',
                );
    $f->g_pack(-side => 'top');

    $row = 0;
    $obj_type  = ucfirst($type);
    $obj_type .= " Link" if ($type =~ /^(text|circle|ellipse|rectangle|diamond|polygon)$/
                             && defined($link_props{$id}{id}));
    $obj_type .= " Link" if ($type eq "text" && &list_match($id, @ind_link_ids) >= 0);

    if ($type eq "graph") {
        if ($props{$id}{meta} eq "data_profile") {
            $obj_type = "Profile Graph";
        } elsif ($props{$id}{meta} eq "data_profile_cmap") {
            $obj_type = "Profile Colormap";
        } elsif ($props{$id}{meta} eq "w2_profile") {
            $obj_type = "W2 Profile Graph";
        } elsif ($props{$id}{meta} eq "w2_profile_cmap") {
            $obj_type = "W2 Profile Colormap";
        } elsif ($props{$id}{meta} eq "w2_profile_matrix") {
            $obj_type = "W2 Profile Matrix";
        } elsif ($props{$id}{meta} eq "w2_outflow") {
            $obj_type = "W2 Outflow Profile";
        } elsif ($props{$id}{meta} eq "w2_wlevels") {
            $obj_type = "W2 Water Levels Graph";
        } elsif ($props{$id}{meta} eq "w2_slice") {
            $obj_type = "W2 Longitudinal Slice";
        } elsif ($props{$id}{meta} eq "w2_tdmap") {
            $obj_type = "W2 Time/Distance Map";
            if ($props{$id}{map_type} =~ /^(parmdiff|filediff)$/) {
                $obj_type = "W2 Time/Distance Difference Map";
            }
        } elsif ($props{$id}{meta} eq "vert_wd_zone") {
            $obj_type = "Vertical Withdrawal Zone";
        } elsif ($props{$id}{meta} eq "linked_time_series") {
            $obj_type = "Linked Time Series Graph";
        } elsif ($props{$id}{meta} eq "time_series") {
            $obj_type = "Time Series Graph";
        }
    }
    $f->new_label(
            -text => "Object: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $f->new_label(
            -text => $obj_type,
            -font => 'default',
            )->g_grid(-row => $row, -column => 1, -sticky => 'w');
    if ($type eq "graph") {
        if ($props{$id}{meta} =~ /data_profile/) {
            $row++;
            $f->new_label(
                    -text => "Profile Type: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => ucfirst($props{$id}{prof_type}),
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
        }
        if ($props{$id}{meta} =~ /data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone/) {
            if ($gr_props{$id}{elev_min} eq "n/a") {
                $elev_txt = "n/a to ";
            } else {
                if ($gr_props{$id}{yunits} eq "feet") {
                    $elev_txt = sprintf("%.2f", $gr_props{$id}{elev_min} *3.28084) . " to ";
                } else {
                    $elev_txt = sprintf("%.2f", $gr_props{$id}{elev_min}) . " to ";
                }
            }
            if ($gr_props{$id}{elev_max} eq "n/a") {
                if ($gr_props{$id}{yunits} eq "feet") {
                    $elev_txt .= "n/a ft";
                } else {
                    $elev_txt .= "n/a m";
                }
            } else {
                if ($gr_props{$id}{yunits} eq "feet") {
                    $elev_txt .= sprintf("%.2f", $gr_props{$id}{elev_max} *3.28084) . " ft";
                } else {
                    $elev_txt .= sprintf("%.2f", $gr_props{$id}{elev_max}) . " m";
                }
            }
            if ($props{$id}{meta} ne "w2_wlevels") {
                if ($gr_props{$id}{dpth_min} eq "n/a") {
                    $dpth_txt = "n/a to ";
                } else {
                    if ($gr_props{$id}{yunits} eq "feet") {
                        $dpth_txt = sprintf("%.2f", $gr_props{$id}{dpth_min} *3.28084) . " to ";
                    } else {
                        $dpth_txt = sprintf("%.2f", $gr_props{$id}{dpth_min}) . " to ";
                    }
                }
                if ($gr_props{$id}{dpth_max} eq "n/a") {
                    if ($gr_props{$id}{yunits} eq "feet") {
                        $dpth_txt .= "n/a ft";
                    } else {
                        $dpth_txt .= "n/a m";
                    }
                } else {
                    if ($gr_props{$id}{yunits} eq "feet") {
                        $dpth_txt .= sprintf("%.2f", $gr_props{$id}{dpth_max} *3.28084) . " ft";
                    } else {
                        $dpth_txt .= sprintf("%.2f", $gr_props{$id}{dpth_max}) . " m";
                    }
                }
            }
        }
        if ($props{$id}{meta} =~ /data_profile|w2_profile|w2_slice/) {
            if ($props{$id}{parm} eq "Temperature") {
                if ($props{$id}{parm_units} eq "Fahrenheit") {
                    if ($props{$id}{meta} =~ /data_profile/
                         && $props{$id}{prof_type} eq "difference") {
                        $diff = 0;
                    } else {
                        $diff = 32;
                    }
                    if ($gr_props{$id}{parm_min} eq "n/a") {
                        $parm_txt = "n/a to ";
                    } else {
                        $parm_txt = sprintf("%.2f", $gr_props{$id}{parm_min} *1.8 +$diff) . " to ";
                    }
                    if ($gr_props{$id}{parm_max} eq "n/a") {
                        $parm_txt .= "n/a " . " \N{U+00B0}" . substr($props{$id}{parm_units},0,1);
                    } else {
                        $parm_txt .= sprintf("%.2f", $gr_props{$id}{parm_max} *1.8 +$diff)
                                   . " \N{U+00B0}" . substr($props{$id}{parm_units},0,1);
                    }
                } else {
                    if ($gr_props{$id}{parm_min} eq "n/a") {
                        $parm_txt = "n/a to ";
                    } else {
                        $parm_txt = sprintf("%.2f", $gr_props{$id}{parm_min}) . " to ";
                    }
                    if ($gr_props{$id}{parm_max} eq "n/a") {
                        $parm_txt .= "n/a " . " \N{U+00B0}" . substr($props{$id}{parm_units},0,1);
                    } else {
                        $parm_txt .= sprintf("%.2f", $gr_props{$id}{parm_max})
                                   . " \N{U+00B0}" . substr($props{$id}{parm_units},0,1);
                    }
                }
            } else {
                if ($gr_props{$id}{parm_min} eq "n/a") {
                    $parm_txt = "n/a to ";
                } else {
                    $parm_txt = sprintf("%.2f", $gr_props{$id}{parm_min}) . " to ";
                }
                if ($gr_props{$id}{parm_max} eq "n/a") {
                    $parm_txt .= "n/a " . $props{$id}{parm_units};
                } else {
                    $parm_txt .= sprintf("%.2f", $gr_props{$id}{parm_max}) . " "
                               . $props{$id}{parm_units};
                }
            }
            $row++;
            $f->new_label(
                    -text => "Parameter: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            if ($props{$id}{meta} =~ /w2_profile|w2_slice/ && $props{$id}{parm_div} ne "None") {
                $f->new_label(
                        -text => $props{$id}{parm} . " / " . $props{$id}{parm_div},
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            } else {
                $f->new_label(
                        -text => $props{$id}{parm},
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            }
            $row++;
            $f->new_label(
                    -text => "Parameter Range: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $parm_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "Elevation Range: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $elev_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "Depth Range: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $dpth_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');

            if ($props{$id}{meta} eq "w2_slice") {
                if ($gr_props{$id}{xunits} eq "miles") {
                    $dist_txt = sprintf("%.3f", $gr_props{$id}{x_km} *3280.84/5280.) . " miles";
                } else {
                    $dist_txt = sprintf("%.3f", $gr_props{$id}{x_km}) . " kms";
                }
                $row++;
                $f->new_label(
                        -text => "Distance Range: ",
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                $f->new_label(
                        -text => $dist_txt,
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            }

        } elsif ($props{$id}{meta} eq "w2_tdmap") {
            if ($props{$id}{parm} eq "Temperature") {
                if ($props{$id}{parm_units} eq "Fahrenheit") {
                    $diff = ($props{$id}{map_type} eq "standard") ? 32 : 0;
                    if ($gr_props{$id}{parm_min} eq "n/a") {
                        $parm_txt = "n/a to ";
                    } else {
                        $parm_txt = sprintf("%.2f", $gr_props{$id}{parm_min} *1.8 +$diff) . " to ";
                    }
                    if ($gr_props{$id}{parm_max} eq "n/a") {
                        $parm_txt .= "n/a " . " \N{U+00B0}" . substr($props{$id}{parm_units},0,1);
                    } else {
                        $parm_txt .= sprintf("%.2f", $gr_props{$id}{parm_max} *1.8 +$diff)
                                   . " \N{U+00B0}" . substr($props{$id}{parm_units},0,1);
                    }
                } else {
                    if ($gr_props{$id}{parm_min} eq "n/a") {
                        $parm_txt = "n/a to ";
                    } else {
                        $parm_txt = sprintf("%.2f", $gr_props{$id}{parm_min}) . " to ";
                    }
                    if ($gr_props{$id}{parm_max} eq "n/a") {
                        $parm_txt .= "n/a " . " \N{U+00B0}" . substr($props{$id}{parm_units},0,1);
                    } else {
                        $parm_txt .= sprintf("%.2f", $gr_props{$id}{parm_max})
                                   . " \N{U+00B0}" . substr($props{$id}{parm_units},0,1);
                    }
                }
                if ($props{$id}{parm_div} ne "None" && $parm_txt =~ / \N{U+00B0}[CF]/) {
                    $parm_txt =~ s/ \N{U+00B0}[CF]//;
                }
            } else {
                if ($gr_props{$id}{parm_min} eq "n/a") {
                    $parm_txt = "n/a to ";
                } else {
                    $parm_txt = sprintf("%.2f", $gr_props{$id}{parm_min}) . " to ";
                }
                if ($gr_props{$id}{parm_max} eq "n/a") {
                    $parm_txt .= "n/a " . $props{$id}{parm_units};
                } else {
                    $parm_txt .= sprintf("%.2f", $gr_props{$id}{parm_max}) . " "
                               . $props{$id}{parm_units};
                }
            }
            if ($gr_props{$id}{dunits} eq "miles") {
                $dist_txt = sprintf("%.3f", $gr_props{$id}{d_km} *3280.84/5280.) . " miles";
            } else {
                $dist_txt = sprintf("%.3f", $gr_props{$id}{d_km}) . " kms";
            }
            if ($props{$id}{pdiv_sav} ne "None") {
                $txt = $props{$id}{parm_sav} . " / " . $props{$id}{pdiv_sav};
            } else {
                $txt = $props{$id}{parm_sav};
            }
            if ($props{$id}{map_type} eq "parmdiff") {
                if ($props{$id}{swap_order}) {
                    if ($props{$id}{pdiv2_sav} ne "None") {
                        $txt = $props{$id}{parm2_sav} . " / " . $props{$id}{pdiv2_sav} . " minus " . $txt;
                    } else {
                        $txt = $props{$id}{parm2_sav} . " minus " . $txt;
                    }
                } else {
                    if ($props{$id}{pdiv2_sav} ne "None") {
                        $txt .= " minus " . $props{$id}{parm2_sav} . " / " . $props{$id}{pdiv2_sav};
                    } else {
                        $txt .= " minus " . $props{$id}{parm2_sav};
                    }
                }
                $ptxt = "Difference: ";
            } else {
                $ptxt = "Parameter: ";
            }
            $row++;
            $f->new_label(
                    -text => $ptxt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "Profile Stat: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $props{$id}{prof_stat},
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "Parameter Range: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $parm_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "Distance Range: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $dist_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');

        } elsif ($props{$id}{meta} eq "w2_outflow") {
            if ($gr_props{$id}{qunits} eq "cfs/ft") {
                $txt      = "Outflow Range: ";
                $flow_txt = sprintf("%.2f", $gr_props{$id}{flow_min} *10.763911) . " to "
                          . sprintf("%.2f", $gr_props{$id}{flow_max} *10.763911) . " cfs/(vert. ft)";
            } elsif ($gr_props{$id}{qunits} eq "cms/m") {
                $txt      = "Outflow Range: ";
                $flow_txt = sprintf("%.2f", $gr_props{$id}{flow_min}) . " to "
                          . sprintf("%.2f", $gr_props{$id}{flow_max}) . " cms/(vert. m)";
            } elsif ($gr_props{$id}{qunits} eq "ft/s") {
                $txt      = "Velocity Range: ";
                $flow_txt = sprintf("%.3f", $gr_props{$id}{vel_min} *3.28084) . " to "
                          . sprintf("%.3f", $gr_props{$id}{vel_max} *3.28084) . " ft/s";
            } else {
                $txt      = "Velocity Range: ";
                $flow_txt = sprintf("%.3f", $gr_props{$id}{vel_min}) . " to "
                          . sprintf("%.3f", $gr_props{$id}{vel_max}) . " m/s";
            }
            $row++;
            $f->new_label(
                    -text => "Elevation Range: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $elev_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "Depth Range: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $dpth_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => $txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $flow_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            if ($props{$id}{add_parm}) {
                if ($props{$id}{parm} eq "Temperature") {
                    if ($props{$id}{parm_units} eq "Fahrenheit") {
                        if ($gr_props{$id}{parm_min} eq "n/a") {
                            $parm_txt = "n/a to ";
                        } else {
                            $parm_txt = sprintf("%.2f", $gr_props{$id}{parm_min} *1.8 +32) . " to ";
                        }
                        if ($gr_props{$id}{parm_max} eq "n/a") {
                            $parm_txt .= "n/a " . " \N{U+00B0}" . substr($props{$id}{parm_units},0,1);
                        } else {
                            $parm_txt .= sprintf("%.2f", $gr_props{$id}{parm_max} *1.8 +32)
                                       . " \N{U+00B0}" . substr($props{$id}{parm_units},0,1);
                        }
                    } else {
                        if ($gr_props{$id}{parm_min} eq "n/a") {
                            $parm_txt = "n/a to ";
                        } else {
                            $parm_txt = sprintf("%.2f", $gr_props{$id}{parm_min}) . " to ";
                        }
                        if ($gr_props{$id}{parm_max} eq "n/a") {
                            $parm_txt .= "n/a " . " \N{U+00B0}" . substr($props{$id}{parm_units},0,1);
                        } else {
                            $parm_txt .= sprintf("%.2f", $gr_props{$id}{parm_max})
                                       . " \N{U+00B0}" . substr($props{$id}{parm_units},0,1);
                        }
                    }
                } else {
                    if ($gr_props{$id}{parm_min} eq "n/a") {
                        $parm_txt = "n/a to ";
                    } else {
                        $parm_txt = sprintf("%.2f", $gr_props{$id}{parm_min}) . " to ";
                    }
                    if ($gr_props{$id}{parm_max} eq "n/a") {
                        $parm_txt .= "n/a " . $props{$id}{parm_units};
                    } else {
                        $parm_txt .= sprintf("%.2f", $gr_props{$id}{parm_max}) . " "
                                   . $props{$id}{parm_units};
                    }
                }
                $row++;
                $f->new_label(
                        -text => "Color Parameter: ",
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                if ($props{$id}{parm_div} ne "None") {
                    $f->new_label(
                            -text => $props{$id}{parm} . " / " . $props{$id}{parm_div},
                            -font => 'default',
                            )->g_grid(-row => $row, -column => 1, -sticky => 'w');
                } else {
                    $f->new_label(
                            -text => $props{$id}{parm},
                            -font => 'default',
                            )->g_grid(-row => $row, -column => 1, -sticky => 'w');
                }
                $row++;
                $f->new_label(
                        -text => "Parameter Range: ",
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                $f->new_label(
                        -text => $parm_txt,
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            }

        } elsif ($props{$id}{meta} eq "w2_wlevels") {
            if ($gr_props{$id}{xunits} eq "miles") {
                $dist_txt = sprintf("%.3f", $gr_props{$id}{x_km} *3280.84/5280.) . " miles";
            } else {
                $dist_txt = sprintf("%.3f", $gr_props{$id}{x_km}) . " kms";
            }
            $row++;
            $f->new_label(
                    -text => "Elevation Range: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $elev_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "Distance Range: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $dist_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');

        } elsif ($props{$id}{meta} eq "vert_wd_zone") {
            if ($props{$id}{wt_units} eq "Fahrenheit") {
                if ($gr_props{$id}{parm_min} eq "n/a") {
                    $parm_txt = "n/a to ";
                } else {
                    $parm_txt = sprintf("%.2f", $gr_props{$id}{parm_min} *1.8 +32) . " to ";
                }
                if ($gr_props{$id}{parm_max} eq "n/a") {
                    $parm_txt .= "n/a " . " \N{U+00B0}" . substr($props{$id}{wt_units},0,1);
                } else {
                    $parm_txt .= sprintf("%.2f", $gr_props{$id}{parm_max} *1.8 +32)
                               . " \N{U+00B0}" . substr($props{$id}{wt_units},0,1);
                }
            } else {
                if ($gr_props{$id}{parm_min} eq "n/a") {
                    $parm_txt = "n/a to ";
                } else {
                    $parm_txt = sprintf("%.2f", $gr_props{$id}{parm_min}) . " to ";
                }
                if ($gr_props{$id}{parm_max} eq "n/a") {
                    $parm_txt .= "n/a " . " \N{U+00B0}" . substr($props{$id}{wt_units},0,1);
                } else {
                    $parm_txt .= sprintf("%.2f", $gr_props{$id}{parm_max})
                               . " \N{U+00B0}" . substr($props{$id}{wt_units},0,1);
                }
            }
            if ($gr_props{$id}{qunits} eq "cfs/ft" || $gr_props{$id}{qunits} eq "ft/s") {
                $flow_txt = sprintf("%.2f", $gr_props{$id}{flow_min} *35.31467) . " to "
                          . sprintf("%.2f", $gr_props{$id}{flow_max} *35.31467) . " cfs";
            } else {
                $flow_txt = sprintf("%.2f", $gr_props{$id}{flow_min}) . " to "
                          . sprintf("%.2f", $gr_props{$id}{flow_max}) . " cms";
            }
            $row++;
            $f->new_label(
                    -text => "Temperature Range: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $parm_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "Elevation Range: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $elev_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "Depth Range: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $dpth_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "Total Outflow Range: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $flow_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');

            if (! defined($gr_props{$id}{qtot_min}) || $gr_props{$id}{qtot_min} eq "not determined") {
                if ($gr_props{$id}{qunits} eq "cfs/ft" || $gr_props{$id}{qunits} eq "cms/m") {
                    $txt = "Layer Flow Range: ";
                } else {
                    $txt = "Velocity Range: ";
                }
                $row++;
                $f->new_label(
                        -text => $txt,
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                ($tmp_frame = $f->new_frame(
                        -borderwidth => 0,
                        -relief      => 'flat',
                        ))->g_grid(-row => $row, -column => 1, -sticky => 'ew');
                $tmp_frame->new_label(
                        -text => "not determined ",
                        -font => 'default',
                        )->g_pack(-side => 'left', -anchor => 'w');
                $tmp_frame->new_button(
                        -text    => "Calculate",
                        -command => sub { my (%limits, %profile);
                                          &generate_outflow_temps($id, 0);
                                          %profile = %{ $gr_props{$id} };
                                          %limits  = &find_data_limits($id, %profile);

                                          $gr_props{$id}{date_min} = $limits{date_min};
                                          $gr_props{$id}{date_max} = $limits{date_max};
                                          $gr_props{$id}{dpth_min} = $limits{dpth_min};
                                          $gr_props{$id}{dpth_max} = $limits{dpth_max};
                                          $gr_props{$id}{elev_min} = $limits{elev_min};
                                          $gr_props{$id}{elev_max} = $limits{elev_max};
                                          $gr_props{$id}{parm_min} = $limits{parm_min};
                                          $gr_props{$id}{parm_max} = $limits{parm_max};
                                          $gr_props{$id}{flow_min} = $limits{flow_min};
                                          $gr_props{$id}{flow_max} = $limits{flow_max};
                                          $gr_props{$id}{qtot_min} = $limits{qtot_min};
                                          $gr_props{$id}{qtot_max} = $limits{qtot_max};
                                          $gr_props{$id}{vtot_min} = $limits{vtot_min};
                                          $gr_props{$id}{vtot_max} = $limits{vtot_max};
                                          undef %limits;
                                          undef %profile;

                                          $geom = $object_infobox->g_wm_geometry();
                                          (undef, $X, $Y) = split(/\+/, $geom);
                                          &show_info($canv, $id, $X, $Y);
                                        },
                        )->g_pack(-side => 'left', -anchor => 'w', -padx => 2);
            } else {
                if ($gr_props{$id}{qunits} eq "cfs/ft") {
                    $txt      = "Layer Flow Range: ";
                    $flow_txt = sprintf("%.2f", $gr_props{$id}{qtot_min} *10.763911) . " to "
                              . sprintf("%.2f", $gr_props{$id}{qtot_max} *10.763911) . " cfs/(vert. ft)";
                } elsif ($gr_props{$id}{qunits} eq "cms/m") {
                    $txt      = "Layer Flow Range: ";
                    $flow_txt = sprintf("%.2f", $gr_props{$id}{qtot_min}) . " to "
                              . sprintf("%.2f", $gr_props{$id}{qtot_max}) . " cms/(vert. m)";
                } elsif ($gr_props{$id}{qunits} eq "ft/s") {
                    $txt      = "Velocity Range: ";
                    $flow_txt = sprintf("%.3f", $gr_props{$id}{vtot_min} *3.28084) . " to "
                              . sprintf("%.3f", $gr_props{$id}{vtot_max} *3.28084) . " ft/s";
                } else {
                    $txt      = "Velocity Range: ";
                    $flow_txt = sprintf("%.3f", $gr_props{$id}{vtot_min}) . " to "
                              . sprintf("%.3f", $gr_props{$id}{vtot_max}) . " m/s";
                }
                $row++;
                $f->new_label(
                        -text => $txt,
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                $f->new_label(
                        -text => $flow_txt,
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            }

        } elsif ($props{$id}{meta} =~ /time_series/) {
            $txt   = ($props{$id}{meta} eq "linked_time_series") ? "Link " : "";
            %parms = %{ $props{$id}{ts_parms} };
            if ($parms{ts_type} =~ /Temperature/i) {
                $parm_txt = "Temperature (\N{U+00B0}" . substr($parms{units},0,1) . ")";
            } else {
                $parm_txt = $parms{ts_type} . " (" . $parms{units} . ")";
            }
            undef %parms;
            $row++;
            $f->new_label(
                    -text => $txt . "Parameter: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $parm_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');

            ($dtmin, $dtmax, $pmin, $pmax) = &find_ts_limits($id);
            if ($dtmin != -999) {
                $dt_txt = &date2datelabel($dtmin, "Mon-DD-YYYY") . " to ";
                if (substr($dtmax,8,4) eq "0000") {
                    $dt_txt .= &date2datelabel($dtmax, "Mon-DD-YYYY");
                } else {
                    $dt_txt .= &date2datelabel(&adjust_dt_by_day($dtmax, 1), "Mon-DD-YYYY");
                }
                $parm_txt = sprintf("%.2f", $pmin) . " to " . sprintf("%.2f", $pmax);
            } else {
                $dt_txt = $parm_txt = "n/a";
            }
            $row++;
            $f->new_label(
                    -text => "Parameter Range: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $parm_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "Date Range: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $dt_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
        }
        if ($props{$id}{meta}
                =~ /data_profile|w2_profile|w2_tdmap|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone/) {
            if ($gr_props{$id}{date_min} != -999) {
                $dt_txt = &date2datelabel($gr_props{$id}{date_min}, "Mon-DD-YYYY") . " to ";
                if (substr($gr_props{$id}{date_max},8,4) eq "0000") {
                    $dt_txt .= &date2datelabel($gr_props{$id}{date_max}, "Mon-DD-YYYY");
                } else {
                    $dt_txt .= &date2datelabel(&adjust_dt_by_day($gr_props{$id}{date_max}, 1), "Mon-DD-YYYY");
                }
                if ($props{$id}{meta} eq "w2_slice" && $props{$id}{dt_limits}) {
                    $dt_txt .= " (restricted)";
                }
            } else {
                $dt_txt = "n/a";
            }
            $row++;
            $f->new_label(
                    -text => "Date Range: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $dt_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
        }
    }
    if ($type eq "graph") {
        $row++;
        $f->new_label(
                -text => "Graph Number: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text => $props{$id}{gnum},
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
    }
    $row++;
    $f->new_label(
            -text => "ID: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $f->new_label(
            -text => $id,
            -font => 'default',
            )->g_grid(-row => $row, -column => 1, -sticky => 'w');
    $row++;
    $f->new_label(
            -text => "Anchor X: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $f->new_label(
            -text => sprintf("%.4f", $props{$id}{x} -3),
            -font => 'default',
            )->g_grid(-row => $row, -column => 1, -sticky => 'w');
    $row++;
    $f->new_label(
            -text => "Anchor Y: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $f->new_label(
            -text => sprintf("%.4f", $props{$id}{y} -3),
            -font => 'default',
            )->g_grid(-row => $row, -column => 1, -sticky => 'w');
    $row++;
    $f->new_label(
            -text => "Anchor Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $f->new_label(
            -text => $props{$id}{anchor},
            -font => 'default',
            )->g_grid(-row => $row, -column => 1, -sticky => 'w');

    if ($type !~ /^(circle|line|graph)$/) {
        $row++;
        $f->new_label(
                -text => "Angle: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text => sprintf("%d", $props{$id}{angle}),
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
    }

    if ($type eq "image") {
        $flip = "None";
        if ($props{$id}{flip} eq "h") {
            $flip = "Horizontal";
        } elsif ($props{$id}{flip} eq "v") {
            $flip = "Vertical";
        } elsif ($props{$id}{flip} eq "vh") {
            $flip = "Horizontal and Vertical";
        }
        @crop = @{ $props{$id}{crop} };
        $croplist = sprintf("%.5f, %.5f, %.5f, %.5f",
                             $crop[0], $crop[1], $crop[2], $crop[3]);
        $scale = sprintf("%.5f", $props{$id}{iw} /$props{$id}{iwc});
        $row++;
        $f->new_label(
                -text => "Flip: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text => $flip,
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
        $row++;
        $f->new_label(
                -text => "Image Width: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text => $props{$id}{iw},
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
        $row++;
        $f->new_label(
                -text => "Image Height: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text => $props{$id}{ih},
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
        $row++;
        $f->new_label(
                -text => "Crop (L,R,T,B): ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text    => $croplist,
                -font    => 'default',
                -justify => 'left',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
        $row++;
        $f->new_label(
                -text => "Scale: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text => $scale,
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
        $row++;
        $f->new_label(
                -text => "File: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text => $props{$id}{file},
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
        Tkx::wm_resizable($object_infobox,0,0);
        &adjust_window_position($object_infobox);
        $object_infobox->g_focus;
        return;

    } elsif ($type eq "text") {
        $row++;
        $f->new_label(
                -text => "Font Family: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text => $props{$id}{family},
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
        $row++;
        $f->new_label(
                -text => "Font Size: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text => $props{$id}{size},
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
        $row++;
        $f->new_label(
                -text => "Font Weight: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text => $props{$id}{weight},
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
        $row++;
        $f->new_label(
                -text => "Font Slant: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text => $slant_options[$props{$id}{slant}],
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
        $row++;
        $f->new_label(
                -text => "Underline: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text => ("no", "yes")[$props{$id}{underline}],
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
        if (&list_match($id, @ind_link_ids) >= 0) {
            $row++;
            $f->new_label(
                    -text => "Source File: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $props{$id}{src_file},
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
        }
        Tkx::wm_resizable($object_infobox,0,0);
        &adjust_window_position($object_infobox);
        $object_infobox->g_focus;
        return;
    }

    @xvals     = @yvals = ();
    @coords    = Tkx::SplitList($canv->coords($id));
    $npts      = ($#coords +1)/2;
    $coordlist = "";
    for ($i=0; $i<$npts; $i++) {
        push (@xvals, $coords[2*$i]  -3);
        push (@yvals, $coords[2*$i+1]-3);
        $coordlist .= sprintf("%.4f, %.4f", $coords[2*$i]-3, $coords[2*$i+1]-3);
        $coordlist .= ", " if ($i % 2 == 0 && $i < $npts-1);
        $coordlist .= "\n" if ($i % 2 == 1 && $i < $npts-1);
    }
    $xmin = &min(@xvals);
    $xmax = &max(@xvals);
    $ymin = &min(@yvals);
    $ymax = &max(@yvals);

    if ($type =~ /^(circle|ellipse|rectangle|diamond|graph)$/) {
        $row++;
        $f->new_label(
                -text => "Center X: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text => sprintf("%.4f", $props{$id}{xc} -3),
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
        $row++;
        $f->new_label(
                -text => "Center Y: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text => sprintf("%.4f", $props{$id}{yc} -3),
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
    }

    if ($type eq "ellipse") {
        $row++;
        $f->new_label(
                -text => "Half Width: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text => $props{$id}{hw},
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
        $row++;
        $f->new_label(
                -text => "Half Height: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text => $props{$id}{hh},
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');

    } elsif ($type eq "circle") {
        $row++;
        $f->new_label(
                -text => "Diameter: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text => $xmax -$xmin,
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');

    } elsif ($type =~ /^(rectangle|diamond)$/) {
        $row++;
        $f->new_label(
                -text => "Corners: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text => $smooth_options[$props{$id}{smooth}],
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
    }

    if ($type eq "graph") {
        $row++;
        $f->new_label(
                -text => "Width: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'ne');
        $f->new_label(
                -text    => sprintf("%.4f", $xmax -$xmin),
                -font    => 'default',
                -justify => 'left',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
        $row++;
        $f->new_label(
                -text => "Height: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'ne');
        $f->new_label(
                -text    => sprintf("%.4f", $ymax -$ymin),
                -font    => 'default',
                -justify => 'left',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
    }
    if ($type ne "ellipse") {
        $row++;
        $f->new_label(
                -text => "Coordinates: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'ne');
        $f->new_label(
                -text    => $coordlist,
                -font    => 'default',
                -justify => 'left',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
    }

    if ($type eq "graph") {
        if ($props{$id}{meta} =~ /data_profile/) {
            $row++;
            $f->new_label(
                    -text => "Data File: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $props{$id}{src_file},
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
        } elsif ($props{$id}{meta} =~ /vert_wd_zone/) {
            $row++;
            $f->new_label(
                    -text => "WT Data File: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $props{$id}{wt_file},
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "Flow Data File: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $props{$id}{flow_file},
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "Bathymetry File: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $props{$id}{bth_file},
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            if ($props{$id}{wd_alg} eq "Libby Dam") {
                $row++;
                $f->new_label(
                        -text => "Bulkhead Config File: ",
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                $f->new_label(
                        -text => $props{$id}{lbc_file},
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            }
        } elsif ($props{$id}{meta} =~ /w2_profile/) {
            $row++;
            $f->new_label(
                    -text => "W2 Control File: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $props{$id}{con_file},
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => $props{$id}{src_type} . ": ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $props{$id}{src_file},
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "Bathymetry File: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $props{$id}{bth_file},
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            if (defined($props{$id}{ref_file})) {
                $row++;
                $f->new_label(
                        -text => "Reference File: ",
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                $f->new_label(
                        -text => $props{$id}{ref_file},
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            }
        } elsif ($props{$id}{meta} =~ /w2_slice|w2_wlevels/) {
            $row++;
            $f->new_label(
                    -text => "Y Exaggeration: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -textvariable => \$props{$id}{yexag_fac},
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "W2 Segments: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $props{$id}{seg_list},
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "W2 Waterbodies: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $props{$id}{wb_list},
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "W2 Control File: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $props{$id}{con_file},
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');

            if ($props{$id}{src_type} =~ /Contour/i) {
                @cfiles = @{ $props{$id}{cpl_files} };
                for ($i=0; $i<=$#cfiles; $i++) {
                    $row++;
                    $f->new_label(
                            -text => "W2 Contour File: ",
                            -font => 'default',
                            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                    $f->new_label(
                            -text => $cfiles[$i],
                            -font => 'default',
                            )->g_grid(-row => $row, -column => 1, -sticky => 'w');
                }
            } elsif ($props{$id}{src_type} =~ /Vector/i) {
                $row++;
                $f->new_label(
                        -text => "W2 Vector File: ",
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                $f->new_label(
                        -text => $props{$id}{w2l_file},
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            } elsif ($props{$id}{src_type} =~ /Water Level/i) {
                $row++;
                $f->new_label(
                        -text => "W2 Water Level File: ",
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                $f->new_label(
                        -text => $props{$id}{wl_file},
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            }
            @bfiles = @{ $props{$id}{bth_files} };
            for ($i=0; $i<=$#bfiles; $i++) {
                $row++;
                $f->new_label(
                        -text => "Bathymetry File: ",
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                $f->new_label(
                        -text => $bfiles[$i],
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            }
        } elsif ($props{$id}{meta} =~ /w2_tdmap/) {
            $row++;
            $f->new_label(
                    -text => "W2 Segments: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $props{$id}{seg_list},
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "W2 Waterbodies: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $props{$id}{wb_list},
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "W2 Control File: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $props{$id}{con_file},
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');

            if ($props{$id}{src_type} =~ /Contour/i) {
                @cfiles = @{ $props{$id}{cpl_files} };
                for ($i=0; $i<=$#cfiles; $i++) {
                    $row++;
                    $f->new_label(
                            -text => "W2 Contour File: ",
                            -font => 'default',
                            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                    $f->new_label(
                            -text => $cfiles[$i],
                            -font => 'default',
                            )->g_grid(-row => $row, -column => 1, -sticky => 'w');
                }
            } elsif ($props{$id}{src_type} =~ /RiverCon/i) {
                @cfiles = @{ $props{$id}{riv_files} };
                for ($i=0; $i<=$#cfiles; $i++) {
                    $row++;
                    $f->new_label(
                            -text => "W2 RiverCon File: ",
                            -font => 'default',
                            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                    $f->new_label(
                            -text => $cfiles[$i],
                            -font => 'default',
                            )->g_grid(-row => $row, -column => 1, -sticky => 'w');
                }
            } else {
                $row++;
                $f->new_label(
                        -text => $props{$id}{src_type} . ": ",
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                if ($props{$id}{src_type} =~ /Vector/i) {
                    $f->new_label(
                            -text => $props{$id}{w2l_file},
                            -font => 'default',
                            )->g_grid(-row => $row, -column => 1, -sticky => 'w');
                } else {
                    $f->new_label(
                            -text => $props{$id}{src_file},
                            -font => 'default',
                            )->g_grid(-row => $row, -column => 1, -sticky => 'w');
                }
            }
            @bfiles = @{ $props{$id}{bth_files} };
            for ($i=0; $i<=$#bfiles; $i++) {
                $row++;
                $f->new_label(
                        -text => "Bathymetry File: ",
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                $f->new_label(
                        -text => $bfiles[$i],
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            }
            if ($props{$id}{map_type} eq "filediff") {
                if ($props{$id}{src_type2} =~ /Contour/i) {
                    @cfiles = @{ $props{$id}{cpl_files2} };
                    for ($i=0; $i<=$#cfiles; $i++) {
                        $row++;
                        $f->new_label(
                                -text => "W2 Contour File 2: ",
                                -font => 'default',
                                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                        $f->new_label(
                                -text => $cfiles[$i],
                                -font => 'default',
                                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
                    }
                } elsif ($props{$id}{src_type2} =~ /RiverCon/i) {
                    @cfiles = @{ $props{$id}{riv_files2} };
                    for ($i=0; $i<=$#cfiles; $i++) {
                        $row++;
                        $f->new_label(
                                -text => "W2 RiverCon File 2: ",
                                -font => 'default',
                                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                        $f->new_label(
                                -text => $cfiles[$i],
                                -font => 'default',
                                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
                    }
                } else {
                    $row++;
                    $f->new_label(
                            -text => $props{$id}{src_type2} . " 2: ",
                            -font => 'default',
                            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                    if ($props{$id}{src_type2} =~ /Vector/i) {
                        $f->new_label(
                                -text => $props{$id}{w2l_file2},
                                -font => 'default',
                                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
                    } else {
                        $f->new_label(
                                -text => $props{$id}{src_file2},
                                -font => 'default',
                                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
                    }
                }
            }
        } elsif ($props{$id}{meta} =~ /w2_outflow/) {
            $row++;
            $f->new_label(
                    -text => "W2 Control File: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $props{$id}{con_file},
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "Layer Outflow File: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $props{$id}{qla_file},
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "Bathymetry File: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $props{$id}{bth_file},
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            if ($props{$id}{add_parm}) {
                $row++;
                $f->new_label(
                        -text => $props{$id}{src_type} . ": ",
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                $f->new_label(
                        -text => $props{$id}{src_file},
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            }
        }
    }
    Tkx::wm_resizable($object_infobox,0,0);
    &adjust_window_position($object_infobox);
    $object_infobox->g_focus;
}


sub edit_canvas_props {
    my ($X, $Y) = @_;
    my (
        $cc, $ch, $ch_minus_btn, $ch_scale, $code, $color_btn, $cw,
        $cw_minus_btn, $cw_scale, $geom, $gs, $f, $fg, $frame, $grid_scale,
        $minus_img, $plus_img, $row, $s2g, $sc, $sel_color_btn, $sh, $sw,
       );

    $cw  = $canvas_width;
    $ch  = $canvas_height;
    $s2g = $snap2grid;
    $gs  = $grid_spacing;
    $cc  = $canvas_color;
    $sc  = $text_select_color;
    if ($s2g) {
        $sw = &round_to_int(($screen_width  -$min_canvas_width) /$gs) *$gs +$min_canvas_width;
        $sh = &round_to_int(($screen_height -$min_canvas_height)/$gs) *$gs +$min_canvas_height;
    } else {
        $sw = $screen_width;
        $sh = $screen_height;
    }
    if (abs($max_canvas_width -$sw) <= $gs) {
        $max_canvas_width = &max($cw, $sw);
    } else {
        $max_canvas_width = &max($cw, $max_canvas_width, $sw);
    }
    if (abs($max_canvas_height -$sh) <= $gs) {
        $max_canvas_height = &max($ch, $sh);
    } else {
        $max_canvas_height = &max($ch, $max_canvas_height, $sh);
    }
    if ($X == 0) {
        (undef, $X, $Y) = split(/\+/, $main->g_wm_geometry());
        $X += 100;
        $Y += 100;
    }
    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($canvas_props_menu) && Tkx::winfo_exists($canvas_props_menu)) {
        if ($canvas_props_menu->g_wm_title() eq "Canvas Properties") {
            $canvas_props_menu->g_wm_deiconify();
            $canvas_props_menu->g_wm_geometry($geom);
            $canvas_props_menu->g_raise();
            $canvas_props_menu->g_focus;
            &adjust_window_position($canvas_props_menu);
            return;
        }
    }

    $canvas_props_menu = $main->new_toplevel();
    $canvas_props_menu->g_wm_transient($main);
    $canvas_props_menu->g_wm_title("Canvas Properties");
    $canvas_props_menu->configure(-cursor => $cursor_norm);
    $canvas_props_menu->g_wm_geometry($geom);

    $frame = $canvas_props_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    $frame->new_button(
            -text => "OK",
            -command => sub { &set_canvas_props($cw, $ch, $s2g, $gs, $cc, $sc, "OK") },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text => "Apply",
            -command => sub { &set_canvas_props($cw, $ch, $s2g, $gs, $cc, $sc, "Apply") },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text => "Cancel",
            -command => sub { $canvas_props_menu->g_destroy();
                              undef $canvas_props_menu; },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

    $f = $canvas_props_menu->new_frame(
            -borderwidth => 2,
            -relief => 'groove',
            );
    $f->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "Canvas Width: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'se', -pady => 2);
    ($cw_scale = $f->new_scale(
            -orient       => 'horizontal',
            -from         => $min_canvas_width,
            -to           => $max_canvas_width,
            -variable     => \$cw,
            -resolution   => 1,
            -width        => 10,
            -sliderlength => 20,
            -takefocus    => 1,
            -command      => sub { if (&max($cw, $sw) == $max_canvas_width) {
                                       $cw_minus_btn->configure(-state => 'disabled');
                                   } else {
                                       $cw_minus_btn->configure(-state => 'normal');
                                   }
                                 },
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $f->new_label(
            -text => "pixels",
            -font => 'default',
            )->g_grid(-row => $row, -column => 2, -sticky => 'sw', -padx => 2, -pady => 2);

    $plus_img  = Tkx::image_create_photo(-file => "${prog_path}images/plus.png");
    $minus_img = Tkx::image_create_photo(-file => "${prog_path}images/minus.png");
    $f->new_button(
            -repeatdelay    => 10000,
            -repeatinterval => 10000,
            -image   => $plus_img,
            -command => sub { $max_canvas_width += 200;
                              $cw_minus_btn->configure(-state => 'normal');
                              $cw_scale->configure(-to => $max_canvas_width);
                            },
            )->g_grid(-row => $row, -column => 3, -sticky => 'sw', -padx => 2, -pady => 2);
    ($cw_minus_btn = $f->new_button(
            -repeatdelay    => 10000,
            -repeatinterval => 10000,
            -image   => $minus_img,
            -state   => 'normal',
            -command => sub { $max_canvas_width = &max($cw, $max_canvas_width -200, $sw);
                              if ($max_canvas_width == $sw || $max_canvas_width == $cw) {
                                  $cw_minus_btn->configure(-state => 'disabled');
                              }
                              $cw_scale->configure(-to => $max_canvas_width);
                            },
            ))->g_grid(-row => $row, -column => 4, -sticky => 'sw', -padx => 2, -pady => 2);
    if (&max($cw, $sw) == $max_canvas_width) {
        $cw_minus_btn->configure(-state => 'disabled');
    }

    $row++;
    $f->new_label(
            -text => "Canvas Height: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'se', -pady => 2);
    ($ch_scale = $f->new_scale(
            -orient       => 'horizontal',
            -from         => $min_canvas_height,
            -to           => $max_canvas_height,
            -variable     => \$ch,
            -resolution   => 1,
            -width        => 10,
            -sliderlength => 20,
            -takefocus    => 1,
            -command      => sub { if (&max($ch, $sh) == $max_canvas_height) {
                                       $ch_minus_btn->configure(-state => 'disabled');
                                   } else {
                                       $ch_minus_btn->configure(-state => 'normal');
                                   }
                                 },
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $f->new_label(
            -text => "pixels",
            -font => 'default',
            )->g_grid(-row => $row, -column => 2, -sticky => 'sw', -padx => 2, -pady => 2);
    $f->new_button(
            -repeatdelay    => 10000,
            -repeatinterval => 10000,
            -image   => $plus_img,
            -command => sub { $max_canvas_height += 200;
                              $ch_minus_btn->configure(-state => 'normal');
                              $ch_scale->configure(-to => $max_canvas_height);
                            },
            )->g_grid(-row => $row, -column => 3, -sticky => 'sw', -padx => 2, -pady => 2);
    ($ch_minus_btn = $f->new_button(
            -repeatdelay    => 10000,
            -repeatinterval => 10000,
            -image   => $minus_img,
            -state   => 'normal',
            -command => sub { $max_canvas_height = &max($ch, $max_canvas_height -200, $sh);
                              if ($max_canvas_height == $sh || $max_canvas_height == $ch) {
                                  $ch_minus_btn->configure(-state => 'disabled');
                              }
                              $ch_scale->configure(-to => $max_canvas_height);
                            },
            ))->g_grid(-row => $row, -column => 4, -sticky => 'sw', -padx => 2, -pady => 2);
    if (&max($ch, $sh) == $max_canvas_height) {
        $ch_minus_btn->configure(-state => 'disabled');
    }

    $row++;
    ($grid_scale = $f->new_scale(
            -orient       => 'horizontal',
            -from         => $grid_spacing_min,
            -to           => $grid_spacing_max,
            -variable     => \$gs,
            -width        => 10,
            -sliderlength => 20,
            -takefocus    => 1,
            -command      => sub { $sw = &round_to_int(($screen_width -$min_canvas_width) /$gs) *$gs
                                         +$min_canvas_width;
                                   $sh = &round_to_int(($screen_height -$min_canvas_height)/$gs) *$gs
                                         +$min_canvas_height;
                                   if (abs($max_canvas_width -$sw) <= $gs) {
                                       $max_canvas_width = &max($cw, $sw);
                                   } else {
                                       $max_canvas_width = &max($cw, $max_canvas_width, $sw);
                                   }
                                   if (abs($max_canvas_height -$sh) <= $gs) {
                                       $max_canvas_height = &max($ch, $sh);
                                   } else {
                                       $max_canvas_height = &max($ch, $max_canvas_height, $sh);
                                   }
                                   $cw_scale->configure(-to         => $max_canvas_width,
                                                        -resolution => $gs);
                                   $ch_scale->configure(-to         => $max_canvas_height,
                                                        -resolution => $gs);
                                   if (&max($ch, $sh) == $max_canvas_height) {
                                       $ch_minus_btn->configure(-state => 'disabled');
                                   } else {
                                       $ch_minus_btn->configure(-state => 'normal');
                                   }
                                   if (&max($cw, $sw) == $max_canvas_width) {
                                       $cw_minus_btn->configure(-state => 'disabled');
                                   } else {
                                       $cw_minus_btn->configure(-state => 'normal');
                                   }
                                 },
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $f->new_checkbutton(
            -onvalue  => 1,
            -offvalue => 0,
            -text     => "Snap to Grid: ",
            -font     => 'default',
            -variable => \$s2g,
            -command  => sub { if ($s2g) {
                                   $sw = &round_to_int(($screen_width -$min_canvas_width) /$gs) *$gs
                                         +$min_canvas_width;
                                   $sh = &round_to_int(($screen_height -$min_canvas_height)/$gs) *$gs
                                         +$min_canvas_height;
                               } else {
                                   $sw = $screen_width;
                                   $sh = $screen_height;
                               }
                               if (abs($max_canvas_width -$sw) <= $gs) {
                                   $max_canvas_width = &max($cw, $sw);
                               } else {
                                   $max_canvas_width = &max($cw, $max_canvas_width, $sw);
                               }
                               if (abs($max_canvas_height -$sh) <= $gs) {
                                   $max_canvas_height = &max($ch, $sh);
                               } else {
                                   $max_canvas_height = &max($ch, $max_canvas_height, $sh);
                               }
                               if ($s2g) {
                                   $grid_scale->configure(-state => 'normal');
                                   $cw_scale->configure(-to         => $max_canvas_width,
                                                        -resolution => $gs);
                                   $ch_scale->configure(-to         => $max_canvas_height,
                                                        -resolution => $gs);
                               } else {
                                   $grid_scale->configure(-state => 'disabled');
                                   $cw_scale->configure(-to         => $max_canvas_width,
                                                        -resolution => 1);
                                   $ch_scale->configure(-to         => $max_canvas_height,
                                                        -resolution => 1);
                               }
                               if (&max($ch, $sh) == $max_canvas_height) {
                                   $ch_minus_btn->configure(-state => 'disabled');
                               } else {
                                   $ch_minus_btn->configure(-state => 'normal');
                               }
                               if (&max($cw, $sw) == $max_canvas_width) {
                                   $cw_minus_btn->configure(-state => 'disabled');
                               } else {
                                   $cw_minus_btn->configure(-state => 'normal');
                               }
                             }
            )->g_grid(-row => $row, -column => 0, -sticky => 'se', -pady => 2);
    $f->new_label(
            -text => "pixels",
            -font => 'default',
            )->g_grid(-row => $row, -column => 2, -sticky => 'sw', -padx => 2, -pady => 2);
    if ($s2g) {
        $grid_scale->configure(-state => 'normal');
        $cw_scale->configure(-resolution => $gs);
        $ch_scale->configure(-resolution => $gs);
    } else {
        $grid_scale->configure(-state => 'disabled');
        $cw_scale->configure(-resolution => 1);
        $ch_scale->configure(-resolution => 1);
    }

    $row++;
    $f->new_label(
            -text => "Canvas Background Color: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);

    $code = &get_rgb_code($cc);
    $cc   = &get_rgb_name($code);
    $fg   = &get_rgb_code("black");
    if ($code =~ /^\#[0-9a-f]/i) {
        $fg = &get_rgb_code(&get_bw_contrast($code));
    }
    $color_btn = $f->new_button(
            -textvariable => \$cc,
            -background   => $code,
            -foreground   => $fg,
            -width        => -7,
            -command => sub {
                          my ($newc, $code, $fg);
                          $code = &get_rgb_code($cc);
                          $newc = Tkx::tk___chooseColor(
                                     -initialcolor => $code,
                                     -parent       => $canvas_props_menu);
                          if ($newc) {
                            $code = &get_rgb_code($newc);
                            $cc   = &get_rgb_name($code);
                            $fg   = &get_rgb_code("black");
                            if ($code =~ /^#?[0-9a-f]/i) {
                                $fg = &get_rgb_code(&get_bw_contrast($code));
                            }
                            $color_btn->configure(-foreground => $fg,
                                                  -background => $code);
                          }
                        }
            );
    $color_btn->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Text Selection Color: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);

    $code = &get_rgb_code($sc);
    $sc   = &get_rgb_name($code);
    $fg   = &get_rgb_code("black");
    if ($code =~ /^\#[0-9a-f]/i) {
        $fg = &get_rgb_code(&get_bw_contrast($code));
    }
    $sel_color_btn = $f->new_button(
            -textvariable => \$sc,
            -background   => $code,
            -foreground   => $fg,
            -width        => -7,
            -command => sub {
                          my ($newc, $code, $fg);
                          $code = &get_rgb_code($sc);
                          $newc = Tkx::tk___chooseColor(
                                     -initialcolor => $code,
                                     -parent       => $canvas_props_menu);
                          if ($newc) {
                            $code = &get_rgb_code($newc);
                            $sc   = &get_rgb_name($code);
                            $fg   = &get_rgb_code("black");
                            if ($code =~ /^\#[0-9a-f]/i) {
                                $fg = &get_rgb_code(&get_bw_contrast($code));
                            }
                            $sel_color_btn->configure(-foreground => $fg,
                                                      -background => $code);
                          }
                        }
            );
    $sel_color_btn->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);

    Tkx::wm_resizable($canvas_props_menu,0,0);
    &adjust_window_position($canvas_props_menu);
    $canvas_props_menu->g_focus;
}


sub set_canvas_props {
    my ($cw, $ch, $s2g, $gs, $cc, $sc, $action) = @_;

    if ($cc ne $canvas_color) {
        $canvas->configure(-background => &get_rgb_code($cc));
        $canvas_color = $cc;
    }
    if ($cw != $canvas_width || $ch != $canvas_height) {
        $canvas->configure(-width        => $cw,
                           -height       => $ch,
                           -scrollregion => [0, 0, $cw, $ch],
                          );
        $canvas_width  = $cw;
        $canvas_height = $ch;
        &initialize_canvas_scrollbars();
        &adjust_main_position();
    }
    $snap2grid         = $s2g;
    $grid_spacing      = &min(&max($grid_spacing_min, $gs), $grid_spacing_max);
    $text_select_color = $sc;
    if ($action eq "OK") {
        $canvas_props_menu->g_destroy();
        undef $canvas_props_menu;
    }
}


sub edit_defaults {
    my ($X, $Y, $tabid) = @_;
    my (
        $ahd1, $ahd2, $ahd3, $angle, $angle_cb, $arrow, $arrow_frame,
        $arrow_opt, $arrow_tab, $code, $color, $f, $family, $family_cb,
        $fc_btn, $fcolor, $fg, $fg_btn, $fill, $fill_opt, $frame, $geom,
        $notebook, $object_frame, $object_tab, $ph, $pid_arrow, $pid_obj,
        $pid_txt, $preview_arrow, $preview_obj, $preview_txt, $pw, $row,
        $size, $size_cb, $slant, $slant_cb, $slant_opt, $smooth, $smooth_opt,
        $text_frame, $text_tab, $under, $under_cb, $under_opt, $weight,
        $weight_cb, $width,
       );

    $family = $default_family;
    $size   = $default_size;
    $weight = $default_weight;
    $slant  = $default_slant;
    $under  = $default_underline;
    $angle  = $default_angle;
    $width  = $default_width;
    $color  = $default_color;
    $fill   = $default_fill;
    $fcolor = $default_fillcolor;
    $arrow  = $default_arrow;
    $ahd1   = $default_ahd1;
    $ahd2   = $default_ahd2;
    $ahd3   = $default_ahd3;
    $smooth = $default_smooth;

    if ($X == 0) {
        (undef, $X, $Y) = split(/\+/, $main->g_wm_geometry());
        $X += 100;
        $Y += 100;
    }
    $geom       = sprintf("+%d+%d", $X, $Y);
    $slant_opt  = $slant_options[$slant];
    $under_opt  = ("no", "yes")[$under];
    $fill_opt   = ("no", "yes")[$fill];
    $smooth_opt = $smooth_options[$smooth];
    $arrow_opt  = $arrow_options[$arrow];

    if (defined($default_props_menu) && Tkx::winfo_exists($default_props_menu)) {
        if ($default_props_menu->g_wm_title() eq "Set Defaults") {
            $default_props_menu->g_wm_deiconify();
            $default_props_menu->g_wm_geometry($geom);
            $default_props_menu->g_raise();
            $default_props_menu->g_focus;
            &adjust_window_position($default_props_menu);
            return;
        }
    }

    $default_props_menu = $main->new_toplevel();
    $default_props_menu->g_wm_transient($main);
    $default_props_menu->g_wm_title("Set Defaults");
    $default_props_menu->configure(-cursor => $cursor_norm);
    $default_props_menu->g_wm_geometry($geom);

    $frame = $default_props_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    $frame->new_button(
            -text    => "OK",
            -command => sub { &set_defaults($family, $size, $weight,
                                $slant, $under, $angle, $width, $color, $smooth,
                                $fill, $fcolor, $arrow, $ahd1, $ahd2, $ahd3,
                                "OK") },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Apply",
            -command => sub { &set_defaults($family, $size, $weight,
                                $slant, $under, $angle, $width, $color, $smooth,
                                $fill, $fcolor, $arrow, $ahd1, $ahd2, $ahd3,
                                "Apply") },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Restore",
            -command => sub { my $tabid = $notebook->index('current');
                              my $geom  = $default_props_menu->g_wm_geometry();
                              (undef, $X, $Y) = split(/\+/, $geom);
                              &set_defaults($family, $size, $weight,
                                $slant, $under, $angle, $width, $color, $smooth,
                                $fill, $fcolor, $arrow, $ahd1, $ahd2, $ahd3,
                                "Restore", $X, $Y, $tabid) },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $default_props_menu->g_destroy();
                              undef $default_props_menu; },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

    $f = $default_props_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f->g_pack(-side => 'top');

#   Create tabbed notebook
    $notebook = $f->new_ttk__notebook();
    $notebook->g_pack();

#   Text tab
    $text_tab = $notebook->new_frame();
    $notebook->add($text_tab,
            -text      => "Text",
            -underline => 0,
            -sticky    => 'nsew',
            );

    $row = 0;
    $pw  = 270;
    $ph  = 45;
    $preview_txt = $text_tab->new_canvas(
            -background  => &get_rgb_code($canvas_color),
            -width       => $pw,
            -height      => $ph,
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $preview_txt->g_grid(-row => 0, -column => 0, -sticky => 'wne');

    $pid_txt = $preview_txt->create_text($pw*0.5 +3, $ph*0.5 +3,
            -anchor => 'center', 
            -text   => "Default text",
            -fill   => &get_rgb_code($color),
            -angle  => $angle,
            -font   => [-family     => $family,
                        -size       => $size,
                        -weight     => $weight,
                        -slant      => $slant_type[$slant],
                        -underline  => $under,
                        -overstrike => 0,
                       ]);

    $text_frame = $text_tab->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $text_frame->g_grid(-row => 1, -column => 0, -sticky => 'wnes');

    $text_frame->new_label(
            -text => "Default Font Family: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($family_cb = $text_frame->new_ttk__combobox(
            -textvariable => \$family,
            -values       => [ sort @available_fonts ],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $family_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_txt->itemconfigure($pid_txt,
                          -font => [ -family     => $family,
                                     -size       => $size,
                                     -weight     => $weight,
                                     -slant      => $slant_type[$slant],
                                     -underline  => $under,
                                     -overstrike => 0,
                                   ]);
                  });

    $row++;
    $text_frame->new_label(
            -text => "Default Font Size: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($size_cb = $text_frame->new_ttk__combobox(
            -textvariable => \$size,
            -values       => [(5 .. 32)],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $size_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_txt->itemconfigure($pid_txt,
                          -font => [ -family     => $family,
                                     -size       => $size,
                                     -weight     => $weight,
                                     -slant      => $slant_type[$slant],
                                     -underline  => $under,
                                     -overstrike => 0,
                                   ]);
                  });

    $row++;
    $text_frame->new_label(
            -text => "Default Font Weight: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($weight_cb = $text_frame->new_ttk__combobox(
            -textvariable => \$weight,
            -values       => [("normal", "bold")],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $weight_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_txt->itemconfigure($pid_txt,
                          -font => [ -family     => $family,
                                     -size       => $size,
                                     -weight     => $weight,
                                     -slant      => $slant_type[$slant],
                                     -underline  => $under,
                                     -overstrike => 0,
                                   ]);
                  });

    $row++;
    $text_frame->new_label(
            -text => "Default Font Slant: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($slant_cb = $text_frame->new_ttk__combobox(
            -textvariable => \$slant_opt,
            -values       => [ @slant_options ],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $slant_cb->g_bind("<<ComboboxSelected>>",
              sub { my $s = &list_match($slant_opt, @slant_options);
                    return if ($s < 0);
                    $slant = $s;
                    $preview_txt->itemconfigure($pid_txt,
                          -font => [ -family     => $family,
                                     -size       => $size,
                                     -weight     => $weight,
                                     -slant      => $slant_type[$slant],
                                     -underline  => $under,
                                     -overstrike => 0,
                                   ]);
                  });

    $row++;
    $text_frame->new_label(
            -text => "Default Font Underline: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($under_cb = $text_frame->new_ttk__combobox(
            -textvariable => \$under_opt,
            -values       => [("no", "yes")],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $under_cb->g_bind("<<ComboboxSelected>>",
              sub { my $u = &list_match($under_opt, ("no", "yes"));
                    return if ($u < 0);
                    $under = $u;
                    $preview_txt->itemconfigure($pid_txt,
                          -font => [ -family     => $family,
                                     -size       => $size,
                                     -weight     => $weight,
                                     -slant      => $slant_type[$slant],
                                     -underline  => $under,
                                     -overstrike => 0,
                                   ])
                  });

    $row++;
    $text_frame->new_label(
            -text => "Default Text Angle: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($angle_cb = $text_frame->new_ttk__combobox(
            -textvariable => \$angle,
            -values       => [(0 .. 359)],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $angle_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_txt->itemconfigure($pid_txt,
                          -text  => "Default text",
                          -angle => $angle);
                  });

#   Object tab
    $object_tab = $notebook->new_frame();
    $notebook->add($object_tab,
            -text      => "Objects",
            -underline => 0,
            -sticky    => 'nsew',
            );

    $row = 0;
    $preview_obj = $object_tab->new_canvas(
            -background  => &get_rgb_code($canvas_color),
            -width       => $pw,
            -height      => $ph,
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $preview_obj->g_grid(-row => 0, -column => 0, -sticky => 'wne');

    $pid_obj = $preview_obj->create_polygon($pw*0.2 + 3, $ph*0.2 + 3,
                                            $pw*0.8 + 3, $ph*0.2 + 3,
                                            $pw*0.8 + 3, $ph*0.8 + 3,
                                            $pw*0.2 + 3, $ph*0.8 + 3,
                 -outline => &get_rgb_code($color),
                 -smooth  => $smooth_type[$smooth],
                 -width   => $width);
    if ($fill) {
        $preview_obj->itemconfigure($pid_obj, -fill => &get_rgb_code($fcolor));
    } else {
        $preview_obj->itemconfigure($pid_obj, -fill => "");
    }

    $object_frame = $object_tab->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $object_frame->g_grid(-row => 1, -column => 0, -sticky => 'wnes');

    $object_frame->new_label(
            -text => "Default Object Width: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    &native_optionmenu(
            $object_frame, 
            \$width,
            $width - 1,
            [ sub { $preview_obj->itemconfigure($pid_obj, -width => $width);
                    $preview_arrow->itemconfigure($pid_arrow, -width => $width);
                  } ],
            (1 .. 10),
            )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    $row++;
    $object_frame->new_label(
            -text => "Default Color: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);

    $code  = &get_rgb_code($color);
    $color = &get_rgb_name($code);
    $fg    = &get_rgb_code("black");
    if ($code =~ /^\#[0-9a-f]/i) {
        $fg = &get_rgb_code(&get_bw_contrast($code));
    }
    $fg_btn = $object_frame->new_button(
            -textvariable => \$color,
            -background   => $code,
            -foreground   => $fg,
            -command => sub {
                          my ($newc, $code, $fg);
                          $code = &get_rgb_code($color);
                          $newc = Tkx::tk___chooseColor(
                                     -initialcolor => $code,
                                     -parent       => $default_props_menu);
                          if ($newc) {
                            $code  = &get_rgb_code($newc);
                            $color = &get_rgb_name($code);
                            $fg    = &get_rgb_code("black");
                            if ($code =~ /^\#[0-9a-f]/i) {
                                $fg = &get_rgb_code(&get_bw_contrast($code));
                            }
                            $fg_btn->configure(-foreground => $fg,
                                               -background => $code);
                            $preview_txt->itemconfigure($pid_txt,
                                               -fill => $code);
                            $preview_obj->itemconfigure($pid_obj,
                                               -outline => $code);
                            $preview_arrow->itemconfigure($pid_arrow,
                                               -fill => $code);
                          }
                        }
            );
    $fg_btn->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);

    $row++;
    $object_frame->new_label(
            -text => "Default Corners: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    &native_optionmenu(
            $object_frame, 
            \$smooth_opt,
            $smooth,
            [ sub { my $s = &list_match($smooth_opt, @smooth_options);
                    return if ($s < 0);
                    $smooth = $s;
                    $preview_obj->itemconfigure($pid_obj,
                                     -smooth => $smooth_type[$smooth]);
                  } ],
            @smooth_options,
            )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    $row++;
    $object_frame->new_label(
            -text => "Default Fill: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    &native_optionmenu(
            $object_frame, 
            \$fill_opt,
            $fill,
            [ sub { my $f = &list_match($fill_opt, ("no", "yes"));
                    return if ($f < 0);
                    $fill = $f;
                    if ($fill) {
                        $preview_obj->itemconfigure($pid_obj, -fill => &get_rgb_code($fcolor));
                        $fc_btn->configure(-state => 'normal');
                    } else {
                        $preview_obj->itemconfigure($pid_obj, -fill => "");
                        $fc_btn->configure(-state => 'disabled');
                    }
                  } ],
            ("no", "yes"),
            )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    $row++;
    $object_frame->new_label(
            -text => "Default Fill Color: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);

    $code   = &get_rgb_code($fcolor);
    $fcolor = &get_rgb_name($code);
    $fg     = &get_rgb_code("black");
    if ($code =~ /^\#[0-9a-f]/i) {
        $fg = &get_rgb_code(&get_bw_contrast($code));
    }
    $fc_btn = $object_frame->new_button(
            -textvariable => \$fcolor,
            -background   => $code,
            -foreground   => $fg,
            -command => sub {
                          my ($newc, $code, $fg);
                          $code = &get_rgb_code($fcolor);
                          $newc = Tkx::tk___chooseColor(
                                     -initialcolor => $code,
                                     -parent       => $default_props_menu);
                          if ($newc) {
                            $code   = &get_rgb_code($newc);
                            $fcolor = &get_rgb_name($code);
                            $fg     = &get_rgb_code("black");
                            if ($code =~ /^\#[0-9a-f]/i) {
                                $fg = &get_rgb_code(&get_bw_contrast($code));
                            }
                            $fc_btn->configure(-foreground => $fg,
                                               -background => $code);
                            if ($fill) {
                                $preview_obj->itemconfigure($pid_obj,
                                               -fill => $code);
                            }
                          }
                        }
            );
    $fc_btn->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
    if ($fill) {
        $fc_btn->configure(-state => 'normal');
    } else {
        $fc_btn->configure(-state => 'disabled');
    }

#   Arrowhead tab
    $arrow_tab = $notebook->new_frame();
    $notebook->add($arrow_tab,
            -text      => "Arrowheads",
            -underline => 0,
            -sticky    => 'nsew',
            );

    $row = 0;
    $preview_arrow = $arrow_tab->new_canvas(
            -background  => &get_rgb_code($canvas_color),
            -width       => $pw,
            -height      => $ph,
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $preview_arrow->g_grid(-row => 0, -column => 0, -sticky => 'wne');

    $pid_arrow = $preview_arrow->create_line($pw*0.2 + 3, $ph*0.5 + 3,
                                             $pw*0.8 + 3, $ph*0.5 + 3,
                 -fill  => &get_rgb_code($color),
                 -width => $width,
                 -arrow => $arrow_type[$arrow],
            -arrowshape => [ $ahd1, $ahd2, $ahd3 ]);

    $arrow_frame = $arrow_tab->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $arrow_frame->g_grid(-row => 1, -column => 0, -sticky => 'wnes');

    $arrow_frame->new_label(
            -text => "Default Arrowhead: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    &native_optionmenu(
            $arrow_frame, 
            \$arrow_opt,
            $arrow,
            [ sub { my $a = &list_match($arrow_opt, @arrow_options);
                    if ($a >= 0) {
                        $arrow = $a;
                        $preview_arrow->itemconfigure($pid_arrow,
                                             -arrow => $arrow_type[$arrow]);
                    }
                  } ],
            @arrow_options,
            )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    $row++;
    $arrow_frame->new_label(
            -text    => "Arrowhead  \nCenter Length: ",
            -justify => 'right',
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'se', -pady => 2);
    $arrow_frame->new_scale(
            -orient   => 'horizontal',
            -from     => 6,
            -to       => 100,
            -variable => \$ahd1,
            -width    => 10,
            -length   => 150,
            -sliderlength => 20,
            -takefocus    => 1,
            -command  => sub { $preview_arrow->itemconfigure($pid_arrow,
                                      -arrowshape => [ $ahd1, $ahd2, $ahd3 ]);
                             },
            )->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);

    $row++;
    $arrow_frame->new_label(
            -text    => "Arrowhead  \nSide Length: ",
            -justify => 'right',
            -font    => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'se', -pady => 2);
    $arrow_frame->new_scale(
            -orient   => 'horizontal',
            -from     => 10,
            -to       => 100,
            -variable => \$ahd2,
            -width    => 10,
            -sliderlength => 20,
            -takefocus    => 1,
            -command  => sub { $preview_arrow->itemconfigure($pid_arrow,
                                      -arrowshape => [ $ahd1, $ahd2, $ahd3 ]);
                             },
            )->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);

    $row++;
    $arrow_frame->new_label(
            -text    => "Arrowhead  \nHalf Width: ",
            -justify => 'right',
            -font    => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'se', -pady => 2);
    $arrow_frame->new_scale(
            -orient   => 'horizontal',
            -from     => 3,
            -to       => 40,
            -variable => \$ahd3,
            -width    => 10,
            -sliderlength => 20,
            -takefocus    => 1,
            -command  => sub { $preview_arrow->itemconfigure($pid_arrow,
                                      -arrowshape => [ $ahd1, $ahd2, $ahd3 ]);
                             },
            )->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);

    Tkx::ttk__notebook__enableTraversal($notebook);
    $notebook->select($tabid);
    Tkx::wm_resizable($default_props_menu,0,0);
    &adjust_window_position($default_props_menu);
    $default_props_menu->g_focus;
}


sub set_defaults {
    my ($fam, $siz, $wei, $sla, $und, $ang, $wid, $col, $smo, $fill, $fcol,
        $arr, $ahd1, $ahd2, $ahd3, $action, $X, $Y, $tabid) = @_;

    if ($action eq "Restore") {
        $default_family    = $save_family;
        $default_size      = $save_size;
        $default_weight    = $save_weight;
        $default_slant     = $save_slant;
        $default_underline = $save_underline;
        $default_angle     = $save_angle;
        $default_width     = $save_width;
        $default_color     = $save_color;
        $default_smooth    = $save_smooth;
        $default_fill      = $save_fill;
        $default_fillcolor = $save_fillcolor;
        $default_arrow     = $save_arrow;
        $default_ahd1      = $save_ahd1;
        $default_ahd2      = $save_ahd2;
        $default_ahd3      = $save_ahd3;
    } else {
        $default_family    = $fam;
        $default_size      = $siz;
        $default_weight    = $wei;
        $default_slant     = $sla;
        $default_underline = $und;
        $default_angle     = $ang;
        $default_width     = $wid;
        $default_color     = $col;
        $default_smooth    = $smo;
        $default_fill      = $fill;
        $default_fillcolor = $fcol;
        $default_arrow     = $arr;
        $default_ahd1      = $ahd1;
        $default_ahd2      = $ahd2;
        $default_ahd3      = $ahd3;
    }

    if ($action eq "OK" || $action eq "Restore") {
        $default_props_menu->g_destroy();
        undef $default_props_menu;
    }
    if ($action eq "Restore") {
        &edit_defaults($X, $Y, $tabid);
    }
}


################################################################################
#
# Specialized graphics
#
################################################################################

sub setup_w2_profile {
    my ($canv, $id) = @_;
    my (
        $bth_file, $bth_file_btn, $byear, $byear_cb, $con_file, $conv_add,
        $conv_add_entry, $conv_mult, $conv_mult_entry, $conv_type,
        $conv_type_cb, $conv_type_na_label, $cscheme, $cscheme_cb,
        $custom_frame, $elev_base, $f, $frame, $ftype, $geom, $gtitle, $i,
        $jb, $jd_skip, $jd_skip_active, $jd_skip_explain, $jd_skip_frame,
        $jd_skip_label, $jjw, $jw, $lcon_freq, $meta, $n, $nbr, $ncolors,
        $ncolors_cb, $ncolors_na_label, $new_graph, $nwb, $offset_frame, $ok,
        $ok_btn, $old_units, $oldparm, $oldparm_short, $oldsrc_type, $parm,
        $parm_cb, $parm_chars, $parm_div, $parm_div_cb, $parm_div_label,
        $parm_frame, $parm_short, $parms_ref, $row, $segnum, $segnum_cb,
        $segs_ref, $segwidth, $src_file, $src_file_btn, $src_file_label,
        $src_lines, $src_parm, $src_type, $src_type_cb, $tecplot, $title,
        $tmp_id, $tz_offset, $units, $units_cb, $units_entry, $wb_input_cb,
        $wb_input_label, $wb_txt, $X, $x1, $x2, $xmajor, $xmajor_entry,
        $xmax, $xmax_entry, $xmin, $xmin_entry, $Y, $y1, $y2, $yaxis_type,
        $yaxis_type_cb, $yaxis_units, $yaxis_units_label, $ymajor,
        $ymajor_entry, $ymajor_label, $ymax, $ymax_entry, $ymax_label,
        $ymin, $ymin_entry, $ymin_label, $ymin_units_label, $yr_max, $yr_min,

        @bs, @be, @cmaps, @cplf, @ds, @jbdn, @jd_skip_opts, @ncpl, @nspr,
        @nvpl, @parm_divlist, @parmlist, @segs, @slope, @sprf, @us, @vplf,
       );

    ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $geom = sprintf("+%d+%d", $X+$x1+30, $Y+$y1+50);

    if (defined($w2profile_setup_menu) && Tkx::winfo_exists($w2profile_setup_menu)) {
        if ($w2profile_setup_menu->g_wm_title() eq "W2 Profile Setup") {
            $w2profile_setup_menu->g_destroy();
            undef $w2profile_setup_menu;
        }
    }
    $w2profile_setup_menu = $main->new_toplevel();
    $w2profile_setup_menu->g_wm_transient($main);
    $w2profile_setup_menu->g_wm_title("W2 Profile Setup");
    $w2profile_setup_menu->configure(-cursor => $cursor_norm);
    $w2profile_setup_menu->g_wm_geometry($geom);

#   Try to keep the nascent graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

#   Retrieve parameter values if this graph already exists.
    $new_graph = (defined($props{$id}{oldcoords})) ? 0 : 1;
    if (! $new_graph) {
        &end_select($canv, $id, 1);

        $nwb   = $grid{$id}{nwb};
        $nbr   = $grid{$id}{nbr};
        @bs    = @{ $grid{$id}{bs}    };
        @be    = @{ $grid{$id}{be}    };
        @us    = @{ $grid{$id}{us}    };
        @ds    = @{ $grid{$id}{ds}    };
        @jbdn  = @{ $grid{$id}{jbdn}  };
        @slope = @{ $grid{$id}{slope} };
        @nspr  = @{ $grid{$id}{nspr}  };
        @sprf  = @{ $grid{$id}{sprf}  };
        @ncpl  = @{ $grid{$id}{ncpl}  };
        @cplf  = @{ $grid{$id}{cplf}  };
        @nvpl  = @{ $grid{$id}{nvpl}  };
        @vplf  = @{ $grid{$id}{vplf}  };

        $con_file    = $props{$id}{con_file};
        $src_type    = $props{$id}{src_type};
        $src_file    = $props{$id}{src_file};
        $src_lines   = $props{$id}{src_lines};
        $bth_file    = $props{$id}{bth_file};
        $parm        = $props{$id}{parm};
        $parm_div    = $props{$id}{parm_div};
        $units       = $props{$id}{parm_units};
        $conv_type   = $props{$id}{ctype};
        $segnum      = $props{$id}{seg};
        $byear       = $props{$id}{byear};
        $tz_offset   = $props{$id}{tz_offset};
        $jd_skip     = $props{$id}{jd_skip};

        $yaxis_type  = $gr_props{$id}{ytype};
        $yaxis_units = $gr_props{$id}{yunits};
        $ymin        = $gr_props{$id}{ymin};
        $ymax        = $gr_props{$id}{ymax};
        $ymajor      = $gr_props{$id}{ymajor};
        $gtitle      = $gr_props{$id}{gtitle};
        $ncolors     = $gr_props{$id}{ncolors};
        $elev_base   = &min($ymin, $ymax);

        if ($props{$id}{meta} eq "w2_profile_cmap") {
            $xmin   = $gr_props{$id}{cs_min};
            $xmax   = $gr_props{$id}{cs_max};
            $title  = $gr_props{$id}{keytitle};
        } else {
            $xmin   = $gr_props{$id}{xmin};
            $xmax   = $gr_props{$id}{xmax};
            $xmajor = $gr_props{$id}{xmajor};
            $title  = $gr_props{$id}{xtitle};
        }
        if ($gr_props{$id}{add_cs}) {
            if ($gr_props{$id}{cscheme1} =~ /CoolWarm|Turbo|Viridis/) {
                $cscheme  = $gr_props{$id}{cscheme1};
                $ncolors  = &max(8, &min(100, $ncolors));
            } elsif ($gr_props{$id}{cscheme1} eq "Blue" && $gr_props{$id}{cscheme2} eq "Orange") {
                $cscheme  = "Blue to Orange";
                $ncolors *= 2;
                $ncolors  = &max(16, &min(46, $ncolors));
                foreach $n (reverse @valid_nc) {
                    if ($ncolors >= 2 *$n) {
                        $ncolors = 2 *$n;
                        last;
                    }
                }
            } elsif ($gr_props{$id}{cscheme1} eq "Blue" && $gr_props{$id}{cscheme2} eq "Red") {
                $cscheme  = "Blue to Red";
                $ncolors *= 2;
                $ncolors  = &max(16, &min(46, $ncolors));
                foreach $n (reverse @valid_nc) {
                    if ($ncolors >= 2 *$n) {
                        $ncolors = 2 *$n;
                        last;
                    }
                }
            } else {
                $cscheme = "Blue to Orange";
                $ncolors = 20;
            }
        } else {
            $cscheme = "None";
            $ncolors = 20;
        }
        if ($conv_type =~ /Custom/) {
            ($conv_type, $conv_mult, $conv_add) = split(/,/, $conv_type);
        } else {
            $conv_mult = 1.0;
            $conv_add  = 0.0;
        }

        if ($src_type =~ /Spreadsheet/i) {
            ($ok, undef, $segs_ref, $parms_ref)
                      = &scan_w2_spr_file($w2profile_setup_menu, $src_file, "");
            if ($ok ne "okay") {
                return &pop_up_error($w2profile_setup_menu,
                                     "The specified file is not a W2 Spreadsheet file:\n$src_file");
            }
            @parmlist = @{ $parms_ref };
            @segs     = @{ $segs_ref  };
            $segnum   = $segs[$#segs] if ($segnum eq "" || &list_match($segnum, @segs) == -1);

        } elsif ($src_type =~ /Contour/i) {
            ($tecplot, undef, $jw, $parms_ref, undef, undef)
                  = &scan_w2_cpl_file($w2profile_setup_menu, $src_file, $id, 0, "");
            if ($tecplot == -1) {
                return &pop_up_error($w2profile_setup_menu,
                                     "The specified file is not a W2 Contour file:\n$src_file");
            }
            if ($tecplot == 1 && $jw == 0) {   # Tecplot-type file; waterbody index unknown
                for ($jjw=1; $jjw<=$nwb; $jjw++) {
                    if ($segnum >= $us[$bs[$jjw]] && $segnum <= $ds[$be[$jjw]]) {
                        $jw = $jjw;
                        last;
                    }
                }
            }
            @segs = ();
            for ($jb=$bs[$jw]; $jb<=$be[$jw]; $jb++) {
                push (@segs, ($us[$jb] .. $ds[$jb]));
            }
            $segnum   = $ds[$jbdn[$jw]] if ($segnum eq "" || &list_match($segnum, @segs) == -1);
            @parmlist = @{ $parms_ref };

        } elsif ($src_type =~ /Vector/i) {
            ($ok, $parms_ref, undef, undef, undef)
                      = &scan_w2_vector_file($w2profile_setup_menu, $src_file, $id, 0);
            if ($ok ne "okay") {
                return &pop_up_error($w2profile_setup_menu,
                                     "The specified file is not a W2 Vector (w2l) file:\n$src_file");
            }
            @segs = ();
            for ($jb=1; $jb<=$nbr; $jb++) {
                push (@segs, ($us[$jb] .. $ds[$jb]));
            }
            $segnum   = $ds[$jbdn[1]] if ($segnum eq "" || &list_match($segnum, @segs) == -1);
            @parmlist = @{ $parms_ref };

        } elsif ($src_type =~ /LakeCon/i) {
            ($ftype, $src_parm, $meta, undef) = &scan_w2_rlcon_file($w2profile_setup_menu, $src_file, "");
            if ($ftype ne "lcon1") {
                return &pop_up_error($w2profile_setup_menu,
                                     "The specified file is not an acceptable\n"
                                   . "W2 Lake Contour (format 1) file:\n$src_file");
            }
            ($segnum, $lcon_freq) = split(/_/, $meta);
            @segs     = ($segnum);
            @parmlist = ($src_parm);
        }
        @segs     = sort numerically @segs;
        $segwidth = &max(5, length(&max(@segs)));
        $wb_txt   = "";
        for ($jw=1; $jw<=$nwb; $jw++) {
            for ($jb=$bs[$jw]; $jb<=$be[$jw]; $jb++) {
                if ($segnum >= $us[$jb] && $segnum <= $ds[$jb]) {
                    $wb_txt = " (waterbody $jw, branch $jb)";
                    last;
                }
            }
            last if ($wb_txt ne "");
        }
        $parm_chars = length($parmlist[0]);
        for ($i=1; $i<=$#parmlist; $i++) {
            $parm_chars = &max($parm_chars, length($parmlist[$i]));
        }
        $parm_chars += 2;
        $parm_short = $parm;
        if ($parm ne "Temperature") {
            $parm_short =~ s/\(ms-1\)//i;
            $parm_short =~ s/\(m3s-1\)//i;
            $parm_short =~ s/ [kmu]?g\/L\/day//i;
            $parm_short =~ s/ [kmu]?g\/m2\/day//i;
            $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
            $parm_short =~ s/ [kmu]?g\/L//i;
            $parm_short =~ s/ [kmu]?g\/m3//i;
            $parm_short =~ s/ [kmu]?g\/m\^3//i;
            $parm_short =~ s/, days//i;
            $parm_short =~ s/ days//i;
            $parm_short =~ s/,$//;
        }
        @parm_divlist = ("None");
        for ($i=0; $i<=$#parmlist; $i++) {
            next if ($parmlist[$i] eq "Horizontal Velocity"
                      || $parmlist[$i] eq "Vertical Velocity"
                      || $parmlist[$i] eq "Horizontal Layer Flow"
                      || $parmlist[$i] eq "Density"
                      || $parmlist[$i] eq "Habitat");
            if ($parm ne $parmlist[$i]) {
                push (@parm_divlist, $parmlist[$i]);
            }
        }
        $parm_div = "None" if (&list_match($parm_div, @parm_divlist) == -1);

        $jd_skip_active = 0;
        if ($src_type =~ /Spreadsheet/i) {
            for ($i=1; $i<=$nspr[$jw]; $i++) {
                next if ($sprf[$i][$jw] eq "na");
                if ($sprf[$i][$jw] < 1.0) {
                    $jd_skip_active = 1;
                    last;
                }
            }
        } elsif ($src_type =~ /Contour/i) {
            for ($i=1; $i<=$ncpl[$jw]; $i++) {
                next if ($cplf[$i][$jw] eq "na");
                if ($cplf[$i][$jw] < 1.0) {
                    $jd_skip_active = 1;
                    last;
                }
            }
        } elsif ($src_type =~ /Vector/i) {
            for ($i=1; $i<=$nvpl[$jw]; $i++) {
                next if ($vplf[$i][$jw] eq "na");
                if ($vplf[$i][$jw] < 1.0) {
                    $jd_skip_active = 1;
                    last;
                }
            }
        } elsif ($src_type =~ /LakeCon/i) {
            $jd_skip_active = 1 if ($lcon_freq < 1.0);
        }

#   New graph
    } else {
        $src_file        = $bth_file = $con_file = $src_type = "";
        $src_lines       = 0;
        $tecplot         = 0;
        $jd_skip         = 0;
        $tz_offset       = "+00:00";
        $yaxis_units     = "feet";
        $yaxis_type      = "Elevation";
        $elev_base       = -999;
        $parm            = "Unknown";
        $parm_short      = $parm;
        @parmlist        = ();
        $parmlist[0]     = $parm;
        $parm_chars      = length($parm) +2;
        $parm_div        = "None";
        @parm_divlist    = ();
        $parm_divlist[0] = $parm_div;
        @segs            = ();
        $segnum          = "";
        $segwidth        = 5;
        $wb_txt          = "";
        $units           = "";
        $cscheme         = "Blue to Orange";
        $ncolors         = 20;
        $jd_skip_active  = 0;
        $conv_type       = $conv_types[0];
        $conv_mult       = 1.0;
        $conv_add        = 0.0;

        $nwb = $jw = 1;

        $byear = (localtime(time))[5] +1900;
        $ymin  = $ymax   = $ymajor = "";
        $xmin  = $xmax   = $xmajor = "";
        $title = $gtitle = "";
    }
    $tmp_id        = -1 *$id;
    $grid{$tmp_id} = $grid{$id};   # temporary, in case new control file is read
    $oldsrc_type   = $src_type;
    $oldparm       = $parm;
    $oldparm_short = $parm_short;
    $old_units     = $units;
    $yr_max        = (localtime(time))[5] +1900;
    $yr_min        = ($byear > $yr_max -25) ? $yr_max -25 : $byear -10;

    @jd_skip_opts = ("(keep all)", "(keep every other)", "(keep every 3rd)", "(keep every 4th)",
                     "(keep every 5th)",  "(keep every 6th)",  "(keep every 7th)",  "(keep every 8th)",
                     "(keep every 9th)",  "(keep every 10th)", "(keep every 11th)", "(keep every 12th)",
                     "(keep every 13th)", "(keep every 14th)", "(keep every 15th)", "(keep every 16th)",
                     "(keep every 17th)", "(keep every 18th)", "(keep every 19th)", "(keep every 20th)",
                     "(keep every 21st)", "(keep every 22nd)", "(keep every 23rd)", "(keep every 24th)",
                     "(keep every 25th)", "(keep every 26th)", "(keep every 27th)", "(keep every 28th)",
                     "(keep every 29th)", "(keep every 30th)", "(keep every 31st)", "(keep every 32nd)",
                     "(keep every 33rd)", "(keep every 34th)", "(keep every 35st)", "(keep every 36th)",
                     "(keep every 37th)", "(keep every 38th)", "(keep every 39th)", "(keep every 40th)",
                     "(keep every 41st)", "(keep every 42nd)", "(keep every 43rd)", "(keep every 44th)",
                     "(keep every 45th)", "(keep every 46th)", "(keep every 47th)", "(keep every 48th)",
                     "(keep every 49th)", "(keep every 50th)");
    $jd_skip = 0 if ($jd_skip < 0 || $jd_skip > 49);
    $jd_skip_explain = $jd_skip_opts[$jd_skip];

#   Available initial colormaps
    @cmaps = ("None", "Blue to Orange", "Blue to Red", "CoolWarm", "Turbo", "Viridis");
    shift @cmaps if ($props{$id}{meta} eq "w2_profile_cmap");

    $frame = $w2profile_setup_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -state   => ($new_graph) ? 'disabled' : 'normal',
            -command => sub { my ($confirm_type, %parms);
                              %parms = ();
                              if ($src_type =~ /Spreadsheet/i) {
                                  if ($src_file eq "" || ! -e $src_file) {
                                      return &pop_up_error($w2profile_setup_menu,
                                      "W2 Spreadsheet file not set or does not exist:\n$src_file");
                                  }
                              } elsif ($src_type =~ /Contour/i) {
                                  if ($src_file eq "" || ! -e $src_file) {
                                      return &pop_up_error($w2profile_setup_menu,
                                      "W2 Contour file not set or does not exist:\n$src_file");
                                  }
                              } elsif ($src_type =~ /Vector/i) {
                                  if ($src_file eq "" || ! -e $src_file) {
                                      return &pop_up_error($w2profile_setup_menu,
                                      "W2 Vector (w2l) file not set or does not exist:\n$src_file");
                                  }
                              } elsif ($src_type =~ /LakeCon/i) {
                                  if ($src_file eq "" || ! -e $src_file) {
                                      return &pop_up_error($w2profile_setup_menu,
                                      "W2 Lake Contour file not set or does not exist:\n$src_file");
                                  }
                              }
                              $confirm_type = &confirm_w2_ftype($w2profile_setup_menu, $src_file);
                              if ($src_type =~ /Spreadsheet/i && $confirm_type ne "spr") {
                                  return &pop_up_error($w2profile_setup_menu,
                                      "The W2 source file is not a W2 Spreadsheet file:\n$src_file");
                              } elsif ($src_type =~ /Contour/i && $confirm_type ne "cpl") {
                                  return &pop_up_error($w2profile_setup_menu,
                                      "The W2 source file is not a W2 Contour file:\n$src_file");
                              } elsif ($src_type =~ /Vector/i && $confirm_type ne "w2l") {
                                  return &pop_up_error($w2profile_setup_menu,
                                      "The W2 source file is not a W2 Vector (w2l) file:\n$src_file");
                              } elsif ($src_type =~ /LakeCon/i && $confirm_type ne "lcon1") {
                                  return &pop_up_error($w2profile_setup_menu,
                                      "The W2 source file is not an acceptable\n"
                                    . "W2 Lake Contour (format 1) file:\n$src_file");
                              }
                              if ($bth_file eq "" || ! -e $bth_file) {
                                  return &pop_up_error($w2profile_setup_menu,
                                      "W2 Bathymetry file not set or does not exist:\n$bth_file");
                              }
                              if ($xmin eq "" || $xmax eq "") {
                                  return &pop_up_error($w2profile_setup_menu,
                                  "Please provide both a min and max for your parameter.");
                              }
                              if ($xmin >= $xmax) {
                                  return &pop_up_error($w2profile_setup_menu,
                                  "The minimum data value must be less than the maximum data value.");
                              }
                              if ($yaxis_type eq "Elevation") {
                                  if ($ymin eq "" || $ymax eq "") {
                                      return &pop_up_error($w2profile_setup_menu,
                                      "Please provide both a min and max elevation.");
                                  }
                                  if ($ymin >= $ymax) {
                                      return &pop_up_error($w2profile_setup_menu,
                                      "The minimum elevation must be less than the maximum elevation.");
                                  }
                              } else {
                                  if ($ymax eq "") {
                                      return &pop_up_error($w2profile_setup_menu,
                                      "Please provide a maximum depth.");
                                  }
                              }
                              if ($segnum eq "" || $segnum <= 0) {
                                  return &pop_up_error($w2profile_setup_menu,
                                  "W2 segment number must be numeric and positive.");
                              }
                              if ($conv_type eq "Custom") {
                                  $conv_type = sprintf("Custom,%s,%s", $conv_mult, $conv_add);
                              }
                              $gtitle =~ s/^\s+//;
                              $gtitle =~ s/\s+$//;

#                             Delete reference dataset if different control file, seg, parm, or units
                              if (! $new_graph && defined($props{$id}{ref_file})
                                   && ($con_file  ne $props{$id}{con_file} ||
                                       $segnum    != $props{$id}{seg} ||
                                       $parm      ne $props{$id}{parm} ||
                                       $parm_div  ne $props{$id}{parm_div} ||
                                       $units     ne $props{$id}{parm_units} ||
                                       $conv_type ne $props{$id}{ctype})) {
                                  undef $props{$id}{ref_file};
                                  undef $gr_props{$id}{ref_data};
                              }

#                             Rebuild the dates array if different segment, jd_skip, or byear
                              if (! $new_graph) {
                                  $parms{rebuild} = ($props{$id}{meta} eq "w2_profile" &&
                                                     ($con_file  ne $props{$id}{con_file}  ||
                                                      $src_file  ne $props{$id}{src_file}  ||
                                                      $segnum    != $props{$id}{seg}       ||
                                                      $byear     != $props{$id}{byear}     ||
                                                      $tz_offset ne $props{$id}{tz_offset} ||
                                                      $jd_skip   != $props{$id}{jd_skip})) ? 1 : 0;
                                  $parms{change} = "all";
                              }
                              $parms{xmin}       = $xmin;
                              $parms{xmax}       = $xmax;
                              $parms{xmajor}     = $xmajor;
                              $parms{ymin}       = $ymin;
                              $parms{ymax}       = $ymax;
                              $parms{ymajor}     = $ymajor;
                              $parms{ytype}      = $yaxis_type;
                              $parms{yunits}     = $yaxis_units;
                              $parms{cscheme}    = $cscheme;
                              $parms{ncolors}    = $ncolors;
                              $parms{gtitle}     = $gtitle;
                              $props{$id}{parms} = { %parms };

                              $props{$id}{files}      = 1;
                              $props{$id}{data}       = 0;
                              $props{$id}{con_file}   = $con_file;
                              $props{$id}{bth_file}   = $bth_file;
                              $props{$id}{src_type}   = $src_type;
                              $props{$id}{src_file}   = $src_file;
                              $props{$id}{src_lines}  = $src_lines;
                              $props{$id}{tplot}      = $tecplot;
                              $props{$id}{parm}       = $parm;
                              $props{$id}{parm_div}   = $parm_div;
                              $props{$id}{parm_units} = $units;
                              $props{$id}{ctype}      = $conv_type;
                              $props{$id}{seg}        = $segnum;
                              $props{$id}{byear}      = $byear;
                              $props{$id}{tz_offset}  = $tz_offset;
                              $props{$id}{jd_skip}    = $jd_skip;

                              $grid{$id} = $grid{$tmp_id};
                              delete $grid{$tmp_id};

                              $w2profile_setup_menu->g_bind('<Destroy>', "");
                              $w2profile_setup_menu->g_destroy();
                              undef $w2profile_setup_menu;
                              &reset_bindings;
                              &make_w2_profile($canv, $id, 0);
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $w2profile_setup_menu->g_bind('<Destroy>', "");
                              $w2profile_setup_menu->g_destroy();
                              undef $w2profile_setup_menu;
                              if ($new_graph) {
                                  $canv->delete("graph" . $id);
                                  delete $props{$id};
                              }
                              delete $grid{$tmp_id} if (defined($grid{$tmp_id}));
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Delete graph if this menu is destroyed by other than the Cancel button
    $w2profile_setup_menu->g_bind('<Destroy>' => sub { undef $w2profile_setup_menu;
                                                       if ($new_graph) {
                                                           $canv->delete("graph" . $id);
                                                           delete $props{$id}; 
                                                       }
                                                       delete $grid{$tmp_id} if (defined($grid{$tmp_id}));
                                                       &reset_bindings;
                                                     });

    $f = $w2profile_setup_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "W2 Control File: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$con_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);
    $f->new_button(
            -text    => "Browse",
            -command => sub { my ($file, $segwidth);
                              $file = Tkx::tk___getOpenFile(
                                      -parent           => $w2profile_setup_menu,
                                      -title            => "Select W2 Control File",
                                      -initialdir       => abs_path(),
                                      -filetypes => [ ['All Files',  '*'],
                                                      ['CSV (comma delimited)', '.csv'],
                                                      ['NPT (W2 input file)', '.npt'],
                                                    ],
                                      );
                              if (defined($file) && -e $file) {
                                  $con_file = File::Spec->rel2abs($file);
                                  &read_con($main, $tmp_id, $con_file);

                                  $nbr   = $grid{$tmp_id}{nbr};
                                  $nwb   = $grid{$tmp_id}{nwb};
                                  @bs    = @{ $grid{$tmp_id}{bs}    };
                                  @be    = @{ $grid{$tmp_id}{be}    };
                                  @us    = @{ $grid{$tmp_id}{us}    };
                                  @ds    = @{ $grid{$tmp_id}{ds}    };
                                  @jbdn  = @{ $grid{$tmp_id}{jbdn}  };
                                  @slope = @{ $grid{$tmp_id}{slope} };
                                  @nspr  = @{ $grid{$tmp_id}{nspr}  };
                                  @sprf  = @{ $grid{$tmp_id}{sprf}  };
                                  @ncpl  = @{ $grid{$tmp_id}{ncpl}  };
                                  @cplf  = @{ $grid{$tmp_id}{cplf}  };
                                  @nvpl  = @{ $grid{$tmp_id}{nvpl}  };
                                  @vplf  = @{ $grid{$tmp_id}{vplf}  };
                                  $byear = $grid{$tmp_id}{byear};

                                  @segs = ();
                                  for ($jb=1; $jb<=$nbr; $jb++) {
                                      push (@segs, ($us[$jb] .. $ds[$jb]));
                                  }
                                  $segwidth = &max(5, length(&max(@segs)));
                                  $segnum_cb->configure(-values => [ @segs ],
                                                        -width  => $segwidth,
                                                        -state  => 'readonly');
                                  $segnum = $ds[$jbdn[1]];
                                  $wb_txt = "";
                                  for ($jw=1; $jw<=$nwb; $jw++) {
                                      for ($jb=$bs[$jw]; $jb<=$be[$jw]; $jb++) {
                                          if ($segnum >= $us[$jb] && $segnum <= $ds[$jb]) {
                                              $wb_txt = " (waterbody $jw, branch $jb)";
                                              last;
                                          }
                                      }
                                      last if ($wb_txt ne "");
                                  }
                                  if ($byear <= $yr_min) {
                                      $yr_min = $byear -10;
                                      $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                  }
                                  $byear_cb->configure(-state => 'readonly');
                                  $src_type_cb->configure(-state => 'readonly');
                              } else {
                                  $con_file = $segnum = $wb_txt = "";
                                  @segs = ();
                                  $segnum_cb->configure(-values => [ @segs ],
                                                        -state  => 'disabled');
                                  $src_type_cb->configure(-state => 'disabled');
                                  $byear_cb->configure(-state => 'disabled');
                              }
                              $bth_file = $src_file = $src_type = $oldsrc_type = "";
                              $title    = $gtitle   = $units    = $old_units   = "";
                              $parm            = "Unknown";
                              $oldparm         = $parm;
                              $parm_short      = $parm;
                              $oldparm_short   = $parm;
                              @parmlist        = ();
                              $parmlist[0]     = $parm;
                              $parm_chars      = length($parm) +2;
                              $parm_div        = "None";
                              @parm_divlist    = ();
                              $parm_divlist[0] = $parm_div;
                              $parm_cb->configure(-values => [ @parmlist ],
                                                  -width  => $parm_chars);
                              $parm_div_cb->configure(-values => [ @parm_divlist ],
                                                      -width  => $parm_chars);
                              $units_cb->g_grid_remove();
                              $units_entry->g_grid();
                              $conv_type_na_label->g_grid_remove();
                              $custom_frame->g_grid() if ($conv_type eq "Custom");
                              $conv_type_cb->g_grid();
                              $src_file_label->configure(-text => "W2 Output File: ");
                              $src_file_btn->configure(-state => 'disabled');
                              $bth_file_btn->configure(-state => 'disabled');
                              $jd_skip_label->g_grid_remove();
                              $jd_skip_frame->g_grid_remove();
                              $ok_btn->configure(-state => 'disabled');
                            }
            )->g_grid(-row => $row, -column => 4, -sticky => 'ew', -padx => 2, -pady => 2);

    $row++;
    $f->new_label(
            -text => "W2 Source Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($src_type_cb = $f->new_ttk__combobox(
            -textvariable => \$src_type,
            -values       => [ ("W2 Spreadsheet File", "W2 Contour File",
                                "W2 Vector File", "W2 LakeCon File") ],
            -state        => ($new_graph) ? 'disabled' : 'readonly',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w', -pady => 2);
    $src_type_cb->g_bind("<<ComboboxSelected>>",
                          sub { my ($i);
                                return if ($src_type eq $oldsrc_type);
                                $oldsrc_type     = $src_type;
                                $src_file        = $title = $units = $old_units = "";
                                $parm            = "Unknown";
                                $oldparm         = $parm;
                                $parm_short      = $parm;
                                $oldparm_short   = $parm;
                                @parmlist        = ();
                                $parmlist[0]     = $parm;
                                $parm_chars      = length($parm) +2;
                                $parm_div        = "None";
                                @parm_divlist    = ();
                                $parm_divlist[0] = $parm_div;
                                $parm_cb->configure(-values => [ @parmlist ],
                                                    -width  => $parm_chars);
                                $parm_div_cb->configure(-values => [ @parm_divlist ],
                                                        -width  => $parm_chars);
                                $parm_div_label->g_pack_forget();
                                $parm_div_cb->g_pack_forget();
                                $units_cb->g_grid_remove();
                                $units_entry->g_grid();
                                $conv_type_na_label->g_grid_remove();
                                $custom_frame->g_grid() if ($conv_type eq "Custom");
                                $conv_type_cb->g_grid();
                                $ok_btn->configure(-state => 'disabled');

                                if ($src_type =~ /Spreadsheet|Contour|Vector|LakeCon/i) {
                                    $src_file_label->configure(-text => $src_type . ": ");
                                    $src_file_btn->configure(-state => 'normal');
                                    $bth_file_btn->configure(-state => 'normal');
                                    $jd_skip_active = 0;
                                    if ($src_type =~ /Spreadsheet/i) {
                                        for ($i=1; $i<=$nspr[$jw]; $i++) {
                                            next if ($sprf[$i][$jw] eq "na");
                                            if ($sprf[$i][$jw] < 1.0) {
                                                $jd_skip_active = 1;
                                                last;
                                            }
                                        }
                                    } elsif ($src_type =~ /Contour/i) {
                                        for ($i=1; $i<=$ncpl[$jw]; $i++) {
                                            next if ($cplf[$i][$jw] eq "na");
                                            if ($cplf[$i][$jw] < 1.0) {
                                                $jd_skip_active = 1;
                                                last;
                                            }
                                        }
                                    } elsif ($src_type =~ /Vector/i) {
                                        for ($i=1; $i<=$nvpl[$jw]; $i++) {
                                            next if ($vplf[$i][$jw] eq "na");
                                            if ($vplf[$i][$jw] < 1.0) {
                                                $jd_skip_active = 1;
                                                last;
                                            }
                                        }
                                    } elsif ($src_type =~ /LakeCon/i) {
                                        $jd_skip_active = 1;  # placeholder
                                    }
                                    if ($jd_skip_active) {
                                        $jd_skip = 0 if ($jd_skip < 0 || $jd_skip > 49);
                                        $jd_skip_explain = $jd_skip_opts[$jd_skip];
                                        $jd_skip_label->g_grid();
                                        $jd_skip_frame->g_grid();
                                    } else {
                                        $jd_skip_label->g_grid_remove();
                                        $jd_skip_frame->g_grid_remove();
                                    }
                                    if ($slope[$jb] > 0.0) {
                                        if ($src_type =~ /Spreadsheet/i) {
                                            return &pop_up_info($w2profile_setup_menu,
                                                    "Branch $jb has a nonzero slope.\n"
                                                  . "W2 spreadsheet outputs may not\n"
                                                  . "work well for nonzero branch slopes.\n"
                                                  . "Consider using the W2 Contour File\n"
                                                  . "or W2 Vector File output option.");
                                        } elsif ($src_type =~ /LakeCon/i) {
                                            return &pop_up_info($w2profile_setup_menu,
                                                    "Branch $jb has a nonzero slope.\n"
                                                  . "W2 Lake Contour outputs may not\n"
                                                  . "work well for nonzero branch slopes.\n"
                                                  . "Consider using the W2 Contour File\n"
                                                  . "or W2 Vector File output option.");
                                        }
                                    }
                                } else {
                                    $src_file_label->configure(-text => "W2 Output File: ");
                                    $src_file_btn->configure(-state => 'disabled');
                                    $bth_file_btn->configure(-state => 'disabled');
                                    $jd_skip_label->g_grid_remove();
                                    $jd_skip_frame->g_grid_remove();
                                    $bth_file = "";
                                }
                              });

    $row++;
    ($src_file_label = $f->new_label(
            -text => "W2 Output File: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$src_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);
    ($src_file_btn = $f->new_button(
            -text    => "Browse",
            -state   => ($new_graph) ? 'disabled' : 'normal',
            -command => sub { my ($confirm_type, $file, $i, $ok, $parms_ref,
                                  $pbar, $pbar_img, $pbar_win, $segs_ref, $segwidth);
                              $file = Tkx::tk___getOpenFile(
                                      -parent           => $w2profile_setup_menu,
                                      -title            => "Select $src_type",
                                   #  -initialdir       => abs_path(),
                                      -filetypes => [ ['All Files',  '*'],
                                                      ['CSV (comma delimited)', '.csv'],
                                                    ],
                                      );
                              if (defined($file) && -e $file) {
                                  $src_file        = File::Spec->rel2abs($file);
                                  $title           = $units = $old_units = "";
                                  $parm            = "Unknown";
                                  $oldparm         = $parm;
                                  $parm_short      = $parm;
                                  $oldparm_short   = $parm;
                                  @parmlist        = ();
                                  $parmlist[0]     = $parm;
                                  $parm_chars      = length($parm) +2;
                                  $parm_div        = "None";
                                  @parm_divlist    = ();
                                  $parm_divlist[0] = $parm_div;
                                  $parm_cb->configure(-values => [ @parmlist ],
                                                      -width  => $parm_chars);
                                  $parm_div_cb->configure(-values => [ @parm_divlist ],
                                                          -width  => $parm_chars);
                                  $units_cb->g_grid_remove();
                                  $units_entry->g_grid();
                                  $conv_type_na_label->g_grid_remove();
                                  $custom_frame->g_grid() if ($conv_type eq "Custom");
                                  $conv_type_cb->g_grid();
                                  $wb_input_label->g_grid_remove();
                                  $wb_input_cb->g_grid_remove();

                                  $confirm_type = &confirm_w2_ftype($w2profile_setup_menu, $src_file);
                                  if ($src_type =~ /Spreadsheet/i && $confirm_type ne "spr") {
                                      $src_file = "";
                                      $ok_btn->configure(-state => 'disabled');
                                      return &pop_up_error($w2profile_setup_menu,
                                          "The specified file is not a W2 Spreadsheet file:\n$file");
                                  } elsif ($src_type =~ /Contour/i && $confirm_type ne "cpl") {
                                      $src_file = "";
                                      $ok_btn->configure(-state => 'disabled');
                                      return &pop_up_error($w2profile_setup_menu,
                                          "The specified file is not a W2 Contour file:\n$file");
                                  } elsif ($src_type =~ /Vector/i && $confirm_type ne "w2l") {
                                      $src_file = "";
                                      $ok_btn->configure(-state => 'disabled');
                                      return &pop_up_error($w2profile_setup_menu,
                                          "The specified file is not a W2 Vector (w2l) file:\n$file");
                                  } elsif ($src_type =~ /LakeCon/i && $confirm_type ne "lcon1") {
                                      $src_file = "";
                                      $ok_btn->configure(-state => 'disabled');
                                      return &pop_up_error($w2profile_setup_menu,
                                          "The specified file is not an acceptable\n"
                                        . "W2 Lake Contour (format 1) file:\n$file");
                                  }
                                  if ($src_type =~ /Spreadsheet/i) {
                                      ($pbar_win, $pbar, $pbar_img)
                                          = &create_alt_progress_bar($main, $id,
                                                                     "Scanning W2 spreadsheet file...");
                                      ($ok, $src_lines, $segs_ref, $parms_ref)
                                          = &scan_w2_spr_file($w2profile_setup_menu, $src_file, $pbar_img);
                                      &destroy_progress_bar($main, $pbar_win);

                                      if ($ok ne "okay") {
                                          $src_file = "";
                                          $ok_btn->configure(-state => 'disabled');
                                          return &pop_up_error($w2profile_setup_menu,
                                              "The specified file is not a W2 Spreadsheet file:\n$file");
                                      }
                                      @parmlist = @{ $parms_ref };
                                      @segs     = @{ $segs_ref  };
                                      if ($segnum eq "" || &list_match($segnum, @segs) == -1) {
                                          $segnum = $segs[$#segs];
                                      }

                                  } elsif ($src_type =~ /Contour/i) {
                                      ($pbar_win, $pbar, $pbar_img)
                                          = &create_alt_progress_bar($main, $id,
                                                                     "Scanning W2 contour file...");
                                      ($tecplot, $src_lines, $jw, $parms_ref, undef, undef)
                                          = &scan_w2_cpl_file($w2profile_setup_menu,
                                                              $src_file, $tmp_id, 0, $pbar_img);
                                      &destroy_progress_bar($main, $pbar_win);

                                      if ($tecplot == -1) {
                                          $src_file = "";
                                          $ok_btn->configure(-state => 'disabled');
                                          return &pop_up_error($w2profile_setup_menu,
                                              "The specified file is not a W2 Contour output file:\n$file");
                                      }
                                      @segs = ();
                                      if ($jw == 0) {
                                          for ($jb=1; $jb<=$nbr; $jb++) {
                                              push (@segs, ($us[$jb] .. $ds[$jb]));
                                          }
                                          $jw = 1;
                                          if ($nwb > 1) {
                                              $wb_input_label->g_grid();
                                              $wb_input_cb->g_grid();
                                          }
                                      } else {
                                          for ($jb=$bs[$jw]; $jb<=$be[$jw]; $jb++) {
                                              push (@segs, ($us[$jb] .. $ds[$jb]));
                                          }
                                      }
                                      if ($segnum eq "" || &list_match($segnum, @segs) == -1) {
                                          $segnum = $ds[$jbdn[$jw]];
                                      }
                                      @parmlist = @{ $parms_ref };

                                  } elsif ($src_type =~ /Vector/i) {
                                      $status_line = "Scanning W2 vector file...";  # no progress bar needed
                                      ($ok, $parms_ref, undef, undef, undef)
                                          = &scan_w2_vector_file($w2profile_setup_menu,
                                                                 $src_file, $tmp_id, 0);
                                      $status_line = "";

                                      if ($ok ne "okay") {
                                          $src_file = "";
                                          $ok_btn->configure(-state => 'disabled');
                                          return &pop_up_error($w2profile_setup_menu,
                                              "The specified file is not a W2 Vector (w2l) file:\n$file");
                                      }
                                      @segs = ();
                                      for ($jb=1; $jb<=$nbr; $jb++) {
                                          push (@segs, ($us[$jb] .. $ds[$jb]));
                                      }
                                      if ($segnum eq "" || &list_match($segnum, @segs) == -1) {
                                          $segnum = $ds[$jbdn[1]];
                                      }
                                      @parmlist = @{ $parms_ref };

                                  } elsif ($src_type =~ /LakeCon/i) {
                                      ($pbar_win, $pbar, $pbar_img)
                                          = &create_alt_progress_bar($main, $id,
                                                                     "Scanning W2 Lake Contour file...");
                                      ($ftype, $src_parm, $meta, $src_lines)
                                          = &scan_w2_rlcon_file($w2profile_setup_menu, $src_file, $pbar_img);
                                      &destroy_progress_bar($main, $pbar_win);

                                      if ($ftype ne "lcon1") {
                                          $src_file = "";
                                          $ok_btn->configure(-state => 'disabled');
                                          return &pop_up_error($w2profile_setup_menu,
                                              "The specified file is not an acceptable\n"
                                            . "W2 Lake Contour (format 1) file:\n$file");
                                      }
                                      ($segnum, $lcon_freq) = split(/_/, $meta);
                                      @segs     = ($segnum);
                                      @parmlist = ($src_parm);
                                      $jd_skip_active = ($lcon_freq < 1.0) ? 1 : 0;
                                      if ($jd_skip_active) {
                                          $jd_skip = 0 if ($jd_skip < 0 || $jd_skip > 49);
                                          $jd_skip_explain = $jd_skip_opts[$jd_skip];
                                          $jd_skip_label->g_grid();
                                          $jd_skip_frame->g_grid();
                                      } else {
                                          $jd_skip_label->g_grid_remove();
                                          $jd_skip_frame->g_grid_remove();
                                      }
                                  }
                                  @segs = sort numerically @segs;
                                  $segwidth = &max(5, length(&max(@segs)));
                                  $segnum_cb->configure(-values => [ @segs ],
                                                        -width  => $segwidth,
                                                        -state  => 'readonly');
                                  $wb_txt = "";
                                  for ($jw=1; $jw<=$nwb; $jw++) {
                                      for ($jb=$bs[$jw]; $jb<=$be[$jw]; $jb++) {
                                          if ($segnum >= $us[$jb] && $segnum <= $ds[$jb]) {
                                              $wb_txt = " (waterbody $jw, branch $jb)";
                                              last;
                                          }
                                      }
                                      last if ($wb_txt ne "");
                                  }
                                  $parm_chars = length($parmlist[0]);
                                  for ($i=1; $i<=$#parmlist; $i++) {
                                      $parm_chars = &max($parm_chars, length($parmlist[$i]));
                                  }
                                  $parm_chars += 2;
                                  $parm_cb->configure(-values => [ @parmlist ],
                                                      -width  => $parm_chars);
                                  if (&list_match($parm, @parmlist) == -1) {
                                      $parm = $parmlist[0];
                                      $parm =~ s/^\s+//;
                                      $parm =~ s/\s+$//;
                                  }
                                  $parm_short = $parm;
                                  if ($parm eq "Temperature") {
                                      $units = "Celsius" if ($units !~ /(Celsius|Fahrenheit)/);
                                      $title = "Temperature, in degrees " . $units;
                                      $units_cb->g_grid();
                                      $units_entry->g_grid_remove();
                                      $conv_type_na_label->g_grid();
                                      $custom_frame->g_grid_remove();
                                      $conv_type_cb->g_grid_remove();
                                      $conv_type = "None";
                                  } else {
                                      $units = "";
                                      $parm_short =~ s/\(ms-1\)//i;
                                      $parm_short =~ s/\(m3s-1\)//i;
                                      $parm_short =~ s/ [kmu]?g\/L\/day//i;
                                      $parm_short =~ s/ [kmu]?g\/m2\/day//i;
                                      $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
                                      $parm_short =~ s/ [kmu]?g\/L//i;
                                      $parm_short =~ s/ [kmu]?g\/m3//i;
                                      $parm_short =~ s/ [kmu]?g\/m\^3//i;
                                      $parm_short =~ s/, days//i;
                                      $parm_short =~ s/ days//i;
                                      $parm_short =~ s/,$//;
                                      if ($parm eq "Horizontal Velocity" || $parm eq "Vertical Velocity") {
                                          $units = "m/s";
                                          $title = $parm_short . ", in m/s";
                                      } elsif ($parm eq "Horizontal Layer Flow") {
                                          $units = "m3/s";
                                          $title = $parm_short . ", in m3/s";
                                      } elsif ($parm eq "Density") {
                                          $units = "kg/m3";
                                          $title = $parm_short . ", in kg/m3";
                                      } else {
                                          $title = $parm_short . ", in ";
                                      }
                                      $units_cb->g_grid_remove();
                                      $units_entry->g_grid();
                                      $conv_type_na_label->g_grid_remove();
                                      $custom_frame->g_grid() if ($conv_type eq "Custom");
                                      $conv_type_cb->g_grid();
                                  }
                                  if ($gtitle eq "") {
                                     if ($props{$id}{meta} eq "w2_profile_cmap") {
                                         $gtitle = ucfirst($parm_short) . " Colormap";
                                     } else {
                                         $gtitle = ucfirst($parm_short) . " Profile";
                                     }
                                  } else {
                                      if (index(lc($gtitle), lc($oldparm_short)) > -1) {
                                          $gtitle =~ s/$oldparm_short/$parm_short/i;
                                      }
                                  }
                                  $old_units     = $units;
                                  $oldparm       = $parm;
                                  $oldparm_short = $parm_short;
                                  @parm_divlist  = ("None");
                                  for ($i=0; $i<=$#parmlist; $i++) {
                                      next if ($parmlist[$i] eq "Horizontal Velocity"
                                               || $parmlist[$i] eq "Vertical Velocity"
                                               || $parmlist[$i] eq "Horizontal Layer Flow"
                                               || $parmlist[$i] eq "Density"
                                               || $parmlist[$i] eq "Habitat");
                                      if ($parm ne $parmlist[$i]) {
                                          push (@parm_divlist, $parmlist[$i]);
                                      }
                                  }
                                  $parm_div_cb->configure(-values => [ @parm_divlist ],
                                                          -width  => $parm_chars);
                                  if (&list_match($parm_div, @parm_divlist) == -1) {
                                      $parm_div = "None";
                                  }
                                  if ($parm eq "Temperature" || $parm eq "Horizontal Velocity"
                                        || $parm eq "Vertical Velocity" || $parm eq "Density"
                                        || $parm eq "Horizontal Layer Flow"
                                        || $parm eq "Habitat" || $#parm_divlist == 0) {
                                      $parm_div_label->g_pack_forget();
                                      $parm_div_cb->g_pack_forget();
                                      $parm_div = "None";
                                  } else {
                                      $parm_div_label->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                                      $parm_div_cb->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                                  }
                                  if ($bth_file ne "" && -e $bth_file) {
                                      $ok_btn->configure(-state => 'normal');
                                  }
                              } else {
                                  $ok_btn->configure(-state => 'disabled');
                              }
                            },
            ))->g_grid(-row => $row, -column => 4, -sticky => 'ew', -padx => 2, -pady => 2);

    $row++;
    $f->new_label(
            -text => "W2 Bathymetry File: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$bth_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);
    ($bth_file_btn = $f->new_button(
            -text    => "Browse",
            -state   => ($new_graph) ? 'disabled' : 'normal',
            -command => sub { my ($file);
                              $file = Tkx::tk___getOpenFile(
                                      -parent           => $w2profile_setup_menu,
                                      -title            => "Select W2 Bathymetry File",
                                   #  -initialdir       => abs_path(),
                                      -defaultextension => ".csv",
                                      -filetypes => [ ['CSV (comma delimited)', '.csv'],
                                                      ['NPT (W2 input file)', '.npt'],
                                                      ['All Files',  '*'],
                                                    ],
                                      );
                              if (defined($file) && -e $file) {
                                  $bth_file = File::Spec->rel2abs($file);
                                  if ($src_file ne "" && -e $src_file) {
                                      $ok_btn->configure(-state => 'normal');
                                  }
                              } else {
                                  $ok_btn->configure(-state => 'disabled');
                              }
                            },
            ))->g_grid(-row => $row, -column => 4, -sticky => 'ew', -padx => 2, -pady => 2);

    $row++;
    ($wb_input_label = $f->new_label(
            -text => "Waterbody: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($wb_input_cb = $f->new_ttk__combobox(
            -textvariable => \$jw,
            -values       => [ (1 .. $nwb) ],
            -state        => ($new_graph) ? 'disabled' : 'readonly',
            -width        => $segwidth,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $wb_input_cb->g_bind("<<ComboboxSelected>>",
                          sub { $wb_txt = "";
                                @segs   = ();
                                for ($jb=$bs[$jw]; $jb<=$be[$jw]; $jb++) {
                                    push (@segs, ($us[$jb] .. $ds[$jb]));
                                }
                                @segs = sort numerically @segs;
                                if ($segnum eq "" || &list_match($segnum, @segs) == -1) {
                                    $segnum = $ds[$jbdn[$jw]];
                                }
                                for ($jb=$bs[$jw]; $jb<=$be[$jw]; $jb++) {
                                    if ($segnum >= $us[$jb] && $segnum <= $ds[$jb]) {
                                        $wb_txt = " (waterbody $jw, branch $jb)";
                                        last;
                                    }
                                }
                                $segwidth = &max(5, length(&max(@segs)));
                                $segnum_cb->configure(-values => [ @segs ],
                                                      -width  => $segwidth);
                              });
    $wb_input_label->g_grid_remove();
    $wb_input_cb->g_grid_remove();

    $row++;
    $f->new_label(
            -text => "Segment: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($segnum_cb = $f->new_ttk__combobox(
            -textvariable => \$segnum,
            -values       => [ @segs ],
            -state        => ($new_graph) ? 'disabled' : 'readonly',
            -width        => $segwidth,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $segnum_cb->g_bind("<<ComboboxSelected>>",
                        sub { $wb_txt = "";
                              for ($jw=1; $jw<=$nwb; $jw++) {
                                  for ($jb=$bs[$jw]; $jb<=$be[$jw]; $jb++) {
                                      if ($segnum >= $us[$jb] && $segnum <= $ds[$jb]) {
                                          $wb_txt = " (waterbody $jw, branch $jb)";
                                          last;
                                      }
                                  }
                                  last if ($wb_txt ne "");
                              }
                            });
    $f->new_label(
            -textvariable => \$wb_txt,
            -anchor       => 'w',
            -font         => 'default',
            )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Base Year: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($byear_cb = $f->new_ttk__combobox(
            -textvariable => \$byear,
            -values       => [ reverse($yr_min .. $yr_max) ],
            -state        => ($new_graph) ? 'disabled' : 'readonly',
            -width        => 5,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $byear_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($byear == $yr_min) {
                                $yr_min -= 10;
                                $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                            }
                          });
    $f->new_label(
            -text   => " for JDAY = 1.0",
            -anchor => 'w',
            -font   => 'default',
            )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Time Offset: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($offset_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    $offset_frame->new_ttk__combobox(
            -textvariable => \$tz_offset,
            -values       => [ @tz_offsets ],
            -justify      => 'right',
            -state        => 'readonly',
            -width        => 6,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $offset_frame->new_label(
            -text   => " time zone adjustment ",
            -anchor => 'w',
            -font   => 'default',
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $offset_frame->new_button(
            -text    => "Help",
            -command => sub { &pop_up_info($w2profile_setup_menu,
                                    "The time offset allows the user to add or subtract a time\n"
                                  . "offset if the W2 model was run with a non-local time zone.\n\n"
                                  . "For example, if W2 was run in UTC but the local time zone\n"
                                  . "is PST, an offset of -08:00 would convert the model date/time\n"
                                  . "to a local standard time of PST. This offset does not make\n"
                                  . "any adjustments related to daylight saving time. In general,\n"
                                  . "W2 is best run in the local standard time.\n\n"
                                  . "Leave the time offset at +00:00 for no adjustment.",
                                    "Time Offset Notice");
                            },
            )->g_pack(-side => 'left', -anchor => 'w', -padx => 2);

    $row++;
    $f->new_label(
            -text => "Parameter: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($parm_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    ($parm_cb = $parm_frame->new_ttk__combobox(
            -textvariable => \$parm,
            -values       => [ @parmlist ],
            -state        => 'readonly',
            -width        => $parm_chars,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $parm_cb->g_bind("<<ComboboxSelected>>",
                         sub { my ($i);
                               return if ($parm eq $oldparm);
                               $parm_short = $parm;
                               if ($parm eq "Temperature") {
                                   $units = "Celsius" if ($units !~ /(Celsius|Fahrenheit)/);
                                   $title = "Temperature, in degrees " . $units;
                                   $units_cb->g_grid();
                                   $units_entry->g_grid_remove();
                                   $conv_type_na_label->g_grid();
                                   $custom_frame->g_grid_remove();
                                   $conv_type_cb->g_grid_remove();
                                   $conv_type = "None";
                               } else {
                                   $units = "";
                                   $parm_short =~ s/\(ms-1\)//i;
                                   $parm_short =~ s/\(m3s-1\)//i;
                                   $parm_short =~ s/ [kmu]?g\/L\/day//i;
                                   $parm_short =~ s/ [kmu]?g\/m2\/day//i;
                                   $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
                                   $parm_short =~ s/ [kmu]?g\/L//i;
                                   $parm_short =~ s/ [kmu]?g\/m3//i;
                                   $parm_short =~ s/ [kmu]?g\/m\^3//i;
                                   $parm_short =~ s/, days//i;
                                   $parm_short =~ s/ days//i;
                                   $parm_short =~ s/,$//;
                                   if ($parm eq "Horizontal Velocity" || $parm eq "Vertical Velocity") {
                                       $units = "m/s";
                                       $title = $parm_short . ", in m/s";
                                   } elsif ($parm eq "Horizontal Layer Flow") {
                                       $units = "m3/s";
                                       $title = $parm_short . ", in m3/s";
                                   } elsif ($parm eq "Density") {
                                       $units = "kg/m3";
                                       $title = $parm_short . ", in kg/m3";
                                   } else {
                                       $title = $parm_short . ", in ";
                                   }
                                   $units_cb->g_grid_remove();
                                   $units_entry->g_grid();
                                   $conv_type_na_label->g_grid_remove();
                                   $custom_frame->g_grid() if ($conv_type eq "Custom");
                                   $conv_type_cb->g_grid();
                               }
                               if ($gtitle eq "") {
                                  if ($props{$id}{meta} eq "w2_profile_cmap") {
                                      $gtitle = ucfirst($parm_short) . " Colormap";
                                  } else {
                                      $gtitle = ucfirst($parm_short) . " Profile";
                                  }
                               } else {
                                   if (index(lc($gtitle), lc($oldparm_short)) > -1) {
                                       $gtitle =~ s/$oldparm_short/$parm_short/i;
                                   }
                               }
                               $old_units     = $units;
                               $oldparm       = $parm;
                               $oldparm_short = $parm_short;
                               @parm_divlist  = ("None");
                               for ($i=0; $i<=$#parmlist; $i++) {
                                   next if ($parmlist[$i] eq "Horizontal Velocity"
                                            || $parmlist[$i] eq "Vertical Velocity"
                                            || $parmlist[$i] eq "Horizontal Layer Flow"
                                            || $parmlist[$i] eq "Density"
                                            || $parmlist[$i] eq "Habitat");
                                   if ($parm ne $parmlist[$i]) {
                                       push (@parm_divlist, $parmlist[$i]);
                                   }
                               }
                               $parm_div_cb->configure(-values => [ @parm_divlist ]);
                               if (&list_match($parm_div, @parm_divlist) == -1) {
                                   $parm_div = "None";
                               }
                               if ($parm eq "Temperature" || $parm eq "Horizontal Velocity"
                                       || $parm eq "Vertical Velocity" || $parm eq "Density"
                                       || $parm eq "Horizontal Layer Flow"
                                       || $parm eq "Habitat" || $#parm_divlist == 0) {
                                   $parm_div_label->g_pack_forget();
                                   $parm_div_cb->g_pack_forget();
                                   $parm_div = "None";
                               } else {
                                   $parm_div_label->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                                   $parm_div_cb->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                               }
                             });
    ($parm_div_label = $parm_frame->new_label(
            -text => " divided by ",
            -font => 'default',
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    ($parm_div_cb = $parm_frame->new_ttk__combobox(
            -textvariable => \$parm_div,
            -values       => [ @parm_divlist ],
            -state        => 'readonly',
            -width        => $parm_chars,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Conversion: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($conv_type_na_label = $f->new_label(
            -text => "n/a",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $conv_type_na_label->g_grid_remove();
    ($conv_type_cb = $f->new_ttk__combobox(
            -textvariable => \$conv_type,
            -values       => [ @conv_types ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $conv_type_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($conv_type eq "Custom") {
                                $custom_frame->g_grid();
                            } else {
                                $custom_frame->g_grid_remove();
                            }
                          }
                      );
    $row++;
    ($custom_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    $custom_frame->new_label(
            -text => "Multiply by: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_mult_entry = $custom_frame->new_entry(
            -textvariable => \$conv_mult,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_mult_entry->g_bind("<KeyRelease>",
                              sub { &numeric_entry_only($conv_mult_entry);
                                    my $chars = &max(7, length($conv_mult));
                                    $conv_mult_entry->configure(-width => $chars);
                                  });
    $custom_frame->new_label(
            -text => "  Then add: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_add_entry = $custom_frame->new_entry(
            -textvariable => \$conv_add,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_add_entry->g_bind("<KeyRelease>",
                             sub { &numeric_entry_only($conv_add_entry);
                                   my $chars = &max(7, length($conv_add));
                                   $conv_add_entry->configure(-width => $chars);
                                 });

    $row++;
    $f->new_label(
            -text => "Data Units: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($units_cb = $f->new_ttk__combobox(
            -textvariable => \$units,
            -values       => [ ("Celsius", "Fahrenheit") ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $units_cb->g_bind("<<ComboboxSelected>>",
                       sub { return if ($units eq $old_units);
                             $old_units = $units;
                             if ($units eq "Celsius") {
                                 if ($xmin ne "" && $xmin ne "." && $xmin ne "-") {
                                     $xmin = &floor(($xmin -32) /1.8);
                                 }
                                 if ($xmax ne "" && $xmax ne "." && $xmax ne "-") {
                                     $xmax = &ceil(($xmax  -32) /1.8);
                                 }
                                 if ($props{$id}{meta} eq "w2_profile") {
                                     if ($xmajor ne "" && $xmajor ne "." && $xmajor ne "-") {
                                         $xmajor = &round_to_int($xmajor /1.8);
                                     }
                                 }
                             } elsif ($units eq "Fahrenheit") {
                                 if ($xmin ne "" && $xmin ne "." && $xmin ne "-") {
                                     $xmin = &floor($xmin *1.8 +32);
                                 }
                                 if ($xmax ne "" && $xmax ne "." && $xmax ne "-") {
                                     $xmax = &ceil($xmax  *1.8 +32);
                                 }
                                 if ($props{$id}{meta} eq "w2_profile") {
                                     if ($xmajor ne "" && $xmajor ne "." && $xmajor ne "-") {
                                         $xmajor = &round_to_int($xmajor *1.8);
                                     }
                                 }
                             }
                             $title = "Temperature, in degrees " . $units;
                           });
    $units_cb->g_grid_remove();
    ($units_entry = $f->new_entry(
            -textvariable => \$units,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $units_entry->g_bind("<KeyRelease>",
                         sub { my $chars = &max(7, length($units));
                               $units_entry->configure(-width => $chars);
                               if ($parm eq "Temperature") {
                                   $title = "Temperature, in degrees " . $units;
                               } else {
                                   $title = $parm_short . ", in " . $units;
                               }
                             });

    $row++;
    $f->new_label(
            -text => "Data Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$title,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Data Min: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($xmin_entry = $f->new_entry(
            -textvariable => \$xmin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $xmin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $xmin_entry ]);

    $row++;
    $f->new_label(
            -text => "Data Max: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($xmax_entry = $f->new_entry(
            -textvariable => \$xmax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $xmax_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $xmax_entry ]);

    if ($props{$id}{meta} eq "w2_profile") {
        $row++;
        $f->new_label(
                -text => "Data Major: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($xmajor_entry = $f->new_entry(
                -textvariable => \$xmajor,
                -font         => 'default',
                -width        => 7,
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $xmajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($xmajor_entry, 1);
                                                    $xmajor =~ s/^-//;
                                                  });
    }

    $row++;
    $f->new_label(
            -text => "Y Axis Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($yaxis_type_cb = $f->new_ttk__combobox(
            -textvariable => \$yaxis_type,
            -values       => [ ("Elevation", "Depth") ],
            -state        => 'readonly',
            -width        => 10,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $yaxis_type_cb->g_bind("<<ComboboxSelected>>",
                           sub { if ($yaxis_type eq "Elevation") {
                                     $ymin_label->g_grid();
                                     $ymin_entry->g_grid();
                                     $ymin_units_label->g_grid();
                                     $ymax_label->configure(-text => "Elevation Max: ");
                                     $ymajor_label->configure(-text => "Elevation Major: ");
                                     $yaxis_units_label->configure(-text => "Elevation Units: ");
                                     if ($elev_base != -999 && $ymax ne "") {
                                         $ymin  = $elev_base;
                                         $ymax += $elev_base;
                                     } else {
                                         $ymin = "";
                                     }
                                 } else {
                                     $ymin_label->g_grid_remove();
                                     $ymin_entry->g_grid_remove();
                                     $ymin_units_label->g_grid_remove();
                                     $ymax_label->configure(-text => "Depth Max: ");
                                     $ymajor_label->configure(-text => "Depth Major: ");
                                     $yaxis_units_label->configure(-text => "Depth Units: ");
                                     if ($ymax ne "" && $ymin ne "" && $ymax -$ymin != 0) {
                                         $elev_base = &min($ymin, $ymax);
                                         $ymax      = abs($ymax -$ymin);
                                     } else {
                                         $ymax = "";
                                     }
                                     $ymin = 0;
                                 }
                               }
                          );

    $row++;
    ($ymin_label = $f->new_label(
            -text => "Elevation Min: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ymin_entry = $f->new_entry(
            -textvariable => \$ymin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $ymin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $ymin_entry ]);
    ($ymin_units_label = $f->new_label(
            -textvariable => \$yaxis_units,
            -font         => 'default',
            -anchor       => 'w',
            ))->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    ($ymax_label = $f->new_label(
            -text => "Elevation Max: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ymax_entry = $f->new_entry(
            -textvariable => \$ymax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $ymax_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($ymax_entry);
                                              $ymax =~ s/^-// if ($yaxis_type eq "Depth");
                                            });
    $f->new_label(
            -textvariable => \$yaxis_units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    ($ymajor_label = $f->new_label(
            -text => "Elevation Major: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ymajor_entry = $f->new_entry(
            -textvariable => \$ymajor,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $ymajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($ymajor_entry, 1);
                                                $ymajor =~ s/^-//;
                                              });
    $f->new_label(
            -textvariable => \$yaxis_units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    ($yaxis_units_label = $f->new_label(
            -text => "Elevation Units: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_ttk__combobox(
            -textvariable => \$yaxis_units,
            -values       => [ ("feet", "meters") ],
            -state        => 'readonly',
            -width        => 7,
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Color Scheme: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($cscheme_cb = $f->new_ttk__combobox(
            -textvariable => \$cscheme,
            -values       => [ @cmaps ],
            -state        => 'readonly',
            -width        => 15,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $cscheme_cb->g_bind("<<ComboboxSelected>>",
                           sub { my ($n);
                                 if ($cscheme eq "None") {
                                     $ncolors_cb->g_grid_remove();
                                     $ncolors_na_label->g_grid();
                                 } else {
                                     $ncolors_na_label->g_grid_remove();
                                     $ncolors_cb->g_grid();
                                     if ($cscheme =~ /CoolWarm|Turbo|Viridis/) {
                                         $ncolors_cb->configure(-values => [ (8 .. 100) ]);
                                     } else {
                                         $ncolors_cb->configure(-values =>
                                             [ (16, 18, 20, 22, 24, 30, 34, 38, 42, 46) ]);
                                         if ($ncolors < 16) {
                                             $ncolors = 16;
                                         } elsif ($ncolors > 46) {
                                             $ncolors = 46;
                                         } else {
                                             foreach $n (reverse @valid_nc) {
                                                 if ($ncolors >= 2 *$n) {
                                                     $ncolors = 2 *$n;
                                                     last;
                                                 }
                                             }
                                         }
                                     }
                                 }
                               });

    $row++;
    $f->new_label(
            -text => "Number of Colors: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ncolors_na_label = $f->new_label(
            -text => "n/a",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $ncolors_na_label->g_grid_remove();
    ($ncolors_cb = $f->new_ttk__combobox(
            -textvariable => \$ncolors,
            -values       => [ (16, 18, 20, 22, 24, 30, 34, 38, 42, 46) ],
            -state        => 'readonly',
            -width        => 4,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    ($jd_skip_label = $f->new_label(
            -text => "Skip Dates: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($jd_skip_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    $jd_skip_frame->new_spinbox(
            -textvariable => \$jd_skip,
            -state        => 'readonly',
            -font         => 'default',
            -from         => 0,
            -to           => 49,
            -increment    => 1,
            -width        => 4,
            -command      => sub { $jd_skip_explain = $jd_skip_opts[$jd_skip]; },
            )->g_pack(-side => 'left', -anchor => 'w');
    $jd_skip_frame->new_label(
            -textvariable => \$jd_skip_explain,
            -font         => 'default',
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $jd_skip_label->g_grid_remove();
    $jd_skip_frame->g_grid_remove();

    $row++;
    $f->new_label(
            -text => "Graph Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gtitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);

    if ($parm eq "Temperature" || $parm eq "Horizontal Velocity" || $parm eq "Vertical Velocity"
                               || $parm eq "Horizontal Layer Flow" || $parm eq "Density"
                               || $parm eq "Habitat" || $#parm_divlist == 0 || $src_type =~ /LakeCon/i) {
        $parm_div_label->g_pack_forget();
        $parm_div_cb->g_pack_forget();
    } else {
        $parm_div_label->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        $parm_div_cb->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    }
    if ($conv_type ne "Custom") {
        $custom_frame->g_grid_remove();
    }
    if (! $new_graph) {
        if ($parm eq "Temperature") {
            $units_cb->g_grid();
            $units_entry->g_grid_remove();
            $conv_type_na_label->g_grid();
            $custom_frame->g_grid_remove();
            $conv_type_cb->g_grid_remove();
            $conv_type = "None";
            $parm_div  = "None";
        } else {
            $units_cb->g_grid_remove();
            $units_entry->g_grid();
            $conv_type_na_label->g_grid_remove();
            $custom_frame->g_grid() if ($conv_type eq "Custom");
            $conv_type_cb->g_grid();
        }
        if ($jd_skip_active) {
            $jd_skip = 0 if ($jd_skip < 0 || $jd_skip > 49);
            $jd_skip_explain = $jd_skip_opts[$jd_skip];
            $jd_skip_label->g_grid();
            $jd_skip_frame->g_grid();
        }
    }
    if ($cscheme eq "None") {
        $ncolors_cb->g_grid_remove();
        $ncolors_na_label->g_grid();
    } else {
        $ncolors_na_label->g_grid_remove();
        $ncolors_cb->g_grid();
        if ($cscheme =~ /CoolWarm|Turbo|Viridis/) {
            $ncolors_cb->configure(-values => [ (8 .. 100) ]);
        } else {
            $ncolors_cb->configure(-values => [ (16, 18, 20, 22, 24, 30, 34, 38, 42, 46) ]);
            if ($ncolors < 16) {
                $ncolors = 16;
            } elsif ($ncolors > 46) {
                $ncolors = 46;
            } else {
                foreach $n (reverse @valid_nc) {
                    if ($ncolors >= 2 *$n) {
                        $ncolors = 2 *$n;
                        last;
                    }
                }
            }
        }
    }
    $f->g_grid_columnconfigure(3, -weight => 2);

    Tkx::wm_resizable($w2profile_setup_menu,0,0);
    &adjust_window_position($w2profile_setup_menu);
    $w2profile_setup_menu->g_focus;
}


sub change_w2_profile {
    my ($canv, $id, $X, $Y, $change) = @_;
    my (
        $byear, $byear_cb, $conv_add, $conv_add_entry, $conv_mult,
        $conv_mult_entry, $conv_type, $conv_type_cb, $conv_type_na_label,
        $custom_frame, $f, $frame, $ftype, $geom, $gtitle, $i, $jb,
        $jd_skip, $jd_skip_active, $jd_skip_explain, $jd_skip_frame, $jjw,
        $jw, $lcon_freq, $meta, $nbr, $nwb, $offset_frame, $ok, $ok_btn,
        $old_units, $oldparm, $oldparm_short, $parm, $parm_cb, $parm_chars,
        $parm_div, $parm_div_cb, $parm_div_label, $parm_frame, $parm_short,
        $parms_ref, $row, $segnum, $segnum_cb, $segs_ref, $segwidth,
        $src_file, $src_parm, $src_type, $tecplot, $title, $tz_offset,
        $units, $units_cb, $units_entry, $wb_txt, $xmajor, $xmajor_entry,
        $xmax, $xmax_entry, $xmin, $xmin_entry, $yr_max, $yr_min,

        @be, @bs, @cplf, @ds, @jbdn, @jd_skip_opts, @ncpl, @nspr, @nvpl,
        @parm_divlist, @parmlist, @segs, @sprf, @us, @vplf,
       );

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($w2profile_mod_menu) && Tkx::winfo_exists($w2profile_mod_menu)) {
        if ($w2profile_mod_menu->g_wm_title() eq "Modify W2 Profile") {
            $w2profile_mod_menu->g_destroy();
            undef $w2profile_mod_menu;
        }
    }
    $w2profile_mod_menu = $main->new_toplevel();
    $w2profile_mod_menu->g_wm_transient($main);
    $w2profile_mod_menu->g_wm_title("Modify W2 Profile");
    $w2profile_mod_menu->configure(-cursor => $cursor_norm);
    $w2profile_mod_menu->g_wm_geometry($geom);

#   Try to keep the nascent graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

#   De-select graph if it already exists
    if (defined($props{$id}{oldcoords})) {
        &end_select($canv, $id, 1);
    }

#   Initialize some variables.
    $nwb   = $grid{$id}{nwb};
    $nbr   = $grid{$id}{nbr};
    @bs    = @{ $grid{$id}{bs}   };
    @be    = @{ $grid{$id}{be}   };
    @us    = @{ $grid{$id}{us}   };
    @ds    = @{ $grid{$id}{ds}   };
    @jbdn  = @{ $grid{$id}{jbdn} };
    @nspr  = @{ $grid{$id}{nspr} };
    @sprf  = @{ $grid{$id}{sprf} };
    @ncpl  = @{ $grid{$id}{ncpl} };
    @cplf  = @{ $grid{$id}{cplf} };
    @nvpl  = @{ $grid{$id}{nvpl} };
    @vplf  = @{ $grid{$id}{vplf} };

    $src_type  = $props{$id}{src_type};
    $src_file  = $props{$id}{src_file};
    $segnum    = $props{$id}{seg};
    $parm      = $props{$id}{parm};
    $parm_div  = $props{$id}{parm_div};
    $units     = $props{$id}{parm_units};
    $conv_type = $props{$id}{ctype};
    $byear     = $props{$id}{byear};
    $tz_offset = $props{$id}{tz_offset};
    $jd_skip   = $props{$id}{jd_skip};

    $gtitle    = $gr_props{$id}{gtitle};

    if ($props{$id}{meta} eq "w2_profile_cmap") {
        $xmin   = $gr_props{$id}{cs_min};
        $xmax   = $gr_props{$id}{cs_max};
        $title  = $gr_props{$id}{keytitle};
    } else {
        $xmin   = $gr_props{$id}{xmin};
        $xmax   = $gr_props{$id}{xmax};
        $xmajor = $gr_props{$id}{xmajor};
        $title  = $gr_props{$id}{xtitle};
    }
    if ($conv_type =~ /Custom/) {
        ($conv_type, $conv_mult, $conv_add) = split(/,/, $conv_type);
    } else {
        $conv_mult = 1.0;
        $conv_add  = 0.0;
    }
    $yr_max = (localtime(time))[5] +1900;
    $yr_min = ($byear > $yr_max -25) ? $yr_max -25 : $byear -10;

    if ($src_type =~ /Spreadsheet/i) {
        ($ok, undef, $segs_ref, $parms_ref)
                  = &scan_w2_spr_file($w2profile_mod_menu, $src_file, "");
        if ($ok ne "okay") {
            return &pop_up_error($w2profile_mod_menu,
                                 "The specified file is not a W2 Spreadsheet file:\n$src_file");
        }
        @parmlist = @{ $parms_ref };
        @segs     = @{ $segs_ref  };
        $segnum   = $segs[$#segs] if ($segnum eq "" || &list_match($segnum, @segs) == -1);

    } elsif ($src_type =~ /Contour/i) {
        ($tecplot, undef, $jw, $parms_ref, undef, undef)
              = &scan_w2_cpl_file($w2profile_mod_menu, $src_file, $id, 0, "");
        if ($tecplot == -1) {
            return &pop_up_error($w2profile_mod_menu,
                                 "The specified file is not a W2 Contour file:\n$src_file");
        }
        if ($tecplot == 1 && $jw == 0) {   # Tecplot-type file; waterbody index unknown
            for ($jjw=1; $jjw<=$nwb; $jjw++) {
                if ($segnum >= $us[$bs[$jjw]] && $segnum <= $ds[$be[$jjw]]) {
                    $jw = $jjw;
                    last;
                }
            }
        }
        @segs = ();
        for ($jb=$bs[$jw]; $jb<=$be[$jw]; $jb++) {
            push (@segs, ($us[$jb] .. $ds[$jb]));
        }
        $segnum   = $ds[$jbdn[$jw]] if ($segnum eq "" || &list_match($segnum, @segs) == -1);
        @parmlist = @{ $parms_ref };

    } elsif ($src_type =~ /Vector/i) {
        ($ok, $parms_ref, undef, undef, undef)
                  = &scan_w2_vector_file($w2profile_mod_menu, $src_file, $id, 0);
        if ($ok ne "okay") {
            return &pop_up_error($w2profile_mod_menu,
                                 "The specified file is not a W2 Vector (w2l) file:\n$src_file");
        }
        @segs = ();
        for ($jb=1; $jb<=$nbr; $jb++) {
            push (@segs, ($us[$jb] .. $ds[$jb]));
        }
        $segnum   = $ds[$jbdn[1]] if ($segnum eq "" || &list_match($segnum, @segs) == -1);
        @parmlist = @{ $parms_ref };

    } elsif ($src_type =~ /LakeCon/i) {
        ($ftype, $src_parm, $meta, undef) = &scan_w2_rlcon_file($w2profile_mod_menu, $src_file, "");
        if ($ftype ne "lcon1") {
            return &pop_up_error($w2profile_mod_menu,
                                 "The specified file is not an acceptable\n"
                               . "W2 Lake Contour (format 1) file:\n$src_file");
        }
        ($segnum, $lcon_freq) = split(/_/, $meta);
        @segs     = ($segnum);
        @parmlist = ($src_parm);
    }
    @segs     = sort numerically @segs;
    $segwidth = &max(5, length(&max(@segs)));
    $wb_txt   = "";
    for ($jw=1; $jw<=$nwb; $jw++) {
        for ($jb=$bs[$jw]; $jb<=$be[$jw]; $jb++) {
            if ($segnum >= $us[$jb] && $segnum <= $ds[$jb]) {
                $wb_txt = " (waterbody $jw, branch $jb)";
                last;
            }
        }
        last if ($wb_txt ne "");
    }

    $jd_skip_active = 0;
    @jd_skip_opts = ("(keep all)", "(keep every other)", "(keep every 3rd)", "(keep every 4th)",
                     "(keep every 5th)",  "(keep every 6th)",  "(keep every 7th)",  "(keep every 8th)",
                     "(keep every 9th)",  "(keep every 10th)", "(keep every 11th)", "(keep every 12th)",
                     "(keep every 13th)", "(keep every 14th)", "(keep every 15th)", "(keep every 16th)",
                     "(keep every 17th)", "(keep every 18th)", "(keep every 19th)", "(keep every 20th)",
                     "(keep every 21st)", "(keep every 22nd)", "(keep every 23rd)", "(keep every 24th)",
                     "(keep every 25th)", "(keep every 26th)", "(keep every 27th)", "(keep every 28th)",
                     "(keep every 29th)", "(keep every 30th)", "(keep every 31st)", "(keep every 32nd)",
                     "(keep every 33rd)", "(keep every 34th)", "(keep every 35st)", "(keep every 36th)",
                     "(keep every 37th)", "(keep every 38th)", "(keep every 39th)", "(keep every 40th)",
                     "(keep every 41st)", "(keep every 42nd)", "(keep every 43rd)", "(keep every 44th)",
                     "(keep every 45th)", "(keep every 46th)", "(keep every 47th)", "(keep every 48th)",
                     "(keep every 49th)", "(keep every 50th)");
    if ($src_type =~ /Spreadsheet/i) {
        for ($i=1; $i<=$nspr[$jw]; $i++) {
            next if ($sprf[$i][$jw] eq "na");
            if ($sprf[$i][$jw] < 1.0) {
                $jd_skip_active = 1;
                last;
            }
        }
    } elsif ($src_type =~ /Contour/i) {
        for ($i=1; $i<=$ncpl[$jw]; $i++) {
            next if ($cplf[$i][$jw] eq "na");
            if ($cplf[$i][$jw] < 1.0) {
                $jd_skip_active = 1;
                last;
            }
        }
    } elsif ($src_type =~ /Vector/i) {
        for ($i=1; $i<=$nvpl[$jw]; $i++) {
            next if ($vplf[$i][$jw] eq "na");
            if ($vplf[$i][$jw] < 1.0) {
                $jd_skip_active = 1;
                last;
            }
        }
    } elsif ($src_type =~ /LakeCon/i) {
        $jd_skip_active = 1 if ($lcon_freq < 1.0);
    }
    $jd_skip = 0 if ($jd_skip < 0 || $jd_skip > 49);
    $jd_skip_explain = $jd_skip_opts[$jd_skip];

    $parm_chars = length($parmlist[0]);
    for ($i=1; $i<=$#parmlist; $i++) {
        $parm_chars = &max($parm_chars, length($parmlist[$i]));
    }
    $parm_chars += 2;
    $parm_short = $parm;
    if ($parm ne "Temperature") {
        $parm_short =~ s/\(ms-1\)//i;
        $parm_short =~ s/\(m3s-1\)//i;
        $parm_short =~ s/ [kmu]?g\/L\/day//i;
        $parm_short =~ s/ [kmu]?g\/m2\/day//i;
        $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
        $parm_short =~ s/ [kmu]?g\/L//i;
        $parm_short =~ s/ [kmu]?g\/m3//i;
        $parm_short =~ s/ [kmu]?g\/m\^3//i;
        $parm_short =~ s/, days//i;
        $parm_short =~ s/ days//i;
        $parm_short =~ s/,$//;
    }
    $old_units     = $units;
    $oldparm       = $parm;
    $oldparm_short = $parm_short;
    @parm_divlist  = ("None");
    for ($i=0; $i<=$#parmlist; $i++) {
        next if ($parmlist[$i] eq "Horizontal Velocity"
                  || $parmlist[$i] eq "Vertical Velocity"
                  || $parmlist[$i] eq "Horizontal Layer Flow"
                  || $parmlist[$i] eq "Density"
                  || $parmlist[$i] eq "Habitat");
        if ($parm ne $parmlist[$i]) {
            push (@parm_divlist, $parmlist[$i]);
        }
    }
    $parm_div = "None" if (&list_match($parm_div, @parm_divlist) == -1);

#   Build the menu.
    $frame = $w2profile_mod_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -command => sub { my ($modified, %parms);
                              $modified = 0;
                              %parms = ();
                              if ($change =~ /misc|base/) {
                                  $modified = 1 if ($byear     != $props{$id}{byear} ||
                                                    $tz_offset ne $props{$id}{tz_offset} ||
                                                    $jd_skip   != $props{$id}{jd_skip});
                              }
                              if ($change =~ /seg|misc/) {
                                  if ($segnum eq "" || $segnum <= 0) {
                                      return &pop_up_error($w2profile_mod_menu,
                                              "W2 segment number must be numeric and positive.");
                                  } elsif (&list_match($segnum, @segs) == -1) {
                                      return &pop_up_error($w2profile_mod_menu,
                                              "W2 segment number is inconsistent with source file.");
                                  }
                                  $modified = 1 if ($segnum != $props{$id}{seg});
                              }
                              if ($change =~ /parm|misc/) {
                                  if ($xmin eq "" || $xmax eq "") {
                                      return &pop_up_error($w2profile_mod_menu,
                                      "Please provide both a min and max for your parameter.");
                                  }
                                  if ($xmin >= $xmax) {
                                      return &pop_up_error($w2profile_mod_menu,
                                      "The minimum data value must be less than the maximum data value.");
                                  }
                                  if ($conv_type eq "Custom") {
                                      $conv_type = sprintf("Custom,%s,%s", $conv_mult, $conv_add);
                                  }
                                  $gtitle =~ s/^\s+//;
                                  $gtitle =~ s/\s+$//;
                                  if ($parm ne $props{$id}{parm} || $parm_div ne $props{$id}{parm_div}
                                       || ($parm ne "Temperature" && $units ne $props{$id}{parm_units})
                                       || $conv_type ne $props{$id}{ctype}) {
                                      $modified = 1;
                                  }
                                  if (! $modified && $parm eq "Temperature"
                                                  && $parm eq $props{$id}{parm}
                                                  && $units ne $props{$id}{parm_units}) {
                                      return &pop_up_error($w2profile_mod_menu,
                                                           "To modify just the temperature units,\n"
                                                         . "use the Graph Properties menu.");
                                  }
                                  if (! $modified &&
                                      (($props{$id}{meta} eq "w2_profile_cmap"
                                         && ($xmin != $gr_props{$id}{cs_min}
                                              || $xmax != $gr_props{$id}{cs_max})) ||
                                       ($props{$id}{meta} eq "w2_profile"
                                         && ($xmin != $gr_props{$id}{xmin}
                                              || $xmax != $gr_props{$id}{xmax}
                                              || $xmajor != $gr_props{$id}{xmajor})))) {
                                      return &pop_up_error($w2profile_mod_menu,
                                                           "To modify just the parameter limits,\n"
                                                         . "use the Graph Properties menu.");
                                  }
                                  if (! $modified && $gtitle ne $gr_props{$id}{gtitle}) {
                                      return &pop_up_error($w2profile_mod_menu,
                                                           "To modify just the graph title,\n"
                                                         . "use the Graph Properties menu.");
                                  }
                              }
                              if (! $modified) {
                                  $w2profile_mod_menu->g_bind('<Destroy>', "");
                                  $w2profile_mod_menu->g_destroy();
                                  undef $w2profile_mod_menu;
                                  &reset_bindings;
                                  return;
                              }

#                             Delete reference dataset if different segment, parameter, or units
                              if (defined($props{$id}{ref_file})
                                   && ($segnum    != $props{$id}{seg} ||
                                       $parm      ne $props{$id}{parm} ||
                                       $parm_div  ne $props{$id}{parm_div} ||
                                       $units     ne $props{$id}{parm_units} ||
                                       $conv_type ne $props{$id}{ctype})) {
                                  undef $props{$id}{ref_file};
                                  undef $gr_props{$id}{ref_data};
                              }

#                             Rebuild the dates array if different segment, jd_skip, byear, or tz_offset
                              $parms{rebuild}    = ($props{$id}{meta} eq "w2_profile" &&
                                                    ($segnum    != $props{$id}{seg}       ||
                                                     $byear     != $props{$id}{byear}     ||
                                                     $tz_offset ne $props{$id}{tz_offset} ||
                                                     $jd_skip   != $props{$id}{jd_skip})) ? 1 : 0;
                              $parms{xmin}       = $xmin;
                              $parms{xmax}       = $xmax;
                              $parms{xmajor}     = $xmajor;
                              $parms{gtitle}     = $gtitle;
                              $parms{change}     = $change;
                              $props{$id}{parms} = { %parms };

                              $props{$id}{data}       = 0;
                              $props{$id}{parm}       = $parm;
                              $props{$id}{parm_div}   = $parm_div;
                              $props{$id}{parm_units} = $units;
                              $props{$id}{ctype}      = $conv_type;
                              $props{$id}{seg}        = $segnum;
                              $props{$id}{byear}      = $byear;
                              $props{$id}{tz_offset}  = $tz_offset;
                              $props{$id}{jd_skip}    = $jd_skip;

                              $w2profile_mod_menu->g_bind('<Destroy>', "");
                              $w2profile_mod_menu->g_destroy();
                              undef $w2profile_mod_menu;
                              &reset_bindings;
                              &make_w2_profile($canv, $id, 0);
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $w2profile_mod_menu->g_bind('<Destroy>', "");
                              $w2profile_mod_menu->g_destroy();
                              undef $w2profile_mod_menu;
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Do not delete graph if this menu is destroyed by other than the Cancel button
    $w2profile_mod_menu->g_bind('<Destroy>' => sub { undef $w2profile_mod_menu;
                                                     &reset_bindings;
                                                   });

    $f = $w2profile_mod_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f->g_pack(-side => 'top');

    $row = 0;
    if ($change ne "base") {
        $f->new_label(
                -text => "Segment: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        if ($change =~ /seg|misc/) {
            ($segnum_cb = $f->new_ttk__combobox(
                    -textvariable => \$segnum,
                    -values       => [ @segs ],
                    -width        => 5,
                    ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
            $segnum_cb->g_bind("<<ComboboxSelected>>",
                                sub { $wb_txt = "";
                                      for ($jb=$bs[$jw]; $jb<=$be[$jw]; $jb++) {
                                          if ($segnum >= $us[$jb] && $segnum <= $ds[$jb]) {
                                              $wb_txt = " (waterbody $jw, branch $jb)";
                                              last;
                                          }
                                      }
                                    });
            if ($change eq "seg") {
                $f->new_label(
                        -textvariable => \$wb_txt,
                        -anchor       => 'w',
                        -font         => 'default',
                        )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);
                Tkx::wm_resizable($w2profile_mod_menu,0,0);
                $w2profile_mod_menu->g_focus;
                return;
            } else {
                $f->new_label(
                        -textvariable => \$wb_txt,
                        -anchor       => 'w',
                        -font         => 'default',
                        )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);
            }
        } else {
            $f->new_label(
                    -text => $segnum . $wb_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
        }
    }

    if ($change =~ /misc|base/) {
        $row++;
        $f->new_label(
                -text => "Base Year: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($byear_cb = $f->new_ttk__combobox(
                -textvariable => \$byear,
                -values       => [ reverse($yr_min .. $yr_max) ],
                -width        => 5,
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $byear_cb->g_bind("<<ComboboxSelected>>",
                          sub { if ($byear == $yr_min) {
                                    $yr_min -= 10;
                                    $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                }
                              });
        $f->new_label(
                -text   => " for JDAY = 1.0",
                -anchor => 'w',
                -font   => 'default',
                )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

        $row++;
        $f->new_label(
                -text => "Time Offset: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($offset_frame = $f->new_frame(
                -borderwidth => 0,
                -relief      => 'flat',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
        $offset_frame->new_ttk__combobox(
                -textvariable => \$tz_offset,
                -values       => [ @tz_offsets ],
                -justify      => 'right',
                -state        => 'readonly',
                -width        => 6,
                )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        $offset_frame->new_label(
                -text   => " time zone adjustment ",
                -anchor => 'w',
                -font   => 'default',
                )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        $offset_frame->new_button(
                -text    => "Help",
                -command => sub { &pop_up_info($w2profile_mod_menu,
                                        "The time offset allows the user to add or subtract a time\n"
                                      . "offset if the W2 model was run with a non-local time zone.\n\n"
                                      . "For example, if W2 was run in UTC but the local time zone\n"
                                      . "is PST, an offset of -08:00 would convert the model date/time\n"
                                      . "to a local standard time of PST. This offset does not make\n"
                                      . "any adjustments related to daylight saving time. In general,\n"
                                      . "W2 is best run in the local standard time.\n\n"
                                      . "Leave the time offset at +00:00 for no adjustment.",
                                        "Time Offset Notice");
                                },
                )->g_pack(-side => 'left', -anchor => 'w', -padx => 2);

        if ($jd_skip_active) {
            $row++;
            $f->new_label(
                    -text => "Skip Dates: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($jd_skip_frame = $f->new_frame(
                    -borderwidth => 0,
                    -relief      => 'flat',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
            $jd_skip_frame->new_spinbox(
                    -textvariable => \$jd_skip,
                    -state        => 'readonly',
                    -font         => 'default',
                    -from         => 0,
                    -to           => 49,
                    -increment    => 1,
                    -width        => 4,
                    -command      => sub { $jd_skip_explain = $jd_skip_opts[$jd_skip]; },
                    )->g_pack(-side => 'left', -anchor => 'w');
            $jd_skip_frame->new_label(
                    -textvariable => \$jd_skip_explain,
                    -font         => 'default',
                    )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        }
        if ($change eq "base") {
            $f->g_grid_columnconfigure(3, -weight => 2);
            Tkx::wm_resizable($w2profile_mod_menu,0,0);
            $w2profile_mod_menu->g_focus;
            return;
        }
    }

    $row++;
    $f->new_label(
            -text => "Parameter: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($parm_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    ($parm_cb = $parm_frame->new_ttk__combobox(
            -textvariable => \$parm,
            -values       => [ @parmlist ],
            -state        => 'readonly',
            -width        => $parm_chars,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $parm_cb->g_bind("<<ComboboxSelected>>",
                      sub { my ($i);
                            return if ($parm eq $oldparm);
                            $parm_short = $parm;
                            if ($parm eq "Temperature") {
                                $units = "Celsius" if ($units !~ /(Celsius|Fahrenheit)/);
                                $title = "Temperature, in degrees " . $units;
                                $units_cb->g_grid();
                                $units_entry->g_grid_remove();
                                $conv_type_na_label->g_grid();
                                $custom_frame->g_grid_remove();
                                $conv_type_cb->g_grid_remove();
                                $conv_type = "None";
                            } else {
                                $units = "";
                                $parm_short =~ s/\(ms-1\)//i;
                                $parm_short =~ s/\(m3s-1\)//i;
                                $parm_short =~ s/ [kmu]?g\/L\/day//i;
                                $parm_short =~ s/ [kmu]?g\/m2\/day//i;
                                $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
                                $parm_short =~ s/ [kmu]?g\/L//i;
                                $parm_short =~ s/ [kmu]?g\/m3//i;
                                $parm_short =~ s/ [kmu]?g\/m\^3//i;
                                $parm_short =~ s/, days//i;
                                $parm_short =~ s/ days//i;
                                $parm_short =~ s/,$//;
                                if ($parm eq "Horizontal Velocity" || $parm eq "Vertical Velocity") {
                                    $units = "m/s";
                                    $title = $parm_short . ", in m/s";
                                } elsif ($parm eq "Horizontal Layer Flow") {
                                    $units = "m3/s";
                                    $title = $parm_short . ", in m3/s";
                                } elsif ($parm eq "Density") {
                                    $units = "kg/m3";
                                    $title = $parm_short . ", in kg/m3";
                                } else {
                                    $title = $parm_short . ", in ";
                                }
                                $units_cb->g_grid_remove();
                                $units_entry->g_grid();
                                $conv_type_na_label->g_grid_remove();
                                $custom_frame->g_grid() if ($conv_type eq "Custom");
                                $conv_type_cb->g_grid();
                            }
                            if ($gtitle eq "") {
                               if ($props{$id}{meta} eq "w2_profile_cmap") {
                                   $gtitle = ucfirst($parm_short) . " Colormap";
                               } else {
                                   $gtitle = ucfirst($parm_short) . " Profile";
                               }
                            } else {
                                if (index(lc($gtitle), lc($oldparm_short)) > -1) {
                                    $gtitle =~ s/$oldparm_short/$parm_short/i;
                                }
                            }
                            $old_units     = $units;
                            $oldparm       = $parm;
                            $oldparm_short = $parm_short;
                            @parm_divlist  = ("None");
                            for ($i=0; $i<=$#parmlist; $i++) {
                                next if ($parmlist[$i] eq "Horizontal Velocity"
                                         || $parmlist[$i] eq "Vertical Velocity"
                                         || $parmlist[$i] eq "Horizontal Layer Flow"
                                         || $parmlist[$i] eq "Density"
                                         || $parmlist[$i] eq "Habitat");
                                if ($parm ne $parmlist[$i]) {
                                    push (@parm_divlist, $parmlist[$i]);
                                }
                            }
                            $parm_div_cb->configure(-values => [ @parm_divlist ]);
                            if (&list_match($parm_div, @parm_divlist) == -1) {
                                $parm_div = "None";
                            }
                            if ($parm eq "Temperature" || $parm eq "Horizontal Velocity"
                                    || $parm eq "Vertical Velocity" || $parm eq "Density"
                                    || $parm eq "Horizontal Layer Flow"
                                    || $parm eq "Habitat" || $#parm_divlist == 0) {
                                $parm_div_label->g_pack_forget();
                                $parm_div_cb->g_pack_forget();
                                $parm_div = "None";
                            } else {
                                $parm_div_label->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                                $parm_div_cb->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                            }
                          });
    ($parm_div_label = $parm_frame->new_label(
            -text => " divided by ",
            -font => 'default',
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    ($parm_div_cb = $parm_frame->new_ttk__combobox(
            -textvariable => \$parm_div,
            -values       => [ @parm_divlist ],
            -state        => 'readonly',
            -width        => $parm_chars,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Conversion: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($conv_type_na_label = $f->new_label(
            -text => "n/a",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $conv_type_na_label->g_grid_remove();
    ($conv_type_cb = $f->new_ttk__combobox(
            -textvariable => \$conv_type,
            -values       => [ @conv_types ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $conv_type_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($conv_type eq "Custom") {
                                $custom_frame->g_grid();
                            } else {
                                $custom_frame->g_grid_remove();
                            }
                          }
                      );
    $row++;
    ($custom_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    $custom_frame->new_label(
            -text => "Multiply by: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_mult_entry = $custom_frame->new_entry(
            -textvariable => \$conv_mult,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_mult_entry->g_bind("<KeyRelease>",
                              sub { &numeric_entry_only($conv_mult_entry);
                                    my $chars = &max(7, length($conv_mult));
                                    $conv_mult_entry->configure(-width => $chars);
                                  });
    $custom_frame->new_label(
            -text => "  Then add: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_add_entry = $custom_frame->new_entry(
            -textvariable => \$conv_add,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_add_entry->g_bind("<KeyRelease>",
                             sub { &numeric_entry_only($conv_add_entry);
                                   my $chars = &max(7, length($conv_add));
                                   $conv_add_entry->configure(-width => $chars);
                                 });

    $row++;
    $f->new_label(
            -text => "Data Units: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($units_cb = $f->new_ttk__combobox(
            -textvariable => \$units,
            -values       => [ ("Celsius", "Fahrenheit") ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $units_cb->g_bind("<<ComboboxSelected>>",
                       sub { return if ($units eq $old_units);
                             $old_units = $units;
                             if ($units eq "Celsius") {
                                 if ($xmin ne "" && $xmin ne "." && $xmin ne "-") {
                                     $xmin = &floor(($xmin -32) /1.8);
                                 }
                                 if ($xmax ne "" && $xmax ne "." && $xmax ne "-") {
                                     $xmax = &ceil(($xmax  -32) /1.8);
                                 }
                                 if ($props{$id}{meta} eq "w2_profile") {
                                     if ($xmajor ne "" && $xmajor ne "." && $xmajor ne "-") {
                                         $xmajor = &round_to_int($xmajor /1.8);
                                     }
                                 }
                             } elsif ($units eq "Fahrenheit") {
                                 if ($xmin ne "" && $xmin ne "." && $xmin ne "-") {
                                     $xmin = &floor($xmin *1.8 +32);
                                 }
                                 if ($xmax ne "" && $xmax ne "." && $xmax ne "-") {
                                     $xmax = &ceil($xmax  *1.8 +32);
                                 }
                                 if ($props{$id}{meta} eq "w2_profile") {
                                     if ($xmajor ne "" && $xmajor ne "." && $xmajor ne "-") {
                                         $xmajor = &round_to_int($xmajor *1.8);
                                     }
                                 }
                             }
                             $title = "Temperature, in degrees " . $units;
                           });
    $units_cb->g_grid_remove();
    ($units_entry = $f->new_entry(
            -textvariable => \$units,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $units_entry->g_bind("<KeyRelease>",
                         sub { my $chars = &max(7, length($units));
                               $units_entry->configure(-width => $chars);
                               if ($parm eq "Temperature") {
                                   $title = "Temperature, in degrees " . $units;
                               } else {
                                   $title = $parm_short . ", in " . $units;
                               }
                             });

    $row++;
    $f->new_label(
            -text => "Data Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$title,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Data Min: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($xmin_entry = $f->new_entry(
            -textvariable => \$xmin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $xmin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $xmin_entry ]);

    $row++;
    $f->new_label(
            -text => "Data Max: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($xmax_entry = $f->new_entry(
            -textvariable => \$xmax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $xmax_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $xmax_entry ]);

    if ($props{$id}{meta} eq "w2_profile") {
        $row++;
        $f->new_label(
                -text => "Data Major: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($xmajor_entry = $f->new_entry(
                -textvariable => \$xmajor,
                -font         => 'default',
                -width        => 7,
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $xmajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($xmajor_entry, 1);
                                                    $xmajor =~ s/^-//;
                                                  });
    }

    $row++;
    $f->new_label(
            -text => "Graph Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gtitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);

    if ($parm eq "Temperature" || $parm eq "Horizontal Velocity" || $parm eq "Vertical Velocity"
                               || $parm eq "Horizontal Layer Flow" || $parm eq "Density"
                               || $parm eq "Habitat" || $#parm_divlist == 0) {
        $parm_div_label->g_pack_forget();
        $parm_div_cb->g_pack_forget();
    } else {
        $parm_div_label->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        $parm_div_cb->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    }
    if ($conv_type ne "Custom") {
        $custom_frame->g_grid_remove();
    }
    if ($parm eq "Temperature") {
        $units_cb->g_grid();
        $units_entry->g_grid_remove();
        $conv_type_na_label->g_grid();
        $custom_frame->g_grid_remove();
        $conv_type_cb->g_grid_remove();
        $conv_type = "None";
        $parm_div  = "None";
    } else {
        $units_cb->g_grid_remove();
        $units_entry->g_grid();
        $conv_type_na_label->g_grid_remove();
        $custom_frame->g_grid() if ($conv_type eq "Custom");
        $conv_type_cb->g_grid();
    }
    $f->g_grid_columnconfigure(3, -weight => 2);

    Tkx::wm_resizable($w2profile_mod_menu,0,0);
    &adjust_window_position($w2profile_mod_menu);
    $w2profile_mod_menu->g_focus;
}


sub edit_w2_profile_matrix {
    my ($canv, $id) = @_;
    my (
        $add_blank_btn, $add_btn, $all_btn, $all_txt, $avail_datelist,
        $avail_fr, $avail_lbox, $avail_sbar, $blank_frame, $box_h, $box_w,
        $c, $choose_frame, $chosen_datelist, $chosen_fr, $chosen_frame,
        $chosen_lbox, $chosen_sbar, $color, $cscheme, $down_btn, $down_img,
        $f, $frame, $geom, $gs_fmt, $gs_pos, $gtitle, $i, $label,
        $legend_canv, $link_id, $match_label, $max_cols, $max_rows, $nb,
        $ncols, $ndates, $new_graph, $nn, $none_btn, $none_label, $nrows,
        $ok_btn, $ph, $position, $position_cb, $preview_canv, $pw, $r,
        $remove_blank_btn, $remove_btn, $row, $sumb, $txt, $txt_color,
        $up_btn, $up_img, $X, $x1, $x2, $xa, $xmajor, $xmajor_entry,
        $xmajor_frame, $xp, $xunits, $Y, $y1, $y2, $ya, $ymajor,
        $ymajor_entry, $ymajor_frame, $yp,

        @avail_dates, @blanks, @chosen_dates, @cmaps, @include_date,
        @matrix_datelist,

        %grid_tmp, %profile_tmp,
       );

    ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $geom = sprintf("+%d+%d", $X+$x1+30, $Y+$y1+50);

    if (defined($w2profile_matrix_menu) && Tkx::winfo_exists($w2profile_matrix_menu)) {
        if ($w2profile_matrix_menu->g_wm_title() eq "Add or Edit W2 Profile Matrix") {
            $w2profile_matrix_menu->g_destroy();
            undef $w2profile_matrix_menu;
        }
    }
    $w2profile_matrix_menu = $main->new_toplevel();
    $w2profile_matrix_menu->g_wm_transient($main);
    $w2profile_matrix_menu->g_wm_title("Add or Edit W2 Profile Matrix");
    $w2profile_matrix_menu->configure(-cursor => $cursor_norm);
    $w2profile_matrix_menu->g_wm_geometry($geom);

#   Try to keep the nascent graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

#   Retrieve parameter values if this graph already exists.
#   Or, populate parameters from parent graph.
    $new_graph = (! defined($props{$id}{files})) ? 1 : 0;
    if ($new_graph) {
        $link_id = $props{$id}{link_id};
        &end_select($canv, $link_id, 1);
        $canv->itemconfigure($id, -state => 'normal');

        %grid_tmp                 = %{ $grid{$link_id} };
        $grid{$id}                = { %grid_tmp };
        %profile_tmp              = %{ $gr_props{$link_id} };
        $gr_props{$id}            = { %profile_tmp };
        $gr_props{$id}{redraw}    = 1;
        $gr_props{$id}{gs_size}   = $gr_props{$id}{gs_size} -2;
        $gr_props{$id}{gs_weight} = 'normal';
        $gr_props{$id}{gs_pos}    = "Top Left";
        $gr_props{$id}{gs_fmt}    = "DD-Mon-YYYY HH:mm";
        $gr_props{$id}{gs_color}  = "black";
        $gr_props{$id}{gs_edge}   = 0;
        $gr_props{$id}{gs_edgec}  = "black";
        $gr_props{$id}{gs_fill}   = 1;
        $gr_props{$id}{gs_fillc}  = "white";

        $props{$id}{files}        = 1;
        $props{$id}{data}         = 1;
        $props{$id}{con_file}     = $props{$link_id}{con_file};
        $props{$id}{bth_file}     = $props{$link_id}{bth_file};
        $props{$id}{src_type}     = $props{$link_id}{src_type};
        $props{$id}{src_file}     = $props{$link_id}{src_file};
        $props{$id}{src_lines}    = $props{$link_id}{src_lines};
        $props{$id}{tplot}        = $props{$link_id}{tplot};
        $props{$id}{parm}         = $props{$link_id}{parm};
        $props{$id}{parm_div}     = $props{$link_id}{parm_div};
        $props{$id}{parm_units}   = $props{$link_id}{parm_units};
        $props{$id}{ctype}        = $props{$link_id}{ctype};
        $props{$id}{seg}          = $props{$link_id}{seg};
        $props{$id}{byear}        = $props{$link_id}{byear};
        $props{$id}{tz_offset}    = $props{$link_id}{tz_offset};
        $props{$id}{jd_skip}      = $props{$link_id}{jd_skip};
        $props{$id}{ref_file}     = $props{$link_id}{ref_file};
        $props{$id}{ref_ctype}    = $props{$link_id}{ref_ctype};
        $props{$id}{ref_tol}      = $props{$link_id}{ref_tol};
        $props{$id}{ref_color}    = $props{$link_id}{ref_color};
        $props{$id}{ref_size}     = $props{$link_id}{ref_size};
        $props{$id}{ref_linew}    = $props{$link_id}{ref_linew};
        $props{$id}{ref_hide}     = 0;
        $props{$id}{oldcoords}    = $props{$id}{coordlist};

        $gtitle       = "Profile Matrix";
        @chosen_dates = ();
        undef %grid_tmp;
        undef %profile_tmp;
    } else {
        &end_select($canv, $id, 1);
        $link_id      = $props{$id}{link_id};
        $gtitle       = $gr_props{$id}{gtitle};
        @chosen_dates = @{ $gr_props{$id}{pdates} };
        @blanks       = @{ $gr_props{$id}{blanks} };
    }
    $xmajor = $gr_props{$id}{xmajor};
    $ymajor = $gr_props{$id}{ymajor};
    $gs_pos = $gr_props{$id}{gs_pos};
    $gs_fmt = $gr_props{$id}{gs_fmt};

#   Get a list of dates where modeled and measured profiles match within set tolerance
    @matrix_datelist = &build_matrix_match_list($id);
    @include_date    = (0) x @matrix_datelist;
    $ndates          = $#matrix_datelist +1;
    if ($ndates <= 1) {
        $w2profile_matrix_menu->g_destroy();
        undef $w2profile_matrix_menu;
        if ($new_graph) {
            $canv->delete("graph" . $id);
            delete $props{$id};
            delete $gr_props{$id};
            delete $grid{$id};
        }
        &reset_bindings;
        if ($ndates == 0) {
            return &pop_up_error($main, "Error -- No matching dates for\n"
                                      . "modeled and measured profiles.");
        } elsif ($ndates == 1) {
            return &pop_up_error($main, "Error -- Only one matching date\n"
                                      . "for modeled and measured profiles.");
        }
    }
    if ($new_graph) {
        if ($#matrix_datelist >= 5) {
            $nrows = 2;
            $ncols = 3;
        } elsif ($#matrix_datelist >= 3) {
            $nrows = 2;
            $ncols = 2;
        } else {
            $nrows = 1;
            $ncols = $#matrix_datelist +1;
        }
        @blanks = (0) x ($nrows *$ncols);
    } else {
        ($nrows, $ncols) = split(/x/, $gr_props{$id}{matrix});
    }
    $max_rows = 15;
    $max_cols = 25;
    $position =  1;

#   Color scheme.  Keep original or turn off (None).
    $cscheme = "None";
    @cmaps   = ("None");
    if ($gr_props{$id}{add_cs}) {
        if ($gr_props{$id}{cscheme2} eq "None") {
            $cscheme = $gr_props{$id}{cscheme1};
        } else {
            $cscheme = $gr_props{$id}{cscheme1} . " to " . $gr_props{$id}{cscheme2};
        }
        push (@cmaps, $cscheme);
    } elsif ($link_id ne "" && $link_id >= 0) {
        if (defined($gr_props{$link_id}{add_cs}) && $gr_props{$link_id}{add_cs}) {
            if ($gr_props{$link_id}{cscheme2} eq "None") {
                $cscheme = $gr_props{$link_id}{cscheme1};
            } else {
                $cscheme = $gr_props{$link_id}{cscheme1} . " to " . $gr_props{$link_id}{cscheme2};
            }
            push (@cmaps, $cscheme);
            $cscheme = "None";
        }
    }

#   Images for some buttons
    $up_img   = Tkx::image_create_photo(-file => "${prog_path}images/up12.png");
    $down_img = Tkx::image_create_photo(-file => "${prog_path}images/down12.png");

#   Set up the menu
    $frame = $w2profile_matrix_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -state   => ($new_graph || $#chosen_dates < 0) ? 'disabled' : 'normal',
            -command => sub { my ($nc, $nr, @tmp);
                              if ($#chosen_dates < 0) {
                                  return &pop_up_error($w2profile_matrix_menu,
                                                       "No dates selected for the\n"
                                                     . "the profile matrix. Try again.");
                              }
                              if ($new_graph) {
                                  $gr_props{$id}{redraw} = 1;
                              } else {
                                  ($nr, $nc) = split(/x/, $gr_props{$id}{matrix});
                                  if ($nr != $nrows || $nc != $ncols) {
                                      $gr_props{$id}{redraw} = 1;
                                  } elsif (($gr_props{$id}{add_cs} == 1 && $cscheme eq "None") ||
                                           ($gr_props{$id}{add_cs} == 0 && $cscheme ne "None")) {
                                      $gr_props{$id}{redraw} = 1;
                                  } else {
                                      @tmp = @{ $gr_props{$id}{blanks} };
                                      for ($nn=0; $nn<=$#blanks; $nn++) {
                                          if ($tmp[$nn] != $blanks[$nn]) {
                                              $gr_props{$id}{redraw} = 1;
                                              last;
                                          }
                                      }
                                      if (! $gr_props{$id}{redraw}) {
                                          @tmp = @{ $gr_props{$id}{pdates} };
                                          if ($#tmp != $#chosen_dates) {
                                              $gr_props{$id}{redraw} = 1;
                                          } else {
                                              for ($nn=0; $nn<=$#chosen_dates; $nn++) {
                                                  if ($tmp[$nn] != $chosen_dates[$nn]) {
                                                      $gr_props{$id}{redraw} = 1;
                                                      last;
                                                  }
                                              }
                                          }
                                      }
                                  }
                              }
                              $gr_props{$id}{matrix} = $nrows . "x" . $ncols;
                              $gr_props{$id}{pdates} = [ @chosen_dates ];
                              $gr_props{$id}{blanks} = [ @blanks       ];
                              if ($new_graph) {
                                  $gtitle =~ s/^\s+//;
                                  $gtitle =~ s/\s+$//;
                                  $gr_props{$id}{gtitle} = $gtitle;
                                  $gr_props{$id}{xmajor} = $xmajor;
                                  $gr_props{$id}{ymajor} = $ymajor;
                                  $gr_props{$id}{gs_pos} = $gs_pos;
                                  $gr_props{$id}{gs_fmt} = $gs_fmt;
                                  $gr_props{$id}{add_cs} = ($cscheme eq "None") ? 0 : 1;
                                  $props{$id}{gnum}      = ++$graph_num;
                              }
                              $w2profile_matrix_menu->g_bind('<Destroy>', "");
                              $w2profile_matrix_menu->g_destroy();
                              undef $w2profile_matrix_menu;
                              &reset_bindings;

                              &make_w2_profile($canv, $id, 1);
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $w2profile_matrix_menu->g_bind('<Destroy>', "");
                              $w2profile_matrix_menu->g_destroy();
                              undef $w2profile_matrix_menu;
                              if ($new_graph) {
                                  $canv->delete("graph" . $id);
                                  delete $props{$id};
                                  delete $gr_props{$id};
                                  delete $grid{$id};
                                  $graph_num--;
                              }
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Delete a new graph if this menu is destroyed by other than the Cancel button
    $w2profile_matrix_menu->g_bind('<Destroy>' => sub { undef $w2profile_matrix_menu;
                                                        if ($new_graph) {
                                                            $canv->delete("graph" . $id);
                                                            delete $props{$id}; 
                                                            delete $gr_props{$id}; 
                                                            delete $grid{$id}; 
                                                            $graph_num--;
                                                        }
                                                        &reset_bindings;
                                                      });

    ($f = $w2profile_matrix_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "Parameter: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    if ($props{$id}{parm_div} ne "None" &&
        $props{$id}{parm} !~ /^(Temperature|Horizontal Velocity|Vertical Velocity)$/ &&
        $props{$id}{parm} !~ /^(Horizontal Layer Flow|Density|Habitat)$/) {
        $f->new_label(
                -text => $props{$id}{parm} . " divided by " . $props{$id}{parm_div},
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    } else {
        $f->new_label(
                -text => $props{$id}{parm},
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    }

    $row++;
    $f->new_label(
            -text => "Rows in Matrix: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_spinbox(
            -textvariable => \$nrows,
            -state        => 'readonly',
            -font         => 'default',
            -from         => 1,
            -to           => $max_rows,
            -increment    => 1,
            -width        => 3,
            -command      => sub { my ($dt, $j, $status, @entries, @tmp);
                                   $match_label = $ndates . " dates available. "
                                                . $nrows * $ncols . " positions in matrix.";
                                   if ($nrows *$ncols != $#blanks +1) {
                                       if ($nrows *$ncols > $#blanks +1) {
                                           @tmp = (0) x ($nrows *$ncols -($#blanks +1));
                                           push (@blanks, @tmp);
                                       } else {
                                           @entries = Tkx::SplitList($chosen_datelist);
                                           for ($i=$#entries; $i>=0; $i--) {
                                               ($nn = $entries[$i]) =~ s/^.* \((\d+)\)$/$1/;
                                               last if ($nn <= $nrows *$ncols);
                                               $chosen_lbox->delete($i);
                                               next if ($blanks[$nn-1]);
                                               ($dt = $entries[$i]) =~ s/^(.*) \(\d+\)$/$1/;
                                               $dt = &format_datelabel($dt, "YYYYMMDDHHmm");
                                               $j  = &list_match($dt, @chosen_dates);
                                               if ($j >= 0) {
                                                   push (@avail_dates, $chosen_dates[$j]);
                                                   splice(@chosen_dates, $j, 1);
                                               }
                                           }
                                           splice(@blanks, ($nrows *$ncols));
                                           $avail_datelist = "";
                                           @avail_dates    = sort @avail_dates;
                                           for ($i=0; $i<=$#avail_dates; $i++) {
                                               $avail_lbox->insert('end', &date2datelabel($avail_dates[$i],
                                                                                     "Mon-DD-YYYY HH:mm"));
                                           }
                                       }
                                   }
                                   $nb = $sumb = 0;
                                   $ph = &max(90, 8+$nrows *14);
                                   $preview_canv->delete("box");
                                   $preview_canv->configure(-height => $ph);
                                   $box_h = &min(20, int(($ph -8)/$nrows));
                                   $box_w = &min(20, int(($pw -12)/$ncols));
                                   $xa    = int(($pw -$ncols *$box_w)/2.) +3;
                                   $ya    = int(($ph -$nrows *$box_h)/2.) +3;
                                   for ($r=0; $r<$nrows; $r++) {
                                       for ($c=0; $c<$ncols; $c++) {
                                           if ($blanks[$nb]) {
                                               $sumb++;
                                               $color     = "gray50";
                                               $txt_color = "white";
                                           } else {
                                               if ($nb <= $#chosen_dates +$sumb) {
                                                  $color = "white";
                                               } else {
                                                  $color = "gray80";
                                               }
                                               $txt_color = "black";
                                           }
                                           $xp = $xa +$c *$box_w;
                                           $yp = $ya +$r *$box_h;
                                           $preview_canv->create_rectangle(
                                                               $xp, $yp, $xp+$box_w, $yp+$box_h,
                                                               -outline => &get_rgb_code("black"),
                                                               -width   => 1,
                                                               -fill    => &get_rgb_code($color),
                                                               -tags    => "box box" . $nb,
                                                               );
                                           $preview_canv->create_text($xp+$box_w/2, $yp+$box_h/2,
                                                               -anchor => 'c',
                                                               -text   => $nb +1,
                                                               -fill   => &get_rgb_code($txt_color),
                                                               -angle  => 0,
                                                               -tags   => "box boxtxt" . $nb,
                                                               -font   => [-family     => $default_family,
                                                                           -size       => $default_size -2,
                                                                           -weight     => 'normal',
                                                                           -slant      => 'roman',
                                                                           -underline  => 0,
                                                                           -overstrike => 0,
                                                                          ]);
                                           $nb++;
                                       }
                                   }
                                   $all_txt = ($nrows*$ncols-$sumb >= $#matrix_datelist+1) ? "All" : "Fill";
                                   if ($nrows *$ncols -$sumb > $#chosen_dates +1
                                           && $#chosen_dates < $#matrix_datelist) {
                                       $all_btn->configure(-state => 'normal');
                                   } else {
                                       $all_btn->configure(-state => 'disabled');
                                   }
                                   $none_label->g_grid() if ($#chosen_dates +&sum(@blanks) < 0);
                                   $position_cb->configure(-values => [ 1 .. ($nrows *$ncols) ]);
                                   $position = &min($position, ($nrows *$ncols));
                                   $status = ($#chosen_dates >= 0) ? 'normal' : 'disabled';
                                   $ok_btn->configure(-state => $status);
                                 },
            )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Columns in Matrix: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_spinbox(
            -textvariable => \$ncols,
            -state        => 'readonly',
            -font         => 'default',
            -from         => 1,
            -to           => $max_cols,
            -increment    => 1,
            -width        => 3,
            -command      => sub { my ($dt, $j, $status, @entries, @tmp);
                                   $match_label = $ndates . " dates available. "
                                                . $nrows * $ncols . " positions in matrix.";
                                   if ($nrows *$ncols != $#blanks +1) {
                                       if ($nrows *$ncols > $#blanks +1) {
                                           @tmp = (0) x ($nrows *$ncols -($#blanks +1));
                                           push (@blanks, @tmp);
                                       } else {
                                           @entries = Tkx::SplitList($chosen_datelist);
                                           for ($i=$#entries; $i>=0; $i--) {
                                               ($nn = $entries[$i]) =~ s/^.* \((\d+)\)$/$1/;
                                               last if ($nn <= $nrows *$ncols);
                                               $chosen_lbox->delete($i);
                                               next if ($blanks[$nn-1]);
                                               ($dt = $entries[$i]) =~ s/^(.*) \(\d+\)$/$1/;
                                               $dt = &format_datelabel($dt, "YYYYMMDDHHmm");
                                               $j  = &list_match($dt, @chosen_dates);
                                               if ($j >= 0) {
                                                   push (@avail_dates, $chosen_dates[$j]);
                                                   splice(@chosen_dates, $j, 1);
                                               }
                                           }
                                           splice(@blanks, ($nrows *$ncols));
                                           $avail_datelist = "";
                                           @avail_dates    = sort @avail_dates;
                                           for ($i=0; $i<=$#avail_dates; $i++) {
                                               $avail_lbox->insert('end', &date2datelabel($avail_dates[$i],
                                                                                     "Mon-DD-YYYY HH:mm"));
                                           }
                                       }
                                   }
                                   $nb = $sumb = 0;
                                   $pw = &max(320, 12+$ncols *18);
                                   $preview_canv->delete("box");
                                   $preview_canv->configure(-width => $pw);
                                   $box_h = &min(20, int(($ph -8)/$nrows));
                                   $box_w = &min(20, int(($pw -12)/$ncols));
                                   $xa    = int(($pw -$ncols *$box_w)/2.) +3;
                                   $ya    = int(($ph -$nrows *$box_h)/2.) +3;
                                   for ($r=0; $r<$nrows; $r++) {
                                       for ($c=0; $c<$ncols; $c++) {
                                           if ($blanks[$nb]) {
                                               $sumb++;
                                               $color     = "gray50";
                                               $txt_color = "white";
                                           } else {
                                               if ($nb <= $#chosen_dates +$sumb) {
                                                  $color = "white";
                                               } else {
                                                  $color = "gray80";
                                               }
                                               $txt_color = "black";
                                           }
                                           $xp = $xa +$c *$box_w;
                                           $yp = $ya +$r *$box_h;
                                           $preview_canv->create_rectangle(
                                                               $xp, $yp, $xp+$box_w, $yp+$box_h,
                                                               -outline => &get_rgb_code("black"),
                                                               -width   => 1,
                                                               -fill    => &get_rgb_code($color),
                                                               -tags    => "box box" . $nb,
                                                               );
                                           $preview_canv->create_text($xp+$box_w/2, $yp+$box_h/2,
                                                               -anchor => 'c',
                                                               -text   => $nb +1,
                                                               -fill   => &get_rgb_code($txt_color),
                                                               -angle  => 0,
                                                               -tags   => "box boxtxt" . $nb,
                                                               -font   => [-family     => $default_family,
                                                                           -size       => $default_size -2,
                                                                           -weight     => 'normal',
                                                                           -slant      => 'roman',
                                                                           -underline  => 0,
                                                                           -overstrike => 0,
                                                                          ]);
                                           $nb++;
                                       }
                                   }
                                   $all_txt = ($nrows*$ncols-$sumb >= $#matrix_datelist+1) ? "All" : "Fill";
                                   if ($nrows *$ncols -$sumb > $#chosen_dates +1
                                           && $#chosen_dates < $#matrix_datelist) {
                                       $all_btn->configure(-state => 'normal');
                                   } else {
                                       $all_btn->configure(-state => 'disabled');
                                   }
                                   $none_label->g_grid() if ($#chosen_dates +&sum(@blanks) < 0);
                                   $position_cb->configure(-values => [ 1 .. ($nrows *$ncols) ]);
                                   $position = &min($position, ($nrows *$ncols));
                                   $status = ($#chosen_dates >= 0) ? 'normal' : 'disabled';
                                   $ok_btn->configure(-state => $status);
                                 },
            )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    $row++;
    $match_label = $ndates . " dates available. " . $nrows * $ncols . " positions in matrix.";
    $f->new_label(
            -text => "Profile Matches: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$match_label,
            -font => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Blank Spaces: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($blank_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $blank_frame->new_label(
            -text => "Position:",
            -font => 'default',
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    ($position_cb = $blank_frame->new_ttk__combobox(
            -textvariable => \$position,
            -values       => [ 1 .. ($nrows *$ncols) ],
            -state        => 'readonly',
            -width        => 3,
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    ($add_blank_btn = $blank_frame->new_button(
            -text    => "Add",
            -state   => 'normal',
            -command => sub { my ($j, $status);
                              return if ($blanks[$position-1] == 1);
                              $none_label->g_grid_remove() if ($#chosen_dates +&sum(@blanks) < 0);
                              $blanks[$position-1] = 1;
                              if (&sum(@blanks) +$#chosen_dates +1 > $nrows *$ncols) {
                                  push (@avail_dates, pop @chosen_dates);
                              }
                              $chosen_lbox->delete($position-1,'end');
                              $avail_datelist = "";
                              @avail_dates    = sort @avail_dates;
                              for ($i=0; $i<=$#avail_dates; $i++) {
                                  $avail_lbox->insert('end', &date2datelabel($avail_dates[$i],
                                                                             "Mon-DD-YYYY HH:mm"));
                              }
                              $sumb = 0;
                              for ($nn=0; $nn<$nrows *$ncols; $nn++) {
                                  $sumb++ if ($blanks[$nn]);
                                  if ($nn >= $position-1) {
                                      $label = " (" . ($nn+1) . ")";
                                      if ($blanks[$nn]) {
                                          $chosen_lbox->insert('end', "Blank" . $label);
                                          $preview_canv->itemconfigure("box" . $nn,
                                                                       -fill => &get_rgb_code("gray50"));
                                          $preview_canv->itemconfigure("boxtxt" . $nn,
                                                                       -fill => &get_rgb_code("white"));
                                      } else {
                                          if ($#chosen_dates >= 0 && $#chosen_dates +$sumb >= $nn) {
                                              $label = &date2datelabel($chosen_dates[$nn-$sumb],
                                                                       "Mon-DD-YYYY HH:mm") . $label;
                                              $chosen_lbox->insert('end', $label);
                                              $preview_canv->itemconfigure("box" . $nn,
                                                                       -fill => &get_rgb_code("white"));
                                          } else {
                                              $preview_canv->itemconfigure("box" . $nn,
                                                                       -fill => &get_rgb_code("gray80"));
                                          }
                                          $preview_canv->itemconfigure("boxtxt" . $nn,
                                                                       -fill => &get_rgb_code("black"));
                                      }
                                  }
                              }
                              $all_txt = ($nrows *$ncols -$sumb >= $#matrix_datelist+1) ? "All" : "Fill";
                              if ($#avail_dates < 0 || $nrows *$ncols -$sumb == $#chosen_dates +1) {
                                  $all_btn->configure(-state => 'disabled');
                              }
                              $status = ($#chosen_dates >= 0) ? 'normal' : 'disabled';
                              $ok_btn->configure(-state => $status);
                            },
            ))->g_pack(-side => 'left', -padx => 2);

    ($remove_blank_btn = $blank_frame->new_button(
            -text    => "Remove",
            -state   => 'normal',
            -command => sub { return if ($blanks[$position-1] == 0);
                              $blanks[$position-1] = 0;
                              $chosen_lbox->delete($position-1,'end');
                              $none_label->g_grid() if ($#chosen_dates +&sum(@blanks) < 0);
                              $sumb = 0;
                              for ($nn=0; $nn<$nrows *$ncols; $nn++) {
                                  $sumb++ if ($blanks[$nn]);
                                  if ($nn >= $position-1) {
                                      $label = " (" . ($nn+1) . ")";
                                      if ($blanks[$nn]) {
                                          $chosen_lbox->insert('end', "Blank" . $label);
                                          $preview_canv->itemconfigure("box" . $nn,
                                                                       -fill => &get_rgb_code("gray50"));
                                          $preview_canv->itemconfigure("boxtxt" . $nn,
                                                                       -fill => &get_rgb_code("white"));
                                      } else {
                                          if ($#chosen_dates >= 0 && $#chosen_dates +$sumb >= $nn) {
                                              $label = &date2datelabel($chosen_dates[$nn-$sumb],
                                                                       "Mon-DD-YYYY HH:mm") . $label;
                                              $chosen_lbox->insert('end', $label);
                                              $preview_canv->itemconfigure("box" . $nn,
                                                                       -fill => &get_rgb_code("white"));
                                          } else {
                                              $preview_canv->itemconfigure("box" . $nn,
                                                                       -fill => &get_rgb_code("gray80"));
                                          }
                                          $preview_canv->itemconfigure("boxtxt" . $nn,
                                                                       -fill => &get_rgb_code("black"));
                                      }
                                  }
                              }
                              $all_txt = ($nrows *$ncols -$sumb >= $#matrix_datelist+1) ? "All" : "Fill";
                              if ($nrows *$ncols -$sumb > $#chosen_dates +1
                                    && $#chosen_dates < $#matrix_datelist) {
                                  $all_btn->configure(-state => 'normal');
                              }
                            },
            ))->g_pack(-side => 'left', -padx => 2);

#   Set up the preview canvas and the legend canvas
    $row++;
    $ph = &max( 90,  8+$nrows *14);
    $pw = &max(320, 12+$ncols *18);

    ($legend_canv = $f->new_canvas(
            -background  => &get_rgb_code("white"),
            -width       => 95,
            -height      => 90,
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'ne', -padx => 5, -pady => 2);
    for ($r=0; $r<3; $r++) {
        $xa = 8;
        $ya = 8+ $r *30;
        $color     = ($r == 0) ? "gray80" : (($r == 1) ? "white" : "gray50");
        $txt_color = ($r == 2) ? "white" : "black";
        $txt       = ($r == 0) ? "Available" : (($r == 1) ? "Assigned" : "Blank Area");
        $legend_canv->create_rectangle($xa, $ya, $xa +20, $ya +20,
                                       -outline => &get_rgb_code("black"),
                                       -width   => 1,
                                       -fill    => &get_rgb_code($color),
                                      );
        $legend_canv->create_text($xa+10, $ya+10,
                                  -anchor => 'c',
                                  -text   => "#",
                                  -fill   => &get_rgb_code($txt_color),
                                  -angle  => 0,
                                  -font   => [-family     => $default_family,
                                              -size       => $default_size -2,
                                              -weight     => 'normal',
                                              -slant      => 'roman',
                                              -underline  => 0,
                                              -overstrike => 0,
                                             ]);
        $legend_canv->create_text($xa+30, $ya+10,
                                  -anchor => 'w',
                                  -text   => $txt,
                                  -fill   => &get_rgb_code("black"),
                                  -angle  => 0,
                                  -font   => [-family     => $default_family,
                                              -size       => $default_size -2,
                                              -weight     => 'normal',
                                              -slant      => 'roman',
                                              -underline  => 0,
                                              -overstrike => 0,
                                             ]);
    }

    ($preview_canv = $f->new_canvas(
            -background  => &get_rgb_code("white"),
            -width       => $pw,
            -height      => $ph,
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

    $nb = $sumb = 0;
    $box_h = &min(20, int(($ph -8)/$nrows));
    $box_w = &min(20, int(($pw -12)/$ncols));
    $xa = int(($pw -$ncols *$box_w)/2.) +3;
    $ya = int(($ph -$nrows *$box_h)/2.) +3;
    for ($r=0; $r<$nrows; $r++) {
        for ($c=0; $c<$ncols; $c++) {
            if ($blanks[$nb]) {
                $sumb++;
                $color     = "gray50";
                $txt_color = "white";
            } else {
                if ($nb <= $#chosen_dates +$sumb) {
                    $color = "white";
                } else {
                    $color = "gray80";
                }
                $txt_color = "black";
            }
            $xp = $xa +$c *$box_w;
            $yp = $ya +$r *$box_h;
            $preview_canv->create_rectangle($xp, $yp, $xp+$box_w, $yp+$box_h,
                                            -outline => &get_rgb_code("black"),
                                            -width   => 1,
                                            -fill    => &get_rgb_code($color),
                                            -tags    => "box box" . $nb,
                                           );
            $preview_canv->create_text($xp+$box_w/2, $yp+$box_h/2,
                                       -anchor => 'c',
                                       -text   => $nb +1,
                                       -fill   => &get_rgb_code($txt_color),
                                       -angle  => 0,
                                       -tags   => "box boxtxt" . $nb,
                                       -font   => [-family     => $default_family,
                                                   -size       => $default_size -2,
                                                   -weight     => 'normal',
                                                   -slant      => 'roman',
                                                   -underline  => 0,
                                                   -overstrike => 0,
                                                  ]);
            $nb++;
        }
    }

    $row++;
    $f->new_label(
            -text => "Available Dates",
            -font => 'default',
            )->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
    $f->new_label(
            -text => "Chosen Dates (Position)",
            -font => 'default',
            )->g_grid(-row => $row, -column => 2, -sticky => 'ew', -pady => 2);

    $row++;
    ($choose_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1);
    ($add_btn = $choose_frame->new_button(
            -text    => "Add",
            -state   => 'disabled',
            -command => sub { my ($list, $newdate, $status, @newdates, @pos);
                              @newdates = @pos = ();
                              $list = $avail_lbox->curselection;
                              return if ($list eq "" || $nrows *$ncols -&sum(@blanks) <= $#chosen_dates +1);
                              if ($list =~ / /) {
                                  @pos = split(/ /, $list);
                              } else {
                                  $pos[0] = $list;
                              }
                              $sumb = &sum(@blanks);
                              for ($i=0; $i<=$#pos; $i++) {
                                  last if ($nrows *$ncols -$sumb <= $#chosen_dates + $#newdates +2);
                                  $nn = $pos[$i] -$i;
                                  push(@newdates, $avail_dates[$nn]);
                                  splice(@avail_dates, $nn, 1);
                                  $avail_lbox->delete($nn);
                              }
                              $avail_lbox->selection_clear(0,'end') if ($#newdates == $#pos);
                              $sumb = 0;
                              for ($nn=0; $nn<$nrows *$ncols; $nn++) {
                                  if ($blanks[$nn]) {
                                      $sumb++;
                                  } elsif ($nn -$sumb > $#chosen_dates) {
                                      last if ($#newdates < 0);
                                      $newdate = shift @newdates;
                                      push (@chosen_dates, $newdate);
                                      $label = &date2datelabel($chosen_dates[$nn -$sumb],
                                                               "Mon-DD-YYYY HH:mm") . " (" . ($nn+1) . ")";
                                      $chosen_lbox->insert($nn, $label);
                                      $preview_canv->itemconfigure("box" . $nn,
                                                                   -fill => &get_rgb_code("white"));
                                      $preview_canv->itemconfigure("boxtxt" . $nn,
                                                                   -fill => &get_rgb_code("black"));
                                  }
                              }
                              $sumb = &sum(@blanks);
                              $none_btn->configure(-state => 'normal');
                              $none_label->g_grid_remove() if ($#chosen_dates +$sumb >= 0);
                              $add_btn->configure(-state => 'disabled');
                              $all_txt = ($nrows *$ncols -$sumb >= $#matrix_datelist+1) ? "All" : "Fill";
                              if ($#avail_dates < 0 || $nrows *$ncols -$sumb == $#chosen_dates +1) {
                                  $all_btn->configure(-state => 'disabled');
                              }
                              $status = ($#chosen_dates >= 0) ? 'normal' : 'disabled';
                              $ok_btn->configure(-state => $status);
                            },
            ))->g_pack(-side => 'left', -padx => 1);
    $all_txt = ($nrows*$ncols-&sum(@blanks) >= $#matrix_datelist+1) ? "All" : "Fill";
    ($all_btn = $choose_frame->new_button(
            -textvariable => \$all_txt,
            -state   => 'normal',
            -command => sub { my ($nd, $status);
                              $sumb = &sum(@blanks);
                              $none_label->g_grid_remove() if ($#chosen_dates +$sumb < 0);
                              $none_btn->configure(-state => 'normal');
                              $all_btn->configure(-state => 'disabled');

                            # All: put all dates in matrix, in chronological order
                              if ($nrows *$ncols -$sumb >= $#matrix_datelist +1) {
                                  @chosen_dates   = @matrix_datelist;
                                  @avail_dates    = ();
                                  $avail_datelist = "";

                            # Fill: insert dates into empty spaces in grid, but leave current choices
                              } else {
                                  $nd = $#avail_dates;
                                  for ($nn=0; $nn<=$nd; $nn++) {
                                      last if ($#chosen_dates +1 >= $nrows *$ncols -$sumb);
                                      push (@chosen_dates, shift @avail_dates);
                                  }
                                  $avail_datelist = "";
                                  for ($i=0; $i<=$#avail_dates; $i++) {
                                      $avail_lbox->insert('end', &date2datelabel($avail_dates[$i],
                                                                                 "Mon-DD-YYYY HH:mm"));
                                  }
                              }

                            # Update list of chosen dates
                              $chosen_datelist = "";
                              $sumb = 0;
                              for ($nn=0; $nn<$nrows *$ncols; $nn++) {
                                  if ($blanks[$nn]) {
                                      $sumb++;
                                      $chosen_lbox->insert('end', "Blank (" . ($nn+1) . ")");

                                  } elsif ($nn -$sumb <= $#chosen_dates) {
                                      $label = &date2datelabel($chosen_dates[$nn -$sumb],
                                                               "Mon-DD-YYYY HH:mm") . " (" . ($nn+1) . ")";
                                      $chosen_lbox->insert('end', $label);
                                      $preview_canv->itemconfigure("box" . $nn,
                                                                   -fill => &get_rgb_code("white"));
                                      $preview_canv->itemconfigure("boxtxt" . $nn,
                                                                   -fill => &get_rgb_code("black"));
                                  }
                              }
                              $status = ($#chosen_dates >= 0) ? 'normal' : 'disabled';
                              $ok_btn->configure(-state => $status);
                            },
            ))->g_pack(-side => 'left', -padx => 1);
    ($chosen_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 2);
    $chosen_frame->new_button(
            -text    => "Sort",
            -state   => 'normal',
            -command => sub { return if ($#chosen_dates < 0);
                              @chosen_dates    = sort @chosen_dates;
                              $chosen_datelist = "";
                              $sumb = 0;
                              for ($nn=0; $nn<$nrows *$ncols; $nn++) {
                                  if ($blanks[$nn]) {
                                      $sumb++;
                                      $chosen_lbox->insert('end', "Blank (" . ($nn+1) . ")");

                                  } elsif ($nn -$sumb <= $#chosen_dates) {
                                      $label = &date2datelabel($chosen_dates[$nn-$sumb],
                                                               "Mon-DD-YYYY HH:mm") . " (" . ($nn+1) . ")";
                                      $chosen_lbox->insert('end', $label);
                                  }
                              }
                            },
            )->g_pack(-side => 'left', -padx => 1, -pady => 2);
    ($none_btn = $chosen_frame->new_button(
            -text    => "None",
            -state   => ($#chosen_dates >= 0) ? 'normal' : 'disabled',
            -command => sub { $chosen_datelist = "";
                              $sumb = 0;
                              for ($nn=0; $nn<$nrows *$ncols; $nn++) {
                                  if ($blanks[$nn]) {
                                      $sumb++;
                                      $chosen_lbox->insert('end', "Blank (" . ($nn+1) . ")");
                                  } elsif ($nn -$sumb <= $#chosen_dates) {
                                      $preview_canv->itemconfigure("box" . $nn,
                                                                   -fill => &get_rgb_code("gray80"));
                                  }
                              }
                              @chosen_dates   = ();
                              @avail_dates    = @matrix_datelist;
                              $avail_datelist = "";
                              for ($i=0; $i<=$#avail_dates; $i++) {
                                  $avail_lbox->insert('end', &date2datelabel($avail_dates[$i],
                                                                             "Mon-DD-YYYY HH:mm"));
                              }
                              $none_label->g_grid() if ($sumb == 0);
                              $none_btn->configure(-state => 'disabled');
                              $all_btn->configure(-state => 'normal');
                              $ok_btn->configure(-state => 'disabled');
                            },
            ))->g_pack(-side => 'left', -padx => 1, -pady => 2);
    ($remove_btn = $chosen_frame->new_button(
            -text    => "Remove",
            -state   => 'disabled',
            -command => sub { my ($entry, $list, $status, @pos, @rm_dates);
                              @rm_dates = @pos = ();
                              $list = $chosen_lbox->curselection;
                              return if ($list eq "" || &sum(@blanks) +$#chosen_dates +1 <= 0);
                              if ($list =~ / /) {
                                  @pos = split(/ /, $list);
                              } else {
                                  $pos[0] = $list;
                              }
                              $sumb = 0;
                              for ($nn=0; $nn<$nrows *$ncols; $nn++) {
                                  $sumb++ if ($blanks[$nn]);
                                  next if (&list_match($nn, @pos) < 0);
                                  $entry = $chosen_lbox->get($nn);
                                  if ($entry =~ /Blank/) {
                                      ($nb = $entry) =~ s/^.* \((\d+)\)$/$1/;
                                      $blanks[$nb-1] = 0;
                                  } elsif ($nn -$sumb <= $#chosen_dates) {
                                      push(@rm_dates, $chosen_dates[$nn-$sumb]);
                                      push(@avail_dates, $chosen_dates[$nn-$sumb]);
                                  }
                              }
                              for ($i=$#rm_dates; $i>=0; $i--) {
                                  $nn = &list_match($rm_dates[$i], @chosen_dates);
                                  if ($nn >= 0) {
                                      splice(@chosen_dates, $nn, 1);
                                  }
                              }
                              $sumb = &sum(@blanks);
                              $chosen_lbox->selection_clear(0,'end');
                              $none_label->g_grid() if ($#chosen_dates +$sumb < 0);
                              $none_btn->configure(-state => 'disabled') if ($#chosen_dates < 0);
                              $remove_btn->configure(-state => 'disabled');
                              $up_btn->configure(-state => 'disabled');
                              $down_btn->configure(-state => 'disabled');
                              $all_txt = ($nrows *$ncols -$sumb >= $#matrix_datelist+1) ? "All" : "Fill";
                              if ($nrows *$ncols -$sumb > $#chosen_dates +1
                                    && $#chosen_dates < $#matrix_datelist) {
                                  $all_btn->configure(-state => 'normal');
                              }

                              @avail_dates    = sort @avail_dates;
                              $avail_datelist = "";
                              for ($i=0; $i<=$#avail_dates; $i++) {
                                  $avail_lbox->insert('end', &date2datelabel($avail_dates[$i],
                                                                             "Mon-DD-YYYY HH:mm"));
                              }
                              $chosen_datelist = "";
                              $sumb = 0;
                              for ($nn=0; $nn<$nrows *$ncols; $nn++) {
                                  if ($blanks[$nn]) {
                                      $sumb++;
                                      $chosen_lbox->insert('end', "Blank (" . ($nn+1) . ")");

                                  } elsif ($nn -$sumb <= $#chosen_dates) {
                                      $label = &date2datelabel($chosen_dates[$nn -$sumb],
                                                               "Mon-DD-YYYY HH:mm") . " (" . ($nn+1) . ")";
                                      $chosen_lbox->insert('end', $label);
                                      $preview_canv->itemconfigure("box" . $nn,
                                                                   -fill => &get_rgb_code("white"));
                                      $preview_canv->itemconfigure("boxtxt" . $nn,
                                                                   -fill => &get_rgb_code("black"));
                                  } else {
                                      $preview_canv->itemconfigure("box" . $nn,
                                                                   -fill => &get_rgb_code("gray80"));
                                      $preview_canv->itemconfigure("boxtxt" . $nn,
                                                                   -fill => &get_rgb_code("black"));
                                  }
                              }
                              $status = ($#chosen_dates >= 0) ? 'normal' : 'disabled';
                              $ok_btn->configure(-state => $status);
                            }
            ))->g_pack(-side => 'left', -padx => 1, -pady => 2);
    ($up_btn = $chosen_frame->new_button(
            -repeatdelay    => 10000,
            -repeatinterval => 10000,
            -state   => 'disabled',
            -image   => $up_img,
            -width   => 12,
            -command => sub { my ($label1, $label2, $list, $n, $nn1, $up_exists, $tmp, @newpos, @pos);
                              $list = $chosen_lbox->curselection;
                              return if ($list eq "" || &sum(@blanks) +$#chosen_dates +1 <= 0);
                              if ($list =~ / /) {
                                  @pos = split(/ /, $list);
                              } else {
                                  $pos[0] = $list;
                              }
                              @newpos = @pos;
                              for ($i=0; $i<=$#pos; $i++) {
                                  $n      = $pos[$i];
                                  $label1 = $chosen_lbox->get($n);
                                  ($nb = $label1) =~ s/^.* \((\d+)\)$/$1/;
                                  next if ($nb == 1);  # don't move up if first position
                                  $nn  = $nb-1;
                                  $nn1 = $nn-1;
                                  if ($blanks[$nn] && $blanks[$nn1]) {
                                      $newpos[$i] = $n-1 if (&list_match($n-1, @newpos) < 0);
                                      next;
                                  }
                                  $sumb      = &sum(@blanks[0 .. $nn1]);
                                  $up_exists = 0;
                                  $up_exists = 1 if ($blanks[$nn1] || $nn1 <= $sumb +$#chosen_dates);
                                  if ($up_exists) {
                                    # Don't move the selection up if destination position also selected
                                      next if (&list_match($n-1, @newpos) >= 0);
                                      $newpos[$i] = $n-1;
                                      $label2  = $chosen_lbox->get($n-1);
                                      $tmp     = $label1;
                                      ($label1 = $label2) =~ s/\(\d+\)$/\($nb\)/;
                                      ($label2 = $tmp)    =~ s/\(\d+\)$/\($nn\)/;
                                      $chosen_lbox->delete($n-1,$n);
                                      $chosen_lbox->insert($n-1, $label2, $label1);
                                      if ($blanks[$nn]) {
                                          $blanks[$nn]  = 0;
                                          $blanks[$nn1] = 1;
                                          $preview_canv->itemconfigure("box"    . $nn,
                                                                       -fill => &get_rgb_code("white"));
                                          $preview_canv->itemconfigure("boxtxt" . $nn,
                                                                       -fill => &get_rgb_code("black"));
                                          $preview_canv->itemconfigure("box"    . $nn1,
                                                                       -fill => &get_rgb_code("gray50"));
                                          $preview_canv->itemconfigure("boxtxt" . $nn1,
                                                                       -fill => &get_rgb_code("white"));
                                      } elsif ($blanks[$nn1]) {
                                          $blanks[$nn]  = 1;
                                          $blanks[$nn1] = 0;
                                          $preview_canv->itemconfigure("box"    . $nn,
                                                                       -fill => &get_rgb_code("gray50"));
                                          $preview_canv->itemconfigure("boxtxt" . $nn,
                                                                       -fill => &get_rgb_code("white"));
                                          $preview_canv->itemconfigure("box"    . $nn1,
                                                                       -fill => &get_rgb_code("white"));
                                          $preview_canv->itemconfigure("boxtxt" . $nn1,
                                                                       -fill => &get_rgb_code("black"));
                                      } else {
                                          $n = $nn -$sumb;
                                          $tmp                = $chosen_dates[$n];
                                          $chosen_dates[$n]   = $chosen_dates[$n-1];
                                          $chosen_dates[$n-1] = $tmp;
                                      }
                                  } elsif ($blanks[$nn]) {
                                      $blanks[$nn]  = 0;
                                      $blanks[$nn1] = 1;
                                      $label1       =~ s/\(\d+\)$/\($nn\)/;
                                      $chosen_lbox->delete($n);
                                      $chosen_lbox->insert($n, $label1);
                                      $preview_canv->itemconfigure("box"    . $nn,
                                                                   -fill => &get_rgb_code("gray80"));
                                      $preview_canv->itemconfigure("boxtxt" . $nn,
                                                                   -fill => &get_rgb_code("black"));
                                      $preview_canv->itemconfigure("box"    . $nn1,
                                                                   -fill => &get_rgb_code("gray50"));
                                      $preview_canv->itemconfigure("boxtxt" . $nn1,
                                                                   -fill => &get_rgb_code("white"));
                                  }
                              }
                              $chosen_lbox->selection_clear(0,'end');
                              for ($i=0; $i<=$#newpos; $i++) {
                                  $chosen_lbox->selection_set($newpos[$i]);
                              }
                              $chosen_lbox->activate($newpos[0]);
                            },
            ))->g_pack(-side => 'left', -padx => 1, -pady => 2, -expand => 1, -fill => 'y');
    ($down_btn = $chosen_frame->new_button(
            -repeatdelay    => 10000,
            -repeatinterval => 10000,
            -state   => 'disabled',
            -image   => $down_img,
            -width   => 12,
            -command => sub { my ($down_exists, $label1, $label2, $list, $n, $nb2, $nn1, $tmp,
                                  @newpos, @pos);
                              $list = $chosen_lbox->curselection;
                              return if ($list eq "" || &sum(@blanks) +$#chosen_dates +1 <= 0);
                              if ($list =~ / /) {
                                  @pos = split(/ /, $list);
                              } else {
                                  $pos[0] = $list;
                              }
                              @newpos = @pos;
                              for ($i=$#pos; $i>=0; $i--) {
                                  $n      = $pos[$i];
                                  $label1 = $chosen_lbox->get($n);
                                  ($nb = $label1) =~ s/^.* \((\d+)\)$/$1/;
                                  next if ($nb == $nrows *$ncols);  # don't move down if last position
                                  $nn  = $nb-1;
                                  $nn1 = $nn+1;
                                  $nb2 = $nb+1;
                                  if ($blanks[$nn] && $blanks[$nn1]) {
                                      $newpos[$i] = $n+1 if (&list_match($n+1, @newpos) < 0);
                                      next;
                                  }
                                  $sumb        = ($nb > 1) ? &sum(@blanks[0 .. $nn]) : 0;
                                  $down_exists = 0;
                                  $down_exists = 1 if ($blanks[$nn1] || $nn1 <= $sumb +$#chosen_dates);
                                  if ($down_exists) {
                                    # Don't move the selection down if destination position also selected
                                      next if (&list_match($n+1, @newpos) >= 0);
                                      $newpos[$i] = $n+1;
                                      $label2  = $chosen_lbox->get($n+1);
                                      $tmp     = $label1;
                                      ($label1 = $label2) =~ s/\(\d+\)$/\($nb\)/;
                                      ($label2 = $tmp)    =~ s/\(\d+\)$/\($nb2\)/;
                                      $chosen_lbox->delete($n,$n+1);
                                      $chosen_lbox->insert($n, $label1, $label2);
                                      if ($blanks[$nn]) {
                                          $blanks[$nn]  = 0;
                                          $blanks[$nn1] = 1;
                                          $preview_canv->itemconfigure("box"    . $nn,
                                                                       -fill => &get_rgb_code("white"));
                                          $preview_canv->itemconfigure("boxtxt" . $nn,
                                                                       -fill => &get_rgb_code("black"));
                                          $preview_canv->itemconfigure("box"    . $nn1,
                                                                       -fill => &get_rgb_code("gray50"));
                                          $preview_canv->itemconfigure("boxtxt" . $nn1,
                                                                       -fill => &get_rgb_code("white"));
                                      } elsif ($blanks[$nn1]) {
                                          $blanks[$nn]  = 1;
                                          $blanks[$nn1] = 0;
                                          $preview_canv->itemconfigure("box"    . $nn,
                                                                       -fill => &get_rgb_code("gray50"));
                                          $preview_canv->itemconfigure("boxtxt" . $nn,
                                                                       -fill => &get_rgb_code("white"));
                                          $preview_canv->itemconfigure("box"    . $nn1,
                                                                       -fill => &get_rgb_code("white"));
                                          $preview_canv->itemconfigure("boxtxt" . $nn1,
                                                                       -fill => &get_rgb_code("black"));
                                      } else {
                                          $n = $nn -$sumb;
                                          $tmp                = $chosen_dates[$n];
                                          $chosen_dates[$n]   = $chosen_dates[$n+1];
                                          $chosen_dates[$n+1] = $tmp;
                                      }
                                  } elsif ($blanks[$nn]) {
                                      $blanks[$nn]  = 0;
                                      $blanks[$nn1] = 1;
                                      $label1       =~ s/\(\d+\)$/\($nb2\)/;
                                      $chosen_lbox->delete($n);
                                      $chosen_lbox->insert($n, $label1);
                                      $preview_canv->itemconfigure("box"    . $nn,
                                                                   -fill => &get_rgb_code("gray80"));
                                      $preview_canv->itemconfigure("boxtxt" . $nn,
                                                                   -fill => &get_rgb_code("black"));
                                      $preview_canv->itemconfigure("box"    . $nn1,
                                                                   -fill => &get_rgb_code("gray50"));
                                      $preview_canv->itemconfigure("boxtxt" . $nn1,
                                                                   -fill => &get_rgb_code("white"));
                                  } else {
                                      $blanks[$nn] = 1;
                                      $label = "Blank (" . $nb . ")";
                                      $label1 =~ s/\(\d+\)$/\($nb2\)/;
                                      $chosen_lbox->delete($n);
                                      $chosen_lbox->insert($n, $label, $label1);
                                      $preview_canv->itemconfigure("box"    . $nn,
                                                                   -fill => &get_rgb_code("gray50"));
                                      $preview_canv->itemconfigure("boxtxt" . $nn,
                                                                   -fill => &get_rgb_code("white"));
                                      $preview_canv->itemconfigure("box"    . $nn1,
                                                                   -fill => &get_rgb_code("white"));
                                      $preview_canv->itemconfigure("boxtxt" . $nn1,
                                                                   -fill => &get_rgb_code("black"));
                                  }
                              }
                              $sumb = &sum(@blanks);
                              $all_txt = ($nrows *$ncols -$sumb >= $#matrix_datelist+1) ? "All" : "Fill";
                              if ($nrows *$ncols -$sumb > $#chosen_dates +1
                                    && $#chosen_dates < $#matrix_datelist) {
                                  $all_btn->configure(-state => 'normal');
                              } else {
                                  $all_btn->configure(-state => 'disabled');
                              }
                              $chosen_lbox->selection_clear(0,'end');
                              for ($i=0; $i<=$#newpos; $i++) {
                                  $chosen_lbox->selection_set($newpos[$i]);
                              }
                              $chosen_lbox->activate($newpos[$#newpos]);
                              $chosen_lbox->see('active');
                            },
            ))->g_pack(-side => 'left', -padx => 1, -pady => 2, -expand => 1, -fill => 'y');

    $row++;
    $f->new_label(
            -text => "Choose Dates: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'ne', -pady => 2);

  # Create a scrollable listbox inside a frame to hold the available dates.
    ($avail_fr = $f->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'nsew', -pady => 2);
    ($avail_sbar = $avail_fr->new_scrollbar(
            -orient => 'vertical',
            -width  => 15,
            ))->g_grid(-row => 0, -column => 1, -sticky => 'nse');

    $avail_datelist = "";
    @avail_dates    = ();
    ($avail_lbox = $avail_fr->new_listbox(
                            -listvariable   => \$avail_datelist,
                            -selectmode     => 'extended',
                            -font           => 'default',
                            -relief         => 'flat',
                            -background     => &get_rgb_code($background_color),
                            -height         => &min(20, $#matrix_datelist+1),
                            -yscrollcommand => [$avail_sbar, 'set'],
                ))->g_grid(-row => 0, -column => 0, -sticky => 'nsew', -padx => 1, -pady => 0);
    $avail_sbar->configure(-command => [$avail_lbox, 'yview']);

    for ($i=0; $i<=$#matrix_datelist; $i++) {
        if (&list_match($matrix_datelist[$i], @chosen_dates) < 0) {
            $avail_lbox->insert('end', &date2datelabel($matrix_datelist[$i], "Mon-DD-YYYY HH:mm"));
            push (@avail_dates, $matrix_datelist[$i]);
        }
    }
    $avail_lbox->g_bind("<<ListboxSelect>>",
                     sub { my ($list);
                           Tkx::update();
                           $list = $avail_lbox->curselection;
                           $remove_btn->configure(-state => 'disabled');
                           $up_btn->configure(-state => 'disabled');
                           $down_btn->configure(-state => 'disabled');
                           return if ($list eq "" || $nrows *$ncols -&sum(@blanks) <= $#chosen_dates +1);
                           $add_btn->configure(-state => 'normal');
                         });
    $avail_lbox->g_bind("<FocusIn>",
                     sub { my ($list);
                           Tkx::update();
                           $list = $avail_lbox->curselection;
                           $remove_btn->configure(-state => 'disabled');
                           $up_btn->configure(-state => 'disabled');
                           $down_btn->configure(-state => 'disabled');
                           return if ($list eq "" || $nrows *$ncols -&sum(@blanks) <= $#chosen_dates +1);
                           $add_btn->configure(-state => 'normal');
                         });

  # Create a scrollable listbox inside a frame to hold the chosen dates.
    ($chosen_fr = $f->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_grid(-row => $row, -column => 2, -sticky => 'nsew', -pady => 2, -padx => 2);
    ($chosen_sbar = $chosen_fr->new_scrollbar(
            -orient => 'vertical',
            -width  => 15,
            ))->g_grid(-row => 0, -column => 1, -sticky => 'nse');

    $chosen_datelist = "";
    ($chosen_lbox = $chosen_fr->new_listbox(
                            -listvariable   => \$chosen_datelist,
                            -selectmode     => 'extended',
                            -font           => 'default',
                            -relief         => 'flat',
                            -background     => &get_rgb_code($background_color),
                            -height         => &min(20, $#matrix_datelist+1),
                            -yscrollcommand => [$chosen_sbar, 'set'],
                ))->g_grid(-row => 0, -column => 0, -sticky => 'nsew', -padx => 1, -pady => 0);
    $chosen_sbar->configure(-command => [$chosen_lbox, 'yview']);

    $sumb = 0;
    for ($nn=0; $nn<$nrows *$ncols; $nn++) {
        $label = " (" . ($nn+1) . ")";
        if ($blanks[$nn]) {
            $sumb++;
            $chosen_lbox->insert('end', "Blank" . $label);

        } elsif ($nn -$sumb <= $#chosen_dates) {
            $label = &date2datelabel($chosen_dates[$nn-$sumb], "Mon-DD-YYYY HH:mm") . $label;
            $chosen_lbox->insert('end', $label);
        }
    }
    $chosen_lbox->g_bind("<<ListboxSelect>>",
                     sub { my ($list);
                           Tkx::update();
                           $list = $chosen_lbox->curselection;
                           $add_btn->configure(-state => 'disabled');
                           return if ($list eq "");
                           $remove_btn->configure(-state => 'normal');
                           $up_btn->configure(-state => 'normal');
                           $down_btn->configure(-state => 'normal');
                         });
    $chosen_lbox->g_bind("<FocusIn>",
                     sub { my ($list);
                           Tkx::update();
                           $list = $chosen_lbox->curselection;
                           $add_btn->configure(-state => 'disabled');
                           return if ($list eq "");
                           $remove_btn->configure(-state => 'normal');
                           $up_btn->configure(-state => 'normal');
                           $down_btn->configure(-state => 'normal');
                         });

    ($none_label = $chosen_fr->new_label(
            -text => "None",
            -font => 'default',
            ))->g_grid(-row => 0, -column => 0, -sticky => 'nw', -pady => 0);

    $sumb = &sum(@blanks);
    $all_txt = ($nrows*$ncols-$sumb >= $#matrix_datelist+1) ? "All" : "Fill";
    if ($nrows *$ncols -$sumb > $#chosen_dates +1 && $#chosen_dates < $#matrix_datelist) {
        $all_btn->configure(-state => 'normal');
    } else {
        $all_btn->configure(-state => 'disabled');
    }
    $none_label->g_grid_remove() if ($#chosen_dates +$sumb >= 0);

    if ($new_graph) {
        $row++;
        $f->new_label(
                -text => "X Tick Interval: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($xmajor_frame = $f->new_frame(
                -borderwidth => 0,
                -relief      => 'flat',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
        ($xmajor_entry = $xmajor_frame->new_entry(
                -textvariable => \$xmajor,
                -font         => 'default',
                -width        => 7,
                ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        $xmajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($xmajor_entry, 1);
                                                    $xmajor =~ s/^-//;
                                                  });
        if ($props{$id}{parm} eq "Temperature") {
            $xunits = "\N{U+00B0}" . substr($props{$id}{parm_units},0,1);
        } else {
            $xunits = $props{$id}{parm_units};
            $xunits = " " . $xunits if ($xunits ne "");
        }
        $xmajor_frame->new_label(
                -text   => $xunits,
                -font   => 'default',
                -anchor => 'w',
                )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);

        $row++;
        $f->new_label(
                -text => "Y Tick Interval: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($ymajor_frame = $f->new_frame(
                -borderwidth => 0,
                -relief      => 'flat',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
        ($ymajor_entry = $ymajor_frame->new_entry(
                -textvariable => \$ymajor,
                -font         => 'default',
                -width        => 7,
                ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        $ymajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($ymajor_entry, 1);
                                                    $ymajor =~ s/^-//;
                                                  });
        $ymajor_frame->new_label(
                -text   => $gr_props{$id}{yunits},
                -font   => 'default',
                -anchor => 'w',
                )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);

        $row++;
        $f->new_label(
                -text => "Color Scheme: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $f->new_ttk__combobox(
                -textvariable => \$cscheme,
                -values       => [ @cmaps ],
                -state        => ($#cmaps > 0) ? 'readonly' : 'disabled',
                -width        => 15,
                )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

        $row++;
        $f->new_label(
                -text => "Date Position: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $f->new_ttk__combobox(
                -textvariable => \$gs_pos,
                -values       => [ ("Top Left", "Top Center", "Top Right", "Middle Left", "Middle Right",
                                    "Bottom Left", "Bottom Center", "Bottom Right") ],
                -state        => 'readonly',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

        $row++;
        $f->new_label(
                -text => "Date Format: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $f->new_ttk__combobox(
                -textvariable => \$gs_fmt,
                -values       => [ ("DD-Mon-YYYY HH:mm",
                                    "DD Mon, YYYY HH:mm",
                                    "Mon DD, YYYY HH:mm",
                                    "MM/DD/YYYY HH:mm",
                                    "MM-DD-YYYY HH:mm") ],
                -state        => 'readonly',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

        $row++;
        $f->new_label(
                -text => "Graph Title: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $f->new_entry(
                -textvariable => \$gtitle,
                -font         => 'default',
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
    }

    Tkx::wm_resizable($w2profile_matrix_menu,0,0);
    &adjust_window_position($w2profile_matrix_menu);
    $w2profile_matrix_menu->g_focus;
}


sub make_w2_profile {
    my ($canv, $id, $props_updated) = @_;
    my (
        $add_dateline, $anc, $base_jd, $box_id, $change, $clipmax, $clipmin,
        $cmap_image, $confirm_type, $cs_max, $cs_min, $cs_range, $cs_rev,
        $cscheme1, $cscheme2, $data_available, $date_id, $date_label,
        $datemax, $datemin, $dsize, $dt, $dt2, $elev_ref, $frame_id,
        $geom, $group_tags, $gtag, $i, $id2, $ih, $in_yrange, $item, $iw,
        $j, $j2, $j3, $j4, $jd, $jd_max, $jd_min, $jd0, $jd2, $jj, $jw,
        $k, $kn_digits, $kt, $kt_ref, $labels, $max_cols, $max_rows, $mi,
        $mismatch, $move_mcursor, $mpointerx, $mpointery, $mult, $n, $n1,
        $nb, $nc, $ncolors, $ncols, $new_graph, $nlayers, $np, $nr, $nrows,
        $nwb, $parm_ref, $parm_short, $pbar, $pbar_frame, $pbar_window,
        $pval, $pval3, $pval4, $refresh_menus, $resized, $seg, $sumb,
        $surf_elev, $tabid, $tag, $update_cs, $X, $x1, $x2, $xmax, $xmin,
        $xp, $xp1, $xp2, $xrange, $Y, $y1, $y2, $ymax, $ymin, $yp, $yp1,
        $yp1i, $yp2, $yp3, $yp3i, $yp4, $yp4i, $ypi, $yr_max, $yr_min,
        $yrange, $yval,

        @be, @blanks, @bs, @chosen_dates, @colors, @coords, @cpl_files,
        @ds, @el, @elws, @grp_tags, @items, @jdates, @kb, @matrix_coords,
        @mydates, @old_coords, @pdata, @scale, @tags, @tmp, @us, @wbs,

        %axis_props, %color_key_props, %data, %date_anchor, %elev_data,
        %kt_data, %limits, %parm_data, %parms, %profile,
       );

#   For new plots, pop up a menu for file names and parameters
    if (! defined($props{$id}{files})) {
        if ($props{$id}{meta} eq "w2_profile_matrix" && defined($props{$id}{link_id})) {
            return &edit_w2_profile_matrix($canv, $id);
        } else {
            return &setup_w2_profile($canv, $id);
        }
    }

#   Make tag and get coordinates of graph frame
    $gtag   = "graph" . $id;
    @coords = @{ $props{$id}{coordlist} };
    ($x1, $y1, $x2, $y2) = @coords;

#   Determine whether group tags are present and save the list
    $group_tags = 0;
    @grp_tags   = ();
    @tags       = Tkx::SplitList($canv->itemcget($id, -tags));
    if (&list_search("group_", @tags) > -1) {
        $group_tags = 1;
        foreach $tag (@tags) {
            push (@grp_tags, $tag) if ($tag =~ /^group_/);
        }
    }

#   Read the data files, if not done already
    if (! defined($props{$id}{data}) || ! $props{$id}{data}) {
        %parms = %{ $props{$id}{parms} };
        $seg   = $props{$id}{seg};

        if (defined($props{$id}{oldcoords})) {
            %profile   = %{ $gr_props{$id} };
            $change    = $parms{change};      # values:  seg, parm, misc, base, all
            $new_graph = 0;
        } else {
            %profile   = ();
            $change    = "";
            $new_graph = 1;
        }

#       Validate the source type
        $confirm_type = &confirm_w2_ftype($main, $props{$id}{src_file});
        if ($props{$id}{src_type} =~ /Spreadsheet/i && $confirm_type ne "spr") {
            return &pop_up_error($main,
                    "The W2 source file is not a W2 Spreadsheet file:\n$props{$id}{src_file}");
        } elsif ($props{$id}{src_type} =~ /Contour/i && $confirm_type ne "cpl") {
            return &pop_up_error($main,
                    "The W2 source file is not a W2 Contour file:\n$props{$id}{src_file}");
        } elsif ($props{$id}{src_type} =~ /Vector/i && $confirm_type ne "w2l") {
            return &pop_up_error($main,
                    "The W2 source file is not a W2 Vector (w2l) file:\n$props{$id}{src_file}");
        } elsif ($props{$id}{src_type} =~ /LakeCon/i && $confirm_type ne "lcon1") {
            return &pop_up_error($main, "The W2 source file is not an acceptable\n"
                                      . "W2 Lake Contour (format 1) file:\n$props{$id}{src_file}");
        }

#       Set some variables and read the bathymetry file.
#       Required for all source file types. Vector (w2l) files don't have a good kb value.
#       It's not necessary to re-read the bth file in certain situations.
        $nwb = $grid{$id}{nwb};
        @bs  = @{ $grid{$id}{bs} };
        @be  = @{ $grid{$id}{be} };
        @us  = @{ $grid{$id}{us} };
        @ds  = @{ $grid{$id}{ds} };
        for ($jw=1; $jw<=$nwb; $jw++) {
            last if ($seg >= $us[$bs[$jw]] && $seg <= $ds[$be[$jw]]);
        }
        if ($new_graph || $change eq "all") {
            &read_bth($main, $id, $jw, $props{$id}{bth_file});
        }

#       Move mouse cursor on first creation, to ensure that it changes to cursor_wait
        if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
            $canv->g_bind("<Motion>", "");
            Tkx::event_generate($main, "<Motion>", -warp => 1, -x => ($x1+$x2)/2, -y => ($y1+$y2)/2);
            $canv->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"), $canv, "menu" ]);
        }

        if ($props{$id}{src_type} =~ /Spreadsheet/i) {
            &get_grid_elevations($main, $id, $jw);
            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $props{$id}{src_lines},
                                                         "Reading W2 spreadsheet file...");
            ($kt_ref, $elev_ref, $parm_ref) = &read_w2_spr_file($main, $id, $props{$id}{src_file},
                                                  $props{$id}{parm}, $props{$id}{parm_div},
                                                  $props{$id}{byear}, $seg, $props{$id}{tz_offset},
                                                  $props{$id}{jd_skip}, $pbar);
            &destroy_progress_bar($main, $pbar_window);

            %kt_data   = %{ $kt_ref   };
            %elev_data = %{ $elev_ref };
            %parm_data = %{ $parm_ref };

        } elsif ($props{$id}{src_type} =~ /Contour/i) {
            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $props{$id}{src_lines},
                                                         "Reading W2 contour file...");
            %data = &read_w2_cpl_file($main, $id, $jw, $props{$id}{src_file}, $props{$id}{tplot},
                                          $seg, $props{$id}{parm}, $props{$id}{parm_div},
                                          $props{$id}{byear}, $props{$id}{tz_offset},
                                          $props{$id}{jd_skip}, $pbar);
            &destroy_progress_bar($main, $pbar_window);

            %kt_data   = ();
            %elev_data = ();
            %parm_data = ();
            @mydates   = keys %data;
            for ($j=0; $j<=$#mydates; $j++) {
                $dt    = $mydates[$j];
                $kt    = $data{$dt}{kt};
                @elws  = @{ $data{$dt}{elws}      };
                @pdata = @{ $data{$dt}{parm_data} };
                if (defined($elws[$seg])) {
                    $elev_data{$dt} = $elws[$seg];
                    for ($k=$kt; $k<=$#pdata; $k++) {
                        $parm_data{$dt}[$k-$kt] = $pdata[$k][$seg];
                    }
                }
                $kt_data{$dt} = $kt;
            }
            undef %data;

        } elsif ($props{$id}{src_type} =~ /Vector/i) {
            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, -s $props{$id}{src_file},
                                                         "Reading W2 vector file...");
            $status_line = "Reading W2 vector file... Date = 1";
            %data = &read_w2_vector_file($main, $id, $props{$id}{src_file}, $seg, $props{$id}{parm},
                                         $props{$id}{parm_div}, $props{$id}{byear}, $props{$id}{tz_offset},
                                         $props{$id}{jd_skip}, $pbar);
            &destroy_progress_bar($main, $pbar_window);

            %kt_data   = ();
            %elev_data = ();
            %parm_data = ();
            @kb        = @{ $grid{$id}{kb} };
            @mydates   = keys %data;
            for ($j=0; $j<=$#mydates; $j++) {
                $dt    = $mydates[$j];
                $kt    = $data{$dt}{kt};
                @pdata = @{ $data{$dt}{parm_data} };
                if (defined($data{$dt}{elws}) && $data{$dt}{elws} != -99) {
                    $elev_data{$dt} = $data{$dt}{elws};
                    for ($k=$kt; $k<=$#pdata; $k++) {
                        $parm_data{$dt}[$k-$kt] = $pdata[$k];
                        last if ($k >= $kb[$seg]);
                    }
                }
                $kt_data{$dt} = $kt;
            }
            undef %data;

        } elsif ($props{$id}{src_type} =~ /LakeCon/i) {
            &get_grid_elevations($main, $id, $jw);
            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $props{$id}{src_lines},
                                                         "Reading W2 Lake Contour file...");
            ($kt_ref, $elev_ref, $parm_ref) = &read_w2_lakecon_file($main, $id, $props{$id}{src_file},
                                                         $seg, $props{$id}{parm}, $props{$id}{byear},
                                                         $props{$id}{tz_offset}, $props{$id}{jd_skip}, $pbar);
            &destroy_progress_bar($main, $pbar_window);

            %kt_data   = %{ $kt_ref   };
            %elev_data = %{ $elev_ref };
            %parm_data = %{ $parm_ref };
        }

        if (&list_match($props{$id}{ctype}, @conv_types) > 0 || $props{$id}{ctype} =~ /^Custom,/) {
            $status_line = "Converting units...";
            Tkx::update_idletasks();
            %parm_data = &convert_timeseries($main, $props{$id}{ctype}, 1, %parm_data);
            $status_line = "";
            Tkx::update_idletasks();
        }

#       Find minimum and maximum elevation and parameter values
        %limits = &find_w2_profile_limits($id, $seg, \%elev_data, \%parm_data);
        $profile{date_min}  = $limits{date_min};
        $profile{date_max}  = $limits{date_max};
        $profile{dpth_min}  = $limits{dpth_min};
        $profile{dpth_max}  = $limits{dpth_max};
        $profile{elev_min}  = $limits{elev_min};
        $profile{elev_max}  = $limits{elev_max};
        $profile{parm_min}  = $limits{parm_min};
        $profile{parm_max}  = $limits{parm_max};
        undef %limits;

        $profile{kt_data}   = { %kt_data   };
        $profile{elev_data} = { %elev_data };
        $profile{parm_data} = { %parm_data };

        if ($new_graph) {
            $profile{yfont}     = $default_family;
            $profile{yl_size}   = &min(11, &max(8, int((abs($x2-$x1)+abs($y2-$y1))/2./41)));
            $profile{yt_size}   = $profile{yl_size} +2;
            $profile{yl_weight} = 'normal';
            $profile{yt_weight} = 'normal';
            $profile{ypr_tics}  = "outside";
            $profile{yop_tics}  = "none";

            $profile{xfont}     = $profile{yfont};
            $profile{xl_size}   = $profile{yl_size};
            $profile{xt_size}   = $profile{yt_size};
            $profile{xl_weight} = $profile{yl_weight};
            $profile{xt_weight} = $profile{yt_weight};
            $profile{xpr_tics}  = "outside";
            $profile{xop_tics}  = "none";

            $profile{gtfont}    = $profile{yfont};
            $profile{gt_size}   = $profile{yt_size};
            $profile{gt_weight} = 'bold';
            if ($props{$id}{meta} eq "w2_profile") {
                $profile{gs_size}   = $profile{gt_size} -1;
                $profile{gs_weight} = $profile{gt_weight};
                $profile{pr_style}  = "Stairstep";
                $profile{pr_linec}  = "black";
                $profile{pr_linew}  = 1;
            } else {
                $profile{dateline}  = 1;
                $profile{datelinec} = "black";
            }
            $profile{pc_style}  = "By Layer";

            $profile{keyfont}   = $default_family;
            $profile{kn_size}   = $profile{yl_size};
            $profile{kt_size}   = $profile{yl_size} +2;
            $profile{kt_weight} = 'normal';
            $profile{kn_weight} = 'normal';
            $profile{kn_digits} = 1;

            $profile{cs_rev}    =  0;
            $profile{cs_hide}   =  0;
            $profile{xleg_off}  = 40;
            $profile{yleg_off}  =  0;
            $profile{cs_width}  = 24;
        }
        if ($new_graph || $change eq "all") {
            $profile{ytype}     = $parms{ytype};
            $profile{yunits}    = $parms{yunits};
            $profile{ymin}      = ($parms{ymin} ne "") ? $parms{ymin} : 0;
            $profile{ymax}      = $parms{ymax};
            $profile{ymajor}    = ($parms{ymajor} eq "") ? "auto" : $parms{ymajor};
            $profile{ytitle}    = $parms{ytype} . ", in " . $parms{yunits};

            if ($props{$id}{meta} eq "w2_profile_cmap") {
                $profile{xmajor}  = "auto";
                $profile{datefmt} = "Month";
                $profile{xmin}    = "first";
                $profile{xmax}    = "last";
                $profile{xtype}   = "Date/Time";
                $profile{base_yr} = $props{$id}{byear};
            }
            if ($parms{cscheme} eq "None") {
                $profile{add_cs}    =  0;
                $profile{cscheme1}  = "Blue";
                $profile{cscheme2}  = "Orange";
                $profile{ncolors}   = 20;
                $profile{cs_height} = &max(2, &min(18, int(($y2-$y1+1) /$profile{ncolors})));
            } else {
                $profile{add_cs}    =  1;
                $profile{cs_height} = &max(2, &min(18, int(($y2-$y1+1) /$parms{ncolors})));
                if ($parms{cscheme} eq "Blue to Orange") {
                    $profile{cscheme1} = "Blue";
                    $profile{cscheme2} = "Orange";
                    $profile{ncolors}  = $parms{ncolors} /2;
                } elsif ($parms{cscheme} eq "Blue to Red") {
                    $profile{cscheme1} = "Blue";
                    $profile{cscheme2} = "Red";
                    $profile{ncolors}  = $parms{ncolors} /2;
                } else {
                    $profile{cscheme1} = $parms{cscheme};
                    $profile{cscheme2} = "None";
                    $profile{ncolors}  = $parms{ncolors};
                }
            }
        } elsif ($change =~ /misc|base/) {
            if ($props{$id}{meta} eq "w2_profile_cmap") {
                $profile{base_yr} = $props{$id}{byear};
            }
        }
        if ($change ne "seg") {
            if ($props{$id}{parm} eq "Temperature") {
                $profile{xtitle} = "Temperature, in degrees " . $props{$id}{parm_units};
            } else {
                $parm_short = $props{$id}{parm};
                $parm_short =~ s/\(ms-1\)//i;
                $parm_short =~ s/\(m3s-1\)//i;
                $parm_short =~ s/ [kmu]?g\/L\/day//i;
                $parm_short =~ s/ [kmu]?g\/m2\/day//i;
                $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
                $parm_short =~ s/ [kmu]?g\/L//i;
                $parm_short =~ s/ [kmu]?g\/m3//i;
                $parm_short =~ s/ [kmu]?g\/m\^3//i;
                $parm_short =~ s/, days//i;
                $parm_short =~ s/ days//i;
                $parm_short =~ s/,$//;
                $profile{xtitle} = $parm_short . ", in " . $props{$id}{parm_units};
            }
            $profile{gtitle}   = $parms{gtitle};
            $profile{keytitle} = $profile{xtitle}; 
            $profile{cs_min}   = $parms{xmin};
            $profile{cs_max}   = $parms{xmax};
            $profile{cs_major} = "auto";

            if ($props{$id}{meta} eq "w2_profile") {
                $profile{xmin}   = $parms{xmin};
                $profile{xmax}   = $parms{xmax};
                $profile{xmajor} = ($parms{xmajor} eq "") ? "auto" : $parms{xmajor};
            }
            $profile{cs_link} = 0;
            if ($profile{add_cs} && @animate_ids && $#animate_ids >= 0) {
                $update_cs = 0;
                foreach $item (@animate_ids) {
                    next if ($item == $id);
                    next if ($props{$item}{meta} =~ /time_series|w2_wlevels/);
                    next if ($props{$item}{meta} eq "w2_outflow" && ! $props{$item}{add_parm});
                    if ($gr_props{$item}{cs_link} == 2) {
                        if ($props{$item}{meta} =~ /(w2_profile|w2_slice|w2_outflow)/
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$item}{parm_div}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                            $id2 = $item;
                            last;
                        } elsif ($props{$item}{meta} eq "w2_tdmap"
                             && $props{$item}{map_type}   eq "standard"
                             && $props{$item}{parm_sav}   eq $props{$id}{parm}
                             && $props{$item}{pdiv_sav}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                            $id2 = $item;
                            last;
                        } elsif ($props{$item}{meta} =~ /data_profile/
                             && $props{$item}{prof_type}  eq "standard"
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$id}{parm_div}     eq "None"
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                            $id2 = $item;
                            last;
                        } elsif ($props{$item}{meta} =~ /vert_wd_zone/
                             && $props{$id}{parm}       eq "Temperature"
                             && $props{$id}{parm_div}   eq "None"
                             && $props{$item}{wt_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                            $id2 = $item;
                            last;
                        }
                    }
                }
                if (! $update_cs) {
                    foreach $item (@animate_ids) {
                        next if ($item == $id);
                        next if ($props{$item}{meta} =~ /data_profile|vert_wd_zone|time_series|w2_wlevels/);
                        next if ($props{$item}{meta} eq "w2_outflow" && ! $props{$item}{add_parm});
                        next if ($props{$item}{meta} =~ /w2_slice|w2_tdmap/
                                  && $props{$item}{src_type} ne $props{$id}{src_type});
                        if ($gr_props{$item}{cs_link} == 1) {
                            if ($props{$item}{meta} =~ /w2_profile|w2_outflow/
                                 && $props{$item}{parm}       eq $props{$id}{parm}
                                 && $props{$item}{parm_div}   eq $props{$id}{parm_div}
                                 && $props{$item}{parm_units} eq $props{$id}{parm_units}
                                 && $props{$item}{src_file}   eq $props{$id}{src_file}) {
                                $update_cs = 1;
                                $id2 = $item;
                                last;
                            } elsif (($props{$item}{meta} =~ /w2_slice/
                                      && $props{$item}{parm}       eq $props{$id}{parm}
                                      && $props{$item}{parm_div}   eq $props{$id}{parm_div}
                                      && $props{$item}{parm_units} eq $props{$id}{parm_units})
                                  || ($props{$item}{meta} eq "w2_tdmap"
                                      && $props{$item}{map_type}   eq "standard"
                                      && $props{$item}{parm_sav}   eq $props{$id}{parm}
                                      && $props{$item}{pdiv_sav}   eq $props{$id}{parm_div}
                                      && $props{$item}{parm_units} eq $props{$id}{parm_units})) {
                                if ($props{$item}{src_type} =~ /Contour/i) {
                                    @wbs       = split(/,/, $props{$item}{wb_list});
                                    @cpl_files = @{ $props{$item}{cpl_files} };
                                    for ($n=0; $n<=$#wbs; $n++) {
                                        if ($cpl_files[$n] eq $props{$id}{src_file}) {
                                            $update_cs = 1;
                                            $id2 = $item;
                                            last;
                                        }
                                    }
                                    last if ($update_cs);
                                } elsif ($props{$item}{src_type} =~ /Vector/i) {
                                    if ($props{$item}{w2l_file} eq $props{$id}{src_file}) {
                                        $update_cs = 1;
                                        $id2 = $item;
                                        last;
                                    }
                                }
                            }
                        }
                    }
                }
                if ($update_cs) {
                    $ncolors           = $profile{ncolors};
                    $profile{cs_link}  = $gr_props{$id2}{cs_link};
                    $profile{cscheme1} = $gr_props{$id2}{cscheme1};
                    $profile{cscheme2} = $gr_props{$id2}{cscheme2};
                    $profile{ncolors}  = $gr_props{$id2}{ncolors};
                    $profile{cs_rev}   = $gr_props{$id2}{cs_rev};
                    $profile{cs_min}   = $gr_props{$id2}{cs_min};
                    $profile{cs_max}   = $gr_props{$id2}{cs_max};
                    $profile{cs_major} = $gr_props{$id2}{cs_major};
                    if ($new_graph) {
                        if ($profile{cs_height} *$ncolors > $y2-$y1+1 && $profile{cs_height} > 2) {
                            $profile{cs_height} = &max(2, &min(18, int(($y2-$y1+1) /$profile{ncolors})));
                        }
                    } elsif ($ncolors != $profile{ncolors}) {
                        $profile{cs_height} = &max(2, &min(30,
                                       &round_to_int($profile{cs_height} *$ncolors /$profile{ncolors})));
                    }
                }
            }
        }
        undef $gr_props{$id} if (! $new_graph);
        $profile{redraw}  = 1;
        $gr_props{$id}    = { %profile };
        $props{$id}{data} = 1;
        $props{$id}{gnum} = ++$graph_num if (! defined($props{$id}{oldcoords}));
        $resized          = 0;
        $refresh_menus    = 0;
        undef %profile;

#       Rebuild @dates array (profile, not colormap) under certain conditions.
#       The rebuild option is determined in change_w2_profile or setup_w2_profile.
        if (! $new_graph) {
            &rebuild_datelist if ($parms{rebuild});
            $refresh_menus = 1;
            $canv->delete($gtag . "_xaxis");
            $canv->delete($gtag . "_xaxisTitle");
            $canv->delete($gtag . "_yaxis");
            $canv->delete($gtag . "_yaxisTitle");
            $canv->delete($gtag . "_date");
            $canv->delete($gtag . "_stats");
            $canv->delete($gtag . "_gtitle");
            $canv->delete($gtag . "_colorKey");
            $canv->delete($gtag . "_colorKeyTitle");
            $canv->delete($gtag . "_profile");
            $canv->delete($gtag . "_colorProfile");
            $canv->delete($gtag . "_refData");
            $canv->delete($gtag . "_colorMap");
            $canv->delete($gtag . "_colorMapDateline");
        }
        undef %parms;

#   Or use previously read info.  If resized, delete graph and redraw
    } else {
        @old_coords    = @{ $props{$id}{oldcoords} };
        $refresh_menus = 0;
        $resized       = 0;
        for ($i=0; $i<=$#coords; $i++) {
            if ($coords[$i] != $old_coords[$i]) {
                $resized = 1;
                last;
            }
        }
        return if (! $resized && ! $props_updated);
        $gr_props{$id}{redraw} = 1 if ($resized);

        $seg       = $props{$id}{seg};
        %kt_data   = %{ $gr_props{$id}{kt_data}   };
        %elev_data = %{ $gr_props{$id}{elev_data} };
        %parm_data = %{ $gr_props{$id}{parm_data} };

        $canv->delete($gtag . "_xaxis");
        $canv->delete($gtag . "_xaxisTitle");
        $canv->delete($gtag . "_yaxis");
        $canv->delete($gtag . "_yaxisTitle");
        $canv->delete($gtag . "_date");
        $canv->delete($gtag . "_stats");
        $canv->delete($gtag . "_gtitle");
        $canv->delete($gtag . "_colorKey");
        $canv->delete($gtag . "_colorKeyTitle");
        $canv->delete($gtag . "_colorMapDateline");
        if ($gr_props{$id}{redraw}) {
            $canv->delete($gtag . "_profile");
            $canv->delete($gtag . "_colorProfile");
            $canv->delete($gtag . "_refData");
            $canv->delete($gtag . "_colorMap");
        }
    }
    $props{$id}{oldcoords} = [ @coords ];
    @items     = Tkx::SplitList($canv->find_withtag($gtag . "_main"));
    $new_graph = ($#items >= 0) ? 0 : 1;

#   For a W2 Profile Matrix graph, the main background and axes are handled differently
    if ($props{$id}{meta} eq "w2_profile_matrix") {
        $max_rows  = 15;
        $max_cols  = 25;
        ($x1, $x2) = sort numerically ($x1, $x2);
        ($y1, $y2) = sort numerically ($y1, $y2);
        ($nrows, $ncols) = split(/x/, $gr_props{$id}{matrix});
        @chosen_dates    = @{ $gr_props{$id}{pdates} };
        @blanks          = @{ $gr_props{$id}{blanks} };
        @matrix_coords   = ();
        $nb = $sumb = 0;
        for ($nr=0; $nr<$nrows; $nr++) {
            for ($nc=0; $nc<$ncols; $nc++) {
                $nb = $nr *$ncols +$nc;
                if ($blanks[$nb]) {
                    $sumb++;
                } elsif ($nb <= $#chosen_dates +$sumb) {
                    $xp1 = $x1 + &round_to_int($nc    *($x2 -$x1)/$ncols);
                    $xp2 = $x1 + &round_to_int(($nc+1)*($x2 -$x1)/$ncols);
                    $yp1 = $y1 + &round_to_int($nr    *($y2 -$y1)/$nrows);
                    $yp2 = $y1 + &round_to_int(($nr+1)*($y2 -$y1)/$nrows);
                    $matrix_coords[$nb-$sumb] = [ ($xp1, $yp1, $xp2, $yp2) ];
                }

              # Plot a white rectangle for each active graph frame
              # Need to re-do these each time in case the number of matrix graphs decreases
                @items = Tkx::SplitList($canv->find_withtag($gtag . "_main" . $nb));
                if ($#items < 0) {
                    next if ($blanks[$nb] || $nb > $#chosen_dates +$sumb);
                    $box_id = $canv->create_rectangle($xp1, $yp1, $xp2, $yp2,
                                         -outline => "",
                                         -width   => 0,
                                         -fill    => &get_rgb_code("white"),
                                         -tags    => $gtag . " " . $gtag . "_main"
                                                           . " " . $gtag . "_main" . $nb);
                    $frame_id = $canv->create_rectangle($xp1, $yp1, $xp2, $yp2,
                                         -outline => &get_rgb_code("black"),
                                         -width   => 1,
                                         -fill    => "",
                                         -tags    => $gtag . " " . $gtag . "_frame"
                                                           . " " . $gtag . "_frame" . $nb);
                    $canv->lower($box_id,   $id);
                    $canv->lower($frame_id, $id);
                } elsif ($blanks[$nb] || $nb > $#chosen_dates +$sumb) {
                    $canv->delete($gtag . "_main"  . $nb);
                    $canv->delete($gtag . "_frame" . $nb);
                    next;
                } else {
                    $canv->coords($gtag . "_main"  . $nb, $xp1, $yp1, $xp2, $yp2);
                    $canv->coords($gtag . "_frame" . $nb, $xp1, $yp1, $xp2, $yp2);
                    $canv->raise($id, $gtag . "_frame" . $nb);
                }

              # Plot Y axis for graph position nb
                if ($nc == 0) {
                    $labels = 1;
                } else {
                    $labels = ($blanks[$nb-1]) ? 1 : 0;
                }
                if ($gr_props{$id}{ytype} eq "Depth") {
                    if ($nr == 0 || $nc == 0) {
                        $clipmin = 0;
                    } else {
                        $clipmin = ($blanks[$nb -$ncols -1]) ? 0 : 1;
                    }
                    if ($nr == $nrows-1) {
                        $clipmax = 0;
                    } elsif ($nc == 0) {
                        $n = $nb +$ncols;
                        $clipmax = ($blanks[$n] || $n > $#chosen_dates +&sum(@blanks[0 .. $n])) ? 0 : 1;
                    } else {
                        $n  = $nb +$ncols;
                        $n1 = $nb +$ncols -1;
                        $clipmax = (($blanks[$n]  || $n  > $#chosen_dates +&sum(@blanks[0 .. $n])) && 
                                    ($blanks[$n1] || $n1 > $#chosen_dates +&sum(@blanks[0 .. $n1]))) ? 1 : 0;
                    }
                } else {
                    if ($nr == 0) {
                        $clipmax = 0;
                    } elsif ($nc == 0) {
                        $clipmax = ($blanks[$nb-$ncols]) ? 0 : 1;
                    } else {
                        $n = $nb -$ncols;
                        $clipmax = ($blanks[$n] && $blanks[$n-1]) ? 0 : 1;
                    }
                    if ($nr == $nrows-1 || $nc == 0) {
                        $clipmin = 0;
                    } else {
                        $n = $nb +$ncols -1;
                        $clipmin = ($blanks[$n] || $n > $#chosen_dates +&sum(@blanks[0 .. $n])) ? 0 : 1;
                    }
                }
                $axis_props{min}     = $gr_props{$id}{ymin};
                $axis_props{max}     = $gr_props{$id}{ymax};
                $axis_props{clipmin} = $clipmin;
                $axis_props{clipmax} = $clipmax;
                $axis_props{major}   = $gr_props{$id}{ymajor};
                $axis_props{minor}   = 1;
                $axis_props{pr_tics} = $gr_props{$id}{ypr_tics};
                $axis_props{op_tics} = $gr_props{$id}{yop_tics};
                $axis_props{reverse} = ($gr_props{$id}{ytype} eq "Depth") ? 1 : 0;
                $axis_props{labels}  = $labels;
                $axis_props{title}   = $gr_props{$id}{ytitle};
                $axis_props{font}    = $gr_props{$id}{yfont};
                $axis_props{size1}   = $gr_props{$id}{yl_size};
                $axis_props{size2}   = $gr_props{$id}{yt_size};
                $axis_props{weight1} = $gr_props{$id}{yl_weight};
                $axis_props{weight2} = $gr_props{$id}{yt_weight};
                $axis_props{side}    = "left";
                $axis_props{tags}    = $gtag . " " . $gtag . "_yaxis";
                $axis_props{coords}  = [$xp1, $yp2, $xp1, $yp1];
                $axis_props{op_loc}  = $xp2;
                &make_axis($canv, %axis_props);

            }
        }

      # Eliminate old graph frames if the matrix size has been decreased
        for ($nb=$nrows *$ncols; $nb<$max_rows *$max_cols; $nb++) {
            @items = Tkx::SplitList($canv->find_withtag($gtag . "_main" . $nb));
            if ($#items >= 0) {
                $canv->delete($gtag . "_main"  . $nb);
                $canv->delete($gtag . "_frame" . $nb);
            }
        }

      # Hide the larger matrix outline
        $canv->itemconfigure($id, -state => 'hidden');

      # Set up hash for date anchor and trap for a bad date-text color
        %date_anchor = ("Top Left",    'nw', "Top Center",    'n', "Top Right",    'ne',
                        "Middle Left", 'w',  "Middle Right",  'e',
                        "Bottom Left", 'sw', "Bottom Center", 's', "Bottom Right", 'se',
                       );
        if (! $gr_props{$id}{add_cs} && $gr_props{$id}{gs_color} eq "white" && ! $gr_props{$id}{gs_fill}) {
            $gr_props{$id}{gs_color} = "black";
            $refresh_menus = 1;
        }

    } else {
#       Plot a white rectangle below the graph frame
        if ($new_graph) {
            $box_id = $canv->create_rectangle($x1, $y1, $x2, $y2,
                                 -outline => "",
                                 -width   => 0,
                                 -fill    => &get_rgb_code("white"),
                                 -tags    => $gtag . " " . $gtag . "_main");
            $canv->lower($box_id, $id);
        } else {
            $canv->coords($gtag . "_main", @coords);
            $canv->raise($id, $gtag . "_main");
        }

#       Plot Y axis
        $axis_props{min}     = $gr_props{$id}{ymin};
        $axis_props{max}     = $gr_props{$id}{ymax};
        $axis_props{major}   = $gr_props{$id}{ymajor};
        $axis_props{minor}   = 1;
        $axis_props{pr_tics} = $gr_props{$id}{ypr_tics};
        $axis_props{op_tics} = $gr_props{$id}{yop_tics};
        $axis_props{reverse} = ($gr_props{$id}{ytype} eq "Depth") ? 1 : 0;
        $axis_props{title}   = $gr_props{$id}{ytitle};
        $axis_props{font}    = $gr_props{$id}{yfont};
        $axis_props{size1}   = $gr_props{$id}{yl_size};
        $axis_props{size2}   = $gr_props{$id}{yt_size};
        $axis_props{weight1} = $gr_props{$id}{yl_weight};
        $axis_props{weight2} = $gr_props{$id}{yt_weight};
        $axis_props{side}    = "left";
        $axis_props{tags}    = $gtag . " " . $gtag . "_yaxis";
        $axis_props{coords}  = [$x1, $y2, $x1, $y1];
        $axis_props{op_loc}  = $x2;
        &make_axis($canv, %axis_props);
    }
    undef %axis_props;

#   Elevation or depth limits.  Keep depths and elevations in meters.
    $mult   = ($gr_props{$id}{yunits} eq "feet") ? 3.28084 : 1.0;
    $ymin   = $gr_props{$id}{ymin} /$mult;
    $ymax   = $gr_props{$id}{ymax} /$mult;
    $yrange = $ymax -$ymin;
    @el     = @{ $grid{$id}{el} };
    @kb     = @{ $grid{$id}{kb} };

#   Deal with optional color scheme and create optional color key
    if ($gr_props{$id}{add_cs} || $props{$id}{meta} eq "w2_profile_cmap") {
        $cscheme1  = $gr_props{$id}{cscheme1};
        $cscheme2  = $gr_props{$id}{cscheme2};
        $ncolors   = $gr_props{$id}{ncolors};
        $cs_rev    = $gr_props{$id}{cs_rev};
        $cs_min    = $gr_props{$id}{cs_min};
        $cs_max    = $gr_props{$id}{cs_max};
        $kn_digits = $gr_props{$id}{kn_digits};
        if (&list_match($cscheme1, @color_scheme_names) == -1 ||
           (&list_match($cscheme1, @full_color_schemes) == -1 && &list_match($ncolors, @valid_nc) == -1) ||
           (&list_match($cscheme1, @full_color_schemes) >= 0 && &list_match($ncolors, @valid_nc_alt) == -1) ||
           ($cscheme2 ne "" && $cscheme2 ne "None" && &list_match($cscheme2, @color_scheme_names) == -1)) {
            $cscheme1  = $gr_props{$id}{cscheme1}  = "Blue";
            $cscheme2  = $gr_props{$id}{cscheme2}  = "Orange";
            $ncolors   = $gr_props{$id}{ncolors}   = 11;
            $cs_rev    = $gr_props{$id}{cs_rev}    =  0;
            $cs_min    = $gr_props{$id}{cs_min}    =  0;
            $cs_max    = $gr_props{$id}{cs_max}    = 22;
            $kn_digits = $gr_props{$id}{kn_digits} =  1;
        }
        $cs_range = $cs_max -$cs_min;
        @colors   = &make_color_scheme($ncolors, $cs_rev, $cscheme1, $cscheme2);
        @scale    = ();
        for ($i=0; $i<=$#colors+1; $i++) {
            $j = $#colors +1 -$i;
            $scale[$j] = $cs_min +$cs_range*$j/($#colors+1);
        }
        $gr_props{$id}{colors}    = [ @colors ];
        $gr_props{$id}{scale}     = [ @scale  ];

        $color_key_props{xleg}    = $x2 + $gr_props{$id}{xleg_off};
        $color_key_props{yleg}    = $y1 + $gr_props{$id}{yleg_off};
        $color_key_props{width}   = $gr_props{$id}{cs_width};
        $color_key_props{height}  = $gr_props{$id}{cs_height};
        $color_key_props{colors}  = [ @colors ];
        $color_key_props{scale}   = [ @scale  ];
        $color_key_props{title}   = $gr_props{$id}{keytitle};
        $color_key_props{font}    = $gr_props{$id}{keyfont};
        $color_key_props{size1}   = $gr_props{$id}{kn_size};
        $color_key_props{size2}   = $gr_props{$id}{kt_size};
        $color_key_props{weight1} = $gr_props{$id}{kn_weight};
        $color_key_props{weight2} = $gr_props{$id}{kt_weight};
        $color_key_props{digits}  = $kn_digits;
        $color_key_props{major}   = $gr_props{$id}{cs_major};
        $color_key_props{tags}    = $gtag . " " . $gtag . "_colorKey";
        &make_color_key($canv, %color_key_props);
        undef %color_key_props;

        if ($gr_props{$id}{cs_hide}) {
            $canv->itemconfigure($gtag . "_colorKey", -state => 'hidden');
        }
    }

#   Set the list of dates or merge the dates array if necessary
#   Add the graph to the list of animated graphs, if necessary
    @mydates = sort keys %parm_data;
    if ($props{$id}{meta} eq "w2_profile") {
        if (! @animate_ids || &list_match($id, @animate_ids) == -1) {
            if (@dates && @animate_ids && $#animate_ids >= 0) {
                $mismatch = 0;
                foreach $id2 (@animate_ids) {
#                   next if ($id2 == $id);
                    next if ($props{$id2}{meta}
                               =~ /data_profile_cmap|w2_profile_cmap|w2_profile_matrix|w2_tdmap|time_series/);
                    if ($props{$id2}{meta} =~ /w2_slice|w2_wlevels/) {
                        if ($props{$id2}{src_type}     ne $props{$id}{src_type}
                            || $props{$id2}{byear}     != $props{$id}{byear}
                            || $props{$id2}{tz_offset} ne $props{$id}{tz_offset}
                            || $props{$id2}{jd_skip}   != $props{$id}{jd_skip}) {
                            $mismatch = 1;
                            last;
                        } elsif ($props{$id2}{src_type} =~ /Contour/i) {
                            @wbs       = split(/,/, $props{$id2}{wb_list});
                            @cpl_files = @{ $props{$id2}{cpl_files} };
                            $mismatch  = 1;
                            for ($n=0; $n<=$#wbs; $n++) {
                                if ($cpl_files[$n] eq $props{$id}{src_file}) {
                                    $mismatch = 0;
                                    last;
                                }
                            }
                            last if ($mismatch);
                        } elsif ($props{$id2}{src_type} =~ /Vector/i) {
                            if ($props{$id2}{w2l_file} ne $props{$id}{src_file}) {
                                $mismatch = 1;
                                last;
                            }
                        }
                    } elsif ($props{$id2}{meta} =~ /^(data_profile|vert_wd_zone|w2_outflow)$/
                             || $props{$id2}{src_file} ne $props{$id}{src_file}) {
                        $mismatch = 1;
                        last;
                    } elsif ($props{$id2}{src_file} eq $props{$id}{src_file}) {
                        if ($props{$id2}{byear}        != $props{$id}{byear}
                            || $props{$id2}{tz_offset} ne $props{$id}{tz_offset}
                            || $props{$id2}{jd_skip}   != $props{$id}{jd_skip}) {
                            $mismatch = 1;
                            last;
                        }
                    }
                }
                if ($mismatch) {
                    if (defined($animate_tb) && Tkx::winfo_exists($animate_tb)) {
                        if ($animate_tb->g_wm_title() eq "Animation toolbar") {
                            $animate_tb->g_destroy();
                            undef $animate_tb;
                        }
                    }
                    $dt      = $dates[$dti-1];
                    @dates   = &merge_dates(\@dates, \@mydates);
                    $dti_max = $#dates+1;
                    $dti     = 1 + &nearest_dt_index($dt, @dates);
                    $dti++ if ($dti == 0);
                    &build_profile_match_list();
                }
            } else {
                @dates   = @mydates;
                $dti_max = $#dates+1;
                $dti     = 1;
                $delay   = 0.5;
            }
            $dti_old = $dti;
            push (@animate_ids, $id);
        }
        $dt = $dates[$dti-1];              # Define current date/time
        if (! defined($parm_data{$dt})) {  # Adjust by up to 10 minutes, if needed
            for ($mi=1; $mi<=10; $mi++) {
                $dt2 = &adjust_dt($dt, $mi);
                if (defined($parm_data{$dt2})) {
                    $dt = $dt2;
                    last;
                }
                $dt2 = &adjust_dt($dt, -1 *$mi);
                if (defined($parm_data{$dt2})) {
                    $dt = $dt2;
                    last;
                }
            }
        }
        $export_menu->entryconfigure(3, -state => 'normal') if ($use_GS);
        $pref_menu->entryconfigure(0,   -state => 'normal');

    } elsif ($props{$id}{meta} eq "w2_profile_matrix") {
        if (! @animate_ids || &list_match($id, @animate_ids) == -1) {
            push (@animate_ids, $id);
        }

    } elsif ($props{$id}{meta} eq "w2_profile_cmap") {
        if (! defined($cmap_datemin)) {
            $cmap_datemin = substr($mydates[0],0,8);
            $cmap_datemax = substr($mydates[$#mydates],0,8);
        } else {
            $datemin      = substr($mydates[0],0,8);
            $datemax      = substr($mydates[$#mydates],0,8);
            $cmap_datemin = $datemin if ($datemin < $cmap_datemin);
            $cmap_datemax = $datemax if ($datemax > $cmap_datemax);
        }
    }

#   Refresh the Graph Properties menu and Object Information box, if present
    if ($refresh_menus) {
        if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
            if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
                $tabid = $grprops_notebook->index('current');
                $geom  = $graph_props_menu->g_wm_geometry();
                (undef, $X, $Y) = split(/\+/, $geom);
                &edit_graph_props($id, $X, $Y, $tabid);
            }
        }
        if (defined($object_infobox) && Tkx::winfo_exists($object_infobox)) {
            if ($object_infobox->g_wm_title() =~ /Object Info/) {
                $geom = $object_infobox->g_wm_geometry();
                (undef, $X, $Y) = split(/\+/, $geom);
                &show_info($canv, $id, $X, $Y);
            }
        }
    }

#   An animated vertical profile or a vertical profile matrix is requested
    if ($props{$id}{meta} =~ /^(w2_profile|w2_profile_matrix)$/) {

        $xp    = ($x1+$x2)/2.;
        $yp    = ($gr_props{$id}{xop_tics} =~ /outside|cross/) ? $y1-14 : $y1-6;
        $dsize = 0;

        if ($props{$id}{meta} eq "w2_profile") {
            $nrows = $ncols = 1;
            @blanks           = (0);
            @chosen_dates     = ($dt);
            $matrix_coords[0] = [ ($x1, $y1, $x2, $y2) ];

#           Plot the date as a subtitle
            $date_label = &get_formatted_date($dt);
            $date_id = $canv->create_text($xp, $yp,
                               -anchor => 's',
                               -text   => $date_label,
                               -fill   => &get_rgb_code("black"),
                               -angle  => 0,
                               -tags   => $gtag . " " . $gtag . "_date",
                               -font   => [-family     => $gr_props{$id}{gtfont},
                                           -size       => $gr_props{$id}{gs_size},
                                           -weight     => $gr_props{$id}{gs_weight},
                                           -slant      => 'roman',
                                           -underline  => 0,
                                           -overstrike => 0,
                                          ]);
            @coords = Tkx::SplitList($canv->bbox($date_id));
            $dsize  = &max(10, abs($coords[3] - $coords[1]));
        }

#       Plot the graph title
        $canv->create_text($xp, $yp-$dsize,
                           -anchor => 's', 
                           -text   => $gr_props{$id}{gtitle},
                           -fill   => &get_rgb_code("black"),
                           -angle  => 0,
                           -tags   => $gtag . " " . $gtag . "_gtitle",
                           -font   => [-family     => $gr_props{$id}{gtfont},
                                       -size       => $gr_props{$id}{gt_size},
                                       -weight     => $gr_props{$id}{gt_weight},
                                       -slant      => 'roman',
                                       -underline  => 0,
                                       -overstrike => 0,
                                      ]);

#       Plot X axis or axes, and dates for matrix graphs
        $sumb = 0;
        for ($nr=0; $nr<$nrows; $nr++) {
            for ($nc=0; $nc<$ncols; $nc++) {
                $nb = $nr *$ncols +$nc;
                $sumb++ if ($blanks[$nb]);
                next if ($blanks[$nb] || $nb > $#chosen_dates +$sumb);
                ($x1, $y1, $x2, $y2) = @{ $matrix_coords[$nb-$sumb] };

                if ($nr == $nrows-1) {
                    $labels = 1;
                } else {
                    $n = $nb +$ncols;
                    $labels = ($blanks[$n] || $n > $#chosen_dates +&sum(@blanks[0 .. $n])) ? 1 : 0;
                }
                if ($nc == $ncols-1) {
                    $clipmax = 0;
                } elsif ($nr == $nrows-1) {
                    $clipmax = ($blanks[$nb+1] || $nb+1 > $#chosen_dates +$sumb) ? 0 : 1;
                } else {
                    $n = $nb +$ncols +1;
                    $clipmax = (($blanks[$nb+1] || $nb+1 > $#chosen_dates +$sumb) &&
                                ($blanks[$n]    || $n > $#chosen_dates +&sum(@blanks[0 .. $n]))) ? 0 : 1;
                }
                if ($nr == $nrows-1 || $nc == 0) {
                    $clipmin = 0;
                } else {
                    $n = $nb +$ncols -1;
                    $clipmin = ($blanks[$n] || $n > $#chosen_dates +&sum(@blanks[0 .. $n])) ? 0 : 1;
                }
                $axis_props{min}     = $gr_props{$id}{xmin};
                $axis_props{max}     = $gr_props{$id}{xmax};
                $axis_props{clipmin} = $clipmin;
                $axis_props{clipmax} = $clipmax;
                $axis_props{major}   = $gr_props{$id}{xmajor};
                $axis_props{minor}   = 1;
                $axis_props{pr_tics} = $gr_props{$id}{xpr_tics};
                $axis_props{op_tics} = $gr_props{$id}{xop_tics};
                $axis_props{reverse} = 0;
                $axis_props{labels}  = $labels;
                $axis_props{title}   = $gr_props{$id}{xtitle};
                $axis_props{font}    = $gr_props{$id}{xfont};
                $axis_props{size1}   = $gr_props{$id}{xl_size};
                $axis_props{size2}   = $gr_props{$id}{xt_size};
                $axis_props{weight1} = $gr_props{$id}{xl_weight};
                $axis_props{weight2} = $gr_props{$id}{xt_weight};
                $axis_props{side}    = "bottom";
                $axis_props{tags}    = $gtag . " " . $gtag . "_xaxis";
                $axis_props{coords}  = [$x1, $y2, $x2, $y2];
                $axis_props{op_loc}  = $y1;
                &make_axis($canv, %axis_props);

              # Make date labels for a profile matrix
                if ($props{$id}{meta} eq "w2_profile_matrix") {
                    $anc = $date_anchor{$gr_props{$id}{gs_pos}};
                    if ($gr_props{$id}{gs_pos} =~ /Left/) {
                        $xp = ($gr_props{$id}{ypr_tics} =~ /inside|cross/) ? $x1+15 : $x1+8;
                    } elsif ($gr_props{$id}{gs_pos} =~ /Right/) {
                        $xp = ($gr_props{$id}{ypr_tics} =~ /inside|cross/) ? $x2-15 : $x2-8;
                    } else {
                        $xp = ($x1+$x2)/2;
                    }
                    if ($gr_props{$id}{gs_pos} =~ /Top/) {
                        $yp = ($gr_props{$id}{xop_tics} =~ /inside|cross/) ? $y1+12 : $y1+8;
                    } elsif ($gr_props{$id}{gs_pos} =~ /Bottom/) {
                        $yp = ($gr_props{$id}{xop_tics} =~ /inside|cross/) ? $y2-12 : $y2-8;
                    } else {
                        $yp = ($y1+$y2)/2;
                    }
                    $date_label = &get_formatted_date($chosen_dates[$nb-$sumb], 1, $gr_props{$id}{gs_fmt});
                    $date_id = $canv->create_text($xp, $yp,
                                       -anchor => $anc,
                                       -text   => $date_label,
                                       -fill   => &get_rgb_code($gr_props{$id}{gs_color}),
                                       -angle  => 0,
                                       -tags   => $gtag . " " . $gtag . "_date"
                                                        . " " . $gtag . "_date" . $nb,
                                       -font   => [-family     => $gr_props{$id}{gtfont},
                                                   -size       => $gr_props{$id}{gs_size},
                                                   -weight     => $gr_props{$id}{gs_weight},
                                                   -slant      => 'roman',
                                                   -underline  => 0,
                                                   -overstrike => 0,
                                                  ]);
                    if (($gr_props{$id}{gs_edge} && $gr_props{$id}{gs_edgec} ne "") ||
                        ($gr_props{$id}{gs_fill} && $gr_props{$id}{gs_fillc} ne "")) {
                        ($xp1, $yp1, $xp2, $yp2) = Tkx::SplitList($canv->bbox($date_id));
                        $box_id = $canv->create_rectangle($xp1-3, $yp1-3, $xp2+3, $yp2+3,
                                             -outline => "",
                                             -width   => 0,
                                             -fill    => &get_rgb_code("white"),
                                             -tags    => $gtag . " " . $gtag . "_date"
                                                               . " " . $gtag . "_date" . $nb);
                        $canv->lower($box_id, $date_id);
                        if ($gr_props{$id}{gs_edge} && $gr_props{$id}{gs_edgec} ne "") {
                            $canv->itemconfigure($box_id,
                                                 -outline => &get_rgb_code($gr_props{$id}{gs_edgec}),
                                                 -width   => 1);
                        }
                        if ($gr_props{$id}{gs_fill} && $gr_props{$id}{gs_fillc} ne "") {
                            $canv->itemconfigure($box_id, -fill => &get_rgb_code($gr_props{$id}{gs_fillc}));
                        } else {
                            $canv->itemconfigure($box_id, -fill => "");
                        }
                    }
                }
            }
        }
        undef %axis_props;

#       Don't recompute and redraw unless necessary
        if (! $gr_props{$id}{redraw}) {

#           Add or update goodness-of-fit statistics for a matrix plot
            if ($props{$id}{meta} eq "w2_profile_matrix") {
                if (defined($gr_props{$id}{ms_stats}) && $gr_props{$id}{ms_stats}) {
                    &set_matrix_stats($canv, $id);
                }
            }
            if ($gr_props{$id}{add_cs}) {
                $canv->lower($gtag . "_colorKey",      $id);
                $canv->lower($gtag . "_colorKeyTitle", $id);
                $canv->lower($gtag . "_colorProfile",  $id);
            }
            $canv->lower($gtag . "_profile",    $id);
            $canv->lower($gtag . "_refData",    $id);
            $canv->lower($gtag . "_date",       $id);
            $canv->lower($gtag . "_stats",      $id) if ($props{$id}{meta} eq "w2_profile_matrix");
            $canv->lower($gtag . "_gtitle",     $id);
            $canv->lower($gtag . "_xaxisTitle", $id);
            $canv->lower($gtag . "_yaxisTitle", $id);
            $canv->lower($gtag . "_xaxis",      $id);
            $canv->lower($gtag . "_yaxis",      $id);
            $canv->lower($gtag . "_frame",      $id) if ($props{$id}{meta} eq "w2_profile_matrix");
            if ($group_tags) {
                foreach $tag (@grp_tags) {
                    $canv->addtag($tag, withtag => $gtag);
                }
            }
            return;
        }

#       Loop over the profile matrix, or plot just the one profile
        $sumb = 0;
        for ($nr=0; $nr<$nrows; $nr++) {
            for ($nc=0; $nc<$ncols; $nc++) {
                $nb = $nr *$ncols +$nc;
                $sumb++ if ($blanks[$nb]);
                next if ($blanks[$nb] || $nb > $#chosen_dates +$sumb);
                ($x1, $y1, $x2, $y2) = @{ $matrix_coords[$nb-$sumb] };

#               For the matrix, test the dates
                if ($props{$id}{meta} eq "w2_profile_matrix") {
                    $dt = $chosen_dates[$nb-$sumb];
                    if (! defined($parm_data{$dt})) {  # Adjust by up to 10 minutes, if needed
                        for ($mi=1; $mi<=10; $mi++) {
                            $dt2 = &adjust_dt($dt, $mi);
                            if (defined($parm_data{$dt2})) {
                                $dt = $dt2;
                                last;
                            }
                            $dt2 = &adjust_dt($dt, -1 *$mi);
                            if (defined($parm_data{$dt2})) {
                                $dt = $dt2;
                                last;
                            }
                        }
                    }
                }

#               Determine whether data are available on this date
                if (defined($parm_data{$dt}) && defined($elev_data{$dt})) {
                    $data_available = 1;
                } else {
                    $data_available = $np = 0;
                }

#               Find the water-surface elevation and number of active layers
                if ($data_available) {
                    $nlayers   = $#{ $parm_data{$dt} } +1;
                    $surf_elev = $elev_data{$dt};
                    $kt        = $kt_data{$dt};
                    $kt        = $kb[$seg] if ($kt > $kb[$seg] && $nlayers == 1);
                }

#               Get coordinates for the profile
                $xmin   = $gr_props{$id}{xmin};
                $xmax   = $gr_props{$id}{xmax};
                $xrange = $xmax -$xmin;
                @coords = @tmp = ();
                if ($data_available) {
                    if ($gr_props{$id}{pr_style} =~ /stairstep/i || $nlayers == 1) {
                        for ($i=0; $i<$nlayers; $i++) {
                            $pval = $parm_data{$dt}[$i];
                            $pval = $pval *1.8 +32 if ($props{$id}{parm}       eq "Temperature" &&
                                                       $props{$id}{parm_units} eq "Fahrenheit");
                            $xp   = &max($x1, &min($x2, $x1 +($x2-$x1)*($pval-$xmin)/$xrange));
                            if ($i == 0) {
                                $yval = $surf_elev;
                            } else {
                                $yval = $el[$kt+$i][$seg];
                            }
                            if ($gr_props{$id}{ytype} eq "Depth") {
                                $yp1 = $y1 +($y2-$y1)*($surf_elev-$yval)/$ymax;
                            } else {
                                $yp1 = $y2 -($y2-$y1)*($yval-$ymin)/$yrange;
                            }
                            last if ($yp1 >= $y2);
                            $yp1 = &max($y1, &min($y2, $yp1));
                            if ($gr_props{$id}{ytype} eq "Depth") {
                                $yp2 = $y1 +($y2-$y1)*($surf_elev-$el[$kt+$i+1][$seg])/$ymax;
                            } else {
                                $yp2 = $y2 -($y2-$y1)*($el[$kt+$i+1][$seg]-$ymin)/$yrange;
                            }
                            next if ($yp2 <= $y1);
                            $yp2 = &max($y1, &min($y2, $yp2));
                            push (@coords, $xp, $yp1, $xp, $yp2);
                            last if ($yp2 >= $y2);
                        }
                        $np = ($#coords +1)/2;
                        $in_yrange = ($np > 1) ? 1 : 0;
                    } else {
                        for ($i=0; $i<$nlayers; $i++) {
                            $pval = $parm_data{$dt}[$i];
                            $pval = $pval *1.8 +32 if ($props{$id}{parm}       eq "Temperature" &&
                                                       $props{$id}{parm_units} eq "Fahrenheit");
                            $xp   = &max($x1, &min($x2, $x1 +($x2-$x1)*($pval-$xmin)/$xrange));
                            if ($i == 0) {
                                if ($gr_props{$id}{ytype} eq "Depth") {
                                    $yp1 = $y1;
                                    $yp2 = $y1 +($y2-$y1)
                                               *($surf_elev-0.5*($surf_elev+$el[$kt+1][$seg]))/$ymax;
                                } else {
                                    $yp1 = $y2 -($y2-$y1)*($surf_elev-$ymin)/$yrange;
                                    $yp2 = $y2 -($y2-$y1)*(0.5*($surf_elev+$el[$kt+1][$seg])-$ymin)/$yrange;
                                }
                                last if ($yp1 >= $y2);
                                push (@tmp, $xp, $yp1, $xp, $yp2);
                            } else {
                                $yval = 0.5*($el[$kt+$i][$seg] +$el[$kt+$i+1][$seg]);
                                if ($gr_props{$id}{ytype} eq "Depth") {
                                    $yp = $y1 +($y2-$y1)*($surf_elev-$yval)/$ymax;
                                } else {
                                    $yp = $y2 -($y2-$y1)*($yval-$ymin)/$yrange;
                                }
                                push (@tmp, $xp, $yp);
                            }
                            if ($i == $nlayers-1) {
                                if ($gr_props{$id}{ytype} eq "Depth") {
                                    $yp = $y1 +($y2-$y1)*($surf_elev-$el[$kt+$i+1][$seg])/$ymax;
                                } else {
                                    $yp = $y2 -($y2-$y1)*($el[$kt+$i+1][$seg]-$ymin)/$yrange;
                                }
                                push (@tmp, $xp, $yp);
                            }
                        }

                      # Remove points outside of graph view and interpolate others to graph edges
                        ($in_yrange, @coords) = &clip_profile($x1, $x2, $y1, $y2, @tmp);
                        $np = ($#coords +1)/2;
                    }
                }

                if ($gr_props{$id}{add_cs} && $in_yrange) {

#                   Create an image to hold the color profile and recognize its methods
                    $iw = $x2 -$x1 +1;
                    $ih = $y2 -$y1 +1;
                    $cmap_image = Tkx::image_create_photo(-width => $iw, -height => $ih);
                    $cmap_image = Tkx::widget->new($cmap_image);
                    $xp1 = $yp2 = $yp4 = $yp4i = $pval4 = $j4 = 0;
                    $xp2 = $iw -1;

#                   By Layer option
                    if ($gr_props{$id}{pc_style} =~ /by layer/i || $nlayers == 1) {
                        if ($gr_props{$id}{ytype} ne "Depth") {
                            $yp2 = &round_to_int($ih-1 -($ih-1)*($surf_elev-$ymin)/$yrange);
                            $yp2 = &max(0, &min($ih-1, $yp2));
                        }
                        for ($i=0; $i<$nlayers; $i++) {
                            $yp1 = $yp2;
                            last if ($yp1 >= $ih-1);
                            if ($gr_props{$id}{ytype} eq "Depth") {
                                $yp2 = &round_to_int(($ih-1)*($surf_elev-$el[$kt+$i+1][$seg])/$ymax);
                            } else {
                                $yp2 = &round_to_int($ih-1 -($ih-1)*($el[$kt+$i+1][$seg]-$ymin)/$yrange);
                            }
                            if ($yp2 < 0) {
                                $yp2 = 0;
                                next;
                            }
                            $yp2  = &min($ih-1, $yp2);
                            $pval = $parm_data{$dt}[$i];
                            $pval = $pval *1.8 +32 if ($props{$id}{parm}       eq "Temperature" &&
                                                       $props{$id}{parm_units} eq "Fahrenheit");
                            $j    = &max(0, &min($#colors, int(($#colors+1) *($pval-$cs_min)/$cs_range)));
                            $cmap_image = &image_put_color($cmap_image, $colors[$j],
                                                           $xp1, $yp1, $xp2, $yp2);
                            last if ($yp2 >= $ih-1);
                        }

#                   Max Interpolation option
                    } elsif ($gr_props{$id}{pc_style} =~ /max interp/i) {
                        if ($gr_props{$id}{ytype} ne "Depth") {
                            $yp2 = $ih-1 -($ih-1)*($surf_elev-$ymin)/$yrange;
                        }
                        $yp1i = &max(0, &min($ih-1, &round_to_int($yp2)));
                        for ($i=0; $i<$nlayers; $i++) {
                            $yp1   = $yp2;
                            $yp3   = $yp4;
                            $yp3i  = $yp4i;
                            $pval3 = $pval4;
                            $j3    = $j4;
                            last if ($i == 0 && $yp1 >= $ih-1);
                            last if ($i >  0 && $yp3 >= $ih-1);
                            if ($gr_props{$id}{ytype} eq "Depth") {
                                $yp2 = ($ih-1)*($surf_elev-$el[$kt+$i+1][$seg])/$ymax;
                            } else {
                                $yp2 = $ih-1 -($ih-1)*($el[$kt+$i+1][$seg]-$ymin)/$yrange;
                            }
                            $pval4 = $parm_data{$dt}[$i];
                            $pval4 = $pval4 *1.8 +32 if ($props{$id}{parm}       eq "Temperature" &&
                                                         $props{$id}{parm_units} eq "Fahrenheit");
                            $j4    = &max(0, &min($#colors, int(($#colors+1) *($pval4-$cs_min)/$cs_range)));
                            $yp4   = 0.5*($yp1+$yp2);
                            $yp4i  = &max(0, &min($ih-1, &round_to_int($yp4)));
                            next if (&round_to_int($yp4) < 0);
                            if ($i==0) {
                                $cmap_image = &image_put_color($cmap_image, $colors[$j4],
                                                               $xp1, $yp1i, $xp2, $yp4i);
                                last if ($yp4i >= $ih-1);
                            } else {
                                if ($j4 == $j3) {
                                    $cmap_image = &image_put_color($cmap_image, $colors[$j4],
                                                                   $xp1, $yp3i, $xp2, $yp4i);
                                } else {
                                    $jj = ($j3 < $j4) ? 1 : -1;
                                    for ($j=$j3*$jj; $j<=$j4*$jj; $j++) {
                                        $pval = ($j3 < $j4) ? $scale[$j+1] : $scale[$j*$jj];
                                        $yp   = $yp3 +($yp4-$yp3)*($pval-$pval3)/($pval4-$pval3);
                                        $yp   = &max($yp3, &min($yp4, $yp));
                                        next if (&round_to_int($yp) < 0);
                                        $ypi  = &max(0, &min($ih-1, &round_to_int($yp)));
                                        $cmap_image = &image_put_color($cmap_image, $colors[$j*$jj],
                                                                       $xp1, $yp3i, $xp2, $ypi);
                                        $yp3i = $ypi;
                                        last if ($yp >= $ih-1);
                                    }
                                    $yp4i = $yp3i;
                                }
                            }
                            if ($i==$nlayers-1) {
                                $yp2 = &round_to_int($yp2);
                                last if ($yp2 < 0);
                                $yp2 = &min($ih-1, $yp2);
                                $cmap_image = &image_put_color($cmap_image, $colors[$j4],
                                                               $xp1, $yp4i, $xp2, $yp2);
                            }
                        }

#                   Interpolation option
                    } else {
                        if ($gr_props{$id}{ytype} ne "Depth") {
                            $yp2 = $ih-1 -($ih-1)*($surf_elev-$ymin)/$yrange;
                        }
                        for ($i=0; $i<$nlayers; $i++) {
                            $yp1 = $yp2;
                            $yp3 = $yp4;
                            if ($gr_props{$id}{ytype} eq "Depth") {
                                $yp2 = ($ih-1)*($surf_elev-$el[$kt+$i+1][$seg])/$ymax;
                            } else {
                                $yp2 = $ih-1 -($ih-1)*($el[$kt+$i+1][$seg]-$ymin)/$yrange;
                            }
                            $pval = $parm_data{$dt}[$i];
                            $pval = $pval *1.8 +32 if ($props{$id}{parm}       eq "Temperature" &&
                                                       $props{$id}{parm_units} eq "Fahrenheit");
                            $j    = &max(0, &min($#colors, int(($#colors+1) *($pval-$cs_min)/$cs_range)));
                            if ($i==0) {
                                $yp4 = &round_to_int(0.25*$yp1 +0.75*$yp2);
                                $yp1 = &round_to_int($yp1);
                                last if ($yp1 >= $ih-1);
                                if ($yp4 < 0) {
                                    $yp4 = 0;
                                    next;
                                }
                                $yp4 = &min($ih-1, $yp4);
                                $cmap_image = &image_put_color($cmap_image, $colors[$j],
                                                               $xp1, $yp1, $xp2, $yp4);
                            } else {
                                $pval = 0.5*($parm_data{$dt}[$i-1] +$parm_data{$dt}[$i]);
                                $pval = $pval *1.8 +32 if ($props{$id}{parm}       eq "Temperature" &&
                                                           $props{$id}{parm_units} eq "Fahrenheit");
                                $j2   = &max(0, &min($#colors, int(($#colors+1) *($pval-$cs_min)/$cs_range)));
                                $yp4  = &round_to_int(0.75*$yp1 +0.25*$yp2);
                                if ($yp4 < 0) {
                                    $yp4 = 0;
                                    next;
                                }
                                $yp4 = &min($ih-1, $yp4);
                                $cmap_image = &image_put_color($cmap_image, $colors[$j2],
                                                               $xp1, $yp3, $xp2, $yp4);
                                last if ($yp4 >= $ih-1);
                                $yp3 = $yp4;
                                $yp4 = &round_to_int(0.25*$yp1 +0.75*$yp2);
                                if ($yp4 < 0) {
                                    $yp4 = 0;
                                    next;
                                }
                                $yp4 = &min($ih-1, $yp4);
                                $cmap_image = &image_put_color($cmap_image, $colors[$j],
                                                               $xp1, $yp3, $xp2, $yp4);
                            }
                            last if ($yp4 >= $ih-1);
                            if ($i==$nlayers-1) {
                                $yp2 = &round_to_int($yp2);
                                last if ($yp2 < 0);
                                $yp2 = &min($ih-1, $yp2);
                                $cmap_image = &image_put_color($cmap_image, $colors[$j],
                                                               $xp1, $yp4, $xp2, $yp2);
                            }
                        }
                    }
                    $canv->create_image($x1, $y1, -anchor => 'nw',
                                                  -image  => $cmap_image,
                                                  -tags   => $gtag . " " . $gtag . "_colorProfile");
                    undef $cmap_image;
                }

#               Plot the water surface and its indicator, if plotting elevations
                if ($data_available && $gr_props{$id}{ytype} ne "Depth") {
                    $yp = $y2 -($y2-$y1)*($surf_elev-$ymin)/$yrange;
                    if ($yp >= $y1 && $yp <= $y2) {
                        $canv->create_line($x1, $yp, $x2, $yp,
                                            -fill  => &get_rgb_code("gray60"),
                                            -width => 1,
                                            -arrow => 'none',
                                            -tags  => $gtag . " " . $gtag . "_profile");
                        $xp = $x1 + 0.9*($x2-$x1);
                        $canv->create_polygon($xp, $yp, $xp-4, $yp-8, $xp+4, $yp-8,
                                            -outline => &get_rgb_code("gray60"),
                                            -width   => 1,
                                            -fill    => &get_rgb_code("white"),
                                            -tags    => $gtag . " " . $gtag . "_profile");
                    }
                }

#               Plot the profile
                if ($np > 1) {
                    if ($gr_props{$id}{pr_style} =~ /stairstep/i || &list_search("-999", @coords) == -1) {
                        $canv->create_line(@coords, -fill  => &get_rgb_code($gr_props{$id}{pr_linec}),
                                                    -width => $gr_props{$id}{pr_linew},
                                                    -arrow => 'none',
                                                    -tags  => $gtag . " " . $gtag . "_profile");
                    } else {
                        @tmp = ();
                        for ($i=0; $i<$#coords; $i+=2) {
                            if ($coords[$i] != -999 && $coords[$i+1] != -999) {
                                push (@tmp, $coords[$i], $coords[$i+1]);
                            } else {
                                if ($#tmp > 1) {
                                    $canv->create_line(@tmp,
                                                       -fill  => &get_rgb_code($gr_props{$id}{pr_linec}),
                                                       -width => $gr_props{$id}{pr_linew},
                                                       -arrow => 'none',
                                                       -tags  => $gtag . " " . $gtag . "_profile");
                                }
                                @tmp = ();
                            }
                        }
                        if ($#tmp > 1) {
                            $canv->create_line(@tmp,
                                               -fill  => &get_rgb_code($gr_props{$id}{pr_linec}),
                                               -width => $gr_props{$id}{pr_linew},
                                               -arrow => 'none',
                                               -tags  => $gtag . " " . $gtag . "_profile");
                        }
                    }
                }

#               Plot a no-data message
                if (! $data_available || ! $in_yrange) {
                    $canv->create_text(($x1+$x2)/2., ($y1 +$y2)/2.,
                                       -anchor => 'center', 
                                       -text   => "No Data",
                                       -fill   => &get_rgb_code("gray60"),
                                       -angle  => 0,
                                       -tags   => $gtag . " " . $gtag . "_profile",
                                       -font   => [-family     => $gr_props{$id}{xfont},
                                                   -size       => $gr_props{$id}{xl_size},
                                                   -weight     => 'normal',
                                                   -slant      => 'roman',
                                                   -underline  => 0,
                                                   -overstrike => 0,
                                                  ]);
                }

#               Add any measured profile data
                if (defined($props{$id}{ref_file})) {
                    &plot_ref_profile($canv, $id, 0, $nb);
                }
            }
        }
        undef %kt_data;
        undef %elev_data;
        undef %parm_data;

#       Add or update goodness-of-fit statistics for a matrix plot
        if ($props{$id}{meta} eq "w2_profile_matrix") {
            if (defined($gr_props{$id}{ms_stats}) && $gr_props{$id}{ms_stats}) {
                &set_matrix_stats($canv, $id);
            }
        }

#       Place the graphic items in the proper order
        &raise_lower($canv, $id, "tiptop") if ($new_graph);
        if ($gr_props{$id}{add_cs}) {
            $canv->lower($gtag . "_colorKey",      $id);
            $canv->lower($gtag . "_colorKeyTitle", $id);
            $canv->lower($gtag . "_colorProfile",  $id);
        }
        $canv->lower($gtag . "_profile",    $id);
        $canv->lower($gtag . "_refData",    $id);
        $canv->lower($gtag . "_date",       $id);
        $canv->lower($gtag . "_stats",      $id) if ($props{$id}{meta} eq "w2_profile_matrix");
        $canv->lower($gtag . "_gtitle",     $id);
        $canv->lower($gtag . "_xaxisTitle", $id);
        $canv->lower($gtag . "_yaxisTitle", $id);
        $canv->lower($gtag . "_xaxis",      $id);
        $canv->lower($gtag . "_yaxis",      $id);
        $canv->lower($gtag . "_frame",      $id) if ($props{$id}{meta} eq "w2_profile_matrix");
        if ($group_tags) {
            foreach $tag (@grp_tags) {
                $canv->addtag($tag, withtag => $gtag);
            }
        }

#       Update any links
        &update_links($canv, $id, $dt) if ($props{$id}{meta} eq "w2_profile");

#   A water-temperature colormap is requested
    } elsif ($props{$id}{meta} eq "w2_profile_cmap") {

#       Keep track of graphs that can be animated
#       Colormaps only get a bit of animation when they have an accompanying profile
#       For first creation, ensure mouse cursor is on canvas so it can be changed
        $move_mcursor = 0;
        if (! @animate_ids || &list_match($id, @animate_ids) == -1) {
            push (@animate_ids, $id);
            $move_mcursor = 1;
        }

        @jdates = &dates2jdates(@mydates);
        if ($gr_props{$id}{xmin} eq "first" && $gr_props{$id}{xmax} eq "last") {
            $jd_min = &floor($jdates[0] +0.0000001);
            $jd_max = &floor($jdates[$#jdates] +1.0000001);
            if ($gr_props{$id}{xtype} eq "Date/Time") {
                $gr_props{$id}{xmin} = &jdate2datelabel($jd_min, "Mon-DD-YYYY");
                $gr_props{$id}{xmax} = &jdate2datelabel($jd_max, "Mon-DD-YYYY");
            }
        } else {
            if (! defined($gr_props{$id}{base_yr})) {
                $gr_props{$id}{base_yr} = substr($mydates[0],0,4);
            }
            if ($gr_props{$id}{xtype} eq "Date/Time") {
                $jd_min = &datelabel2jdate($gr_props{$id}{xmin});
                $jd_max = &datelabel2jdate($gr_props{$id}{xmax});
            } else {
                $base_jd = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
                $jd_min  = $gr_props{$id}{xmin} +$base_jd -1;
                $jd_max  = $gr_props{$id}{xmax} +$base_jd -1;
            }
        }

#       Plot the graph title
        $yp = ($gr_props{$id}{xop_tics} =~ /outside|cross/) ? $y1-18 : $y1-10;
        $canv->create_text(($x1+$x2)/2., $yp,
                           -anchor => 's', 
                           -text   => $gr_props{$id}{gtitle},
                           -fill   => &get_rgb_code("black"),
                           -angle  => 0,
                           -tags   => $gtag . " " . $gtag . "_gtitle",
                           -font   => [-family     => $gr_props{$id}{gtfont},
                                       -size       => $gr_props{$id}{gt_size},
                                       -weight     => $gr_props{$id}{gt_weight},
                                       -slant      => 'roman',
                                       -underline  => 0,
                                       -overstrike => 0,
                                      ]);

#       Plot the X axis -- Date/Time or Julian Date
#       For the date X axis, over-ride any user-supplied axis title
        $axis_props{major}   = $gr_props{$id}{xmajor};
        $axis_props{minor}   = 1;
        $axis_props{pr_tics} = $gr_props{$id}{xpr_tics};
        $axis_props{op_tics} = $gr_props{$id}{xop_tics};
        $axis_props{reverse} = 0;
        $axis_props{font}    = $gr_props{$id}{xfont};
        $axis_props{size1}   = $gr_props{$id}{xl_size};
        $axis_props{size2}   = $gr_props{$id}{xt_size};
        $axis_props{weight1} = $gr_props{$id}{xl_weight};
        $axis_props{weight2} = $gr_props{$id}{xt_weight};
        $axis_props{side}    = "bottom";
        $axis_props{tags}    = $gtag . " " . $gtag . "_xaxis";
        $axis_props{coords}  = [$x1, $y2, $x2, $y2];
        $axis_props{op_loc}  = $y1;
        if ($gr_props{$id}{xtype} eq "Date/Time") {
            $yr_min = substr($gr_props{$id}{xmin},7,4);
            $yr_max = substr($gr_props{$id}{xmax},7,4);
            $yr_max-- if (substr($gr_props{$id}{xmax},0,3) eq "Jan" &&
                          substr($gr_props{$id}{xmax},4,2) eq "01");
            if ($yr_min == $yr_max) {
                $gr_props{$id}{xtitle} = "Date in $yr_min";
            } else {
                $gr_props{$id}{xtitle} = "Date ($yr_min-$yr_max)";
            }
            $axis_props{min}     = $jd_min;
            $axis_props{max}     = $jd_max;
            $axis_props{title}   = $gr_props{$id}{xtitle};
            $axis_props{datefmt} = $gr_props{$id}{datefmt};
            &make_date_axis($canv, %axis_props);
        } else {
            $axis_props{min}     = $gr_props{$id}{xmin};
            $axis_props{max}     = $gr_props{$id}{xmax};
            $axis_props{title}   = $gr_props{$id}{xtitle};
            &make_axis($canv, %axis_props);
        }
        undef %axis_props;

#       Plot the optional dateline
        if ($gr_props{$id}{dateline}) {
            $add_dateline = 0;
            for ($i=0; $i<=$#animate_ids; $i++) {
                $id2 = $animate_ids[$i];
                next if ($id2 == $id);
                next if ($props{$id2}{meta}
                          !~ /^(data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)$/);
                if ($dti != 1) {
                    $add_dateline = 1;
                    last;
                }
            }
            if ($add_dateline) {
                $jd = &date2jdate($dates[$dti-1]);
                if ($jd >= $jd_min && $jd <= $jd_max) {
                    $xp = $x1 + ($x2 -$x1) *($jd -$jd_min)/($jd_max -$jd_min);
                    $canv->create_line($xp, $y1, $xp, $y2,
                                       -fill  => &get_rgb_code($gr_props{$id}{datelinec}),
                                       -width => 1,
                                       -arrow => 'none',
                                       -tags  => $gtag . " " . $gtag . "_colorMapDateline");
                }
            }
        }

#       Don't recompute and redraw unless necessary
        if (! $gr_props{$id}{redraw}) {
            $canv->lower($gtag . "_colorKey",         $id);
            $canv->lower($gtag . "_colorKeyTitle",    $id);
            $canv->lower($gtag . "_gtitle",           $id);
            $canv->lower($gtag . "_xaxisTitle",       $id);
            $canv->lower($gtag . "_yaxisTitle",       $id);
            $canv->lower($gtag . "_colorMap",         $id);
            $canv->lower($gtag . "_colorMapDateline", $id);
            $canv->lower($gtag . "_xaxis",            $id);
            $canv->lower($gtag . "_yaxis",            $id);
            if ($group_tags) {
                foreach $tag (@grp_tags) {
                    $canv->addtag($tag, withtag => $gtag);
                }
            }
            return;
        }

#       Create an image to hold the colormap and recognize its methods
#       This takes time, so don't redraw if it isn't needed
        $iw = $x2 -$x1 +1;
        $ih = $y2 -$y1 +1;
        $cmap_image = Tkx::image_create_photo(-width => $iw, -height => $ih);
        $cmap_image = Tkx::widget->new($cmap_image);

#       Create a progress bar
        $geom = $main->g_wm_geometry();
        (undef, $X, $Y) = split(/\+/, $geom);
        $geom = sprintf("+%d+%d", $X+($x1+$x2)/2-150, $Y+($y1+$y2)/2);

        $pbar_window = $main->new_toplevel();
        $pbar_window->g_wm_transient($main);
        $pbar_window->g_wm_title("Working on colormap...");
        $pbar_window->g_wm_geometry($geom);
        $pbar_window->configure(-cursor => $cursor_wait);
        $pbar_window->g_focus;

        $pbar_frame = $pbar_window->new_frame(
                        -borderwidth => 2,
                        -relief      => 'groove');
        $pbar_frame->g_pack(-anchor => 'nw', -expand => 1, -fill => 'x');
        ($pbar = $pbar_frame->new_ttk__progressbar(
                        -orient  => 'horizontal',
                        -length  => 300,
                        -mode    => 'determinate',
                        -value   => 0,
                        -maximum => $jd_max -$jd_min,
                        ))->g_pack();

#       Move mouse cursor on first creation, to ensure that it changes to cursor_wait
        if ($move_mcursor) {
            if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
                $mpointerx = Tkx::winfo_pointerx($main);
                $mpointery = Tkx::winfo_pointery($main);
                $canv->g_bind("<Motion>", "");
                Tkx::event_generate($main, "<Motion>", -warp => 1, -x => ($x1+$x2)/2, -y => ($y1+$y2)/2);
                $canv->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"), $canv, "menu" ]);
            }
        }

#       Change the mouse cursor to tell the user to be patient
        if ($resized) {
            $canv->configure(-cursor => $cursor_wait);
        } else {
            Tkx::tk_busy_hold($main, -cursor => $cursor_wait);
        }
        if ($move_mcursor) {
            if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
                Tkx::update();
                $canv->g_bind("<Motion>", "");
                Tkx::event_generate("", "<Motion>", -warp => 1, -x => $mpointerx, -y => $mpointery);
                $canv->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"), $canv, "menu" ]);
            }
        }
        $status_line = "Working on colormap.  Please wait...";
        Tkx::update();
        Tkx::wm_resizable($pbar_window,0,0);

#       Create the colormap
        for ($n=0; $n<=$#jdates; $n++) {
            $jd = $jdates[$n];
            next if ($jd < $jd_min);
            last if ($jd > $jd_max);
            if ($n == 0 || $jd == $jd_min) {
                $jd2 = ($jd +$jdates[$n+1])/2.;
                $xp1 = &round_to_int(($iw-1)*($jd -$jd_min)/($jd_max-$jd_min));
                $xp2 = &round_to_int(($iw-1)*($jd2-$jd_min)/($jd_max-$jd_min));
                next if ($xp1 == $xp2);
            } elsif ($n == $#jdates || $jd == $jd_max) {
                $jd0 = ($jd +$jdates[$n-1])/2.;
                $xp1 = &round_to_int(($iw-1)*($jd0-$jd_min)/($jd_max-$jd_min));
                $xp2 = &round_to_int(($iw-1)*($jd -$jd_min)/($jd_max-$jd_min));
                $xp2 = $iw-1 if (abs($jd_max -$jd) <= 1);
            } else {
                $jd0 = ($jd +$jdates[$n-1])/2.;
                $jd2 = ($jd +$jdates[$n+1])/2.;
                $xp1 = &round_to_int(($iw-1)*($jd0-$jd_min)/($jd_max-$jd_min));
                $xp2 = &round_to_int(($iw-1)*($jd2-$jd_min)/($jd_max-$jd_min));
                next if ($xp1 == $xp2);
            }
            $xp1 = &max(0, &min($iw-1, $xp1));
            $xp2 = &max(0, &min($iw-1, $xp2));
            $pbar->configure(-value => $jd -$jd_min);  # update the progress bar
            Tkx::update_idletasks();

            $dt        = $mydates[$n];
            $nlayers   = $#{ $parm_data{$dt} } +1;
            $surf_elev = $elev_data{$dt};
            $kt        = $kt_data{$dt};
            $kt        = $kb[$seg] if ($kt > $kb[$seg] && $nlayers == 1);

            next if ($nlayers < 1);

            $yp2 = 0;

#           By Layer option
            if ($gr_props{$id}{pc_style} =~ /by layer/i || $nlayers == 1) {
                if ($gr_props{$id}{ytype} ne "Depth") {
                    $yp2 = &round_to_int($ih-1 -($ih-1)*($surf_elev-$ymin)/$yrange);
                    $yp2 = &max(0, &min($ih-1, $yp2));
                }
                for ($i=0; $i<$nlayers; $i++) {
                    $yp1 = $yp2;
                    last if ($yp1 >= $ih-1);
                    if ($gr_props{$id}{ytype} eq "Depth") {
                        $yp2 = &round_to_int(($ih-1)*($surf_elev-$el[$kt+$i+1][$seg])/$ymax);
                    } else {
                        $yp2 = &round_to_int($ih-1 -($ih-1)*($el[$kt+$i+1][$seg]-$ymin)/$yrange);
                    }
                    if ($yp2 < 0) {
                        $yp2 = 0;
                        next;
                    }
                    $yp2  = &min($ih-1, $yp2);
                    $pval = $parm_data{$dt}[$i];
                    $pval = $pval *1.8 +32 if ($props{$id}{parm}       eq "Temperature" &&
                                               $props{$id}{parm_units} eq "Fahrenheit");
                    $j    = &max(0, &min($#colors, int(($#colors+1) *($pval-$cs_min)/$cs_range)));
                    $cmap_image = &image_put_color($cmap_image, $colors[$j],
                                                   $xp1, $yp1, $xp2, $yp2);
                    last if ($yp2 >= $ih-1);
                }

#           Max Interpolation option
            } elsif ($gr_props{$id}{pc_style} =~ /max interp/i) {
                if ($gr_props{$id}{ytype} ne "Depth") {
                    $yp2 = $ih-1 -($ih-1)*($surf_elev-$ymin)/$yrange;
                }
                $yp1i = &max(0, &min($ih-1, &round_to_int($yp2)));
                for ($i=0; $i<$nlayers; $i++) {
                    $yp1   = $yp2;
                    $yp3   = $yp4;
                    $yp3i  = $yp4i;
                    $pval3 = $pval4;
                    $j3    = $j4;
                    last if ($i == 0 && $yp1 >= $ih-1);
                    last if ($i >  0 && $yp3 >= $ih-1);
                    if ($gr_props{$id}{ytype} eq "Depth") {
                        $yp2 = ($ih-1)*($surf_elev-$el[$kt+$i+1][$seg])/$ymax;
                    } else {
                        $yp2 = $ih-1 -($ih-1)*($el[$kt+$i+1][$seg]-$ymin)/$yrange;
                    }
                    $pval4 = $parm_data{$dt}[$i];
                    $pval4 = $pval4 *1.8 +32 if ($props{$id}{parm}       eq "Temperature" &&
                                                 $props{$id}{parm_units} eq "Fahrenheit");
                    $j4    = &max(0, &min($#colors, int(($#colors+1) *($pval4-$cs_min)/$cs_range)));
                    $yp4   = 0.5*($yp1+$yp2);
                    $yp4i  = &max(0, &min($ih-1, &round_to_int($yp4)));
                    next if (&round_to_int($yp4) < 0);
                    if ($i==0) {
                        $cmap_image = &image_put_color($cmap_image, $colors[$j4],
                                                       $xp1, $yp1i, $xp2, $yp4i);
                        last if ($yp4i >= $ih-1);
                    } else {
                        if ($j4 == $j3) {
                            $cmap_image = &image_put_color($cmap_image, $colors[$j4],
                                                           $xp1, $yp3i, $xp2, $yp4i);
                        } else {
                            $jj = ($j3 < $j4) ? 1 : -1;
                            for ($j=$j3*$jj; $j<=$j4*$jj; $j++) {
                                $pval = ($j3 < $j4) ? $scale[$j+1] : $scale[$j*$jj];
                                $yp   = $yp3 +($yp4-$yp3)*($pval-$pval3)/($pval4-$pval3);
                                $yp   = &max($yp3, &min($yp4, $yp));
                                next if (&round_to_int($yp) < 0);
                                $ypi  = &max(0, &min($ih-1, &round_to_int($yp)));
                                $cmap_image = &image_put_color($cmap_image, $colors[$j*$jj],
                                                               $xp1, $yp3i, $xp2, $ypi);
                                $yp3i = $ypi;
                                last if ($yp >= $ih-1);
                            }
                            $yp4i = $yp3i;
                        }
                    }
                    if ($i==$nlayers-1) {
                        $yp2 = &round_to_int($yp2);
                        last if ($yp2 < 0);
                        $yp2 = &min($ih-1, $yp2);
                        $cmap_image = &image_put_color($cmap_image, $colors[$j4],
                                                       $xp1, $yp4i, $xp2, $yp2);
                    }
                }

#           Interpolation option
            } else {
                if ($gr_props{$id}{ytype} ne "Depth") {
                    $yp2 = $ih-1 -($ih-1)*($surf_elev-$ymin)/$yrange;
                }
                for ($i=0; $i<$nlayers; $i++) {
                    $yp1 = $yp2;
                    $yp3 = $yp4;
                    if ($gr_props{$id}{ytype} eq "Depth") {
                        $yp2 = ($ih-1)*($surf_elev-$el[$kt+$i+1][$seg])/$ymax;
                    } else {
                        $yp2 = $ih-1 -($ih-1)*($el[$kt+$i+1][$seg]-$ymin)/$yrange;
                    }
                    $pval = $parm_data{$dt}[$i];
                    $pval = $pval *1.8 +32 if ($props{$id}{parm}       eq "Temperature" &&
                                               $props{$id}{parm_units} eq "Fahrenheit");
                    $j    = &max(0, &min($#colors, int(($#colors+1) *($pval-$cs_min)/$cs_range)));
                    if ($i==0) {
                        $yp4 = &round_to_int(0.25*$yp1 +0.75*$yp2);
                        $yp1 = &round_to_int($yp1);
                        last if ($yp1 >= $ih-1);
                        if ($yp4 < 0) {
                            $yp4 = 0;
                            next;
                        }
                        $yp4 = &min($ih-1, $yp4);
                        $cmap_image = &image_put_color($cmap_image, $colors[$j],
                                                       $xp1, $yp1, $xp2, $yp4);
                    } else {
                        $pval = 0.5*($parm_data{$dt}[$i-1] +$parm_data{$dt}[$i]);
                        $pval = $pval *1.8 +32 if ($props{$id}{parm}       eq "Temperature" &&
                                                   $props{$id}{parm_units} eq "Fahrenheit");
                        $j2   = &max(0, &min($#colors, int(($#colors+1) *($pval-$cs_min)/$cs_range)));
                        $yp4  = &round_to_int(0.75*$yp1 +0.25*$yp2);
                        if ($yp4 < 0) {
                            $yp4 = 0;
                            next;
                        }
                        $yp4 = &min($ih-1, $yp4);
                        $cmap_image = &image_put_color($cmap_image, $colors[$j2],
                                                       $xp1, $yp3, $xp2, $yp4);
                        last if ($yp4 >= $ih-1);
                        $yp3 = $yp4;
                        $yp4 = &round_to_int(0.25*$yp1 +0.75*$yp2);
                        if ($yp4 < 0) {
                            $yp4 = 0;
                            next;
                        }
                        $yp4 = &min($ih-1, $yp4);
                        $cmap_image = &image_put_color($cmap_image, $colors[$j],
                                                       $xp1, $yp3, $xp2, $yp4);
                    }
                    last if ($yp4 >= $ih-1);
                    if ($i==$nlayers-1) {
                        $yp2 = &round_to_int($yp2);
                        last if ($yp2 < 0);
                        $yp2 = &min($ih-1, $yp2);
                        $cmap_image = &image_put_color($cmap_image, $colors[$j],
                                                       $xp1, $yp4, $xp2, $yp2);
                    }
                }
            }
        }
        $canv->create_image($x1, $y1, -anchor => 'nw',
                                      -image  => $cmap_image,
                                      -tags   => $gtag . " " . $gtag . "_colorMap");
        undef $cmap_image;
        undef %kt_data;
        undef %elev_data;
        undef %parm_data;

#       Place the graphic items in the proper order
        &raise_lower($canv, $id, "tiptop") if ($new_graph);
        $canv->lower($gtag . "_colorKey",         $id);
        $canv->lower($gtag . "_colorKeyTitle",    $id);
        $canv->lower($gtag . "_gtitle",           $id);
        $canv->lower($gtag . "_xaxisTitle",       $id);
        $canv->lower($gtag . "_yaxisTitle",       $id);
        $canv->lower($gtag . "_colorMap",         $id);
        $canv->lower($gtag . "_colorMapDateline", $id);
        $canv->lower($gtag . "_xaxis",            $id);
        $canv->lower($gtag . "_yaxis",            $id);
        if ($group_tags) {
            foreach $tag (@grp_tags) {
                $canv->addtag($tag, withtag => $gtag);
            }
        }

#       Restore mouse cursor and remove the progress bar
        $canv->configure(-cursor => $cursor_norm);
        $pbar_window->g_destroy();
        $status_line = "";
        if (! $resized) {
            Tkx::tk_busy_forget($main);
        }
    }
}


sub setup_w2_slice_or_tdmap_or_wlevels {
    my ($canv, $id) = @_;
    my (
        $br_frame, $br_list, $br_start, $br_start_cb, $con_file, $f,
        $frame, $geom, $nbr, $nwb, $ok_btn, $old_br_start, $row, $seg_end,
        $seg_end_cb, $seg_list, $seg_start, $seg_start_cb, $wb_list, $X,
        $x1, $x2, $Y, $y1, $y2,

        @be, @br_cbtn, @br_plot, @bs, @ds, @idn, @us,
       );

    ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $geom = sprintf("+%d+%d", $X+$x1+30, $Y+$y1+50);

    if (defined($w2slice_setup_menu) && Tkx::winfo_exists($w2slice_setup_menu)) {
        if ($w2slice_setup_menu->g_wm_title() eq "W2 Longitudinal Slice Setup"
             || $w2slice_setup_menu->g_wm_title() eq "W2 Time/Distance Map Setup"
             || $w2slice_setup_menu->g_wm_title() eq "W2 Water Levels Graph Setup") {
            $w2slice_setup_menu->g_destroy();
            undef $w2slice_setup_menu;
        }
    }
    $w2slice_setup_menu = $main->new_toplevel();
    $w2slice_setup_menu->g_wm_transient($main);
    $w2slice_setup_menu->configure(-cursor => $cursor_norm);
    $w2slice_setup_menu->g_wm_geometry($geom);
    if ($props{$id}{meta} eq "w2_slice") {
        $w2slice_setup_menu->g_wm_title("W2 Longitudinal Slice Setup");
    } elsif ($props{$id}{meta} eq "w2_tdmap") {
        $w2slice_setup_menu->g_wm_title("W2 Time/Distance Map Setup");
    } elsif ($props{$id}{meta} eq "w2_wlevels") {
        $w2slice_setup_menu->g_wm_title("W2 Water Levels Graph Setup");
    }

#   Try to keep the nascent graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

    $con_file   = "";
    @br_cbtn    = ();
    @br_plot    = ();
    $br_plot[0] = 0;

    $seg_list  = $br_list = $wb_list = "";
    $seg_start = $seg_end = "";
    $br_start  = $old_br_start = "";

    @bs = @be = @us = @ds = @idn = ();

#   Set up the menu
    $frame = $w2slice_setup_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -state   => 'disabled',
            -command => sub { my ($jw, @wbs);
                              if ($con_file eq "" || ! -e $con_file) {
                                  return &pop_up_error($w2slice_setup_menu,
                                  "W2 Control file not set or does not exist:\n$con_file");
                              }
                              if (&sum(@br_plot) < 1) {
                                  return &pop_up_error($w2slice_setup_menu,
                                  "At least one branch must be selected for plotting.");
                              }
                              if ($seg_list eq "" || $wb_list eq "") {
                                  return &pop_up_error($w2slice_setup_menu,
                                  "You must choose a set of segments to plot. Try again.");
                              }
                              @wbs = split(/,/, $wb_list);
                              $wb_list = "";
                              foreach $jw (sort numerically @wbs) {
                                  $wb_list .= "," if ($wb_list ne "");
                                  $wb_list .= $jw;
                              }
                              $props{$id}{con_file} = $con_file;
                              $props{$id}{seg_list} = $seg_list;
                              $props{$id}{wb_list}  = $wb_list;
                              $props{$id}{br_list}  = $br_list;

                              $geom = $w2slice_setup_menu->g_wm_geometry();
                              (undef, $X, $Y) = split(/\+/, $geom);

                              $w2slice_setup_menu->g_bind('<Destroy>', "");
                              $w2slice_setup_menu->g_destroy();
                              undef $w2slice_setup_menu;

                              if ($props{$id}{meta} eq "w2_slice") {
                                  &setup_w2_slice_part2($canv, $id, $X, $Y);
                              } elsif ($props{$id}{meta} eq "w2_tdmap") {
                                  &setup_w2_tdmap_part2($canv, $id, $X, $Y);
                              } elsif ($props{$id}{meta} eq "w2_wlevels") {
                                  &setup_w2_wlevels_part2($canv, $id, $X, $Y);
                              }
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $w2slice_setup_menu->g_bind('<Destroy>', "");
                              $w2slice_setup_menu->g_destroy();
                              undef $w2slice_setup_menu;
                              $canv->delete("graph" . $id);
                              delete $props{$id};
                              delete $grid{$id} if (defined($grid{$id}));
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Delete graph if this menu is destroyed by other than the Cancel button
    $w2slice_setup_menu->g_bind('<Destroy>' => sub { undef $w2slice_setup_menu;
                                                     $canv->delete("graph" . $id);
                                                     delete $props{$id}; 
                                                     delete $grid{$id} if (defined($grid{$id}));
                                                     &reset_bindings;
                                                   });

    ($f = $w2slice_setup_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "W2 Control File: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$con_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);
    $f->new_button(
            -text    => "Browse",
            -command => sub { my ($col, $file, $font, $jb, $jw, $n, $padx, $row, $seg, $status, $txt,
                                  @seg_ds, @seglist,
                                 );
                              $file = Tkx::tk___getOpenFile(
                                      -parent           => $w2slice_setup_menu,
                                      -title            => "Select W2 Control File",
                                      -initialdir       => abs_path(),
                                      -filetypes => [ ['All Files', '*'],
                                                      ['CSV (comma delimited)', '.csv'],
                                                      ['NPT (W2 input file)', '.npt'],
                                                    ],
                                      );
                              if (defined($file) && -e $file) {
                                  $con_file = File::Spec->rel2abs($file);
                                  &read_con($main, $id, $con_file);

                                  $nbr = $grid{$id}{nbr};
                                  $nwb = $grid{$id}{nwb};
                                  @bs  = @{ $grid{$id}{bs}  };
                                  @be  = @{ $grid{$id}{be}  };
                                  @us  = @{ $grid{$id}{us}  };
                                  @ds  = @{ $grid{$id}{ds}  };
                                  @idn = @{ $grid{$id}{idn} };

                                  $br_start_cb->configure(-values => [ (1 .. $nbr) ],
                                                          -state  => 'readonly');
                                  if (&list_match($br_start, (1 .. $nbr)) == -1) {
                                      $br_start = 1;
                                  }
                                  $old_br_start = $br_start;
                                  for ($jw=1; $jw<=$nwb; $jw++) {
                                      last if ($br_start >= $bs[$jw] && $br_start <= $be[$jw]);
                                  }
                                  @seglist = ($us[$br_start] .. $ds[$br_start]);
                                  $seg_start_cb->configure(-values => [ @seglist ],
                                                           -state  => 'readonly');
                                  if ($seg_start eq ""
                                        || &list_match($seg_start, @seglist) == -1) {
                                      $seg_start = $seglist[0];
                                  }
                                  if ($seg_end eq ""
                                        || &list_match($seg_end, @seglist) == -1
                                        || $seg_end < $seg_start) {
                                      $seg_end = $seglist[$#seglist];
                                  }
                                  @seglist = ($seg_start .. $ds[$br_start]);
                                  $seg_end_cb->configure(-values => [ @seglist ],
                                                         -state  => 'readonly');
                                  $br_list  = $br_start;
                                  $wb_list  = $jw;
                                  $seg_list = $seg_start . "-" . $seg_end;

                                  for ($n=0; $n<=$#br_cbtn; $n++) {
                                      $br_cbtn[$n]->g_pack_forget();
                                  }
                                  @br_cbtn = @seg_ds = @br_plot = ();
                                  @seg_ds  = split(/,/, $idn[$br_start]);
                                  for ($jb=1; $jb<=$nbr; $jb++) {
                                      $n   = $jb -1;
                                      if ($nbr > 6) {
                                          $row  = int($n /2 +0.001);
                                          $col  = $n -2*$row;
                                          $padx = ($col == 1) ? 3 : 0;
                                      } else {
                                          $row = $n;
                                          $col = $padx = 0;
                                      }
                                      if ($jb == $br_start) {
                                          $br_plot[$n] = 1;
                                          $font   = 'bo';
                                          $status = 'normal';
                                      } else {
                                          $br_plot[$n] = 0;
                                          $font   = 'default';
                                          $status = 'disabled';
                                          foreach $seg (@seg_ds) {
                                              if ($seg >= $us[$jb] && $seg <= $ds[$jb]) {
                                                  $status = 'normal';
                                                  last;
                                              }
                                          }
                                      }
                                      $txt = "Branch " . $jb . ", Segments " . $us[$jb] . "-" . $ds[$jb];
                                      ($br_cbtn[$n] = $br_frame->new_checkbutton(
                                          -onvalue  => 1,
                                          -offvalue => 0,
                                          -text     => $txt,
                                          -font     => $font,
                                          -state    => $status,
                                          -variable => \$br_plot[$n],
                                          -command  =>
                                           [ sub { my ($n) = @_;
                                                   my ($br_pos, $j, $jb, $jw, $nn, $seg,
                                                       @brs, @seg_ds, @seglist, @wb_tmp,
                                                      );
                                                   $jb = $n +1;
                                                   if ($br_plot[$n]) {
                                                       $br_cbtn[$n]->configure(-font => 'bo');
                                                       $br_list .= "," if ($br_list ne "");
                                                       $br_list .= $jb;
                                                       if ($br_start eq "") {
                                                           $br_start = $jb;
                                                           for ($nn=0; $nn<=$#br_cbtn; $nn++) {
                                                               next if ($nn == $jb-1);
                                                               $br_cbtn[$nn]->configure(-state => 'disabled');
                                                           }
                                                           @seglist = ($us[$jb] .. $ds[$jb]);
                                                           $seg_start_cb->configure(-values => [ @seglist ],
                                                                                    -state  => 'readonly');
                                                           $seg_end_cb->configure(-state => 'readonly');
                                                           if ($seg_start eq ""
                                                                 || &list_match($seg_start, @seglist) == -1) {
                                                               $seg_start = $seglist[0];
                                                           }
                                                       }
                                                   } else {
                                                       @brs = split(/,/, $br_list);
                                                       $br_list = "";
                                                       $br_pos = &list_match($jb, @brs);
                                                       for ($j=0; $j<=$#brs; $j++) {
                                                           if ($j < $br_pos) {
                                                               $br_list .= "," if ($br_list ne "");
                                                               $br_list .= $brs[$j];
                                                               next;
                                                           }
                                                           $nn = $brs[$j] -1;
                                                           $br_plot[$nn] = 0;
                                                           $br_cbtn[$nn]->configure(-font  => 'default',
                                                                                    -state => 'disabled');
                                                       }
                                                       @seg_ds = split(/,/, $idn[$brs[$#brs]]);
                                                       foreach $seg (@seg_ds) {
                                                           for ($jb=1; $jb<=$nbr; $jb++) {
                                                               next if ($seg < $us[$jb] || $seg > $ds[$jb]);
                                                               $nn = $jb -1;
                                                               $br_cbtn[$nn]->configure(-state => 'disabled');
                                                           }
                                                       }
                                                   }
                                                   @brs = split(/,/, $br_list);
                                                   if ($#brs >= 0) {
                                                       @seg_ds = split(/,/, $idn[$brs[$#brs]]);
                                                       foreach $seg (@seg_ds) {
                                                           for ($jb=1; $jb<=$nbr; $jb++) {
                                                               next if ($seg < $us[$jb] || $seg > $ds[$jb]);
                                                               $nn = $jb -1;
                                                               $br_cbtn[$nn]->configure(-state => 'normal');
                                                           }
                                                       }
                                                   } else {
                                                       $br_start = $seg_start = $seg_end = "";
                                                       $br_start_cb->configure(-values => [(1 .. $nbr)]);
                                                       $seg_start_cb->configure(-values => [(2)],
                                                                                -state  => 'disabled');
                                                       $seg_end_cb->configure(-values => [(2)],
                                                                              -state  => 'disabled');
                                                       for ($nn=0; $nn<=$#br_cbtn; $nn++) {
                                                           $br_cbtn[$nn]->configure(-state => 'normal');
                                                       }
                                                   }
                                                   $seg_list = $wb_list = "";
                                                   for ($j=0; $j<=$#brs; $j++) {
                                                       $jb = $brs[$j];
                                                       for ($jw=1; $jw<=$nwb; $jw++) {
                                                           last if ($jb >= $bs[$jw] && $jb <= $be[$jw]);
                                                       }
                                                       if ($wb_list ne "") {
                                                           @wb_tmp = split(/,/, $wb_list);
                                                           if (&list_match($jw, @wb_tmp) == -1) {
                                                               $wb_list .= "," . $jw;
                                                           }
                                                       } else {
                                                           $wb_list .= $jw;
                                                       }
                                                       if ($jb == $br_start) {
                                                           $seg_list = $seg_start . "-" . $ds[$jb];
                                                       } else {
                                                           @seg_ds = split(/,/, $idn[$brs[$j-1]]);
                                                           foreach $seg (@seg_ds) {
                                                               if ($seg >= $us[$jb] && $seg <= $ds[$jb]) {
                                                                   $seg_list .= "," . $seg . "-" . $ds[$jb];
                                                                   last;
                                                               }
                                                           }
                                                       }
                                                       if ($j == $#brs) {
                                                           if ($seg_list =~ /,/) {
                                                               ($seg = $seg_list) =~ s/^.*,(\d+)-\d+$/$1/;
                                                           } else {
                                                               $seg = $seg_start;
                                                           }
                                                           @seglist = ($seg .. $ds[$jb]);
                                                           $seg_end_cb->configure(-values => [ @seglist ]);
                                                           if (&list_match($seg_end, @seglist) == -1) {
                                                               $seg_end = $seglist[$#seglist];
                                                           }
                                                       }
                                                   }
                                                   if (&sum(@br_plot) == 0) {
                                                       $ok_btn->configure(-state => 'disabled');
                                                   } else {
                                                       $ok_btn->configure(-state => 'normal');
                                                   }
                                                 }, $n],
                                           ))->g_grid(-row => $row, -column => $col,
                                                      -sticky => 'w', -ipadx => $padx, -pady => 1);
                                  }
                                  $ok_btn->configure(-state => 'normal');
                              } else {
                                  $ok_btn->configure(-state => 'disabled');
                              }
                            },
            )->g_grid(-row => $row, -column => 4, -sticky => 'ew', -padx => 2, -pady => 2);

    $row++;
    $f->new_label(
            -text => "Start Branch: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($br_start_cb = $f->new_ttk__combobox(
            -textvariable => \$br_start,
            -values       => [ (1) ],
            -state        => 'disabled',
            -width        => 5,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w');
    $br_start_cb->g_bind("<<ComboboxSelected>>",
                          sub { my ($font, $jb, $jw, $n, $seg, $status,
                                    @seg_ds, @seglist,
                                   );
                                return if ($br_start == $old_br_start);
                                for ($jw=1; $jw<=$nwb; $jw++) {
                                    last if ($br_start >= $bs[$jw] && $br_start <= $be[$jw]);
                                }
                                @seglist = ($us[$br_start] .. $ds[$br_start]);
                                $seg_start_cb->configure(-values => [ @seglist ],
                                                         -state  => 'readonly');
                                if ($seg_start eq ""
                                      || &list_match($seg_start, @seglist) == -1) {
                                    $seg_start = $seglist[0];
                                }
                                @seglist = ($seg_start .. $ds[$br_start]);
                                if ($seg_end eq ""
                                      || &list_match($seg_end, @seglist) == -1
                                      || $seg_end < $seg_start) {
                                    $seg_end = $seglist[$#seglist];
                                }
                                $seg_end_cb->configure(-values => [ @seglist ],
                                                       -state  => 'readonly');
                                $br_list  = $br_start;
                                $wb_list  = $jw;
                                $seg_list = $seg_start . "-" . $seg_end;

                                @seg_ds = split(/,/, $idn[$br_start]);
                                for ($jb=1; $jb<=$nbr; $jb++) {
                                    $n = $jb -1;
                                    if ($jb == $br_start) {
                                        $br_plot[$n] = 1;
                                        $font   = 'bo';
                                        $status = 'normal';
                                    } else {
                                        $br_plot[$n] = 0;
                                        $font   = 'default';
                                        $status = 'disabled';
                                        foreach $seg (@seg_ds) {
                                            if ($seg >= $us[$jb] && $seg <= $ds[$jb]) {
                                                $status = 'normal';
                                                last;
                                            }
                                        }
                                    }
                                    $br_cbtn[$n]->configure(-font  => $font,
                                                            -state => $status);
                                }
                                if (&sum(@br_plot) == 0) {
                                    $ok_btn->configure(-state => 'disabled');
                                } else {
                                    $ok_btn->configure(-state => 'normal');
                                }
                                $old_br_start = $br_start;
                              });

    $row++;
    $f->new_label(
            -text => "First Segment: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($seg_start_cb = $f->new_ttk__combobox(
            -textvariable => \$seg_start,
            -values       => [ (2) ],
            -state        => 'disabled',
            -width        => 5,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    $seg_start_cb->g_bind("<<ComboboxSelected>>",
                           sub { my ($jb, @seglist);
                                 for ($jb=1; $jb<=$nbr; $jb++) {
                                     last if ($seg_start >= $us[$jb] && $seg_start <= $ds[$jb]);
                                 }
                                 if ($seg_list =~ /,/) {
                                     $seg_list =~ s/^\d+-/${seg_start}-/;
                                 } else {
                                     @seglist = ($seg_start .. $ds[$jb]);
                                     $seg_end_cb->configure(-values => [ @seglist ]);
                                     if ($seg_end eq "" || $seg_end < $seg_start) {
                                         $seg_end = $ds[$jb];
                                     }
                                     $seg_list = $seg_start . "-" . $seg_end;
                                 }
                               });

    $row++;
    $f->new_label(
            -text    => "Include Next  \nDS Branch? ",
            -justify => 'right',
            -font    => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'ne', -pady => 2);
    ($br_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    ($br_cbtn[0] = $br_frame->new_checkbutton(
            -onvalue  => 1,
            -offvalue => 0,
            -text     => "Branch 1",
            -font     => 'default',
            -state    => 'disabled',
            -variable => \$br_plot[0],
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Last Segment: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($seg_end_cb = $f->new_ttk__combobox(
            -textvariable => \$seg_end,
            -values       => [ (2) ],
            -state        => 'disabled',
            -width        => 5,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    $seg_end_cb->g_bind("<<ComboboxSelected>>", sub { $seg_list =~ s/-\d+$/-${seg_end}/; });

    $row++;
    $f->new_label(
            -text => "Segments: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$seg_list,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');

    $row++;
    $f->new_label(
            -text => "Branches: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$br_list,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');

    $row++;
    $f->new_label(
            -text => "Waterbodies: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$wb_list,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');

    $f->g_grid_columnconfigure(3, -weight => 2, -minsize => 70);

    Tkx::wm_resizable($w2slice_setup_menu,0,0);
    &adjust_window_position($w2slice_setup_menu);
    $w2slice_setup_menu->g_focus;
}


sub setup_w2_slice_part2 {
    my ($canv, $id, $X, $Y) = @_;
    my (
        $fr, $frame, $frame2, $geom, $jw, $n, $ok_btn, $oldsrc_type, $row,
        $sc_canv, $sc_fr, $src_type, $src_type_cb, $txt, $vscroll, $w2l_btn,
        $w2l_file, $w2l_first_jd, $w2l_label1, $w2l_label2, $w2l_last_jd,

        @bth_files, @cbtn, @clab1, @clab2, @cpl_fdates, @cpl_files,
        @cpl_ldates, @cpl_lines, @f, @parmlist, @tecplot, @w2l_parms, @wbs,
       );

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($w2slice_setup_menu) && Tkx::winfo_exists($w2slice_setup_menu)) {
        if ($w2slice_setup_menu->g_wm_title() eq "W2 Longitudinal Slice Setup") {
            $w2slice_setup_menu->g_destroy();
            undef $w2slice_setup_menu;
        }
    }
    $w2slice_setup_menu = $main->new_toplevel();
    $w2slice_setup_menu->g_wm_transient($main);
    $w2slice_setup_menu->g_wm_title("W2 Longitudinal Slice Setup");
    $w2slice_setup_menu->configure(-cursor => $cursor_norm);
    $w2slice_setup_menu->g_wm_geometry($geom);

#   Try to keep the nascent graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

    @wbs          = split(/,/, $props{$id}{wb_list});
    @cpl_files    = @cpl_lines = @cpl_fdates = @cpl_ldates = ();
    @bth_files    = @parmlist  = @tecplot    = @w2l_parms = ();
    $src_type     = "W2 Contour File";
    $oldsrc_type  = $src_type;
    $w2l_file     = "";
    $w2l_first_jd = $w2l_last_jd = 0;
    for ($n=0; $n<=$#wbs; $n++) {
        $cpl_files[$n] = "          ";
        $bth_files[$n] = "";
    }

#   Set up the menu
    $frame = $w2slice_setup_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -state   => 'disabled',
            -command => sub { my ($first_jd, $i, $j, $jw1, $jw2, $last_jd, $mismatch, $n, $parm,
                                  @cpld, @cplf, @ncpl, @parm_tmp, @plist, %parms);
                              if ($src_type =~ /Contour/i) {
                                  for ($n=0; $n<=$#wbs; $n++) {
                                      if ($cpl_files[$n] eq "" || $cpl_files[$n] eq "          "
                                                               || ! -e $cpl_files[$n]) {
                                          return &pop_up_error($w2slice_setup_menu,
                                          "W2 Contour file not set or does not exist:\n$cpl_files[$n]");
                                      }
                                  }

#                                 Ensure contour dates and frequencies are identical for all waterbodies
                                  $first_jd = $cpl_fdates[0];
                                  $last_jd  = $cpl_ldates[0];
                                  if ($#wbs > 0) {
                                      @ncpl = @{ $grid{$id}{ncpl} };
                                      @cpld = @{ $grid{$id}{cpld} };
                                      @cplf = @{ $grid{$id}{cplf} };
                                      $mismatch = 0;
                                      for ($j=0; $j<=$#wbs; $j++) {
                                          $jw1 = $wbs[$j];
                                          for ($n=$j+1; $n<=$#wbs; $n++) {
                                              $jw2 = $wbs[$n];
                                              if ($ncpl[$jw1] != $ncpl[$jw2]) {
                                                  $mismatch = 1;
                                                  last;
                                              }
                                              for ($i=1; $i<=$ncpl[$jw1]; $i++) {
                                                  if ($cpld[$i][$jw1] != $cpld[$i][$jw2]) {
                                                      $mismatch = 1;
                                                      last;
                                                  }
                                                  if ($cplf[$i][$jw1] eq "na" || $cplf[$i][$jw2] eq "na") {
                                                      if ($cplf[$i][$jw1] ne $cplf[$i][$jw2]) {
                                                          $mismatch = 1;
                                                          last;
                                                      }
                                                  } else {
                                                      if ($cplf[$i][$jw1] != $cplf[$i][$jw2]) {
                                                          $mismatch = 1;
                                                          last;
                                                      }
                                                  }
                                              }
                                              last if ($mismatch);
                                          }
                                          last if ($mismatch);
                                      }
                                      if ($mismatch) {
                                          return &pop_up_error($w2slice_setup_menu,
                                              "The contour plot output dates and frequencies for\n"
                                            . "the chosen waterbodies do not match. Please try again.");
                                      }
                                      $mismatch = 0;
                                      for ($j=0; $j<=$#wbs; $j++) {
                                          for ($n=$j+1; $n<=$#wbs; $n++) {
                                              if (abs($cpl_fdates[$j] -$cpl_fdates[$n]) > 0.0007 ||
                                                  abs($cpl_ldates[$j] -$cpl_ldates[$n]) > 0.0007) {
                                                  $mismatch = 1;
                                                  last;
                                              }
                                          }
                                          last if ($mismatch);
                                      }
                                      if ($mismatch) {
                                          return &pop_up_error($w2slice_setup_menu,
                                              "The contour plot output start and end dates for the\n"
                                            . "chosen waterbodies do not match. Please try again.");
                                      }
                                  }

#                                 Only keep parameters common to all contour output files
                                  @plist = @{ $parmlist[0] };
                                  for ($n=1; $n<=$#wbs; $n++) {
                                      @parm_tmp = ();
                                      foreach $parm ( @{ $parmlist[$n] } ) {
                                          if (&list_match($parm, @plist) >= 0) {
                                              push (@parm_tmp, $parm);
                                          }
                                      }
                                      @plist = @parm_tmp;
                                  }
                                  if ($#plist < 0) {
                                      return &pop_up_error($w2slice_setup_menu,
                                        "No parameters are common to all of the W2 Contour files.");
                                  }
                                  %parms                 = ();
                                  $parms{first_jd}       = $first_jd;
                                  $parms{last_jd}        = $last_jd;
                                  $parms{parms}          = [ @plist     ];
                                  $props{$id}{tecplot}   = [ @tecplot   ];
                                  $props{$id}{cpl_lines} = [ @cpl_lines ];
                                  $props{$id}{cpl_files} = [ @cpl_files ];

                              } elsif ($src_type =~ /Vector/i) {
                                  if ($w2l_file eq "" || ! -e $w2l_file) {
                                      return &pop_up_error($w2slice_setup_menu,
                                      "W2 Vector file not set or does not exist:\n$w2l_file");
                                  }
                                  %parms                = ();
                                  $parms{parms}         = [ @w2l_parms ];
                                  $parms{first_jd}      = $w2l_first_jd;
                                  $parms{last_jd}       = $w2l_last_jd;
                                  $props{$id}{w2l_file} = $w2l_file;
                              }

                              for ($n=0; $n<=$#wbs; $n++) {
                                  if ($bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                      return &pop_up_error($w2slice_setup_menu,
                                      "W2 Bathymetry file not set or does not exist:\n$bth_files[$n]");
                                  }
                              }
                              $props{$id}{files}     = 1;
                              $props{$id}{parms}     = { %parms };
                              $props{$id}{src_type}  = $src_type;
                              $props{$id}{bth_files} = [ @bth_files ];

                              $geom = $w2slice_setup_menu->g_wm_geometry();
                              (undef, $X, $Y) = split(/\+/, $geom);

                              $w2slice_setup_menu->g_bind('<Destroy>', "");
                              $w2slice_setup_menu->g_destroy();
                              undef $w2slice_setup_menu;

                              &setup_w2_slice_part3($canv, $id, $X, $Y);
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);

    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $w2slice_setup_menu->g_bind('<Destroy>', "");
                              $w2slice_setup_menu->g_destroy();
                              undef $w2slice_setup_menu;
                              $canv->delete("graph" . $id);
                              delete $props{$id};
                              delete $grid{$id};
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Delete graph if this menu is destroyed by other than the Cancel button
    $w2slice_setup_menu->g_bind('<Destroy>' => sub { undef $w2slice_setup_menu;
                                                     $canv->delete("graph" . $id);
                                                     delete $props{$id}; 
                                                     delete $grid{$id};
                                                     &reset_bindings;
                                                   });

#   Need a scrollable container, and a canvas is about the only container that works.
#   Create a parent frame (sc_fr) for the canvas (sc_canv) and scrollbar (vscroll).
#   Then put a frame inside the canvas (fr) as a widget window to hold other menu items.
    ($sc_fr = $w2slice_setup_menu->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_pack(-side => 'top', -expand => 1, -fill => 'both');
    ($vscroll = $sc_fr->new_scrollbar(
            -orient => 'vertical',
            -width  => 15,
            ))->g_grid(-row => 0, -column => 1, -sticky => 'nse');
    ($sc_canv = $sc_fr->new_tk__canvas(
            -highlightthickness => 0,
            -yscrollcommand => [$vscroll, 'set'],
            ))->g_grid(-row => 0, -column => 0, -sticky => 'nsew');
    $vscroll->configure(-command => [$sc_canv, 'yview']);

    $fr = $sc_canv->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );

#   Source type
    $row = 0;
    $fr->new_label(
            -text => "W2 Source Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($src_type_cb = $fr->new_ttk__combobox(
            -textvariable => \$src_type,
            -values       => [ ("W2 Contour File", "W2 Vector File") ],
            -width        => 16,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $src_type_cb->g_bind("<<ComboboxSelected>>",
                          sub { my ($n, $status);
                                return if ($src_type eq $oldsrc_type);
                                $oldsrc_type = $src_type;
                                $status      = 'normal';
                                if ($src_type =~ /Contour/i) {
                                    $w2l_label1->g_grid_remove();
                                    $w2l_label2->g_grid_remove();
                                    $w2l_btn->g_grid_remove();
                                    for ($n=0; $n<=$#wbs; $n++) {
                                        $clab1[$n]->g_grid();
                                        $clab2[$n]->g_grid();
                                        $cbtn[$n]->g_grid();
                                    }
                                    $frame2->g_grid() if ($#wbs > 0);
                                    for ($n=0; $n<=$#wbs; $n++) {
                                        if ($cpl_files[$n] eq "          " ||
                                            $cpl_files[$n] eq "" || ! -e $cpl_files[$n] ||
                                            $bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                            $status = 'disabled';
                                            last;
                                        }
                                    }
                                } else {
                                    $frame2->g_grid_remove() if ($#wbs > 0);
                                    for ($n=0; $n<=$#wbs; $n++) {
                                        $clab1[$n]->g_grid_remove();
                                        $clab2[$n]->g_grid_remove();
                                        $cbtn[$n]->g_grid_remove();
                                    }
                                    $w2l_label1->g_grid();
                                    $w2l_label2->g_grid();
                                    $w2l_btn->g_grid();
                                    if ($w2l_file eq "" || ! -e $w2l_file) {
                                        $status = 'disabled';
                                    } else {
                                        for ($n=0; $n<=$#wbs; $n++) {
                                            if ($bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                                $status = 'disabled';
                                                last;
                                            }
                                        }
                                    }
                                }
                                $ok_btn->configure(-state => $status);
                                &update_scrollable_menu($w2slice_setup_menu, $sc_fr, $sc_canv,
                                                        'scrollable', $vscroll);
                              });

#   Input fields for W2 Vector file
    $row++;
    ($w2l_label1 = $fr->new_label(
            -text => "W2 Vector File: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($w2l_label2 = $fr->new_label(
            -textvariable => \$w2l_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
    ($w2l_btn = $fr->new_button(
            -text    => "Browse",
            -command =>
               sub { my ($file, $first_jd, $last_jd, $n, $ok, $parms_ref, $status);
                     $file = Tkx::tk___getOpenFile(
                             -parent    => $w2slice_setup_menu,
                             -title     => "Select W2 Vector Output File",
                             -filetypes => [ ['All Files', '*'],
                                             ['W2L (W2 Vector)', '.w2l'],
                                           ],
                             );
                     if (defined($file) && -e $file) {
                         $w2l_file = File::Spec->rel2abs($file);
                         $status_line = "Scanning W2 vector file...";  # no progress bar needed
                         &update_scrollable_menu($w2slice_setup_menu,
                                                 $sc_fr, $sc_canv, 'scrollable', $vscroll);
                         Tkx::update_idletasks();
                         ($ok, $parms_ref, undef, $first_jd, $last_jd)
                             = &scan_w2_vector_file($w2slice_setup_menu, $w2l_file, $id, 1);
                         $status_line = "";
                         if ($ok ne "okay") {
                             $w2l_file = "";
                             $ok_btn->configure(-state => 'disabled');
                             &update_scrollable_menu($w2slice_setup_menu,
                                                     $sc_fr, $sc_canv, 'scrollable', $vscroll);
                             return &pop_up_error($w2slice_setup_menu,
                                              "The specified file is not a W2 Vector (w2l) file:\n$file");
                         }
                         @w2l_parms    = @{ $parms_ref };
                         $w2l_first_jd = $first_jd;
                         $w2l_last_jd  = $last_jd;
                         $status = 'normal';
                         for ($n=0; $n<=$#wbs; $n++) {
                             if ($bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                 $status = 'disabled';
                                 last;
                             }
                         }
                         $ok_btn->configure(-state => $status);
                     } else {
                         $ok_btn->configure(-state => 'disabled');
                     }
                     &update_scrollable_menu($w2slice_setup_menu, $sc_fr, $sc_canv, 'scrollable', $vscroll);
                   },
            ))->g_grid(-row => $row, -column => 2, -sticky => 'ew', -padx => 2, -pady => 2);

    $fr->g_grid_columnconfigure(1, -weight => 2);
    $w2l_label1->g_grid_remove();
    $w2l_label2->g_grid_remove();
    $w2l_btn->g_grid_remove();

#   Loop over the required waterbodies
    for ($n=0; $n<=$#wbs; $n++) {
        $jw = $wbs[$n];

        $row++;
        ($f[$n] = $fr->new_labelframe(
                    -borderwidth => 1,
                    -relief      => 'groove',
                    -text        => "Waterbody $jw",
                ))->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew', -pady => 2);

        ($clab1[$n] = $f[$n]->new_label(
                -text => "W2 Contour File: ",
                -font => 'default',
                ))->g_grid(-row => 0, -column => 0, -sticky => 'e', -pady => 2);
        ($clab2[$n] = $f[$n]->new_label(
                -textvariable => \$cpl_files[$n],
                -anchor       => 'w',
                -font         => 'default',
                -background   => 'white',
                -relief       => 'sunken',
                -borderwidth  => 1,
                ))->g_grid(-row => 0, -column => 1, -sticky => 'ew', -pady => 2);
        ($cbtn[$n] = $f[$n]->new_button(
                -text    => "Browse",
                -command =>
                 [ sub { my ($n) = @_;
                         my ($file, $first_jd, $jw_src, $last_jd, $nlines, $parms_ref,
                             $pbar, $pbar_img, $pbar_win, $status, $tecplot,
                            );
                         $file = Tkx::tk___getOpenFile(
                                 -parent    => $w2slice_setup_menu,
                                 -title     => "Select W2 Contour Output File",
                                 -filetypes => [ ['All Files', '*'],
                                                 ['CSV (comma delimited)', '.csv'],
                                                 ['OPT (W2 output files)', '.opt'],
                                               ],
                                 );
                         if (defined($file) && -e $file) {
                             $cpl_files[$n] = File::Spec->rel2abs($file);
                             &update_scrollable_menu($w2slice_setup_menu, $sc_fr, $sc_canv,
                                                     'scrollable', $vscroll);
                             ($pbar_win, $pbar, $pbar_img)
                                 = &create_alt_progress_bar($main, $id,
                                                            "Scanning W2 contour file...");
                             ($tecplot, $nlines, $jw_src, $parms_ref, $first_jd, $last_jd)
                                 = &scan_w2_cpl_file($w2slice_setup_menu, $cpl_files[$n], $id, 1, $pbar_img);
                             &destroy_progress_bar($main, $pbar_win);

                             if ($tecplot == -1) {
                                 $cpl_files[$n] = "          ";
                                 $ok_btn->configure(-state => 'disabled');
                                 &update_scrollable_menu($w2slice_setup_menu, $sc_fr, $sc_canv,
                                                         'scrollable', $vscroll);
                                 return &pop_up_error($w2slice_setup_menu,
                                     "Specified file is not a W2 Contour output file:\n$file");
                             }
                             if ($tecplot == 0 && $jw_src != $wbs[$n]) {
                                 $cpl_files[$n] = "          ";
                                 $ok_btn->configure(-state => 'disabled');
                                 &update_scrollable_menu($w2slice_setup_menu, $sc_fr, $sc_canv,
                                                         'scrollable', $vscroll);
                                 return &pop_up_error($w2slice_setup_menu,
                                         "The specified W2 Contour output file does not\n"
                                       . "appear to be from the correct waterbody:\n"
                                       . "(" . $jw_src . " rather than " . $wbs[$n] . "):\n$file");
                             }
                             $tecplot[$n]    = $tecplot;
                             $cpl_lines[$n]  = $nlines;
                             $cpl_fdates[$n] = $first_jd;
                             $cpl_ldates[$n] = $last_jd;
                             $parmlist[$n]   = [ @{ $parms_ref } ];

                             $status = 'normal';
                             for ($n=0; $n<=$#wbs; $n++) {
                                 if ($cpl_files[$n] eq "          " ||
                                     $cpl_files[$n] eq "" || ! -e $cpl_files[$n] ||
                                     $bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                     $status = 'disabled';
                                     last;
                                 }
                             }
                             $ok_btn->configure(-state => $status);
                         } else {
                             $ok_btn->configure(-state => 'disabled');
                         }
                         &update_scrollable_menu($w2slice_setup_menu, $sc_fr, $sc_canv,
                                                 'scrollable', $vscroll);
                       }, $n ],
                ))->g_grid(-row => 0, -column => 2, -sticky => 'ew', -padx => 2, -pady => 2);

        $f[$n]->new_label(
                -text => "W2 Bathymetry File: ",
                -font => 'default',
                )->g_grid(-row => 1, -column => 0, -sticky => 'e', -pady => 2);
        $f[$n]->new_label(
                -textvariable => \$bth_files[$n],
                -anchor       => 'w',
                -font         => 'default',
                -background   => 'white',
                -relief       => 'sunken',
                -borderwidth  => 1,
                )->g_grid(-row => 1, -column => 1, -sticky => 'ew', -pady => 2);
        $f[$n]->new_button(
                -text    => "Browse",
                -command =>
                 [ sub { my ($n) = @_;
                         my ($file, $status);
                         $file = Tkx::tk___getOpenFile(
                                 -parent           => $w2slice_setup_menu,
                                 -title            => "Select W2 Bathymetry File",
                                 -defaultextension => ".csv",
                                 -filetypes => [ ['CSV (comma delimited)', '.csv'],
                                                 ['NPT (W2 input files)', '.npt'],
                                                 ['All Files', '*'],
                                               ],
                                 );
                         if (defined($file) && -e $file) {
                             $bth_files[$n] = File::Spec->rel2abs($file);
                             $status = 'normal';
                             for ($n=0; $n<=$#wbs; $n++) {
                                 if ($src_type =~ /Contour/i) {
                                     if ($cpl_files[$n] eq "          " ||
                                         $cpl_files[$n] eq "" || ! -e $cpl_files[$n] ||
                                         $bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                         $status = 'disabled';
                                         last;
                                     }
                                 } else {
                                     if ($w2l_file      eq "" || ! -e $w2l_file ||
                                         $bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                         $status = 'disabled';
                                         last;
                                     }
                                 }
                             }
                             $ok_btn->configure(-state => $status);
                         } else {
                             $ok_btn->configure(-state => 'disabled');
                         }
                         &update_scrollable_menu($w2slice_setup_menu, $sc_fr, $sc_canv,
                                                 'scrollable', $vscroll);
                       }, $n ],
                )->g_grid(-row => 1, -column => 2, -sticky => 'ew', -padx => 2, -pady => 2);

        $f[$n]->g_grid_columnconfigure(1, -weight => 2);
    }

    if ($#wbs > 0) {
        $row++;
        ($frame2 = $fr->new_frame(
                    -borderwidth => 1,
                    -relief      => 'groove',
                ))->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew');

        $txt = "Note that this program works best when the contour output files from\n"
             . "each waterbody are assigned the same output dates and output frequencies.\n"
             . "In addition, each is required to include data for the parameter being plotted.";
        $frame2->new_label(
                -text    => $txt,
                -font    => 'default',
                -justify => 'left',
                )->g_pack(-side => 'left', -anchor => 'n', -expand => 1, -fill => 'x', -pady => 2);
    }

    $sc_canv->create_window(0, 0,
            -anchor => 'nw',
            -window => $fr,
            -tags   => 'scrollable',
            );
    &update_scrollable_menu($w2slice_setup_menu, $sc_fr, $sc_canv, 'scrollable', $vscroll);
    $sc_fr->g_grid_columnconfigure(0, -weight => 1);

    Tkx::wm_resizable($w2slice_setup_menu,0,0);
    &adjust_window_position($w2slice_setup_menu);
    $w2slice_setup_menu->g_focus;
}


sub setup_w2_slice_part3 {
    my ($canv, $id, $X, $Y) = @_;
    my (
        $bdate, $bdate_frame, $bdate_label, $bday, $bday_cb, $begin_jd,
        $bm, $bmon, $bmon_cb, $byear, $byear_cb, $byr, $byr_cb,
        $conv_add, $conv_add_entry, $conv_mult, $conv_mult_entry,
        $conv_type, $conv_type_cb, $conv_type_na_label, $cscheme,
        $cscheme_cb, $custom_frame, $data_frame, $data_range, $edate,
        $edate_frame, $edate_label, $eday, $eday_cb, $elev_base, $em,
        $emon, $emon_cb, $eyr, $eyr_cb, $f, $first_jd, $frame, $geom,
        $gtitle, $i, $jd_skip, $jd_skip_active, $jd_skip_explain, $jd1,
        $jd2, $jw, $last_jd, $limit_dates, $n, $ncolors, $ncolors_cb,
        $offset_frame, $ok_btn, $old_units, $oldparm, $oldparm_short, $parm,
        $parm_cb, $parm_chars, $parm_div, $parm_div_cb, $parm_div_label,
        $parm_frame, $parm_short, $pmax, $pmax_entry, $pmin, $pmin_entry,
        $row, $src_type, $title, $tz_offset, $tzoff_cb, $units, $units_cb,
        $units_entry, $xaxis_flip, $xaxis_frame, $xaxis_units, $yaxis_type,
        $yaxis_type_cb, $yaxis_units, $yaxis_units_label, $ymajor,
        $ymajor_entry, $ymajor_label, $ymax, $ymax_entry, $ymax_label,
        $ymin, $ymin_entry, $ymin_label, $ymin_units_label, $yr_max, $yr_min,

        @cmaps, @cplf, @jd_skip_opts, @ncpl, @nvpl, @parm_divlist, @parmlist,
        @vplf, @wbs,

        %parms,
       );

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($w2slice_setup_menu) && Tkx::winfo_exists($w2slice_setup_menu)) {
        if ($w2slice_setup_menu->g_wm_title() eq "W2 Longitudinal Slice Setup") {
            $w2slice_setup_menu->g_destroy();
            undef $w2slice_setup_menu;
        }
    }
    $w2slice_setup_menu = $main->new_toplevel();
    $w2slice_setup_menu->g_wm_transient($main);
    $w2slice_setup_menu->g_wm_title("W2 Longitudinal Slice Setup");
    $w2slice_setup_menu->configure(-cursor => $cursor_norm);
    $w2slice_setup_menu->g_wm_geometry($geom);

#   Try to keep the nascent graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

    $src_type = $props{$id}{src_type};
    %parms    = %{ $props{$id}{parms} };
    @parmlist = @{ $parms{parms}      };
    $first_jd = $parms{first_jd};
    $last_jd  = $parms{last_jd};
    undef %parms;

    $parm         = $parmlist[0];
    $parm_chars   = length($parm) +2;
    for ($i=1; $i<=$#parmlist; $i++) {
        $parm_chars = length($parmlist[$i]) +2 if (length($parmlist[$i]) +2 > $parm_chars);
    }
    $parm_div     = "None";
    @parm_divlist = ("None");
    for ($i=0; $i<=$#parmlist; $i++) {
        next if ($parmlist[$i] eq "Horizontal Velocity"
                    || $parmlist[$i] eq "Vertical Velocity"
                    || $parmlist[$i] eq "Density"
                    || $parmlist[$i] eq "Habitat");
        if ($parm ne $parmlist[$i]) {
            push (@parm_divlist, $parmlist[$i]);
        }
    }
    $yaxis_units  = "feet";
    $yaxis_type   = "Elevation";
    $xaxis_units  = "miles";
    $xaxis_flip   = 0;
    $elev_base    = -999;
    $cscheme      = "Blue to Orange";
    $ncolors      = 20;
    $byear        = $grid{$id}{byear};
    $tz_offset    = "+00:00";
    $limit_dates  = 0;

    $begin_jd = &date2jdate(sprintf("%04d%02d%02d", $byear, 1, 1));
    $jd1      = int($first_jd +0.000001) +$begin_jd -1;
    $jd2      = int($last_jd  +0.000001) +$begin_jd;
    $jd2-- if ($last_jd == int($last_jd));

    ($byr, $bm, $bday) = split(/-/, &jdate2datelabel($jd1, "YYYY-MM-DD"));
    ($eyr, $em, $eday) = split(/-/, &jdate2datelabel($jd2, "YYYY-MM-DD"));
    $bday += 0;
    $eday += 0;
    $bm--;
    $em--;
    $bmon   = $mon_names[$bm];
    $emon   = $mon_names[$em];
    $bdate  = sprintf("%s-%02d-%04d", $bmon, $bday, $byr);
    $edate  = sprintf("%s-%02d-%04d", $emon, $eday, $eyr);

    $yr_max = (localtime(time))[5] +1900;
    $yr_min = $yr_max -25;
    $yr_min = $byear -10 if ($byear <= $yr_min);
    $yr_min = $byr       if ($byr   <  $yr_min);
    $yr_max = $byear +10 if ($byear >= $yr_max);
    $yr_max = $eyr       if ($eyr   >  $yr_max);
    $ymin   = $ymax = $ymajor = "";
    $pmin   = $pmax = "";

    $parm_short = $parm;
    if ($parm eq "Temperature") {
        $title = "Temperature, in degrees Celsius";
        $units = "Celsius";
    } else {
        $units = "";
        $parm_short =~ s/\(ms-1\)//i;
        $parm_short =~ s/\(m3s-1\)//i;
        $parm_short =~ s/ [kmu]?g\/L\/day//i;
        $parm_short =~ s/ [kmu]?g\/m2\/day//i;
        $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
        $parm_short =~ s/ [kmu]?g\/L//i;
        $parm_short =~ s/ [kmu]?g\/m3//i;
        $parm_short =~ s/ [kmu]?g\/m\^3//i;
        $parm_short =~ s/, days//i;
        $parm_short =~ s/ days//i;
        $parm_short =~ s/,$//;
        if ($parm eq "Horizontal Velocity" || $parm eq "Vertical Velocity") {
            $units = "m/s";
            $title = $parm_short . ", in m/s";
        } elsif ($parm eq "Density") {
            $units = "kg/m3";
            $title = $parm_short . ", in kg/m3";
        } else {
            $title = $parm_short . ", in ";
        }
    }
    $gtitle        = "Longitudinal Slice of $parm_short";
    $oldparm       = $parm;
    $oldparm_short = $parm_short;
    $old_units     = $units;

#   Available initial colormaps
    @cmaps = ("Blue to Orange", "Blue to Red", "CoolWarm", "Turbo", "Viridis");

#   Conversion types and factors (@conv_types is global)
    $conv_type = $conv_types[0];
    $conv_mult = 1.0;
    $conv_add  = 0.0;

#   Skip some dates?
    $jd_skip_active = $jd_skip = 0;
    if ($src_type =~ /Contour/i) {
        @ncpl = @{ $grid{$id}{ncpl} };
        @cplf = @{ $grid{$id}{cplf} };
        @wbs  = split(/,/, $props{$id}{wb_list});
        foreach $jw (@wbs) {
            for ($i=1; $i<=$ncpl[$jw]; $i++) {
                next if ($cplf[$i][$jw] eq "na");
                if ($cplf[$i][$jw] < 1.0) {
                    $jd_skip_active = 1;
                    last;
                }
            }
            last if ($jd_skip_active);
        }
        undef @ncpl;
        undef @cplf;
        undef @wbs;
    } elsif ($src_type =~ /Vector/i) {
        @nvpl = @{ $grid{$id}{nvpl} };
        @vplf = @{ $grid{$id}{vplf} };
        @wbs  = split(/,/, $props{$id}{wb_list});
        foreach $jw (@wbs) {
            for ($i=1; $i<=$nvpl[$jw]; $i++) {
                next if ($vplf[$i][$jw] eq "na");
                if ($vplf[$i][$jw] < 1.0) {
                    $jd_skip_active = 1;
                    last;
                }
            }
            last if ($jd_skip_active);
        }
        undef @nvpl;
        undef @vplf;
        undef @wbs;
    }
    @jd_skip_opts = ("(keep all)", "(keep every other)", "(keep every 3rd)", "(keep every 4th)",
                     "(keep every 5th)",  "(keep every 6th)",  "(keep every 7th)",  "(keep every 8th)",
                     "(keep every 9th)",  "(keep every 10th)", "(keep every 11th)", "(keep every 12th)",
                     "(keep every 13th)", "(keep every 14th)", "(keep every 15th)", "(keep every 16th)",
                     "(keep every 17th)", "(keep every 18th)", "(keep every 19th)", "(keep every 20th)",
                     "(keep every 21st)", "(keep every 22nd)", "(keep every 23rd)", "(keep every 24th)",
                     "(keep every 25th)", "(keep every 26th)", "(keep every 27th)", "(keep every 28th)",
                     "(keep every 29th)", "(keep every 30th)", "(keep every 31st)", "(keep every 32nd)",
                     "(keep every 33rd)", "(keep every 34th)", "(keep every 35st)", "(keep every 36th)",
                     "(keep every 37th)", "(keep every 38th)", "(keep every 39th)", "(keep every 40th)",
                     "(keep every 41st)", "(keep every 42nd)", "(keep every 43rd)", "(keep every 44th)",
                     "(keep every 45th)", "(keep every 46th)", "(keep every 47th)", "(keep every 48th)",
                     "(keep every 49th)", "(keep every 50th)");
    $jd_skip_explain = $jd_skip_opts[$jd_skip];

#   Set up the menu
    $frame = $w2slice_setup_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -command => sub { my ($m, %parms);
                              if ($pmin eq "" || $pmax eq "") {
                                  return &pop_up_error($w2slice_setup_menu,
                                  "Please provide both a min and max for your parameter.");
                              }
                              if ($pmin >= $pmax) {
                                  return &pop_up_error($w2slice_setup_menu,
                                  "The minimum data value must be less than the maximum data value.");
                              }
                              if ($yaxis_type eq "Elevation") {
                                  if ($ymin eq "" || $ymax eq "") {
                                      return &pop_up_error($w2slice_setup_menu,
                                      "Please provide both a min and max elevation.");
                                  }
                                  if ($ymin >= $ymax) {
                                      return &pop_up_error($w2slice_setup_menu,
                                      "The minimum elevation must be less than the maximum elevation.");
                                  }
                              } else {
                                  if ($ymax eq "") {
                                      return &pop_up_error($w2slice_setup_menu,
                                      "Please provide a maximum depth.");
                                  }
                              }
                              if ($limit_dates) {
                                  $m   = &list_match($bmon, @mon_names);
                                  $jd1 = &date2jdate(sprintf("%04d%02d%02d", $byr, $m+1, $bday));
                                  $m   = &list_match($emon, @mon_names);
                                  $jd2 = &date2jdate(sprintf("%04d%02d%02d", $eyr, $m+1, $eday));
                                  if ($jd1 > $jd2) {
                                      return &pop_up_error($w2slice_setup_menu,
                                      "The start date is after the end date.\nPlease adjust and try again.");
                                  }
                              }
                              if ($conv_type eq "Custom") {
                                  $conv_type = sprintf("Custom,%s,%s", $conv_mult, $conv_add);
                              }
                              $gtitle =~ s/^\s+//;
                              $gtitle =~ s/\s+$//;

                              %parms             = ();
                              $parms{pmin}       = $pmin;
                              $parms{pmax}       = $pmax;
                              $parms{xunits}     = $xaxis_units;
                              $parms{xflip}      = $xaxis_flip;
                              $parms{ymin}       = $ymin;
                              $parms{ymax}       = $ymax;
                              $parms{ymajor}     = $ymajor;
                              $parms{ytype}      = $yaxis_type;
                              $parms{yunits}     = $yaxis_units;
                              $parms{cscheme}    = $cscheme;
                              $parms{ncolors}    = $ncolors;
                              $parms{gtitle}     = $gtitle;
                              $props{$id}{parms} = { %parms };

                              $props{$id}{parm}       = $parm;
                              $props{$id}{parm_div}   = $parm_div;
                              $props{$id}{parm_units} = $units;
                              $props{$id}{ctype}      = $conv_type;
                              $props{$id}{byear}      = $byear;
                              $props{$id}{tz_offset}  = $tz_offset;
                              $props{$id}{jd_skip}    = $jd_skip;
                              $props{$id}{dt_limits}  = $limit_dates;
                              if ($limit_dates) {
                                  $props{$id}{dt_begin} = sprintf("%s-%02d-%04d", $bmon, $bday, $byr);
                                  $props{$id}{dt_end}   = sprintf("%s-%02d-%04d", $emon, $eday, $eyr);
                              }

                              $w2slice_setup_menu->g_bind('<Destroy>', "");
                              $w2slice_setup_menu->g_destroy();
                              undef $w2slice_setup_menu;
                              &reset_bindings;

                              &make_w2_slice($canv, $id, 0);
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);

    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $w2slice_setup_menu->g_bind('<Destroy>', "");
                              $w2slice_setup_menu->g_destroy();
                              undef $w2slice_setup_menu;
                              $canv->delete("graph" . $id);
                              delete $props{$id};
                              delete $grid{$id};
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Delete graph if this menu is destroyed by other than the Cancel button
    $w2slice_setup_menu->g_bind('<Destroy>' => sub { undef $w2slice_setup_menu;
                                                     $canv->delete("graph" . $id);
                                                     delete $props{$id}; 
                                                     delete $grid{$id};
                                                     &reset_bindings;
                                                   });

    ($f = $w2slice_setup_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "Parameter: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($parm_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    ($parm_cb = $parm_frame->new_ttk__combobox(
            -textvariable => \$parm,
            -values       => [ @parmlist ],
            -state        => 'readonly',
            -width        => $parm_chars,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $parm_cb->g_bind("<<ComboboxSelected>>",
                         sub { my ($i);
                               return if ($parm eq $oldparm);
                               $parm_short = $parm;
                               if ($parm eq "Temperature") {
                                   $units = "Celsius" if ($units !~ /(Celsius|Fahrenheit)/);
                                   $title = "Temperature, in degrees " . $units;
                                   $units_cb->g_grid();
                                   $units_entry->g_grid_remove();
                                   $conv_type_na_label->g_grid();
                                   $custom_frame->g_grid_remove();
                                   $conv_type_cb->g_grid_remove();
                                   $conv_type = "None";
                               } else {
                                   $units = "";
                                   $parm_short =~ s/\(ms-1\)//i;
                                   $parm_short =~ s/\(m3s-1\)//i;
                                   $parm_short =~ s/ [kmu]?g\/L\/day//i;
                                   $parm_short =~ s/ [kmu]?g\/m2\/day//i;
                                   $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
                                   $parm_short =~ s/ [kmu]?g\/L//i;
                                   $parm_short =~ s/ [kmu]?g\/m3//i;
                                   $parm_short =~ s/ [kmu]?g\/m\^3//i;
                                   $parm_short =~ s/, days//i;
                                   $parm_short =~ s/ days//i;
                                   $parm_short =~ s/,$//;
                                   if ($parm eq "Horizontal Velocity" || $parm eq "Vertical Velocity") {
                                       $units = "m/s";
                                       $title = $parm_short . ", in m/s";
                                   } elsif ($parm eq "Density") {
                                       $units = "kg/m3";
                                       $title = $parm_short . ", in kg/m3";
                                   } else {
                                       $title = $parm_short . ", in ";
                                   }
                                   $units_cb->g_grid_remove();
                                   $units_entry->g_grid();
                                   $conv_type_na_label->g_grid_remove();
                                   $custom_frame->g_grid() if ($conv_type eq "Custom");
                                   $conv_type_cb->g_grid();
                               }
                               if ($gtitle eq "") {
                                   $gtitle = "Longitudinal Slice of $parm_short";
                               } else {
                                   if (index(lc($gtitle), lc($oldparm_short)) > -1) {
                                       $gtitle =~ s/$oldparm_short/$parm_short/i;
                                   }
                               }
                               $old_units     = $units;
                               $oldparm       = $parm;
                               $oldparm_short = $parm_short;
                               @parm_divlist = ("None");
                               for ($i=0; $i<=$#parmlist; $i++) {
                                   next if ($parmlist[$i] eq "Horizontal Velocity"
                                               || $parmlist[$i] eq "Vertical Velocity"
                                               || $parmlist[$i] eq "Density"
                                               || $parmlist[$i] eq "Habitat");
                                   if ($parm ne $parmlist[$i]) {
                                       push (@parm_divlist, $parmlist[$i]);
                                   }
                               }
                               $parm_div_cb->configure(-values => [ @parm_divlist ]);
                               if (&list_match($parm_div, @parm_divlist) == -1) {
                                   $parm_div = "None";
                               }
                               if ($parm eq "Temperature" || $parm eq "Horizontal Velocity"
                                     || $parm eq "Vertical Velocity" || $parm eq "Density"
                                     || $parm eq "Habitat" || $#parm_divlist == 0) {
                                   $parm_div_label->g_pack_forget();
                                   $parm_div_cb->g_pack_forget();
                                   $parm_div = "None";
                               } else {
                                   $parm_div_label->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                                   $parm_div_cb->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                               }
                             });
    ($parm_div_label = $parm_frame->new_label(
            -text => " divided by ",
            -font => 'default',
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    ($parm_div_cb = $parm_frame->new_ttk__combobox(
            -textvariable => \$parm_div,
            -values       => [ @parm_divlist ],
            -state        => 'readonly',
            -width        => $parm_chars,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Conversion: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($conv_type_na_label = $f->new_label(
            -text => "n/a",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $conv_type_na_label->g_grid_remove();
    ($conv_type_cb = $f->new_ttk__combobox(
            -textvariable => \$conv_type,
            -values       => [ @conv_types ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $conv_type_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($conv_type eq "Custom") {
                                $custom_frame->g_grid();
                            } else {
                                $custom_frame->g_grid_remove();
                            }
                          }
                      );
    $row++;
    ($custom_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $custom_frame->new_label(
            -text => "Multiply by: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_mult_entry = $custom_frame->new_entry(
            -textvariable => \$conv_mult,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_mult_entry->g_bind("<KeyRelease>",
                              sub { &numeric_entry_only($conv_mult_entry);
                                    my $chars = &max(7, length($conv_mult));
                                    $conv_mult_entry->configure(-width => $chars);
                                  });
    $custom_frame->new_label(
            -text => "  Then add: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_add_entry = $custom_frame->new_entry(
            -textvariable => \$conv_add,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_add_entry->g_bind("<KeyRelease>",
                             sub { &numeric_entry_only($conv_add_entry);
                                   my $chars = &max(7, length($conv_add));
                                   $conv_add_entry->configure(-width => $chars);
                                 });

    $row++;
    $f->new_label(
            -text => "Data Units: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($units_cb = $f->new_ttk__combobox(
            -textvariable => \$units,
            -values       => [ ("Celsius", "Fahrenheit") ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $units_cb->g_bind("<<ComboboxSelected>>",
                       sub { return if ($units eq $old_units);
                             $old_units = $units;
                             $pmin = 0 if ($pmin eq "-");
                             $pmax = 0 if ($pmax eq "-");
                             if ($units eq "Celsius") {
                                 $pmin = &floor(($pmin -32) /1.8) if ($pmin ne "");
                                 $pmax = &ceil(($pmax  -32) /1.8) if ($pmax ne "");
                             } elsif ($units eq "Fahrenheit") {
                                 $pmin = &floor($pmin *1.8 +32) if ($pmin ne "");
                                 $pmax = &ceil($pmax  *1.8 +32) if ($pmax ne "");
                             }
                             $title = "Temperature, in degrees " . $units;
                           });
    $units_cb->g_grid_remove();
    ($units_entry = $f->new_entry(
            -textvariable => \$units,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $units_entry->g_bind("<KeyRelease>",
                         sub { my $chars = &max(7, length($units));
                               $units_entry->configure(-width => $chars);
                               if ($parm eq "Temperature") {
                                   $title = "Temperature, in degrees " . $units;
                               } else {
                                   $title = $parm_short . ", in " . $units;
                               }
                             });

    $row++;
    $f->new_label(
            -text => "Data Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$title,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Data Min: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmin_entry = $f->new_entry(
            -textvariable => \$pmin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $pmin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmin_entry ]);

    $row++;
    $f->new_label(
            -text => "Data Max: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmax_entry = $f->new_entry(
            -textvariable => \$pmax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $pmax_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmax_entry ]);

    $row++;
    $f->new_label(
            -text => "Y Axis Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($yaxis_type_cb = $f->new_ttk__combobox(
            -textvariable => \$yaxis_type,
            -values       => [ ("Elevation", "Depth") ],
            -state        => 'readonly',
            -width        => 10,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $yaxis_type_cb->g_bind("<<ComboboxSelected>>",
                           sub { if ($yaxis_type eq "Elevation") {
                                     $ymin_label->g_grid();
                                     $ymin_entry->g_grid();
                                     $ymin_units_label->g_grid();
                                     $ymax_label->configure(-text => "Elevation Max: ");
                                     $ymajor_label->configure(-text => "Elevation Major: ");
                                     $yaxis_units_label->configure(-text => "Elevation Units: ");
                                     if ($elev_base != -999 && $ymax ne "") {
                                         $ymin  = $elev_base;
                                         $ymax += $elev_base;
                                     } else {
                                         $ymin = "";
                                     }
                                 } else {
                                     $ymin_label->g_grid_remove();
                                     $ymin_entry->g_grid_remove();
                                     $ymin_units_label->g_grid_remove();
                                     $ymax_label->configure(-text => "Depth Max: ");
                                     $ymajor_label->configure(-text => "Depth Major: ");
                                     $yaxis_units_label->configure(-text => "Depth Units: ");
                                     if ($ymax ne "" && $ymin ne "" && $ymax -$ymin != 0) {
                                         $elev_base = &min($ymin, $ymax);
                                         $ymax      = abs($ymax -$ymin);
                                     } else {
                                         $ymax = "";
                                     }
                                     $ymin = 0;
                                 }
                               }
                          );

    $row++;
    ($ymin_label = $f->new_label(
            -text => "Elevation Min: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ymin_entry = $f->new_entry(
            -textvariable => \$ymin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $ymin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $ymin_entry ]);
    ($ymin_units_label = $f->new_label(
            -textvariable => \$yaxis_units,
            -font         => 'default',
            -anchor       => 'w',
            ))->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

    $row++;
    ($ymax_label = $f->new_label(
            -text => "Elevation Max: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ymax_entry = $f->new_entry(
            -textvariable => \$ymax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $ymax_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($ymax_entry);
                                              $ymax =~ s/^-// if ($yaxis_type eq "Depth");
                                            });
    $f->new_label(
            -textvariable => \$yaxis_units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

    $row++;
    ($ymajor_label = $f->new_label(
            -text => "Elevation Major: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ymajor_entry = $f->new_entry(
            -textvariable => \$ymajor,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $ymajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($ymajor_entry, 1);
                                                $ymajor =~ s/^-//;
                                              });
    $f->new_label(
            -textvariable => \$yaxis_units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

    $row++;
    ($yaxis_units_label = $f->new_label(
            -text => "Elevation Units: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_ttk__combobox(
            -textvariable => \$yaxis_units,
            -values       => [ ("feet", "meters") ],
            -state        => 'readonly',
            -width        => 7,
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "X Axis Units: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($xaxis_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $xaxis_frame->new_ttk__combobox(
            -textvariable => \$xaxis_units,
            -values       => [ ("miles", "kilometers") ],
            -state        => 'readonly',
            -width        => 10,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $xaxis_frame->new_checkbutton(
            -onvalue  => 1,
            -offvalue => 0,
            -text     => "Flip Axis",
            -font     => 'default',
            -variable => \$xaxis_flip,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Color Scheme: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($cscheme_cb = $f->new_ttk__combobox(
            -textvariable => \$cscheme,
            -values       => [ @cmaps ],
            -state        => 'readonly',
            -width        => 15,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $cscheme_cb->g_bind("<<ComboboxSelected>>",
                           sub { my ($n);
                                 if ($cscheme =~ /CoolWarm|Turbo|Viridis/) {
                                     $ncolors_cb->configure(-values => [ (8 .. 100) ]);
                                 } else {
                                     $ncolors_cb->configure(-values =>
                                         [ (16, 18, 20, 22, 24, 30, 34, 38, 42, 46) ]);
                                     if ($ncolors < 16) {
                                         $ncolors = 16;
                                     } elsif ($ncolors > 46) {
                                         $ncolors = 46;
                                     } else {
                                         foreach $n (reverse @valid_nc) {
                                             if ($ncolors >= 2 *$n) {
                                                 $ncolors = 2 *$n;
                                                 last;
                                             }
                                         }
                                     }
                                 }
                               });

    $row++;
    $f->new_label(
            -text => "Number of Colors: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ncolors_cb = $f->new_ttk__combobox(
            -textvariable => \$ncolors,
            -values       => [ (16, 18, 20, 22, 24, 30, 34, 38, 42, 46) ],
            -state        => 'readonly',
            -width        => 4,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Base Year: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($byear_cb = $f->new_ttk__combobox(
            -textvariable => \$byear,
            -values       => [ reverse($yr_min .. $yr_max) ],
            -state        => 'readonly',
            -width        => 5,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $byear_cb->g_bind("<<ComboboxSelected>>",
                      sub { my ($hr, $jd_offset, $m, $mi);
                            ($hr, $mi) = split(/:/, $tz_offset);
                            $hr += 0;
                            $mi += 0;
                            $mi *= -1 if ($hr < 0);
                            $jd_offset = $hr/24. +$mi/1440.;
                            $begin_jd  = &date2jdate(sprintf("%04d%02d%02d", $byear, 1, 1));
                            $jd1       = int($first_jd +$jd_offset +0.000001) +$begin_jd -1;
                            $jd2       = int($last_jd  +$jd_offset +0.000001) +$begin_jd;
                            $jd2-- if ($last_jd +$jd_offset == int($last_jd +$jd_offset));

                            ($byr, $m, $bday) = split(/-/, &jdate2datelabel($jd1, "YYYY-MM-DD"));
                            $bday += 0;
                            $bmon  = $mon_names[$m-1];
                            $bdate = sprintf("%s-%02d-%04d", $bmon, $bday, $byr);
                            &set_leap_year($byr);
                            $bday_cb->configure(-values => [ 1 .. $days_in_month[$m-1] ]);

                            ($eyr, $m, $eday) = split(/-/, &jdate2datelabel($jd2, "YYYY-MM-DD"));
                            $eday += 0;
                            $emon  = $mon_names[$m-1];
                            $edate = sprintf("%s-%02d-%04d", $emon, $eday, $eyr);
                            &set_leap_year($eyr);
                            $eday_cb->configure(-values => [ 1 .. $days_in_month[$m-1] ]);
                            $data_range->configure(-text => $bdate . " to " . $edate);

                            if ($byear == $yr_min || $byear == $yr_max || $byr < $yr_min || $eyr > $yr_max) {
                                $yr_min -= 10   if ($byear == $yr_min);
                                $yr_max += 10   if ($byear == $yr_max);
                                $yr_min  = $byr if ($byr < $yr_min);
                                $yr_max  = $eyr if ($eyr > $yr_max);
                                $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                $byr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                $eyr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                            }
                          }
                     );
    $f->new_label(
            -text   => " for JDAY = 1.0",
            -anchor => 'w',
            -font   => 'default',
            )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Time Offset: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($offset_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    ($tzoff_cb = $offset_frame->new_ttk__combobox(
            -textvariable => \$tz_offset,
            -values       => [ @tz_offsets ],
            -justify      => 'right',
            -state        => 'readonly',
            -width        => 6,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $tzoff_cb->g_bind("<<ComboboxSelected>>",
                      sub { my ($hr, $jd_offset, $m, $mi);
                            ($hr, $mi) = split(/:/, $tz_offset);
                            $hr += 0;
                            $mi += 0;
                            $mi *= -1 if ($hr < 0);
                            $jd_offset = $hr/24. +$mi/1440.;
                            $begin_jd  = &date2jdate(sprintf("%04d%02d%02d", $byear, 1, 1));
                            $jd1       = int($first_jd +$jd_offset +0.000001) +$begin_jd -1;
                            $jd2       = int($last_jd  +$jd_offset +0.000001) +$begin_jd;
                            $jd2-- if ($last_jd +$jd_offset == int($last_jd +$jd_offset));

                            ($byr, $m, $bday) = split(/-/, &jdate2datelabel($jd1, "YYYY-MM-DD"));
                            $bday += 0;
                            $bmon  = $mon_names[$m-1];
                            $bdate = sprintf("%s-%02d-%04d", $bmon, $bday, $byr);
                            &set_leap_year($byr);
                            $bday_cb->configure(-values => [ 1 .. $days_in_month[$m-1] ]);

                            ($eyr, $m, $eday) = split(/-/, &jdate2datelabel($jd2, "YYYY-MM-DD"));
                            $eday += 0;
                            $emon  = $mon_names[$m-1];
                            $edate = sprintf("%s-%02d-%04d", $emon, $eday, $eyr);
                            &set_leap_year($eyr);
                            $eday_cb->configure(-values => [ 1 .. $days_in_month[$m-1] ]);
                            $data_range->configure(-text => $bdate . " to " . $edate);

                            if ($byr < $yr_min || $eyr > $yr_max) {
                                $yr_min = $byr if ($byr < $yr_min);
                                $yr_max = $eyr if ($eyr > $yr_max);
                                $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                $byr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                $eyr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                            }
                          }
                     );
    $offset_frame->new_label(
            -text   => " time zone adjustment ",
            -anchor => 'w',
            -font   => 'default',
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $offset_frame->new_button(
            -text    => "Help",
            -command => sub { &pop_up_info($w2slice_setup_menu,
                                    "The time offset allows the user to add or subtract a time\n"
                                  . "offset if the W2 model was run with a non-local time zone.\n\n"
                                  . "For example, if W2 was run in UTC but the local time zone\n"
                                  . "is PST, an offset of -08:00 would convert the model date/time\n"
                                  . "to a local standard time of PST. This offset does not make\n"
                                  . "any adjustments related to daylight saving time. In general,\n"
                                  . "W2 is best run in the local standard time.\n\n"
                                  . "Leave the time offset at +00:00 for no adjustment.",
                                    "Time Offset Notice");
                            },
            )->g_pack(-side => 'left', -anchor => 'w', -padx => 2);

    if ($jd_skip_active) {
        $row++;
        $f->new_label(
                -text => "Skip Dates: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $f->new_spinbox(
                -textvariable => \$jd_skip,
                -state        => 'readonly',
                -font         => 'default',
                -from         => 0,
                -to           => 49,
                -increment    => 1,
                -width        => 4,
                -command      => sub { $jd_skip_explain = $jd_skip_opts[$jd_skip]; },
                )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $f->new_label(
                -textvariable => \$jd_skip_explain,
                -font         => 'default',
                )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);
    }

    $row++;
    $f->new_label(
            -text => "Graph Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gtitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Available Data: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($data_range = $f->new_label(
            -text => $bdate . " to " . $edate,
            -font => 'default',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Date Limits: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($data_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $data_frame->new_checkbutton(
            -onvalue  => 1,
            -offvalue => 0,
            -text     => "Restrict date range ",
            -font     => 'default',
            -variable => \$limit_dates,
            -command  => sub { if ($limit_dates) {
                                   $bdate_label->g_grid();
                                   $bdate_frame->g_grid();
                                   $edate_label->g_grid();
                                   $edate_frame->g_grid();
                               } else {
                                   $bdate_label->g_grid_remove();
                                   $bdate_frame->g_grid_remove();
                                   $edate_label->g_grid_remove();
                                   $edate_frame->g_grid_remove();
                               }
                             },
            )->g_pack(-side => 'left', -anchor => 'w');
    $data_frame->new_button(
            -text    => "Help",
            -command => sub { &pop_up_info($w2slice_setup_menu,
                                    "W2Anim may run out of memory if too many large slice images\n"
                                  . "have to be generated to produce an animation. The user can\n"
                                  . "limit the date range of a W2 longitudinal slice animation by\n"
                                  . "choosing a shorter range of dates from the W2 output. The\n"
                                  . "start and end dates are for midnight at the start of those days.\n\n"
                                  . "In most instances, such a restriction is unnecessary.",
                                    "Date Range Restriction Notice");
                            },
            )->g_pack(-side => 'left', -anchor => 'w', -padx => 2);

    $row++;
    ($bdate_label = $f->new_label(
            -text => "Start Date: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($bdate_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    ($bmon_cb = $bdate_frame->new_ttk__combobox(
            -textvariable => \$bmon,
            -values       => [ @mon_names ],
            -state        => 'readonly',
            -width        => 4,
            ))->g_pack(-side => 'left');
    $bmon_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($byr);
                          $bm = &list_match($bmon, @mon_names);
                          $bday_cb->configure(-values => [ 1 .. $days_in_month[$bm] ]);
                          $bday = $days_in_month[$bm] if ($bday > $days_in_month[$bm]);
                        }
                    );
    $bdate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($bday_cb = $bdate_frame->new_ttk__combobox(
            -textvariable => \$bday,
            -values       => [ 1 .. $days_in_month[$bm] ],
            -state        => 'readonly',
            -width        => 3,
            ))->g_pack(-side => 'left');
    $bdate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($byr_cb = $bdate_frame->new_ttk__combobox(
            -textvariable => \$byr,
            -values       => [ reverse($yr_min .. $yr_max) ],
            -state        => 'readonly',
            -width        => 5,
            ))->g_pack(-side => 'left');
    $byr_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($byr);
                          $bm = &list_match($bmon, @mon_names);
                          if ($bm == 1) {
                              $bday_cb->configure(-values => [ 1 .. $days_in_month[$bm] ]);
                              $bday = $days_in_month[$bm] if ($bday > $days_in_month[$bm]);
                          }
                          if ($byr == $yr_min || $byr == $yr_max) {
                              $yr_min -= 10 if ($byr == $yr_min);
                              $yr_max += 10 if ($byr == $yr_max);
                              $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                              $byr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                              $eyr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                          }
                        }
                    );

    $row++;
    ($edate_label = $f->new_label(
            -text => "End Date: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($edate_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    ($emon_cb = $edate_frame->new_ttk__combobox(
            -textvariable => \$emon,
            -values       => [ @mon_names ],
            -state        => 'readonly',
            -width        => 4,
            ))->g_pack(-side => 'left');
    $emon_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($eyr);
                          $em = &list_match($emon, @mon_names);
                          $eday_cb->configure(-values => [ 1 .. $days_in_month[$em] ]);
                          $eday = $days_in_month[$em] if ($eday > $days_in_month[$em]);
                        }
                    );
    $edate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($eday_cb = $edate_frame->new_ttk__combobox(
            -textvariable => \$eday,
            -values       => [ 1 .. $days_in_month[$em] ],
            -state        => 'readonly',
            -width        => 3,
            ))->g_pack(-side => 'left');
    $edate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($eyr_cb = $edate_frame->new_ttk__combobox(
            -textvariable => \$eyr,
            -values       => [ reverse($yr_min .. $yr_max) ],
            -state        => 'readonly',
            -width        => 5,
            ))->g_pack(-side => 'left');
    $eyr_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($eyr);
                          $em = &list_match($emon, @mon_names);
                          if ($em == 1) {
                              $eday_cb->configure(-values => [ 1 .. $days_in_month[$em] ]);
                              $eday = $days_in_month[$em] if ($eday > $days_in_month[$em]);
                          }
                          if ($eyr == $yr_min || $eyr == $yr_max) {
                              $yr_min -= 10 if ($eyr == $yr_min);
                              $yr_max += 10 if ($eyr == $yr_max);
                              $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                              $byr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                              $eyr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                          }
                        }
                    );

    if ($parm eq "Temperature" || $parm eq "Horizontal Velocity" || $parm eq "Density" || $parm eq "Habitat"
                               || $parm eq "Vertical Velocity" || $#parm_divlist == 0) {
        $parm_div_label->g_pack_forget();
        $parm_div_cb->g_pack_forget();
    } else {
        $parm_div_label->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        $parm_div_cb->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    }
    if ($conv_type ne "Custom") {
        $custom_frame->g_grid_remove();
    }
    if ($parm eq "Temperature") {
        $units_cb->g_grid();
        $units_entry->g_grid_remove();
        $conv_type_na_label->g_grid();
        $custom_frame->g_grid_remove();
        $conv_type_cb->g_grid_remove();
        $conv_type = "None";
        $parm_div  = "None";
    } else {
        $units_cb->g_grid_remove();
        $units_entry->g_grid();
        $conv_type_na_label->g_grid_remove();
        $custom_frame->g_grid() if ($conv_type eq "Custom");
        $conv_type_cb->g_grid();
    }
    if ($cscheme =~ /CoolWarm|Turbo|Viridis/) {
        $ncolors_cb->configure(-values => [ (8 .. 100) ]);
    } else {
        $ncolors_cb->configure(-values => [ (16, 18, 20, 22, 24, 30, 34, 38, 42, 46) ]);
        if ($ncolors < 16) {
            $ncolors = 16;
        } elsif ($ncolors > 46) {
            $ncolors = 46;
        } else {
            foreach $n (reverse @valid_nc) {
                if ($ncolors >= 2 *$n) {
                    $ncolors = 2 *$n;
                    last;
                }
            }
        }
    }
    $bdate_label->g_grid_remove();
    $bdate_frame->g_grid_remove();
    $edate_label->g_grid_remove();
    $edate_frame->g_grid_remove();
    $f->g_grid_columnconfigure(2, -weight => 2);

    Tkx::wm_resizable($w2slice_setup_menu,0,0);
    &adjust_window_position($w2slice_setup_menu);
    $w2slice_setup_menu->g_focus;
}


sub change_w2_slice {
    my ($canv, $id, $X, $Y, $change) = @_;
    my (
        $bdate, $bdate_frame, $bdate_label, $bday, $bday_cb, $begin_jd,
        $bm, $bmon, $bmon_cb, $byear, $byear_cb, $byr, $byr_cb, $conv_add,
        $conv_add_entry, $conv_mult, $conv_mult_entry, $conv_type,
        $conv_type_cb, $conv_type_na_label, $custom_frame, $data_frame,
        $data_range, $dt_limits, $edate, $edate_frame, $edate_label, $eday,
        $eday_cb, $em, $emon, $emon_cb, $eyr, $eyr_cb, $f, $first_jd,
        $frame, $get_dates, $geom, $gtitle, $hr, $i, $jd_offset, $jd_skip,
        $jd_skip_active, $jd_skip_explain, $jd_skip_frame, $jd1, $jd2,
        $jw, $last_jd, $mi, $n, $offset_frame, $ok, $ok_btn, $old_units,
        $oldparm, $oldparm_short, $p, $parm, $parm_cb, $parm_chars,
        $parm_div, $parm_div_cb, $parm_div_label, $parm_frame, $parm_short,
        $parms_ref, $pbar, $pbar_img, $pbar_win, $pmajor, $pmajor_entry,
        $pmax, $pmax_entry, $pmin, $pmin_entry, $row, $src_type, $tecplot,
        $title, $tz_offset, $tzoff_cb, $units, $units_cb, $units_entry,
        $yr_max, $yr_min,

        @cpl_files, @cplf, @jd_skip_opts, @ncpl, @nvpl, @parm_divlist,
        @parm_tmp, @parmlist, @parms, @vplf, @wbs,
       );

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($w2slice_mod_menu) && Tkx::winfo_exists($w2slice_mod_menu)) {
        if ($w2slice_mod_menu->g_wm_title() eq "Modify W2 Longitudinal Slice") {
            $w2slice_mod_menu->g_destroy();
            undef $w2slice_mod_menu;
        }
    }
    if (defined($scale_output_menu) && Tkx::winfo_exists($scale_output_menu)) {
        if ($scale_output_menu->g_wm_title() eq "Select and Scale Output") {
            $scale_output_menu->g_destroy();
            undef $scale_output_menu;
        }
    }

#   Try to keep the graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

#   De-select graph if it already exists
    if (defined($props{$id}{oldcoords})) {
        &end_select($canv, $id, 1);
    }

#   Initialize some variables.
    @ncpl      = @{ $grid{$id}{ncpl} };
    @cplf      = @{ $grid{$id}{cplf} };
    @nvpl      = @{ $grid{$id}{nvpl} };
    @vplf      = @{ $grid{$id}{vplf} };

    $src_type  = $props{$id}{src_type};
    $parm      = $props{$id}{parm};
    $parm_div  = $props{$id}{parm_div};
    $units     = $props{$id}{parm_units};
    $conv_type = $props{$id}{ctype};
    $byear     = $props{$id}{byear};
    $tz_offset = $props{$id}{tz_offset};
    $jd_skip   = $props{$id}{jd_skip};
    $dt_limits = $props{$id}{dt_limits};
    $get_dates = (defined($props{$id}{start_dt})) ? 0 : 1;
    @wbs       = split(/,/, $props{$id}{wb_list});

    $pmin      = $gr_props{$id}{cs_min};
    $pmax      = $gr_props{$id}{cs_max};
    $pmajor    = $gr_props{$id}{cs_major};
    $title     = $gr_props{$id}{keytitle};
    $gtitle    = $gr_props{$id}{gtitle};

    if ($conv_type =~ /Custom/) {
        ($conv_type, $conv_mult, $conv_add) = split(/,/, $conv_type);
    } else {
        $conv_mult = 1.0;
        $conv_add  = 0.0;
    }

    if ($src_type =~ /Contour/i) {
        @cpl_files = @{ $props{$id}{cpl_files} };
        if ($get_dates) {
            ($pbar_win, $pbar, $pbar_img)
                = &create_alt_progress_bar($main, $id, "Scanning W2 contour files...");
        }
        for ($n=0; $n<=$#wbs; $n++) {
            ($tecplot, undef, $jw, $parms_ref, $jd1, $jd2)
                  = &scan_w2_cpl_file($main, $cpl_files[$n], $id, $get_dates, $pbar_img);
            if ($tecplot == -1) {
                &destroy_progress_bar($main, $pbar_win) if ($get_dates);
                return &pop_up_error($main, "The source file is not a W2 Contour file:\n$cpl_files[$n]");
            }
            @parms = @{ $parms_ref };
            if ($n == 0) {
                @parmlist = @parms;
                $first_jd = $jd1;
                $last_jd  = $jd2;
            } else {                # only keep parameters common to all cpl files
                @parm_tmp = ();
                foreach $p ( @parms ) {
                    if (&list_match($p, @parmlist) >= 0) {
                        push (@parm_tmp, $p);
                    }
                }
                @parmlist = @parm_tmp;
                $first_jd = $jd1 if ($jd1 < $first_jd);
                $last_jd  = $jd2 if ($jd2 > $last_jd);
            }
        }
        &destroy_progress_bar($main, $pbar_win) if ($get_dates);

    } elsif ($src_type =~ /Vector/i) {
        $status_line = "Scanning W2 vector file...";
        Tkx::update_idletasks();
        ($ok, $parms_ref, undef, $first_jd, $last_jd)
                  = &scan_w2_vector_file($main, $props{$id}{w2l_file}, $id, $get_dates);
        if ($ok ne "okay") {
            return &pop_up_error($main, "The source file is not a W2 Vector (w2l) file:\n"
                                      . $props{$id}{w2l_file});
        }
        @parmlist = @{ $parms_ref };
        $status_line = "";
        Tkx::update_idletasks();
    }

#   Begin to build the menu
    $w2slice_mod_menu = $main->new_toplevel();
    $w2slice_mod_menu->g_wm_transient($main);
    $w2slice_mod_menu->g_wm_title("Modify W2 Longitudinal Slice");
    $w2slice_mod_menu->configure(-cursor => $cursor_norm);
    $w2slice_mod_menu->g_wm_geometry($geom);

    ($hr, $mi) = split(/:/, $tz_offset);
    $hr += 0;
    $mi += 0;
    $mi *= -1 if ($hr < 0);
    $jd_offset = $hr/24. +$mi/1440.;
    $begin_jd  = &date2jdate(sprintf("%04d%02d%02d", $byear, 1, 1));

    if (! $get_dates) {
        $first_jd = &date2jdate($props{$id}{start_dt}) -$jd_offset -$begin_jd +1;
        $last_jd  = &date2jdate($props{$id}{end_dt})   -$jd_offset -$begin_jd +1;
    } else {
        $props{$id}{start_dt} = &jdate2date($first_jd +$jd_offset +$begin_jd -1);
        $props{$id}{end_dt}   = &jdate2date($last_jd  +$jd_offset +$begin_jd -1);
    }
    $jd1 = int($first_jd +$jd_offset +0.000001) +$begin_jd -1;
    $jd2 = int($last_jd  +$jd_offset +0.000001) +$begin_jd;
    $jd2-- if ($last_jd +$jd_offset == int($last_jd +$jd_offset));
    ($byr, $bm, $bday) = split(/-/, &jdate2datelabel($jd1, "YYYY-MM-DD"));
    ($eyr, $em, $eday) = split(/-/, &jdate2datelabel($jd2, "YYYY-MM-DD"));
    $bdate = sprintf("%s-%02d-%04d", $mon_names[$bm-1], $bday, $byr);
    $edate = sprintf("%s-%02d-%04d", $mon_names[$em-1], $eday, $eyr);

    $yr_max = (localtime(time))[5] +1900;
    $yr_min = ($byear > $yr_max -25) ? $yr_max -25 : $byear -10;
    $yr_min = $byr       if ($byr   <  $yr_min);
    $yr_max = $byear +10 if ($byear >= $yr_max);
    $yr_max = $eyr       if ($eyr   >  $yr_max);

    if ($dt_limits) {
        ($bm, $bday, $byr) = &parse_date($props{$id}{dt_begin}, 1);
        ($em, $eday, $eyr) = &parse_date($props{$id}{dt_end},   1);
    }
    $bday += 0;
    $eday += 0;
    $bm--;
    $em--;
    $bmon   = $mon_names[$bm];
    $emon   = $mon_names[$em];
    $yr_min = $byr if ($byr < $yr_min);
    $yr_max = $eyr if ($eyr > $yr_max);

    $jd_skip_active = 0;
    @jd_skip_opts = ("(keep all)", "(keep every other)", "(keep every 3rd)", "(keep every 4th)",
                     "(keep every 5th)",  "(keep every 6th)",  "(keep every 7th)",  "(keep every 8th)",
                     "(keep every 9th)",  "(keep every 10th)", "(keep every 11th)", "(keep every 12th)",
                     "(keep every 13th)", "(keep every 14th)", "(keep every 15th)", "(keep every 16th)",
                     "(keep every 17th)", "(keep every 18th)", "(keep every 19th)", "(keep every 20th)",
                     "(keep every 21st)", "(keep every 22nd)", "(keep every 23rd)", "(keep every 24th)",
                     "(keep every 25th)", "(keep every 26th)", "(keep every 27th)", "(keep every 28th)",
                     "(keep every 29th)", "(keep every 30th)", "(keep every 31st)", "(keep every 32nd)",
                     "(keep every 33rd)", "(keep every 34th)", "(keep every 35st)", "(keep every 36th)",
                     "(keep every 37th)", "(keep every 38th)", "(keep every 39th)", "(keep every 40th)",
                     "(keep every 41st)", "(keep every 42nd)", "(keep every 43rd)", "(keep every 44th)",
                     "(keep every 45th)", "(keep every 46th)", "(keep every 47th)", "(keep every 48th)",
                     "(keep every 49th)", "(keep every 50th)");
    for ($n=0; $n<=$#wbs; $n++) {
        $jw = $wbs[$n];
        if ($src_type =~ /Contour/i) {
            for ($i=1; $i<=$ncpl[$jw]; $i++) {
                next if ($cplf[$i][$jw] eq "na");
                if ($cplf[$i][$jw] < 1.0) {
                    $jd_skip_active = 1;
                    last;
                }
            }
        } elsif ($src_type =~ /Vector/i) {
            for ($i=1; $i<=$nvpl[$jw]; $i++) {
                next if ($vplf[$i][$jw] eq "na");
                if ($vplf[$i][$jw] < 1.0) {
                    $jd_skip_active = 1;
                    last;
                }
            }
        }
    }
    $jd_skip = 0 if ($jd_skip < 0 || $jd_skip > 49);
    $jd_skip_explain = $jd_skip_opts[$jd_skip];

    $parm_chars = length($parmlist[0]);
    for ($i=1; $i<=$#parmlist; $i++) {
        $parm_chars = &max($parm_chars, length($parmlist[$i]));
    }
    $parm_chars += 2;
    $parm_short = $parm;
    if ($parm ne "Temperature") {
        $parm_short =~ s/\(ms-1\)//i;
        $parm_short =~ s/\(m3s-1\)//i;
        $parm_short =~ s/ [kmu]?g\/L\/day//i;
        $parm_short =~ s/ [kmu]?g\/m2\/day//i;
        $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
        $parm_short =~ s/ [kmu]?g\/L//i;
        $parm_short =~ s/ [kmu]?g\/m3//i;
        $parm_short =~ s/ [kmu]?g\/m\^3//i;
        $parm_short =~ s/, days//i;
        $parm_short =~ s/ days//i;
        $parm_short =~ s/,$//;
    }
    $old_units     = $units;
    $oldparm       = $parm;
    $oldparm_short = $parm_short;
    @parm_divlist  = ("None");
    for ($i=0; $i<=$#parmlist; $i++) {
        next if ($parmlist[$i] eq "Horizontal Velocity"
                  || $parmlist[$i] eq "Vertical Velocity"
                  || $parmlist[$i] eq "Density"
                  || $parmlist[$i] eq "Habitat");
        if ($parm ne $parmlist[$i]) {
            push (@parm_divlist, $parmlist[$i]);
        }
    }
    $parm_div = "None" if (&list_match($parm_div, @parm_divlist) == -1);

#   Build the menu.
    $frame = $w2slice_mod_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -command => sub { my ($dt_begin, $dt_end, $m, $modified, $result, %parms);
                              $modified = 0;
                              %parms = ();
                              if ($change eq "misc") {
                                  $dt_begin = sprintf("%s-%02d-%04d", $bmon, $bday, $byr);
                                  $dt_end   = sprintf("%s-%02d-%04d", $emon, $eday, $eyr);
                                  $modified = 1 if ($byear     != $props{$id}{byear}     ||
                                                    $tz_offset ne $props{$id}{tz_offset} ||
                                                    $dt_limits != $props{$id}{dt_limits} ||
                                                    $jd_skip   != $props{$id}{jd_skip}   ||
                                                    ($dt_limits &&
                                                     ($dt_begin ne $props{$id}{dt_begin} ||
                                                      $dt_end   ne $props{$id}{dt_end})));
                                  if ($dt_limits) {
                                      $m = &list_match($bmon, @mon_names);
                                      $jd1 = &date2jdate(sprintf("%04d%02d%02d", $byr, $m+1, $bday));
                                      $m = &list_match($emon, @mon_names);
                                      $jd2 = &date2jdate(sprintf("%04d%02d%02d", $eyr, $m+1, $eday));
                                      if ($jd1 > $jd2) {
                                          return &pop_up_error($w2slice_mod_menu,
                                                  "The start date is after the end date.\n"
                                                . "Please adjust and try again.");
                                      }
                                  }
                              }
                              if ($change =~ /parm|misc/) {
                                  if ($pmin eq "" || $pmax eq "") {
                                      return &pop_up_error($w2slice_mod_menu,
                                      "Please provide both a min and max for your parameter.");
                                  }
                                  if ($pmajor eq "") {
                                      return &pop_up_error($w2slice_mod_menu,
                                      "Please provide a major increment for your parameter.");
                                  }
                                  if ($pmin >= $pmax) {
                                      return &pop_up_error($w2slice_mod_menu,
                                      "The minimum data value must be less than the maximum data value.");
                                  }
                                  if ($conv_type eq "Custom") {
                                      $conv_type = sprintf("Custom,%s,%s", $conv_mult, $conv_add);
                                  }
                                  $gtitle =~ s/^\s+//;
                                  $gtitle =~ s/\s+$//;
                                  if ($parm ne $props{$id}{parm} || $parm_div ne $props{$id}{parm_div}
                                       || ($parm ne "Temperature" && $units ne $props{$id}{parm_units})
                                       || $conv_type ne $props{$id}{ctype}) {
                                      $modified = 1;
                                  }
                                  if (! $modified && $parm eq "Temperature"
                                                  && $parm eq $props{$id}{parm}
                                                  && $units ne $props{$id}{parm_units}) {
                                      return &pop_up_error($w2slice_mod_menu,
                                                           "To modify just the temperature units,\n"
                                                         . "use the Graph Properties menu.");
                                  }
                                  if (! $modified && ($pmin != $gr_props{$id}{cs_min} ||
                                                      $pmax != $gr_props{$id}{cs_max})) {
                                      return &pop_up_error($w2slice_mod_menu,
                                                           "To modify just the parameter limits,\n"
                                                         . "use the Graph Properties menu.");
                                  }
                                  if (! $modified && $pmajor != $gr_props{$id}{cs_major}) {
                                      return &pop_up_error($w2slice_mod_menu,
                                                           "To modify just the parameter increment,\n"
                                                         . "use the Graph Properties menu.");
                                  }
                                  if (! $modified && $gtitle ne $gr_props{$id}{gtitle}) {
                                      return &pop_up_error($w2slice_mod_menu,
                                                           "To modify just the graph title,\n"
                                                         . "use the Graph Properties menu.");
                                  }
                              }
                              if (! $modified) {
                                  $result = &pop_up_question($w2slice_mod_menu,
                                                         "No changes were made. Try again?");
                                  return if (lc($result) eq "yes");
                                  $w2slice_mod_menu->g_bind('<Destroy>', "");
                                  $w2slice_mod_menu->g_destroy();
                                  undef $w2slice_mod_menu;
                                  &reset_bindings;
                                  return;
                              }

#                             Rebuild the dates array if different jd_skip, byear, tz_offset, or dt_limit
                              $parms{rebuild}    = ($byear     != $props{$id}{byear}     ||
                                                    $tz_offset ne $props{$id}{tz_offset} ||
                                                    $dt_limits != $props{$id}{dt_limits} ||
                                                    $jd_skip   != $props{$id}{jd_skip}   ||
                                                    ($dt_limits && $change eq "misc" &&
                                                     ($dt_begin ne $props{$id}{dt_begin} ||
                                                      $dt_end   ne $props{$id}{dt_end}))) ? 1 : 0;
                              $parms{pmin}       = $pmin;
                              $parms{pmax}       = $pmax;
                              $parms{pmajor}     = $pmajor;
                              $parms{gtitle}     = $gtitle;
                              $parms{change}     = $change;
                              $props{$id}{parms} = { %parms };

                              $props{$id}{data}       = 0;
                              $props{$id}{parm}       = $parm;
                              $props{$id}{parm_div}   = $parm_div;
                              $props{$id}{parm_units} = $units;
                              $props{$id}{ctype}      = $conv_type;
                              $props{$id}{byear}      = $byear;
                              $props{$id}{tz_offset}  = $tz_offset;
                              $props{$id}{jd_skip}    = $jd_skip;
                              $props{$id}{dt_limits}  = $dt_limits;
                              if ($dt_limits) {
                                  $props{$id}{dt_begin} = $dt_begin;
                                  $props{$id}{dt_end}   = $dt_end;
                              }

                              $w2slice_mod_menu->g_bind('<Destroy>', "");
                              $w2slice_mod_menu->g_destroy();
                              undef $w2slice_mod_menu;
                              &reset_bindings;
                              &make_w2_slice($canv, $id, 0);
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $w2slice_mod_menu->g_bind('<Destroy>', "");
                              $w2slice_mod_menu->g_destroy();
                              undef $w2slice_mod_menu;
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Do not delete graph if this menu is destroyed by other than the Cancel button
    $w2slice_mod_menu->g_bind('<Destroy>' => sub { undef $w2slice_mod_menu;
                                                   &reset_bindings;
                                                 });

    $f = $w2slice_mod_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "Parameter: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($parm_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    ($parm_cb = $parm_frame->new_ttk__combobox(
            -textvariable => \$parm,
            -values       => [ @parmlist ],
            -state        => 'readonly',
            -width        => $parm_chars,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $parm_cb->g_bind("<<ComboboxSelected>>",
                         sub { my ($i);
                               return if ($parm eq $oldparm);
                               $parm_short = $parm;
                               if ($parm eq "Temperature") {
                                   $units = "Celsius" if ($units !~ /(Celsius|Fahrenheit)/);
                                   $title = "Temperature, in degrees " . $units;
                                   $units_cb->g_grid();
                                   $units_entry->g_grid_remove();
                                   $conv_type_na_label->g_grid();
                                   $custom_frame->g_grid_remove();
                                   $conv_type_cb->g_grid_remove();
                                   $conv_type = "None";
                               } else {
                                   $units = "";
                                   $parm_short =~ s/\(ms-1\)//i;
                                   $parm_short =~ s/\(m3s-1\)//i;
                                   $parm_short =~ s/ [kmu]?g\/L\/day//i;
                                   $parm_short =~ s/ [kmu]?g\/m2\/day//i;
                                   $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
                                   $parm_short =~ s/ [kmu]?g\/L//i;
                                   $parm_short =~ s/ [kmu]?g\/m3//i;
                                   $parm_short =~ s/ [kmu]?g\/m\^3//i;
                                   $parm_short =~ s/, days//i;
                                   $parm_short =~ s/ days//i;
                                   $parm_short =~ s/,$//;
                                   if ($parm eq "Horizontal Velocity" || $parm eq "Vertical Velocity") {
                                       $units = "m/s";
                                       $title = $parm_short . ", in m/s";
                                   } elsif ($parm eq "Density") {
                                       $units = "kg/m3";
                                       $title = $parm_short . ", in kg/m3";
                                   } else {
                                       $title = $parm_short . ", in ";
                                   }
                                   $units_cb->g_grid_remove();
                                   $units_entry->g_grid();
                                   $conv_type_na_label->g_grid_remove();
                                   $custom_frame->g_grid() if ($conv_type eq "Custom");
                                   $conv_type_cb->g_grid();
                               }
                               if ($gtitle eq "") {
                                   $gtitle = "Longitudinal Slice of " . ucfirst($parm_short);
                               } else {
                                   if (index(lc($gtitle), lc($oldparm_short)) > -1) {
                                       $gtitle =~ s/$oldparm_short/$parm_short/i;
                                   }
                               }
                               $old_units     = $units;
                               $oldparm       = $parm;
                               $oldparm_short = $parm_short;
                               @parm_divlist  = ("None");
                               for ($i=0; $i<=$#parmlist; $i++) {
                                   next if ($parmlist[$i] eq "Horizontal Velocity"
                                            || $parmlist[$i] eq "Vertical Velocity"
                                            || $parmlist[$i] eq "Density"
                                            || $parmlist[$i] eq "Habitat");
                                   if ($parm ne $parmlist[$i]) {
                                       push (@parm_divlist, $parmlist[$i]);
                                   }
                               }
                               $parm_div_cb->configure(-values => [ @parm_divlist ]);
                               if (&list_match($parm_div, @parm_divlist) == -1) {
                                   $parm_div = "None";
                               }
                               if ($parm eq "Temperature" || $parm eq "Horizontal Velocity"
                                       || $parm eq "Vertical Velocity" || $parm eq "Density"
                                       || $parm eq "Habitat" || $#parm_divlist == 0) {
                                   $parm_div_label->g_pack_forget();
                                   $parm_div_cb->g_pack_forget();
                                   $parm_div = "None";
                               } else {
                                   $parm_div_label->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                                   $parm_div_cb->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                               }
                             });
    ($parm_div_label = $parm_frame->new_label(
            -text => " divided by ",
            -font => 'default',
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    ($parm_div_cb = $parm_frame->new_ttk__combobox(
            -textvariable => \$parm_div,
            -values       => [ @parm_divlist ],
            -state        => 'readonly',
            -width        => $parm_chars,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Conversion: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($conv_type_na_label = $f->new_label(
            -text => "n/a",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $conv_type_na_label->g_grid_remove();
    ($conv_type_cb = $f->new_ttk__combobox(
            -textvariable => \$conv_type,
            -values       => [ @conv_types ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $conv_type_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($conv_type eq "Custom") {
                                $custom_frame->g_grid();
                            } else {
                                $custom_frame->g_grid_remove();
                            }
                          }
                      );
    $row++;
    ($custom_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $custom_frame->new_label(
            -text => "Multiply by: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_mult_entry = $custom_frame->new_entry(
            -textvariable => \$conv_mult,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_mult_entry->g_bind("<KeyRelease>",
                              sub { &numeric_entry_only($conv_mult_entry);
                                    my $chars = &max(7, length($conv_mult));
                                    $conv_mult_entry->configure(-width => $chars);
                                  });
    $custom_frame->new_label(
            -text => "  Then add: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_add_entry = $custom_frame->new_entry(
            -textvariable => \$conv_add,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_add_entry->g_bind("<KeyRelease>",
                             sub { &numeric_entry_only($conv_add_entry);
                                   my $chars = &max(7, length($conv_add));
                                   $conv_add_entry->configure(-width => $chars);
                                 });

    $row++;
    $f->new_label(
            -text => "Data Units: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($units_cb = $f->new_ttk__combobox(
            -textvariable => \$units,
            -values       => [ ("Celsius", "Fahrenheit") ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $units_cb->g_bind("<<ComboboxSelected>>",
                       sub { return if ($units eq $old_units);
                             $old_units = $units;
                             if ($units eq "Celsius") {
                                 if ($pmin ne "" && $pmin ne "." && $pmin ne "-") {
                                     $pmin = &floor(($pmin -32) /1.8);
                                 }
                                 if ($pmax ne "" && $pmax ne "." && $pmax ne "-") {
                                     $pmax = &ceil(($pmax  -32) /1.8);
                                 }
                                 if ($pmajor ne "" && $pmajor ne ".") {
                                     $pmajor = &round_to_int($pmajor /1.8);
                                 }
                             } elsif ($units eq "Fahrenheit") {
                                 if ($pmin ne "" && $pmin ne "." && $pmin ne "-") {
                                     $pmin = &floor($pmin *1.8 +32);
                                 }
                                 if ($pmax ne "" && $pmax ne "." && $pmax ne "-") {
                                     $pmax = &ceil($pmax  *1.8 +32);
                                 }
                                 if ($pmajor ne "" && $pmajor ne ".") {
                                     $pmajor = &round_to_int($pmajor *1.8);
                                 }
                             }
                             $title = "Temperature, in degrees " . $units;
                           });
    $units_cb->g_grid_remove();
    ($units_entry = $f->new_entry(
            -textvariable => \$units,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $units_entry->g_bind("<KeyRelease>",
                         sub { my $chars = &max(7, length($units));
                               $units_entry->configure(-width => $chars);
                               if ($parm eq "Temperature") {
                                   $title = "Temperature, in degrees " . $units;
                               } else {
                                   $title = $parm_short . ", in " . $units;
                               }
                             });

    $row++;
    $f->new_label(
            -text => "Data Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$title,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Data Min: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmin_entry = $f->new_entry(
            -textvariable => \$pmin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmin_entry ]);

    $row++;
    $f->new_label(
            -text => "Data Max: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmax_entry = $f->new_entry(
            -textvariable => \$pmax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmax_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmax_entry ]);

    $row++;
    $f->new_label(
            -text => "Data Major: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmajor_entry = $f->new_entry(
            -textvariable => \$pmajor,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($pmajor_entry, 1);
                                                $pmajor =~ s/^-//;
                                              });

    $row++;
    $f->new_label(
            -text => "Graph Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gtitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);

    if ($change eq "misc") {
        $row++;
        $f->new_label(
                -text => "Base Year: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($byear_cb = $f->new_ttk__combobox(
                -textvariable => \$byear,
                -values       => [ reverse($yr_min .. $yr_max) ],
                -width        => 5,
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $byear_cb->g_bind("<<ComboboxSelected>>",
                          sub { my ($m);
                                ($hr, $mi) = split(/:/, $tz_offset);
                                $hr += 0;
                                $mi += 0;
                                $mi *= -1 if ($hr < 0);
                                $jd_offset = $hr/24. +$mi/1440.;
                                $begin_jd  = &date2jdate(sprintf("%04d%02d%02d", $byear, 1, 1));
                                $jd1       = int($first_jd +$jd_offset +0.000001) +$begin_jd -1;
                                $jd2       = int($last_jd  +$jd_offset +0.000001) +$begin_jd;
                                $jd2-- if ($last_jd +$jd_offset == int($last_jd +$jd_offset));

                                ($byr, $m, $bday) = split(/-/, &jdate2datelabel($jd1, "YYYY-MM-DD"));
                                $bday += 0;
                                $bmon  = $mon_names[$m-1];
                                $bdate = sprintf("%s-%02d-%04d", $bmon, $bday, $byr);
                                &set_leap_year($byr);
                                $bday_cb->configure(-values => [ 1 .. $days_in_month[$m-1] ]);

                                ($eyr, $m, $eday) = split(/-/, &jdate2datelabel($jd2, "YYYY-MM-DD"));
                                $eday += 0;
                                $emon  = $mon_names[$m-1];
                                $edate = sprintf("%s-%02d-%04d", $emon, $eday, $eyr);
                                &set_leap_year($eyr);
                                $eday_cb->configure(-values => [ 1 .. $days_in_month[$m-1] ]);
                                $data_range->configure(-text => $bdate . " to " . $edate);

                                if ($byear == $yr_min || $byear == $yr_max
                                                      || $byr < $yr_min || $eyr > $yr_max) {
                                    $yr_min -= 10   if ($byear == $yr_min);
                                    $yr_max += 10   if ($byear == $yr_max);
                                    $yr_min  = $byr if ($byr < $yr_min);
                                    $yr_max  = $eyr if ($eyr > $yr_max);
                                    $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                    $byr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                    $eyr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                }
                              }
                         );
        $f->new_label(
                -text   => " for JDAY = 1.0",
                -anchor => 'w',
                -font   => 'default',
                )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

        $row++;
        $f->new_label(
                -text => "Time Offset: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($offset_frame = $f->new_frame(
                -borderwidth => 0,
                -relief      => 'flat',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
        ($tzoff_cb = $offset_frame->new_ttk__combobox(
                -textvariable => \$tz_offset,
                -values       => [ @tz_offsets ],
                -justify      => 'right',
                -state        => 'readonly',
                -width        => 6,
                ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        $tzoff_cb->g_bind("<<ComboboxSelected>>",
                          sub { my ($m);
                                ($hr, $mi) = split(/:/, $tz_offset);
                                $hr += 0;
                                $mi += 0;
                                $mi *= -1 if ($hr < 0);
                                $jd_offset = $hr/24. +$mi/1440.;
                                $begin_jd  = &date2jdate(sprintf("%04d%02d%02d", $byear, 1, 1));
                                $jd1       = int($first_jd +$jd_offset +0.000001) +$begin_jd -1;
                                $jd2       = int($last_jd  +$jd_offset +0.000001) +$begin_jd;
                                $jd2-- if ($last_jd +$jd_offset == int($last_jd +$jd_offset));

                                ($byr, $m, $bday) = split(/-/, &jdate2datelabel($jd1, "YYYY-MM-DD"));
                                $bday += 0;
                                $bmon  = $mon_names[$m-1];
                                $bdate = sprintf("%s-%02d-%04d", $bmon, $bday, $byr);
                                &set_leap_year($byr);
                                $bday_cb->configure(-values => [ 1 .. $days_in_month[$m-1] ]);

                                ($eyr, $m, $eday) = split(/-/, &jdate2datelabel($jd2, "YYYY-MM-DD"));
                                $eday += 0;
                                $emon  = $mon_names[$m-1];
                                $edate = sprintf("%s-%02d-%04d", $emon, $eday, $eyr);
                                &set_leap_year($eyr);
                                $eday_cb->configure(-values => [ 1 .. $days_in_month[$m-1] ]);
                                $data_range->configure(-text => $bdate . " to " . $edate);

                                if ($byr < $yr_min || $eyr > $yr_max) {
                                    $yr_min = $byr if ($byr < $yr_min);
                                    $yr_max = $eyr if ($eyr > $yr_max);
                                    $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                    $byr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                    $eyr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                }
                              }
                         );
        $offset_frame->new_label(
                -text   => " time zone adjustment ",
                -anchor => 'w',
                -font   => 'default',
                )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        $offset_frame->new_button(
                -text    => "Help",
                -command => sub { &pop_up_info($w2slice_mod_menu,
                                        "The time offset allows the user to add or subtract a time\n"
                                      . "offset if the W2 model was run with a non-local time zone.\n\n"
                                      . "For example, if W2 was run in UTC but the local time zone\n"
                                      . "is PST, an offset of -08:00 would convert the model date/time\n"
                                      . "to a local standard time of PST. This offset does not make\n"
                                      . "any adjustments related to daylight saving time. In general,\n"
                                      . "W2 is best run in the local standard time.\n\n"
                                      . "Leave the time offset at +00:00 for no adjustment.",
                                        "Time Offset Notice");
                                },
                )->g_pack(-side => 'left', -anchor => 'w', -padx => 2);

        if ($jd_skip_active) {
            $row++;
            $f->new_label(
                    -text => "Skip Dates: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($jd_skip_frame = $f->new_frame(
                    -borderwidth => 0,
                    -relief      => 'flat',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
            $jd_skip_frame->new_spinbox(
                    -textvariable => \$jd_skip,
                    -state        => 'readonly',
                    -font         => 'default',
                    -from         => 0,
                    -to           => 49,
                    -increment    => 1,
                    -width        => 4,
                    -command      => sub { $jd_skip_explain = $jd_skip_opts[$jd_skip]; },
                    )->g_pack(-side => 'left', -anchor => 'w');
            $jd_skip_frame->new_label(
                    -textvariable => \$jd_skip_explain,
                    -font         => 'default',
                    )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        }

        $row++;
        $f->new_label(
                -text => "Available Data: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($data_range = $f->new_label(
                -text => $bdate . " to " . $edate,
                -font => 'default',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

        $row++;
        $f->new_label(
                -text => "Date Limits: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($data_frame = $f->new_frame(
                -borderwidth => 0,
                -relief      => 'flat',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
        $data_frame->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "Restrict date range ",
                -font     => 'default',
                -variable => \$dt_limits,
                -command  => sub { if ($dt_limits) {
                                       $bdate_label->g_grid();
                                       $bdate_frame->g_grid();
                                       $edate_label->g_grid();
                                       $edate_frame->g_grid();
                                   } else {
                                       $bdate_label->g_grid_remove();
                                       $bdate_frame->g_grid_remove();
                                       $edate_label->g_grid_remove();
                                       $edate_frame->g_grid_remove();
                                   }
                                 },
                )->g_pack(-side => 'left', -anchor => 'w');
        $data_frame->new_button(
                -text    => "Help",
                -command => sub { &pop_up_info($w2slice_mod_menu,
                                        "W2Anim may run out of memory if too many large slice images\n"
                                      . "have to be generated to produce an animation. The user can\n"
                                      . "limit the date range of a W2 longitudinal slice animation by\n"
                                      . "choosing a shorter range of dates from the W2 output. The\n"
                                      . "start and end dates are for midnight at the start of those days.\n\n"
                                      . "In most instances, such a restriction is unnecessary.",
                                        "Date Range Restriction Notice");
                                },
                )->g_pack(-side => 'left', -anchor => 'w', -padx => 2);

        $row++;
        ($bdate_label = $f->new_label(
                -text => "Start Date: ",
                -font => 'default',
                ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($bdate_frame = $f->new_frame(
                -borderwidth => 0,
                -relief      => 'flat',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
        ($bmon_cb = $bdate_frame->new_ttk__combobox(
                -textvariable => \$bmon,
                -values       => [ @mon_names ],
                -state        => 'readonly',
                -width        => 4,
                ))->g_pack(-side => 'left');
        $bmon_cb->g_bind("<<ComboboxSelected>>",
                        sub { &set_leap_year($byr);
                              $bm = &list_match($bmon, @mon_names);
                              $bday_cb->configure(-values => [ 1 .. $days_in_month[$bm] ]);
                              $bday = $days_in_month[$bm] if ($bday > $days_in_month[$bm]);
                            }
                        );
        $bdate_frame->new_label(
                -text => "-",
                -font => 'default',
                )->g_pack(-side => 'left');
        ($bday_cb = $bdate_frame->new_ttk__combobox(
                -textvariable => \$bday,
                -values       => [ 1 .. $days_in_month[$bm] ],
                -state        => 'readonly',
                -width        => 3,
                ))->g_pack(-side => 'left');
        $bdate_frame->new_label(
                -text => "-",
                -font => 'default',
                )->g_pack(-side => 'left');
        ($byr_cb = $bdate_frame->new_ttk__combobox(
                -textvariable => \$byr,
                -values       => [ reverse($yr_min .. $yr_max) ],
                -state        => 'readonly',
                -width        => 5,
                ))->g_pack(-side => 'left');
        $byr_cb->g_bind("<<ComboboxSelected>>",
                        sub { &set_leap_year($byr);
                              $bm = &list_match($bmon, @mon_names);
                              if ($bm == 1) {
                                  $bday_cb->configure(-values => [ 1 .. $days_in_month[$bm] ]);
                                  $bday = $days_in_month[$bm] if ($bday > $days_in_month[$bm]);
                              }
                              if ($byr == $yr_min || $byr == $yr_max) {
                                  $yr_min -= 10 if ($byr == $yr_min);
                                  $yr_max += 10 if ($byr == $yr_max);
                                  $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                  $byr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                  $eyr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                              }
                            }
                        );

        $row++;
        ($edate_label = $f->new_label(
                -text => "End Date: ",
                -font => 'default',
                ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($edate_frame = $f->new_frame(
                -borderwidth => 0,
                -relief      => 'flat',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
        ($emon_cb = $edate_frame->new_ttk__combobox(
                -textvariable => \$emon,
                -values       => [ @mon_names ],
                -state        => 'readonly',
                -width        => 4,
                ))->g_pack(-side => 'left');
        $emon_cb->g_bind("<<ComboboxSelected>>",
                        sub { &set_leap_year($eyr);
                              $em = &list_match($emon, @mon_names);
                              $eday_cb->configure(-values => [ 1 .. $days_in_month[$em] ]);
                              $eday = $days_in_month[$em] if ($eday > $days_in_month[$em]);
                            }
                        );
        $edate_frame->new_label(
                -text => "-",
                -font => 'default',
                )->g_pack(-side => 'left');
        ($eday_cb = $edate_frame->new_ttk__combobox(
                -textvariable => \$eday,
                -values       => [ 1 .. $days_in_month[$em] ],
                -state        => 'readonly',
                -width        => 3,
                ))->g_pack(-side => 'left');
        $edate_frame->new_label(
                -text => "-",
                -font => 'default',
                )->g_pack(-side => 'left');
        ($eyr_cb = $edate_frame->new_ttk__combobox(
                -textvariable => \$eyr,
                -values       => [ reverse($yr_min .. $yr_max) ],
                -state        => 'readonly',
                -width        => 5,
                ))->g_pack(-side => 'left');
        $eyr_cb->g_bind("<<ComboboxSelected>>",
                        sub { &set_leap_year($eyr);
                              $em = &list_match($emon, @mon_names);
                              if ($em == 1) {
                                  $eday_cb->configure(-values => [ 1 .. $days_in_month[$em] ]);
                                  $eday = $days_in_month[$em] if ($eday > $days_in_month[$em]);
                              }
                              if ($eyr == $yr_min || $eyr == $yr_max) {
                                  $yr_min -= 10 if ($eyr == $yr_min);
                                  $yr_max += 10 if ($eyr == $yr_max);
                                  $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                  $byr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                  $eyr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                              }
                            }
                        );

        if (! $dt_limits) {
            $bdate_label->g_grid_remove();
            $bdate_frame->g_grid_remove();
            $edate_label->g_grid_remove();
            $edate_frame->g_grid_remove();
        }
    }

    if ($parm eq "Temperature" || $parm eq "Horizontal Velocity" || $parm eq "Density" || $parm eq "Habitat"
                               || $parm eq "Vertical Velocity" || $#parm_divlist == 0) {
        $parm_div_label->g_pack_forget();
        $parm_div_cb->g_pack_forget();
    } else {
        $parm_div_label->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        $parm_div_cb->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    }
    if ($conv_type ne "Custom") {
        $custom_frame->g_grid_remove();
    }
    if ($parm eq "Temperature") {
        $units_cb->g_grid();
        $units_entry->g_grid_remove();
        $conv_type_na_label->g_grid();
        $custom_frame->g_grid_remove();
        $conv_type_cb->g_grid_remove();
        $conv_type = "None";
        $parm_div  = "None";
    } else {
        $units_cb->g_grid_remove();
        $units_entry->g_grid();
        $conv_type_na_label->g_grid_remove();
        $custom_frame->g_grid() if ($conv_type eq "Custom");
        $conv_type_cb->g_grid();
    }
    $f->g_grid_columnconfigure(2, -weight => 2);

    Tkx::wm_resizable($w2slice_mod_menu,0,0);
    &adjust_window_position($w2slice_mod_menu);
    $w2slice_mod_menu->g_focus;
}


sub make_w2_slice {
    my ($canv, $id, $props_updated) = @_;
    my (
        $box_id, $change, $cs_max, $cs_min, $cs_range, $cs_rev, $cscheme1,
        $cscheme2, $day, $date_id, $date_label, $dsize, $dsum, $dt,
        $dt_begin, $dt_end, $dy_full, $geom, $group_tags, $gtag, $i,
        $id2, $ih, $img, $img_data, $indx, $item, $iw, $j, $j2, $j3,
        $j4, $jb, $jj, $jw, $k, $kalt, $kmx, $kn_digits, $kt, $last_jb,
        $last_jw, $last_seg, $mismatch, $mon, $move_mcursor, $mult, $mydt,
        $n, $nbr, $ncolors, $new_graph, $ns, $nsegs, $nwb, $parm_short,
        $pbar, $pbar1, $pbar2, $pbar_frame, $pbar_window, $pval, $pval3,
        $pval4, $refresh_menus, $resized, $seg_dn, $seg_list, $seg_up,
        $slice_image, $src_type, $stop_processing, $surf_elev, $tabid,
        $tag, $update_cs, $X, $x1, $x2, $xbase, $xd1, $xd2, $xdistance,
        $xmax, $xmin, $xmult, $xp, $xp1, $xp2, $xrange, $Y, $y1, $y2,
        $yexag, $ymax, $ymin, $yp, $yp1, $yp1i, $yp2, $yp3, $yp3i, $yp3o,
        $yp4, $yp4i, $ypi, $yr, $yrange,

        @be, @bs, @bth_files, @colors, @coords, @cpl_files, @cpl_lines,
        @cus, @dlx, @ds, @el, @elws, @grp_tags, @img_keys, @items, @kb,
        @ktwb, @mydates, @old_coords, @pdata, @scale, @seg_limits, @seg_wb,
        @seglist, @slice_data, @slope, @tags, @tecplot, @us, @wbs, @xdist,

        %axis_props, %color_key_props, %limits, %parms, %profile, %sdata,
        %slice_img,
       );

#   For new plots, pop up a menu for file names and parameters
    if (! defined($props{$id}{files})) {
        return &setup_w2_slice_or_tdmap_or_wlevels($canv, $id);
    }

#   Make tag and get coordinates of graph frame
    $gtag   = "graph" . $id;
    @coords = @{ $props{$id}{coordlist} };
    ($x1, $y1, $x2, $y2) = @coords;

#   Determine whether group tags are present and save the list
    $group_tags = 0;
    @grp_tags   = ();
    @tags       = Tkx::SplitList($canv->itemcget($id, -tags));
    if (&list_search("group_", @tags) > -1) {
        $group_tags = 1;
        foreach $tag (@tags) {
            push (@grp_tags, $tag) if ($tag =~ /^group_/);
        }
    }

#   Read the data files, if not done already
    if (! defined($props{$id}{data}) || ! $props{$id}{data}) {
        %parms    = %{ $props{$id}{parms} };
        @wbs      = split(/,/, $props{$id}{wb_list});
        $src_type = $props{$id}{src_type};

        if (defined($props{$id}{oldcoords})) {
            %profile   = %{ $gr_props{$id} };
            $change    = $parms{change};      # values:  parm, misc
            $new_graph = 0;
        } else {
            %profile   = ();
            $change    = "";
            $new_graph = 1;
        }

        $dt_begin = $dt_end = -999;
        if ($props{$id}{dt_limits}) {
            ($mon, $day, $yr) = &parse_date($props{$id}{dt_begin}, 1);
            $dt_begin = sprintf("%04d%02d%02d0000", $yr, $mon, $day);
            ($mon, $day, $yr) = &parse_date($props{$id}{dt_end}, 1);
            $dt_end   = sprintf("%04d%02d%02d0000", $yr, $mon, $day);
        }

#       Read bathymetry files, as necessary
#       Required for all source file types. Vector (w2l) files don't have a good kb value.
        if ($new_graph) {
            $status_line = "Reading bathymetry files...";
            Tkx::update_idletasks();
            @bth_files = @{ $props{$id}{bth_files} };
            for ($n=0; $n<=$#wbs; $n++) {
                &read_bth($main, $id, $wbs[$n], $bth_files[$n]);
            }
            $status_line = "";
            Tkx::update_idletasks();
        }

#       Move mouse cursor on first creation, to ensure that it changes to cursor_wait
        if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
            $canv->g_bind("<Motion>", "");
            Tkx::event_generate($main, "<Motion>", -warp => 1, -x => ($x1+$x2)/2, -y => ($y1+$y2)/2);
            $canv->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"), $canv, "menu" ]);
        }

#       Read contour files or vector file
        if ($src_type =~ /Contour/i) {
            @tecplot   = @{ $props{$id}{tecplot}   };
            @cpl_lines = @{ $props{$id}{cpl_lines} };
            @cpl_files = @{ $props{$id}{cpl_files} };
            for ($n=0; $n<=$#wbs; $n++) {
                $jw = $wbs[$n];
                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $cpl_lines[$n],
                                                             "Reading W2 contour file...");
                %sdata = &read_w2_cpl_file($main, $id, $jw, $cpl_files[$n], $tecplot[$n], 0,
                                           $props{$id}{parm},  $props{$id}{parm_div}, $props{$id}{byear},
                                           $props{$id}{tz_offset}, $props{$id}{jd_skip}, $pbar,
                                           $dt_begin, $dt_end);
                &destroy_progress_bar($main, $pbar_window);

#               Data conversion
                if (&list_match($props{$id}{ctype}, @conv_types) > 0 || $props{$id}{ctype} =~ /^Custom,/) {
                    $status_line = "Converting units...";
                    Tkx::update_idletasks();
                    %sdata = &convert_slice_data($main, $props{$id}{ctype}, $id, $jw, %sdata);
                    $status_line = "";
                    Tkx::update_idletasks();
                }
                $slice_data[$n] = { %sdata };
            }

        } elsif ($src_type =~ /Vector/i) {
            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, -s $props{$id}{w2l_file},
                                                         "Reading W2 vector file...");
            $status_line = "Reading W2 vector file... Date = 1";
            %sdata = &read_w2_vector_file($main, $id, $props{$id}{w2l_file}, 0,
                                          $props{$id}{parm}, $props{$id}{parm_div}, $props{$id}{byear},
                                          $props{$id}{tz_offset}, $props{$id}{jd_skip}, $pbar,
                                          $dt_begin, $dt_end);
            &destroy_progress_bar($main, $pbar_window);

#           Data conversion
            if (&list_match($props{$id}{ctype}, @conv_types) > 0 || $props{$id}{ctype} =~ /^Custom,/) {
                $status_line = "Converting units...";
                Tkx::update_idletasks();
                %sdata = &convert_slice_data($main, $props{$id}{ctype}, $id, 'all', %sdata);
                $status_line = "";
                Tkx::update_idletasks();
            }
            $slice_data[0] = { %sdata };
        }
        $profile{slice_data} = [ @slice_data ];

#       Find minimum and maximum elevation and parameter values
        %limits = &find_w2_slice_limits($id, %profile);
        $profile{date_min} = $limits{date_min};
        $profile{date_max} = $limits{date_max};
        $profile{dpth_min} = $limits{dpth_min};
        $profile{dpth_max} = $limits{dpth_max};
        $profile{elev_min} = $limits{elev_min};
        $profile{elev_max} = $limits{elev_max};
        $profile{parm_min} = $limits{parm_min};
        $profile{parm_max} = $limits{parm_max};
        undef %limits;

        if ($new_graph) {
            $profile{yfont}     = $default_family;
            $profile{yl_size}   = &min(11, &max(8, int((abs($x2-$x1)+abs($y2-$y1))/2./41)));
            $profile{yt_size}   = $profile{yl_size} +2;
            $profile{yl_weight} = 'normal';
            $profile{yt_weight} = 'normal';
            $profile{ytype}     = $parms{ytype};
            $profile{yunits}    = $parms{yunits};
            $profile{ymin}      = ($parms{ymin} ne "") ? $parms{ymin} : 0;
            $profile{ymax}      = $parms{ymax};
            $profile{ymajor}    = ($parms{ymajor} eq "") ? "auto" : $parms{ymajor};
            $profile{ypr_tics}  = "outside";
            $profile{yop_tics}  = "none";
            $profile{ytitle}    = $parms{ytype} . ", in " . $parms{yunits};

            $profile{xfont}     = $profile{yfont};
            $profile{xl_size}   = $profile{yl_size};
            $profile{xt_size}   = $profile{yt_size};
            $profile{xl_weight} = $profile{yl_weight};
            $profile{xt_weight} = $profile{yt_weight};
            $profile{xunits}    = $parms{xunits};
            $profile{xflip}     = $parms{xflip};
            $profile{xflip_img} = 0;
            $profile{xbase}     = 0;
            $profile{xmin}      = 0;
            $profile{xfirst}    = 0;
            $profile{xmax}      = 0;
            $profile{x_km}      = 0;
            $profile{xmajor}    = "auto";
            $profile{xpr_tics}  = "outside";
            $profile{xop_tics}  = "none";
            $profile{xmax_auto} = 1;
            if ($parms{xunits} eq "kilometers") {
                $profile{xtitle} = "River Kilometer";
            } else {
                $profile{xtitle} = "River Mile";
            }

            $profile{stype}     = "none";
            $profile{sfont}     = $default_family;
            $profile{st_size}   = $profile{xt_size};
            $profile{sl_size}   = $profile{xl_size};
            $profile{st_weight} = $profile{xt_weight};
            $profile{sl_weight} = $profile{xl_weight};
            $profile{smajor}    = "auto";
            $profile{spr_tics}  = "outside";
            $profile{sop_tics}  = "none";
            $profile{stic_loc}  = "upstream edge";
            $profile{sgrid}     = 0;
            $profile{sgrid_col} = '#C0C0C0';
            $profile{bgrid}     = 0;
            $profile{bgrid_col} = '#FF8040';
            $profile{stitle}    = "Segment Number";

            $profile{gtfont}    = $profile{yfont};
            $profile{gt_size}   = $profile{yt_size};
            $profile{gt_weight} = 'bold';
            $profile{gs_size}   = $profile{gt_size} -1;
            $profile{gs_weight} = $profile{gt_weight};

            $profile{keyfont}   = $default_family;
            $profile{kn_size}   = $profile{yl_size};
            $profile{kt_size}   = $profile{yl_size} +2;
            $profile{kt_weight} = 'normal';
            $profile{kn_weight} = 'normal';
            $profile{kn_digits} = 1;

            $profile{add_cs}    = 1;
            $profile{cs_height} = &max(2, &min(18, int(($y2-$y1+1) /$parms{ncolors})));
            if ($parms{cscheme} eq "Blue to Orange") {
                $profile{cscheme1} = "Blue";
                $profile{cscheme2} = "Orange";
                $profile{ncolors}  = $parms{ncolors} /2;
            } elsif ($parms{cscheme} eq "Blue to Red") {
                $profile{cscheme1} = "Blue";
                $profile{cscheme2} = "Red";
                $profile{ncolors}  = $parms{ncolors} /2;
            } else {
                $profile{cscheme1} = $parms{cscheme};
                $profile{cscheme2} = "None";
                $profile{ncolors}  = $parms{ncolors};
            }
            $profile{cs_rev}   =  0;
            $profile{cs_hide}  =  0;
            $profile{xleg_off} = 40;
            $profile{yleg_off} =  0;
            $profile{cs_width} = 24;
            $profile{cs_link}  =  0;
            $profile{cs_major} = "auto";
            $profile{pc_style} = "By Layer";
        }

        if ($props{$id}{parm} eq "Temperature") {
            $profile{keytitle} = "Temperature, in degrees " . $props{$id}{parm_units};
        } else {
            $parm_short = $props{$id}{parm};
            $parm_short =~ s/\(ms-1\)//i;
            $parm_short =~ s/\(m3s-1\)//i;
            $parm_short =~ s/ [kmu]?g\/L\/day//i;
            $parm_short =~ s/ [kmu]?g\/m2\/day//i;
            $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
            $parm_short =~ s/ [kmu]?g\/L//i;
            $parm_short =~ s/ [kmu]?g\/m3//i;
            $parm_short =~ s/ [kmu]?g\/m\^3//i;
            $parm_short =~ s/, days//i;
            $parm_short =~ s/ days//i;
            $parm_short =~ s/,$//;
            $profile{keytitle} = $parm_short . ", in " . $props{$id}{parm_units};
        }
        $profile{gtitle}   = $parms{gtitle};
        $profile{cs_min}   = $parms{pmin};
        $profile{cs_max}   = $parms{pmax};
        $profile{cs_major} = $parms{pmajor} if (! $new_graph);

        if (@animate_ids && $#animate_ids >= 0) {
            $update_cs = 0;
            foreach $item (@animate_ids) {
                next if ($item == $id);
                next if ($props{$item}{meta} =~ /time_series|w2_wlevels/);
                next if ($props{$item}{meta} eq "w2_outflow" && ! $props{$item}{add_parm});
                if ($gr_props{$item}{cs_link} == 2) {
                    if ($props{$item}{meta} =~ /(w2_slice|w2_profile|w2_outflow)/
                         && $props{$item}{parm}       eq $props{$id}{parm}
                         && $props{$item}{parm_div}   eq $props{$id}{parm_div}
                         && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                        $update_cs = 1;
                        $id2 = $item;
                        last;
                    } elsif ($props{$item}{meta} eq "w2_tdmap"
                         && $props{$item}{map_type}   eq "standard"
                         && $props{$item}{parm_sav}   eq $props{$id}{parm}
                         && $props{$item}{pdiv_sav}   eq $props{$id}{parm_div}
                         && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                        $update_cs = 1;
                        $id2 = $item;
                        last;
                    } elsif ($props{$item}{meta} =~ /data_profile/
                         && $props{$item}{prof_type}  eq "standard"
                         && $props{$item}{parm}       eq $props{$id}{parm}
                         && $props{$id}{parm_div}     eq "None"
                         && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                        $update_cs = 1;
                        $id2 = $item;
                        last;
                    } elsif ($props{$item}{meta} =~ /vert_wd_zone/
                         && $props{$id}{parm}       eq "Temperature"
                         && $props{$id}{parm_div}   eq "None"
                         && $props{$item}{wt_units} eq $props{$id}{parm_units}) {
                        $update_cs = 1;
                        $id2 = $item;
                        last;
                    }
                }
            }
            if (! $update_cs) {
                foreach $item (@animate_ids) {
                    next if ($item == $id);
                    next if ($props{$item}{meta} =~ /data_profile|vert_wd_zone|time_series|w2_wlevels/);
                    next if ($props{$item}{meta} eq "w2_outflow" && ! $props{$item}{add_parm});
                    next if ($props{$item}{meta} =~ /w2_profile|w2_outflow|w2_tdmap/
                             && $props{$item}{src_type} ne $src_type);
                    if ($gr_props{$item}{cs_link} == 1) {
                        if ($props{$item}{meta} =~ /w2_slice/
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$item}{parm_div}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}
                             && $props{$item}{con_file}   eq $props{$id}{con_file}
                             && $props{$item}{src_type}   eq $props{$id}{src_type}) {
                            $update_cs = 1;
                            $id2 = $item;
                            last;
                        } elsif ($props{$item}{meta} eq "w2_tdmap"
                             && $props{$item}{map_type}   eq "standard"
                             && $props{$item}{parm_sav}   eq $props{$id}{parm}
                             && $props{$item}{pdiv_sav}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}
                             && $props{$item}{con_file}   eq $props{$id}{con_file}
                             && $props{$item}{src_type}   eq $props{$id}{src_type}) {
                            $update_cs = 1;
                            $id2 = $item;
                            last;
                        } elsif ($props{$item}{meta} =~ /w2_profile|w2_outflow/
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$item}{parm_div}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            if ($src_type =~ /Contour/i) {
                                for ($n=0; $n<=$#wbs; $n++) {
                                    if ($cpl_files[$n] eq $props{$item}{src_file}) {
                                        $update_cs = 1;
                                        $id2 = $item;
                                        last;
                                    }
                                }
                                last if ($update_cs);
                            } elsif ($src_type =~ /Vector/i) {
                                if ($props{$id}{w2l_file} eq $props{$item}{src_file}) {
                                    $update_cs = 1;
                                    $id2 = $item;
                                    last;
                                }
                            }
                        }
                    }
                }
            }
            if ($update_cs) {
                $ncolors           = $profile{ncolors};
                $profile{cs_link}  = $gr_props{$id2}{cs_link};
                $profile{cscheme1} = $gr_props{$id2}{cscheme1};
                $profile{cscheme2} = $gr_props{$id2}{cscheme2};
                $profile{ncolors}  = $gr_props{$id2}{ncolors};
                $profile{cs_rev}   = $gr_props{$id2}{cs_rev};
                $profile{cs_min}   = $gr_props{$id2}{cs_min};
                $profile{cs_max}   = $gr_props{$id2}{cs_max};
                $profile{cs_major} = $gr_props{$id2}{cs_major};
                if ($new_graph) {
                    if ($profile{cs_height} *$ncolors > $y2-$y1+1 && $profile{cs_height} > 2) {
                        $profile{cs_height} = &max(2, &min(18, int(($y2-$y1+1) /$profile{ncolors})));
                    }
                } elsif ($ncolors != $profile{ncolors}) {
                    $profile{cs_height} = &max(2, &min(30,
                                   &round_to_int($profile{cs_height} *$ncolors /$profile{ncolors})));
                }
            }
        }
        if (! $new_graph) {
            undef $gr_props{$id};
            if (defined($profile{slice_img})) {
                undef $profile{slice_img};
            }
        }
        $profile{redraw}  = 1;
        $gr_props{$id}    = { %profile };
        $props{$id}{data} = 1;
        $props{$id}{gnum} = ++$graph_num if (! defined($props{$id}{oldcoords}));
        $resized          = 0;
        $refresh_menus    = 0;
        undef %profile;

#       Rebuild the dates array if different jd_skip or byear.
#       The rebuild option is determined in change_w2_slice.
        if (! $new_graph) {
            &rebuild_datelist if ($parms{rebuild});
            $refresh_menus = 1;
            $canv->delete($gtag . "_xaxis");
            $canv->delete($gtag . "_xaxisTitle");
            $canv->delete($gtag . "_yaxis");
            $canv->delete($gtag . "_yaxisTitle");
            $canv->delete($gtag . "_saxis");
            $canv->delete($gtag . "_saxisTitle");
            $canv->delete($gtag . "_sgrid");
            $canv->delete($gtag . "_date");
            $canv->delete($gtag . "_gtitle");
            $canv->delete($gtag . "_colorKey");
            $canv->delete($gtag . "_colorKeyTitle");
            $canv->delete($gtag . "_noData");
            $canv->delete($gtag . "_colorMap");
        }
        undef %parms;

#   Or use previously read info.  If resized, delete graph and redraw
    } else {
        @old_coords    = @{ $props{$id}{oldcoords} };
        $refresh_menus = 0;
        $resized       = 0;
        for ($i=0; $i<=$#coords; $i++) {
            if ($coords[$i] != $old_coords[$i]) {
                $resized = 1;
                last;
            }
        }
        return if (! $resized && ! $props_updated);
        $gr_props{$id}{redraw} = 1 if ($resized);

        @slice_data = @{ $gr_props{$id}{slice_data} };
        @wbs        = split(/,/, $props{$id}{wb_list});
        $src_type   = $props{$id}{src_type};

        $canv->delete($gtag . "_xaxis");
        $canv->delete($gtag . "_xaxisTitle");
        $canv->delete($gtag . "_yaxis");
        $canv->delete($gtag . "_yaxisTitle");
        $canv->delete($gtag . "_saxis");
        $canv->delete($gtag . "_saxisTitle");
        $canv->delete($gtag . "_sgrid");
        $canv->delete($gtag . "_date");
        $canv->delete($gtag . "_gtitle");
        $canv->delete($gtag . "_colorKey");
        $canv->delete($gtag . "_colorKeyTitle");
        if ($gr_props{$id}{redraw}) {
            $canv->delete($gtag . "_noData");
            $canv->delete($gtag . "_colorMap");
        }
    }
    $props{$id}{oldcoords} = [ @coords ];

#   Check the dates from each waterbody's dataset, if using contour files
    if ($#wbs > 0 && $src_type =~ /Contour/i) {
        %sdata   = %{ $slice_data[0] };
        @mydates = keys %sdata;
        $dsum    = &sum(@mydates);
        for ($n=1; $n<=$#wbs; $n++) {
            %sdata   = %{ $slice_data[$n] };
            @mydates = keys %sdata;
            if ($dsum != &sum(@mydates)) {
                &pop_up_info($main, "Contour file dates for waterbody " . $wbs[$n] . "\n"
                                  . "do not match those for waterbody " . $wbs[0] . "\n"
                                  . "This could lead to visualization problems.");
            }
        }
    }

#   Set the list of dates or merge the dates array if necessary
#   Add the graph to the list of animated graphs, if necessary
#   For first creation, ensure mouse cursor is on canvas so it can be changed
    %sdata   = %{ $slice_data[0] };
    @mydates = sort keys %sdata;
    if (! $props{$id}{dt_limits} && $props{$id}{jd_skip} == 0) {
        $props{$id}{start_dt} = $mydates[0];
        $props{$id}{end_dt}   = $mydates[$#mydates];
    }
    $move_mcursor = 0;
    if (! @animate_ids || &list_match($id, @animate_ids) == -1) {
        $move_mcursor = 1;
        if (@dates && @animate_ids && $#animate_ids >= 0) {
            $mismatch = 0;
            foreach $id2 (@animate_ids) {
#               next if ($id2 == $id);
                next if ($props{$id2}{meta}
                               =~ /data_profile_cmap|w2_profile_cmap|w2_profile_matrix|w2_tdmap|time_series/);
                if ($props{$id2}{meta} eq "w2_profile") {
                    if ($props{$id2}{src_type}      ne $src_type
                         || $props{$id2}{byear}     != $props{$id}{byear}
                         || $props{$id2}{tz_offset} ne $props{$id}{tz_offset}
                         || $props{$id2}{jd_skip}   != $props{$id}{jd_skip}) {
                        $mismatch = 1;
                        last;
                    }
                    if ($src_type =~ /Contour/i) {
                        @cpl_files = @{ $props{$id}{cpl_files} };
                        $mismatch  = 1;
                        for ($n=0; $n<=$#wbs; $n++) {
                            if ($cpl_files[$n] eq $props{$id2}{src_file}) {
                                $mismatch = 0;
                                last;
                            }
                        }
                        last if ($mismatch);
                    } elsif ($src_type =~ /Vector/i) {
                        if ($props{$id}{w2l_file} ne $props{$id2}{src_file}) {
                            $mismatch = 1;
                            last;
                        }
                    }
                } elsif ($props{$id2}{meta} =~ /w2_slice|w2_wlevels/) {
                    if ($props{$id2}{con_file}     ne $props{$id}{con_file}
                        || $props{$id2}{src_type}  ne $src_type
                        || $props{$id2}{byear}     != $props{$id}{byear}
                        || $props{$id2}{tz_offset} ne $props{$id}{tz_offset} 
                        || $props{$id2}{jd_skip}   != $props{$id}{jd_skip}) {
                        $mismatch = 1;
                        last;
                    }
                    if ($props{$id2}{meta} eq "w2_slice") {
                        if ($props{$id2}{dt_limits}) {
                            if (! $props{$id}{dt_limits}
                                   || $props{$id2}{dt_begin} ne $props{$id}{dt_begin}
                                   || $props{$id2}{dt_end}   ne $props{$id}{dt_end}) {
                                $mismatch = 1;
                                last;
                            }
                        }
                    }
                } elsif ($props{$id2}{meta} =~ /^(data_profile|vert_wd_zone|w2_outflow)$/) {
                    $mismatch = 1;
                    last;
                }
            }
            if ($mismatch) {
                if (defined($animate_tb) && Tkx::winfo_exists($animate_tb)) {
                    if ($animate_tb->g_wm_title() eq "Animation toolbar") {
                        $animate_tb->g_destroy();
                        undef $animate_tb;
                    }
                }
                $dt    = $dates[$dti-1];
                @dates = &merge_dates(\@dates, \@mydates);
                $dti   = 1 + &nearest_dt_index($dt, @dates);
                $dti++ if ($dti == 0);
            }
        } else {
            @dates = @mydates;
            $dti   = 1;
            $delay = 0.5;
        }
        if ($global_dt_limits) {     # Truncate date range if global limits
            $dt    = $dates[$dti-1];
            @dates = &truncate_dates($global_dt_begin, $global_dt_end, @dates);
            $dti   = 1 + &nearest_dt_index($dt, @dates);
            $dti++ if ($dti == 0);
        }
        $dti_max = $#dates+1;
        $dti_old = $dti;
        push (@animate_ids, $id);
    }
    $dt = $dates[$dti-1];
    $export_menu->entryconfigure(3, -state => 'normal') if ($use_GS);
    $pref_menu->entryconfigure(0,   -state => 'normal');

#   Plot a white rectangle below the graph frame
    @items     = Tkx::SplitList($canv->find_withtag($gtag . "_main"));
    $new_graph = ($#items >= 0) ? 0 : 1;
    if ($new_graph) {
        $box_id = $canv->create_rectangle($x1, $y1, $x2, $y2,
                             -outline => "",
                             -width   => 0,
                             -fill    => &get_rgb_code("white"),
                             -tags    => $gtag . " " . $gtag . "_main");
        $canv->lower($box_id, $id);
    } else {
        $canv->coords($gtag . "_main", @coords);
        $canv->raise($id, $gtag . "_main");
    }

#   Plot Y axis
    $axis_props{min}     = $gr_props{$id}{ymin};
    $axis_props{max}     = $gr_props{$id}{ymax};
    $axis_props{major}   = $gr_props{$id}{ymajor};
    $axis_props{pr_tics} = $gr_props{$id}{ypr_tics};
    $axis_props{op_tics} = $gr_props{$id}{yop_tics};
    $axis_props{minor}   = 1;
    $axis_props{reverse} = ($gr_props{$id}{ytype} eq "Depth") ? 1 : 0;
    $axis_props{title}   = $gr_props{$id}{ytitle};
    $axis_props{font}    = $gr_props{$id}{yfont};
    $axis_props{size1}   = $gr_props{$id}{yl_size};
    $axis_props{size2}   = $gr_props{$id}{yt_size};
    $axis_props{weight1} = $gr_props{$id}{yl_weight};
    $axis_props{weight2} = $gr_props{$id}{yt_weight};
    $axis_props{side}    = "left";
    $axis_props{tags}    = $gtag . " " . $gtag . "_yaxis";
    $axis_props{coords}  = [$x1, $y2, $x1, $y1];
    $axis_props{op_loc}  = $x2;
    &make_axis($canv, %axis_props);
    undef %axis_props;

#   Deal with the color scheme and create the color key
    $cscheme1  = $gr_props{$id}{cscheme1};
    $cscheme2  = $gr_props{$id}{cscheme2};
    $ncolors   = $gr_props{$id}{ncolors};
    $cs_rev    = $gr_props{$id}{cs_rev};
    $cs_min    = $gr_props{$id}{cs_min};
    $cs_max    = $gr_props{$id}{cs_max};
    $kn_digits = $gr_props{$id}{kn_digits};
    if (&list_match($cscheme1, @color_scheme_names) == -1 ||
       (&list_match($cscheme1, @full_color_schemes) == -1 && &list_match($ncolors, @valid_nc) == -1) ||
       (&list_match($cscheme1, @full_color_schemes) >= 0 && &list_match($ncolors, @valid_nc_alt) == -1) ||
       ($cscheme2 ne "" && $cscheme2 ne "None" && &list_match($cscheme2, @color_scheme_names) == -1)) {
        $cscheme1  = $gr_props{$id}{cscheme1}  = "Blue";
        $cscheme2  = $gr_props{$id}{cscheme2}  = "Orange";
        $ncolors   = $gr_props{$id}{ncolors}   = 11;
        $cs_rev    = $gr_props{$id}{cs_rev}    =  0;
        $cs_min    = $gr_props{$id}{cs_min}    =  0;
        $cs_max    = $gr_props{$id}{cs_max}    = 22;
        $kn_digits = $gr_props{$id}{kn_digits} =  1;
    }
    $cs_range = $cs_max -$cs_min;
    @colors   = &make_color_scheme($ncolors, $cs_rev, $cscheme1, $cscheme2);
    @scale    = ();
    for ($i=0; $i<=$#colors+1; $i++) {
        $j = $#colors +1 -$i;
        $scale[$j] = $cs_min +$cs_range*$j/($#colors+1);
    }
    $gr_props{$id}{colors}    = [ @colors ];
    $gr_props{$id}{scale}     = [ @scale  ];

    $color_key_props{xleg}    = $x2 + $gr_props{$id}{xleg_off};
    $color_key_props{yleg}    = $y1 + $gr_props{$id}{yleg_off};
    $color_key_props{width}   = $gr_props{$id}{cs_width};
    $color_key_props{height}  = $gr_props{$id}{cs_height};
    $color_key_props{colors}  = [ @colors ];
    $color_key_props{scale}   = [ @scale  ];
    $color_key_props{title}   = $gr_props{$id}{keytitle};
    $color_key_props{font}    = $gr_props{$id}{keyfont};
    $color_key_props{size1}   = $gr_props{$id}{kn_size};
    $color_key_props{size2}   = $gr_props{$id}{kt_size};
    $color_key_props{weight1} = $gr_props{$id}{kn_weight};
    $color_key_props{weight2} = $gr_props{$id}{kt_weight};
    $color_key_props{digits}  = $kn_digits;
    $color_key_props{major}   = $gr_props{$id}{cs_major};
    $color_key_props{tags}    = $gtag . " " . $gtag . "_colorKey";
    &make_color_key($canv, %color_key_props);
    undef %color_key_props;

    if ($gr_props{$id}{cs_hide}) {
        $canv->itemconfigure($gtag . "_colorKey", -state => 'hidden');
    }

#   Plot the date as a subtitle
    $xp = ($x1+$x2)/2.;
    if (($gr_props{$id}{stype} ne "none"    && $gr_props{$id}{sop_tics} =~ /outside|cross/) ||
        ($gr_props{$id}{stype} ne "replace" && $gr_props{$id}{xop_tics} =~ /outside|cross/)) {
        $yp = $y1-14;
    } else {
        $yp = $y1-6;
    }
    $date_label = &get_formatted_date($dt);
    $date_id = $canv->create_text($xp, $yp,
                       -anchor => 's',
                       -text   => $date_label,
                       -fill   => &get_rgb_code("black"),
                       -angle  => 0,
                       -tags   => $gtag . " " . $gtag . "_date",
                       -font   => [-family     => $gr_props{$id}{gtfont},
                                   -size       => $gr_props{$id}{gs_size},
                                   -weight     => $gr_props{$id}{gs_weight},
                                   -slant      => 'roman',
                                   -underline  => 0,
                                   -overstrike => 0,
                                  ]);
    @coords = Tkx::SplitList($canv->bbox($date_id));
    $dsize  = &max(10, abs($coords[3] - $coords[1]));

#   Plot the graph title
    $canv->create_text($xp, $yp-$dsize,
                       -anchor => 's', 
                       -text   => $gr_props{$id}{gtitle},
                       -fill   => &get_rgb_code("black"),
                       -angle  => 0,
                       -tags   => $gtag . " " . $gtag . "_gtitle",
                       -font   => [-family     => $gr_props{$id}{gtfont},
                                   -size       => $gr_props{$id}{gt_size},
                                   -weight     => $gr_props{$id}{gt_weight},
                                   -slant      => 'roman',
                                   -underline  => 0,
                                   -overstrike => 0,
                                  ]);

#   Initialize some arrays. Get segment list and downstream distance.
    $nwb   = $grid{$id}{nwb};
    $nbr   = $grid{$id}{nbr};
    $kmx   = $grid{$id}{kmx};
    @bs    = @{ $grid{$id}{bs}    };
    @be    = @{ $grid{$id}{be}    };
    @us    = @{ $grid{$id}{us}    };
    @ds    = @{ $grid{$id}{ds}    };
    @dlx   = @{ $grid{$id}{dlx}   };
    @kb    = @{ $grid{$id}{kb}    };
    @el    = @{ $grid{$id}{el}    };
    @slope = @{ $grid{$id}{slope} };

    if (defined($gr_props{$id}{xdist}) && defined($gr_props{$id}{seglist})) {
        @seglist = @{ $gr_props{$id}{seglist} };
        @seg_wb  = @{ $gr_props{$id}{seg_wb}  };
        @xdist   = @{ $gr_props{$id}{xdist}   };  # saved in units of kilometers
    } else {
        $seg_list   = $props{$id}{seg_list};
        @seg_limits = reverse split(/,|-/, $seg_list);  # reverse the order: ds to us
        @seglist    = ();
        @seg_wb     = ();
        $xdistance  = $last_seg = $last_jb = 0;
        for ($j=0; $j<=$#seg_limits; $j+=2) {
            $seg_dn = $seg_limits[$j];
            $seg_up = $seg_limits[$j+1];
            for ($jb=1; $jb<=$nbr; $jb++) {
                last if ($seg_dn >= $us[$jb] && $seg_dn <= $ds[$jb]);
            }
            for ($jw=1; $jw<=$nwb; $jw++) {
                last if ($jb >= $bs[$jw] && $jb <= $be[$jw]);
            }
            if ($j > 1 && $last_seg != $us[$last_jb]) {
                $xdistance       -= $dlx[$last_seg] /2. *0.001;   # km
                $xdist[$last_seg] = $xdistance;
            }
            for ($i=$seg_dn; $i>=$seg_up; $i--) {
                $xdistance += $dlx[$i] *0.001;    # km
                $xdist[$i]  = $xdistance;
                $seg_wb[$i] = $jw;
                push (@seglist, $i);
            }
            $last_seg = $seg_up;
            $last_jb  = $jb;
        }
        $gr_props{$id}{seglist} = [ @seglist ];
        $gr_props{$id}{seg_wb}  = [ @seg_wb  ];
        $gr_props{$id}{xdist}   = [ @xdist   ];
    }
    $xmult = ($gr_props{$id}{xunits} eq "miles") ? 3280.84/5280. : 1.0;
    $xmin  = $gr_props{$id}{xmin};
    $xbase = $gr_props{$id}{xbase};
    if ($gr_props{$id}{xmax_auto}) {
        $xdistance = &round_to_int(1000.*$xdist[$seglist[$#seglist]] *$xmult)/1000.;
        $gr_props{$id}{xmax} = $xmax = $xbase +$xdistance;
    } else {
        $xmax = $gr_props{$id}{xmax};
    }
    $gr_props{$id}{x_km} = $xdist[$seglist[$#seglist]];

#   Update the Y axis exaggeration factor, using meters for Y units
    $mult  = ($gr_props{$id}{yunits} eq "feet") ? 3.28084 : 1.0;
    $ymin  = $gr_props{$id}{ymin} /$mult;
    $ymax  = $gr_props{$id}{ymax} /$mult;
    $yexag = abs( (($xmax -$xmin) /$xmult  /($x2-$x1))
                 /(($ymax -$ymin) /1000.   /($y2-$y1)));
    $props{$id}{yexag_fac} = sprintf("%.4f", $yexag);

#   Plot X axis
    if ($gr_props{$id}{stype} ne "replace") {
        $axis_props{min}     = $xmin;
        $axis_props{max}     = $xmax;
        $axis_props{first}   = $gr_props{$id}{xfirst};
        $axis_props{major}   = $gr_props{$id}{xmajor};
        $axis_props{pr_tics} = $gr_props{$id}{xpr_tics};
        $axis_props{op_tics} = $gr_props{$id}{xop_tics};
        $axis_props{minor}   = 1;
        $axis_props{reverse} = 0;
        $axis_props{title}   = $gr_props{$id}{xtitle};
        $axis_props{font}    = $gr_props{$id}{xfont};
        $axis_props{size1}   = $gr_props{$id}{xl_size};
        $axis_props{size2}   = $gr_props{$id}{xt_size};
        $axis_props{weight1} = $gr_props{$id}{xl_weight};
        $axis_props{weight2} = $gr_props{$id}{xt_weight};
        $axis_props{side}    = "bottom";
        $axis_props{tags}    = $gtag . " " . $gtag . "_xaxis";
        $axis_props{coords}  = ($gr_props{$id}{xflip}) ? [$x2, $y2, $x1, $y2] : [$x1, $y2, $x2, $y2];
        $axis_props{op_loc}  = $y1;
        &make_axis($canv, %axis_props);
        undef %axis_props;
    }
    if ($gr_props{$id}{stype} ne "none") {
        $axis_props{base}     = $xbase /$xmult;           # convert to km
        $axis_props{min}      = $xmin  /$xmult;           # convert to km
        $axis_props{max}      = $xmax  /$xmult;           # convert to km
        $axis_props{dist}     = $gr_props{$id}{xdist};    # distance array in km
        $axis_props{seglist}  = $gr_props{$id}{seglist};  # list of segments, from ds to us
        $axis_props{type}     = $gr_props{$id}{stype};
        $axis_props{major}    = $gr_props{$id}{smajor};
        $axis_props{pr_tics}  = $gr_props{$id}{spr_tics};
        $axis_props{op_tics}  = $gr_props{$id}{sop_tics};
        $axis_props{title}    = $gr_props{$id}{stitle};
        $axis_props{font}     = $gr_props{$id}{sfont};
        $axis_props{size1}    = $gr_props{$id}{sl_size};
        $axis_props{size2}    = $gr_props{$id}{st_size};
        $axis_props{weight1}  = $gr_props{$id}{sl_weight};
        $axis_props{weight2}  = $gr_props{$id}{st_weight};
        $axis_props{tic_loc}  = $gr_props{$id}{stic_loc};
        $axis_props{grid}     = $gr_props{$id}{sgrid};
        $axis_props{gridcol}  = $gr_props{$id}{sgrid_col};
        $axis_props{bgrid}    = $gr_props{$id}{bgrid};
        $axis_props{bgridcol} = $gr_props{$id}{bgrid_col};
        $axis_props{grcoord}  = [$y1, $y2];
        $axis_props{side}     = "bottom";
        $axis_props{tags}     = $gtag . " " . $gtag . "_saxis";
        $axis_props{coords}   = ($gr_props{$id}{xflip}) ? [$x2, $y2, $x1, $y2] : [$x1, $y2, $x2, $y2];
        $axis_props{op_loc}   = $y1;
        &make_seg_axis($canv, %axis_props);
        undef %axis_props;
    }

#   Refresh the Graph Properties menu and Object Information box, if present
    if ($refresh_menus) {
        if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
            if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
                $tabid = $grprops_notebook->index('current');
                $geom  = $graph_props_menu->g_wm_geometry();
                (undef, $X, $Y) = split(/\+/, $geom);
                &edit_graph_props($id, $X, $Y, $tabid);
            }
        }
        if (defined($object_infobox) && Tkx::winfo_exists($object_infobox)) {
            if ($object_infobox->g_wm_title() =~ /Object Info/) {
                $geom = $object_infobox->g_wm_geometry();
                (undef, $X, $Y) = split(/\+/, $geom);
                &show_info($canv, $id, $X, $Y);
            }
        }
    }

#   Check for a full complement of images; otherwise, regenerate all.
    if (! $gr_props{$id}{redraw}) {
        %slice_img = %{ $gr_props{$id}{slice_img} };
        @img_keys  = keys %slice_img;
        if ($#mydates != $#img_keys) {
            $gr_props{$id}{redraw} = 1;
            $canv->delete($gtag . "_noData");
            $canv->delete($gtag . "_colorMap");
        }
    }
    $gr_props{$id}{xflip_img} = 0 if ($gr_props{$id}{redraw});

#   Don't recompute and redraw unless necessary
    if (! $gr_props{$id}{redraw}) {
        $canv->lower($gtag . "_colorKey",      $id);
        $canv->lower($gtag . "_colorKeyTitle", $id);
        $canv->lower($gtag . "_date",          $id);
        $canv->lower($gtag . "_gtitle",        $id);
        $canv->lower($gtag . "_xaxisTitle",    $id);
        $canv->lower($gtag . "_saxisTitle",    $id);
        $canv->lower($gtag . "_yaxisTitle",    $id);
        $canv->lower($gtag . "_sgrid",         $id);
        $canv->lower($gtag . "_noData",        $id);
        $canv->lower($gtag . "_colorMap",      $id);
        $canv->lower($gtag . "_xaxis",         $id);
        $canv->lower($gtag . "_saxis",         $id);
        $canv->lower($gtag . "_yaxis",         $id);
        if ($group_tags) {
            foreach $tag (@grp_tags) {
                $canv->addtag($tag, withtag => $gtag);
            }
        }
        if ($gr_props{$id}{xflip_img}) {         # Flip existing images
            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $#mydates,
                                        "Flipping slice images...");
            $status_line = "Flipping slice images:  Date = 1";
            $img = Imager->new;
            for ($indx=0; $indx<=$#mydates; $indx++) {
                $mydt = $mydates[$indx];
                &update_progress_bar($pbar, $indx, $mydt);
                $img_data = $slice_img{$mydt}->data(-format => 'png');
                $img->read(data => $img_data);
                $img->flip(dir => "h");
                $img->write(data => \$img_data, type => 'png');
                $slice_img{$mydt}->put($img_data, -format => 'png');
            }
            if (&list_match($dt, @mydates) == -1 || ! defined($slice_img{$dt})) {
                $dt  = $mydates[0];
                $dti = 1 + &nearest_dt_index($dt, @dates);
                $dti++ if ($dti == 0);
                $dti_old = $dti;
            }
            $canv->itemconfigure($gtag . "_colorMap", -image => $slice_img{$dt});
            &destroy_progress_bar($main, $pbar_window);
            $status_line = "Flipping slice images:  Done";
            Tkx::update_idletasks();
            $gr_props{$id}{xflip_img} = 0;
            $gr_props{$id}{slice_img} = { %slice_img };
        }
        undef %slice_img;
        return;
    }

#   Create a progress bar
    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $geom = sprintf("+%d+%d", $X+($x1+$x2)/2-150, $Y+($y1+$y2)/2);

    $pbar_window = $main->new_toplevel();
    $pbar_window->g_wm_transient($main);
    $pbar_window->g_wm_title("Creating colormap slices...");
    $pbar_window->g_wm_geometry($geom);
    $pbar_window->configure(-cursor => $cursor_wait);
    $pbar_window->g_focus;
    $pbar_window->g_bind('<Destroy>' => sub { $stop_processing = 1;
                                              $pbar_window->g_grab_release();
                                              $pbar_window->g_bind('<Destroy>' => "");
                                              Tkx::update_idletasks();
                                            });

    ($pbar_frame = $pbar_window->new_frame(
                    -borderwidth => 2,
                    -relief      => 'groove',
                    ))->g_pack(-anchor => 'nw', -expand => 1, -fill => 'x');
    ($pbar1 = $pbar_frame->new_ttk__progressbar(
                    -orient  => 'horizontal',
                    -length  => 300,
                    -mode    => 'determinate',
                    -value   => 0,
                    -maximum => $#mydates,
                    ))->g_grid(-row => 0, -column => 0);
    ($pbar2 = $pbar_frame->new_ttk__progressbar(
                    -orient  => 'horizontal',
                    -length  => 300,
                    -mode    => 'determinate',
                    -value   => 0,
                    -maximum => $#seglist,
                    ))->g_grid(-row => 1, -column => 0);
    $pbar_frame->new_button(
                    -text    => "Cancel",
                    -font    => 'default',
                    -cursor  => $cursor_select,
                    -command => sub { $stop_processing = 1; },
                    )->g_grid(-row => 1, -column => 1);

#   Move mouse cursor on first creation, to ensure that it changes to cursor_wait
    if ($move_mcursor) {
        if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
            $canv->g_bind("<Motion>", "");
            Tkx::event_generate($main, "<Motion>", -warp => 1, -x => ($x1+$x2)/2, -y => ($y1+$y2)/2);
            $canv->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"), $canv, "menu" ]);
        }
    }

#   Prepare the application to appear busy.
    $status_line = "Creating colormap slices:  Date = 1";
    $canv->configure(-cursor => $cursor_wait);
    $main->configure(-cursor => $cursor_wait);
    $pbar_window->g_focus;
    $pbar_window->g_grab_set();
    Tkx::update();
    Tkx::wm_resizable($pbar_window,0,0);

#   Create a placeholder image
    $iw = $x2 -$x1 +1;
    $ih = $y2 -$y1 +1;
    undef %slice_img;
    %slice_img = ();
    $img = Tkx::image_create_photo(-width => $iw, -height => $ih);
    $img = Tkx::widget->new($img);
    $canv->create_image($x1, $y1, -anchor => 'nw',
                                  -image  => $img,
                                  -tags   => $gtag . " " . $gtag . "_colorMap");

#   Loop over the dates
    $xrange = $xmax -$xmin;   # user units (miles or kilometers)
    $yrange = $ymax -$ymin;   # meters
    $stop_processing = 0;
    for ($indx=0; $indx<=$#mydates; $indx++) {
        $mydt = $mydates[$indx];
        if ($src_type =~ /Vector/i) {
            @ktwb  = @{ $sdata{$mydt}{kt}        };
            @cus   = @{ $sdata{$mydt}{cus}       };
            @elws  = @{ $sdata{$mydt}{elws}      };
            @pdata = @{ $sdata{$mydt}{parm_data} };
        }

#       Reset the progress bars
        $nsegs = 0;
        $pbar1->configure(-value => $indx);
        $pbar2->configure(-value => $nsegs);
        $status_line =~ s/  Date = \d+$/  Date = $mydt/;
        Tkx::update();
        last if ($stop_processing);

#       Create an image to hold the colormap and recognize its methods
        $slice_image = Tkx::image_create_photo(-width => $iw, -height => $ih);
        $slice_image = Tkx::widget->new($slice_image);

#       Loop over the segment list
        $last_jw = 0;
        for ($ns=0; $ns<=$#seglist; $ns++) {
            $nsegs++;
            $i  = $seglist[$ns];
            $jw = $seg_wb[$i];
            if ($src_type =~ /Contour/i) {
                if ($ns == 0 || $jw != $last_jw) {
                    $n     = &list_match($jw, @wbs);
                    %sdata = %{ $slice_data[$n] };
                    if (defined($sdata{$mydt})) {
                        $kt    = $sdata{$mydt}{kt};
                        @cus   = @{ $sdata{$mydt}{cus}       };
                        @elws  = @{ $sdata{$mydt}{elws}      };
                        @pdata = @{ $sdata{$mydt}{parm_data} };
                    }
                    $last_jw = $jw;
                }
            } elsif ($src_type =~ /Vector/i) {
                $kt = $ktwb[$jw];
            }
            $pbar2->configure(-value => $nsegs);
            Tkx::update_idletasks();
            next if (! defined($sdata{$mydt}));

#           Check for segment upstream of current upstream segment
            for ($jb=$bs[$jw]; $jb<=$be[$jw]; $jb++) {
                last if ($i >= $us[$jb] && $i <= $ds[$jb]);
            }
            next if (! defined($cus[$jb]) || $i < $cus[$jb]);

#           X limits
            $xd1 = ($ns == 0) ? 0 : $xdist[$seglist[$ns-1]] *$xmult;
            $xd2 = $xdist[$i] *$xmult;
            if ($gr_props{$id}{xflip}) {
                $xp1 = &round_to_int(($iw-1)*(1.-($xd1 +$xbase -$xmin)/$xrange));
                $xp2 = &round_to_int(($iw-1)*(1.-($xd2 +$xbase -$xmin)/$xrange));
                next if ($xp2 > $iw-1);
                last if ($xp1 < 0);
            } else {
                $xp1 = &round_to_int(($iw-1)*($xd1 +$xbase -$xmin)/$xrange);
                $xp2 = &round_to_int(($iw-1)*($xd2 +$xbase -$xmin)/$xrange);
                next if ($xp2 < 0);
                last if ($xp1 > $iw-1);
            }
            $xp1 = &max(0, &min($iw-1, $xp1));
            $xp2 = &max(0, &min($iw-1, $xp2));
            next if ($xp1 == $xp2 && $ns < $#seglist);

#           Cycle through the layers and add to the color map
            $surf_elev = $elws[$i];
            $yp2 = $yp4 = $yp4i = $pval4 = $j4 = 0;

#           Depth plots or zero-slope plots
            if ($gr_props{$id}{ytype} eq "Depth" || $slope[$jb] == 0.0) {

#               By Layer option
                if ($gr_props{$id}{pc_style} =~ /by layer/i || $kt >= $kb[$i]) {
                    if ($gr_props{$id}{ytype} ne "Depth") {
                        $yp2 = &round_to_int(($ih-1)*(1.-($surf_elev-$ymin)/$yrange));
                        $yp2 = &max(0, &min($ih-1, $yp2));
                    }
                    for ($k=$kt; $k<$kmx; $k++) {
                        $yp1  = $yp2;
                        last if ($yp1 >= $ih-1);
                        $kalt = ($k > $kb[$i]) ? $kb[$i] : $k;
                        if ($gr_props{$id}{ytype} eq "Depth") {
                            $yp2 = &round_to_int(($ih-1)*($surf_elev-$el[$kalt+1][$i])/$ymax);
                        } else {
                            $yp2 = &round_to_int(($ih-1)*(1.-($el[$kalt+1][$i]-$ymin)/$yrange));
                        }
                        if ($yp2 < 0) {
                            $yp2 = 0;
                            next;
                        }
                        $yp2 = &min($ih-1, $yp2);
                        next if ($yp1 == $yp2 && $k < $kb[$i]);
                        if (defined($pdata[$k][$i])) {
                            $pval = $pdata[$k][$i];
                            $pval = $pval *1.8 +32 if ($props{$id}{parm}       eq "Temperature" &&
                                                       $props{$id}{parm_units} eq "Fahrenheit");
                            $j    = &max(0, &min($#colors, int(($#colors+1) *($pval-$cs_min)/$cs_range)));
                            $slice_image = &image_put_color($slice_image, $colors[$j],
                                                            $xp1, $yp1, $xp2, $yp2);
                        }
                        last if ($yp2 >= $ih-1);
                        last if ($k >= $kb[$i]);   # ensures once-through, for kt > kb[i]
                    }

#               Max Interpolation option
                } elsif ($gr_props{$id}{pc_style} =~ /max interp/i) {
                    if ($gr_props{$id}{ytype} ne "Depth") {
                        $yp2 = ($ih-1)*(1.-($surf_elev-$ymin)/$yrange);
                    }
                    $yp1i = &max(0, &min($ih-1, &round_to_int($yp2)));
                    for ($k=$kt; $k<$kmx; $k++) {
                        $yp1   = $yp2;
                        $yp3   = $yp4;
                        $yp3i  = $yp4i;
                        $pval3 = $pval4;
                        $j3    = $j4;
                        last if ($k == $kt && $yp1 >= $ih-1);
                        last if ($k >  $kt && $yp3 >= $ih-1);
                        $kalt  = ($k > $kb[$i]) ? $kb[$i] : $k;
                        if ($gr_props{$id}{ytype} eq "Depth") {
                            $yp2 = ($ih-1)*($surf_elev-$el[$kalt+1][$i])/$ymax;
                        } else {
                            $yp2 = ($ih-1)*(1.-($el[$kalt+1][$i]-$ymin)/$yrange);
                        }
                        if (defined($pdata[$k][$i])) {
                            $pval4 = $pdata[$k][$i];
                            $pval4 = $pval4 *1.8 +32 if ($props{$id}{parm}       eq "Temperature" &&
                                                         $props{$id}{parm_units} eq "Fahrenheit");
                            $j4    = &max(0, &min($#colors, int(($#colors+1) *($pval4-$cs_min)/$cs_range)));
                        }
                        $yp4  = 0.5*($yp1+$yp2);
                        $yp4i = &max(0, &min($ih-1, &round_to_int($yp4)));
                        next if (&round_to_int($yp4) < 0);
                        if ($k==$kt) {
                            if (defined($pdata[$k][$i])) {
                                $slice_image = &image_put_color($slice_image, $colors[$j4],
                                                                $xp1, $yp1i, $xp2, $yp4i);
                            }
                            last if ($yp4i >= $ih-1);
                        } else {
                            if ($j4 == $j3) {
                                if (defined($pdata[$k][$i])) {
                                    $slice_image = &image_put_color($slice_image, $colors[$j4],
                                                                    $xp1, $yp3i, $xp2, $yp4i);
                                }
                            } else {
                                if (defined($pdata[$k][$i]) && defined($pdata[$k-1][$i])) {
                                    $jj = ($j3 < $j4) ? 1 : -1;
                                    for ($j=$j3*$jj; $j<=$j4*$jj; $j++) {
                                        $pval = ($j3 < $j4) ? $scale[$j+1] : $scale[$j*$jj];
                                        $yp   = $yp3 +($yp4-$yp3)*($pval-$pval3)/($pval4-$pval3);
                                        $yp   = &max($yp3, &min($yp4, $yp));
                                        next if (&round_to_int($yp) < 0);
                                        $ypi  = &max(0, &min($ih-1, &round_to_int($yp)));
                                        $slice_image = &image_put_color($slice_image, $colors[$j*$jj],
                                                                        $xp1, $yp3i, $xp2, $ypi);
                                        $yp3i = $ypi;
                                        last if ($yp >= $ih-1);
                                    }
                                    $yp4i = $yp3i;
                                }
                            }
                        }
                        if ($k >= $kb[$i]) {
                            $yp2 = &round_to_int($yp2);
                            last if ($yp2 < 0);
                            $yp2 = &min($ih-1, $yp2);
                            if (defined($pdata[$k][$i])) {
                                $slice_image = &image_put_color($slice_image, $colors[$j4],
                                                                $xp1, $yp4i, $xp2, $yp2);
                            }
                        }
                        last if ($k >= $kb[$i]);   # ensures once-through, for kt > kb[i]
                    }

#               Interpolation option
                } else {
                    if ($gr_props{$id}{ytype} ne "Depth") {
                        $yp2 = ($ih-1)*(1.-($surf_elev-$ymin)/$yrange);
                    }
                    for ($k=$kt; $k<$kmx; $k++) {
                        $yp1  = $yp2;
                        $yp3  = $yp4;
                        $kalt = ($k > $kb[$i]) ? $kb[$i] : $k;
                        if ($gr_props{$id}{ytype} eq "Depth") {
                            $yp2 = ($ih-1)*($surf_elev-$el[$kalt+1][$i])/$ymax;
                        } else {
                            $yp2 = ($ih-1)*(1.-($el[$kalt+1][$i]-$ymin)/$yrange);
                        }
                        if (defined($pdata[$k][$i])) {
                            $pval = $pdata[$k][$i];
                            $pval = $pval *1.8 +32 if ($props{$id}{parm}       eq "Temperature" &&
                                                       $props{$id}{parm_units} eq "Fahrenheit");
                            $j    = &max(0, &min($#colors, int(($#colors+1) *($pval-$cs_min)/$cs_range)));
                        }
                        if ($k==$kt) {
                            $yp4 = &round_to_int(0.25*$yp1 +0.75*$yp2);
                            $yp1 = &round_to_int($yp1);
                            last if ($yp1 >= $ih-1);
                            if ($yp4 < 0) {
                                $yp4 = 0;
                                next;
                            }
                            $yp4 = &min($ih-1, $yp4);
                            if (defined($pdata[$k][$i])) {
                                $slice_image = &image_put_color($slice_image, $colors[$j],
                                                                $xp1, $yp1, $xp2, $yp4);
                            }
                        } else {
                            $yp4 = &round_to_int(0.75*$yp1 +0.25*$yp2);
                            if ($yp4 < 0) {
                                $yp4 = 0;
                                next;
                            }
                            $yp4 = &min($ih-1, $yp4);
                            if (defined($pdata[$k][$i]) && defined($pdata[$k-1][$i])) {
                                $pval = 0.5*($pdata[$k][$i] +$pdata[$k-1][$i]);
                                $pval = $pval *1.8 +32 if ($props{$id}{parm}       eq "Temperature" &&
                                                           $props{$id}{parm_units} eq "Fahrenheit");
                                $j2   = &max(0, &min($#colors, int(($#colors+1) *($pval-$cs_min)/$cs_range)));
                                $slice_image = &image_put_color($slice_image, $colors[$j2],
                                                                $xp1, $yp3, $xp2, $yp4);
                            }
                            last if ($yp4 >= $ih-1);
                            $yp3 = $yp4;
                            $yp4 = &round_to_int(0.25*$yp1 +0.75*$yp2);
                            if ($yp4 < 0) {
                                $yp4 = 0;
                                next;
                            }
                            $yp4 = &min($ih-1, $yp4);
                            if (defined($pdata[$k][$i])) {
                                $slice_image = &image_put_color($slice_image, $colors[$j],
                                                                $xp1, $yp3, $xp2, $yp4);
                            }
                        }
                        last if ($yp4 >= $ih-1);
                        if ($k >= $kb[$i]) {
                            $yp2 = &round_to_int($yp2);
                            last if ($yp2 < 0);
                            $yp2 = &min($ih-1, $yp2);
                            if (defined($pdata[$k][$i])) {
                                $slice_image = &image_put_color($slice_image, $colors[$j],
                                                                $xp1, $yp4, $xp2, $yp2);
                            }
                        }
                        last if ($k >= $kb[$i]);   # ensures once-through, for kt > kb[i]
                    }
                }

#           Sloped elevation plots
            } else {
                $yp2 = ($ih-1)*(1.-($surf_elev-$ymin)/$yrange);
                if ($ns < $#seglist && $i != $us[$jb] && $seglist[$ns+1] != $i-1) {
                    $dy_full = ($ih-1)*$slope[$jb]*0.5*$dlx[$i]/$yrange;
                } else {
                    $dy_full = ($ih-1)*$slope[$jb]*$dlx[$i]/$yrange;
                }

#               By Layer option
                if ($gr_props{$id}{pc_style} =~ /by layer/i || $kt >= $kb[$i]) {
                    for ($k=$kt; $k<$kmx; $k++) {
                        $yp1  = $yp2;
                        $kalt = ($k > $kb[$i]) ? $kb[$i] : $k;
                        $yp2  = ($ih-1)*(1.-($el[$kalt+1][$i]-$ymin)/$yrange);
                        last if (&round_to_int($yp1-0.5*$dy_full) >= $ih-1);
                        if (&round_to_int($yp2+0.5*$dy_full) < 0) {
                            $yp2 = 0;
                            next;
                        }
                        if (defined($pdata[$k][$i])) {
                            $pval = $pdata[$k][$i];
                            $pval = $pval *1.8 +32 if ($props{$id}{parm}       eq "Temperature" &&
                                                       $props{$id}{parm_units} eq "Fahrenheit");
                            $j    = &max(0, &min($#colors, int(($#colors+1) *($pval-$cs_min)/$cs_range)));
                            $slice_image = &paint_slice_cell($slice_image, $colors[$j], $ih,
                                                             $dy_full, $gr_props{$id}{xflip},
                                                             $xp1, $yp1, $xp2, $yp2);
                        }
                        last if ($k >= $kb[$i]);   # ensures once-through, for kt > kb[i]
                    }

#               Max Interpolation option
                } elsif ($gr_props{$id}{pc_style} =~ /max interp/i) {
                    for ($k=$kt; $k<$kmx; $k++) {
                        $yp1   = $yp2;
                        $yp3   = $yp4;
                        last if ($k == $kt && &round_to_int($yp1-0.5*$dy_full) >= $ih-1);
                        last if ($k >  $kt && &round_to_int($yp3-0.5*$dy_full) >= $ih-1);
                        $pval3 = $pval4;
                        $j3    = $j4;
                        $kalt  = ($k > $kb[$i]) ? $kb[$i] : $k;
                        $yp2   = ($ih-1)*(1.-($el[$kalt+1][$i]-$ymin)/$yrange);
                        if (defined($pdata[$k][$i])) {
                            $pval4 = $pdata[$k][$i];
                            $pval4 = $pval4 *1.8 +32 if ($props{$id}{parm}       eq "Temperature" &&
                                                         $props{$id}{parm_units} eq "Fahrenheit");
                            $j4    = &max(0, &min($#colors, int(($#colors+1) *($pval4-$cs_min)/$cs_range)));
                        }
                        $yp4 = 0.5*($yp1+$yp2);
                        next if (&round_to_int($yp4+0.5*$dy_full) < 0);
                        if ($k==$kt) {
                            if (defined($pdata[$k][$i])) {
                                $slice_image = &paint_slice_cell($slice_image, $colors[$j4], $ih,
                                                                 $dy_full, $gr_props{$id}{xflip},
                                                                 $xp1, $yp1, $xp2, $yp4);
                            }
                        } else {
                            if ($j4 == $j3) {
                                if (defined($pdata[$k][$i])) {
                                    $slice_image = &paint_slice_cell($slice_image, $colors[$j4], $ih,
                                                                     $dy_full, $gr_props{$id}{xflip},
                                                                     $xp1, $yp3, $xp2, $yp4);
                                }
                            } else {
                                if (defined($pdata[$k][$i]) && defined($pdata[$k-1][$i])) {
                                    $yp3o = $yp3;
                                    $jj   = ($j3 < $j4) ? 1 : -1;
                                    for ($j=$j3*$jj; $j<=$j4*$jj; $j++) {
                                        $pval = ($j3 < $j4) ? $scale[$j+1] : $scale[$j*$jj];
                                        $yp   = $yp3 +($yp4-$yp3)*($pval-$pval3)/($pval4-$pval3);
                                        $yp   = &max($yp3, &min($yp4, $yp));
                                        next if (&round_to_int($yp+0.5*$dy_full) < 0);
                                        $slice_image = &paint_slice_cell($slice_image, $colors[$j*$jj], $ih,
                                                                         $dy_full, $gr_props{$id}{xflip},
                                                                         $xp1, $yp3o, $xp2, $yp);
                                        $yp3o = $yp;
                                        last if (&round_to_int($yp-0.5*$dy_full) >= $ih-1);
                                    }
                                    $yp4 = $yp3o;
                                }
                            }
                        }
                        if ($k >= $kb[$i]) {
                            last if (&round_to_int($yp2+0.5*$dy_full) < 0);
                            if (defined($pdata[$k][$i])) {
                                $slice_image = &paint_slice_cell($slice_image, $colors[$j4], $ih,
                                                                 $dy_full, $gr_props{$id}{xflip},
                                                                 $xp1, $yp4, $xp2, $yp2);
                            }
                        }
                        last if ($k >= $kb[$i]);   # ensures once-through, for kt > kb[i]
                    }

#               Interpolation option
                } else {
                    for ($k=$kt; $k<$kmx; $k++) {
                        $yp1  = $yp2;
                        $yp3  = $yp4;
                        $kalt = ($k > $kb[$i]) ? $kb[$i] : $k;
                        $yp2  = ($ih-1)*(1.-($el[$kalt+1][$i]-$ymin)/$yrange);
                        if (defined($pdata[$k][$i])) {
                            $pval = $pdata[$k][$i];
                            $pval = $pval *1.8 +32 if ($props{$id}{parm}       eq "Temperature" &&
                                                       $props{$id}{parm_units} eq "Fahrenheit");
                            $j    = &max(0, &min($#colors, int(($#colors+1) *($pval-$cs_min)/$cs_range)));
                        }
                        if ($k==$kt) {
                            $yp4 = 0.25*$yp1 +0.75*$yp2;
                            last if (&round_to_int($yp1-0.5*$dy_full) >= $ih-1);
                            if (&round_to_int($yp4+0.5*$dy_full) < 0) {
                                $yp4 = 0;
                                next;
                            }
                            if (defined($pdata[$k][$i])) {
                                $slice_image = &paint_slice_cell($slice_image, $colors[$j], $ih,
                                                                 $dy_full, $gr_props{$id}{xflip},
                                                                 $xp1, $yp1, $xp2, $yp4);
                            }
                        } else {
                            $yp4 = 0.75*$yp1 +0.25*$yp2;
                            if (&round_to_int($yp4+0.5*$dy_full) < 0) {
                                $yp4 = 0;
                                next;
                            }
                            if (defined($pdata[$k][$i]) && defined($pdata[$k-1][$i])) {
                                $pval = 0.5*($pdata[$k][$i] +$pdata[$k-1][$i]);
                                $pval = $pval *1.8 +32 if ($props{$id}{parm}       eq "Temperature" &&
                                                           $props{$id}{parm_units} eq "Fahrenheit");
                                $j2   = &max(0, &min($#colors, int(($#colors+1) *($pval-$cs_min)/$cs_range)));
                                $slice_image = &paint_slice_cell($slice_image, $colors[$j2], $ih,
                                                                 $dy_full, $gr_props{$id}{xflip},
                                                                 $xp1, $yp3, $xp2, $yp4);
                            }
                            last if (&round_to_int($yp4-0.5*$dy_full) >= $ih-1);
                            $yp3 = $yp4;
                            $yp4 = 0.25*$yp1 +0.75*$yp2;
                            if (&round_to_int($yp4+0.5*$dy_full) < 0) {
                                $yp4 = 0;
                                next;
                            }
                            if (defined($pdata[$k][$i])) {
                                $slice_image = &paint_slice_cell($slice_image, $colors[$j], $ih,
                                                                 $dy_full, $gr_props{$id}{xflip},
                                                                 $xp1, $yp3, $xp2, $yp4);
                            }
                        }
                        last if (&round_to_int($yp4-0.5*$dy_full) >= $ih-1);
                        if ($k >= $kb[$i]) {
                            last if (&round_to_int($yp2+0.5*$dy_full) < 0 && &round_to_int($yp2) < 0);
                            if (defined($pdata[$k][$i])) {
                                $slice_image = &paint_slice_cell($slice_image, $colors[$j], $ih,
                                                                 $dy_full, $gr_props{$id}{xflip},
                                                                 $xp1, $yp4, $xp2, $yp2);
                            }
                        }
                        last if ($k >= $kb[$i]);   # ensures once-through, for kt > kb[i]
                    }
                }
            }
        }
        $slice_img{$mydt} = $slice_image;
        $canv->itemconfigure($date_id, -text => &get_formatted_date($mydt));
        $canv->itemconfigure($gtag . "_colorMap", -image => $slice_img{$mydt});
        undef $slice_image;
    }
    if ($indx > 0 || $stop_processing) {
        if (&list_match($dt, @mydates) == -1 || ! defined($slice_img{$dt})) {
            $dt  = $mydates[0];
            $dti = 1 + &nearest_dt_index($dt, @dates);
            $dti++ if ($dti == 0);
            $dti_old = $dti;
            &update_animate(&get_formatted_date($dates[$dti-1]));
          # $canv->delete($gtag . "_noData");
        }
        $canv->itemconfigure($date_id, -text => &get_formatted_date($dt));
        $canv->itemconfigure($gtag . "_colorMap", -image => $slice_img{$dt});
    }

#   Place the graphic items in the proper order
    &raise_lower($canv, $id, "tiptop") if ($new_graph);
    $canv->lower($gtag . "_colorKey",      $id);
    $canv->lower($gtag . "_colorKeyTitle", $id);
    $canv->lower($gtag . "_date",          $id);
    $canv->lower($gtag . "_gtitle",        $id);
    $canv->lower($gtag . "_xaxisTitle",    $id);
    $canv->lower($gtag . "_saxisTitle",    $id);
    $canv->lower($gtag . "_yaxisTitle",    $id);
    $canv->lower($gtag . "_sgrid",         $id);
    $canv->lower($gtag . "_noData",        $id);
    $canv->lower($gtag . "_colorMap",      $id);
    $canv->lower($gtag . "_xaxis",         $id);
    $canv->lower($gtag . "_saxis",         $id);
    $canv->lower($gtag . "_yaxis",         $id);
    if ($group_tags) {
        foreach $tag (@grp_tags) {
            $canv->addtag($tag, withtag => $gtag);
        }
    }

#   Update any links
#xxx &update_links($canv, $id, $dt);

#   Remove progress bar and unset the busy status.
    if (defined($pbar_window) && Tkx::winfo_exists($pbar_window)) {
        $pbar_window->g_grab_release();
        $pbar_window->g_bind('<Destroy>' => "");
        $pbar_window->g_destroy();
    }
    $canv->configure(-cursor => $cursor_norm);
    $main->configure(-cursor => $cursor_norm);
    if ($stop_processing) {
        $status_line =~ s/  Date = \d+$/  Processing stopped./;
    } else {
        $status_line =~ s/  Date = \d+$/  Processing completed./;
    }
    $gr_props{$id}{slice_img} = { %slice_img };
    undef %slice_img;
}


sub setup_w2_tdmap_part2 {
    my ($canv, $id, $X, $Y) = @_;
    my (
        $flowtemp_file, $fr, $frame, $frame2, $geom, $jw, $n, $nbr,
        $ok_btn, $oldsrc_type, $row, $sc_canv, $sc_fr, $src_btn, $src_file,
        $src_label1, $src_label2, $src_lines, $src_text, $src_type,
        $src_type_cb, $surftemp_file, $txt, $voltemp_file, $vscroll,
        $w2l_file,

        @brs, @bth_files, @cbtn, @clab1, @clab2, @cpl_files, @cpl_lines,
        @ds, @f, @frv, @frv_label, @parmlist, @rbtn, @riv_files, @riv_freq,
        @riv_lines, @frv_on, @riv_parm, @src_parms, @tecplot, @td_filetypes,
        @us, @wbs,
       );

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($w2tdmap_setup_menu) && Tkx::winfo_exists($w2tdmap_setup_menu)) {
        if ($w2tdmap_setup_menu->g_wm_title() eq "W2 Time/Distance Map Setup") {
            $w2tdmap_setup_menu->g_destroy();
            undef $w2tdmap_setup_menu;
        }
    }
    $w2tdmap_setup_menu = $main->new_toplevel();
    $w2tdmap_setup_menu->g_wm_transient($main);
    $w2tdmap_setup_menu->g_wm_title("W2 Time/Distance Map Setup");
    $w2tdmap_setup_menu->configure(-cursor => $cursor_norm);
    $w2tdmap_setup_menu->g_wm_geometry($geom);

#   Try to keep the nascent graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

    @wbs = split(/,/, $props{$id}{wb_list});
    @brs = sort numerically split(/,/, $props{$id}{br_list});
    @us  = @{ $grid{$id}{us} };
    @ds  = @{ $grid{$id}{ds} };
    $nbr = $grid{$id}{nbr};

    @cpl_files    = @cpl_lines = @tecplot = @bth_files = @riv_files = @riv_lines = @riv_freq = ();
    @parmlist     = @src_parms = ();
    $src_type     = "W2 Contour File";
    $src_text     = $src_type . ": ";
    $src_file     = "";
    $src_lines    = 0;
    $oldsrc_type  = $src_type;
    $w2l_file     = $surftemp_file = $voltemp_file = $flowtemp_file = "";
    @td_filetypes = ("W2 Contour File",  "W2 Vector File", "W2 RiverCon File",
                     "W2 SurfTemp File", "W2 VolTemp File", "W2 FlowTemp File");
    for ($n=0; $n<=$#wbs; $n++) {
        $cpl_files[$n] = "          ";
        $bth_files[$n] = "";
    }
    for ($n=0; $n<=$#brs; $n++) {
        $riv_files[$n] = "          ";
    }

#   Set up the menu
    $frame = $w2tdmap_setup_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -state   => 'disabled',
            -command => sub { my ($br_list, $i, $j, $jw1, $jw2, $label, $mismatch, $n, $parm, $rfreq,
                                  @cpld, @cplf, @ncpl, @parm_tmp, @plist, @tmp_files, @tmp_lines, @vals,
                                  %parms);
                              if ($src_type =~ /Contour/i) {
                                  for ($n=0; $n<=$#wbs; $n++) {
                                      if ($cpl_files[$n] eq "" || $cpl_files[$n] eq "          "
                                                               || ! -e $cpl_files[$n]) {
                                          return &pop_up_error($w2tdmap_setup_menu,
                                          "W2 Contour file not set or does not exist:\n$cpl_files[$n]");
                                      }
                                  }

#                                 Ensure contour dates and frequencies are identical for all waterbodies
                                  if ($#wbs > 0) {
                                      @ncpl = @{ $grid{$id}{ncpl} };
                                      @cpld = @{ $grid{$id}{cpld} };
                                      @cplf = @{ $grid{$id}{cplf} };
                                      $mismatch = 0;
                                      for ($j=0; $j<=$#wbs; $j++) {
                                          $jw1 = $wbs[$j];
                                          for ($n=$j+1; $n<=$#wbs; $n++) {
                                              $jw2 = $wbs[$n];
                                              if ($ncpl[$jw1] != $ncpl[$jw2]) {
                                                  $mismatch = 1;
                                                  last;
                                              }
                                              for ($i=1; $i<=$ncpl[$jw1]; $i++) {
                                                  if ($cpld[$i][$jw1] != $cpld[$i][$jw2]) {
                                                      $mismatch = 1;
                                                      last;
                                                  }
                                                  if ($cplf[$i][$jw1] eq "na" || $cplf[$i][$jw2] eq "na") {
                                                      if ($cplf[$i][$jw1] ne $cplf[$i][$jw2]) {
                                                          $mismatch = 1;
                                                          last;
                                                      }
                                                  } else {
                                                      if ($cplf[$i][$jw1] != $cplf[$i][$jw2]) {
                                                          $mismatch = 1;
                                                          last;
                                                      }
                                                  }
                                              }
                                              last if ($mismatch);
                                          }
                                          last if ($mismatch);
                                      }
                                      if ($mismatch) {
                                          return &pop_up_error($w2tdmap_setup_menu,
                                              "The contour plot output dates and frequencies for\n"
                                            . "the chosen waterbodies do not match. Please try again.");
                                      }
                                  }

#                                 Only keep parameters common to all contour output files
                                  @plist = @{ $parmlist[0] };
                                  for ($n=1; $n<=$#wbs; $n++) {
                                      @parm_tmp = ();
                                      foreach $parm ( @{ $parmlist[$n] } ) {
                                          if (&list_match($parm, @plist) >= 0) {
                                              push (@parm_tmp, $parm);
                                          }
                                      }
                                      @plist = @parm_tmp;
                                  }
                                  if ($#plist < 0) {
                                      return &pop_up_error($w2tdmap_setup_menu,
                                        "No parameters are common to all of the W2 Contour files.");
                                  }
                                  %parms                 = ();
                                  $parms{parms}          = [ @plist     ];
                                  $props{$id}{tecplot}   = [ @tecplot   ];
                                  $props{$id}{cpl_lines} = [ @cpl_lines ];
                                  $props{$id}{cpl_files} = [ @cpl_files ];

                              } elsif ($src_type =~ /RiverCon/i) {
                                  for ($n=0; $n<=$#riv_files; $n++) {
                                      next if (! $frv_on[$n]);
                                      if ($riv_files[$n] eq "" || $riv_files[$n] eq "          "
                                                               || ! -e $riv_files[$n]) {
                                          return &pop_up_error($w2tdmap_setup_menu,
                                          "W2 River Contour file not set or does not exist:\n$riv_files[$n]");
                                      }
                                  }
                                  if ($#brs > 0) {
                                      $parm = "";
                                      for ($n=0; $n<=$#brs; $n++) {
                                          next if (! $frv_on[$n]);
                                          if ($parm eq "") {
                                              $parm = $riv_parm[$n];
                                              next;
                                          }
                                          if ($riv_parm[$n] ne $parm) {
                                              return &pop_up_error($w2tdmap_setup_menu,
                                                "The W2 RiverCon files do not contain the same parameter.");
                                          }
                                      }
                                      $rfreq = -99;
                                      for ($n=0; $n<=$#brs; $n++) {
                                          next if (! $frv_on[$n]);
                                          if ($rfreq == -99) {
                                              $rfreq = $riv_freq[$n];
                                              next;
                                          }
                                          if ($rfreq != $riv_freq[$n]) {
                                              return &pop_up_error($w2tdmap_setup_menu,
                                                  "The W2 RiverCon output frequencies for the\n"
                                                . "chosen branches do not match. Please try again.");
                                          }
                                      }
                                  } else {
                                      $parm  = $riv_parm[0];
                                      $rfreq = $riv_freq[0];
                                  }
                                  @tmp_files = @riv_files;
                                  @tmp_lines = @riv_lines;
                                  @riv_files = @riv_lines = ();
                                  $br_list   = "";
                                  for ($n=0; $n<=$#brs; $n++) {
                                      next if (! $frv_on[$n]);
                                      push (@riv_files, $tmp_files[$n]);
                                      push (@riv_lines, $tmp_lines[$n]);
                                      $label = $frv_label[$n];
                                      if ($label =~ /,/) {
                                          $label =~ s/Branch //;
                                          @vals  = split(/,/, $label);
                                          @vals  = sort numerically @vals;
                                          $br_list .= $vals[0] . ",";
                                      } else {
                                          $br_list .= $brs[$n] . ",";
                                      }
                                  }
                                  $br_list =~ s/,$//;
                                  %parms                 = ();
                                  $parms{riv_freq}       = $rfreq;
                                  $parms{parms}          = [ ($parm)    ];
                                  $props{$id}{riv_lines} = [ @riv_lines ];
                                  $props{$id}{riv_files} = [ @riv_files ];
                                  $props{$id}{br_list}   = $br_list;

                              } else {
                                  if ($src_file eq "" || ! -e $src_file) {
                                      return &pop_up_error($w2tdmap_setup_menu,
                                          $src_type . " not set or does not exist:\n$src_file");
                                  }
                                  if ($src_type =~ /SurfTemp|VolTemp|FlowTemp/i) {
                                      $props{$id}{src_file}  = $src_file;
                                      $props{$id}{src_lines} = $src_lines;
                                  } else {
                                      $props{$id}{w2l_file}  = $src_file;
                                  }
                                  %parms        = ();
                                  $parms{parms} = [ @src_parms ];
                              }

                              for ($n=0; $n<=$#wbs; $n++) {
                                  if ($bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                      return &pop_up_error($w2tdmap_setup_menu,
                                      "W2 Bathymetry file not set or does not exist:\n$bth_files[$n]");
                                  }
                              }
                              $props{$id}{files}     = 1;
                              $props{$id}{parms}     = { %parms };
                              $props{$id}{src_type}  = $src_type;
                              $props{$id}{bth_files} = [ @bth_files ];

                              $geom = $w2tdmap_setup_menu->g_wm_geometry();
                              (undef, $X, $Y) = split(/\+/, $geom);

                              $w2tdmap_setup_menu->g_bind('<Destroy>', "");
                              $w2tdmap_setup_menu->g_destroy();
                              undef $w2tdmap_setup_menu;

                              &setup_w2_tdmap_part3($canv, $id, $X, $Y);
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);

    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $w2tdmap_setup_menu->g_bind('<Destroy>', "");
                              $w2tdmap_setup_menu->g_destroy();
                              undef $w2tdmap_setup_menu;
                              $canv->delete("graph" . $id);
                              delete $props{$id};
                              delete $grid{$id};
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Delete graph if this menu is destroyed by other than the Cancel button
    $w2tdmap_setup_menu->g_bind('<Destroy>' => sub { undef $w2tdmap_setup_menu;
                                                     $canv->delete("graph" . $id);
                                                     delete $props{$id}; 
                                                     delete $grid{$id};
                                                     &reset_bindings;
                                                   });

#   Need a scrollable container, and a canvas is about the only container that works.
#   Create a parent frame (sc_fr) for the canvas (sc_canv) and scrollbar (vscroll).
#   Then put a frame inside the canvas (fr) as a widget window to hold other menu items.
    ($sc_fr = $w2tdmap_setup_menu->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_pack(-side => 'top', -expand => 1, -fill => 'both');
    ($vscroll = $sc_fr->new_scrollbar(
            -orient => 'vertical',
            -width  => 15,
            ))->g_grid(-row => 0, -column => 1, -sticky => 'nse');
    ($sc_canv = $sc_fr->new_tk__canvas(
            -highlightthickness => 0,
            -yscrollcommand => [$vscroll, 'set'],
            ))->g_grid(-row => 0, -column => 0, -sticky => 'nsew');
    $vscroll->configure(-command => [$sc_canv, 'yview']);

    $fr = $sc_canv->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );

#   Source type
    $row = 0;
    $fr->new_label(
            -text => "W2 Source Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($src_type_cb = $fr->new_ttk__combobox(
            -textvariable => \$src_type,
            -values       => [ @td_filetypes ],
            -width        => 17,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $src_type_cb->g_bind("<<ComboboxSelected>>",
                          sub { my ($n, $ok, $status);
                                return if ($src_type eq $oldsrc_type);
                                if ($src_type =~ /Contour/i) {
                                    $src_label1->g_grid_remove();
                                    $src_label2->g_grid_remove();
                                    $src_btn->g_grid_remove();
                                    for ($n=0; $n<=$#wbs; $n++) {
                                        $clab1[$n]->g_grid();
                                        $clab2[$n]->g_grid();
                                        $cbtn[$n]->g_grid();
                                    }
                                    for ($n=0; $n<=$#brs; $n++) {
                                        $frv[$n]->g_grid_remove();
                                    }
                                    $frame2->g_grid() if ($#wbs > 0);
                                    $ok = 1;
                                    for ($n=0; $n<=$#wbs; $n++) {
                                        if ($cpl_files[$n] eq "          " ||
                                            $cpl_files[$n] eq "" || ! -e $cpl_files[$n]) {
                                            $ok = 0;
                                            last;
                                        }
                                    }
                                } elsif ($src_type =~ /RiverCon/i) {
                                    $src_label1->g_grid_remove();
                                    $src_label2->g_grid_remove();
                                    $src_btn->g_grid_remove();
                                    for ($n=0; $n<=$#wbs; $n++) {
                                        $clab1[$n]->g_grid_remove();
                                        $clab2[$n]->g_grid_remove();
                                        $cbtn[$n]->g_grid_remove();
                                    }
                                    for ($n=0; $n<=$#brs; $n++) {
                                        $frv[$n]->g_grid() if ($frv_on[$n]);
                                    }
                                    $frame2->g_grid_remove() if ($#wbs > 0 && $oldsrc_type =~ /Contour/i);
                                    $ok = 1;
                                    for ($n=0; $n<=$#brs; $n++) {
                                        next if (! $frv_on[$n]);
                                        if ($riv_files[$n] eq "          " ||
                                            $riv_files[$n] eq "" || ! -e $riv_files[$n]) {
                                            $ok = 0;
                                            last;
                                        }
                                    }
                                } else {
                                    for ($n=0; $n<=$#wbs; $n++) {
                                        $clab1[$n]->g_grid_remove();
                                        $clab2[$n]->g_grid_remove();
                                        $cbtn[$n]->g_grid_remove();
                                    }
                                    for ($n=0; $n<=$#brs; $n++) {
                                        $frv[$n]->g_grid_remove();
                                    }
                                    $frame2->g_grid_remove() if ($#wbs > 0 && $oldsrc_type =~ /Contour/i);
                                    $src_label1->g_grid();
                                    $src_label2->g_grid();
                                    $src_btn->g_grid();
                                    if ($src_type =~ /SurfTemp/) {
                                        $src_file = $surftemp_file;
                                    } elsif ($src_type =~ /VolTemp/) {
                                        $src_file = $voltemp_file;
                                    } elsif ($src_type =~ /FlowTemp/) {
                                        $src_file = $flowtemp_file;
                                    } elsif ($src_type =~ /Vector/i) {
                                        $src_file = $w2l_file;
                                    }
                                    $ok = ($src_file eq "" || ! -e $src_file) ? 0 : 1;
                                }
                                $oldsrc_type = $src_type;
                                $src_text    = $src_type . ": ";
                                for ($n=0; $n<=$#wbs; $n++) {
                                    if ($bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                        $ok = 0;
                                        last;
                                    }
                                }
                                $status = ($ok) ? 'normal' : 'disabled';
                                $ok_btn->configure(-state => $status);
                                &update_scrollable_menu($w2tdmap_setup_menu, $sc_fr, $sc_canv,
                                                        'scrollable', $vscroll);
                              });
    $fr->new_label(
            -text => "            ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 2, -sticky => 'ew', -pady => 2);

#   Input fields for W2 Vector, SurfTemp, VolTemp, or FlowTemp file
    $row++;
    ($src_label1 = $fr->new_label(
            -textvariable => \$src_text,
            -font         => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($src_label2 = $fr->new_label(
            -textvariable => \$src_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
    ($src_btn = $fr->new_button(
            -text    => "Browse",
            -command =>
               sub { my ($file, $ftype, $n, $ok, $parms_ref, $status);
                     if ($src_type =~ /Vector/i) {
                         $file = Tkx::tk___getOpenFile(
                                 -parent    => $w2tdmap_setup_menu,
                                 -title     => "Select W2 Vector File",
                                 -filetypes => [ ['W2L (W2 Vector)', '.w2l'],
                                                 ['All Files', '*'],
                                               ],
                                 );
                         if (defined($file) && -e $file) {
                             $src_file = File::Spec->rel2abs($file);
                             $status_line = "Scanning W2 vector file...";  # no progress bar needed
                             &update_scrollable_menu($w2tdmap_setup_menu,
                                                     $sc_fr, $sc_canv, 'scrollable', $vscroll);
                             Tkx::update_idletasks();
                             ($ok, $parms_ref, undef, undef, undef)
                                 = &scan_w2_vector_file($w2tdmap_setup_menu, $src_file, $id, 0);
                             $status_line = "";
                             if ($ok ne "okay") {
                                 $src_file = $w2l_file = "";
                                 $ok_btn->configure(-state => 'disabled');
                                 &update_scrollable_menu($w2tdmap_setup_menu,
                                                         $sc_fr, $sc_canv, 'scrollable', $vscroll);
                                 return &pop_up_error($w2tdmap_setup_menu,
                                              "The specified file is not a W2 Vector (w2l) file:\n$file");
                             }
                             @src_parms = @{ $parms_ref };
                             $w2l_file  = $src_file;
                             $status    = 'normal';
                             for ($n=0; $n<=$#wbs; $n++) {
                                 if ($bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                     $status = 'disabled';
                                     last;
                                 }
                             }
                             $ok_btn->configure(-state => $status);
                         } else {
                             $ok_btn->configure(-state => 'disabled');
                         }
                     } else {
                         $file = Tkx::tk___getOpenFile(
                                 -parent    => $w2tdmap_setup_menu,
                                 -title     => "Select " . $src_type,
                                 -filetypes => [ ['All Files', '*'],
                                                 ['Custom W2 *Temp Files', '*Temp.dat'],
                                                 ['Custom W2 *Temp2 Files', '*Temp2.dat'],
                                               ],
                                 );
                         if (defined($file) && -e $file) {
                             $src_file = File::Spec->rel2abs($file);
                             $status_line = "Scanning " . $src_type . "...";
                             &update_scrollable_menu($w2tdmap_setup_menu,
                                                     $sc_fr, $sc_canv, 'scrollable', $vscroll);
                             Tkx::update_idletasks();
                             ($ftype, $src_lines, @src_parms)
                                 = &determine_ts_type($w2tdmap_setup_menu, $src_file, 1);
                             $status_line = "";
                             if ($ftype !~ /^W2 .*aily .*Temp2?\.dat format$/
                                   || ($src_type =~ /SurfTemp/ && $ftype !~ /SurfTemp/)
                                   || ($src_type =~ /VolTemp/  && $ftype !~ /VolTemp/)
                                   || ($src_type =~ /FlowTemp/ && $ftype !~ /FlowTemp/)) {
                                 $src_file  = "";
                                 $src_lines = 0;
                                 if ($src_type =~ /SurfTemp/) {
                                     $surftemp_file = "";
                                 } elsif ($src_type =~ /VolTemp/) {
                                     $voltemp_file  = "";
                                 } elsif ($src_type =~ /FlowTemp/) {
                                     $flowtemp_file = "";
                                 }
                                 $ok_btn->configure(-state => 'disabled');
                                 &update_scrollable_menu($w2tdmap_setup_menu,
                                                         $sc_fr, $sc_canv, 'scrollable', $vscroll);
                                 return &pop_up_error($w2tdmap_setup_menu,
                                              "The specified file is not a " . $src_type . ":\n$file");
                             }
                             if ($src_type =~ /SurfTemp/) {
                                 $surftemp_file = $src_file;
                             } elsif ($src_type =~ /VolTemp/) {
                                 $voltemp_file = $src_file;
                             } elsif ($src_type =~ /FlowTemp/) {
                                 $flowtemp_file = $src_file;
                             }
                             $status = 'normal';
                             for ($n=0; $n<=$#wbs; $n++) {
                                 if ($bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                     $status = 'disabled';
                                     last;
                                 }
                             }
                             $ok_btn->configure(-state => $status);
                         } else {
                             $ok_btn->configure(-state => 'disabled');
                         }
                     }
                     &update_scrollable_menu($w2tdmap_setup_menu, $sc_fr, $sc_canv, 'scrollable', $vscroll);
                   },
            ))->g_grid(-row => 1, -column => 2, -sticky => 'ew', -padx => 2, -pady => 2);

    $fr->g_grid_columnconfigure(1, -weight => 2);
    $src_label1->g_grid_remove();
    $src_label2->g_grid_remove();
    $src_btn->g_grid_remove();

#   Loop over the required branches for River Contour file inputs
    for ($n=0; $n<=$#brs; $n++) {
        $frv_on[$n]    = 1;
        $frv_label[$n] = "Branch " . $brs[$n];

        $row++;
        ($frv[$n] = $fr->new_labelframe(
                -borderwidth => 1,
                -relief      => 'groove',
                -text        => $frv_label[$n],
                ))->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew', -pady => 2);

        $frv[$n]->new_label(
                -text => "W2 RiverCon File: ",
                -font => 'default',
                )->g_grid(-row => 0, -column => 0, -sticky => 'e', -pady => 2);
        $frv[$n]->new_label(
                -textvariable => \$riv_files[$n],
                -anchor       => 'w',
                -font         => 'default',
                -background   => 'white',
                -relief       => 'sunken',
                -borderwidth  => 1,
                )->g_grid(-row => 0, -column => 1, -sticky => 'ew', -pady => 2);
        ($rbtn[$n] = $frv[$n]->new_button(
                -text    => "Browse",
                -command =>
                 [ sub { my ($n) = @_;
                         my (
                             $file, $ftype, $j, $jb1, $jb2, $meta, $nlines, $nn,
                             $nsegs, $parm, $pbar, $pbar_img, $pbar_win, $status, $txt,
                            );

                         $file = Tkx::tk___getOpenFile(
                                 -parent    => $w2tdmap_setup_menu,
                                 -title     => "Select W2 RiverCon Output File",
                                 -filetypes => [ ['W2 RiverCon files', 'RiverContour_*.csv'],
                                                 ['All Files', '*'],
                                               ],
                                 );
                         if (defined($file) && -e $file) {
                             $riv_files[$n] = File::Spec->rel2abs($file);
                             &update_scrollable_menu($w2tdmap_setup_menu, $sc_fr, $sc_canv,
                                                     'scrollable', $vscroll);
                             ($pbar_win, $pbar, $pbar_img)
                                 = &create_alt_progress_bar($main, $id,
                                                            "Scanning W2 River Contour file...");
                             ($ftype, $parm, $meta, $nlines)
                                 = &scan_w2_rlcon_file($w2tdmap_setup_menu, $riv_files[$n], $pbar_img);
                             &destroy_progress_bar($main, $pbar_win);

                             if ($ftype !~ /rcon/) {
                                 $riv_files[$n] = "          ";
                                 while ($frv_label[$n] =~ /,\d+$/) {
                                     $frv_label[$n] =~ s/,(\d+)//;
                                     $nn = &list_match($1, @brs);
                                     $frv_on[$nn]    = 1;
                                     $frv_label[$nn] = "Branch " . $brs[$nn];
                                     $frv[$nn]->configure(-text => $frv_label[$nn]);
                                     $frv[$nn]->g_grid();
                                 }
                                 $frv[$n]->configure(-text => $frv_label[$n]);
                                 $ok_btn->configure(-state => 'disabled');
                                 &update_scrollable_menu($w2tdmap_setup_menu, $sc_fr, $sc_canv,
                                                         'scrollable', $vscroll);
                                 return &pop_up_error($w2tdmap_setup_menu,
                                         "Specified file is not a W2 River Contour output file:\n$file");
                             }
                             ($jb1, $nsegs, $riv_freq[$n]) = split(/_/, $meta);
                             $jb2 = $jb1;
                             for ($j=$jb1; $j<=$nbr; $j++) {
                                 last if ($nsegs <= $ds[$j] -$us[$j] +1);
                                 $jb2++;
                                 $nsegs -= $ds[$j] -$us[$j] +1;
                             }
                             if ($brs[$n] < $jb1 || $brs[$n] > $jb2) {
                                 $riv_files[$n] = "          ";
                                 while ($frv_label[$n] =~ /,\d+$/) {
                                     $frv_label[$n] =~ s/,(\d+)//;
                                     $nn = &list_match($1, @brs);
                                     $frv_on[$nn]    = 1;
                                     $frv_label[$nn] = "Branch " . $brs[$nn];
                                     $frv[$nn]->configure(-text => $frv_label[$nn]);
                                     $frv[$nn]->g_grid();
                                 }
                                 $frv[$n]->configure(-text => $frv_label[$n]);
                                 $ok_btn->configure(-state => 'disabled');
                                 &update_scrollable_menu($w2tdmap_setup_menu, $sc_fr, $sc_canv,
                                                         'scrollable', $vscroll);
                                 $txt = ($jb2 == $jb1) ? $jb1 : $jb1 . "-" . $jb2;
                                 return &pop_up_error($w2tdmap_setup_menu,
                                           "The specified W2 River Contour file\n"
                                         . "does not include the correct branch:\n"
                                         . "(" . $txt . " rather than " . $brs[$n] . "):\n$file");
                             }
                             $frv_label[$n] = "Branch " . $brs[$n];
                             if ($jb2 > $jb1) {
                                 for ($j=$jb1; $j<=$jb2; $j++) {
                                     $nn = &list_match($j, @brs);
                                     if ($nn >= 0 && $brs[$nn] != $brs[$n]) {
                                         $frv_label[$n] .= "," . $brs[$nn];
                                         $frv_on[$nn]    = 0;
                                         $frv_label[$nn] = "Branch " . $brs[$nn];
                                         $frv[$nn]->configure(-text => $frv_label[$nn]);
                                         $frv[$nn]->g_grid_remove();
                                     }
                                 }
                                 $frv[$n]->configure(-text => $frv_label[$n]);
                             }
                             $riv_lines[$n] = $nlines;
                             $riv_parm[$n]  = $parm;

                             $status = 'normal';
                             for ($j=0; $j<=$#brs; $j++) {
                                 next if (! $frv_on[$j]);
                                 if ($riv_files[$j] eq "          " ||
                                     $riv_files[$j] eq "" || ! -e $riv_files[$j]) {
                                     $status = 'disabled';
                                     last;
                                 }
                             }
                             for ($j=0; $j<=$#wbs; $j++) {
                                 if ($bth_files[$j] eq "" || ! -e $bth_files[$j]) {
                                     $status = 'disabled';
                                     last;
                                 }
                             }
                             $ok_btn->configure(-state => $status);
                         } else {
                             $ok_btn->configure(-state => 'disabled');
                         }
                         &update_scrollable_menu($w2tdmap_setup_menu, $sc_fr, $sc_canv,
                                                 'scrollable', $vscroll);
                       }, $n ],
                ))->g_grid(-row => 0, -column => 2, -sticky => 'ew', -padx => 2, -pady => 2);

        $frv[$n]->g_grid_columnconfigure(1, -weight => 2);
        $frv[$n]->g_grid_remove();
    }

#   Loop over the required waterbodies for contour file and bathymetry file inputs
    for ($n=0; $n<=$#wbs; $n++) {
        $jw = $wbs[$n];

        $row++;
        ($f[$n] = $fr->new_labelframe(
                -borderwidth => 1,
                -relief      => 'groove',
                -text        => "Waterbody $jw",
                ))->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew', -pady => 2);

        ($clab1[$n] = $f[$n]->new_label(
                -text => "W2 Contour File: ",
                -font => 'default',
                ))->g_grid(-row => 0, -column => 0, -sticky => 'e', -pady => 2);
        ($clab2[$n] = $f[$n]->new_label(
                -textvariable => \$cpl_files[$n],
                -anchor       => 'w',
                -font         => 'default',
                -background   => 'white',
                -relief       => 'sunken',
                -borderwidth  => 1,
                ))->g_grid(-row => 0, -column => 1, -sticky => 'ew', -pady => 2);
        ($cbtn[$n] = $f[$n]->new_button(
                -text    => "Browse",
                -command =>
                 [ sub { my ($n) = @_;
                         my ($file, $i, $jw_src, $nlines, $parms_ref, $pbar, $pbar_img, $pbar_win,
                             $status, $tecplot, $txt,
                            );
                         $file = Tkx::tk___getOpenFile(
                                 -parent    => $w2tdmap_setup_menu,
                                 -title     => "Select W2 Contour Output File",
                                 -filetypes => [ ['All Files', '*'],
                                                 ['CSV (comma delimited)', '.csv'],
                                                 ['OPT (W2 output files)', '.opt'],
                                               ],
                                 );
                         if (defined($file) && -e $file) {
                             $cpl_files[$n] = File::Spec->rel2abs($file);
                             &update_scrollable_menu($w2tdmap_setup_menu, $sc_fr, $sc_canv,
                                                     'scrollable', $vscroll);
                             ($pbar_win, $pbar, $pbar_img)
                                 = &create_alt_progress_bar($main, $id, "Scanning W2 contour file...");
                             ($tecplot, $nlines, $jw_src, $parms_ref, undef, undef)
                                 = &scan_w2_cpl_file($w2tdmap_setup_menu, $cpl_files[$n], $id, 0, $pbar_img);
                             &destroy_progress_bar($main, $pbar_win);

                             if ($tecplot == -1) {
                                 $cpl_files[$n] = "          ";
                                 $ok_btn->configure(-state => 'disabled');
                                 &update_scrollable_menu($w2tdmap_setup_menu, $sc_fr, $sc_canv,
                                                         'scrollable', $vscroll);
                                 return &pop_up_error($w2tdmap_setup_menu,
                                     "Specified file is not a W2 Contour output file:\n$file");
                             }
                             if ($tecplot == 0 && $jw_src != $wbs[$n]) {
                                 $cpl_files[$n] = "          ";
                                 $ok_btn->configure(-state => 'disabled');
                                 &update_scrollable_menu($w2tdmap_setup_menu, $sc_fr, $sc_canv,
                                                         'scrollable', $vscroll);
                                 return &pop_up_error($w2tdmap_setup_menu,
                                         "The specified W2 Contour output file does not\n"
                                       . "appear to be from the correct waterbody:\n"
                                       . "(" . $jw_src . " rather than " . $wbs[$n] . "):\n$file");
                             }
                             $tecplot[$n]   = $tecplot;
                             $cpl_lines[$n] = $nlines;
                             $parmlist[$n]  = [ @{ $parms_ref } ];

                             $status = 'normal';
                             for ($i=0; $i<=$#wbs; $i++) {
                                 if ($cpl_files[$i] eq "          " ||
                                     $cpl_files[$i] eq "" || ! -e $cpl_files[$i] ||
                                     $bth_files[$i] eq "" || ! -e $bth_files[$i]) {
                                     $status = 'disabled';
                                     last;
                                 }
                             }
                             $ok_btn->configure(-state => $status);
                         } else {
                             $ok_btn->configure(-state => 'disabled');
                         }
                         &update_scrollable_menu($w2tdmap_setup_menu, $sc_fr, $sc_canv,
                                                 'scrollable', $vscroll);
                       }, $n ],
                ))->g_grid(-row => 0, -column => 2, -sticky => 'ew', -padx => 2, -pady => 2);

        $f[$n]->new_label(
                -text => "W2 Bathymetry File: ",
                -font => 'default',
                )->g_grid(-row => 1, -column => 0, -sticky => 'e', -pady => 2);
        $f[$n]->new_label(
                -textvariable => \$bth_files[$n],
                -anchor       => 'w',
                -font         => 'default',
                -background   => 'white',
                -relief       => 'sunken',
                -borderwidth  => 1,
                )->g_grid(-row => 1, -column => 1, -sticky => 'ew', -pady => 2);
        $f[$n]->new_button(
                -text    => "Browse",
                -command =>
                 [ sub { my ($n) = @_;
                         my ($file, $status);
                         $file = Tkx::tk___getOpenFile(
                                 -parent           => $w2tdmap_setup_menu,
                                 -title            => "Select W2 Bathymetry File",
                                 -defaultextension => ".csv",
                                 -filetypes => [ ['CSV (comma delimited)', '.csv'],
                                                 ['NPT (W2 input files)', '.npt'],
                                                 ['All Files', '*'],
                                               ],
                                 );
                         if (defined($file) && -e $file) {
                             $bth_files[$n] = File::Spec->rel2abs($file);
                             $status = 'normal';
                             if ($src_type =~ /Contour/i) {
                                 for ($n=0; $n<=$#wbs; $n++) {
                                     if ($cpl_files[$n] eq "          " ||
                                         $cpl_files[$n] eq "" || ! -e $cpl_files[$n]) {
                                         $status = 'disabled';
                                         last;
                                     }
                                 }
                             } elsif ($src_type =~ /RiverCon/i) {
                                 for ($n=0; $n<=$#brs; $n++) {
                                     next if (! $frv_on[$n]);
                                     if ($riv_files[$n] eq "          " ||
                                         $riv_files[$n] eq "" || ! -e $riv_files[$n]) {
                                         $status = 'disabled';
                                         last;
                                     }
                                 }
                             } else {
                                 $status = 'disabled' if ($src_file eq "" || ! -e $src_file);
                             }
                             if ($status eq 'normal') {
                                 for ($n=0; $n<=$#wbs; $n++) {
                                     if ($bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                         $status = 'disabled';
                                         last;
                                     }
                                 }
                             }
                             $ok_btn->configure(-state => $status);
                         } else {
                             $ok_btn->configure(-state => 'disabled');
                         }
                         &update_scrollable_menu($w2tdmap_setup_menu, $sc_fr, $sc_canv,
                                                 'scrollable', $vscroll);
                       }, $n ],
                )->g_grid(-row => 1, -column => 2, -sticky => 'ew', -padx => 2, -pady => 2);

        $f[$n]->g_grid_columnconfigure(1, -weight => 2);
    }

    if ($#wbs > 0) {
        $row++;
        ($frame2 = $fr->new_frame(
                    -borderwidth => 1,
                    -relief      => 'groove',
                ))->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew');

        $txt = "Note that this program works best when the contour output files from\n"
             . "each waterbody are assigned the same output dates and output frequencies.\n"
             . "In addition, each is required to include data for the parameter being plotted.";
        $frame2->new_label(
                -text    => $txt,
                -font    => 'default',
                -justify => 'left',
                )->g_pack(-side => 'left', -anchor => 'n', -expand => 1, -fill => 'x', -pady => 2);
    }

    $sc_canv->create_window(0, 0,
            -anchor => 'nw',
            -window => $fr,
            -tags   => 'scrollable',
            );
    $sc_fr->g_grid_columnconfigure(0, -weight => 1);
    &update_scrollable_menu($w2tdmap_setup_menu, $sc_fr, $sc_canv, 'scrollable', $vscroll);

    Tkx::wm_resizable($w2tdmap_setup_menu,0,0);
    &adjust_window_position($w2tdmap_setup_menu);
    $w2tdmap_setup_menu->g_focus;
}


sub setup_w2_tdmap_part3 {
    my ($canv, $id, $X, $Y) = @_;
    my (
        $axis_opt, $byear, $byear_cb, $conv_add, $conv_add_entry, $conv_mult,
        $conv_mult_entry, $conv_type, $conv_type_cb, $conv_type_na_label,
        $cscheme, $cscheme_cb, $custom_frame, $date_flip, $date_frame,
        $date_type, $dbase, $dbase_entry, $dfirst, $dfirst_entry,
        $dist_flip, $dist_frame, $dist_units, $dmajor, $dmajor_entry,
        $dmin, $dmin_entry, $f, $ftype, $frame, $geom, $gstitle, $gtitle,
        $i, $jd_skip, $jd_skip_active, $jd_skip_explain, $jw, $n,
        $ncolors, $ncolors_cb, $ntsr, $offset_frame, $ok_btn, $old_units,
        $oldparm, $oldparm_short, $parm, $parm_cb, $parm_chars, $parm_div,
        $parm_div_cb, $parm_div_label, $parm_frame, $parm_short, $pmax,
        $pmax_entry, $pmin, $pmin_entry, $profile_stat, $riv_freq, $row,
        $src_type, $title, $tz_offset, $units, $units_cb, $units_entry,
        $yr_max, $yr_min,

        @axis_opts, @cmaps, @cplf, @jd_skip_opts, @ncpl, @nvpl,
        @parm_divlist, @parmlist, @tsrf, @vplf, @wbs,

        %parms,
       );

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($w2tdmap_setup_menu) && Tkx::winfo_exists($w2tdmap_setup_menu)) {
        if ($w2tdmap_setup_menu->g_wm_title() eq "W2 Time/Distance Map Setup") {
            $w2tdmap_setup_menu->g_destroy();
            undef $w2tdmap_setup_menu;
        }
    }
    $w2tdmap_setup_menu = $main->new_toplevel();
    $w2tdmap_setup_menu->g_wm_transient($main);
    $w2tdmap_setup_menu->g_wm_title("W2 Time/Distance Map Setup");
    $w2tdmap_setup_menu->configure(-cursor => $cursor_norm);
    $w2tdmap_setup_menu->g_wm_geometry($geom);

#   Try to keep the nascent graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

    $src_type = $props{$id}{src_type};
    %parms    = %{ $props{$id}{parms} };
    @parmlist = @{ $parms{parms}      };
    $riv_freq = $parms{riv_freq} if ($src_type =~ /RiverCon/i);
    undef %parms;

    $parm         = $parmlist[0];
    $parm_chars   = length($parm) +2;
    for ($i=1; $i<=$#parmlist; $i++) {
        $parm_chars = length($parmlist[$i]) +2 if (length($parmlist[$i]) +2 > $parm_chars);
    }
    $parm_div     = "None";
    @parm_divlist = ("None");
    for ($i=0; $i<=$#parmlist; $i++) {
        next if ($parmlist[$i] eq "Horizontal Velocity"
                  || $parmlist[$i] eq "Vertical Velocity"
                  || $parmlist[$i] eq "Density"
                  || $parmlist[$i] eq "Habitat");
        if ($parm ne $parmlist[$i]) {
            push (@parm_divlist, $parmlist[$i]);
        }
    }
    $axis_opt     = "Time on X, Distance on Y";
    @axis_opts    = ("Time on X, Distance on Y", "Time on Y, Distance on X");
    $dist_units   = "miles";
    $dist_flip    = 0;
    $date_type    = "Date/Time";
    $date_flip    = 0;
    $cscheme      = "Blue to Orange";
    $ncolors      = 20;
    $byear        = $grid{$id}{byear};
    $tz_offset    = "+00:00";
    $profile_stat = "Volume-weighted";

    $yr_max = (localtime(time))[5] +1900;
    $yr_min = $yr_max -25;
    $yr_min = $byear -10 if ($byear <= $yr_min);
    $dbase  = $dmin = $dfirst = 0;
    $dmajor = $pmin = $pmax   = "";

    $parm_short = $parm;
    if ($parm eq "Temperature" || $parm =~ /^(Tmax|Tmean|Tmin|TEMP)$/) {
        $units = "Celsius";
        if ($parm eq "Temperature" || $parm eq "TEMP") {
            $title = "Temperature, in degrees Celsius";
        } elsif ($parm eq "Tmax") {
            $title = "Max Temperature, in degrees Celsius";
        } elsif ($parm eq "Tmean") {
            $title = "Mean Temperature, in degrees Celsius";
        } elsif ($parm eq "Tmin") {
            $title = "Min Temperature, in degrees Celsius";
        }
    } else {
        $units = "";
        $parm_short =~ s/\(ms-1\)//i;
        $parm_short =~ s/\(m3s-1\)//i;
        $parm_short =~ s/ [kmu]?g\/L\/day//i;
        $parm_short =~ s/ [kmu]?g\/m2\/day//i;
        $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
        $parm_short =~ s/ [kmu]?g\/L//i;
        $parm_short =~ s/ [kmu]?g\/m3//i;
        $parm_short =~ s/ [kmu]?g\/m\^3//i;
        $parm_short =~ s/, days//i;
        $parm_short =~ s/ days//i;
        $parm_short =~ s/,$//;
        if ($parm eq "Horizontal Velocity" || $parm eq "Vertical Velocity") {
            $units = "m/s";
            $title = $parm_short . ", in m/s";
        } elsif ($parm eq "Density") {
            $units = "kg/m3";
            $title = $parm_short . ", in kg/m3";
        } else {
            $title = $parm_short . ", in ";
        }
    }
    $gtitle        = "Time/Distance Map of $parm_short";
    $gstitle       = "";
    $oldparm       = $parm;
    $oldparm_short = $parm_short;
    $old_units     = $units;

#   Available initial colormaps
    @cmaps = ("Blue to Orange", "Blue to Red", "CoolWarm", "Turbo", "Viridis");

#   Conversion types and factors (@conv_types is global)
    $conv_type = $conv_types[0];
    $conv_mult = 1.0;
    $conv_add  = 0.0;

#   Skip some dates?
    $jd_skip_active = $jd_skip = 0;
    if ($src_type =~ /RiverCon/i) {
        $jd_skip_active = 1 if ($riv_freq < 1.0);
    } elsif ($src_type =~ /Contour/i) {
        @ncpl = @{ $grid{$id}{ncpl} };
        @cplf = @{ $grid{$id}{cplf} };
        @wbs  = split(/,/, $props{$id}{wb_list});
        foreach $jw (@wbs) {
            for ($i=1; $i<=$ncpl[$jw]; $i++) {
                next if ($cplf[$i][$jw] eq "na");
                if ($cplf[$i][$jw] < 1.0) {
                    $jd_skip_active = 1;
                    last;
                }
            }
            last if ($jd_skip_active);
        }
        undef @ncpl;
        undef @cplf;
        undef @wbs;
    } elsif ($src_type =~ /Vector/i) {
        @nvpl = @{ $grid{$id}{nvpl} };
        @vplf = @{ $grid{$id}{vplf} };
        @wbs  = split(/,/, $props{$id}{wb_list});
        foreach $jw (@wbs) {
            for ($i=1; $i<=$nvpl[$jw]; $i++) {
                next if ($vplf[$i][$jw] eq "na");
                if ($vplf[$i][$jw] < 1.0) {
                    $jd_skip_active = 1;
                    last;
                }
            }
            last if ($jd_skip_active);
        }
        undef @nvpl;
        undef @vplf;
        undef @wbs;
    } elsif ($src_type =~ /SurfTemp|VolTemp|FlowTemp/i) {
        ($ftype, undef, undef) = &determine_ts_type($w2tdmap_setup_menu, $props{$id}{src_file}, 1);
        if ($ftype =~ /^W2 .*daily .*Temp2\.dat format$/i) {
            $ntsr = $grid{$id}{ntsr};
            @tsrf = @{ $grid{$id}{tsrf} };
            for ($i=1; $i<=$ntsr; $i++) {
                next if ($tsrf[$i] eq "na");
                if ($tsrf[$i] < 1.0) {
                    $jd_skip_active = 1;
                    last;
                }
            }
            undef @tsrf;
        }
    }
    @jd_skip_opts = ("(keep all)", "(keep every other)", "(keep every 3rd)", "(keep every 4th)",
                     "(keep every 5th)",  "(keep every 6th)",  "(keep every 7th)",  "(keep every 8th)",
                     "(keep every 9th)",  "(keep every 10th)", "(keep every 11th)", "(keep every 12th)",
                     "(keep every 13th)", "(keep every 14th)", "(keep every 15th)", "(keep every 16th)",
                     "(keep every 17th)", "(keep every 18th)", "(keep every 19th)", "(keep every 20th)",
                     "(keep every 21st)", "(keep every 22nd)", "(keep every 23rd)", "(keep every 24th)",
                     "(keep every 25th)", "(keep every 26th)", "(keep every 27th)", "(keep every 28th)",
                     "(keep every 29th)", "(keep every 30th)", "(keep every 31st)", "(keep every 32nd)",
                     "(keep every 33rd)", "(keep every 34th)", "(keep every 35st)", "(keep every 36th)",
                     "(keep every 37th)", "(keep every 38th)", "(keep every 39th)", "(keep every 40th)",
                     "(keep every 41st)", "(keep every 42nd)", "(keep every 43rd)", "(keep every 44th)",
                     "(keep every 45th)", "(keep every 46th)", "(keep every 47th)", "(keep every 48th)",
                     "(keep every 49th)", "(keep every 50th)");
    $jd_skip_explain = $jd_skip_opts[$jd_skip];

#   Set up the menu
    $frame = $w2tdmap_setup_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -command => sub { my (%parms);
                              if ($pmin eq "" || $pmax eq "") {
                                  return &pop_up_error($w2tdmap_setup_menu,
                                  "Please provide both a min and max for your parameter.");
                              }
                              if ($pmin >= $pmax) {
                                  return &pop_up_error($w2tdmap_setup_menu,
                                  "The minimum data value must be less than the maximum data value.");
                              }
                              if ($dfirst ne "" && (($dmin ne "" && $dfirst < $dmin)
                                                 || ($dmin eq "" && $dfirst < 0))) {
                                  return &pop_up_error($w2tdmap_setup_menu,
                                  "The first distance label should not be less than the minimum distance.");
                              }
                              if ($conv_type eq "Custom") {
                                  $conv_type = sprintf("Custom,%s,%s", $conv_mult, $conv_add);
                              }
                              $gtitle  =~ s/^\s+//;
                              $gtitle  =~ s/\s+$//;
                              $gstitle =~ s/^\s+//;
                              $gstitle =~ s/\s+$//;

                              %parms             = ();
                              $parms{pmin}       = $pmin;
                              $parms{pmax}       = $pmax;
                              $parms{date_axis}  = ($axis_opt =~ /Time on X/) ? "X" : "Y";
                              $parms{date_type}  = $date_type;
                              $parms{date_flip}  = $date_flip;
                              $parms{dist_units} = $dist_units;
                              $parms{dist_flip}  = $dist_flip;
                              $parms{dist_base}  = $dbase;
                              $parms{dist_min}   = $dmin;
                              $parms{dist_first} = $dfirst;
                              $parms{dist_major} = $dmajor;
                              $parms{cscheme}    = $cscheme;
                              $parms{ncolors}    = $ncolors;
                              $parms{gtitle}     = $gtitle;
                              $parms{gstitle}    = $gstitle;
                              $props{$id}{parms} = { %parms };

                              $props{$id}{parm}       = $parm;
                              $props{$id}{parm_sav}   = $parm;
                              $props{$id}{parm_div}   = $parm_div;
                              $props{$id}{pdiv_sav}   = $parm_div;
                              $props{$id}{parm_units} = $units;
                              $props{$id}{ctype}      = $conv_type;
                              $props{$id}{byear}      = $byear;
                              $props{$id}{tz_offset}  = $tz_offset;
                              $props{$id}{prof_stat}  = $profile_stat;
                              $props{$id}{jd_skip}    = $jd_skip;
                              $props{$id}{map_type}   = "standard";

                              $w2tdmap_setup_menu->g_bind('<Destroy>', "");
                              $w2tdmap_setup_menu->g_destroy();
                              undef $w2tdmap_setup_menu;
                              &reset_bindings;

                              &make_w2_tdmap($canv, $id, 0);
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);

    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $w2tdmap_setup_menu->g_bind('<Destroy>', "");
                              $w2tdmap_setup_menu->g_destroy();
                              undef $w2tdmap_setup_menu;
                              $canv->delete("graph" . $id);
                              delete $props{$id};
                              delete $grid{$id};
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Delete graph if this menu is destroyed by other than the Cancel button
    $w2tdmap_setup_menu->g_bind('<Destroy>' => sub { undef $w2tdmap_setup_menu;
                                                     $canv->delete("graph" . $id);
                                                     delete $props{$id}; 
                                                     delete $grid{$id};
                                                     &reset_bindings;
                                                   });

    ($f = $w2tdmap_setup_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "Parameter: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    if ($src_type =~ /RiverCon/i) {
        $f->new_label(
                -text => $parm,
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    } else {
        ($parm_frame = $f->new_frame(
                -borderwidth => 0,
                -relief      => 'flat',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
        ($parm_cb = $parm_frame->new_ttk__combobox(
                -textvariable => \$parm,
                -values       => [ @parmlist ],
                -state        => 'readonly',
                -width        => $parm_chars,
                ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        $parm_cb->g_bind("<<ComboboxSelected>>",
                             sub { my ($i);
                                   return if ($parm eq $oldparm);
                                   $parm_short = $parm;
                                   if ($parm eq "Temperature" || $parm =~ /^(Tmax|Tmean|Tmin|TEMP)$/) {
                                       $units = "Celsius" if ($units !~ /(Celsius|Fahrenheit)/);
                                       if ($parm eq "Temperature" || $parm eq "TEMP") {
                                           $title = "Temperature, in degrees " . $units;
                                       } elsif ($parm eq "Tmax") {
                                           $title = "Max Temperature, in degrees " . $units;
                                       } elsif ($parm eq "Tmean") {
                                           $title = "Mean Temperature, in degrees " . $units;
                                       } elsif ($parm eq "Tmin") {
                                           $title = "Min Temperature, in degrees " . $units;
                                       }
                                       $units_cb->g_grid();
                                       $units_entry->g_grid_remove();
                                       $conv_type_na_label->g_grid();
                                       $custom_frame->g_grid_remove();
                                       $conv_type_cb->g_grid_remove();
                                       $conv_type = "None";
                                   } else {
                                       $units = "";
                                       $parm_short =~ s/\(ms-1\)//i;
                                       $parm_short =~ s/\(m3s-1\)//i;
                                       $parm_short =~ s/ [kmu]?g\/L\/day//i;
                                       $parm_short =~ s/ [kmu]?g\/m2\/day//i;
                                       $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
                                       $parm_short =~ s/ [kmu]?g\/L//i;
                                       $parm_short =~ s/ [kmu]?g\/m3//i;
                                       $parm_short =~ s/ [kmu]?g\/m\^3//i;
                                       $parm_short =~ s/, days//i;
                                       $parm_short =~ s/ days//i;
                                       $parm_short =~ s/,$//;
                                       if ($parm eq "Horizontal Velocity" || $parm eq "Vertical Velocity") {
                                           $units = "m/s";
                                           $title = $parm_short . ", in m/s";
                                       } elsif ($parm eq "Density") {
                                           $units = "kg/m3";
                                           $title = $parm_short . ", in kg/m3";
                                       } else {
                                           $title = $parm_short . ", in ";
                                       }
                                       $units_cb->g_grid_remove();
                                       $units_entry->g_grid();
                                       $conv_type_na_label->g_grid_remove();
                                       $custom_frame->g_grid() if ($conv_type eq "Custom");
                                       $conv_type_cb->g_grid();
                                   }
                                   if ($gtitle eq "") {
                                       $gtitle = "Time/Distance Map of $parm_short";
                                   } else {
                                       if (index(lc($gtitle), lc($oldparm_short)) > -1) {
                                           $gtitle =~ s/$oldparm_short/$parm_short/i;
                                       }
                                   }
                                   $old_units     = $units;
                                   $oldparm       = $parm;
                                   $oldparm_short = $parm_short;
                                   @parm_divlist = ("None");
                                   for ($i=0; $i<=$#parmlist; $i++) {
                                       next if ($parmlist[$i] eq "Horizontal Velocity"
                                                   || $parmlist[$i] eq "Vertical Velocity"
                                                   || $parmlist[$i] eq "Density"
                                                   || $parmlist[$i] eq "Habitat");
                                       if ($parm ne $parmlist[$i]) {
                                           push (@parm_divlist, $parmlist[$i]);
                                       }
                                   }
                                   $parm_div_cb->configure(-values => [ @parm_divlist ]);
                                   if (&list_match($parm_div, @parm_divlist) == -1) {
                                       $parm_div = "None";
                                   }
                                   if ($parm =~ /^(Temperature|TEMP)$/ || $parm eq "Horizontal Velocity"
                                                || $parm eq "Vertical Velocity" || $parm eq "Density"
                                                || $parm eq "Habitat" || $#parm_divlist == 0) {
                                       $parm_div_label->g_pack_forget();
                                       $parm_div_cb->g_pack_forget();
                                       $parm_div = "None";
                                   } else {
                                       $parm_div_label->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                                       $parm_div_cb->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                                   }
                                 });
        ($parm_div_label = $parm_frame->new_label(
                -text => " divided by ",
                -font => 'default',
                ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        ($parm_div_cb = $parm_frame->new_ttk__combobox(
                -textvariable => \$parm_div,
                -values       => [ @parm_divlist ],
                -state        => 'readonly',
                -width        => $parm_chars,
                ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    }

    $row++;
    $f->new_label(
            -text => "Profile Stat: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    if ($src_type =~ /Contour|Vector/i) {
        $f->new_ttk__combobox(
                -textvariable => \$profile_stat,
                -values       => [ ("Surface value", "Volume-weighted") ],
                -state        => 'readonly',
                -width        => 16,
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    } else {
        if ($src_type =~ /SurfTemp|RiverCon/) {
            $profile_stat = "Surface value";
        } elsif ($src_type =~ /VolTemp/) {
            $profile_stat = "Volume-weighted";
        } elsif ($src_type =~ /FlowTemp/) {
            $profile_stat = "Flow-weighted";
        }
        $f->new_label(
                -text => $profile_stat,
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    }

    $row++;
    $f->new_label(
            -text => "Conversion: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($conv_type_na_label = $f->new_label(
            -text => "n/a",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $conv_type_na_label->g_grid_remove();
    ($conv_type_cb = $f->new_ttk__combobox(
            -textvariable => \$conv_type,
            -values       => [ @conv_types ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $conv_type_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($conv_type eq "Custom") {
                                $custom_frame->g_grid();
                            } else {
                                $custom_frame->g_grid_remove();
                            }
                          }
                      );
    $row++;
    ($custom_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $custom_frame->new_label(
            -text => "Multiply by: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_mult_entry = $custom_frame->new_entry(
            -textvariable => \$conv_mult,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_mult_entry->g_bind("<KeyRelease>",
                              sub { &numeric_entry_only($conv_mult_entry);
                                    my $chars = &max(7, length($conv_mult));
                                    $conv_mult_entry->configure(-width => $chars);
                                  });
    $custom_frame->new_label(
            -text => "  Then add: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_add_entry = $custom_frame->new_entry(
            -textvariable => \$conv_add,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_add_entry->g_bind("<KeyRelease>",
                             sub { &numeric_entry_only($conv_add_entry);
                                   my $chars = &max(7, length($conv_add));
                                   $conv_add_entry->configure(-width => $chars);
                                 });

    $row++;
    $f->new_label(
            -text => "Data Units: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($units_cb = $f->new_ttk__combobox(
            -textvariable => \$units,
            -values       => [ ("Celsius", "Fahrenheit") ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $units_cb->g_bind("<<ComboboxSelected>>",
                       sub { return if ($units eq $old_units);
                             $old_units = $units;
                             $pmin = 0 if ($pmin eq "-");
                             $pmax = 0 if ($pmax eq "-");
                             if ($units eq "Celsius") {
                                 $pmin = &floor(($pmin -32) /1.8) if ($pmin ne "");
                                 $pmax = &ceil(($pmax  -32) /1.8) if ($pmax ne "");
                             } elsif ($units eq "Fahrenheit") {
                                 $pmin = &floor($pmin *1.8 +32) if ($pmin ne "");
                                 $pmax = &ceil($pmax  *1.8 +32) if ($pmax ne "");
                             }
                             $title = "Temperature, in degrees " . $units;
                           });
    $units_cb->g_grid_remove();
    ($units_entry = $f->new_entry(
            -textvariable => \$units,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $units_entry->g_bind("<KeyRelease>",
                         sub { my $chars = &max(7, length($units));
                               $units_entry->configure(-width => $chars);
                               if ($parm eq "Temperature") {
                                   $title = "Temperature, in degrees " . $units;
                               } else {
                                   $title = $parm_short . ", in " . $units;
                               }
                             });

    $row++;
    $f->new_label(
            -text => "Data Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$title,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Data Min: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmin_entry = $f->new_entry(
            -textvariable => \$pmin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $pmin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmin_entry ]);

    $row++;
    $f->new_label(
            -text => "Data Max: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmax_entry = $f->new_entry(
            -textvariable => \$pmax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $pmax_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmax_entry ]);

    $row++;
    $f->new_label(
            -text => "Axis Orientation: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_ttk__combobox(
            -textvariable => \$axis_opt,
            -values       => [ @axis_opts ],
            -state        => 'readonly',
            -width        => 25,
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Date Axis Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($date_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $date_frame->new_ttk__combobox(
            -textvariable => \$date_type,
            -values       => [ ("Date/Time", "Julian Date") ],
            -state        => 'readonly',
            -width        => 12,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $date_frame->new_checkbutton(
            -onvalue  => 1,
            -offvalue => 0,
            -text     => "Flip Axis",
            -font     => 'default',
            -variable => \$date_flip,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Distance Base: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($dbase_entry = $f->new_entry(
            -textvariable => \$dbase,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $dbase_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $dbase_entry ]);
    $f->new_label(
            -textvariable => \$dist_units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Distance Min: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($dmin_entry = $f->new_entry(
            -textvariable => \$dmin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $dmin_entry->g_bind("<KeyRelease>",
                         sub { &numeric_entry_only($dmin_entry);
                               if ($dmin ne "" && $dmin ne "." && $dmin ne "-") {
                                   if ($dfirst ne "" && $dfirst ne "."
                                                     && $dfirst ne "-" && $dfirst < $dmin) {
                                       if (&ceil($dmin) != $dmin) {
                                           $dfirst = &ceil($dmin);
                                       } else {
                                           $dfirst = $dmin;
                                       }
                                   }
                               }
                             });
    $f->new_label(
            -textvariable => \$dist_units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "First Distance Label: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($dfirst_entry = $f->new_entry(
            -textvariable => \$dfirst,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $dfirst_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $dfirst_entry ]);
    $f->new_label(
            -textvariable => \$dist_units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Distance Major: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($dmajor_entry = $f->new_entry(
            -textvariable => \$dmajor,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $dmajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($dmajor_entry, 1);
                                                $dmajor =~ s/^-//;
                                              });
    $f->new_label(
            -textvariable => \$dist_units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Distance Units: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($dist_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $dist_frame->new_ttk__combobox(
            -textvariable => \$dist_units,
            -values       => [ ("miles", "kilometers") ],
            -state        => 'readonly',
            -width        => 10,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $dist_frame->new_checkbutton(
            -onvalue  => 1,
            -offvalue => 0,
            -text     => "Flip Axis",
            -font     => 'default',
            -variable => \$dist_flip,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Color Scheme: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($cscheme_cb = $f->new_ttk__combobox(
            -textvariable => \$cscheme,
            -values       => [ @cmaps ],
            -state        => 'readonly',
            -width        => 15,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $cscheme_cb->g_bind("<<ComboboxSelected>>",
                           sub { my ($n);
                                 if ($cscheme =~ /CoolWarm|Turbo|Viridis/) {
                                     $ncolors_cb->configure(-values => [ (8 .. 100) ]);
                                 } else {
                                     $ncolors_cb->configure(-values =>
                                         [ (16, 18, 20, 22, 24, 30, 34, 38, 42, 46) ]);
                                     if ($ncolors < 16) {
                                         $ncolors = 16;
                                     } elsif ($ncolors > 46) {
                                         $ncolors = 46;
                                     } else {
                                         foreach $n (reverse @valid_nc) {
                                             if ($ncolors >= 2 *$n) {
                                                 $ncolors = 2 *$n;
                                                 last;
                                             }
                                         }
                                     }
                                 }
                               });

    $row++;
    $f->new_label(
            -text => "Number of Colors: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ncolors_cb = $f->new_ttk__combobox(
            -textvariable => \$ncolors,
            -values       => [ (16, 18, 20, 22, 24, 30, 34, 38, 42, 46) ],
            -state        => 'readonly',
            -width        => 4,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Base Year: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($byear_cb = $f->new_ttk__combobox(
            -textvariable => \$byear,
            -values       => [ reverse($yr_min .. $yr_max) ],
            -state        => 'readonly',
            -width        => 5,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $byear_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($byear == $yr_min) {
                                $yr_min -= 10;
                                $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                            }
                          }
                     );
    $f->new_label(
            -text   => " for JDAY = 1.0",
            -anchor => 'w',
            -font   => 'default',
            )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Time Offset: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($offset_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    $offset_frame->new_ttk__combobox(
            -textvariable => \$tz_offset,
            -values       => [ @tz_offsets ],
            -justify      => 'right',
            -state        => 'readonly',
            -width        => 6,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $offset_frame->new_label(
            -text   => " time zone adjustment ",
            -anchor => 'w',
            -font   => 'default',
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $offset_frame->new_button(
            -text    => "Help",
            -command => sub { &pop_up_info($w2tdmap_setup_menu,
                                    "The time offset allows the user to add or subtract a time\n"
                                  . "offset if the W2 model was run with a non-local time zone.\n\n"
                                  . "For example, if W2 was run in UTC but the local time zone\n"
                                  . "is PST, an offset of -08:00 would convert the model date/time\n"
                                  . "to a local standard time of PST. This offset does not make\n"
                                  . "any adjustments related to daylight saving time. In general,\n"
                                  . "W2 is best run in the local standard time.\n\n"
                                  . "Leave the time offset at +00:00 for no adjustment.",
                                    "Time Offset Notice");
                            },
            )->g_pack(-side => 'left', -anchor => 'w', -padx => 2);

    if ($jd_skip_active) {
        $row++;
        $f->new_label(
                -text => "Skip Dates: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $f->new_spinbox(
                -textvariable => \$jd_skip,
                -state        => 'readonly',
                -font         => 'default',
                -from         => 0,
                -to           => 49,
                -increment    => 1,
                -width        => 4,
                -command      => sub { $jd_skip_explain = $jd_skip_opts[$jd_skip]; },
                )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $f->new_label(
                -textvariable => \$jd_skip_explain,
                -font         => 'default',
                )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);
    }

    $row++;
    $f->new_label(
            -text => "Graph Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gtitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Graph Subtitle: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gstitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);

    if ($src_type !~ /RiverCon/i) {
        if ($parm =~ /^(Temperature|TEMP)$/ || $parm eq "Horizontal Velocity" || $parm eq "Density"
                     || $parm eq "Habitat" || $#parm_divlist == 0 || $parm eq "Vertical Velocity") {
            $parm_div_label->g_pack_forget();
            $parm_div_cb->g_pack_forget();
            $parm_div = "None";
        } else {
            $parm_div_label->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
            $parm_div_cb->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        }
    }
    if ($conv_type ne "Custom") {
        $custom_frame->g_grid_remove();
    }
    if ($parm eq "Temperature" || $parm =~ /^(Tmax|Tmean|Tmin|TEMP)$/) {
        $units_cb->g_grid();
        $units_entry->g_grid_remove();
        $conv_type_na_label->g_grid();
        $custom_frame->g_grid_remove();
        $conv_type_cb->g_grid_remove();
        $conv_type = "None";
        $parm_div  = "None";
    } else {
        $units_cb->g_grid_remove();
        $units_entry->g_grid();
        $conv_type_na_label->g_grid_remove();
        $custom_frame->g_grid() if ($conv_type eq "Custom");
        $conv_type_cb->g_grid();
    }
    if ($cscheme =~ /CoolWarm|Turbo|Viridis/) {
        $ncolors_cb->configure(-values => [ (8 .. 100) ]);
    } else {
        $ncolors_cb->configure(-values => [ (16, 18, 20, 22, 24, 30, 34, 38, 42, 46) ]);
        if ($ncolors < 16) {
            $ncolors = 16;
        } elsif ($ncolors > 46) {
            $ncolors = 46;
        } else {
            foreach $n (reverse @valid_nc) {
                if ($ncolors >= 2 *$n) {
                    $ncolors = 2 *$n;
                    last;
                }
            }
        }
    }
    $f->g_grid_columnconfigure(2, -weight => 2);

    Tkx::wm_resizable($w2tdmap_setup_menu,0,0);
    &adjust_window_position($w2tdmap_setup_menu);
    $w2tdmap_setup_menu->g_focus;
}


sub setup_w2_tdmap_parmdiff {
    my ($canv, $id, $X, $Y) = @_;
    my (
        $conv_add, $conv_add_entry, $conv_mult, $conv_mult_entry, $conv_type,
        $conv_type_cb, $conv_type_na_label, $custom_frame, $f, $frame, $geom,
        $gstitle, $gtitle, $i, $jw, $n, $ok, $ok_btn, $old_units, $oldparm,
        $oldparm_short, $p, $parm, $parm_cb, $parm_chars, $parm_div,
        $parm_div_cb, $parm_div_label, $parm_frame, $parm_short, $parm1,
        $parm1_txt, $parms_ref, $pmax, $pmax_entry, $pmin, $pmin_entry,
        $row, $src_type, $tecplot, $title, $units, $units_cb, $units_entry,

        @cpl_files, @parm_divlist, @parm_tmp, @parmlist, @parms_list, @wbs,
       );

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($w2tdmap_diff_menu) && Tkx::winfo_exists($w2tdmap_diff_menu)) {
        if ($w2tdmap_diff_menu->g_wm_title() eq "W2 Time/Distance Difference Setup") {
            $w2tdmap_diff_menu->g_destroy();
            undef $w2tdmap_diff_menu;
        }
    }
    $w2tdmap_diff_menu = $main->new_toplevel();
    $w2tdmap_diff_menu->g_wm_transient($main);
    $w2tdmap_diff_menu->g_wm_title("W2 Time/Distance Difference Setup");
    $w2tdmap_diff_menu->configure(-cursor => $cursor_norm);
    $w2tdmap_diff_menu->g_wm_geometry($geom);

#   Try to keep the graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");
    &end_select($canv, $id, 1);

#   Initialize some variables.
    $src_type  = $props{$id}{src_type};
    $pmin      = $gr_props{$id}{cs_min};
    $pmax      = $gr_props{$id}{cs_max};
    $gstitle   = $gr_props{$id}{gstitle};
    $conv_type = $conv_types[0];
    $conv_mult = 1.0;
    $conv_add  = 0.0;

    $parm1 = $props{$id}{parm_sav};
    if ($parm1 =~ /^(Temperature|TEMP|Tmin|Tmean|Tmax)$/) {
        if ($parm1 eq "TEMP") {
            $parm1 = "Temperature";
        } elsif ($parm1 eq "Tmax") {
            $parm1 = "Max Temperature";
        } elsif ($parm1 eq "Tmean") {
            $parm1 = "Mean Temperature";
        } elsif ($parm1 eq "Tmin") {
            $parm1 = "Min Temperature";
        }
    } else {
        $parm1 =~ s/\(ms-1\)//i;
        $parm1 =~ s/\(m3s-1\)//i;
        $parm1 =~ s/ [kmu]?g\/L\/day//i;
        $parm1 =~ s/ [kmu]?g\/m2\/day//i;
        $parm1 =~ s/ [kmu]?g\/m\^2\/day//i;
        $parm1 =~ s/ [kmu]?g\/L//i;
        $parm1 =~ s/ [kmu]?g\/m3//i;
        $parm1 =~ s/ [kmu]?g\/m\^3//i;
        $parm1 =~ s/, days//i;
        $parm1 =~ s/ days//i;
        $parm1 =~ s/,$//;
    }
    if ($props{$id}{pdiv_sav} ne "None") {
        $parm1_txt = $props{$id}{parm_sav} . " / " . $props{$id}{pdiv_sav};
    } else {
        $parm1_txt = $props{$id}{parm_sav};
    }
    if ($props{$id}{parm_units} =~ /^(Celsius|Fahrenheit)$/) {
        $parm1_txt .= ", in degrees " . $props{$id}{parm_units};
    } else {
        $parm1_txt .= ", in " . $props{$id}{parm_units};
    }

    if ($src_type =~ /Contour/i) {
        @cpl_files = @{ $props{$id}{cpl_files} };
        @wbs       = split(/,/, $props{$id}{wb_list});
        for ($n=0; $n<=$#wbs; $n++) {
            ($tecplot, undef, $jw, $parms_ref, undef, undef)
                  = &scan_w2_cpl_file($w2tdmap_diff_menu, $cpl_files[$n], $id, 0, "");
            if ($tecplot == -1) {
                return &pop_up_error($w2tdmap_diff_menu,
                                     "The source file is not a W2 Contour file:\n$cpl_files[$n]");
            }
            @parms_list = @{ $parms_ref };
            if ($n == 0) {
                @parmlist = @parms_list;
            } else {                # only keep parameters common to all cpl files
                @parm_tmp = ();
                foreach $p ( @parms_list ) {
                    if (&list_match($p, @parmlist) >= 0) {
                        push (@parm_tmp, $p);
                    }
                }
                @parmlist = @parm_tmp;
            }
        }
    } elsif ($src_type =~ /Vector/i) {
        ($ok, $parms_ref, undef, undef, undef)
                  = &scan_w2_vector_file($w2tdmap_diff_menu, $props{$id}{w2l_file}, $id, 0);
        if ($ok ne "okay") {
            return &pop_up_error($w2tdmap_diff_menu,
                                 "The source file is not a W2 Vector (w2l) file:\n$props{$id}{w2l_file}");
        }
        @parmlist = @{ $parms_ref };
    } elsif ($src_type =~ /SurfTemp|VolTemp|FlowTemp/i) {
        (undef, undef, @parmlist) = &determine_ts_type($w2tdmap_diff_menu, $props{$id}{src_file}, 1);
    }

#   Remove current parameter from working list
    @parms_list = @parmlist;
    @parm_tmp   = ();
    foreach $p ( @parmlist ) {
        push (@parm_tmp, $p) if ($p ne $props{$id}{parm_sav});
    }
    @parmlist = @parm_tmp;
    $parm     = $parmlist[0];
    $parm_div = "None";
    $units    = "";

    $parm_chars = length($parm);
    for ($i=1; $i<=$#parmlist; $i++) {
        $parm_chars = &max($parm_chars, length($parmlist[$i]));
    }
    $parm_chars += 2;
    $parm_short = $parm;
    if ($parm !~ /^(Temperature|TEMP|Tmin|Tmean|Tmax)$/) {
        $parm_short =~ s/\(ms-1\)//i;
        $parm_short =~ s/\(m3s-1\)//i;
        $parm_short =~ s/ [kmu]?g\/L\/day//i;
        $parm_short =~ s/ [kmu]?g\/m2\/day//i;
        $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
        $parm_short =~ s/ [kmu]?g\/L//i;
        $parm_short =~ s/ [kmu]?g\/m3//i;
        $parm_short =~ s/ [kmu]?g\/m\^3//i;
        $parm_short =~ s/, days//i;
        $parm_short =~ s/ days//i;
        $parm_short =~ s/,$//;
    }
    $gtitle        = "Time/Distance Diff Map of $parm1 minus $parm_short";
    $old_units     = $units;
    $oldparm       = $parm;
    $oldparm_short = $parm_short;
    @parm_divlist  = ("None");
    for ($i=0; $i<=$#parms_list; $i++) {
        next if ($parms_list[$i] eq "Horizontal Velocity"
                  || $parms_list[$i] eq "Vertical Velocity"
                  || $parms_list[$i] eq "Density"
                  || $parms_list[$i] eq "Habitat");
        if ($parm ne $parms_list[$i]) {
            push (@parm_divlist, $parms_list[$i]);
        }
    }

    if ($parm =~ /^(Temperature|Tmax|Tmean|Tmin|TEMP)$/) {
        if ($parm eq "Temperature" || $parm eq "TEMP") {
            $title = $parm1 . " minus Temperature, in ";
        } elsif ($parm eq "Tmax") {
            $title = $parm1 . " minus Max Temperature, in ";
        } elsif ($parm eq "Tmean") {
            $title = $parm1 . " minus Mean Temperature, in ";
        } elsif ($parm eq "Tmin") {
            $title = $parm1 . " minus Min Temperature, in ";
        }
        if ($parm1 =~ /Temperature/) {
            $units     = "Celsius" if ($units !~ /(Celsius|Fahrenheit)/);
            $title    .= "degrees " . $units;
            $old_units = $units;
        }
    } elsif (($parm  eq "Horizontal Velocity" || $parm  eq "Vertical Velocity") &&
             ($parm1 eq "Horizontal Velocity" || $parm1 eq "Vertical Velocity")) {
        $units     = "m/s";
        $title     = $parm1 . " minus " . $parm_short . ", in m/s";
        $old_units = $units;
    } elsif ($parm eq "Density" && $parm1 eq "Density") {
        $units     = "kg/m3";
        $title     = $parm1 . " minus " . $parm_short . ", in kg/m3";
        $old_units = $units;
    } else {
        $title = $parm1 . " minus " . $parm_short . ", in ";
    }

#   Build the menu.
    $frame = $w2tdmap_diff_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -command => sub { my (%parms);
                              %parms = ();
                              if ($pmin eq "" || $pmax eq "") {
                                  return &pop_up_error($w2tdmap_diff_menu,
                                  "Please provide both a min and max for your data.");
                              }
                              if ($pmin >= $pmax) {
                                  return &pop_up_error($w2tdmap_diff_menu,
                                  "The minimum data value must be less than the maximum data value.");
                              }
                              if ($conv_type eq "Custom") {
                                  $conv_type = sprintf("Custom,%s,%s", $conv_mult, $conv_add);
                              }
                              $title   =~ s/^\s+//;
                              $title   =~ s/\s+$//;
                              $gtitle  =~ s/^\s+//;
                              $gtitle  =~ s/\s+$//;
                              $gstitle =~ s/^\s+//;
                              $gstitle =~ s/\s+$//;

                              $parms{pmin}       = $pmin;
                              $parms{pmax}       = $pmax;
                              $parms{title}      = $title;
                              $parms{gtitle}     = $gtitle;
                              $parms{gstitle}    = $gstitle;
                              $parms{change}     = "";
                              $props{$id}{parms} = { %parms };

                              if ($src_type =~ /Contour/i) {
                                  $props{$id}{tecplot2}   = $props{$id}{tecplot};
                                  $props{$id}{cpl_lines2} = $props{$id}{cpl_lines};
                                  $props{$id}{cpl_files2} = $props{$id}{cpl_files};
                              } elsif ($src_type =~ /Contour/i) {
                                  $props{$id}{w2l_file2}  = $props{$id}{w2l_file};
                              } elsif ($src_type =~ /SurfTemp|VolTemp|FlowTemp/i) {
                                  $props{$id}{src_file2}  = $props{$id}{src_file};
                                  $props{$id}{src_lines2} = $props{$id}{src_lines};
                              }
                              $props{$id}{map_type}   = "parmdiff";
                              $props{$id}{src_type2}  = $props{$id}{src_type};
                              $props{$id}{parm2}      = $parm;
                              $props{$id}{parm2_sav}  = $parm;
                              $props{$id}{parm2_div}  = $parm_div;
                              $props{$id}{pdiv2_sav}  = $parm_div;
                              $props{$id}{ctype2}     = $conv_type;
                              $props{$id}{parm_units} = $units;
                              $props{$id}{data2}      = 0;

                              $w2tdmap_diff_menu->g_bind('<Destroy>', "");
                              $w2tdmap_diff_menu->g_destroy();
                              undef $w2tdmap_diff_menu;
                              &reset_bindings;

                              &make_w2_tdmap($canv, $id, 0);
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $w2tdmap_diff_menu->g_bind('<Destroy>', "");
                              $w2tdmap_diff_menu->g_destroy();
                              undef $w2tdmap_diff_menu;
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Do not delete graph if this menu is destroyed by other than the Cancel button
    $w2tdmap_diff_menu->g_bind('<Destroy>' => sub { undef $w2tdmap_diff_menu;
                                                    &reset_bindings;
                                                  });

    $f = $w2tdmap_diff_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "Parameter 2 will be subtracted from Parameter 1.",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew');
    $row++;
    $f->new_ttk__separator(
            -orient => 'horizontal',
            )->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew');
    $row++;
    $f->new_label(
            -text => "Parameter 1: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $f->new_label(
            -text => $parm1_txt,
            -font => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $row++;
    $f->new_label(
            -text => "Profile Stat: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $f->new_label(
            -text => $props{$id}{prof_stat},
            -font => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');

    $row++;
    $f->new_label(
            -text => "Parameter 2: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($parm_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    ($parm_cb = $parm_frame->new_ttk__combobox(
            -textvariable => \$parm,
            -values       => [ @parmlist ],
            -state        => 'readonly',
            -width        => $parm_chars,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $parm_cb->g_bind("<<ComboboxSelected>>",
                      sub { my ($i);
                            return if ($parm eq $oldparm);
                            $parm_short = $parm;
                            if ($parm =~ /^(Temperature|Tmax|Tmean|Tmin|TEMP)$/) {
                                if ($parm eq "Temperature" || $parm eq "TEMP") {
                                    $title = $parm1 . " minus Temperature, in ";
                                } elsif ($parm eq "Tmax") {
                                    $title = $parm1 . " minus Max Temperature, in ";
                                } elsif ($parm eq "Tmean") {
                                    $title = $parm1 . " minus Mean Temperature, in ";
                                } elsif ($parm eq "Tmin") {
                                    $title = $parm1 . " minus Min Temperature, in ";
                                }
                                if ($parm1 =~ /Temperature/) {
                                    $units  = "Celsius" if ($units !~ /(Celsius|Fahrenheit)/);
                                    $title .= "degrees " . $units;
                                    $units_cb->g_grid();
                                    $units_entry->g_grid_remove();
                                    $conv_type_na_label->g_grid();
                                    $custom_frame->g_grid_remove();
                                    $conv_type_cb->g_grid_remove();
                                    $conv_type = "None";
                                } else {
                                    $units_cb->g_grid_remove();
                                    $units_entry->g_grid();
                                    $conv_type_na_label->g_grid_remove();
                                    $custom_frame->g_grid() if ($conv_type eq "Custom");
                                    $conv_type_cb->g_grid();
                                }
                            } else {
                                $units = "";
                                $parm_short =~ s/\(ms-1\)//i;
                                $parm_short =~ s/\(m3s-1\)//i;
                                $parm_short =~ s/ [kmu]?g\/L\/day//i;
                                $parm_short =~ s/ [kmu]?g\/m2\/day//i;
                                $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
                                $parm_short =~ s/ [kmu]?g\/L//i;
                                $parm_short =~ s/ [kmu]?g\/m3//i;
                                $parm_short =~ s/ [kmu]?g\/m\^3//i;
                                $parm_short =~ s/, days//i;
                                $parm_short =~ s/ days//i;
                                $parm_short =~ s/,$//;
                                if (($parm  eq "Horizontal Velocity" || $parm  eq "Vertical Velocity") &&
                                    ($parm1 eq "Horizontal Velocity" || $parm1 eq "Vertical Velocity")) {
                                    $units = "m/s";
                                    $title = $parm1 . " minus " . $parm_short . ", in m/s";
                                } elsif ($parm eq "Density" && $parm1 eq "Density") {
                                    $units = "kg/m3";
                                    $title = $parm1 . " minus " . $parm_short . ", in kg/m3";
                                } else {
                                    $title = $parm1 . " minus " . $parm_short . ", in ";
                                }
                                $units_cb->g_grid_remove();
                                $units_entry->g_grid();
                                $conv_type_na_label->g_grid_remove();
                                $custom_frame->g_grid() if ($conv_type eq "Custom");
                                $conv_type_cb->g_grid();
                            }
                            if ($gtitle eq "") {
                                $gtitle = "Time/Distance Diff Map of $parm1 minus $parm_short";
                            } else {
                                if (index(lc($gtitle), lc($oldparm_short)) > -1) {
                                    $gtitle =~ s/$oldparm_short/$parm_short/i;
                                }
                            }
                            $old_units     = $units;
                            $oldparm       = $parm;
                            $oldparm_short = $parm_short;
                            @parm_divlist  = ("None");
                            for ($i=0; $i<=$#parms_list; $i++) {
                                next if ($parms_list[$i] eq "Horizontal Velocity"
                                         || $parms_list[$i] eq "Vertical Velocity"
                                         || $parms_list[$i] eq "Density"
                                         || $parms_list[$i] eq "Habitat");
                                if ($parm ne $parms_list[$i]) {
                                    push (@parm_divlist, $parms_list[$i]);
                                }
                            }
                            $parm_div_cb->configure(-values => [ @parm_divlist ]);
                            if (&list_match($parm_div, @parm_divlist) == -1) {
                                $parm_div = "None";
                            }
                            if ($parm =~ /^(Temperature|TEMP)$/ || $parm eq "Horizontal Velocity"
                                    || $parm eq "Vertical Velocity" || $parm eq "Density"
                                    || $parm eq "Habitat" || $#parm_divlist == 0) {
                                $parm_div_label->g_pack_forget();
                                $parm_div_cb->g_pack_forget();
                                $parm_div = "None";
                            } else {
                                $parm_div_label->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                                $parm_div_cb->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                            }
                          });
    ($parm_div_label = $parm_frame->new_label(
            -text => " divided by ",
            -font => 'default',
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    ($parm_div_cb = $parm_frame->new_ttk__combobox(
            -textvariable => \$parm_div,
            -values       => [ @parm_divlist ],
            -state        => 'readonly',
            -width        => $parm_chars,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Conversion: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($conv_type_na_label = $f->new_label(
            -text => "n/a",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $conv_type_na_label->g_grid_remove();
    ($conv_type_cb = $f->new_ttk__combobox(
            -textvariable => \$conv_type,
            -values       => [ @conv_types ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $conv_type_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($conv_type eq "Custom") {
                                $custom_frame->g_grid();
                            } else {
                                $custom_frame->g_grid_remove();
                            }
                          }
                      );
    $row++;
    ($custom_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $custom_frame->new_label(
            -text => "Multiply by: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_mult_entry = $custom_frame->new_entry(
            -textvariable => \$conv_mult,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_mult_entry->g_bind("<KeyRelease>",
                              sub { &numeric_entry_only($conv_mult_entry);
                                    my $chars = &max(7, length($conv_mult));
                                    $conv_mult_entry->configure(-width => $chars);
                                  });
    $custom_frame->new_label(
            -text => "  Then add: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_add_entry = $custom_frame->new_entry(
            -textvariable => \$conv_add,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_add_entry->g_bind("<KeyRelease>",
                             sub { &numeric_entry_only($conv_add_entry);
                                   my $chars = &max(7, length($conv_add));
                                   $conv_add_entry->configure(-width => $chars);
                                 });

    $row++;
    $f->new_label(
            -text => "Data Units: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($units_cb = $f->new_ttk__combobox(
            -textvariable => \$units,
            -values       => [ ("Celsius", "Fahrenheit") ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $units_cb->g_bind("<<ComboboxSelected>>",
                       sub { return if ($units eq $old_units);
                             $old_units = $units;
                             if ($units eq "Celsius") {
                                 if ($pmin ne "" && $pmin ne "." && $pmin ne "-") {
                                     $pmin = &floor(($pmin -32) /1.8);
                                 }
                                 if ($pmax ne "" && $pmax ne "." && $pmax ne "-") {
                                     $pmax = &ceil(($pmax  -32) /1.8);
                                 }
                             } elsif ($units eq "Fahrenheit") {
                                 if ($pmin ne "" && $pmin ne "." && $pmin ne "-") {
                                     $pmin = &floor($pmin *1.8 +32);
                                 }
                                 if ($pmax ne "" && $pmax ne "." && $pmax ne "-") {
                                     $pmax = &ceil($pmax  *1.8 +32);
                                 }
                             }
                             if ($parm eq "Temperature" || $parm eq "TEMP") {
                                 $title = $parm1 . " minus Temperature, in degrees " . $units;
                             } elsif ($parm eq "Tmax") {
                                 $title = $parm1 . " minus Max Temperature, in degrees " . $units;
                             } elsif ($parm eq "Tmean") {
                                 $title = $parm1 . " minus Mean Temperature, in degrees " . $units;
                             } elsif ($parm eq "Tmin") {
                                 $title = $parm1 . " minus Min Temperature, in degrees " . $units;
                             }
                           });
    $units_cb->g_grid_remove();
    ($units_entry = $f->new_entry(
            -textvariable => \$units,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $units_entry->g_bind("<KeyRelease>",
                         sub { my $chars = &max(7, length($units) +1);
                               $units_entry->configure(-width => $chars);
                               if ($parm =~ /^(Temperature|Tmax|Tmean|Tmin|TEMP)$/) {
                                   if ($parm eq "Temperature" || $parm eq "TEMP") {
                                       $title = $parm1 . " minus Temperature, in ";
                                   } elsif ($parm eq "Tmax") {
                                       $title = $parm1 . " minus Max Temperature, in ";
                                   } elsif ($parm eq "Tmean") {
                                       $title = $parm1 . " minus Mean Temperature, in ";
                                   } elsif ($parm eq "Tmin") {
                                       $title = $parm1 . " minus Min Temperature, in ";
                                   }
                               } else {
                                   $title = $parm1 . " minus " . $parm_short . ", in ";
                               }
                               $title .= $units;
                             });

    $row++;
    $f->new_label(
            -text => "Color Key Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$title,
            -font         => 'default',
            -width        => 40,
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Data Min: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmin_entry = $f->new_entry(
            -textvariable => \$pmin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmin_entry ]);

    $row++;
    $f->new_label(
            -text => "Data Max: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmax_entry = $f->new_entry(
            -textvariable => \$pmax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmax_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmax_entry ]);

    $row++;
    $f->new_label(
            -text => "Graph Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gtitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Graph Subtitle: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gstitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);

    if ($parm =~ /^(Temperature|TEMP)$/ || $parm eq "Horizontal Velocity" || $parm eq "Density"
                                        || $parm eq "Vertical Velocity" || $parm eq "Habitat"
                                        || $#parm_divlist == 0) {
        $parm_div_label->g_pack_forget();
        $parm_div_cb->g_pack_forget();
        $parm_div = "None";
    } else {
        $parm_div_label->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        $parm_div_cb->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    }
    if ($conv_type ne "Custom") {
        $custom_frame->g_grid_remove();
    }
    if ($parm =~ /^(Temperature|Tmax|Tmean|Tmin|TEMP)$/) {
        $units_cb->g_grid();
        $units_entry->g_grid_remove();
        $conv_type_na_label->g_grid();
        $custom_frame->g_grid_remove();
        $conv_type_cb->g_grid_remove();
        $conv_type = "None";
    } else {
        $units_cb->g_grid_remove();
        $units_entry->g_grid();
        $conv_type_na_label->g_grid_remove();
        $custom_frame->g_grid() if ($conv_type eq "Custom");
        $conv_type_cb->g_grid();
    }
    $f->g_grid_columnconfigure(2, -weight => 2);

    Tkx::wm_resizable($w2tdmap_diff_menu,0,0);
    &adjust_window_position($w2tdmap_diff_menu);
    $w2tdmap_diff_menu->g_focus;
}


sub setup_w2_tdmap_filediff {
    my ($canv, $id, $X, $Y) = @_;
    my (
        $add, $ctype, $ctype_txt, $f, $flowtemp_file, $frame, $geom,
        $gstitle, $gtitle, $i, $jb, $jw, $mult, $n, $nbr, $ok_btn,
        $oldsrc_type, $parm, $parm_div, $parm_txt, $pmax, $pmax_entry,
        $pmin, $pmin_entry, $row, $src_btn, $src_file, $src_label1,
        $src_label2, $src_lines, $src_text, $src_type, $src_type_cb,
        $surftemp_file, $title, $tol, $tol_frame, $txt, $voltemp_file,
        $w2l_file, $xtra_label,

        @brs, @cpl_files, @cpl_lines, @ds, @fr, @frv, @frv_label, @frv_on,
        @rbtn, @riv_files, @riv_freq, @riv_lines, @seg_limits, @td_filetypes,
        @tecplot, @us, @wbs,
       );

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($w2tdmap_diff_menu) && Tkx::winfo_exists($w2tdmap_diff_menu)) {
        if ($w2tdmap_diff_menu->g_wm_title() eq "W2 Time/Distance Difference Setup") {
            $w2tdmap_diff_menu->g_destroy();
            undef $w2tdmap_diff_menu;
        }
    }
    $w2tdmap_diff_menu = $main->new_toplevel();
    $w2tdmap_diff_menu->g_wm_transient($main);
    $w2tdmap_diff_menu->g_wm_title("W2 Time/Distance Difference Setup");
    $w2tdmap_diff_menu->configure(-cursor => $cursor_norm);
    $w2tdmap_diff_menu->g_wm_geometry($geom);

#   Try to keep the graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");
    &end_select($canv, $id, 1);

#   Initialize some variables.
    $parm       = $props{$id}{parm_sav};
    $parm_div   = $props{$id}{pdiv_sav};
    $ctype      = $props{$id}{ctype};
    $src_type   = $props{$id}{src_type};
    $pmin       = $gr_props{$id}{cs_min};
    $pmax       = $gr_props{$id}{cs_max};
    $gstitle    = $gr_props{$id}{gstitle};
    @wbs        = split(/,/, $props{$id}{wb_list});

    @us         = @{ $grid{$id}{us} };
    @ds         = @{ $grid{$id}{ds} };
    $nbr        = $grid{$id}{nbr};
    @seg_limits = split(/,|-/, $props{$id}{seg_list});
    @brs        = ();
    for ($i=0; $i<=$#seg_limits; $i+=2) {
        for ($jb=1; $jb<=$nbr; $jb++) {
            last if ($seg_limits[$i] >= $us[$jb] && $seg_limits[$i] <= $ds[$jb]);
        }
        push (@brs, $jb);
    }
    @brs = sort numerically @brs;

    $tol         = 10;
    @cpl_files   = @cpl_lines = @tecplot = @riv_files = @riv_lines = ();
    $src_text    = $src_type . ": ";
    $src_file    = "";
    $src_lines   = 0;
    $oldsrc_type = $src_type;
    $w2l_file    = $surftemp_file = $voltemp_file = $flowtemp_file = "";

    if ($props{$id}{prof_stat} eq "Surface value") {
        @td_filetypes = ("W2 Contour File", "W2 Vector File", "W2 RiverCon File", "W2 SurfTemp File");
    } elsif ($props{$id}{prof_stat} eq "Volume-weighted") {
        @td_filetypes = ("W2 Contour File", "W2 Vector File", "W2 VolTemp File");
    } elsif ($props{$id}{prof_stat} eq "Flow-weighted") {
        @td_filetypes = ("W2 FlowTemp File");
        $src_type = "W2 FlowTemp File";
    }
    for ($n=0; $n<=$#wbs; $n++) {
        $cpl_files[$n] = "          ";
        $cpl_lines[$n] = 0;
    }
    $ctype_txt = $ctype;
    if ($ctype =~ /^Custom/i) {
        (undef, $mult, $add) = split(/,/, $ctype);
        $ctype_txt = "Custom (mult by $mult, add $add)";
    }

    if ($parm !~ /^(Temperature|TEMP|Tmin|Tmean|Tmax)$/) {
        $parm =~ s/\(ms-1\)//i;
        $parm =~ s/\(m3s-1\)//i;
        $parm =~ s/ [kmu]?g\/L\/day//i;
        $parm =~ s/ [kmu]?g\/m2\/day//i;
        $parm =~ s/ [kmu]?g\/m\^2\/day//i;
        $parm =~ s/ [kmu]?g\/L//i;
        $parm =~ s/ [kmu]?g\/m3//i;
        $parm =~ s/ [kmu]?g\/m\^3//i;
        $parm =~ s/, days//i;
        $parm =~ s/ days//i;
        $parm =~ s/,$//;
    }
    if ($parm_div ne "None" && $parm_div !~ /^(Temperature|TEMP|Tmin|Tmean|Tmax)$/) {
        $parm_div =~ s/\(ms-1\)//i;
        $parm_div =~ s/\(m3s-1\)//i;
        $parm_div =~ s/ [kmu]?g\/L\/day//i;
        $parm_div =~ s/ [kmu]?g\/m2\/day//i;
        $parm_div =~ s/ [kmu]?g\/m\^2\/day//i;
        $parm_div =~ s/ [kmu]?g\/L//i;
        $parm_div =~ s/ [kmu]?g\/m3//i;
        $parm_div =~ s/ [kmu]?g\/m\^3//i;
        $parm_div =~ s/, days//i;
        $parm_div =~ s/ days//i;
        $parm_div =~ s/,$//;
    }
    if ($props{$id}{pdiv_sav} ne "None") {
        $parm_txt = $parm . " / " . $parm_div;
    } else {
        $parm_txt = $parm;
    }
    if ($props{$id}{parm_units} =~ /^(Celsius|Fahrenheit)$/) {
        $parm_txt .= ", in degrees " . $props{$id}{parm_units};
    } else {
        $parm_txt .= ", in " . $props{$id}{parm_units};
    }
    if ($parm =~ /^(Temperature|TEMP|Tmin|Tmean|Tmax)$/) {
        if ($parm eq "TEMP") {
            $parm = "Temperature";
        } elsif ($parm eq "Tmin") {
            $parm = "Min Temperature";
        } elsif ($parm eq "Tmean") {
            $parm = "Mean Temperature";
        } elsif ($parm eq "Tmax") {
            $parm = "Max Temperature";
        }
    }
    if ($parm_div =~ /^(Temperature|TEMP|Tmin|Tmean|Tmax)$/) {
        if ($parm_div eq "TEMP") {
            $parm_div = "Temperature";
        } elsif ($parm_div eq "Tmin") {
            $parm_div = "Min Temperature";
        } elsif ($parm_div eq "Tmean") {
            $parm_div = "Mean Temperature";
        } elsif ($parm_div eq "Tmax") {
            $parm_div = "Max Temperature";
        }
    }
    if ($props{$id}{pdiv_sav} ne "None") {
        $gtitle = "Time/Distance Diff Map of $parm / $parm_div";
        $title  = "$parm / $parm_div Difference, in ";
    } else {
        $gtitle = "Time/Distance Diff Map of $parm";
        $title  = "$parm Difference, in ";
    }
    if ($props{$id}{parm_units} =~ /^(Celsius|Fahrenheit)$/) {
        $title .= "degrees " . $props{$id}{parm_units};
    } else {
        $title .= $props{$id}{parm_units};
    }

#   Build the menu.
    $frame = $w2tdmap_diff_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -command => sub { my ($br_list, $label, $n, $rfreq, @tmp_files, @tmp_lines, @vals, %parms);
                              %parms = ();
                              if ($pmin eq "" || $pmax eq "") {
                                  return &pop_up_error($w2tdmap_diff_menu,
                                  "Please provide both a min and max for your data.");
                              }
                              if ($pmin >= $pmax) {
                                  return &pop_up_error($w2tdmap_diff_menu,
                                  "The minimum data value must be less than the maximum data value.");
                              }
                              if ($src_type =~ /Contour/i) {
                                  for ($n=0; $n<=$#wbs; $n++) {
                                      if ($cpl_files[$n] eq "" || $cpl_files[$n] eq "          "
                                                               || ! -e $cpl_files[$n]) {
                                          return &pop_up_error($w2tdmap_diff_menu,
                                          "W2 Contour file not set or does not exist:\n$cpl_files[$n]");
                                      }
                                  }
                                  $props{$id}{tecplot2}   = [ @tecplot   ];
                                  $props{$id}{cpl_lines2} = [ @cpl_lines ];
                                  $props{$id}{cpl_files2} = [ @cpl_files ];

                              } elsif ($src_type =~ /RiverCon/i) {
                                  for ($n=0; $n<=$#riv_files; $n++) {
                                      next if (! $frv_on[$n]);
                                      if ($riv_files[$n] eq "" || $riv_files[$n] eq "          "
                                                               || ! -e $riv_files[$n]) {
                                          return &pop_up_error($w2tdmap_diff_menu,
                                          "W2 River Contour file not set or does not exist:\n$riv_files[$n]");
                                      }
                                  }
                                  if ($#brs > 0) {
                                      $rfreq = -99;
                                      for ($n=0; $n<=$#brs; $n++) {
                                          next if (! $frv_on[$n]);
                                          if ($rfreq == -99) {
                                              $rfreq = $riv_freq[$n];
                                              next;
                                          }
                                          if ($rfreq != $riv_freq[$n]) {
                                              return &pop_up_error($w2tdmap_diff_menu,
                                                  "The W2 RiverCon output frequencies for the\n"
                                                . "chosen branches do not match. Please try again.");
                                          }
                                      }
                                  }
                                  @tmp_files = @riv_files;
                                  @tmp_lines = @riv_lines;
                                  @riv_files = @riv_lines = ();
                                  $br_list   = "";
                                  for ($n=0; $n<=$#brs; $n++) {
                                      next if (! $frv_on[$n]);
                                      push (@riv_files, $tmp_files[$n]);
                                      push (@riv_lines, $tmp_lines[$n]);
                                      $label = $frv_label[$n];
                                      if ($label =~ /,/) {
                                          $label =~ s/Branch //;
                                          @vals  = split(/,/, $label);
                                          @vals  = sort numerically @vals;
                                          $br_list .= $vals[0] . ",";
                                      } else {
                                          $br_list .= $brs[$n] . ",";
                                      }
                                  }
                                  $br_list =~ s/,$//;
                                  $props{$id}{br_list2}   = $br_list;
                                  $props{$id}{riv_lines2} = [ @riv_lines ];
                                  $props{$id}{riv_files2} = [ @riv_files ];

                              } else {
                                  if ($src_file eq "" || ! -e $src_file) {
                                      return &pop_up_error($w2tdmap_diff_menu,
                                          $src_type . " not set or does not exist:\n$src_file");
                                  }
                                  if ($src_type =~ /SurfTemp|VolTemp|FlowTemp/i) {
                                      $props{$id}{src_file2}  = $src_file;
                                      $props{$id}{src_lines2} = $src_lines;
                                  } else {
                                      $props{$id}{w2l_file2}  = $src_file;
                                  }
                              }
                              $title   =~ s/^\s+//;
                              $title   =~ s/\s+$//;
                              $gtitle  =~ s/^\s+//;
                              $gtitle  =~ s/\s+$//;
                              $gstitle =~ s/^\s+//;
                              $gstitle =~ s/\s+$//;

                              $parms{pmin}       = $pmin;
                              $parms{pmax}       = $pmax;
                              $parms{title}      = $title;
                              $parms{gtitle}     = $gtitle;
                              $parms{gstitle}    = $gstitle;
                              $parms{change}     = "";
                              $props{$id}{parms} = { %parms };

                              $props{$id}{map_type}  = "filediff";
                              $props{$id}{src_type2} = $src_type;
                              $props{$id}{match_tol} = $tol;
                              $props{$id}{parm2}     = $props{$id}{parm_sav};
                              $props{$id}{parm2_sav} = $props{$id}{parm_sav};
                              $props{$id}{parm2_div} = $props{$id}{pdiv_sav};
                              $props{$id}{pdiv2_sav} = $props{$id}{pdiv_sav};
                              $props{$id}{ctype2}    = $props{$id}{ctype};
                              $props{$id}{data2}     = 0;

                              $w2tdmap_diff_menu->g_bind('<Destroy>', "");
                              $w2tdmap_diff_menu->g_destroy();
                              undef $w2tdmap_diff_menu;
                              &reset_bindings;

                              &make_w2_tdmap($canv, $id, 0);
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $w2tdmap_diff_menu->g_bind('<Destroy>', "");
                              $w2tdmap_diff_menu->g_destroy();
                              undef $w2tdmap_diff_menu;
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Do not delete graph if this menu is destroyed by other than the Cancel button
    $w2tdmap_diff_menu->g_bind('<Destroy>' => sub { undef $w2tdmap_diff_menu;
                                                    &reset_bindings;
                                                  });

    $f = $w2tdmap_diff_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "Difference requires a 2nd model run with an identical grid.",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew');
    $row++;
    $f->new_ttk__separator(
            -orient => 'horizontal',
            )->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew');
    $row++;
    $f->new_label(
            -text => "Parameter: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $f->new_label(
            -text => $parm_txt,
            -font => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $row++;
    $f->new_label(
            -text => "Conversion: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -text => $ctype_txt,
            -font => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $row++;
    $f->new_label(
            -text => "Profile Stat: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $f->new_label(
            -text => $props{$id}{prof_stat},
            -font => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');

    $row++;
    $f->new_label(
            -text   => "W2 Source Type: ",
            -font   => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    if ($#td_filetypes == 0) {
        $f->new_label(
                -text => $src_type,
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    } else {
        ($src_type_cb = $f->new_ttk__combobox(
                -textvariable => \$src_type,
                -values       => [ @td_filetypes ],
                -width        => 17,
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $src_type_cb->g_bind("<<ComboboxSelected>>",
                              sub { my ($n, $nb, $ok, $status);
                                    return if ($src_type eq $oldsrc_type);
                                    if ($src_type =~ /Contour/i) {
                                        $src_label1->g_grid_remove();
                                        $src_label2->g_grid_remove();
                                        $src_btn->g_grid_remove();
                                        for ($n=0; $n<=$#brs; $n++) {
                                            $frv[$n]->g_grid_remove();
                                        }
                                        for ($n=0; $n<=$#wbs; $n++) {
                                            $fr[$n]->g_grid();
                                        }
                                        $xtra_label->g_grid() if ($#wbs > 0);
                                        $ok = 1;
                                        for ($n=0; $n<=$#wbs; $n++) {
                                            if ($cpl_files[$n] eq "          " ||
                                                $cpl_files[$n] eq "" || ! -e $cpl_files[$n]) {
                                                $ok = 0;
                                                last;
                                            }
                                        }
                                    } elsif ($src_type =~ /RiverCon/i) {
                                        $src_label1->g_grid_remove();
                                        $src_label2->g_grid_remove();
                                        $src_btn->g_grid_remove();
                                        for ($n=0; $n<=$#wbs; $n++) {
                                            $fr[$n]->g_grid_remove();
                                        }
                                        $nb = 0;
                                        for ($n=0; $n<=$#brs; $n++) {
                                            if ($frv_on[$n]) {
                                                $frv[$n]->g_grid();
                                                $nb++;
                                            }
                                        }
                                        $xtra_label->g_grid() if ($nb > 1);
                                        $ok = 1;
                                        for ($n=0; $n<=$#brs; $n++) {
                                            next if (! $frv_on[$n]);
                                            if ($riv_files[$n] eq "          " ||
                                                $riv_files[$n] eq "" || ! -e $riv_files[$n]) {
                                                $ok = 0;
                                                last;
                                            }
                                        }
                                    } else {
                                        $xtra_label->g_grid_remove();
                                        for ($n=0; $n<=$#wbs; $n++) {
                                            $fr[$n]->g_grid_remove();
                                        }
                                        for ($n=0; $n<=$#brs; $n++) {
                                            $frv[$n]->g_grid_remove();
                                        }
                                        $src_label1->g_grid();
                                        $src_label2->g_grid();
                                        $src_btn->g_grid();
                                        if ($src_type =~ /SurfTemp/) {
                                            $src_file = $surftemp_file;
                                        } elsif ($src_type =~ /VolTemp/) {
                                            $src_file = $voltemp_file;
                                        } elsif ($src_type =~ /FlowTemp/) {
                                            $src_file = $flowtemp_file;
                                        } elsif ($src_type =~ /Vector/i) {
                                            $src_file = $w2l_file;
                                        }
                                        $ok = 1;
                                        $ok = 0 if ($src_file eq "" || ! -e $src_file);
                                    }
                                    $oldsrc_type = $src_type;
                                    $src_text    = $src_type . ": ";
                                    $status      = ($ok) ? 'normal' : 'disabled';
                                    $ok_btn->configure(-state => $status);
                                  });
    }

#   Input fields for W2 Vector, SurfTemp, VolTemp, or FlowTemp file
    $row++;
    ($src_label1 = $f->new_label(
            -textvariable => \$src_text,
            -font         => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($src_label2 = $f->new_label(
            -textvariable => \$src_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
    ($src_btn = $f->new_button(
            -text    => "Browse",
            -command =>
               sub { my ($file, $ftype, $ok, $parm_mismatch, $parms_ref, $pdiv_mismatch, $status,
                         @src_parms);
                     $status = 'disabled';
                     if ($src_type =~ /Vector/i) {
                         $file = Tkx::tk___getOpenFile(
                                 -parent    => $w2tdmap_diff_menu,
                                 -title     => "Select W2 Vector File",
                                 -filetypes => [ ['W2L (W2 Vector)', '.w2l'],
                                                 ['All Files', '*'],
                                               ],
                                 );
                         if (defined($file) && -e $file) {
                             $src_file = File::Spec->rel2abs($file);
                             $status_line = "Scanning W2 vector file...";  # no progress bar needed
                             Tkx::update_idletasks();
                             ($ok, $parms_ref, undef, undef, undef)
                                 = &scan_w2_vector_file($w2tdmap_diff_menu, $src_file, $id, 0);
                             $status_line = "";
                             if ($ok ne "okay") {
                                 $src_file = $w2l_file = "";
                                 $ok_btn->configure(-state => 'disabled');
                                 return &pop_up_error($w2tdmap_diff_menu,
                                              "The specified file is not a W2 Vector (w2l) file:\n$file");
                             }
                             @src_parms = @{ $parms_ref };
                             $w2l_file  = $src_file;
                             $status    = 'normal';
                         }
                     } else {
                         $file = Tkx::tk___getOpenFile(
                                 -parent    => $w2tdmap_diff_menu,
                                 -title     => "Select " . $src_type,
                                 -filetypes => [ ['All Files', '*'],
                                                 ['Custom W2 *Temp Files', '*Temp.dat'],
                                                 ['Custom W2 *Temp2 Files', '*Temp2.dat'],
                                               ],
                                 );
                         if (defined($file) && -e $file) {
                             $src_file = File::Spec->rel2abs($file);
                             $status_line = "Scanning " . $src_type . "...";
                             Tkx::update_idletasks();
                             ($ftype, $src_lines, @src_parms)
                                 = &determine_ts_type($w2tdmap_diff_menu, $src_file, 1);
                             $status_line = "";
                             if ($ftype !~ /^W2 .*aily .*Temp2?\.dat format$/
                                   || ($src_type =~ /SurfTemp/ && $ftype !~ /SurfTemp/)
                                   || ($src_type =~ /VolTemp/  && $ftype !~ /VolTemp/)
                                   || ($src_type =~ /FlowTemp/ && $ftype !~ /FlowTemp/)) {
                                 $src_file  = "";
                                 $src_lines = 0;
                                 if ($src_type =~ /SurfTemp/) {
                                     $surftemp_file = "";
                                 } elsif ($src_type =~ /VolTemp/) {
                                     $voltemp_file  = "";
                                 } elsif ($src_type =~ /FlowTemp/) {
                                     $flowtemp_file = "";
                                 }
                                 $ok_btn->configure(-state => 'disabled');
                                 return &pop_up_error($w2tdmap_diff_menu,
                                              "The specified file is not a " . $src_type . ":\n$file");
                             }
                             if ($src_type =~ /SurfTemp/) {
                                 $surftemp_file = $src_file;
                             } elsif ($src_type =~ /VolTemp/) {
                                 $voltemp_file = $src_file;
                             } elsif ($src_type =~ /FlowTemp/) {
                                 $flowtemp_file = $src_file;
                             }
                             $status = 'normal';
                         }
                     }
                     $parm_mismatch = 0;
                     if ($props{$id}{parm_sav} =~ /^(Temperature|TEMP|Tmean)$/i) {
                         $parm_mismatch = 1 if (&list_match("Temperature", @src_parms) == -1 &&
                                                &list_match("TEMP",        @src_parms) == -1 &&
                                                &list_match("Tmean",       @src_parms) == -1);
                     } elsif ($props{$id}{parm_sav} =~ /^(Dissolved ?Oxygen|DO)$/i) {
                         $parm_mismatch = 1 if (&list_match("Dissolved Oxygen", @src_parms) == -1 &&
                                                &list_match("DissolvedOxygen",  @src_parms) == -1 &&
                                                &list_match("DO",               @src_parms) == -1);
                     } elsif (&list_match($props{$id}{parm_sav}, @src_parms) == -1) {
                         $parm_mismatch = 1;
                     }
                     $pdiv_mismatch = 0;
                     if ($props{$id}{pdiv_sav} ne "None") {
                         if ($props{$id}{pdiv_sav} =~ /^(Temperature|TEMP|Tmean)$/i) {
                             $pdiv_mismatch = 1 if (&list_match("Temperature", @src_parms) == -1 &&
                                                    &list_match("TEMP",        @src_parms) == -1 &&
                                                    &list_match("Tmean",       @src_parms) == -1);
                         } elsif ($props{$id}{pdiv_sav} =~ /^(Dissolved ?Oxygen|DO)$/i) {
                             $pdiv_mismatch = 1 if (&list_match("Dissolved Oxygen", @src_parms) == -1 &&
                                                    &list_match("DissolvedOxygen",  @src_parms) == -1 &&
                                                    &list_match("DO",               @src_parms) == -1);
                         } elsif (&list_match($props{$id}{pdiv_sav}, @src_parms) == -1) {
                             $pdiv_mismatch = 1;
                         }
                     }
                     if ($parm_mismatch || $pdiv_mismatch) {
                         $src_file  = "";
                         $src_lines = 0;
                         if ($src_type =~ /Vector/i) {
                             $w2l_file = "";
                         } elsif ($src_type =~ /SurfTemp/) {
                             $surftemp_file = "";
                         } elsif ($src_type =~ /VolTemp/) {
                             $voltemp_file  = "";
                         } elsif ($src_type =~ /FlowTemp/) {
                             $flowtemp_file = "";
                         }
                         $ok_btn->configure(-state => 'disabled');
                         if ($parm_mismatch) {
                             return &pop_up_error($w2tdmap_diff_menu,
                                                  "The specified file does not contain\n"
                                                . "the parameter of interest ("
                                                . $props{$id}{parm_sav} . "):\n$file");
                         } else {
                             return &pop_up_error($w2tdmap_diff_menu,
                                                  "The specified file does not contain\n"
                                                . "the parameter divisor of interest ("
                                                . $props{$id}{pdiv_sav} . "):\n$file");
                         }
                     }
                     $ok_btn->configure(-state => $status);
                   },
            ))->g_grid(-row => $row, -column => 2, -sticky => 'ew', -padx => 2, -pady => 2);

#   Loop over the required branches for River Contour file inputs
    for ($n=0; $n<=$#brs; $n++) {
        $riv_files[$n] = "          ";
        $frv_on[$n]    = 1;
        $frv_label[$n] = "Branch " . $brs[$n];

        $row++;
        ($frv[$n] = $f->new_labelframe(
                -borderwidth => 1,
                -relief      => 'groove',
                -text        => $frv_label[$n],
                ))->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew', -pady => 2);

        $frv[$n]->new_label(
                -text => "W2 RiverCon File: ",
                -font => 'default',
                )->g_grid(-row => 0, -column => 0, -sticky => 'e', -pady => 2);
        $frv[$n]->new_label(
                -textvariable => \$riv_files[$n],
                -anchor       => 'w',
                -font         => 'default',
                -background   => 'white',
                -relief       => 'sunken',
                -borderwidth  => 1,
                )->g_grid(-row => 0, -column => 1, -sticky => 'ew', -pady => 2);
        ($rbtn[$n] = $frv[$n]->new_button(
                -text    => "Browse",
                -command =>
                 [ sub { my ($n) = @_;
                         my (
                             $file, $ftype, $j, $jb1, $jb2, $meta, $mismatch, $nlines,
                             $nn, $nsegs, $ok, $parm, $pbar, $pbar_img,
                             $pbar_win, $status, $txt,
                            );

                         $file = Tkx::tk___getOpenFile(
                                 -parent    => $w2tdmap_diff_menu,
                                 -title     => "Select W2 RiverCon Output File",
                                 -filetypes => [ ['W2 RiverCon files', 'RiverContour_*.csv'],
                                                 ['All Files', '*'],
                                               ],
                                 );
                         if (defined($file) && -e $file) {
                             $riv_files[$n] = File::Spec->rel2abs($file);
                             ($pbar_win, $pbar, $pbar_img)
                                 = &create_alt_progress_bar($main, $id,
                                                            "Scanning W2 River Contour file...");
                             ($ftype, $parm, $meta, $nlines)
                                 = &scan_w2_rlcon_file($w2tdmap_diff_menu, $riv_files[$n], $pbar_img);
                             &destroy_progress_bar($main, $pbar_win);

                             $mismatch = 0;
                             if ($parm eq "Temperature") {
                                 $mismatch = 1 if ($props{$id}{parm_sav} !~ /^(Temperature|TEMP|Tmean)$/i);
                             } elsif ($parm eq "Dissolved Oxygen") {
                                 $mismatch = 1 if ($props{$id}{parm_sav} !~ /^(Dissolved ?Oxygen|DO)$/i);
                             }
                             if ($ftype !~ /rcon/ || $mismatch) {
                                 $riv_files[$n] = "          ";
                                 while ($frv_label[$n] =~ /,\d+$/) {
                                     $frv_label[$n] =~ s/,(\d+)//;
                                     $nn = &list_match($1, @brs);
                                     $frv_on[$nn]    = 1;
                                     $frv_label[$nn] = "Branch " . $brs[$nn];
                                     $frv[$nn]->configure(-text => $frv_label[$nn]);
                                     $frv[$nn]->g_grid();
                                 }
                                 $frv[$n]->configure(-text => $frv_label[$n]);
                                 $ok_btn->configure(-state => 'disabled');
                                 if ($ftype !~ /rcon/) {
                                     return &pop_up_error($w2tdmap_diff_menu,
                                             "Specified file is not a W2 River Contour output file:\n$file");
                                 } elsif ($mismatch) {
                                     return &pop_up_error($w2tdmap_diff_menu,
                                                          "The specified file does not contain\n"
                                                        . "the parameter of interest ("
                                                        . $props{$id}{parm_sav} . "):\n$file");
                                 }
                             }
                             ($jb1, $nsegs, $riv_freq[$n]) = split(/_/, $meta);
                             $jb2 = $jb1;
                             for ($j=$jb1; $j<=$nbr; $j++) {
                                 last if ($nsegs <= $ds[$j] -$us[$j] +1);
                                 $jb2++;
                                 $nsegs -= $ds[$j] -$us[$j] +1;
                             }
                             if ($brs[$n] < $jb1 || $brs[$n] > $jb2) {
                                 $riv_files[$n] = "          ";
                                 while ($frv_label[$n] =~ /,\d+$/) {
                                     $frv_label[$n] =~ s/,(\d+)//;
                                     $nn = &list_match($1, @brs);
                                     $frv_on[$nn]    = 1;
                                     $frv_label[$nn] = "Branch " . $brs[$nn];
                                     $frv[$nn]->configure(-text => $frv_label[$nn]);
                                     $frv[$nn]->g_grid();
                                 }
                                 $frv[$n]->configure(-text => $frv_label[$n]);
                                 $ok_btn->configure(-state => 'disabled');
                                 $txt = ($jb2 == $jb1) ? $jb1 : $jb1 . "-" . $jb2;
                                 return &pop_up_error($w2tdmap_diff_menu,
                                           "The specified W2 River Contour file\n"
                                         . "does not include the correct branch:\n"
                                         . "(" . $txt . " rather than " . $brs[$n] . "):\n$file");
                             }
                             $frv_label[$n] = "Branch " . $brs[$n];
                             if ($jb2 > $jb1) {
                                 for ($j=$jb1; $j<=$jb2; $j++) {
                                     $nn = &list_match($j, @brs);
                                     if ($nn >= 0 && $brs[$nn] != $brs[$n]) {
                                         $frv_label[$n] .= "," . $brs[$nn];
                                         $frv_on[$nn]    = 0;
                                         $frv_label[$nn] = "Branch " . $brs[$nn];
                                         $frv[$nn]->configure(-text => $frv_label[$nn]);
                                         $frv[$nn]->g_grid_remove();
                                     }
                                 }
                                 $frv[$n]->configure(-text => $frv_label[$n]);
                             }
                             $riv_lines[$n] = $nlines;

                             $ok = 1;
                             for ($j=0; $j<=$#brs; $j++) {
                                 next if (! $frv_on[$j]);
                                 if ($riv_files[$j] eq "          " ||
                                     $riv_files[$j] eq "" || ! -e $riv_files[$j]) {
                                     $ok = 0;
                                     last;
                                 }
                             }
                             $status = ($ok) ? 'normal' : 'disabled';
                             $ok_btn->configure(-state => $status);
                         } else {
                             $ok_btn->configure(-state => 'disabled');
                         }
                       }, $n ],
                ))->g_grid(-row => 0, -column => 2, -sticky => 'ew', -padx => 2, -pady => 2);

        $frv[$n]->g_grid_columnconfigure(1, -weight => 2);
    }

#   Loop over the required waterbodies and set up inputs for contour files
    for ($n=0; $n<=$#wbs; $n++) {
        $jw = $wbs[$n];
        $cpl_files[$n] = "          ";

        $row++;
        ($fr[$n] = $f->new_labelframe(
                -borderwidth => 1,
                -relief      => 'groove',
                -text        => "Waterbody $jw",
                ))->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew', -pady => 2);

        $fr[$n]->new_label(
                -text => "W2 Contour File: ",
                -font => 'default',
                )->g_grid(-row => 0, -column => 0, -sticky => 'e', -pady => 2);
        $fr[$n]->new_label(
                -textvariable => \$cpl_files[$n],
                -anchor       => 'w',
                -font         => 'default',
                -background   => 'white',
                -relief       => 'sunken',
                -borderwidth  => 1,
                )->g_grid(-row => 0, -column => 1, -sticky => 'ew', -pady => 2);
        $fr[$n]->new_button(
                -text    => "Browse",
                -command =>
                 [ sub { my ($n) = @_;
                         my ($file, $i, $jw_src, $nlines, $ok, $parm_mismatch, $parms_ref, $pbar,
                             $pbar_img, $pbar_win, $pdiv_mismatch, $status, $tecplot, @parms,
                            );
                         $file = Tkx::tk___getOpenFile(
                                 -parent    => $w2tdmap_diff_menu,
                                 -title     => "Select W2 Contour Output File",
                                 -filetypes => [ ['All Files', '*'],
                                                 ['CSV (comma delimited)', '.csv'],
                                                 ['OPT (W2 output files)', '.opt'],
                                               ],
                                 );
                         if (defined($file) && -e $file) {
                             $cpl_files[$n] = File::Spec->rel2abs($file);
                             ($pbar_win, $pbar, $pbar_img)
                                 = &create_alt_progress_bar($main, $id, "Scanning W2 contour file...");
                             ($tecplot, $nlines, $jw_src, $parms_ref, undef, undef)
                                 = &scan_w2_cpl_file($w2tdmap_diff_menu, $cpl_files[$n], $id, 0, $pbar_img);
                             &destroy_progress_bar($main, $pbar_win);

                             if ($tecplot == -1) {
                                 $cpl_files[$n] = "          ";
                                 $ok_btn->configure(-state => 'disabled');
                                 return &pop_up_error($w2tdmap_diff_menu,
                                     "Specified file is not a W2 Contour output file:\n$file");
                             }
                             if ($tecplot == 0 && $jw_src != $wbs[$n]) {
                                 $cpl_files[$n] = "          ";
                                 $ok_btn->configure(-state => 'disabled');
                                 return &pop_up_error($w2tdmap_diff_menu,
                                         "The specified W2 Contour output file does not\n"
                                       . "appear to be from the correct waterbody:\n"
                                       . "(" . $jw_src . " rather than " . $wbs[$n] . "):\n$file");
                             }
                             @parms = @{ $parms_ref };

                             $parm_mismatch = 0;
                             if ($props{$id}{parm_sav} =~ /^(Temperature|TEMP|Tmean)$/i) {
                                 $parm_mismatch = 1 if (&list_match("Temperature", @parms) == -1 &&
                                                        &list_match("TEMP",        @parms) == -1 &&
                                                        &list_match("Tmean",       @parms) == -1);
                             } elsif ($props{$id}{parm_sav} =~ /^(Dissolved ?Oxygen|DO)$/i) {
                                 $parm_mismatch = 1 if (&list_match("Dissolved Oxygen", @parms) == -1 &&
                                                        &list_match("DissolvedOxygen",  @parms) == -1 &&
                                                        &list_match("DO",               @parms) == -1);
                             } elsif (&list_match($props{$id}{parm_sav}, @parms) == -1) {
                                 $parm_mismatch = 1;
                             }
                             $pdiv_mismatch = 0;
                             if ($props{$id}{pdiv_sav} ne "None") {
                                 if ($props{$id}{pdiv_sav} =~ /^(Temperature|TEMP|Tmean)$/i) {
                                     $pdiv_mismatch = 1 if (&list_match("Temperature", @parms) == -1 &&
                                                            &list_match("TEMP",        @parms) == -1 &&
                                                            &list_match("Tmean",       @parms) == -1);
                                 } elsif ($props{$id}{pdiv_sav} =~ /^(Dissolved ?Oxygen|DO)$/i) {
                                     $pdiv_mismatch = 1 if (&list_match("Dissolved Oxygen", @parms) == -1 &&
                                                            &list_match("DissolvedOxygen",  @parms) == -1 &&
                                                            &list_match("DO",               @parms) == -1);
                                 } elsif (&list_match($props{$id}{pdiv_sav}, @parms) == -1) {
                                     $pdiv_mismatch = 1;
                                 }
                             }
                             if ($parm_mismatch || $pdiv_mismatch) {
                                 $cpl_files[$n] = "          ";
                                 $cpl_lines[$n] = 0;
                                 $ok_btn->configure(-state => 'disabled');
                                 if ($parm_mismatch) {
                                     return &pop_up_error($w2tdmap_diff_menu,
                                                          "The specified file does not contain\n"
                                                        . "the parameter of interest ("
                                                        . $props{$id}{parm_sav} . "):\n$file");
                                 } else {
                                     return &pop_up_error($w2tdmap_diff_menu,
                                                          "The specified file does not contain\n"
                                                        . "the parameter divisor of interest ("
                                                        . $props{$id}{pdiv_sav} . "):\n$file");
                                 }
                             }
                             $tecplot[$n]   = $tecplot;
                             $cpl_lines[$n] = $nlines;

                             $ok = 1;
                             for ($i=0; $i<=$#wbs; $i++) {
                                 if ($cpl_files[$i] eq "          " ||
                                     $cpl_files[$i] eq "" || ! -e $cpl_files[$i]) {
                                     $ok = 0;
                                     last;
                                 }
                             }
                             $status = ($ok) ? 'normal' : 'disabled';
                             $ok_btn->configure(-state => $status);
                         } else {
                             $ok_btn->configure(-state => 'disabled');
                         }
                       }, $n ],
                )->g_grid(-row => 0, -column => 2, -sticky => 'ew', -padx => 2, -pady => 2);

        $fr[$n]->g_grid_columnconfigure(1, -weight => 2);
    }

    $row++;
    $f->new_label(
            -text => "Match Tolerance: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($tol_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $tol_frame->new_spinbox(
            -textvariable => \$tol,
            -state        => 'readonly',
            -font         => 'default',
            -from         => 0,
            -to           => 60,
            -increment    => 1,
            -width        => 3,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $tol_frame->new_label(
            -text => " minutes",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');

    $row++;
    $f->new_label(
            -text => "Color Key Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$title,
            -font         => 'default',
            -width        => 40,
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Data Min: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmin_entry = $f->new_entry(
            -textvariable => \$pmin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmin_entry ]);

    $row++;
    $f->new_label(
            -text => "Data Max: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmax_entry = $f->new_entry(
            -textvariable => \$pmax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmax_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmax_entry ]);

    $row++;
    $f->new_label(
            -text => "Graph Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gtitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Graph Subtitle: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gstitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);

    $row++;
    $txt = "Note that this program works best when each of the W2 output files\n"
         . "has the same output dates and output frequencies. In addition,\n"
         . "each is required to include data for the parameter being plotted.";
    ($xtra_label = $f->new_label(
            -text    => $txt,
            -font    => 'default',
            -justify => 'left',
            ))->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew', -pady => 2);
    $xtra_label->g_grid_remove();

    if ($src_type =~ /Contour/i) {
        $src_label1->g_grid_remove();
        $src_label2->g_grid_remove();
        $src_btn->g_grid_remove();
        for ($n=0; $n<=$#brs; $n++) {
            $frv[$n]->g_grid_remove();
        }
        $xtra_label->g_grid() if ($#wbs > 0);
    } elsif ($src_type =~ /RiverCon/i) {
        $src_label1->g_grid_remove();
        $src_label2->g_grid_remove();
        $src_btn->g_grid_remove();
        for ($n=0; $n<=$#wbs; $n++) {
            $fr[$n]->g_grid_remove();
        }
        $xtra_label->g_grid() if ($#brs > 1);
    } else {
        for ($n=0; $n<=$#wbs; $n++) {
            $fr[$n]->g_grid_remove();
        }
        for ($n=0; $n<=$#brs; $n++) {
            $frv[$n]->g_grid_remove();
        }
    }
    $f->g_grid_columnconfigure(1, -weight => 2);

    Tkx::wm_resizable($w2tdmap_diff_menu,0,0);
    &adjust_window_position($w2tdmap_diff_menu);
    $w2tdmap_diff_menu->g_focus;
}


sub undo_w2_tdmap_diffs {
    my ($canv, $id, $X, $Y) = @_;
    my (
        $f, $frame, $geom, $gstitle, $gtitle, $ok_btn, $parm_txt, $pmax,
        $pmax_entry, $pmin, $pmin_entry, $row, $title,
       );

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($w2tdmap_undo_menu) && Tkx::winfo_exists($w2tdmap_undo_menu)) {
        if ($w2tdmap_undo_menu->g_wm_title() eq "W2 Time/Distance Map - Undo Difference") {
            $w2tdmap_undo_menu->g_destroy();
            undef $w2tdmap_undo_menu;
        }
    }
    $w2tdmap_undo_menu = $main->new_toplevel();
    $w2tdmap_undo_menu->g_wm_transient($main);
    $w2tdmap_undo_menu->g_wm_title("W2 Time/Distance Map - Undo Difference");
    $w2tdmap_undo_menu->configure(-cursor => $cursor_norm);
    $w2tdmap_undo_menu->g_wm_geometry($geom);

#   Try to keep the graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");
    &end_select($canv, $id, 1);

#   Initialize some variables.
    $pmin    = $gr_props{$id}{cs_min};
    $pmax    = $gr_props{$id}{cs_max};
    $title   = $gr_props{$id}{keytitle};
    $gtitle  = $gr_props{$id}{gtitle};
    $gstitle = $gr_props{$id}{gstitle};
    $gtitle =~ s/Diff Map/Map/;
    $gtitle =~ s/minus .*$//;
    $gtitle =~ s/  / /;
    $title  =~ s/minus \w+//;
    $title  =~ s/  / /;
    $title  =~ s/Temperature Temperature/Temperature/;

    if ($props{$id}{pdiv_sav} ne "None") {
        $parm_txt = $props{$id}{parm_sav} . " / " . $props{$id}{pdiv_sav};
    } else {
        $parm_txt = $props{$id}{parm_sav};
    }
    if ($props{$id}{parm_units} =~ /^(Celsius|Fahrenheit)$/) {
        $parm_txt .= ", in degrees " . $props{$id}{parm_units};
    } else {
        $parm_txt .= ", in " . $props{$id}{parm_units};
    }

#   Build the menu.
    $frame = $w2tdmap_undo_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -command => sub { my (%parms);
                              %parms = ();
                              if ($pmin eq "" || $pmax eq "") {
                                  return &pop_up_error($w2tdmap_undo_menu,
                                  "Please provide both a min and max for your data.");
                              }
                              if ($pmin >= $pmax) {
                                  return &pop_up_error($w2tdmap_undo_menu,
                                  "The minimum data value must be less than the maximum data value.");
                              }
                              $title   =~ s/^\s+//;
                              $title   =~ s/\s+$//;
                              $gtitle  =~ s/^\s+//;
                              $gtitle  =~ s/\s+$//;
                              $gstitle =~ s/^\s+//;
                              $gstitle =~ s/\s+$//;

                              $parms{pmin}          = $pmin;
                              $parms{pmax}          = $pmax;
                              $parms{title}         = $title;
                              $parms{gtitle}        = $gtitle;
                              $parms{gstitle}       = $gstitle;
                              $parms{change}        = "";
                              $props{$id}{parms}    = { %parms };
                              $props{$id}{map_type} = "standard";
                              $props{$id}{data}     = 0;

                              $w2tdmap_undo_menu->g_bind('<Destroy>', "");
                              $w2tdmap_undo_menu->g_destroy();
                              undef $w2tdmap_undo_menu;
                              &reset_bindings;

                              &make_w2_tdmap($canv, $id, 0);
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $w2tdmap_undo_menu->g_bind('<Destroy>', "");
                              $w2tdmap_undo_menu->g_destroy();
                              undef $w2tdmap_undo_menu;
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Do not delete graph if this menu is destroyed by other than the Cancel button
    $w2tdmap_undo_menu->g_bind('<Destroy>' => sub { undef $w2tdmap_undo_menu;
                                                    &reset_bindings;
                                                  });

    $f = $w2tdmap_undo_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "Removing Parameter 2 and Parameter Difference.",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -columnspan => 2, -sticky => 'ew');
    $row++;
    $f->new_ttk__separator(
            -orient => 'horizontal',
            )->g_grid(-row => $row, -column => 0, -columnspan => 2, -sticky => 'ew');
    $row++;
    $f->new_label(
            -text => "Parameter: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $f->new_label(
            -text => $parm_txt,
            -font => 'default',
            )->g_grid(-row => $row, -column => 1, -sticky => 'w');
    $row++;
    $f->new_label(
            -text => "Profile Stat: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $f->new_label(
            -text => $props{$id}{prof_stat},
            -font => 'default',
            )->g_grid(-row => $row, -column => 1, -sticky => 'w');

    $row++;
    $f->new_label(
            -text => "Data Min: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmin_entry = $f->new_entry(
            -textvariable => \$pmin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmin_entry ]);

    $row++;
    $f->new_label(
            -text => "Data Max: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmax_entry = $f->new_entry(
            -textvariable => \$pmax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmax_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmax_entry ]);

    $row++;
    $f->new_label(
            -text => "Color Key Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$title,
            -font         => 'default',
            -width        => 45,
            )->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Graph Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gtitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Graph Subtitle: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gstitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);

    $f->g_grid_columnconfigure(1, -weight => 2);

    Tkx::wm_resizable($w2tdmap_undo_menu,0,0);
    &adjust_window_position($w2tdmap_undo_menu);
    $w2tdmap_undo_menu->g_focus;
}


sub reverse_w2_tdmap_diffs {
    my ($canv, $id, $X, $Y) = @_;
    my (
        $f, $frame, $geom, $gstitle, $gtitle, $ok_btn, $parm_txt, $parm2_txt,
        $pmax, $pmax_entry, $pmin, $pmin_entry, $row, $title, $txt,
       );

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($w2tdmap_rev_menu) && Tkx::winfo_exists($w2tdmap_rev_menu)) {
        if ($w2tdmap_rev_menu->g_wm_title() eq "W2 Time/Distance Map - Reverse Difference") {
            $w2tdmap_rev_menu->g_destroy();
            undef $w2tdmap_rev_menu;
        }
    }
    $w2tdmap_rev_menu = $main->new_toplevel();
    $w2tdmap_rev_menu->g_wm_transient($main);
    $w2tdmap_rev_menu->g_wm_title("W2 Time/Distance Map - Reverse Difference");
    $w2tdmap_rev_menu->configure(-cursor => $cursor_norm);
    $w2tdmap_rev_menu->g_wm_geometry($geom);

#   Try to keep the graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");
    &end_select($canv, $id, 1);

#   Initialize some variables.
    $pmin    = $gr_props{$id}{cs_max} * -1.0;
    $pmax    = $gr_props{$id}{cs_min} * -1.0;
    $title   = $gr_props{$id}{keytitle};
    $gtitle  = $gr_props{$id}{gtitle};
    $gstitle = $gr_props{$id}{gstitle};
    if ($title =~ /\w+ minus \w+/) {
        $title =~ s/(\w+) minus (\w+)/$2 minus $1/;
    }
    if ($gtitle =~ /\w+ minus \w+/) {
        $gtitle =~ s/(\w+) minus (\w+)/$2 minus $1/;
    }
    if ($gstitle =~ /\w+ minus \w+/) {
        $gstitle =~ s/(\w+) minus (\w+)/$2 minus $1/;
    }

    if ($props{$id}{pdiv_sav} ne "None") {
        $parm_txt = $props{$id}{parm_sav} . " / " . $props{$id}{pdiv_sav};
    } else {
        $parm_txt = $props{$id}{parm_sav};
    }
    if ($props{$id}{map_type} eq "parmdiff") {
        if ($props{$id}{pdiv2_sav} ne "None") {
            $parm2_txt = $props{$id}{parm2_sav} . " / " . $props{$id}{pdiv2_sav};
        } else {
            $parm2_txt = $props{$id}{parm2_sav};
        }
        if ($props{$id}{swap_order}) {
            $parm_txt = $parm_txt . " minus " . $parm2_txt;
        } else {
            $parm_txt = $parm2_txt . " minus " . $parm_txt;
        }
    }

#   Build the menu.
    $frame = $w2tdmap_rev_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -command => sub { my ( %parms);
                              %parms = ();
                              if ($pmin eq "" || $pmax eq "") {
                                  return &pop_up_error($w2tdmap_rev_menu,
                                  "Please provide both a min and max for your data.");
                              }
                              if ($pmin >= $pmax) {
                                  return &pop_up_error($w2tdmap_rev_menu,
                                  "The minimum data value must be less than the maximum data value.");
                              }
                              $title   =~ s/^\s+//;
                              $title   =~ s/\s+$//;
                              $gtitle  =~ s/^\s+//;
                              $gtitle  =~ s/\s+$//;
                              $gstitle =~ s/^\s+//;
                              $gstitle =~ s/\s+$//;

                              $parms{pmin}            = $pmin;
                              $parms{pmax}            = $pmax;
                              $parms{title}           = $title;
                              $parms{gtitle}          = $gtitle;
                              $parms{gstitle}         = $gstitle;
                              $parms{change}          = "";
                              $props{$id}{parms}      = { %parms };
                              $props{$id}{data}       = 0;
                              $props{$id}{data2}      = 0;
                              $props{$id}{swap_order} = ($props{$id}{swap_order}) ? 0 : 1;

                              $w2tdmap_rev_menu->g_bind('<Destroy>', "");
                              $w2tdmap_rev_menu->g_destroy();
                              undef $w2tdmap_rev_menu;
                              &reset_bindings;

                              &make_w2_tdmap($canv, $id, 0);
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $w2tdmap_rev_menu->g_bind('<Destroy>', "");
                              $w2tdmap_rev_menu->g_destroy();
                              undef $w2tdmap_rev_menu;
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Do not delete graph if this menu is destroyed by other than the Cancel button
    $w2tdmap_rev_menu->g_bind('<Destroy>' => sub { undef $w2tdmap_rev_menu;
                                                   &reset_bindings;
                                                 });

    $f = $w2tdmap_rev_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "Swapping the Parameter Difference Order.",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -columnspan => 2, -sticky => 'ew');
    $row++;
    $f->new_ttk__separator(
            -orient => 'horizontal',
            )->g_grid(-row => $row, -column => 0, -columnspan => 2, -sticky => 'ew');
    $row++;
    if ($props{$id}{map_type} eq "parmdiff") {
        $txt = "Difference: ";
    } else {
        $txt = "Parameter: ";
    }
    $f->new_label(
            -text => $txt,
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $f->new_label(
            -text => $parm_txt,
            -font => 'default',
            )->g_grid(-row => $row, -column => 1, -sticky => 'w');
    $row++;
    $f->new_label(
            -text => "Units: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $f->new_label(
            -text => $props{$id}{parm_units},
            -font => 'default',
            )->g_grid(-row => $row, -column => 1, -sticky => 'w');
    $row++;
    $f->new_label(
            -text => "Profile Stat: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $f->new_label(
            -text => $props{$id}{prof_stat},
            -font => 'default',
            )->g_grid(-row => $row, -column => 1, -sticky => 'w');

    $row++;
    $f->new_label(
            -text => "Data Min: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmin_entry = $f->new_entry(
            -textvariable => \$pmin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmin_entry ]);

    $row++;
    $f->new_label(
            -text => "Data Max: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmax_entry = $f->new_entry(
            -textvariable => \$pmax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmax_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmax_entry ]);

    $row++;
    $f->new_label(
            -text => "Color Key Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$title,
            -font         => 'default',
            -width        => 45,
            )->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Graph Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gtitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Graph Subtitle: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gstitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);

    $f->g_grid_columnconfigure(1, -weight => 2);

    Tkx::wm_resizable($w2tdmap_rev_menu,0,0);
    &adjust_window_position($w2tdmap_rev_menu);
    $w2tdmap_rev_menu->g_focus;
}


sub change_w2_tdmap {
    my ($canv, $id, $X, $Y, $change) = @_;
    my (
        $byear, $byear_cb, $conv_add, $conv_add_entry, $conv_mult,
        $conv_mult_entry, $conv_type, $conv_type_cb, $conv_type_na_label,
        $custom_frame, $f, $frame, $ftype, $geom, $gstitle, $gtitle, $i,
        $jd_skip, $jd_skip_active, $jd_skip_explain, $jd_skip_frame, $jw,
        $n, $ntsr, $offset_frame, $ok, $ok_btn, $old_units, $oldparm,
        $oldparm_short, $p, $parm, $parm_cb, $parm_chars, $parm_div,
        $parm_div_cb, $parm_div_label, $parm_frame, $parm_short, $parm2,
        $parms_ref, $pmax, $pmax_entry, $pmin, $pmin_entry, $prof_stat,
        $row, $src_type, $tecplot, $title, $tz_offset, $units, $units_cb,
        $units_entry, $yr_max, $yr_min,

        @cpl_files, @cplf, @jd_skip_opts, @ncpl, @nvpl, @parm_divlist,
        @parm_tmp, @parmlist, @parmlist4div, @parms, @tsrf, @vplf, @wbs,
       );

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($w2tdmap_mod_menu) && Tkx::winfo_exists($w2tdmap_mod_menu)) {
        if ($w2tdmap_mod_menu->g_wm_title() eq "Modify W2 Time/Distance Map") {
            $w2tdmap_mod_menu->g_destroy();
            undef $w2tdmap_mod_menu;
        }
    }
    $w2tdmap_mod_menu = $main->new_toplevel();
    $w2tdmap_mod_menu->g_wm_transient($main);
    $w2tdmap_mod_menu->g_wm_title("Modify W2 Time/Distance Map");
    $w2tdmap_mod_menu->configure(-cursor => $cursor_norm);
    $w2tdmap_mod_menu->g_wm_geometry($geom);

#   Try to keep the graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

#   De-select graph if it already exists
    if (defined($props{$id}{oldcoords})) {
        &end_select($canv, $id, 1);
    }

#   Initialize some variables.
    @ncpl      = @{ $grid{$id}{ncpl} };
    @cplf      = @{ $grid{$id}{cplf} };
    @nvpl      = @{ $grid{$id}{nvpl} };
    @vplf      = @{ $grid{$id}{vplf} };
    $ntsr      = $grid{$id}{ntsr};
    @tsrf      = @{ $grid{$id}{tsrf} };

    $src_type  = $props{$id}{src_type};
    $parm      = $props{$id}{parm_sav};
    $parm_div  = $props{$id}{pdiv_sav};
    $prof_stat = $props{$id}{prof_stat};
    $units     = $props{$id}{parm_units};
    $conv_type = $props{$id}{ctype};
    $byear     = $props{$id}{byear};
    $tz_offset = $props{$id}{tz_offset};
    $jd_skip   = $props{$id}{jd_skip};
    @wbs       = split(/,/, $props{$id}{wb_list});

    $pmin      = $gr_props{$id}{cs_min};
    $pmax      = $gr_props{$id}{cs_max};
    $title     = $gr_props{$id}{keytitle};
    $gtitle    = $gr_props{$id}{gtitle};
    $gstitle   = $gr_props{$id}{gstitle};

    if ($conv_type =~ /^Custom/i) {
        ($conv_type, $conv_mult, $conv_add) = split(/,/, $conv_type);
    } else {
        $conv_mult = 1.0;
        $conv_add  = 0.0;
    }
    $yr_max = (localtime(time))[5] +1900;
    $yr_min = ($byear > $yr_max -25) ? $yr_max -25 : $byear -10;

    if ($src_type =~ /Contour/i) {
        @cpl_files = @{ $props{$id}{cpl_files} };
        for ($n=0; $n<=$#wbs; $n++) {
            ($tecplot, undef, undef, $parms_ref, undef, undef)
                  = &scan_w2_cpl_file($w2tdmap_mod_menu, $cpl_files[$n], $id, 0, "");
            if ($tecplot == -1) {
                return &pop_up_error($w2tdmap_mod_menu,
                                     "The source file is not a W2 Contour file:\n$cpl_files[$n]");
            }
            @parms = @{ $parms_ref };
            if ($n == 0) {
                @parmlist = @parms;
            } else {                # only keep parameters common to all cpl files
                @parm_tmp = ();
                foreach $p ( @parms ) {
                    if (&list_match($p, @parmlist) >= 0) {
                        push (@parm_tmp, $p);
                    }
                }
                @parmlist = @parm_tmp;
            }
        }
    } elsif ($src_type =~ /Vector/i) {
        ($ok, $parms_ref, undef, undef, undef)
                  = &scan_w2_vector_file($w2tdmap_mod_menu, $props{$id}{w2l_file}, $id, 0);
        if ($ok ne "okay") {
            return &pop_up_error($w2tdmap_mod_menu,
                                 "The source file is not a W2 Vector (w2l) file:\n$props{$id}{w2l_file}");
        }
        @parmlist = @{ $parms_ref };
    } elsif ($src_type =~ /SurfTemp|VolTemp|FlowTemp/i) {
        ($ftype, undef, @parmlist) = &determine_ts_type($w2tdmap_mod_menu, $props{$id}{src_file}, 1);
    }
    @parmlist4div = @parmlist;
    if ($props{$id}{map_type} eq "parmdiff") {
        @parm_tmp = @parmlist;
        @parmlist = ();
        for ($i=0; $i<=$#parm_tmp; $i++) {
            if ($parm_tmp[$i] ne $props{$id}{parm2_sav}) {
                push (@parmlist, $parm_tmp[$i]);
            }
        }
        if ($#parmlist <= 0) {
            $w2tdmap_mod_menu->g_destroy();
            undef $w2tdmap_mod_menu;
            &reset_bindings;
            return &pop_up_error($main, "Insufficient parameters to modify parameter difference. Aborting.");
        }
        $parm2 = $props{$id}{parm2_sav};
        if ($parm2 =~ /^(Temperature|TEMP|Tmin|Tmean|Tmax)$/) {
            if ($parm2 eq "TEMP") {
                $parm2 = "Temperature";
            } elsif ($parm2 eq "Tmax") {
                $parm2 = "Max Temperature";
            } elsif ($parm2 eq "Tmean") {
                $parm2 = "Mean Temperature";
            } elsif ($parm2 eq "Tmin") {
                $parm2 = "Min Temperature";
            }
        } else {
            $parm2 =~ s/\(ms-1\)//i;
            $parm2 =~ s/\(m3s-1\)//i;
            $parm2 =~ s/ [kmu]?g\/L\/day//i;
            $parm2 =~ s/ [kmu]?g\/m2\/day//i;
            $parm2 =~ s/ [kmu]?g\/m\^2\/day//i;
            $parm2 =~ s/ [kmu]?g\/L//i;
            $parm2 =~ s/ [kmu]?g\/m3//i;
            $parm2 =~ s/ [kmu]?g\/m\^3//i;
            $parm2 =~ s/, days//i;
            $parm2 =~ s/ days//i;
            $parm2 =~ s/,$//;
        }
    }

    $jd_skip_active = 0;
    @jd_skip_opts = ("(keep all)", "(keep every other)", "(keep every 3rd)", "(keep every 4th)",
                     "(keep every 5th)",  "(keep every 6th)",  "(keep every 7th)",  "(keep every 8th)",
                     "(keep every 9th)",  "(keep every 10th)", "(keep every 11th)", "(keep every 12th)",
                     "(keep every 13th)", "(keep every 14th)", "(keep every 15th)", "(keep every 16th)",
                     "(keep every 17th)", "(keep every 18th)", "(keep every 19th)", "(keep every 20th)",
                     "(keep every 21st)", "(keep every 22nd)", "(keep every 23rd)", "(keep every 24th)",
                     "(keep every 25th)", "(keep every 26th)", "(keep every 27th)", "(keep every 28th)",
                     "(keep every 29th)", "(keep every 30th)", "(keep every 31st)", "(keep every 32nd)",
                     "(keep every 33rd)", "(keep every 34th)", "(keep every 35st)", "(keep every 36th)",
                     "(keep every 37th)", "(keep every 38th)", "(keep every 39th)", "(keep every 40th)",
                     "(keep every 41st)", "(keep every 42nd)", "(keep every 43rd)", "(keep every 44th)",
                     "(keep every 45th)", "(keep every 46th)", "(keep every 47th)", "(keep every 48th)",
                     "(keep every 49th)", "(keep every 50th)");
    if ($src_type =~ /Contour|Vector/i) {
        for ($n=0; $n<=$#wbs; $n++) {
            $jw = $wbs[$n];
            if ($src_type =~ /Contour/i) {
                for ($i=1; $i<=$ncpl[$jw]; $i++) {
                    next if ($cplf[$i][$jw] eq "na");
                    if ($cplf[$i][$jw] < 1.0) {
                        $jd_skip_active = 1;
                        last;
                    }
                }
            } elsif ($src_type =~ /Vector/i) {
                for ($i=1; $i<=$nvpl[$jw]; $i++) {
                    next if ($vplf[$i][$jw] eq "na");
                    if ($vplf[$i][$jw] < 1.0) {
                        $jd_skip_active = 1;
                        last;
                    }
                }
            }
            last if ($jd_skip_active);
        }
    } elsif ($src_type =~ /SurfTemp|VolTemp|FlowTemp/i) {
        if ($ftype =~ /^W2 .*daily .*Temp2\.dat format$/i) {
            for ($i=1; $i<=$ntsr; $i++) {
                next if ($tsrf[$i] eq "na");
                if ($tsrf[$i] < 1.0) {
                    $jd_skip_active = 1;
                    last;
                }
            }
        }
    }
    $jd_skip = 0 if ($jd_skip < 0 || $jd_skip > 49);
    $jd_skip_explain = $jd_skip_opts[$jd_skip];
    undef @ncpl;
    undef @cplf;
    undef @nvpl;
    undef @vplf;
    undef @wbs;
    undef @tsrf;

    $parm_chars = length($parmlist[0]);
    for ($i=1; $i<=$#parmlist; $i++) {
        $parm_chars = &max($parm_chars, length($parmlist[$i]));
    }
    $parm_chars += 2;
    $parm_short = $parm;
    if ($props{$id}{parm} ne "Temperature") {
        $parm_short =~ s/\(ms-1\)//i;
        $parm_short =~ s/\(m3s-1\)//i;
        $parm_short =~ s/ [kmu]?g\/L\/day//i;
        $parm_short =~ s/ [kmu]?g\/m2\/day//i;
        $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
        $parm_short =~ s/ [kmu]?g\/L//i;
        $parm_short =~ s/ [kmu]?g\/m3//i;
        $parm_short =~ s/ [kmu]?g\/m\^3//i;
        $parm_short =~ s/, days//i;
        $parm_short =~ s/ days//i;
        $parm_short =~ s/,$//;
    }
    $old_units     = $units;
    $oldparm       = $parm;
    $oldparm_short = $parm_short;
    @parm_divlist  = ("None");
    for ($i=0; $i<=$#parmlist4div; $i++) {
        next if ($parmlist4div[$i] eq "Horizontal Velocity"
                  || $parmlist4div[$i] eq "Vertical Velocity"
                  || $parmlist4div[$i] eq "Density"
                  || $parmlist4div[$i] eq "Habitat");
        if ($parm ne $parmlist4div[$i]) {
            push (@parm_divlist, $parmlist4div[$i]);
        }
    }
    $parm_div = "None" if (&list_match($parm_div, @parm_divlist) == -1);

#   Build the menu.
    $frame = $w2tdmap_mod_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -command => sub { my ($modified, @cpl_files2, @parmlist2, @parms2, %parms);
                              $modified = 0;
                              %parms = ();
                              if ($change eq "misc") {
                                  $modified = 1 if ($byear     != $props{$id}{byear} ||
                                                    $tz_offset ne $props{$id}{tz_offset} ||
                                                    $jd_skip   != $props{$id}{jd_skip});
                              }
                              if ($change =~ /parm|misc/) {
                                  if ($pmin eq "" || $pmax eq "") {
                                      return &pop_up_error($w2tdmap_mod_menu,
                                      "Please provide both a min and max for your parameter.");
                                  }
                                  if ($pmin >= $pmax) {
                                      return &pop_up_error($w2tdmap_mod_menu,
                                      "The minimum data value must be less than the maximum data value.");
                                  }
                                  if ($conv_type eq "Custom") {
                                      $conv_type = sprintf("Custom,%s,%s", $conv_mult, $conv_add);
                                  }
                                  $gtitle  =~ s/^\s+//;
                                  $gtitle  =~ s/\s+$//;
                                  $gstitle =~ s/^\s+//;
                                  $gstitle =~ s/\s+$//;
                                  if ($parm ne $props{$id}{parm_sav} || $parm_div ne $props{$id}{pdiv_sav}
                                       || ($parm !~ /^(Temperature|Tmax|Tmean|Tmin|TEMP)$/
                                             && $units ne $props{$id}{parm_units})
                                       || $prof_stat ne $props{$id}{prof_stat}
                                       || $conv_type ne $props{$id}{ctype}) {
                                      $modified = 1;
                                  }
                                  if (! $modified) {
                                      if ($parm =~ /^(Temperature|Tmax|Tmean|Tmin|TEMP)$/
                                                  && $parm eq $props{$id}{parm_sav}
                                                  && $units ne $props{$id}{parm_units}) {
                                          return &pop_up_error($w2tdmap_mod_menu,
                                                               "To modify just the temperature units,\n"
                                                             . "use the Graph Properties menu.");
                                      } elsif ($pmin != $gr_props{$id}{cs_min}
                                                  || $pmax != $gr_props{$id}{cs_max}) {
                                          return &pop_up_error($w2tdmap_mod_menu,
                                                               "To modify just the parameter limits,\n"
                                                             . "use the Graph Properties menu.");
                                      } elsif ($gtitle ne $gr_props{$id}{gtitle}
                                                  || $gstitle ne $gr_props{$id}{gstitle}) {
                                          return &pop_up_error($w2tdmap_mod_menu,
                                                               "To modify just the graph titles,\n"
                                                             . "use the Graph Properties menu.");
                                      }
                                  }
                              }
                              if (! $modified) {
                                  $w2tdmap_mod_menu->g_bind('<Destroy>', "");
                                  $w2tdmap_mod_menu->g_destroy();
                                  undef $w2tdmap_mod_menu;
                                  &reset_bindings;
                                  return;
                              }

#                             Check consistency of parameters if this is a difference plot
                              if ($props{$id}{map_type} eq "filediff") {     # same parameter
                                  if ($props{$id}{src_type2} =~ /Contour/i) {
                                      @cpl_files2 = @{ $props{$id}{cpl_files2} };
                                      for ($n=0; $n<=$#wbs; $n++) {
                                          (undef, undef, undef, $parms_ref, undef, undef)
                                                = &scan_w2_cpl_file($w2tdmap_mod_menu,
                                                                    $cpl_files2[$n], $id, 0, "");
                                          @parms2 = @{ $parms_ref };
                                          if ($n == 0) {
                                              @parmlist2 = @parms2;
                                          } else {
                                              @parm_tmp = ();
                                              foreach $p ( @parms2 ) {
                                                  if (&list_match($p, @parmlist2) >= 0) {
                                                      push (@parm_tmp, $p);
                                                  }
                                              }
                                              @parmlist2 = @parm_tmp;
                                          }
                                      }
                                  } elsif ($props{$id}{src_type2} =~ /Vector/i) {
                                      (undef, $parms_ref, undef, undef, undef)
                                            = &scan_w2_vector_file($w2tdmap_mod_menu,
                                                                   $props{$id}{w2l_file2}, $id, 0);
                                      @parmlist2 = @{ $parms_ref };
                                  } elsif ($props{$id}{src_type2} =~ /SurfTemp|VolTemp|FlowTemp/i) {
                                      (undef, undef, @parmlist2)
                                            = &determine_ts_type($w2tdmap_mod_menu,
                                                                 $props{$id}{src_file2}, 1);
                                  }
                                  if (&list_match($parm, @parmlist2) == -1) {
                                      return &pop_up_error($w2tdmap_mod_menu,
                                                           "The chosen parameter (" . $parm . ")\n"
                                                         . "is not present in the source file\n"
                                                         . "for the parameter difference.");
                                  }
                                  if ($parm_div ne "None") {
                                      if (&list_match($parm_div, @parmlist2) == -1) {
                                          return &pop_up_error($w2tdmap_mod_menu,
                                                               "The chosen parameter divisor ("
                                                             . $parm_div . ")\n"
                                                             . "is not present in the source file\n"
                                                             . "for the parameter difference.");
                                      }
                                  }
                              }

#                             Reset the min/max dates if different jd_skip or byear
                              $parms{rebuild}    = ($byear     != $props{$id}{byear} ||
                                                    $tz_offset ne $props{$id}{tz_offset} ||
                                                    $jd_skip   != $props{$id}{jd_skip}) ? 1 : 0;
                              $parms{pmin}       = $pmin;
                              $parms{pmax}       = $pmax;
                              $parms{gtitle}     = $gtitle;
                              $parms{gstitle}    = $gstitle;
                              $parms{change}     = $change;
                              $props{$id}{parms} = { %parms };

                              $props{$id}{data}       = 0;
                              $props{$id}{parm}       = $parm;
                              $props{$id}{parm_sav}   = $parm;
                              $props{$id}{parm_div}   = $parm_div;
                              $props{$id}{pdiv_sav}   = $parm_div;
                              $props{$id}{prof_stat}  = $prof_stat;
                              $props{$id}{parm_units} = $units;
                              $props{$id}{ctype}      = $conv_type;
                              $props{$id}{byear}      = $byear;
                              $props{$id}{tz_offset}  = $tz_offset;
                              $props{$id}{jd_skip}    = $jd_skip;

                              if ($props{$id}{map_type} eq "filediff") {
                                  $props{$id}{parm2}     = $parm;
                                  $props{$id}{parm2_sav} = $parm;
                                  $props{$id}{parm2_div} = $parm_div;
                                  $props{$id}{pdiv2_sav} = $parm_div;
                                  $props{$id}{ctype2}    = $conv_type;
                              }
                              if ($props{$id}{map_type} =~ /^(parmdiff|filediff)$/) {
                                  $props{$id}{data2} = 0;
                              }

                              $w2tdmap_mod_menu->g_bind('<Destroy>', "");
                              $w2tdmap_mod_menu->g_destroy();
                              undef $w2tdmap_mod_menu;
                              &reset_bindings;
                              &make_w2_tdmap($canv, $id, 0);
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $w2tdmap_mod_menu->g_bind('<Destroy>', "");
                              $w2tdmap_mod_menu->g_destroy();
                              undef $w2tdmap_mod_menu;
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Do not delete graph if this menu is destroyed by other than the Cancel button
    $w2tdmap_mod_menu->g_bind('<Destroy>' => sub { undef $w2tdmap_mod_menu;
                                                   &reset_bindings;
                                                 });

    $f = $w2tdmap_mod_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "Parameter: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($parm_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    ($parm_cb = $parm_frame->new_ttk__combobox(
            -textvariable => \$parm,
            -values       => [ @parmlist ],
            -state        => 'readonly',
            -width        => $parm_chars,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $parm_cb->g_bind("<<ComboboxSelected>>",
                         sub { my ($i);
                               return if ($parm eq $oldparm);
                               $parm_short = $parm;
                               if ($parm eq "Temperature" || $parm =~ /^(Tmax|Tmean|Tmin|TEMP)$/) {
                                   $units = "Celsius" if ($units !~ /(Celsius|Fahrenheit)/);
                                   if ($parm eq "Temperature" || $parm eq "TEMP") {
                                       $title = "Temperature";
                                   } elsif ($parm eq "Tmax") {
                                       $title = "Max Temperature";
                                   } elsif ($parm eq "Tmean") {
                                       $title = "Mean Temperature";
                                   } elsif ($parm eq "Tmin") {
                                       $title = "Min Temperature";
                                   }
                                   if ($props{$id}{map_type} eq "parmdiff") {
                                       $title .= " minus " . $parm2;
                                   }
                                   $title .= ", in degrees " . $units;
                                   $units_cb->g_grid();
                                   $units_entry->g_grid_remove();
                                   $conv_type_na_label->g_grid();
                                   $custom_frame->g_grid_remove();
                                   $conv_type_cb->g_grid_remove();
                                   $conv_type = "None";
                               } else {
                                   $units = "";
                                   $parm_short =~ s/\(ms-1\)//i;
                                   $parm_short =~ s/\(m3s-1\)//i;
                                   $parm_short =~ s/ [kmu]?g\/L\/day//i;
                                   $parm_short =~ s/ [kmu]?g\/m2\/day//i;
                                   $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
                                   $parm_short =~ s/ [kmu]?g\/L//i;
                                   $parm_short =~ s/ [kmu]?g\/m3//i;
                                   $parm_short =~ s/ [kmu]?g\/m\^3//i;
                                   $parm_short =~ s/, days//i;
                                   $parm_short =~ s/ days//i;
                                   $parm_short =~ s/,$//;
                                   $title = $parm_short;
                                   if ($props{$id}{map_type} eq "parmdiff") {
                                       $title .= " minus " . $parm2;
                                   }
                                   if ($parm eq "Horizontal Velocity" || $parm eq "Vertical Velocity") {
                                       $units  = "m/s";
                                       $title .= ", in m/s";
                                   } elsif ($parm eq "Density") {
                                       $units  = "kg/m3";
                                       $title .= ", in kg/m3";
                                   } else {
                                       $title .= ", in ";
                                   }
                                   $units_cb->g_grid_remove();
                                   $units_entry->g_grid();
                                   $conv_type_na_label->g_grid_remove();
                                   $custom_frame->g_grid() if ($conv_type eq "Custom");
                                   $conv_type_cb->g_grid();
                               }
                               if ($gtitle eq "") {
                                   if ($props{$id}{map_type} eq "parmdiff") {
                                       $gtitle = "Time/Distance Diff Map of $parm_short minus " . $parm2;
                                   } elsif ($props{$id}{map_type} eq "filediff") {
                                       $gtitle = "Time/Distance Diff Map of $parm_short";
                                   } else {
                                       $gtitle = "Time/Distance Map of $parm_short";
                                   }
                               } else {
                                   if (index(lc($gtitle), lc($oldparm_short)) > -1) {
                                       $gtitle =~ s/$oldparm_short/$parm_short/i;
                                   }
                               }
                               $old_units     = $units;
                               $oldparm       = $parm;
                               $oldparm_short = $parm_short;
                               @parm_divlist  = ("None");
                               for ($i=0; $i<=$#parmlist4div; $i++) {
                                   next if ($parmlist4div[$i] eq "Horizontal Velocity"
                                            || $parmlist4div[$i] eq "Vertical Velocity"
                                            || $parmlist4div[$i] eq "Density"
                                            || $parmlist4div[$i] eq "Habitat");
                                   if ($parm ne $parmlist4div[$i]) {
                                       push (@parm_divlist, $parmlist4div[$i]);
                                   }
                               }
                               $parm_div_cb->configure(-values => [ @parm_divlist ]);
                               if (&list_match($parm_div, @parm_divlist) == -1) {
                                   $parm_div = "None";
                               }
                               if ($parm =~ /^(Temperature|TEMP)$/ || $parm eq "Horizontal Velocity"
                                       || $parm eq "Vertical Velocity" || $parm eq "Density"
                                       || $parm eq "Habitat" || $#parm_divlist == 0) {
                                   $parm_div_label->g_pack_forget();
                                   $parm_div_cb->g_pack_forget();
                                   $parm_div = "None";
                               } else {
                                   $parm_div_label->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                                   $parm_div_cb->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                               }
                             });
    ($parm_div_label = $parm_frame->new_label(
            -text => " divided by ",
            -font => 'default',
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    ($parm_div_cb = $parm_frame->new_ttk__combobox(
            -textvariable => \$parm_div,
            -values       => [ @parm_divlist ],
            -state        => 'readonly',
            -width        => $parm_chars,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Profile Stat: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    if ($src_type =~ /Contour|Vector/i) {
        $f->new_ttk__combobox(
                -textvariable => \$prof_stat,
                -values       => [ ("Surface value", "Volume-weighted") ],
                -state        => 'readonly',
                -width        => 16,
                )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    } else {
        $f->new_label(
                -text => $prof_stat,
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    }

    $row++;
    $f->new_label(
            -text => "Conversion: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($conv_type_na_label = $f->new_label(
            -text => "n/a",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $conv_type_na_label->g_grid_remove();
    ($conv_type_cb = $f->new_ttk__combobox(
            -textvariable => \$conv_type,
            -values       => [ @conv_types ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $conv_type_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($conv_type eq "Custom") {
                                $custom_frame->g_grid();
                            } else {
                                $custom_frame->g_grid_remove();
                            }
                          }
                      );
    $row++;
    ($custom_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    $custom_frame->new_label(
            -text => "Multiply by: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_mult_entry = $custom_frame->new_entry(
            -textvariable => \$conv_mult,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_mult_entry->g_bind("<KeyRelease>",
                              sub { &numeric_entry_only($conv_mult_entry);
                                    my $chars = &max(7, length($conv_mult));
                                    $conv_mult_entry->configure(-width => $chars);
                                  });
    $custom_frame->new_label(
            -text => "  Then add: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_add_entry = $custom_frame->new_entry(
            -textvariable => \$conv_add,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_add_entry->g_bind("<KeyRelease>",
                             sub { &numeric_entry_only($conv_add_entry);
                                   my $chars = &max(7, length($conv_add));
                                   $conv_add_entry->configure(-width => $chars);
                                 });

    $row++;
    $f->new_label(
            -text => "Data Units: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($units_cb = $f->new_ttk__combobox(
            -textvariable => \$units,
            -values       => [ ("Celsius", "Fahrenheit") ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $units_cb->g_bind("<<ComboboxSelected>>",
                       sub { return if ($units eq $old_units);
                             $old_units = $units;
                             if ($units eq "Celsius") {
                                 if ($pmin ne "" && $pmin ne "." && $pmin ne "-") {
                                     $pmin = &floor(($pmin -32) /1.8);
                                 }
                                 if ($pmax ne "" && $pmax ne "." && $pmax ne "-") {
                                     $pmax = &ceil(($pmax  -32) /1.8);
                                 }
                             } elsif ($units eq "Fahrenheit") {
                                 if ($pmin ne "" && $pmin ne "." && $pmin ne "-") {
                                     $pmin = &floor($pmin *1.8 +32);
                                 }
                                 if ($pmax ne "" && $pmax ne "." && $pmax ne "-") {
                                     $pmax = &ceil($pmax  *1.8 +32);
                                 }
                             }
                             $title = "Temperature, in degrees " . $units;
                           });
    $units_cb->g_grid_remove();
    ($units_entry = $f->new_entry(
            -textvariable => \$units,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $units_entry->g_bind("<KeyRelease>",
                         sub { my $chars = &max(7, length($units));
                               $units_entry->configure(-width => $chars);
                               if ($parm eq "Temperature") {
                                   $title = "Temperature, in degrees " . $units;
                               } else {
                                   $title = $parm_short . ", in " . $units;
                               }
                             });

    $row++;
    $f->new_label(
            -text => "Data Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$title,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Data Min: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmin_entry = $f->new_entry(
            -textvariable => \$pmin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmin_entry ]);

    $row++;
    $f->new_label(
            -text => "Data Max: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmax_entry = $f->new_entry(
            -textvariable => \$pmax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmax_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmax_entry ]);

    $row++;
    $f->new_label(
            -text => "Graph Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gtitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Graph Subtitle: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gstitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);

    if ($change eq "misc") {
        $row++;
        $f->new_label(
                -text => "Base Year: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($byear_cb = $f->new_ttk__combobox(
                -textvariable => \$byear,
                -values       => [ reverse($yr_min .. $yr_max) ],
                -width        => 5,
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $byear_cb->g_bind("<<ComboboxSelected>>",
                          sub { if ($byear == $yr_min) {
                                    $yr_min -= 10;
                                    $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                }
                              });
        $f->new_label(
                -text   => " for JDAY = 1.0",
                -anchor => 'w',
                -font   => 'default',
                )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

        $row++;
        $f->new_label(
                -text => "Time Offset: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($offset_frame = $f->new_frame(
                -borderwidth => 0,
                -relief      => 'flat',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
        $offset_frame->new_ttk__combobox(
                -textvariable => \$tz_offset,
                -values       => [ @tz_offsets ],
                -justify      => 'right',
                -state        => 'readonly',
                -width        => 6,
                )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        $offset_frame->new_label(
                -text   => " time zone adjustment ",
                -anchor => 'w',
                -font   => 'default',
                )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        $offset_frame->new_button(
                -text    => "Help",
                -command => sub { &pop_up_info($w2tdmap_mod_menu,
                                        "The time offset allows the user to add or subtract a time\n"
                                      . "offset if the W2 model was run with a non-local time zone.\n\n"
                                      . "For example, if W2 was run in UTC but the local time zone\n"
                                      . "is PST, an offset of -08:00 would convert the model date/time\n"
                                      . "to a local standard time of PST. This offset does not make\n"
                                      . "any adjustments related to daylight saving time. In general,\n"
                                      . "W2 is best run in the local standard time.\n\n"
                                      . "Leave the time offset at +00:00 for no adjustment.",
                                        "Time Offset Notice");
                                },
                )->g_pack(-side => 'left', -anchor => 'w', -padx => 2);

        if ($jd_skip_active) {
            $row++;
            $f->new_label(
                    -text => "Skip Dates: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($jd_skip_frame = $f->new_frame(
                    -borderwidth => 0,
                    -relief      => 'flat',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
            $jd_skip_frame->new_spinbox(
                    -textvariable => \$jd_skip,
                    -state        => 'readonly',
                    -font         => 'default',
                    -from         => 0,
                    -to           => 49,
                    -increment    => 1,
                    -width        => 4,
                    -command      => sub { $jd_skip_explain = $jd_skip_opts[$jd_skip]; },
                    )->g_pack(-side => 'left', -anchor => 'w');
            $jd_skip_frame->new_label(
                    -textvariable => \$jd_skip_explain,
                    -font         => 'default',
                    )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        }
    }

    if ($parm =~ /^(Temperature|TEMP)$/ || $parm eq "Horizontal Velocity" || $parm eq "Density"
                                        || $parm eq "Vertical Velocity" || $parm eq "Habitat"
                                        || $#parm_divlist == 0) {
        $parm_div_label->g_pack_forget();
        $parm_div_cb->g_pack_forget();
        $parm_div = "None";
    } else {
        $parm_div_label->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        $parm_div_cb->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    }
    if ($conv_type ne "Custom") {
        $custom_frame->g_grid_remove();
    }
    if ($parm =~ /^(Temperature|Tmax|Tmean|Tmin|TEMP)$/) {
        $units_cb->g_grid();
        $units_entry->g_grid_remove();
        $conv_type_na_label->g_grid();
        $custom_frame->g_grid_remove();
        $conv_type_cb->g_grid_remove();
        $conv_type = "None";
    } else {
        $units_cb->g_grid_remove();
        $units_entry->g_grid();
        $conv_type_na_label->g_grid_remove();
        $custom_frame->g_grid() if ($conv_type eq "Custom");
        $conv_type_cb->g_grid();
    }
    $f->g_grid_columnconfigure(3, -weight => 2);

    Tkx::wm_resizable($w2tdmap_mod_menu,0,0);
    &adjust_window_position($w2tdmap_mod_menu);
    $w2tdmap_mod_menu->g_focus;
}


sub make_w2_tdmap {
    my ($canv, $id, $props_updated) = @_;
    my (
        $add, $base_jd, $box_id, $change, $cmap_image, $cs_max, $cs_min,
        $cs_range, $cs_rev, $cscheme1, $cscheme2, $cshade, $cvert, $d1,
        $d2, $datemax, $datemin, $dbase, $dflip, $distance, $dmax, $dmin,
        $dp, $dp1, $dp2, $dpix, $drange, $dsize, $dsum, $dt, $dt_adj,
        $dt2, $flip_dir, $geom, $group_tags, $gtag, $i, $id2, $ih, $img,
        $img_data, $item, $iw, $j, $jb, $jd, $jd_max, $jd_min, $jd0, $jd2,
        $jw, $kn_digits, $last_jb, $last_seg, $mi, $mpointerx, $mpointery,
        $mult, $n, $nbr, $ncolors, $new_graph, $ns, $nwb, $parm_short, $pbar,
        $pbar_frame, $pbar_window, $refresh_menus, $resized, $seg, $seg_dn,
        $seg_list, $seg_up, $src_type, $src_type2, $stitle_id, $tabid,
        $tag, $td_img, $tflip, $time_on_x, $tp, $tp1, $tp2, $tpix, $trange,
        $update_cs, $X, $x1, $x2, $Y, $y1, $y2, $yp, $yr_max, $yr_min,

        @be, @brs, @bth_files, @bs, @cdata, @colors, @coords, @cpl_files,
        @cpl_lines, @dlx, @dist, @ds, @jdates, @grp_tags, @items, @mydates,
        @old_coords, @riv_files, @riv_lines, @scale, @seg_limits, @seg_wb,
        @seglist, @tags, @tecplot, @us, @wbs,

        %axis_props, %color_key_props, %limits, %parms, %profile, %sdata,
        %td_data, %tmp_data,
       );

#   For new plots, pop up a menu for file names and parameters
    if (! defined($props{$id}{files})) {
        return &setup_w2_slice_or_tdmap_or_wlevels($canv, $id);
    }

#   Make tag and get coordinates of graph frame
    $gtag   = "graph" . $id;
    @coords = @{ $props{$id}{coordlist} };
    ($x1, $y1, $x2, $y2) = @coords;

#   Determine whether group tags are present and save the list
    $group_tags = 0;
    @grp_tags   = ();
    @tags       = Tkx::SplitList($canv->itemcget($id, -tags));
    if (&list_search("group_", @tags) > -1) {
        $group_tags = 1;
        foreach $tag (@tags) {
            push (@grp_tags, $tag) if ($tag =~ /^group_/);
        }
    }

#   Define the swap-order flag, if not set
    $props{$id}{swap_order} = 0 if (! defined($props{$id}{swap_order}));

#   Read the data files, if not done already
    if (! defined($props{$id}{data}) || ! $props{$id}{data}
           || ($props{$id}{map_type} ne "standard"
                && (! defined($props{$id}{data2}) || ! $props{$id}{data2}))) {
        %parms    = %{ $props{$id}{parms} };
        @wbs      = split(/,/, $props{$id}{wb_list});
        $src_type = $props{$id}{src_type};

        if (defined($props{$id}{oldcoords})) {
            %profile   = %{ $gr_props{$id} };
            $change    = $parms{change};      # values:  parm, misc
            $new_graph = 0;
        } else {
            %profile   = ();
            $change    = "";
            $new_graph = 1;
        }

#       Move mouse cursor on first creation, to ensure that it changes to cursor_wait
        if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
            $canv->g_bind("<Motion>", "");
            Tkx::event_generate($main, "<Motion>", -warp => 1, -x => ($x1+$x2)/2, -y => ($y1+$y2)/2);
            $canv->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"), $canv, "menu" ]);
        }

#       Read bathymetry and source data files, as necessary
#       Required for all source file types. Vector (w2l) files don't have a good kb value.
        if (! defined($props{$id}{data}) || ! $props{$id}{data}) {
            if ($new_graph) {
                $status_line = "Reading bathymetry files...";
                Tkx::update_idletasks();
                @bth_files = @{ $props{$id}{bth_files} };
                for ($n=0; $n<=$#wbs; $n++) {
                    &read_bth($main, $id, $wbs[$n], $bth_files[$n]);
                }
                $status_line = "";
                Tkx::update_idletasks();
            }

            if ($src_type =~ /Contour/i) {
                @tecplot   = @{ $props{$id}{tecplot}   };
                @cpl_lines = @{ $props{$id}{cpl_lines} };
                @cpl_files = @{ $props{$id}{cpl_files} };
                for ($n=0; $n<=$#wbs; $n++) {
                    $jw = $wbs[$n];
                    ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $cpl_lines[$n],
                                                                 "Reading W2 contour file...");
                    %sdata = &read_w2_cpl_file($main, $id, $jw, $cpl_files[$n], $tecplot[$n], 0,
                                               $props{$id}{parm_sav}, $props{$id}{pdiv_sav},
                                               $props{$id}{byear}, $props{$id}{tz_offset},
                                               $props{$id}{jd_skip}, $pbar);
                    &destroy_progress_bar($main, $pbar_window);

#                   Reformat data hash and compute profile stat
                    ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, 10,
                                                                 "Computing profile stats...");
                    %tmp_data = &compute_pstat_from_slice($main, $id, $props{$id}{prof_stat},
                                                          $jw, $pbar, %sdata);
                    &destroy_progress_bar($main, $pbar_window);

#                   Consolidate data from different waterbodies
                    if ($#wbs == 0 || $n == 0) {
                        %td_data = %tmp_data;
                        @mydates = keys %td_data;
                        $dsum    = &sum(@mydates);
                    } else {
                        @mydates = keys %tmp_data;
                        if ($dsum != &sum(@mydates)) {
                            &pop_up_info($main, "Contour file dates for waterbody " . $wbs[$n] . "\n"
                                              . "do not match those for waterbody " . $wbs[0] . "\n"
                                              . "This could lead to visualization problems.");
                        }
                        foreach $dt (@mydates) {                             # each date/time
                            foreach $seg (keys %{ $tmp_data{$dt} }) {        # each segment
                                $td_data{$dt}{$seg} = $tmp_data{$dt}{$seg};
                            }
                        }
                    }
                    undef %sdata;
                    undef %tmp_data;
                }

            } elsif ($src_type =~ /Vector/i) {
                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, -s $props{$id}{w2l_file},
                                                             "Reading W2 vector file...");
                $status_line = "Reading W2 vector file... Date = 1";
                %sdata = &read_w2_vector_file($main, $id, $props{$id}{w2l_file}, 0,
                                              $props{$id}{parm_sav}, $props{$id}{pdiv_sav},
                                              $props{$id}{byear}, $props{$id}{tz_offset},
                                              $props{$id}{jd_skip}, $pbar);
                &destroy_progress_bar($main, $pbar_window);

#               Reformat data hash and compute profile stat
                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, 10,
                                                             "Computing profile stats...");
                %td_data = &compute_pstat_from_slice($main, $id, $props{$id}{prof_stat},
                                                     "all", $pbar, %sdata);
                &destroy_progress_bar($main, $pbar_window);
                undef %sdata;

            } elsif ($src_type =~ /RiverCon/i) {
                @riv_lines = @{ $props{$id}{riv_lines} };
                @riv_files = @{ $props{$id}{riv_files} };
                @brs       = split(/,/, $props{$id}{br_list});
                for ($n=0; $n<=$#brs; $n++) {
                    ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $riv_lines[$n],
                                                                 "Reading W2 RiverCon file...");
                    %tmp_data = &read_w2_rivcon_file($main, $id, $riv_files[$n], $props{$id}{parm_sav},
                                                     $brs[$n], $props{$id}{byear}, $props{$id}{tz_offset},
                                                     $props{$id}{jd_skip}, $pbar);
                    &destroy_progress_bar($main, $pbar_window);

#                   Consolidate data from different branches
                    if ($#brs == 0 || $n == 0) {
                        %td_data = %tmp_data;
                        @mydates = keys %td_data;
                        $dsum    = &sum(@mydates);
                    } else {
                        @mydates = keys %tmp_data;
                        if ($dsum != &sum(@mydates)) {
                            &pop_up_info($main, "RiverCon file dates for branch " . $brs[$n] . "\n"
                                              . "do not match those for branch " . $brs[0] . "\n"
                                              . "This could lead to visualization problems.");
                        }
                        foreach $dt (@mydates) {                             # each date/time
                            foreach $seg (keys %{ $tmp_data{$dt} }) {        # each segment
                                $td_data{$dt}{$seg} = $tmp_data{$dt}{$seg};
                            }
                        }
                    }
                    undef %tmp_data;
                }

            } elsif ($src_type =~ /SurfTemp|VolTemp|FlowTemp/i) {
                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $props{$id}{src_lines},
                                                             "Reading " . $src_type . "...");
                %td_data = &read_w2_flowtemp_alt($main, $props{$id}{src_file}, $props{$id}{parm_sav},
                                                 $props{$id}{pdiv_sav}, $props{$id}{byear},
                                                 $props{$id}{tz_offset}, $props{$id}{jd_skip}, $pbar);
                &destroy_progress_bar($main, $pbar_window);
            }

#           Data conversion
            if (&list_match($props{$id}{ctype}, @conv_types) > 0 || $props{$id}{ctype} =~ /^Custom,/) {
                $status_line = "Converting units...";
                Tkx::update_idletasks();
                %td_data = &convert_tdmap_data($main, $props{$id}{ctype}, %td_data);
                $status_line = "";
                Tkx::update_idletasks();
            }
            $profile{td_data} = { %td_data };
        }

        if ($props{$id}{map_type} =~ /^(parmdiff|filediff)$/
              && (! defined($props{$id}{data2}) || ! $props{$id}{data2})) {

            $src_type2 = $props{$id}{src_type2};
            if ($src_type2 =~ /Contour/i) {
                @tecplot   = @{ $props{$id}{tecplot2}   };
                @cpl_lines = @{ $props{$id}{cpl_lines2} };
                @cpl_files = @{ $props{$id}{cpl_files2} };
                for ($n=0; $n<=$#wbs; $n++) {
                    $jw = $wbs[$n];
                    ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $cpl_lines[$n],
                                                                 "Reading W2 contour file...");
                    %sdata = &read_w2_cpl_file($main, $id, $jw, $cpl_files[$n], $tecplot[$n], 0,
                                               $props{$id}{parm2_sav}, $props{$id}{pdiv2_sav},
                                               $props{$id}{byear}, $props{$id}{tz_offset},
                                               $props{$id}{jd_skip}, $pbar);
                    &destroy_progress_bar($main, $pbar_window);

#                   Reformat data hash and compute profile stat
                    ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, 10,
                                                                 "Computing profile stats...");
                    %tmp_data = &compute_pstat_from_slice($main, $id, $props{$id}{prof_stat},
                                                          $jw, $pbar, %sdata);
                    &destroy_progress_bar($main, $pbar_window);

#                   Consolidate data from different waterbodies
                    if ($#wbs == 0 || $n == 0) {
                        %td_data = %tmp_data;
                        @mydates = keys %td_data;
                        $dsum    = &sum(@mydates);
                    } else {
                        @mydates = keys %tmp_data;
                        if ($dsum != &sum(@mydates)) {
                            &pop_up_info($main, "Contour file dates for waterbody " . $wbs[$n] . "\n"
                                              . "do not match those for waterbody " . $wbs[0] . "\n"
                                              . "This could lead to visualization problems.");
                        }
                        foreach $dt (@mydates) {                             # each date/time
                            foreach $seg (keys %{ $tmp_data{$dt} }) {        # each segment
                                $td_data{$dt}{$seg} = $tmp_data{$dt}{$seg};
                            }
                        }
                    }
                    undef %sdata;
                    undef %tmp_data;
                }

            } elsif ($src_type2 =~ /Vector/i) {
                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, -s $props{$id}{w2l_file2},
                                                             "Reading W2 vector file...");
                $status_line = "Reading W2 vector file... Date = 1";
                %sdata = &read_w2_vector_file($main, $id, $props{$id}{w2l_file2}, 0,
                                              $props{$id}{parm2_sav}, $props{$id}{pdiv2_sav},
                                              $props{$id}{byear}, $props{$id}{tz_offset},
                                              $props{$id}{jd_skip}, $pbar);
                &destroy_progress_bar($main, $pbar_window);

#               Reformat data hash and compute profile stat
                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, 10,
                                                             "Computing profile stats...");
                %td_data = &compute_pstat_from_slice($main, $id, $props{$id}{prof_stat},
                                                     "all", $pbar, %sdata);
                &destroy_progress_bar($main, $pbar_window);
                undef %sdata;

            } elsif ($src_type2 =~ /RiverCon/i) {
                @riv_lines = @{ $props{$id}{riv_lines2} };
                @riv_files = @{ $props{$id}{riv_files2} };
                @brs       = split(/,/, $props{$id}{br_list2});
                for ($n=0; $n<=$#brs; $n++) {
                    ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $riv_lines[$n],
                                                                 "Reading W2 RiverCon file...");
                    %tmp_data = &read_w2_rivcon_file($main, $id, $riv_files[$n], $props{$id}{parm2_sav},
                                                     $brs[$n], $props{$id}{byear}, $props{$id}{tz_offset},
                                                     $props{$id}{jd_skip}, $pbar);
                    &destroy_progress_bar($main, $pbar_window);

#                   Consolidate data from different branches
                    if ($#brs == 0 || $n == 0) {
                        %td_data = %tmp_data;
                        @mydates = keys %td_data;
                        $dsum    = &sum(@mydates);
                    } else {
                        @mydates = keys %tmp_data;
                        if ($dsum != &sum(@mydates)) {
                            &pop_up_info($main, "RiverCon file dates for branch " . $brs[$n] . "\n"
                                              . "do not match those for branch " . $brs[0] . "\n"
                                              . "This could lead to visualization problems.");
                        }
                        foreach $dt (@mydates) {                             # each date/time
                            foreach $seg (keys %{ $tmp_data{$dt} }) {        # each segment
                                $td_data{$dt}{$seg} = $tmp_data{$dt}{$seg};
                            }
                        }
                    }
                    undef %tmp_data;
                }

            } elsif ($src_type2 =~ /SurfTemp|VolTemp|FlowTemp/i) {
                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $props{$id}{src_lines2},
                                                             "Reading " . $src_type2 . "...");
                %td_data = &read_w2_flowtemp_alt($main, $props{$id}{src_file2}, $props{$id}{parm2_sav},
                                                 $props{$id}{pdiv2_sav}, $props{$id}{byear},
                                                 $props{$id}{tz_offset}, $props{$id}{jd_skip}, $pbar);
                &destroy_progress_bar($main, $pbar_window);
            }

#           Data conversion
            if (&list_match($props{$id}{ctype2}, @conv_types) > 0 || $props{$id}{ctype2} =~ /^Custom,/) {
                $status_line = "Converting units...";
                Tkx::update_idletasks();
                %td_data = &convert_tdmap_data($main, $props{$id}{ctype2}, %td_data);
                $status_line = "";
                Tkx::update_idletasks();
            }

#           Compute differences
            %tmp_data = %{ $profile{td_data} };                     # data for parameter 1
            if ($props{$id}{map_type} eq "parmdiff") {
                foreach $dt (keys %tmp_data) {                      # each date/time
                    foreach $seg (keys %{ $tmp_data{$dt} }) {       # each segment
                        if (! defined($td_data{$dt}{$seg}) || $td_data{$dt}{$seg}  == -99
                                                           || $tmp_data{$dt}{$seg} == -99) {
                            $tmp_data{$dt}{$seg} = -99;
                        } else {
                            $tmp_data{$dt}{$seg} -= $td_data{$dt}{$seg};
                        }
                    }
                }
            } elsif ($props{$id}{map_type} eq "filediff") {
                foreach $dt (keys %tmp_data) {                      # each date/time
                    $dt2 = $dt;
                    if (! defined($td_data{$dt2}) && $props{$id}{match_tol} > 0) {
                        for ($mi=1; $mi<=$props{$id}{match_tol}; $mi++) {
                            $dt_adj = &adjust_dt($dt2, $mi);
                            if (defined($td_data{$dt_adj})) {
                                $dt2 = $dt_adj;
                                last;
                            }
                            $dt_adj = &adjust_dt($dt2, -1 *$mi);
                            if (defined($td_data{$dt_adj})) {
                                $dt2 = $dt_adj;
                                last;
                            }
                        }
                    }
                    foreach $seg (keys %{ $tmp_data{$dt} }) {       # each segment
                        if (! defined($td_data{$dt2}{$seg}) || $td_data{$dt2}{$seg} == -99
                                                            || $tmp_data{$dt}{$seg} == -99) {
                            $tmp_data{$dt}{$seg} = -99;
                        } else {
                            $tmp_data{$dt}{$seg} -= $td_data{$dt2}{$seg};
                        }
                    }
                }
            }
            if ($props{$id}{swap_order}) {                          # swap order of difference
                foreach $dt (keys %tmp_data) {                      # each date/time
                    foreach $seg (keys %{ $tmp_data{$dt} }) {       # each segment
                        if ($tmp_data{$dt}{$seg} != -99) {
                            $tmp_data{$dt}{$seg} *= -1.0;
                        }
                    }
                }
            }
            %td_data           = %tmp_data;
            $profile{td_data}  = { %td_data };
            $props{$id}{data2} = 1;
            undef %tmp_data;
        }

#       Find minimum and maximum elevation and parameter values
        %limits = &find_w2_tdmap_limits($id, %td_data);
        $profile{date_min} = $limits{date_min};
        $profile{date_max} = $limits{date_max};
        $profile{parm_min} = $limits{parm_min};
        $profile{parm_max} = $limits{parm_max};
        undef %limits;

        if ($new_graph) {                              # not x or y.  d: distance, t: date/time
            $profile{dfont}     = $default_family;
            $profile{dl_size}   = &min(11, &max(8, int((abs($x2-$x1)+abs($y2-$y1))/2./41)));
            $profile{dt_size}   = $profile{dl_size} +2;
            $profile{dl_weight} = 'normal';
            $profile{dt_weight} = 'normal';

            $profile{tfont}     = $profile{dfont};
            $profile{tl_size}   = $profile{dl_size};
            $profile{tt_size}   = $profile{dt_size};
            $profile{tl_weight} = $profile{dl_weight};
            $profile{tt_weight} = $profile{dt_weight};

            $profile{date_axis} = $parms{date_axis};
            $profile{ttype}     = $parms{date_type};
            $profile{tflip}     = $parms{date_flip};
            $profile{tmin}      = "first";
            $profile{tmax}      = "last";
            $profile{tmajor}    = "auto";
            $profile{tpr_tics}  = "outside";
            $profile{top_tics}  = "none";
            $profile{datefmt}   = "Month";
            $profile{tflip_img} = 0;                   # flag set later

            $profile{dunits}    = $parms{dist_units};  # d: distance, t: time
            $profile{dflip}     = $parms{dist_flip};
            $profile{dbase}     = ($parms{dist_base}  ne "") ? $parms{dist_base}  : 0;
            $profile{dmin}      = ($parms{dist_min}   ne "") ? $parms{dist_min}   : 0;
            $profile{dfirst}    = ($parms{dist_first} ne "") ? $parms{dist_first} : $profile{$dmin};
            $profile{dmajor}    = ($parms{dist_major} eq "") ? "auto" : $parms{dist_major};
            $profile{dpr_tics}  = "outside";
            $profile{dop_tics}  = "none";
            $profile{dtitle}    = ($parms{dist_units} eq "kilometers") ? "River Kilometer" : "River Mile";
            $profile{dmax_auto} = 1;
            $profile{dflip_img} = 0;                   # flag set later
            $profile{dmax}      = 0;                   # calculated later
            $profile{d_km}      = 0;                   # calculated later

            $profile{gtfont}    = $profile{dfont};
            $profile{gt_size}   = $profile{dt_size};
            $profile{gt_weight} = 'bold';
            $profile{gs_size}   = $profile{gt_size} -1;
            $profile{gs_weight} = $profile{gt_weight};

            $profile{keyfont}   = $default_family;
            $profile{kn_size}   = $profile{dl_size};
            $profile{kt_size}   = $profile{dl_size} +2;
            $profile{kt_weight} = 'normal';
            $profile{kn_weight} = 'normal';
            $profile{kn_digits} = 1;

            $profile{add_cs}    = 1;
            $profile{cs_height} = &max(2, &min(18, int(($y2-$y1+1) /$parms{ncolors})));
            if ($parms{cscheme} eq "Blue to Orange") {
                $profile{cscheme1} = "Blue";
                $profile{cscheme2} = "Orange";
                $profile{ncolors}  = $parms{ncolors} /2;
            } elsif ($parms{cscheme} eq "Blue to Red") {
                $profile{cscheme1} = "Blue";
                $profile{cscheme2} = "Red";
                $profile{ncolors}  = $parms{ncolors} /2;
            } else {
                $profile{cscheme1} = $parms{cscheme};
                $profile{cscheme2} = "None";
                $profile{ncolors}  = $parms{ncolors};
            }
            $profile{cs_rev}     =  0;
            $profile{cs_hide}    =  0;
            $profile{xleg_off}   = 40;
            $profile{yleg_off}   =  0;
            $profile{cs_width}   = 24;
            $profile{cs_link}    =  0;
            $profile{cs_major}   = "auto";
            $profile{hide_title} =  0;
            $profile{hide_taxis} =  0;
            $profile{hide_daxis} =  0;
        }

        if (defined($parms{title}) && $parms{title} ne "") {
            $profile{keytitle} = $parms{title};
            if ($props{$id}{parm_sav} =~ /^(Temperature|TEMP|Tmin|Tmean|Tmax)$/) {
                $props{$id}{parm} = "Temperature";
            }
        } elsif ($props{$id}{parm_sav} =~ /^(Temperature|TEMP|Tmin|Tmean|Tmax)$/) {
            if ($props{$id}{parm_sav} eq "Temperature" || $props{$id}{parm_sav} eq "TEMP") {
                $profile{keytitle} = "Temperature, in degrees " . $props{$id}{parm_units};
            } elsif ($props{$id}{parm_sav} eq "Tmax") {
                $profile{keytitle} = "Max Temperature, in degrees " . $props{$id}{parm_units};
            } elsif ($props{$id}{parm_sav} eq "Tmean") {
                $profile{keytitle} = "Mean Temperature, in degrees " . $props{$id}{parm_units};
            } elsif ($props{$id}{parm_sav} eq "Tmin") {
                $profile{keytitle} = "Min Temperature, in degrees " . $props{$id}{parm_units};
            }
            $props{$id}{parm} = "Temperature";
        } else {
            $parm_short = $props{$id}{parm};
            $parm_short =~ s/\(ms-1\)//i;
            $parm_short =~ s/\(m3s-1\)//i;
            $parm_short =~ s/ [kmu]?g\/L\/day//i;
            $parm_short =~ s/ [kmu]?g\/m2\/day//i;
            $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
            $parm_short =~ s/ [kmu]?g\/L//i;
            $parm_short =~ s/ [kmu]?g\/m3//i;
            $parm_short =~ s/ [kmu]?g\/m\^3//i;
            $parm_short =~ s/, days//i;
            $parm_short =~ s/ days//i;
            $parm_short =~ s/,$//;
            $profile{keytitle} = $parm_short . ", in " . $props{$id}{parm_units};
        }
        if ($props{$id}{pdiv_sav} =~ /^(Temperature|TEMP|Tmin|Tmean|Tmax)$/) {
            $props{$id}{parm_div} = "Temperature";
        }
        if ($props{$id}{map_type} =~ /^(parmdiff|filediff)$/) {
            if ($props{$id}{pdiv2_sav} =~ /^(Temperature|TEMP|Tmin|Tmean|Tmax)$/) {
                $props{$id}{parm2_div} = "Temperature";
            }
        }
        $profile{gtitle}  = $parms{gtitle};
        $profile{gstitle} = $parms{gstitle};
        $profile{cs_min}  = $parms{pmin};
        $profile{cs_max}  = $parms{pmax};
        $profile{base_yr} = $props{$id}{byear};

        if (@animate_ids && $#animate_ids >= 0) {
            $update_cs = 0;
            foreach $item (@animate_ids) {
                next if ($item == $id);
                next if ($props{$item}{meta} =~ /time_series|w2_wlevels/);
                next if ($props{$item}{meta} eq "w2_outflow" && ! $props{$item}{add_parm});
                if ($gr_props{$item}{cs_link} == 2) {
                    if ($props{$item}{meta} =~ /(w2_slice|w2_profile|w2_outflow)/
                         && $props{$id}{map_type}     eq "standard"
                         && $props{$item}{parm}       eq $props{$id}{parm_sav}
                         && $props{$item}{parm_div}   eq $props{$id}{pdiv_sav}
                         && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                        $update_cs = 1;
                        $id2 = $item;
                        last;
                    } elsif ($props{$item}{meta} eq "w2_tdmap"
                         && $props{$item}{map_type}   eq $props{$id}{map_type}
                         && $props{$item}{parm_sav}   eq $props{$id}{parm_sav}
                         && $props{$item}{pdiv_sav}   eq $props{$id}{pdiv_sav}
                         && $props{$item}{parm_units} eq $props{$id}{parm_units}
                         && ($props{$id}{map_type} eq "standard"
                            || ($props{$item}{parm2_sav} eq $props{$id}{parm2_sav}
                             && $props{$item}{pdiv2_sav} eq $props{$id}{pdiv2_sav}))) {
                        $update_cs = 1;
                        $id2 = $item;
                        last;
                    } elsif ($props{$item}{meta} =~ /data_profile/
                         && $props{$id}{map_type}     eq "standard"
                         && $props{$item}{prof_type}  eq "standard"
                         && $props{$item}{parm}       eq $props{$id}{parm_sav}
                         && $props{$id}{pdiv_sav}     eq "None"
                         && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                        $update_cs = 1;
                        $id2 = $item;
                        last;
                    } elsif ($props{$item}{meta} =~ /vert_wd_zone/
                         && $props{$id}{map_type}   eq "standard"
                         && $props{$id}{parm_sav}   eq "Temperature"
                         && $props{$id}{pdiv_sav}   eq "None"
                         && $props{$item}{wt_units} eq $props{$id}{parm_units}) {
                        $update_cs = 1;
                        $id2 = $item;
                        last;
                    }
                }
            }
            if (! $update_cs) {
                foreach $item (@animate_ids) {
                    next if ($item == $id);
                    next if ($props{$item}{meta} =~ /data_profile|vert_wd_zone|time_series|w2_wlevels/);
                    next if ($props{$item}{meta} eq "w2_outflow" && ! $props{$item}{add_parm});
                    next if ($props{$item}{meta} =~ /w2_tdmap|w2_slice|w2_profile|w2_outflow/
                             && $props{$item}{src_type} ne $src_type);
                    if ($gr_props{$item}{cs_link} == 1) {
                        if ($props{$item}{meta} =~ /w2_slice/
                             && $props{$id}{map_type}     eq "standard"
                             && $props{$item}{parm}       eq $props{$id}{parm_sav}
                             && $props{$item}{parm_div}   eq $props{$id}{pdiv_sav}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}
                             && $props{$item}{con_file}   eq $props{$id}{con_file}) {
                            $update_cs = 1;
                            $id2 = $item;
                            last;
                        } elsif ($props{$item}{meta} eq "w2_tdmap"
                             && $props{$item}{map_type}   eq $props{$id}{map_type}
                             && $props{$item}{parm_sav}   eq $props{$id}{parm_sav}
                             && $props{$item}{pdiv_sav}   eq $props{$id}{pdiv_sav}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}
                             && $props{$item}{con_file}   eq $props{$id}{con_file}
                             && ($props{$id}{map_type} eq "standard"
                                || ($props{$item}{parm2_sav} eq $props{$id}{parm2_sav}
                                 && $props{$item}{pdiv2_sav} eq $props{$id}{pdiv2_sav}
                                 && $props{$item}{src_type2} eq $props{$id}{src_type2}))) {
                            $update_cs = 1;
                            $id2 = $item;
                            last;
                        } elsif ($props{$item}{meta} =~ /w2_profile|w2_outflow/
                             && $props{$id}{map_type}     eq "standard"
                             && $props{$item}{parm}       eq $props{$id}{parm_sav}
                             && $props{$item}{parm_div}   eq $props{$id}{pdiv_sav}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            if ($src_type =~ /Contour/i) {
                                for ($n=0; $n<=$#wbs; $n++) {
                                    if ($cpl_files[$n] eq $props{$item}{src_file}) {
                                        $update_cs = 1;
                                        $id2 = $item;
                                        last;
                                    }
                                }
                                last if ($update_cs);
                            } elsif ($src_type =~ /Vector/i) {
                                if ($props{$id}{w2l_file} eq $props{$item}{src_file}) {
                                    $update_cs = 1;
                                    $id2 = $item;
                                    last;
                                }
                            }
                        }
                    }
                }
            }
            if ($update_cs) {
                $ncolors           = $profile{ncolors};
                $profile{cs_link}  = $gr_props{$id2}{cs_link};
                $profile{cscheme1} = $gr_props{$id2}{cscheme1};
                $profile{cscheme2} = $gr_props{$id2}{cscheme2};
                $profile{ncolors}  = $gr_props{$id2}{ncolors};
                $profile{cs_rev}   = $gr_props{$id2}{cs_rev};
                $profile{cs_min}   = $gr_props{$id2}{cs_min};
                $profile{cs_max}   = $gr_props{$id2}{cs_max};
                $profile{cs_major} = $gr_props{$id2}{cs_major};
                if ($new_graph) {
                    if ($profile{cs_height} *$ncolors > $y2-$y1+1 && $profile{cs_height} > 2) {
                        $profile{cs_height} = &max(2, &min(18, int(($y2-$y1+1) /$profile{ncolors})));
                    }
                } elsif ($ncolors != $profile{ncolors}) {
                    $profile{cs_height} = &max(2, &min(30,
                                   &round_to_int($profile{cs_height} *$ncolors /$profile{ncolors})));
                }
            }
        }
        undef $gr_props{$id} if (! $new_graph);
        $profile{redraw}  = 1;
        $gr_props{$id}    = { %profile };
        $props{$id}{data} = 1;
        $props{$id}{gnum} = ++$graph_num if (! defined($props{$id}{oldcoords}));
        $resized          = 0;
        $refresh_menus    = 0;
        undef %profile;

#       Reset the min/max dates if different jd_skip or byear.
#       The rebuild option is determined in change_w2_tdmap.
        if (! $new_graph) {
            if ($parms{rebuild}) {
                @mydates      = sort keys %td_data;
                $datemin      = substr($mydates[0],0,8);
                $datemax      = substr($mydates[$#mydates],0,8);
                $cmap_datemin = $datemin if ($datemin < $cmap_datemin);
                $cmap_datemax = $datemax if ($datemax > $cmap_datemax);
            }
            $refresh_menus = 1;
            $canv->delete($gtag . "_xaxis");
            $canv->delete($gtag . "_xaxisTitle");
            $canv->delete($gtag . "_yaxis");
            $canv->delete($gtag . "_yaxisTitle");
            $canv->delete($gtag . "_gtitle");
            $canv->delete($gtag . "_colorKey");
            $canv->delete($gtag . "_colorKeyTitle");
            $canv->delete($gtag . "_colorMap");
        }
        undef %parms;

#   Or use previously read info.  If resized, delete graph and redraw
    } else {
        @old_coords    = @{ $props{$id}{oldcoords} };
        $refresh_menus = 0;
        $resized       = 0;
        for ($i=0; $i<=$#coords; $i++) {
            if ($coords[$i] != $old_coords[$i]) {
                $resized = 1;
                last;
            }
        }
        return if (! $resized && ! $props_updated);
        $gr_props{$id}{redraw} = 1 if ($resized || $props_updated == 2);

        %td_data  = %{ $gr_props{$id}{td_data} };
        @wbs      = split(/,/, $props{$id}{wb_list});
        $src_type = $props{$id}{src_type};

        $canv->delete($gtag . "_xaxis");
        $canv->delete($gtag . "_xaxisTitle");
        $canv->delete($gtag . "_yaxis");
        $canv->delete($gtag . "_yaxisTitle");
        $canv->delete($gtag . "_gtitle");
        $canv->delete($gtag . "_colorKey");
        $canv->delete($gtag . "_colorKeyTitle");
        $canv->delete($gtag . "_colorMap") if ($gr_props{$id}{redraw});
    }
    $props{$id}{oldcoords} = [ @coords ];

#   Plot a white rectangle below the graph frame
    @items     = Tkx::SplitList($canv->find_withtag($gtag . "_main"));
    $new_graph = ($#items >= 0) ? 0 : 1;
    if ($new_graph) {
        $box_id = $canv->create_rectangle($x1, $y1, $x2, $y2,
                             -outline => "",
                             -width   => 0,
                             -fill    => &get_rgb_code("white"),
                             -tags    => $gtag . " " . $gtag . "_main");
        $canv->lower($box_id, $id);
    } else {
        $canv->coords($gtag . "_main", @coords);
        $canv->raise($id, $gtag . "_main");
    }

#   Plot the graph subtitle, if present
    if ($gr_props{$id}{date_axis} eq "X") {
        $yp = (! $gr_props{$id}{hide_taxis} &&
                 $gr_props{$id}{top_tics} =~ /outside|cross/) ? $y1-14 : $y1-6;
    } else {
        $yp = (! $gr_props{$id}{hide_daxis} &&
                 $gr_props{$id}{dop_tics} =~ /outside|cross/) ? $y1-14 : $y1-6;
    }
    if ($gr_props{$id}{gstitle} ne "") {
        $stitle_id = $canv->create_text(($x1+$x2)/2., $yp,
                           -anchor => 's',
                           -text   => $gr_props{$id}{gstitle},
                           -fill   => &get_rgb_code("black"),
                           -angle  => 0,
                           -tags   => $gtag . " " . $gtag . "_gtitle",
                           -font   => [-family     => $gr_props{$id}{gtfont},
                                       -size       => $gr_props{$id}{gs_size},
                                       -weight     => $gr_props{$id}{gs_weight},
                                       -slant      => 'roman',
                                       -underline  => 0,
                                       -overstrike => 0,
                                      ]);
        @coords = Tkx::SplitList($canv->bbox($stitle_id));
        $dsize  = &max(10, abs($coords[3] - $coords[1]));
    } else {
        $dsize = 0;
    }

#   Plot the graph title
    $canv->create_text(($x1+$x2)/2., $yp-$dsize,
                       -anchor => 's',
                       -text   => $gr_props{$id}{gtitle},
                       -fill   => &get_rgb_code("black"),
                       -angle  => 0,
                       -tags   => $gtag . " " . $gtag . "_gtitle",
                       -font   => [-family     => $gr_props{$id}{gtfont},
                                   -size       => $gr_props{$id}{gt_size},
                                   -weight     => $gr_props{$id}{gt_weight},
                                   -slant      => 'roman',
                                   -underline  => 0,
                                   -overstrike => 0,
                                  ]);
    if ($gr_props{$id}{hide_title}) {
        $canv->itemconfigure($gtag . "_gtitle", -state => 'hidden');
    }

#   Deal with the color scheme and create the color key
    $cscheme1  = $gr_props{$id}{cscheme1};
    $cscheme2  = $gr_props{$id}{cscheme2};
    $ncolors   = $gr_props{$id}{ncolors};
    $cs_rev    = $gr_props{$id}{cs_rev};
    $cs_min    = $gr_props{$id}{cs_min};
    $cs_max    = $gr_props{$id}{cs_max};
    $kn_digits = $gr_props{$id}{kn_digits};
    if (&list_match($cscheme1, @color_scheme_names) == -1 ||
       (&list_match($cscheme1, @full_color_schemes) == -1 && &list_match($ncolors, @valid_nc) == -1) ||
       (&list_match($cscheme1, @full_color_schemes) >= 0 && &list_match($ncolors, @valid_nc_alt) == -1) ||
       ($cscheme2 ne "" && $cscheme2 ne "None" && &list_match($cscheme2, @color_scheme_names) == -1)) {
        $cscheme1  = $gr_props{$id}{cscheme1}  = "Blue";
        $cscheme2  = $gr_props{$id}{cscheme2}  = "Orange";
        $ncolors   = $gr_props{$id}{ncolors}   = 11;
        $cs_rev    = $gr_props{$id}{cs_rev}    =  0;
        $cs_min    = $gr_props{$id}{cs_min}    =  0;
        $cs_max    = $gr_props{$id}{cs_max}    = 22;
        $kn_digits = $gr_props{$id}{kn_digits} =  1;
    }
    $cs_range = $cs_max -$cs_min;
    @colors   = &make_color_scheme($ncolors, $cs_rev, $cscheme1, $cscheme2);
    @scale    = ();
    for ($i=0; $i<=$#colors+1; $i++) {
        $j = $#colors +1 -$i;
        $scale[$j] = $cs_min +$cs_range*$j/($#colors+1);
    }
    $gr_props{$id}{colors}    = [ @colors ];
    $gr_props{$id}{scale}     = [ @scale  ];

    $color_key_props{xleg}    = $x2 + $gr_props{$id}{xleg_off};
    $color_key_props{yleg}    = $y1 + $gr_props{$id}{yleg_off};
    $color_key_props{width}   = $gr_props{$id}{cs_width};
    $color_key_props{height}  = $gr_props{$id}{cs_height};
    $color_key_props{colors}  = [ @colors ];
    $color_key_props{scale}   = [ @scale  ];
    $color_key_props{title}   = $gr_props{$id}{keytitle};
    $color_key_props{font}    = $gr_props{$id}{keyfont};
    $color_key_props{size1}   = $gr_props{$id}{kn_size};
    $color_key_props{size2}   = $gr_props{$id}{kt_size};
    $color_key_props{weight1} = $gr_props{$id}{kn_weight};
    $color_key_props{weight2} = $gr_props{$id}{kt_weight};
    $color_key_props{digits}  = $kn_digits;
    $color_key_props{major}   = $gr_props{$id}{cs_major};
    $color_key_props{tags}    = $gtag . " " . $gtag . "_colorKey";
    &make_color_key($canv, %color_key_props);
    undef %color_key_props;

    if ($gr_props{$id}{cs_hide}) {
        $canv->itemconfigure($gtag . "_colorKey", -state => 'hidden');
    }

#   The Time/Distance colormap is not animated.
#   Add id to animate_ids array, but no need to reconcile with @dates array.
#   Might need to update the cmap date min/max.
    @mydates = sort keys %td_data;
    if (! defined($cmap_datemin)) {
        $cmap_datemin = substr($mydates[0],0,8);
        $cmap_datemax = substr($mydates[$#mydates],0,8);
    } elsif ($new_graph) {
        $datemin      = substr($mydates[0],0,8);
        $datemax      = substr($mydates[$#mydates],0,8);
        $cmap_datemin = $datemin if ($datemin < $cmap_datemin);
        $cmap_datemax = $datemax if ($datemax > $cmap_datemax);
    }
    if (! @animate_ids || &list_match($id, @animate_ids) == -1) {
        push (@animate_ids, $id);
    }

#   Determine limits of date/time axis
    @jdates = &dates2jdates(@mydates);
    if ($gr_props{$id}{tmin} eq "first" && $gr_props{$id}{tmax} eq "last") {
        $jd_min = &floor($jdates[0] +0.0000001);
        $jd_max = &floor($jdates[$#jdates] +1.0000001);
        if ($gr_props{$id}{ttype} eq "Date/Time") {
            $gr_props{$id}{tmin} = &jdate2datelabel($jd_min, "Mon-DD-YYYY");
            $gr_props{$id}{tmax} = &jdate2datelabel($jd_max, "Mon-DD-YYYY");
        }
    } else {
        if (! defined($gr_props{$id}{base_yr})) {
            $gr_props{$id}{base_yr} = substr($mydates[0],0,4);
        }
        if ($gr_props{$id}{ttype} eq "Date/Time") {
            $jd_min = &datelabel2jdate($gr_props{$id}{tmin});
            $jd_max = &datelabel2jdate($gr_props{$id}{tmax});
        } else {
            $base_jd = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
            $jd_min  = $gr_props{$id}{tmin} +$base_jd -1;
            $jd_max  = $gr_props{$id}{tmax} +$base_jd -1;
        }
    }

#   Plot the date axis -- Date/Time or Julian Date
#   For the date axis, over-ride any user-supplied axis title
    $axis_props{major}   = $gr_props{$id}{tmajor};
    $axis_props{pr_tics} = $gr_props{$id}{tpr_tics};
    $axis_props{op_tics} = $gr_props{$id}{top_tics};
    $axis_props{minor}   = 1;
    $axis_props{reverse} = 0;
    $axis_props{font}    = $gr_props{$id}{tfont};
    $axis_props{size1}   = $gr_props{$id}{tl_size};
    $axis_props{size2}   = $gr_props{$id}{tt_size};
    $axis_props{weight1} = $gr_props{$id}{tl_weight};
    $axis_props{weight2} = $gr_props{$id}{tt_weight};
    if ($gr_props{$id}{date_axis} eq "X") {
        $axis_props{side}   = "bottom";
        $axis_props{tags}   = $gtag . " " . $gtag . "_xaxis";
        $axis_props{coords} = ($gr_props{$id}{tflip}) ? [$x2, $y2, $x1, $y2] : [$x1, $y2, $x2, $y2];
        $axis_props{op_loc} = $y1;
    } else {
        $axis_props{side}   = "left";
        $axis_props{tags}   = $gtag . " " . $gtag . "_yaxis";
        $axis_props{coords} = ($gr_props{$id}{tflip}) ? [$x1, $y2, $x1, $y1] : [$x1, $y1, $x1, $y2];
        $axis_props{op_loc} = $x2;
    }
    if ($gr_props{$id}{ttype} eq "Date/Time") {
        $yr_min = substr($gr_props{$id}{tmin},7,4);
        $yr_max = substr($gr_props{$id}{tmax},7,4);
        $yr_max-- if (substr($gr_props{$id}{tmax},0,3) eq "Jan" &&
                      substr($gr_props{$id}{tmax},4,2) eq "01");
        if ($yr_min == $yr_max) {
            $gr_props{$id}{ttitle} = "Date in $yr_min";
        } else {
            $gr_props{$id}{ttitle} = "Date ($yr_min-$yr_max)";
        }
        $axis_props{min}     = $jd_min;
        $axis_props{max}     = $jd_max;
        $axis_props{title}   = $gr_props{$id}{ttitle};
        $axis_props{datefmt} = $gr_props{$id}{datefmt};
        &make_date_axis($canv, %axis_props);
    } else {
        $axis_props{min}     = $gr_props{$id}{tmin};
        $axis_props{max}     = $gr_props{$id}{tmax};
        $axis_props{title}   = $gr_props{$id}{ttitle};
        &make_axis($canv, %axis_props);
    }
    undef %axis_props;
    if ($gr_props{$id}{hide_taxis}) {
        if ($gr_props{$id}{date_axis} eq "X") {
            $canv->itemconfigure($gtag . "_xaxis",      -state => 'hidden');
            $canv->itemconfigure($gtag . "_xaxisTitle", -state => 'hidden');
        } else {
            $canv->itemconfigure($gtag . "_yaxis",      -state => 'hidden');
            $canv->itemconfigure($gtag . "_yaxisTitle", -state => 'hidden');
        }
    }

#   Initialize some arrays. Get segment list and downstream distance.
    $nwb = $grid{$id}{nwb};
    $nbr = $grid{$id}{nbr};
    @bs  = @{ $grid{$id}{bs}  };
    @be  = @{ $grid{$id}{be}  };
    @us  = @{ $grid{$id}{us}  };
    @ds  = @{ $grid{$id}{ds}  };
    @dlx = @{ $grid{$id}{dlx} };

    if (defined($gr_props{$id}{dist}) && defined($gr_props{$id}{seglist})) {
        @seglist = @{ $gr_props{$id}{seglist} };
        @seg_wb  = @{ $gr_props{$id}{seg_wb}  };
        @dist    = @{ $gr_props{$id}{dist}    };  # saved in units of kilometers
    } else {
        $seg_list   = $props{$id}{seg_list};
        @seg_limits = reverse split(/,|-/, $seg_list);  # reverse the order: ds to us
        @seglist    = ();
        @seg_wb     = ();
        $distance   = $last_seg = $last_jb = 0;
        for ($j=0; $j<=$#seg_limits; $j+=2) {
            $seg_dn = $seg_limits[$j];
            $seg_up = $seg_limits[$j+1];
            for ($jb=1; $jb<=$nbr; $jb++) {
                last if ($seg_dn >= $us[$jb] && $seg_dn <= $ds[$jb]);
            }
            for ($jw=1; $jw<=$nwb; $jw++) {
                last if ($jb >= $bs[$jw] && $jb <= $be[$jw]);
            }
            if ($j > 1 && $last_seg != $us[$last_jb]) {
                $distance       -= $dlx[$last_seg] /2. *0.001;   # km
                $dist[$last_seg] = $distance;
            }
            for ($i=$seg_dn; $i>=$seg_up; $i--) {
                $distance  += $dlx[$i] *0.001;    # km
                $dist[$i]   = $distance;
                $seg_wb[$i] = $jw;
                push (@seglist, $i);
            }
            $last_seg = $seg_up;
            $last_jb  = $jb;
        }
        $gr_props{$id}{seglist} = [ @seglist ];
        $gr_props{$id}{seg_wb}  = [ @seg_wb  ];
        $gr_props{$id}{dist}    = [ @dist    ];
    }
    $mult  = ($gr_props{$id}{dunits} eq "miles") ? 3280.84/5280. : 1.0;
    $dmin  = $gr_props{$id}{dmin};
    $dbase = $gr_props{$id}{dbase};
    if ($gr_props{$id}{dmax_auto}) {
        $distance = &round_to_int(1000.*$dist[$seglist[$#seglist]] *$mult)/1000.;
        $gr_props{$id}{dmax} = $dmax = $dbase +$distance;
    } else {
        $dmax = $gr_props{$id}{dmax};
    }
    $gr_props{$id}{d_km} = $dist[$seglist[$#seglist]];

#   Plot distance axis
    $axis_props{min}     = $dmin;
    $axis_props{max}     = $dmax;
    $axis_props{first}   = $gr_props{$id}{dfirst};
    $axis_props{major}   = $gr_props{$id}{dmajor};
    $axis_props{pr_tics} = $gr_props{$id}{dpr_tics};
    $axis_props{op_tics} = $gr_props{$id}{dop_tics};
    $axis_props{minor}   = 1;
    $axis_props{reverse} = 0;
    $axis_props{title}   = $gr_props{$id}{dtitle};
    $axis_props{font}    = $gr_props{$id}{dfont};
    $axis_props{size1}   = $gr_props{$id}{dl_size};
    $axis_props{size2}   = $gr_props{$id}{dt_size};
    $axis_props{weight1} = $gr_props{$id}{dl_weight};
    $axis_props{weight2} = $gr_props{$id}{dt_weight};
    if ($gr_props{$id}{date_axis} eq "Y") {
        $axis_props{side}   = "bottom";
        $axis_props{tags}   = $gtag . " " . $gtag . "_xaxis";
        $axis_props{coords} = ($gr_props{$id}{dflip}) ? [$x1, $y2, $x2, $y2] : [$x2, $y2, $x1, $y2];
        $axis_props{op_loc} = $y1;
    } else {
        $axis_props{side}   = "left";
        $axis_props{tags}   = $gtag . " " . $gtag . "_yaxis";
        $axis_props{coords} = ($gr_props{$id}{dflip}) ? [$x1, $y1, $x1, $y2] : [$x1, $y2, $x1, $y1];
        $axis_props{op_loc} = $x2;
    }
    &make_axis($canv, %axis_props);
    undef %axis_props;
    if ($gr_props{$id}{hide_daxis}) {
        if ($gr_props{$id}{date_axis} eq "X") {
            $canv->itemconfigure($gtag . "_yaxis",      -state => 'hidden');
            $canv->itemconfigure($gtag . "_yaxisTitle", -state => 'hidden');
        } else {
            $canv->itemconfigure($gtag . "_xaxis",      -state => 'hidden');
            $canv->itemconfigure($gtag . "_xaxisTitle", -state => 'hidden');
        }
    }

#   Refresh the Graph Properties menu and Object Information box, if present
    if ($refresh_menus) {
        if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
            if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
                $tabid = $grprops_notebook->index('current');
                $geom  = $graph_props_menu->g_wm_geometry();
                (undef, $X, $Y) = split(/\+/, $geom);
                &edit_graph_props($id, $X, $Y, $tabid);
            }
        }
        if (defined($object_infobox) && Tkx::winfo_exists($object_infobox)) {
            if ($object_infobox->g_wm_title() =~ /Object Info/) {
                $geom = $object_infobox->g_wm_geometry();
                (undef, $X, $Y) = split(/\+/, $geom);
                &show_info($canv, $id, $X, $Y);
            }
        }
    }

#   Don't recompute and redraw unless necessary
    if ($gr_props{$id}{redraw}) {
        $gr_props{$id}{dflip_img} = 0;
        $gr_props{$id}{tflip_img} = 0;
    }
    if (! $gr_props{$id}{redraw}) {
        $canv->lower($gtag . "_colorKey",      $id);
        $canv->lower($gtag . "_colorKeyTitle", $id);
        $canv->lower($gtag . "_gtitle",        $id);
        $canv->lower($gtag . "_xaxisTitle",    $id);
        $canv->lower($gtag . "_yaxisTitle",    $id);
        $canv->lower($gtag . "_colorMap",      $id);
        $canv->lower($gtag . "_xaxis",         $id);
        $canv->lower($gtag . "_yaxis",         $id);
        if ($group_tags) {
            foreach $tag (@grp_tags) {
                $canv->addtag($tag, withtag => $gtag);
            }
        }
        if ($gr_props{$id}{dflip_img} || $gr_props{$id}{tflip_img}) {         # Flip existing image
            $status_line = "Flipping time/distance map...";
            Tkx::update_idletasks();

            $td_img   = $gr_props{$id}{td_img};
            $img      = Imager->new;
            $img_data = $td_img->data(-format => 'png');
            $img->read(data => $img_data);
            if ($gr_props{$id}{tflip_img} && $gr_props{$id}{dflip_img}) {
                $flip_dir = "vh";
            } elsif ($gr_props{$id}{tflip_img}) {
                $flip_dir = ($gr_props{$id}{date_axis} eq "X") ? "h" : "v";
            } else {
                $flip_dir = ($gr_props{$id}{date_axis} eq "Y") ? "h" : "v";
            }
            $img->flip(dir => $flip_dir);
            $img->write(data => \$img_data, type => 'png');
            $td_img->put($img_data, -format => 'png');

            $canv->itemconfigure($gtag . "_colorMap", -image => $td_img);
            $status_line = "Flipping time/distance map:  Done";
            Tkx::update_idletasks();
            $gr_props{$id}{dflip_img} = 0;
            $gr_props{$id}{tflip_img} = 0;
            $gr_props{$id}{td_img}    = $td_img;
        }
        return;
    }

#   Create an image to hold the colormap and recognize its methods
    $iw = $x2 -$x1 +1;
    $ih = $y2 -$y1 +1;
    $cmap_image = Tkx::image_create_photo(-width => $iw, -height => $ih);
    $cmap_image = Tkx::widget->new($cmap_image);

#   Create a progress bar
    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $geom = sprintf("+%d+%d", $X+($x1+$x2)/2-150, $Y+($y1+$y2)/2);

    $pbar_window = $main->new_toplevel();
    $pbar_window->g_wm_transient($main);
    $pbar_window->g_wm_title("Working on colormap...");
    $pbar_window->g_wm_geometry($geom);
    $pbar_window->configure(-cursor => $cursor_wait);
    $pbar_window->g_focus;

    $pbar_frame = $pbar_window->new_frame(
                    -borderwidth => 2,
                    -relief      => 'groove');
    $pbar_frame->g_pack(-anchor => 'nw', -expand => 1, -fill => 'x');
    ($pbar = $pbar_frame->new_ttk__progressbar(
                    -orient  => 'horizontal',
                    -length  => 300,
                    -mode    => 'determinate',
                    -value   => 0,
                    -maximum => $jd_max -$jd_min,
                    ))->g_pack();

#   Move mouse cursor on first creation, to ensure that it changes to cursor_wait
    if ($new_graph) {
        if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
            $mpointerx = Tkx::winfo_pointerx($main);
            $mpointery = Tkx::winfo_pointery($main);
            $canv->g_bind("<Motion>", "");
            Tkx::event_generate($main, "<Motion>", -warp => 1, -x => ($x1+$x2)/2, -y => ($y1+$y2)/2);
            $canv->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"), $canv, "menu" ]);
        }
    }

#   Change the mouse cursor to tell the user to be patient
    if ($resized) {
        $canv->configure(-cursor => $cursor_wait);
    } else {
        Tkx::tk_busy_hold($main, -cursor => $cursor_wait);
    }
    if ($new_graph) {
        if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
            Tkx::update();
            $canv->g_bind("<Motion>", "");
            Tkx::event_generate("", "<Motion>", -warp => 1, -x => $mpointerx, -y => $mpointery);
            $canv->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"), $canv, "menu" ]);
        }
    }
    $status_line = "Working on colormap.  Please wait...";
    Tkx::update();
    Tkx::wm_resizable($pbar_window,0,0);

#   Create the time/distance colormap
    if ($gr_props{$id}{date_axis} eq "X") {
        $time_on_x = 1;
        $tpix = $iw;
        $dpix = $ih;
    } else {
        $time_on_x = 0;
        $tpix = $ih;
        $dpix = $iw;
    }
    $tflip  = $gr_props{$id}{tflip};
    $dflip  = $gr_props{$id}{dflip};
    $trange = $jd_max -$jd_min;
    $drange = $dmax -$dmin;
    for ($n=0; $n<=$#jdates; $n++) {
        $jd = $jdates[$n];
        next if ($jd < $jd_min);
        last if ($jd > $jd_max);
        if ($n == 0 || $jd == $jd_min) {
            $jd2 = ($jd +$jdates[$n+1])/2.;
            if ($tflip) {
                $tp1 = &round_to_int(($tpix-1)*(1.0-($jd -$jd_min)/$trange));
                $tp2 = &round_to_int(($tpix-1)*(1.0-($jd2-$jd_min)/$trange));
            } else {
                $tp1 = &round_to_int(($tpix-1)*($jd -$jd_min)/$trange);
                $tp2 = &round_to_int(($tpix-1)*($jd2-$jd_min)/$trange);
            }
            next if ($tp1 == $tp2);
        } elsif ($n == $#jdates || $jd == $jd_max) {
            $jd0 = ($jd +$jdates[$n-1])/2.;
            if ($tflip) {
                $tp1 = &round_to_int(($tpix-1)*(1.0-($jd0-$jd_min)/$trange));
                $tp2 = &round_to_int(($tpix-1)*(1.0-($jd -$jd_min)/$trange));
                $tp2 = 0 if (abs($jd_max -$jd) <= 1);
            } else {
                $tp1 = &round_to_int(($tpix-1)*($jd0-$jd_min)/$trange);
                $tp2 = &round_to_int(($tpix-1)*($jd -$jd_min)/$trange);
                $tp2 = $tpix-1 if (abs($jd_max -$jd) <= 1);
            }
        } else {
            $jd0 = ($jd +$jdates[$n-1])/2.;
            $jd2 = ($jd +$jdates[$n+1])/2.;
            if ($tflip) {
                $tp1 = &round_to_int(($tpix-1)*(1.0-($jd0-$jd_min)/$trange));
                $tp2 = &round_to_int(($tpix-1)*(1.0-($jd2-$jd_min)/$trange));
            } else {
                $tp1 = &round_to_int(($tpix-1)*($jd0-$jd_min)/$trange);
                $tp2 = &round_to_int(($tpix-1)*($jd2-$jd_min)/$trange);
            }
            next if ($tp1 == $tp2);
        }
        $tp1 = &max(0, &min($tpix-1, $tp1));
        $tp2 = &max(0, &min($tpix-1, $tp2));
        $pbar->configure(-value => $jd -$jd_min);  # update the progress bar
        Tkx::update_idletasks();

        $dt = $mydates[$n];
        for ($ns=0; $ns<=$#seglist; $ns++) {
            $seg = $seglist[$ns];
            next if (! defined($td_data{$dt}{$seg}) || $td_data{$dt}{$seg} == -99);

#           Distance limits
            $d1 = ($ns == 0) ? 0 : $dist[$seglist[$ns-1]] *$mult;
            $d2 = $dist[$seg] *$mult;
            if ($dflip) {
                $dp1 = &round_to_int(($dpix-1)*($d1 +$dbase -$dmin)/$drange);
                $dp2 = &round_to_int(($dpix-1)*($d2 +$dbase -$dmin)/$drange);
                next if ($dp2 <= 0);
                last if ($dp1 > $dpix-1);
            } else {
                $dp1 = &round_to_int(($dpix-1)*(1.-($d1 +$dbase -$dmin)/$drange));
                $dp2 = &round_to_int(($dpix-1)*(1.-($d2 +$dbase -$dmin)/$drange));
                next if ($dp2 > $dpix-1);
                last if ($dp1 <= 0);
            }
            $dp1 = &max(0, &min($dpix-1, $dp1));
            $dp2 = &max(0, &min($dpix-1, $dp2));
            next if ($dp1 == $dp2 && $ns < $#seglist);

            if ($props{$id}{parm} eq "Temperature" && $props{$id}{parm_units} eq "Fahrenheit") {
                $add = ($props{$id}{map_type} eq "standard") ? 32 : 0;
                $j   = int(($#colors+1) *(($td_data{$dt}{$seg} *1.8 +$add)-$cs_min)/$cs_range);
            } else {
                $j = int(($#colors+1) *($td_data{$dt}{$seg}-$cs_min)/$cs_range);
            }
            $j = &max(0, &min($#colors, $j));
            $cshade = $colors[$j];

          # Consider special cases. Single rows or columns won't plot with 4-arg -to option.
            if ($time_on_x) {
                if ($tp1 != $tp2 && $dp1 != $dp2) {
                    $cmap_image->put($cshade, -to => $tp1, $dp1, $tp2, $dp2);
                } elsif ($tp1 != $tp2) {
                    @cdata    = ();
                    $cdata[0] = $cshade;
                    if ($tp2 > $tp1) {
                        for ($tp=$tp1+1; $tp<=$tp2; $tp++) {
                            $cdata[0] .= " " . $cshade;
                        }
                        $cmap_image->put([ @cdata ], -to => $tp1, $dp1);  # horizontal line
                    } else {
                        for ($tp=$tp2+1; $tp<=$tp1; $tp++) {
                            $cdata[0] .= " " . $cshade;
                        }
                        $cmap_image->put([ @cdata ], -to => $tp2, $dp1);  # horizontal line
                    }
                } elsif ($dp1 != $dp2) {
                    $cvert = $cshade;
                    if ($dp2 > $dp1) {
                        for ($dp=$dp1+1; $dp<=$dp2; $dp++) {
                            $cvert .= " " . $cshade;
                        }
                        $cmap_image->put($cvert, -to => $tp1, $dp1);      # vertical line
                    } else {
                        for ($dp=$dp2+1; $dp<=$dp1; $dp++) {
                            $cvert .= " " . $cshade;
                        }
                        $cmap_image->put($cvert, -to => $tp1, $dp2);      # vertical line
                    }
                } else {
                    $cmap_image->put($cshade, -to => $tp1, $dp1);         # single point
                }
            } else {
                if ($tp1 != $tp2 && $dp1 != $dp2) {
                    $cmap_image->put($cshade, -to => $dp1, $tp1, $dp2, $tp2);
                } elsif ($dp1 != $dp2) {
                    @cdata    = ();
                    $cdata[0] = $cshade;
                    if ($dp2 > $dp1) {
                        for ($dp=$dp1+1; $dp<=$dp2; $dp++) {
                            $cdata[0] .= " " . $cshade;
                        }
                        $cmap_image->put([ @cdata ], -to => $dp1, $tp1);  # horizontal line
                    } else {
                        for ($dp=$dp2+1; $dp<=$dp1; $dp++) {
                            $cdata[0] .= " " . $cshade;
                        }
                        $cmap_image->put([ @cdata ], -to => $dp2, $tp1);  # horizontal line
                    }
                } elsif ($tp1 != $tp2) {
                    $cvert = $cshade;
                    if ($tp2 > $tp1) {
                        for ($tp=$tp1+1; $tp<=$tp2; $tp++) {
                            $cvert .= " " . $cshade;
                        }
                        $cmap_image->put($cvert, -to => $dp1, $tp1);      # vertical line
                    } else {
                        for ($tp=$tp2+1; $tp<=$tp1; $tp++) {
                            $cvert .= " " . $cshade;
                        }
                        $cmap_image->put($cvert, -to => $dp1, $tp2);      # vertical line
                    }
                } else {
                    $cmap_image->put($cshade, -to => $dp1, $tp1);         # single point
                }
            }
            last if ($dp2 >= $dpix-1);
        }
    }
    $canv->create_image($x1, $y1, -anchor => 'nw',
                                  -image  => $cmap_image,
                                  -tags   => $gtag . " " . $gtag . "_colorMap");
    $gr_props{$id}{td_img} = $cmap_image;
    undef $cmap_image;

#   Place the graphic items in the proper order
    &raise_lower($canv, $id, "tiptop") if ($new_graph);
    $canv->lower($gtag . "_colorKey",      $id);
    $canv->lower($gtag . "_colorKeyTitle", $id);
    $canv->lower($gtag . "_gtitle",        $id);
    $canv->lower($gtag . "_xaxisTitle",    $id);
    $canv->lower($gtag . "_yaxisTitle",    $id);
    $canv->lower($gtag . "_colorMap",      $id);
    $canv->lower($gtag . "_xaxis",         $id);
    $canv->lower($gtag . "_yaxis",         $id);
    if ($group_tags) {
        foreach $tag (@grp_tags) {
            $canv->addtag($tag, withtag => $gtag);
        }
    }

#   Restore mouse cursor and remove the progress bar
    $canv->configure(-cursor => $cursor_norm);
    $pbar_window->g_destroy();
    $status_line = "";
    if (! $resized) {
        Tkx::tk_busy_forget($main);
    }
}


sub swap_w2_tdmap_axes {
    my ($canv, $id) = @_;
    my ($geom, $tabid, $X, $Y);

#   The axes could be swapped by re-plotting the axes and re-scaling/rotating
#   the existing colormap, but I'm afraid that the image will degrade. So,
#   it's better to just remake the plot.

#   De-select graph
    &end_select($canv, $id, 1);

#   Swap axes
    $gr_props{$id}{date_axis} = ($gr_props{$id}{date_axis} eq "X") ? "Y" : "X";

#   Remake the graph and force a redraw
    &make_w2_tdmap($canv, $id, 2);

#   Refresh the Graph Properties menu, if present
    if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
        if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
            $tabid = $grprops_notebook->index('current');
            $geom  = $graph_props_menu->g_wm_geometry();
            (undef, $X, $Y) = split(/\+/, $geom);
            &edit_graph_props($id, $X, $Y, $tabid);
        }
    }
}


sub setup_data_profile {
    my ($canv, $id) = @_;
    my (
        $cscheme, $cscheme_cb, $display_units, $elev_base, $f, $frame, $geom,
        $gtitle, $n, $ncolors, $ncolors_cb, $ncolors_na_label, $ok_btn,
        $old_parm_units, $parm, $parm_txt, $parm_units, $parm_units_cb,
        $parm_units_label, $pmajor, $pmajor_entry, $pmajor_label, $pmax,
        $pmax_entry, $pmax_label, $pmin, $pmin_entry, $pmin_label,
        $row, $src_file, $X, $x1, $x2, $Y, $y1, $y2, $yaxis_type,
        $yaxis_type_cb, $yaxis_units, $yaxis_units_label, $ymajor,
        $ymajor_entry, $ymajor_label, $ymax, $ymax_entry, $ymax_label,
        $ymin, $ymin_entry, $ymin_label, $ymin_units_label,

        @cmaps,
       );

    ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $geom = sprintf("+%d+%d", $X+$x1+30, $Y+$y1+50);

    if (defined($profile_setup_menu) && Tkx::winfo_exists($profile_setup_menu)) {
        if ($profile_setup_menu->g_wm_title() eq "Profile Setup") {
            $profile_setup_menu->g_destroy();
            undef $profile_setup_menu;
        }
    }
    $profile_setup_menu = $main->new_toplevel();
    $profile_setup_menu->g_wm_transient($main);
    $profile_setup_menu->g_wm_title("Profile Setup");
    $profile_setup_menu->configure(-cursor => $cursor_norm);
    $profile_setup_menu->g_wm_geometry($geom);

#   Try to keep the nascent graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

    $src_file    = $gtitle = "";
    $parm        = $parm_units = $old_parm_units = $display_units = $parm_txt = "";
    $pmin        = $pmax = $pmajor = "";
    $ymin        = $ymax = $ymajor = "";
    $yaxis_type  = "Elevation";
    $yaxis_units = "feet";
    $cscheme     = "Blue to Orange";
    $ncolors     = 20;
    $elev_base   = -999;

#   Available initial colormaps
    @cmaps = ("None", "Blue to Orange", "Blue to Red", "CoolWarm", "Turbo", "Viridis");
    shift @cmaps if ($props{$id}{meta} eq "data_profile_cmap");

    $frame = $profile_setup_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -state   => 'disabled',
            -command => sub { my (%parms);
                              if ($src_file eq "" || ! -e $src_file) {
                                  return &pop_up_error($profile_setup_menu,
                                  "Data profile file not set or does not exist:\n$src_file");
                              }
                              if ($pmin eq "" || $pmax eq "") {
                                  return &pop_up_error($profile_setup_menu,
                                      "Please provide both a minimum and\n"
                                    . "and maximum parameter value.");
                              }
                              if ($pmin >= $pmax) {
                                  return &pop_up_error($profile_setup_menu,
                                      "The minimum parameter value must be less\n"
                                    . "than the maximum parameter value.");
                              }
                              if ($yaxis_type eq "Elevation") {
                                  if ($ymin eq "" || $ymax eq "") {
                                      return &pop_up_error($profile_setup_menu,
                                      "Please provide both a minimum and maximum elevation.");
                                  }
                                  if ($ymin >= $ymax) {
                                      return &pop_up_error($profile_setup_menu,
                                      "The minimum elevation must be less than the maximum elevation.");
                                  }
                              } else {
                                  if ($ymax eq "") {
                                      return &pop_up_error($profile_setup_menu,
                                      "Please provide a maximum depth.");
                                  }
                              }
                              $gtitle =~ s/^\s+//;
                              $gtitle =~ s/\s+$//;

                              %parms             = ();
                              $parms{pmin}       = $pmin;
                              $parms{pmax}       = $pmax;
                              $parms{pmajor}     = $pmajor;
                              $parms{ymin}       = $ymin;
                              $parms{ymax}       = $ymax;
                              $parms{ymajor}     = $ymajor;
                              $parms{ytype}      = $yaxis_type;
                              $parms{yunits}     = $yaxis_units;
                              $parms{cscheme}    = $cscheme;
                              $parms{ncolors}    = $ncolors;
                              $parms{gtitle}     = $gtitle;
                              $props{$id}{parms} = { %parms };

                              $props{$id}{files}      = 1;
                              $props{$id}{src_file}   = $src_file;
                              $props{$id}{parm}       = $parm;
                              $props{$id}{parm_units} = $parm_units;
                              $props{$id}{prof_type}  = "standard";     # standard or difference

                              $profile_setup_menu->g_bind('<Destroy>', "");
                              $profile_setup_menu->g_destroy();
                              undef $profile_setup_menu;
                              &reset_bindings;

                              &make_data_profile($canv, $id, 0);
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $profile_setup_menu->g_bind('<Destroy>', "");
                              $profile_setup_menu->g_destroy();
                              undef $profile_setup_menu;
                              $canv->delete("graph" . $id);
                              delete $props{$id};
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Delete graph if this menu is destroyed by other than the Cancel button
    $profile_setup_menu->g_bind('<Destroy>' => sub { undef $profile_setup_menu;
                                                     $canv->delete("graph" . $id);
                                                     delete $props{$id}; 
                                                     &reset_bindings;
                                                   });

    $f = $profile_setup_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "Profile Data File: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$src_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);
    $f->new_button(
            -text    => "Browse",
            -command => sub { my ($file, $status, %meta);
                              $file = Tkx::tk___getOpenFile(
                                      -parent           => $profile_setup_menu,
                                      -title            => "Select Profile Data File",
                                      -initialdir       => abs_path(),
                                      -defaultextension => ".csv",
                                      -filetypes => [ ['CSV (comma delimited)', '.csv'],
                                                      ['All Files', '*'],
                                                    ],
                                      );
                              if (defined($file) && -e $file && -r $file && ! -z $file) {
                                  $src_file = File::Spec->rel2abs($file);
                                  ($status, %meta) = &scan_profile($profile_setup_menu, $src_file);
                                  if ($status ne "okay") {
                                      $src_file = "";
                                      $ok_btn->configure(-state => 'disabled');
                                      return &pop_up_error($profile_setup_menu,
                                            "Specified file is not a profile data file "
                                          . "or is incomplete:\n$file");
                                  }
                                  if (defined($meta{parm})) {
                                      $parm = $meta{parm};
                                      if (defined($meta{parm_units})) {
                                          $parm_units = $meta{parm_units};
                                          if ($parm_units =~ /^(Celsius|Fahrenheit)$/) {
                                              $display_units = "\N{U+00B0}" . substr($parm_units,0,1);
                                          } else {
                                              $display_units = $parm_units;
                                          }
                                      }
                                      if ($parm =~ /Temperature/i) {
                                          $parm_txt = "Temperature, in degrees " . ucfirst($parm_units);
                                          $pmin_label->configure(-text => "Temperature Min: ");
                                          $pmax_label->configure(-text => "Temperature Max: ");
                                          $parm_units_label->g_grid();
                                          $parm_units_cb->g_grid();
                                          if ($props{$id}{meta} eq "data_profile") {
                                              $pmajor_label->configure(-text => "Temperature Major: ");
                                              $gtitle = "Temperature Profile";
                                          } else {
                                              $gtitle = "Temperature Colormap";
                                          }
                                      } else {
                                          $parm_txt = $parm . ", in " . $parm_units;
                                          $pmin_label->configure(-text => "Parameter Min: ");
                                          $pmax_label->configure(-text => "Parameter Max: ");
                                          $parm_units_label->g_grid_remove();
                                          $parm_units_cb->g_grid_remove();
                                          if ($props{$id}{meta} eq "data_profile") {
                                              $pmajor_label->configure(-text => "Parameter Major: ");
                                              $gtitle = $parm . " Profile";
                                          } else {
                                              $gtitle = $parm . " Colormap";
                                          }
                                      }
                                  }
                                  if (defined($meta{parm_min}) && defined($meta{parm_max})
                                       && $meta{parm_min} ne "" && $meta{parm_max} ne ""
                                       && $meta{parm_max} > $meta{parm_min}) {
                                      $pmin = $meta{parm_min};
                                      $pmax = $meta{parm_max};
                                  }
                                  if (defined($meta{parm_major}) && $meta{parm_major} ne "") {
                                      $pmajor = abs($meta{parm_major});
                                  }
                                  if (defined($meta{ymin}) && defined($meta{ymax})
                                       && $meta{ymin} ne "" && $meta{ymax} ne ""
                                       && $meta{ymax} > $meta{ymin}) {
                                      $ymin = $meta{ymin};
                                      $ymax = $meta{ymax};
                                      $elev_base = &min($ymin, $ymax);
                                  } elsif (defined($meta{ymax}) && $meta{ymax} ne "") {
                                      $ymax = $meta{ymax};
                                      $ymin = "";
                                  }
                                  if (defined($meta{ymajor}) && $meta{ymajor} ne "") {
                                      $ymajor = abs($meta{ymajor});
                                  }
                                  if (defined($meta{ytype})
                                       && $meta{ytype} =~ /^(Elevation|Depth)$/) {
                                      $yaxis_type = $meta{ytype};
                                      if ($yaxis_type eq "Elevation") {
                                          $ymin_label->g_grid();
                                          $ymin_entry->g_grid();
                                          $ymin_units_label->g_grid();
                                          $ymax_label->configure(-text => "Elevation Max: ");
                                          $ymajor_label->configure(-text => "Elevation Major: ");
                                          $yaxis_units_label->configure(-text => "Elevation Units: ");
                                      } else {
                                          $ymin_label->g_grid_remove();
                                          $ymin_entry->g_grid_remove();
                                          $ymin_units_label->g_grid_remove();
                                          $ymax_label->configure(-text => "Depth Max: ");
                                          $ymajor_label->configure(-text => "Depth Major: ");
                                          $yaxis_units_label->configure(-text => "Depth Units: ");
                                      }
                                  }
                                  if (defined($meta{yunits})
                                       && $meta{yunits} =~ /^(feet|meters)$/) {
                                      $yaxis_units = $meta{yunits};
                                  }
                                  $ok_btn->configure(-state => 'normal');
                              } else {
                                  $ok_btn->configure(-state => 'disabled');
                              }
                            },
            )->g_grid(-row => $row, -column => 4, -sticky => 'ew', -padx => 2, -pady => 2);

    $row++;
    $f->new_label(
            -text => "Parameter: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$parm_txt,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Y Axis Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($yaxis_type_cb = $f->new_ttk__combobox(
            -textvariable => \$yaxis_type,
            -values       => [ ("Elevation", "Depth") ],
            -state        => 'readonly',
            -width        => 10,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $yaxis_type_cb->g_bind("<<ComboboxSelected>>",
                           sub { if ($yaxis_type eq "Elevation") {
                                     $ymin_label->g_grid();
                                     $ymin_entry->g_grid();
                                     $ymin_units_label->g_grid();
                                     $ymax_label->configure(-text => "Elevation Max: ");
                                     $ymajor_label->configure(-text => "Elevation Major: ");
                                     $yaxis_units_label->configure(-text => "Elevation Units: ");
                                     if ($elev_base != -999 && $ymax ne "") {
                                         $ymin  = $elev_base;
                                         $ymax += $elev_base;
                                     } else {
                                         $ymin = "";
                                     }
                                 } else {
                                     $ymin_label->g_grid_remove();
                                     $ymin_entry->g_grid_remove();
                                     $ymin_units_label->g_grid_remove();
                                     $ymax_label->configure(-text => "Depth Max: ");
                                     $ymajor_label->configure(-text => "Depth Major: ");
                                     $yaxis_units_label->configure(-text => "Depth Units: ");
                                     if ($ymax ne "" && $ymin ne "" && $ymax -$ymin != 0) {
                                         $elev_base = &min($ymin, $ymax);
                                         $ymax      = abs($ymax -$ymin);
                                     } else {
                                         $ymax = "";
                                     }
                                     $ymin = 0;
                                 }
                               }
                          );

    $row++;
    ($ymin_label = $f->new_label(
            -text => "Elevation Min: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ymin_entry = $f->new_entry(
            -textvariable => \$ymin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $ymin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $ymin_entry ]);
    ($ymin_units_label = $f->new_label(
            -textvariable => \$yaxis_units,
            -font         => 'default',
            -anchor       => 'w',
            ))->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    ($ymax_label = $f->new_label(
            -text => "Elevation Max: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ymax_entry = $f->new_entry(
            -textvariable => \$ymax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $ymax_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($ymax_entry);
                                              $ymax =~ s/^-// if ($yaxis_type eq "Depth");
                                            });
    $f->new_label(
            -textvariable => \$yaxis_units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    ($ymajor_label = $f->new_label(
            -text => "Elevation Major: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ymajor_entry = $f->new_entry(
            -textvariable => \$ymajor,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $ymajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($ymajor_entry, 1);
                                                $ymajor =~ s/^-//;
                                              });
    $f->new_label(
            -textvariable => \$yaxis_units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    ($yaxis_units_label = $f->new_label(
            -text => "Elevation Units: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_ttk__combobox(
            -textvariable => \$yaxis_units,
            -values       => [ ("feet", "meters") ],
            -state        => 'readonly',
            -width        => 7,
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    ($pmin_label = $f->new_label(
            -text => "Parameter Min: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmin_entry = $f->new_entry(
            -textvariable => \$pmin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmin_entry ]);
    $f->new_label(
            -textvariable => \$display_units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    ($pmax_label = $f->new_label(
            -text => "Parameter Max: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmax_entry = $f->new_entry(
            -textvariable => \$pmax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmax_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmax_entry ]);
    $f->new_label(
            -textvariable => \$display_units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    if ($props{$id}{meta} eq "data_profile") {
        $row++;
        ($pmajor_label = $f->new_label(
                -text => "Parameter Major: ",
                -font => 'default',
                ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($pmajor_entry = $f->new_entry(
                -textvariable => \$pmajor,
                -font         => 'default',
                -width        => 7,
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $pmajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($pmajor_entry, 1);
                                                    $pmajor =~ s/^-//;
                                                  });
        $f->new_label(
                -textvariable => \$display_units,
                -font         => 'default',
                -anchor       => 'w',
                )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);
    }

    $row++;
    ($parm_units_label = $f->new_label(
            -text => "Temperature Units: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($parm_units_cb = $f->new_ttk__combobox(
            -textvariable => \$parm_units,
            -values       => [ ("Celsius", "Fahrenheit") ],
            -state        => 'readonly',
            -width        => 12,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $parm_units_cb->g_bind("<<ComboboxSelected>>",
                          sub { $display_units = "\N{U+00B0}" . substr($parm_units,0,1);
                                $pmin = 0 if ($pmin eq "-");
                                $pmax = 0 if ($pmax eq "-");
                                if ($parm_units eq "Celsius" && $old_parm_units eq "Fahrenheit") {
                                    $pmin   = &floor(($pmin -32) /1.8)    if ($pmin   ne "");
                                    $pmax   = &ceil(($pmax -32) /1.8)     if ($pmax   ne "");
                                    $pmajor = &round_to_int($pmajor /1.8) if ($pmajor ne "");
                                } elsif ($parm_units eq "Fahrenheit" && $old_parm_units eq "Celsius") {
                                    $pmin   = &floor($pmin *1.8 +32)      if ($pmin   ne "");
                                    $pmax   = &ceil($pmax *1.8 +32)       if ($pmax   ne "");
                                    $pmajor = &round_to_int($pmajor *1.8) if ($pmajor ne "");
                                }
                                $old_parm_units = $parm_units;
                              });

    $row++;
    $f->new_label(
            -text => "Color Scheme: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($cscheme_cb = $f->new_ttk__combobox(
            -textvariable => \$cscheme,
            -values       => [ @cmaps ],
            -state        => 'readonly',
            -width        => 15,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $cscheme_cb->g_bind("<<ComboboxSelected>>",
                           sub { my ($n);
                                 if ($cscheme eq "None") {
                                     $ncolors_cb->g_grid_remove();
                                     $ncolors_na_label->g_grid();
                                 } else {
                                     $ncolors_na_label->g_grid_remove();
                                     $ncolors_cb->g_grid();
                                     if ($cscheme =~ /CoolWarm|Turbo|Viridis/) {
                                         $ncolors_cb->configure(-values => [ (8 .. 100) ]);
                                     } else {
                                         $ncolors_cb->configure(-values =>
                                             [ (16, 18, 20, 22, 24, 30, 34, 38, 42, 46) ]);
                                         if ($ncolors < 16) {
                                             $ncolors = 16;
                                         } elsif ($ncolors > 46) {
                                             $ncolors = 46;
                                         } else {
                                             foreach $n (reverse @valid_nc) {
                                                 if ($ncolors >= 2 *$n) {
                                                     $ncolors = 2 *$n;
                                                     last;
                                                 }
                                             }
                                         }
                                     }
                                 }
                               });

    $row++;
    $f->new_label(
            -text => "Number of Colors: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ncolors_na_label = $f->new_label(
            -text => "n/a",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $ncolors_na_label->g_grid_remove();
    ($ncolors_cb = $f->new_ttk__combobox(
            -textvariable => \$ncolors,
            -values       => [ (16, 18, 20, 22, 24, 30, 34, 38, 42, 46) ],
            -state        => 'readonly',
            -width        => 4,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Graph Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gtitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);

    if ($cscheme eq "None") {
        $ncolors_cb->g_grid_remove();
        $ncolors_na_label->g_grid();
    } else {
        $ncolors_na_label->g_grid_remove();
        $ncolors_cb->g_grid();
        if ($cscheme =~ /CoolWarm|Turbo|Viridis/) {
            $ncolors_cb->configure(-values => [ (8 .. 100) ]);
        } else {
            $ncolors_cb->configure(-values => [ (16, 18, 20, 22, 24, 30, 34, 38, 42, 46) ]);
            if ($ncolors < 16) {
                $ncolors = 16;
            } elsif ($ncolors > 46) {
                $ncolors = 46;
            } else {
                foreach $n (reverse @valid_nc) {
                    if ($ncolors >= 2 *$n) {
                        $ncolors = 2 *$n;
                        last;
                    }
                }
            }
        }
    }
    $parm_units_label->g_grid_remove();
    $parm_units_cb->g_grid_remove();

    $f->g_grid_columnconfigure(3, -weight => 2);

    Tkx::wm_resizable($profile_setup_menu,0,0);
    &adjust_window_position($profile_setup_menu);
    $profile_setup_menu->g_focus;
}


sub make_data_profile {
    my ($canv, $id, $props_updated) = @_;
    my (
        $add_dateline, $anc, $base_jd, $bot, $box_id, $cmap_image, $cs_max,
        $cs_min, $cs_range, $cs_rev, $cscheme1, $cscheme2, $data_available,
        $date_id, $date_label, $datemax, $datemin, $diff, $dsize, $dt, $dt2,
        $dy, $el_limit, $el1, $el2, $el3, $elev, $first, $geom, $got_depth,
        $group_tags, $gtag, $gtitle, $i, $id2, $ih, $item, $iw, $j, $jd,
        $jd_max, $jd_min, $jd0, $jd2, $kn_digits, $lastpt, $mi, $mismatch,
        $move_mcursor, $mult, $n, $ncolors, $new_graph, $np, $old_elev,
        $pbar, $pbar_frame, $pbar_window, $pt1_in, $pt2_in, $pval, $pval1,
        $pval2, $pval3, $resized, $surf_elev, $tag, $title_size, $top,
        $update_cs, $X, $x1, $x2, $xmax, $xmin, $xp, $xp1, $xp2, $xrange, $Y,
        $y1, $y2, $ymax, $ymin, $yp, $yp1, $yp2, $yr_max, $yr_min, $yrange,

        @colors, @coords, @depths, @elevations, @estimated, @grp_tags,
        @items, @jdates, @mydates, @old_coords, @pdata, @pt_color,
        @pt_elevations, @scale, @tags, @valid_elevs, @valid_pdata,

        %axis_props, %color_key_props, %limits, %parm_data, %parms,
        %profile, %wsurf,
       );

#   For new plots, pop up a menu for file names and parameters
    if (! defined($props{$id}{files})) {
        return &setup_data_profile($canv, $id);
    }

#   Make tag and get coordinates of graph frame
    $gtag   = "graph" . $id;
    @coords = @{ $props{$id}{coordlist} };
    ($x1, $y1, $x2, $y2) = @coords;

#   Determine whether group tags are present and save the list
    $group_tags = 0;
    @grp_tags   = ();
    @tags       = Tkx::SplitList($canv->itemcget($id, -tags));
    if (&list_search("group_", @tags) > -1) {
        $group_tags = 1;
        foreach $tag (@tags) {
            push (@grp_tags, $tag) if ($tag =~ /^group_/);
        }
    }

#   Read the file
    if (! defined($props{$id}{data})) {
        %parms              = %{ $props{$id}{parms} };
        %profile            = &read_profile($main, $props{$id}{src_file});

#       Find minimum and maximum elevation and parameter values
        %limits             = &find_data_limits($id, %profile);
        $profile{date_min}  = $limits{date_min};
        $profile{date_max}  = $limits{date_max};
        $profile{dpth_min}  = $limits{dpth_min};
        $profile{dpth_max}  = $limits{dpth_max};
        $profile{elev_min}  = $limits{elev_min};
        $profile{elev_max}  = $limits{elev_max};
        $profile{parm_min}  = $limits{parm_min};
        $profile{parm_max}  = $limits{parm_max};
        undef %limits;

        $profile{yfont}     = $default_family;
        $profile{yl_size}   = &min(11, &max(8, int((abs($x2-$x1)+abs($y2-$y1))/2./41)));
        $profile{yt_size}   = $profile{yl_size} +2;
        $profile{yl_weight} = 'normal';
        $profile{yt_weight} = 'normal';
        $profile{ytype}     = $parms{ytype};
        $profile{yunits}    = $parms{yunits};
        $profile{ymin}      = ($parms{ymin} ne "") ? $parms{ymin} : 0;
        $profile{ymax}      = $parms{ymax};
        $profile{ymajor}    = ($parms{ymajor} eq "") ? "auto" : $parms{ymajor};
        $profile{ypr_tics}  = "outside";
        $profile{yop_tics}  = "none";
        $profile{ytitle}    = $parms{ytype} . ", in " . $parms{yunits};

        $profile{xfont}     = $profile{yfont};
        $profile{xl_size}   = $profile{yl_size};
        $profile{xt_size}   = $profile{yt_size};
        $profile{xl_weight} = $profile{yl_weight};
        $profile{xt_weight} = $profile{yt_weight};
        $profile{xpr_tics}  = "outside";
        $profile{xop_tics}  = "none";

        $profile{gtfont}    = $profile{yfont};
        $profile{gt_size}   = $profile{yt_size};
        $profile{gt_weight} = 'bold';
        $profile{gtitle}    = $parms{gtitle};

        $profile{keyfont}   = $default_family;
        $profile{kn_size}   = $profile{yl_size};
        $profile{kt_size}   = $profile{yl_size} +2;
        $profile{kt_weight} = 'normal';
        $profile{kn_weight} = 'normal';
        $profile{kn_digits} = 1;
        if ($props{$id}{parm} =~ /Temperature/i) {
            $profile{keytitle} = "Water temperature, in degrees " . $props{$id}{parm_units};
        } else {
            $profile{keytitle} = $props{$id}{parm} . ", in " . $props{$id}{parm_units};
        }

        if ($parms{cscheme} eq "None") {
            $profile{add_cs}    =  0;
            $profile{cscheme1}  = "Blue";
            $profile{cscheme2}  = "Orange";
            $profile{ncolors}   = 20;
            $profile{cs_height} = &max(2, &min(18, int(($y2-$y1+1) /$profile{ncolors})));
        } else {
            $profile{add_cs}    =  1;
            $profile{cs_height} = &max(2, &min(18, int(($y2-$y1+1) /$parms{ncolors})));
            if ($parms{cscheme} eq "Blue to Orange") {
                $profile{cscheme1} = "Blue";
                $profile{cscheme2} = "Orange";
                $profile{ncolors}  = $parms{ncolors} /2;
            } elsif ($parms{cscheme} eq "Blue to Red") {
                $profile{cscheme1} = "Blue";
                $profile{cscheme2} = "Red";
                $profile{ncolors}  = $parms{ncolors} /2;
            } else {
                $profile{cscheme1} = $parms{cscheme};
                $profile{cscheme2} = "None";
                $profile{ncolors}  = $parms{ncolors};
            }
        }
        $profile{cs_min}   = $parms{pmin};
        $profile{cs_max}   = $parms{pmax};
        $profile{cs_rev}   =  0;
        $profile{cs_hide}  =  0;
        $profile{xleg_off} = 40;
        $profile{yleg_off} =  0;
        $profile{cs_width} = 24;
        $profile{cs_major} = "auto";

        if ($props{$id}{meta} eq "data_profile_cmap") {
            $profile{xmajor}    = "auto";
            $profile{datefmt}   = "Month";
            $profile{xmin}      = "first";
            $profile{xmax}      = "last";
            $profile{xtype}     = "Date/Time";
            $profile{dateline}  = 1;
            $profile{datelinec} = "black";
        } else {
            $profile{xmin}      = $parms{pmin};
            $profile{xmax}      = $parms{pmax};
            $profile{xmajor}    = ($parms{pmajor} eq "") ? "auto" : $parms{pmajor};
            $profile{xtitle}    = $profile{keytitle};
            $profile{gs_size}   = $profile{gt_size} -1;
            $profile{gs_weight} = $profile{gt_weight};
        }
        $profile{cs_link} = 0;
        if ($profile{add_cs} && @animate_ids && $#animate_ids >= 0) {
            $update_cs = 0;
            foreach $item (@animate_ids) {
                next if ($props{$item}{meta} =~ /time_series|w2_wlevels/);
                next if ($props{$item}{meta} eq "w2_outflow" && ! $props{$item}{add_parm});
                if ($gr_props{$item}{cs_link} == 2) {
                    if ($props{$item}{meta} =~ /data_profile/
                         && $props{$item}{prof_type}  eq "standard"
                         && $props{$item}{parm}       eq $props{$id}{parm}
                         && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                        $update_cs = 1;
                        $id2 = $item;
                        last;
                    } elsif ($props{$item}{meta} =~ /(w2_profile|w2_slice|w2_outflow)/
                         && $props{$item}{parm}       eq $props{$id}{parm}
                         && $props{$item}{parm_div}   eq "None"
                         && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                        $update_cs = 1;
                        $id2 = $item;
                        last;
                    } elsif ($props{$item}{meta} eq "w2_tdmap"
                         && $props{$item}{map_type}   eq "standard"
                         && $props{$item}{parm_sav}   eq $props{$id}{parm}
                         && $props{$item}{pdiv_sav}   eq "None"
                         && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                        $update_cs = 1;
                        $id2 = $item;
                        last;
                    } elsif ($props{$item}{meta} =~ /vert_wd_zone/
                         && $props{$id}{parm}       eq "Temperature"
                         && $props{$item}{wt_units} eq $props{$id}{parm_units}) {
                        $update_cs = 1;
                        $id2 = $item;
                        last;
                    }
                }
            }
            if (! $update_cs) {
                foreach $item (@animate_ids) {
                    next if ($props{$item}{meta}
                               =~ /w2_profile|w2_slice|w2_tdmap|w2_outflow|time_series|w2_wlevels/);
                    if ($gr_props{$item}{cs_link} == 1) {
                        if ($props{$item}{meta} =~ /data_profile/
                             && $props{$item}{prof_type}  eq "standard"
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}
                             && $props{$item}{src_file}   eq $props{$id}{src_file}) {
                            $update_cs = 1;
                            $id2 = $item;
                            last;
                        } elsif ($props{$item}{meta} =~ /vert_wd_zone/
                             && $props{$id}{parm}       eq "Temperature"
                             && $props{$item}{wt_units} eq $props{$id}{parm_units}
                             && $props{$item}{wt_file}  eq $props{$id}{src_file}) {
                            $update_cs = 1;
                            $id2 = $item;
                            last;
                        }
                    }
                }
            }
            if ($update_cs) {
                $ncolors           = $profile{ncolors};
                $profile{cs_link}  = $gr_props{$id2}{cs_link};
                $profile{cscheme1} = $gr_props{$id2}{cscheme1};
                $profile{cscheme2} = $gr_props{$id2}{cscheme2};
                $profile{ncolors}  = $gr_props{$id2}{ncolors};
                $profile{cs_rev}   = $gr_props{$id2}{cs_rev};
                $profile{cs_min}   = $gr_props{$id2}{cs_min};
                $profile{cs_max}   = $gr_props{$id2}{cs_max};
                $profile{cs_major} = $gr_props{$id2}{cs_major};
                if ($profile{cs_height} *$ncolors > $y2-$y1+1 && $profile{cs_height} > 2) {
                    $profile{cs_height} = &max(2, &min(18, int(($y2-$y1+1) /$profile{ncolors})));
                }
            }
        }
        $profile{redraw}  = 1;
        $gr_props{$id}    = { %profile };
        $props{$id}{data} = 1;
        $props{$id}{gnum} = ++$graph_num;
        $resized = 0;
        undef %profile;

#   Or use previously read info.  If resized, delete graph and redraw
    } else {
        @old_coords = @{ $props{$id}{oldcoords} };
        $resized = 0;
        for ($i=0; $i<=$#coords; $i++) {
            if ($coords[$i] != $old_coords[$i]) {
                $resized = 1;
                last;
            }
        }
        return if (! $resized && ! $props_updated);
        $gr_props{$id}{redraw} = 1 if ($resized);

        $canv->delete($gtag . "_xaxis");
        $canv->delete($gtag . "_xaxisTitle");
        $canv->delete($gtag . "_yaxis");
        $canv->delete($gtag . "_yaxisTitle");
        $canv->delete($gtag . "_date");
        $canv->delete($gtag . "_gtitle");
        $canv->delete($gtag . "_colorKey");
        $canv->delete($gtag . "_colorKeyTitle");
        $canv->delete($gtag . "_colorMapDateline");
        if ($gr_props{$id}{redraw}) {
            $canv->delete($gtag . "_profile");
            $canv->delete($gtag . "_colorProfile");
            $canv->delete($gtag . "_colorMap");
        }
    }
    $props{$id}{oldcoords} = [ @coords ];

#   Plot a white rectangle below the graph frame
    @items     = Tkx::SplitList($canv->find_withtag($gtag . "_main"));
    $new_graph = ($#items >= 0) ? 0 : 1;
    if ($new_graph) {
        $box_id = $canv->create_rectangle($x1, $y1, $x2, $y2,
                             -outline => "",
                             -width   => 0,
                             -fill    => &get_rgb_code("white"),
                             -tags    => $gtag . " " . $gtag . "_main");
        $canv->lower($box_id, $id);
    } else {
        $canv->coords($gtag . "_main", @coords);
        $canv->raise($id, $gtag . "_main");
    }

#   Plot Y axis
    $axis_props{min}     = $gr_props{$id}{ymin};
    $axis_props{max}     = $gr_props{$id}{ymax};
    $axis_props{major}   = $gr_props{$id}{ymajor};
    $axis_props{pr_tics} = $gr_props{$id}{ypr_tics};
    $axis_props{op_tics} = $gr_props{$id}{yop_tics};
    $axis_props{minor}   = 1;
    $axis_props{reverse} = ($gr_props{$id}{ytype} eq "Depth") ? 1 : 0;
    $axis_props{title}   = $gr_props{$id}{ytitle};
    $axis_props{font}    = $gr_props{$id}{yfont};
    $axis_props{size1}   = $gr_props{$id}{yl_size};
    $axis_props{size2}   = $gr_props{$id}{yt_size};
    $axis_props{weight1} = $gr_props{$id}{yl_weight};
    $axis_props{weight2} = $gr_props{$id}{yt_weight};
    $axis_props{side}    = "left";
    $axis_props{tags}    = $gtag . " " . $gtag . "_yaxis";
    $axis_props{coords}  = [$x1, $y2, $x1, $y1];
    $axis_props{op_loc}  = $x2;
    &make_axis($canv, %axis_props);
    undef %axis_props;

    $mult   = ($gr_props{$id}{yunits} eq "feet") ? 3.28084 : 1.0;
    $ymin   = $gr_props{$id}{ymin} /$mult;
    $ymax   = $gr_props{$id}{ymax} /$mult;
    $yrange = $ymax -$ymin;

#   Deal with optional color scheme and create optional color key
    if ($gr_props{$id}{add_cs} || $props{$id}{meta} eq "data_profile_cmap") {
        $cscheme1  = $gr_props{$id}{cscheme1};
        $cscheme2  = $gr_props{$id}{cscheme2};
        $ncolors   = $gr_props{$id}{ncolors};
        $cs_rev    = $gr_props{$id}{cs_rev};
        $cs_min    = $gr_props{$id}{cs_min};
        $cs_max    = $gr_props{$id}{cs_max};
        $kn_digits = $gr_props{$id}{kn_digits};
        if (&list_match($cscheme1, @color_scheme_names) == -1 ||
           (&list_match($cscheme1, @full_color_schemes) == -1 && &list_match($ncolors, @valid_nc) == -1) ||
           (&list_match($cscheme1, @full_color_schemes) >= 0 && &list_match($ncolors, @valid_nc_alt) == -1) ||
           ($cscheme2 ne "" && $cscheme2 ne "None" && &list_match($cscheme2, @color_scheme_names) == -1)) {
            $cscheme1  = $gr_props{$id}{cscheme1}  = "Blue";
            $cscheme2  = $gr_props{$id}{cscheme2}  = "Orange";
            $ncolors   = $gr_props{$id}{ncolors}   = 11;
            $cs_rev    = $gr_props{$id}{cs_rev}    =  0;
            $cs_min    = $gr_props{$id}{cs_min}    =  0;
            $cs_max    = $gr_props{$id}{cs_max}    = 22;
            $kn_digits = $gr_props{$id}{kn_digits} =  1;
        }
        $cs_range = $cs_max -$cs_min;
        @colors   = &make_color_scheme($ncolors, $cs_rev, $cscheme1, $cscheme2);
        @scale    = ();
        for ($i=0; $i<=$#colors+1; $i++) {
            $j = $#colors +1 -$i;
            $scale[$j] = $cs_min +$cs_range*$j/($#colors+1);
        }
        $gr_props{$id}{colors}    = [ @colors ];
        $gr_props{$id}{scale}     = [ @scale  ];

        $color_key_props{xleg}    = $x2 + $gr_props{$id}{xleg_off};
        $color_key_props{yleg}    = $y1 + $gr_props{$id}{yleg_off};
        $color_key_props{width}   = $gr_props{$id}{cs_width};
        $color_key_props{height}  = $gr_props{$id}{cs_height};
        $color_key_props{colors}  = [ @colors ];
        $color_key_props{scale}   = [ @scale  ];
        $color_key_props{title}   = $gr_props{$id}{keytitle};
        $color_key_props{font}    = $gr_props{$id}{keyfont};
        $color_key_props{size1}   = $gr_props{$id}{kn_size};
        $color_key_props{size2}   = $gr_props{$id}{kt_size};
        $color_key_props{weight1} = $gr_props{$id}{kn_weight};
        $color_key_props{weight2} = $gr_props{$id}{kt_weight};
        $color_key_props{digits}  = $kn_digits;
        $color_key_props{major}   = $gr_props{$id}{cs_major};
        $color_key_props{tags}    = $gtag . " " . $gtag . "_colorKey";
        &make_color_key($canv, %color_key_props);
        undef %color_key_props;

        if ($gr_props{$id}{cs_hide}) {
            $canv->itemconfigure($gtag . "_colorKey", -state => 'hidden');
        }
    }

#   Set some variables and populate some arrays and hashes
    $got_depth = ($gr_props{$id}{elv_dep} eq "elevation") ? 0 : 1;
    if ($got_depth) {
        @depths     = @{ $gr_props{$id}{depths} };
    } else {
        @elevations = @{ $gr_props{$id}{elevations} };
    }
    %parm_data = %{ $gr_props{$id}{pdata} };
    %wsurf     = %{ $gr_props{$id}{ws_elev} };
    @estimated = @{ $gr_props{$id}{estimated} };

#   Set the list of dates or merge the dates array if necessary
#   Add the graph to the list of animated graphs, if necessary
    @mydates = sort keys %parm_data;
    if ($props{$id}{meta} eq "data_profile") {
        if (! @animate_ids || &list_match($id, @animate_ids) == -1) {
            if (@dates && @animate_ids && $#animate_ids >= 0) {
                $mismatch = 0;
                foreach $id2 (@animate_ids) {
#                   next if ($id2 == $id);
                    next if ($props{$id2}{meta}
                               =~ /data_profile_cmap|w2_profile_cmap|w2_profile_matrix|w2_tdmap|time_series/);
                    if ($props{$id2}{meta} =~ /^(w2_profile|w2_slice|w2_outflow|w2_wlevels)$/
                        || ($props{$id2}{meta} eq "data_profile"
                            && $props{$id2}{src_file} ne $props{$id}{src_file})
                        || ($props{$id2}{meta} eq "vert_wd_zone" 
                            && $props{$id2}{wt_file} ne $props{$id}{src_file})) {
                        $mismatch = 1;
                        last;
                    }
                }
                if ($mismatch) {
                    if (defined($animate_tb) && Tkx::winfo_exists($animate_tb)) {
                        if ($animate_tb->g_wm_title() eq "Animation toolbar") {
                            $animate_tb->g_destroy();
                            undef $animate_tb;
                        }
                    }
                    $dt      = $dates[$dti-1];
                    @dates   = &merge_dates(\@dates, \@mydates);
                    $dti_max = $#dates+1;
                    $dti     = 1 + &nearest_dt_index($dt, @dates);
                    $dti++ if ($dti == 0);
                }
            } else {
                @dates   = @mydates;
                $dti_max = $#dates+1;
                $dti     = 1;
                $delay   = 0.5;
            }
            $dti_old = $dti;
            push (@animate_ids, $id);
        }
        $dt = $dates[$dti-1];
        $export_menu->entryconfigure(3, -state => 'normal') if ($use_GS);
        $pref_menu->entryconfigure(0,   -state => 'normal');

    } else {
        if (! defined($cmap_datemin)) {
            $cmap_datemin = substr($mydates[0],0,8);
            $cmap_datemax = substr($mydates[$#mydates],0,8);
        } else {
            $datemin      = substr($mydates[0],0,8);
            $datemax      = substr($mydates[$#mydates],0,8);
            $cmap_datemin = $datemin if ($datemin < $cmap_datemin);
            $cmap_datemax = $datemax if ($datemax > $cmap_datemax);
        }
    }

#   A vertical profile plot is requested
    if ($props{$id}{meta} eq "data_profile") {

#       Adjust the date slightly, or to a daily value, if necessary
        if (length($dt) == 12) {
            if ($gr_props{$id}{daily}) {
                $dt = substr($dt,0,8);
            } elsif (! defined($parm_data{$dt})) {
                for ($mi=1; $mi<=10; $mi++) {
                    $dt2 = &adjust_dt($dt, $mi);
                    if (defined($parm_data{$dt2})) {
                        $dt = $dt2;
                        last;
                    }
                    $dt2 = &adjust_dt($dt, -1 *$mi);
                    if (defined($parm_data{$dt2})) {
                        $dt = $dt2;
                        last;
                    }
                }
            }
        }

#       Determine whether data are available on this date
        if (defined($wsurf{$dt}) && defined($parm_data{$dt})) {
            $data_available = 1;
        } else {
            $data_available = $np = 0;
        }

#       Plot the date as a subtitle
        $xp = ($x1+$x2)/2.;
        $yp = ($gr_props{$id}{xop_tics} =~ /outside|cross/) ? $y1-14 : $y1-6;
        $date_label = &get_formatted_date($dt);
        $date_id = $canv->create_text($xp, $yp,
                           -anchor => 's',
                           -text   => $date_label,
                           -fill   => &get_rgb_code("black"),
                           -angle  => 0,
                           -tags   => $gtag . " " . $gtag . "_date",
                           -font   => [-family     => $gr_props{$id}{gtfont},
                                       -size       => $gr_props{$id}{gs_size},
                                       -weight     => $gr_props{$id}{gs_weight},
                                       -slant      => 'roman',
                                       -underline  => 0,
                                       -overstrike => 0,
                                      ]);
        @coords = Tkx::SplitList($canv->bbox($date_id));
        $dsize  = &max(10, abs($coords[3] - $coords[1]));

#       Plot the graph title
        $canv->create_text($xp, $yp-$dsize,
                           -anchor => 's', 
                           -text   => $gr_props{$id}{gtitle},
                           -fill   => &get_rgb_code("black"),
                           -angle  => 0,
                           -tags   => $gtag . " " . $gtag . "_gtitle",
                           -font   => [-family     => $gr_props{$id}{gtfont},
                                       -size       => $gr_props{$id}{gt_size},
                                       -weight     => $gr_props{$id}{gt_weight},
                                       -slant      => 'roman',
                                       -underline  => 0,
                                       -overstrike => 0,
                                      ]);

#       Plot X axis
        $axis_props{min}     = $gr_props{$id}{xmin};
        $axis_props{max}     = $gr_props{$id}{xmax};
        $axis_props{major}   = $gr_props{$id}{xmajor};
        $axis_props{pr_tics} = $gr_props{$id}{xpr_tics};
        $axis_props{op_tics} = $gr_props{$id}{xop_tics};
        $axis_props{minor}   = 1;
        $axis_props{reverse} = 0;
        $axis_props{title}   = $gr_props{$id}{xtitle};
        $axis_props{font}    = $gr_props{$id}{xfont};
        $axis_props{size1}   = $gr_props{$id}{xl_size};
        $axis_props{size2}   = $gr_props{$id}{xt_size};
        $axis_props{weight1} = $gr_props{$id}{xl_weight};
        $axis_props{weight2} = $gr_props{$id}{xt_weight};
        $axis_props{side}    = "bottom";
        $axis_props{tags}    = $gtag . " " . $gtag . "_xaxis";
        $axis_props{coords}  = [$x1, $y2, $x2, $y2];
        $axis_props{op_loc}  = $y1;
        &make_axis($canv, %axis_props);
        undef %axis_props;

#       Don't recompute and redraw unless necessary
        if (! $gr_props{$id}{redraw}) {
            if ($gr_props{$id}{add_cs}) {
                $canv->lower($gtag . "_colorKey",      $id);
                $canv->lower($gtag . "_colorKeyTitle", $id);
                $canv->lower($gtag . "_colorProfile",  $id);
            }
            $canv->lower($gtag . "_date",       $id);
            $canv->lower($gtag . "_gtitle",     $id);
            $canv->lower($gtag . "_xaxisTitle", $id);
            $canv->lower($gtag . "_yaxisTitle", $id);
            $canv->lower($gtag . "_profile",    $id);
            $canv->lower($gtag . "_xaxis",      $id);
            $canv->lower($gtag . "_yaxis",      $id);
            if ($group_tags) {
                foreach $tag (@grp_tags) {
                    $canv->addtag($tag, withtag => $gtag);
                }
            }
            return;
        }

#       Populate the pt_elevations array.  Keep depths and elevations in meters.
        if ($data_available) {
            $surf_elev = ($wsurf{$dt} ne "na") ? $wsurf{$dt} : 0.0;
            $lastpt    = ($got_depth) ? $#depths : $#elevations;
            @pt_elevations = ();
            for ($i=0; $i<=$lastpt; $i++) {
                if ($got_depth) {
                    push (@pt_elevations, $surf_elev - $depths[$i]);
                } else {
                    push (@pt_elevations, $elevations[$i]);
                }
            }
        }

#       Analyze the vertical profile
        $xmin        = $gr_props{$id}{xmin};
        $xmax        = $gr_props{$id}{xmax};
        $xrange      = $xmax -$xmin;
        @coords      = ();
        @pt_color    = ();
        @valid_pdata = ();
        @valid_elevs = ();
        if ($data_available) {
            @pdata = @{ $parm_data{$dt} };
            if ($props{$id}{parm_units} eq "Fahrenheit") {
                $diff = ($props{$id}{prof_type} eq "difference") ? 0 : 32;
                for ($i=0; $i<=$lastpt; $i++) {
                    next if ($pdata[$i] eq "na");
                    $pdata[$i] = $pdata[$i] *1.8 +$diff;
                }
            }
            for ($i=0; $i<=$lastpt; $i++) {
                next if ($pdata[$i] eq "na");
                next if ($pt_elevations[$i] > $surf_elev +0.1/3.28084);
                next if ($gr_props{$id}{ytype} ne "Depth" && $wsurf{$dt} eq "na");
                $xp = $x1 +($x2-$x1)*($pdata[$i]-$xmin)/$xrange;
                if ($gr_props{$id}{ytype} eq "Depth") {
                    $yp = $y1 +($y2-$y1)*($surf_elev-$pt_elevations[$i])/$ymax;
                } else {
                    $yp = $y2 -($y2-$y1)*($pt_elevations[$i]-$ymin)/$yrange;
                }
                push (@coords, $xp, $yp);
                push (@valid_pdata, $pdata[$i]);
                push (@valid_elevs, $pt_elevations[$i]);
                if ($estimated[$i]) {
                    push (@pt_color, "DarkGray");
                } else {
                    push (@pt_color, "black");
                }
            }
            $np = ($#coords +1)/2;
        }

        if ($gr_props{$id}{add_cs} && $np > 1) {

#           Create an image to hold the color profile and recognize its methods
            $iw = $x2 -$x1 +1;
            $ih = $y2 -$y1 +1;
            $cmap_image = Tkx::image_create_photo(-width => $iw, -height => $ih);
            $cmap_image = Tkx::widget->new($cmap_image);
            $xp1 = 0;
            $xp2 = $iw -1;

            $old_elev = $surf_elev;
            if ($gr_props{$id}{ytype} eq "Depth") {
                $yp2 = 0;
                $el_limit = $surf_elev -$ymax;
            } else {
                $yp2 = &round_to_int($ih-1 -($ih-1)*($old_elev-$ymin)/$yrange);
                $yp2 = &max(0, &min($ih-1, $yp2));
                $el_limit = $ymin;
            }
            $dy = &max(1.0/3.28084, $yrange/($ih-1));
            for ($elev=$surf_elev-$dy; $elev>$el_limit-$dy; $elev-=$dy) {
                $yp1 = $yp2;
                if ($gr_props{$id}{ytype} eq "Depth") {
                    $yp2 = &round_to_int(($ih-1)*($surf_elev-$elev)/$ymax);
                } else {
                    $yp2 = &round_to_int($ih-1 -($ih-1)*($elev-$ymin)/$yrange);
                }
                last if ($yp1 >= $ih-1);
                if ($yp2 < 0) {
                    $old_elev = $elev;
                    $yp2 = 0;
                    next;
                }
                $yp2 = &max(0, &min($ih-1, $yp2));

#               Elevation range of interest is deeper than deepest measurement
                if ($old_elev <= $valid_elevs[$np-1]) {
                    $pval = $valid_pdata[$np-1];
                } else {
                    $first = 1;
                    for ($i=0; $i<$np; $i++) {
                        next if ($valid_elevs[$i] > $surf_elev +0.1/3.28084);
                        $el1   = $valid_elevs[$i];
                        $el2   = $valid_elevs[$i+1] if ($i < $np-1);
                        $el3   = $valid_elevs[$i-1] if ($i > 0 && ! $first);
                        $pval1 = $valid_pdata[$i];
                        $pval2 = $valid_pdata[$i+1] if ($i < $np-1);
                        $pval3 = $valid_pdata[$i-1] if ($i > 0 && ! $first);

#                       Elevation is shallower than first measurement
                        if ($first && $el1 <= $elev) {
                            $pval = $pval1;
                            last;

#                       Measurement is in the elevation range of interest
                        } elsif ($el1 < $old_elev && $el1 >= $elev) {

#                           Shallowest measurement in elevation range of interest
                            if ($first) {
                                $bot  = $pval1 + ($pval2-$pval1)*($el1-$elev)/($el1-$el2);
                                $pval = ($pval1*($old_elev-$el1)
                                        +(($pval1+$bot)/2.)*($el1-$elev))/($old_elev-$elev);
                                last;

#                           Deepest measurement in elevation range of interest
                            } elsif ($i == $np-1) {
                                $top  = $pval3 + ($pval1-$pval3)*($el3-$old_elev)/($el3-$el1);
                                $pval = ((($top+$pval1)/2.)*($old_elev-$el1)
                                        +$pval1*($el1-$elev))/($old_elev-$elev);
                                last;

#                           Not shallowest, not deepest, in range of interest
                            } else {
                                $top  = $pval3 + ($pval1-$pval3)*($el3-$old_elev)/($el3-$el1);
                                $bot  = $pval1 + ($pval2-$pval1)*($el1-$elev)/($el1-$el2);
                                $pval = ((($top+$pval1)/2.)*($old_elev-$el1)
                                        +(($pval1+$bot)/2.)*($el1-$elev))/($old_elev-$elev);
                                last;
                            }

#                       One measurement above and one below the elevation range of interest
                        } elsif ($el1 >= $old_elev && $el2 <= $elev) {
                            $top  = $pval1 + ($pval2-$pval1)*($el1-$old_elev)/($el1-$el2);
                            $bot  = $pval1 + ($pval2-$pval1)*($el1-$elev)/($el1-$el2);
                            $pval = ($top+$bot)/2.;
                            last;
                        }
                        $first = 0;
                    }
                }
                $j = int(($#colors+1) *($pval-$cs_min)/$cs_range);
                $j = &max(0, &min($#colors, $j));
                $cmap_image->put($colors[$j], -to => $xp1, $yp1, $xp2, $yp2);
                $old_elev = $elev;
                last if ($yp2 >= $ih-1);
            }
            $canv->create_image($x1, $y1, -anchor => 'nw',
                                          -image  => $cmap_image,
                                          -tags   => $gtag . " " . $gtag . "_colorProfile");
            undef $cmap_image;
        }

#       Plot the water surface and its indicator, if plotting elevations
        if ($data_available && $gr_props{$id}{ytype} ne "Depth" && $wsurf{$dt} ne "na") {
            $yp = $y2 -($y2-$y1)*($surf_elev-$ymin)/$yrange;
            if ($yp >= $y1 && $yp <= $y2) {
                $canv->create_line($x1, $yp, $x2, $yp,
                                    -fill  => &get_rgb_code("gray60"),
                                    -width => 1,
                                    -arrow => 'none',
                                    -tags  => $gtag . " " . $gtag . "_profile");
                $xp = $x1 + 0.9*($x2-$x1);
                $canv->create_polygon($xp, $yp, $xp-4, $yp-8, $xp+4, $yp-8,
                                    -outline => &get_rgb_code("gray60"),
                                    -width   => 1,
                                    -fill    => &get_rgb_code("white"),
                                    -tags    => $gtag . " " . $gtag . "_profile");
            }
        }

#       Plot the vertical profile
        if ($np > 1) {
            for ($i=1; $i<$np; $i++) {
                $xp1 = $coords[2*$i-2];
                $yp1 = $coords[2*$i-1];
                $xp2 = $coords[2*$i];
                $yp2 = $coords[2*$i+1];
                $pt1_in = ($xp1 >= $x1 && $xp1 <= $x2 &&
                           $yp1 >= $y1 && $yp1 <= $y2) ? 1 : 0;
                $pt2_in = ($xp2 >= $x1 && $xp2 <= $x2 &&
                           $yp2 >= $y1 && $yp2 <= $y2) ? 1 : 0;
                next if (! $pt1_in && ! $pt2_in);
                if (! $pt1_in) {
                    if ($xp1 < $x1) {
                        $yp = $yp1 +($yp2-$yp1) *($x1-$xp1) /($xp2-$xp1);
                        $xp = $x1;
                    } elsif ($xp1 > $x2) {
                        $yp = $yp1 +($yp2-$yp1) *($x2-$xp1) /($xp2-$xp1);
                        $xp = $x2;
                    } else {
                        $xp = $xp1 +($xp2-$xp1) *($y1-$yp1) /($yp2-$yp1);
                        $yp = $y1;
                    }
                    if ($yp < $y1) {
                        $xp = $xp1 +($xp2-$xp1) *($y1-$yp1) /($yp2-$yp1);
                        $yp = $y1;
                    }
                    $xp1 = $xp;
                    $yp1 = $yp;
                } elsif (! $pt2_in) {
                    if ($xp2 < $x1) {
                        $yp = $yp1 +($yp2-$yp1) *($x1-$xp1) /($xp2-$xp1);
                        $xp = $x1;
                    } elsif ($xp2 > $x2) {
                        $yp = $yp1 +($yp2-$yp1) *($x2-$xp1) /($xp2-$xp1);
                        $xp = $x2;
                    } else {
                        $xp = $xp1 +($xp2-$xp1) *($y2-$yp1) /($yp2-$yp1);
                        $yp = $y2;
                    }
                    if ($yp > $y2) {
                        $xp = $xp1 +($xp2-$xp1) *($y2-$yp1) /($yp2-$yp1);
                        $yp = $y2;
                    }
                    $xp2 = $xp;
                    $yp2 = $yp;
                }
                $canv->create_line($xp1, $yp1, $xp2, $yp2,
                                        -fill  => &get_rgb_code($pt_color[$i]),
                                        -width => 1,
                                        -arrow => 'none',
                                        -tags  => $gtag . " " . $gtag . "_profile");
            }
        }

#       Plot a no-data message
        if (! $data_available || $np <= 1) {
            if ($data_available && $gr_props{$id}{ytype} ne "Depth" && $wsurf{$dt} ne "na") {
                $yp  = $y2 -($y2-$y1)*($surf_elev-$ymin)/$yrange +5;
                $anc = 'n';
                if ($yp < $y1 || $yp > $y2) {
                    $yp  = ($y1 +$y2)/2.;
                    $anc = 'center';
                }
            } else {
                $yp  = ($y1 +$y2)/2.;
                $anc = 'center';
            }
            $canv->create_text(($x1+$x2)/2, $yp,
                               -anchor => $anc, 
                               -text   => "No Data",
                               -fill   => &get_rgb_code("gray60"),
                               -angle  => 0,
                               -tags   => $gtag . " " . $gtag . "_profile",
                               -font   => [-family     => $gr_props{$id}{xfont},
                                           -size       => $gr_props{$id}{xl_size},
                                           -weight     => 'normal',
                                           -slant      => 'roman',
                                           -underline  => 0,
                                           -overstrike => 0,
                                          ]);
        }
        undef %wsurf;
        undef %parm_data;

#       Plot the measured points
        for ($i=0; $i<$np; $i++) {
            $xp = $coords[2*$i];
            $yp = $coords[2*$i+1];
            if ($xp >= $x1 && $xp <= $x2 && $yp >= $y1 && $yp <= $y2) {
                if ($gr_props{$id}{add_cs}) {
                    $pval = $valid_pdata[$i];
                    $j    = int(($#colors+1) *($pval-$cs_min)/$cs_range);
                    $j    = &max(0, &min($#colors, $j));
                    $canv->create_oval($xp-3, $yp-3, $xp+3, $yp+3,
                                        -outline => &get_rgb_code($pt_color[$i]),
                                        -width   => 1,
                                        -fill    => $colors[$j],
                                        -tags    => $gtag . " " . $gtag . "_profile");
                } else {
                    $canv->create_oval($xp-3, $yp-3, $xp+3, $yp+3,
                                        -outline => &get_rgb_code($pt_color[$i]),
                                        -width   => 1,
                                        -fill    => &get_rgb_code("white"),
                                        -tags    => $gtag . " " . $gtag . "_profile");
                }
            }
        }

#       Place the graphic items in the proper order
        &raise_lower($canv, $id, "tiptop") if ($new_graph);
        if ($gr_props{$id}{add_cs}) {
            $canv->lower($gtag . "_colorKey",      $id);
            $canv->lower($gtag . "_colorKeyTitle", $id);
            $canv->lower($gtag . "_colorProfile",  $id);
        }
        $canv->lower($gtag . "_date",       $id);
        $canv->lower($gtag . "_gtitle",     $id);
        $canv->lower($gtag . "_xaxisTitle", $id);
        $canv->lower($gtag . "_yaxisTitle", $id);
        $canv->lower($gtag . "_profile",    $id);
        $canv->lower($gtag . "_xaxis",      $id);
        $canv->lower($gtag . "_yaxis",      $id);
        if ($group_tags) {
            foreach $tag (@grp_tags) {
                $canv->addtag($tag, withtag => $gtag);
            }
        }

#       Update any links
        &update_links($canv, $id, $dt);

#   A vertical profile colormap is requested
    } elsif ($props{$id}{meta} eq "data_profile_cmap") {

#       Keep track of graphs that can be animated
#       Colormaps only get a bit of animation when they have an accompanying profile
#       For first creation, ensure mouse cursor is on canvas so it can be changed
        $move_mcursor = 0;
        if (&list_match($id, @animate_ids) == -1) {
            push (@animate_ids, $id);
            $move_mcursor = 1;
        }

        @jdates = &dates2jdates(@mydates);
        if ($gr_props{$id}{xmin} eq "first" && $gr_props{$id}{xmax} eq "last") {
            $jd_min = &floor($jdates[0] +0.0000001);
            $jd_max = &floor($jdates[$#jdates] +1.0000001);
            if ($gr_props{$id}{xtype} eq "Date/Time") {
                $gr_props{$id}{xmin}    = &jdate2datelabel($jd_min, "Mon-DD-YYYY");
                $gr_props{$id}{xmax}    = &jdate2datelabel($jd_max, "Mon-DD-YYYY");
                $gr_props{$id}{base_yr} = substr($mydates[0],0,4);
            }
        } else {
            if (! defined($gr_props{$id}{base_yr})) {
                $gr_props{$id}{base_yr} = substr($mydates[0],0,4);
            }
            if ($gr_props{$id}{xtype} eq "Date/Time") {
                $jd_min = &datelabel2jdate($gr_props{$id}{xmin});
                $jd_max = &datelabel2jdate($gr_props{$id}{xmax});
            } else {
                $base_jd = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
                $jd_min  = $gr_props{$id}{xmin} +$base_jd -1;
                $jd_max  = $gr_props{$id}{xmax} +$base_jd -1;
            }
        }

#       Plot the graph title
        $yp = ($gr_props{$id}{xop_tics} =~ /outside|cross/) ? $y1-18 : $y1-10;
        $canv->create_text(($x1+$x2)/2., $yp,
                           -anchor => 's', 
                           -text   => $gr_props{$id}{gtitle},
                           -fill   => &get_rgb_code("black"),
                           -angle  => 0,
                           -tags   => $gtag . " " . $gtag . "_gtitle",
                           -font   => [-family     => $gr_props{$id}{gtfont},
                                       -size       => $gr_props{$id}{gt_size},
                                       -weight     => $gr_props{$id}{gt_weight},
                                       -slant      => 'roman',
                                       -underline  => 0,
                                       -overstrike => 0,
                                      ]);

#       Plot the X axis -- Date/Time or Julian Date
#       For the date X axis, over-ride any user-supplied axis title
        $axis_props{major}   = $gr_props{$id}{xmajor};
        $axis_props{pr_tics} = $gr_props{$id}{xpr_tics};
        $axis_props{op_tics} = $gr_props{$id}{xop_tics};
        $axis_props{minor}   = 1;
        $axis_props{reverse} = 0;
        $axis_props{font}    = $gr_props{$id}{xfont};
        $axis_props{size1}   = $gr_props{$id}{xl_size};
        $axis_props{size2}   = $gr_props{$id}{xt_size};
        $axis_props{weight1} = $gr_props{$id}{xl_weight};
        $axis_props{weight2} = $gr_props{$id}{xt_weight};
        $axis_props{side}    = "bottom";
        $axis_props{tags}    = $gtag . " " . $gtag . "_xaxis";
        $axis_props{coords}  = [$x1, $y2, $x2, $y2];
        $axis_props{op_loc}  = $y1;
        if ($gr_props{$id}{xtype} eq "Date/Time") {
            $yr_min = substr($gr_props{$id}{xmin},7,4);
            $yr_max = substr($gr_props{$id}{xmax},7,4);
            $yr_max-- if (substr($gr_props{$id}{xmax},0,3) eq "Jan" &&
                          substr($gr_props{$id}{xmax},4,2) eq "01");
            if ($yr_min == $yr_max) {
                $gr_props{$id}{xtitle} = "Date in $yr_min";
            } else {
                $gr_props{$id}{xtitle} = "Date ($yr_min-$yr_max)";
            }
            $axis_props{min}     = $jd_min;
            $axis_props{max}     = $jd_max;
            $axis_props{title}   = $gr_props{$id}{xtitle};
            $axis_props{datefmt} = $gr_props{$id}{datefmt};
            &make_date_axis($canv, %axis_props);
        } else {
            $axis_props{min}     = $gr_props{$id}{xmin};
            $axis_props{max}     = $gr_props{$id}{xmax};
            $axis_props{title}   = $gr_props{$id}{xtitle};
            &make_axis($canv, %axis_props);
        }
        undef %axis_props;

#       Plot the optional dateline
        if ($gr_props{$id}{dateline}) {
            $add_dateline = 0;
            for ($i=0; $i<=$#animate_ids; $i++) {
                $id2 = $animate_ids[$i];
                next if ($id2 == $id);
                next if ($props{$id2}{meta}
                           !~ /^(data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)$/);
                if ($dti != 1) {
                    $add_dateline = 1;
                    last;
                }
            }
            if ($add_dateline) {
                $jd = &date2jdate($dates[$dti-1]);
                if ($jd >= $jd_min && $jd <= $jd_max) {
                    $xp = $x1 + ($x2 -$x1) *($jd -$jd_min)/($jd_max -$jd_min);
                    $canv->create_line($xp, $y1, $xp, $y2,
                                       -fill  => &get_rgb_code($gr_props{$id}{datelinec}),
                                       -width => 1,
                                       -arrow => 'none',
                                       -tags  => $gtag . " " . $gtag . "_colorMapDateline");
                }
            }
        }

#       Don't recompute and redraw unless necessary
        if (! $gr_props{$id}{redraw}) {
            $canv->lower($gtag . "_colorKey",         $id);
            $canv->lower($gtag . "_colorKeyTitle",    $id);
            $canv->lower($gtag . "_gtitle",           $id);
            $canv->lower($gtag . "_xaxisTitle",       $id);
            $canv->lower($gtag . "_yaxisTitle",       $id);
            $canv->lower($gtag . "_colorMap",         $id);
            $canv->lower($gtag . "_colorMapDateline", $id);
            $canv->lower($gtag . "_xaxis",            $id);
            $canv->lower($gtag . "_yaxis",            $id);
            if ($group_tags) {
                foreach $tag (@grp_tags) {
                    $canv->addtag($tag, withtag => $gtag);
                }
            }
            return;
        }

#       Create an image to hold the colormap and recognize its methods
#       This takes time, so don't redraw if it isn't needed
        $iw = $x2 -$x1 +1;
        $ih = $y2 -$y1 +1;
        $cmap_image = Tkx::image_create_photo(-width => $iw, -height => $ih);
        $cmap_image = Tkx::widget->new($cmap_image);

#       Create a progress bar
        $geom = $main->g_wm_geometry();
        (undef, $X, $Y) = split(/\+/, $geom);
        $geom = sprintf("+%d+%d", $X+($x1+$x2)/2-150, $Y+($y1+$y2)/2);

        $pbar_window = $main->new_toplevel();
        $pbar_window->g_wm_transient($main);
        $pbar_window->g_wm_title("Working on colormap...");
        $pbar_window->g_wm_geometry($geom);
        $pbar_window->configure(-cursor => $cursor_wait);
        $pbar_window->g_focus;

        $pbar_frame = $pbar_window->new_frame(
                        -borderwidth => 2,
                        -relief      => 'groove');
        $pbar_frame->g_pack(-anchor => 'nw', -expand => 1, -fill => 'x');
        ($pbar = $pbar_frame->new_ttk__progressbar(
                        -orient  => 'horizontal',
                        -length  => 300,
                        -mode    => 'determinate',
                        -value   => 0,
                        -maximum => $jd_max -$jd_min,
                        ))->g_pack();

#       Move mouse cursor on first creation, to ensure that it changes to cursor_wait
        if ($move_mcursor) {
            if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
                $canv->g_bind("<Motion>", "");
                Tkx::event_generate($main, "<Motion>", -warp => 1, -x => ($x1+$x2)/2, -y => ($y1+$y2)/2);
                $canv->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"), $canv, "menu" ]);
            }
        }

#       Change the mouse cursor to tell the user to be patient
        if ($resized) {
            $canv->configure(-cursor => $cursor_wait);
        } else {
            Tkx::tk_busy_hold($main, -cursor => $cursor_wait);
        }
        $status_line = "Working on colormap.  Please wait...";
        Tkx::update();
        Tkx::wm_resizable($pbar_window,0,0);

#       Set elevations, if constant
        if (! $got_depth) {
            $lastpt = $#elevations;
            @pt_elevations = ();
            for ($i=0; $i<=$lastpt; $i++) {
                push (@pt_elevations, $elevations[$i]);
            }
        }

#       Create the colormap
        for ($n=0; $n<=$#jdates; $n++) {
            $jd = $jdates[$n];
            next if ($jd < $jd_min);
            last if ($jd > $jd_max);
            if ($n == 0 || $jd == $jd_min) {
                $jd2 = ($jd +$jdates[$n+1])/2.;
                $xp1 = &round_to_int(($iw-1)*($jd -$jd_min)/($jd_max-$jd_min));
                $xp2 = &round_to_int(($iw-1)*($jd2-$jd_min)/($jd_max-$jd_min));
                next if ($xp1 == $xp2);
            } elsif ($n == $#jdates || $jd == $jd_max) {
                $jd0 = ($jd +$jdates[$n-1])/2.;
                $xp1 = &round_to_int(($iw-1)*($jd0-$jd_min)/($jd_max-$jd_min));
                $xp2 = &round_to_int(($iw-1)*($jd -$jd_min)/($jd_max-$jd_min));
                $xp2 = $iw-1 if (abs($jd_max -$jd) <= 1);
            } else {
                $jd0 = ($jd +$jdates[$n-1])/2.;
                $jd2 = ($jd +$jdates[$n+1])/2.;
                $xp1 = &round_to_int(($iw-1)*($jd0-$jd_min)/($jd_max-$jd_min));
                $xp2 = &round_to_int(($iw-1)*($jd2-$jd_min)/($jd_max-$jd_min));
                next if ($xp1 == $xp2);
            }
            $xp1 = &max(0, &min($iw-1, $xp1));
            $xp2 = &max(0, &min($iw-1, $xp2));
            $pbar->configure(-value => $jd -$jd_min);  # update the progress bar
            Tkx::update_idletasks();

            $dt        = $mydates[$n];
            $surf_elev = ($wsurf{$dt} ne "na") ? $wsurf{$dt} : 0.0;
            $old_elev  = $surf_elev;
            if ($got_depth) {
                $lastpt = $#depths;
                @pt_elevations = ();
                for ($i=0; $i<=$lastpt; $i++) {
                    push (@pt_elevations, $surf_elev -$depths[$i]);
                }
            }
            $np = 0;
            @valid_pdata = ();
            @valid_elevs = ();
            for ($i=0; $i<=$lastpt; $i++) {
                next if ($parm_data{$dt}[$i] eq "na");
                next if ($pt_elevations[$i] > $surf_elev +0.1/3.28084);
                next if ($gr_props{$id}{ytype} ne "Depth" && $wsurf{$dt} eq "na");
                push (@valid_pdata, $parm_data{$dt}[$i]);
                push (@valid_elevs, $pt_elevations[$i]);
                $np++;
            }
            next if ($np < 2);

#           Convert temperature units, if needed
            if ($props{$id}{parm_units} eq "Fahrenheit") {
                $diff = ($props{$id}{prof_type} eq "difference") ? 0 : 32;
                for ($i=0; $i<=$#valid_pdata; $i++) {
                    $valid_pdata[$i] = $valid_pdata[$i] *1.8 +$diff;
                }
            }

            if ($gr_props{$id}{ytype} eq "Depth") {
                $yp2 = 0;
                $el_limit = $surf_elev -$ymax;
            } else {
                $yp2 = &round_to_int($ih-1 -($ih-1)*($old_elev-$ymin)/$yrange);
                $yp2 = &max(0, &min($ih-1, $yp2));
                $el_limit = $ymin;
            }
            $dy = &max(1.0/3.28084, $yrange/($ih-1));
            for ($elev=$surf_elev-$dy; $elev>$el_limit-$dy; $elev-=$dy) {
                $yp1 = $yp2;
                if ($gr_props{$id}{ytype} eq "Depth") {
                    $yp2 = &round_to_int(($ih-1)*($surf_elev-$elev)/$ymax);
                } else {
                    $yp2 = &round_to_int($ih-1 -($ih-1)*($elev-$ymin)/$yrange);
                }
                last if ($yp1 >= $ih-1);
                if ($yp2 < 0) {
                    $old_elev = $elev;
                    $yp2 = 0;
                    next;
                }
                $yp2 = &max(0, &min($ih-1, $yp2));

#               Elevation range of interest is deeper than deepest measurement
                if ($old_elev <= $valid_elevs[$np-1]) {
                    $pval = $valid_pdata[$np-1];
                } else {
                    $first = 1;
                    for ($i=0; $i<$np; $i++) {
                        next if ($valid_elevs[$i] > $surf_elev +0.1/3.28084);
                        $el1   = $valid_elevs[$i];
                        $el2   = $valid_elevs[$i+1] if ($i < $np-1);
                        $el3   = $valid_elevs[$i-1] if ($i > 0 && ! $first);
                        $pval1 = $valid_pdata[$i];
                        $pval2 = $valid_pdata[$i+1] if ($i < $np-1);
                        $pval3 = $valid_pdata[$i-1] if ($i > 0 && ! $first);

#                       Elevation is shallower than first measurement
                        if ($first && $el1 <= $elev) {
                            $pval = $pval1;
                            last;

#                       Measurement is in the elevation range of interest
                        } elsif ($el1 < $old_elev && $el1 >= $elev) {

#                           Shallowest measurement in elevation range of interest
                            if ($first) {
                                $bot  = $pval1 + ($pval2-$pval1)*($el1-$elev)/($el1-$el2);
                                $pval = ($pval1*($old_elev-$el1)
                                        +(($pval1+$bot)/2.)*($el1-$elev))/($old_elev-$elev);
                                last;

#                           Deepest measurement in elevation range of interest
                            } elsif ($i == $np-1) {
                                $top  = $pval3 + ($pval1-$pval3)*($el3-$old_elev)/($el3-$el1);
                                $pval = ((($top+$pval1)/2.)*($old_elev-$el1)
                                        +$pval1*($el1-$elev))/($old_elev-$elev);
                                last;

#                           Not shallowest, not deepest, in range of interest
                            } else {
                                $top  = $pval3 + ($pval1-$pval3)*($el3-$old_elev)/($el3-$el1);
                                $bot  = $pval1 + ($pval2-$pval1)*($el1-$elev)/($el1-$el2);
                                $pval = ((($top+$pval1)/2.)*($old_elev-$el1)
                                        +(($pval1+$bot)/2.)*($el1-$elev))/($old_elev-$elev);
                                last;
                            }

#                       One measurement above and one below the elevation range of interest
                        } elsif ($el1 >= $old_elev && $el2 <= $elev) {
                            $top  = $pval1 + ($pval2-$pval1)*($el1-$old_elev)/($el1-$el2);
                            $bot  = $pval1 + ($pval2-$pval1)*($el1-$elev)/($el1-$el2);
                            $pval = ($top+$bot)/2.;
                            last;
                        }
                        $first = 0;
                    }
                }
                $j = int(($#colors+1) *($pval-$cs_min)/$cs_range);
                $j = &max(0, &min($#colors, $j));
                $cmap_image->put($colors[$j], -to => $xp1, $yp1, $xp2, $yp2);
                $old_elev = $elev;
                last if ($yp2 >= $ih-1);
            }
        }
        $canv->create_image($x1, $y1, -anchor => 'nw',
                                      -image  => $cmap_image,
                                      -tags   => $gtag . " " . $gtag . "_colorMap");
        undef $cmap_image;
        undef %wsurf;
        undef %parm_data;

#       Place the graphic items in the proper order
        &raise_lower($canv, $id, "tiptop") if ($new_graph);
        $canv->lower($gtag . "_colorKey",         $id);
        $canv->lower($gtag . "_colorKeyTitle",    $id);
        $canv->lower($gtag . "_gtitle",           $id);
        $canv->lower($gtag . "_xaxisTitle",       $id);
        $canv->lower($gtag . "_yaxisTitle",       $id);
        $canv->lower($gtag . "_colorMap",         $id);
        $canv->lower($gtag . "_colorMapDateline", $id);
        $canv->lower($gtag . "_xaxis",            $id);
        $canv->lower($gtag . "_yaxis",            $id);
        if ($group_tags) {
            foreach $tag (@grp_tags) {
                $canv->addtag($tag, withtag => $gtag);
            }
        }

#       Restore mouse cursor and remove the progress bar
        $canv->configure(-cursor => $cursor_norm);
        $pbar_window->g_destroy();
        $status_line = "";
        if (! $resized) {
            Tkx::tk_busy_forget($main);
        }
    }
}


sub setup_wd_zone {
    my ($canv, $id) = @_;
    my (
        $bth_file, $cscheme, $cscheme_cb, $elbot, $elbot_frame, $elbot_entry,
        $elbot_units, $elev_base, $f, $flow_file, $frame, $geom, $gtitle,
        $gtitle_char, $lbc_btn, $lbc_file, $lbc_label1, $lbc_label2, $n,
        $ncolors, $ncolors_cb, $ncolors_na_label, $ok_btn, $qaxis_units,
        $qmajor, $qmajor_entry, $qmax, $qmax_entry, $row, $seg, $seg_entry,
        $wd_alg, $wd_cb, $wt_degunits, $wt_file, $wt_max, $wt_max_entry,
        $wt_max_label, $wt_max_units_label, $wt_min, $wt_min_entry,
        $wt_min_label, $wt_min_units_label, $wt_oldunits, $wt_units,
        $wt_units_cb, $wt_units_label, $X, $x1, $x2, $Y, $y1, $y2,
        $yaxis_type, $yaxis_type_cb, $yaxis_units, $yaxis_units_label,
        $ymajor, $ymajor_entry, $ymajor_label, $ymax, $ymax_entry,
        $ymax_label, $ymin, $ymin_entry, $ymin_label, $ymin_units_label,

        @cmaps,
       );

    ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $geom = sprintf("+%d+%d", $X+$x1+30, $Y+$y1+50);

    if (defined($wdzone_setup_menu) && Tkx::winfo_exists($wdzone_setup_menu)) {
        if ($wdzone_setup_menu->g_wm_title() eq "Withdrawal Zone Setup") {
            $wdzone_setup_menu->g_destroy();
            undef $wdzone_setup_menu;
        }
    }
    $wdzone_setup_menu = $main->new_toplevel();
    $wdzone_setup_menu->g_wm_transient($main);
    $wdzone_setup_menu->g_wm_title("Withdrawal Zone Setup");
    $wdzone_setup_menu->configure(-cursor => $cursor_norm);
    $wdzone_setup_menu->g_wm_geometry($geom);

#   Try to keep the nascent graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

    $wt_file = $bth_file = $flow_file = $lbc_file = "";
    $ymin    = $ymax     = $ymajor    = $seg      = "";
    $qmax    = $qmajor   = "";

    $yaxis_type  = "Elevation";
    $yaxis_units = "feet";
    $wt_min      =  4;
    $wt_max      = 24;
    $wt_units    = "Celsius";
    $wt_oldunits = "Celsius";
    $wt_degunits = "\N{U+00B0}" . substr($wt_units,0,1);
    $qaxis_units = "cfs/ft";
    $cscheme     = "Blue to Orange";
    $ncolors     = 20;
    $elev_base   = -999;
    $elbot       = 0;
    $wd_alg      = "W2 original";
    $elbot_units = "meters";
    $gtitle      = "Release Rate Distribution";
    $gtitle_char = length($gtitle);

#   Available initial colormaps
    @cmaps = ("None", "Blue to Orange", "Blue to Red", "CoolWarm", "Turbo", "Viridis");

    $frame = $wdzone_setup_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -state   => 'disabled',
            -command => sub { my (%parms);
                              if ($wt_file eq "" || ! -e $wt_file) {
                                  return &pop_up_error($wdzone_setup_menu,
                                  "WT Profile file not set or does not exist:\n$wt_file");
                              }
                              if ($flow_file eq "" || ! -e $flow_file) {
                                  return &pop_up_error($wdzone_setup_menu,
                                  "Outlet flow file not set or does not exist:\n$flow_file");
                              }
                              if ($bth_file eq "" || ! -e $bth_file) {
                                  return &pop_up_error($wdzone_setup_menu,
                                  "Bathymetry file not set or does not exist:\n$bth_file");
                              }
                              if ($wd_alg eq "Libby Dam" && ($lbc_file eq "" || ! -e $lbc_file)) {
                                  return &pop_up_error($wdzone_setup_menu,
                                  "Libby bulkhead configuration file not set or does not exist:\n$lbc_file");
                              }
                              if ($wt_min eq "" || $wt_max eq "") {
                                  return &pop_up_error($wdzone_setup_menu,
                                  "Please provide both a min and max water temperature.");
                              }
                              if ($wt_min >= $wt_max) {
                                  return &pop_up_error($wdzone_setup_menu,
                                  "The minimum WT must be less than the maximum WT.");
                              }
                              if ($yaxis_type eq "Elevation") {
                                  if ($ymin eq "" || $ymax eq "") {
                                      return &pop_up_error($wdzone_setup_menu,
                                      "Please provide both a min and max elevation.");
                                  }
                                  if ($ymin >= $ymax) {
                                      return &pop_up_error($wdzone_setup_menu,
                                      "The minimum elevation must be less than the maximum elevation.");
                                  }
                              } else {
                                  if ($ymax eq "") {
                                      return &pop_up_error($wdzone_setup_menu,
                                      "Please provide a maximum depth.");
                                  }
                              }
                              if ($qmax eq "" || $qmax <= 0) {
                                  return &pop_up_error($wdzone_setup_menu,
                                  "Please provide a maximum release rate that is greater than zero.");
                              }
                              if ($seg eq "" || $seg <= 0) {
                                  return &pop_up_error($wdzone_setup_menu,
                                  "Segment number must be numeric and positive.");
                              }
                              if ($elbot eq "") {
                                  return &pop_up_error($wdzone_setup_menu,
                                  "Elevation of top of bottom layer must be numeric.");
                              }
                              if ($elbot_units eq "feet") {
                                  $elbot /= 3.28084;
                              }
                              $gtitle =~ s/^\s+//;
                              $gtitle =~ s/\s+$//;

                              %parms             = ();
                              $parms{wt_min}     = $wt_min;
                              $parms{wt_max}     = $wt_max;
                              $parms{ymin}       = $ymin;
                              $parms{ymax}       = $ymax;
                              $parms{ymajor}     = $ymajor;
                              $parms{ytype}      = $yaxis_type;
                              $parms{yunits}     = $yaxis_units;
                              $parms{qmax}       = $qmax;
                              $parms{qmajor}     = $qmajor;
                              $parms{qunits}     = $qaxis_units;
                              $parms{cscheme}    = $cscheme;
                              $parms{ncolors}    = $ncolors;
                              $parms{gtitle}     = $gtitle;
                              $props{$id}{parms} = { %parms };

                              $props{$id}{files}     = 1;
                              $props{$id}{wd_alg}    = $wd_alg;
                              $props{$id}{wt_file}   = $wt_file;
                              $props{$id}{flow_file} = $flow_file;
                              $props{$id}{bth_file}  = $bth_file;
                              $props{$id}{lbc_file}  = $lbc_file;
                              $props{$id}{seg}       = $seg;
                              $props{$id}{elbot}     = $elbot;
                              $props{$id}{wt_units}  = $wt_units;

                              $wdzone_setup_menu->g_bind('<Destroy>', "");
                              $wdzone_setup_menu->g_destroy();
                              undef $wdzone_setup_menu;
                              &reset_bindings;
                              &make_wd_zone($canv, $id, 0);
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $wdzone_setup_menu->g_bind('<Destroy>', "");
                              $wdzone_setup_menu->g_destroy();
                              undef $wdzone_setup_menu;
                              $canv->delete("graph" . $id);
                              delete $props{$id};
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Delete graph if this menu is destroyed by other than the Cancel button
    $wdzone_setup_menu->g_bind('<Destroy>' => sub { undef $wdzone_setup_menu;
                                                    $canv->delete("graph" . $id);
                                                    delete $props{$id}; 
                                                    &reset_bindings;
                                                  });

    $f = $wdzone_setup_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "Withdrawal Algorithm: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($wd_cb = $f->new_ttk__combobox(
            -textvariable => \$wd_alg,
            -values       => [ ("W2 original", "Libby Dam") ],
            -state        => 'readonly',
            -width        => 12,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w', -pady => 2);
    $wd_cb->g_bind("<<ComboboxSelected>>",
                    sub { if ($wd_alg eq "Libby Dam") {
                              $lbc_label1->g_grid();
                              $lbc_label2->g_grid();
                              $lbc_btn->g_grid();
                          } else {
                              $lbc_label1->g_grid_remove();
                              $lbc_label2->g_grid_remove();
                              $lbc_btn->g_grid_remove();
                          }
                        }
                    );

    $row++;
    $f->new_label(
            -text => "WT Profile File: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$wt_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);
    $f->new_button(
            -text    => "Browse",
            -command => sub { my ($file, $status, %meta);
                              $file = Tkx::tk___getOpenFile(
                                      -parent           => $wdzone_setup_menu,
                                      -title            => "Select WT Profile File",
                                      -initialdir       => abs_path(),
                                      -defaultextension => ".csv",
                                      -filetypes => [ ['CSV (comma delimited)', '.csv'],
                                                      ['All Files',  '*'],
                                                    ],
                                      );
                              if (defined($file) && -e $file && -r $file && ! -z $file) {
                                  $wt_file = File::Spec->rel2abs($file);
                                  ($status, %meta) = &scan_profile($wdzone_setup_menu, $wt_file);
                                  if ($status ne "okay") {
                                      $wt_file = "";
                                      $ok_btn->configure(-state => 'disabled');
                                      return &pop_up_error($wdzone_setup_menu,
                                            "Specified file is not a WT Profile file "
                                          . "or is incomplete:\n$file");
                                  }
                                  if (defined($meta{parm_min}) && defined($meta{parm_max})
                                       && $meta{parm_min} ne "" && $meta{parm_max} ne ""
                                       && $meta{parm_max} > $meta{parm_min}) {
                                      $wt_min = $meta{parm_min};
                                      $wt_max = $meta{parm_max};
                                  }
                                  if (defined($meta{parm_units})
                                       && $meta{parm_units} =~ /^(Celsius|Fahrenheit)$/) {
                                      $wt_units    = $meta{parm_units};
                                      $wt_oldunits = $wt_units;
                                  }
                                  if (defined($meta{ymin}) && defined($meta{ymax})
                                       && $meta{ymin} ne "" && $meta{ymax} ne ""
                                       && $meta{ymax} > $meta{ymin}) {
                                      $ymin = $meta{ymin};
                                      $ymax = $meta{ymax};
                                      $elev_base = &min($ymin, $ymax);
                                  } elsif (defined($meta{ymax}) && $meta{ymax} ne "") {
                                      $ymax = $meta{ymax};
                                      $ymin = "";
                                  }
                                  if (defined($meta{ymajor}) && $meta{ymajor} ne "") {
                                      $ymajor = abs($meta{ymajor});
                                  }
                                  if (defined($meta{ytype})
                                       && $meta{ytype} =~ /^(Elevation|Depth)$/) {
                                      $yaxis_type = $meta{ytype};
                                      if ($yaxis_type eq "Elevation") {
                                          $ymin_label->g_grid();
                                          $ymin_entry->g_grid();
                                          $ymin_units_label->g_grid();
                                          $ymax_label->configure(-text => "Elevation Max: ");
                                          $ymajor_label->configure(-text => "Elevation Major: ");
                                          $yaxis_units_label->configure(-text => "Elevation Units: ");
                                      } else {
                                          $ymin_label->g_grid_remove();
                                          $ymin_entry->g_grid_remove();
                                          $ymin_units_label->g_grid_remove();
                                          $ymax_label->configure(-text => "Depth Max: ");
                                          $ymajor_label->configure(-text => "Depth Major: ");
                                          $yaxis_units_label->configure(-text => "Depth Units: ");
                                      }
                                  }
                                  if (defined($meta{yunits})
                                       && $meta{yunits} =~ /^(feet|meters)$/) {
                                      $yaxis_units = $meta{yunits};
                                  }
                                  if (defined($bth_file)  && -e $bth_file  &&
                                      defined($flow_file) && -e $flow_file &&
                                      ($wd_alg ne "Libby Dam" ||
                                       (defined($lbc_file) && -e $lbc_file))) {
                                      $ok_btn->configure(-state => 'normal');
                                  }
                              } else {
                                  $ok_btn->configure(-state => 'disabled');
                              }
                            },
            )->g_grid(-row => $row, -column => 4, -sticky => 'ew', -padx => 2, -pady => 2);

    $row++;
    $f->new_label(
            -text => "Outlet Flow File: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$flow_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);
    $f->new_button(
            -text    => "Browse",
            -command => sub { my ($file, $status, %meta);
                              $file = Tkx::tk___getOpenFile(
                                      -parent           => $wdzone_setup_menu,
                                      -title            => "Select Outlet Flow File",
                                      -initialdir       => abs_path(),
                                      -defaultextension => ".csv",
                                      -filetypes => [ ['CSV (comma delimited)', '.csv'],
                                                      ['All Files',  '*'],
                                                    ],
                                      );
                              if (defined($file) && -e $file) {
                                  $flow_file = File::Spec->rel2abs($file);
                                  ($status, %meta) = &scan_release_rates($wdzone_setup_menu, $flow_file);
                                  if ($status ne "okay") {
                                      $flow_file = "";
                                      $ok_btn->configure(-state => 'disabled');
                                      return &pop_up_error($wdzone_setup_menu,
                                            "Specified file is not an outlet flow file "
                                          . "or is incomplete:\n$file");
                                  }
                                  if (defined($meta{qmax}) && $meta{qmax} ne "" && $meta{qmax} > 0.0) {
                                      $qmax = $meta{qmax};
                                  }
                                  if (defined($meta{qmajor}) && $meta{qmajor} ne "") {
                                      $qmajor = abs($meta{qmajor});
                                  }
                                  if (defined($meta{qunits})
                                       && $meta{qunits} =~ /^(cfs\/ft|cms\/m|ft\/s|m\/s)$/) {
                                      $qaxis_units = $meta{qunits};
                                  }
                                  if (defined($bth_file) && -e $bth_file &&
                                      defined($wt_file)  && -e $wt_file  &&
                                      ($wd_alg ne "Libby Dam" ||
                                       (defined($lbc_file) && -e $lbc_file))) {
                                      $ok_btn->configure(-state => 'normal');
                                  }
                              } else {
                                  $ok_btn->configure(-state => 'disabled');
                              }
                            },
            )->g_grid(-row => $row, -column => 4, -sticky => 'ew', -padx => 2, -pady => 2);

    $row++;
    $f->new_label(
            -text => "W2 Bathymetry File: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$bth_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);
    $f->new_button(
            -text    => "Browse",
            -command => sub { my ($file);
                              $file = Tkx::tk___getOpenFile(
                                      -parent           => $wdzone_setup_menu,
                                      -title            => "Select W2 Bathymetry File",
                                      -initialdir       => abs_path(),
                                      -defaultextension => ".csv",
                                      -filetypes => [ ['CSV (comma delimited)', '.csv'],
                                                      ['NPT (W2 input file)', '.npt'],
                                                      ['All Files',  '*'],
                                                    ],
                                      );
                              if (defined($file) && -e $file) {
                                  $bth_file = File::Spec->rel2abs($file);
                                  if (defined($flow_file) && -e $flow_file &&
                                      defined($wt_file)   && -e $wt_file   &&
                                      ($wd_alg ne "Libby Dam" ||
                                       (defined($lbc_file) && -e $lbc_file))) {
                                      $ok_btn->configure(-state => 'normal');
                                  }
                              } else {
                                  $ok_btn->configure(-state => 'disabled');
                              }
                            },
            )->g_grid(-row => $row, -column => 4, -sticky => 'ew', -padx => 2, -pady => 2);

    $row++;
    ($lbc_label1 = $f->new_label(
            -text    => "Libby Bulkhead  \nConfiguration File: ",
            -justify => 'right',
            -font    => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($lbc_label2 = $f->new_label(
            -textvariable => \$lbc_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);
    ($lbc_btn = $f->new_button(
            -text    => "Browse",
            -command => sub { my ($file);
                              $file = Tkx::tk___getOpenFile(
                                      -parent           => $wdzone_setup_menu,
                                      -title            => "Select Bulkhead Configuration File",
                                      -initialdir       => abs_path(),
                                      -defaultextension => ".csv",
                                      -filetypes => [ ['CSV (comma delimited)', '.csv'],
                                                      ['All Files',  '*'],
                                                    ],
                                      );
                              if (defined($file) && -e $file) {
                                  $lbc_file = File::Spec->rel2abs($file);
                                  if (defined($flow_file) && -e $flow_file &&
                                      defined($wt_file)   && -e $wt_file   &&
                                      defined($bth_file)  && -e $bth_file) {
                                      $ok_btn->configure(-state => 'normal');
                                  }
                              } else {
                                  $ok_btn->configure(-state => 'disabled');
                              }
                            },
            ))->g_grid(-row => $row, -column => 4, -sticky => 'ew', -padx => 2, -pady => 2);

    $row++;
    $f->new_label(
            -text => "Segment Number: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($seg_entry = $f->new_entry(
            -textvariable => \$seg,
            -font         => 'default',
            -width        => 5,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w', -pady => 2);
    $seg_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($seg_entry);
                                             $seg =~ s/^-//;
                                             $seg = int($seg) if ($seg ne "");
                                             my $segwidth = &max(5, length($seg));
                                             $seg_entry->configure(-width => $segwidth);
                                           });

    $row++;
    $f->new_label(
            -text    => "Top Elevation  \nof Bottom Layer: ",
            -justify => 'right',
            -font    => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($elbot_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    ($elbot_entry = $elbot_frame->new_entry(
            -textvariable => \$elbot,
            -font         => 'default',
            -width        => 5,
            ))->g_pack(-side => 'left', -pady => 2);
    $elbot_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($elbot_entry);
                                               my $elbot_width = &max(5, length($elbot));
                                               $elbot_entry->configure(-width => $elbot_width);
                                             });
    $elbot_frame->new_ttk__combobox(
            -textvariable => \$elbot_units,
            -values       => [ ("feet", "meters") ],
            -state        => 'readonly',
            -width        => 7,
            )->g_pack(-side => 'left', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Y Axis Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($yaxis_type_cb = $f->new_ttk__combobox(
            -textvariable => \$yaxis_type,
            -values       => [ ("Elevation", "Depth") ],
            -state        => 'readonly',
            -width        => 10,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $yaxis_type_cb->g_bind("<<ComboboxSelected>>",
                           sub { if ($yaxis_type eq "Elevation") {
                                     $ymin_label->g_grid();
                                     $ymin_entry->g_grid();
                                     $ymin_units_label->g_grid();
                                     $ymax_label->configure(-text => "Elevation Max: ");
                                     $ymajor_label->configure(-text => "Elevation Major: ");
                                     $yaxis_units_label->configure(-text => "Elevation Units: ");
                                     if ($elev_base != -999 && $ymax ne "") {
                                         $ymin  = $elev_base;
                                         $ymax += $elev_base;
                                     } else {
                                         $ymin = "";
                                     }
                                 } else {
                                     $ymin_label->g_grid_remove();
                                     $ymin_entry->g_grid_remove();
                                     $ymin_units_label->g_grid_remove();
                                     $ymax_label->configure(-text => "Depth Max: ");
                                     $ymajor_label->configure(-text => "Depth Major: ");
                                     $yaxis_units_label->configure(-text => "Depth Units: ");
                                     if ($ymax ne "" && $ymin ne "" && $ymax -$ymin != 0) {
                                         $elev_base = &min($ymin, $ymax);
                                         $ymax      = abs($ymax -$ymin);
                                     } else {
                                         $ymax = "";
                                     }
                                     $ymin = 0;
                                 }
                               }
                          );

    $row++;
    ($ymin_label = $f->new_label(
            -text => "Elevation Min: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ymin_entry = $f->new_entry(
            -textvariable => \$ymin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $ymin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $ymin_entry ]);
    ($ymin_units_label = $f->new_label(
            -textvariable => \$yaxis_units,
            -font         => 'default',
            -anchor       => 'w',
            ))->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    ($ymax_label = $f->new_label(
            -text => "Elevation Max: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ymax_entry = $f->new_entry(
            -textvariable => \$ymax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $ymax_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($ymax_entry);
                                              $ymax =~ s/^-// if ($yaxis_type eq "Depth");
                                            });
    $f->new_label(
            -textvariable => \$yaxis_units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    ($ymajor_label = $f->new_label(
            -text => "Elevation Major: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ymajor_entry = $f->new_entry(
            -textvariable => \$ymajor,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $ymajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($ymajor_entry, 1);
                                                $ymajor =~ s/^-//;
                                              });
    $f->new_label(
            -textvariable => \$yaxis_units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    ($yaxis_units_label = $f->new_label(
            -text => "Elevation Units: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_ttk__combobox(
            -textvariable => \$yaxis_units,
            -values       => [ ("feet", "meters") ],
            -state        => 'readonly',
            -width        => 7,
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Release Rate Max: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($qmax_entry = $f->new_entry(
            -textvariable => \$qmax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $qmax_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($qmax_entry);
                                              $qmax =~ s/^-//;
                                            });
    $f->new_label(
            -textvariable => \$qaxis_units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Release Rate Major: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($qmajor_entry = $f->new_entry(
            -textvariable => \$qmajor,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $qmajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($qmajor_entry, 1);
                                                $qmajor =~ s/^-//;
                                              });
    $f->new_label(
            -textvariable => \$qaxis_units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Release Rate Units: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_ttk__combobox(
            -textvariable => \$qaxis_units,
            -values       => [ ("cfs/ft", "cms/m", "ft/s", "m/s") ],
            -state        => 'readonly',
            -width        => 7,
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "WT Color Scheme: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($cscheme_cb = $f->new_ttk__combobox(
            -textvariable => \$cscheme,
            -values       => [ @cmaps ],
            -state        => 'readonly',
            -width        => 15,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $cscheme_cb->g_bind("<<ComboboxSelected>>",
                           sub { my ($n);
                                 if ($cscheme eq "None") {
                                     $ncolors_cb->g_grid_remove();
                                     $ncolors_na_label->g_grid();
                                     $wt_min_label->g_grid_remove();
                                     $wt_min_entry->g_grid_remove();
                                     $wt_min_units_label->g_grid_remove();
                                     $wt_max_label->g_grid_remove();
                                     $wt_max_entry->g_grid_remove();
                                     $wt_max_units_label->g_grid_remove();
                                     $wt_units_label->g_grid_remove();
                                     $wt_units_cb->g_grid_remove();
                                 } else {
                                     $ncolors_na_label->g_grid_remove();
                                     $ncolors_cb->g_grid();
                                     if ($cscheme =~ /CoolWarm|Turbo|Viridis/) {
                                         $ncolors_cb->configure(-values => [ (8 .. 100) ]);
                                     } else {
                                         $ncolors_cb->configure(-values =>
                                             [ (16, 18, 20, 22, 24, 30, 34, 38, 42, 46) ]);
                                         if ($ncolors < 16) {
                                             $ncolors = 16;
                                         } elsif ($ncolors > 46) {
                                             $ncolors = 46;
                                         } else {
                                             foreach $n (reverse @valid_nc) {
                                                 if ($ncolors >= 2 *$n) {
                                                     $ncolors = 2 *$n;
                                                     last;
                                                 }
                                             }
                                         }
                                     }
                                     $wt_min_label->g_grid();
                                     $wt_min_entry->g_grid();
                                     $wt_min_units_label->g_grid();
                                     $wt_max_label->g_grid();
                                     $wt_max_entry->g_grid();
                                     $wt_max_units_label->g_grid();
                                     $wt_units_label->g_grid();
                                     $wt_units_cb->g_grid();
                                 }
                               });

    $row++;
    $f->new_label(
            -text => "Number of Colors: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ncolors_na_label = $f->new_label(
            -text => "n/a",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $ncolors_na_label->g_grid_remove();
    ($ncolors_cb = $f->new_ttk__combobox(
            -textvariable => \$ncolors,
            -values       => [ (16, 18, 20, 22, 24, 30, 34, 38, 42, 46) ],
            -state        => 'readonly',
            -width        => 4,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    ($wt_min_label = $f->new_label(
            -text => "Temperature Min: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($wt_min_entry = $f->new_entry(
            -textvariable => \$wt_min,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $wt_min_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $wt_min_entry ]);
    ($wt_min_units_label = $f->new_label(
            -textvariable => \$wt_degunits,
            -font         => 'default',
            -anchor       => 'w',
            ))->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    ($wt_max_label = $f->new_label(
            -text => "Temperature Max: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($wt_max_entry = $f->new_entry(
            -textvariable => \$wt_max,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $wt_max_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $wt_max_entry ]);
    ($wt_max_units_label = $f->new_label(
            -textvariable => \$wt_degunits,
            -font         => 'default',
            -anchor       => 'w',
            ))->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    ($wt_units_label = $f->new_label(
            -text => "Temperature Units: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($wt_units_cb = $f->new_ttk__combobox(
            -textvariable => \$wt_units,
            -values       => [ ("Celsius", "Fahrenheit") ],
            -state        => 'readonly',
            -width        => 12,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $wt_units_cb->g_bind("<<ComboboxSelected>>",
                          sub { $wt_degunits = "\N{U+00B0}" . substr($wt_units,0,1);
                                $wt_min = 0 if ($wt_min eq "-");
                                $wt_max = 0 if ($wt_max eq "-");
                                if ($wt_units eq "Celsius" && $wt_oldunits eq "Fahrenheit") {
                                    $wt_min = &floor(($wt_min -32) /1.8) if ($wt_min ne "");
                                    $wt_max = &ceil(($wt_max -32) /1.8)  if ($wt_max ne "");
                                } elsif ($wt_units eq "Fahrenheit" && $wt_oldunits eq "Celsius") {
                                    $wt_min = &floor($wt_min *1.8 +32) if ($wt_min ne "");
                                    $wt_max = &ceil($wt_max *1.8 +32)  if ($wt_max ne "");
                                }
                                $wt_oldunits = $wt_units;
                              });

    $row++;
    $f->new_label(
            -text => "Graph Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gtitle,
            -font         => 'default',
            -width        => $gtitle_char,
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);

    if ($wd_alg ne "Libby Dam") {
        $lbc_label1->g_grid_remove();
        $lbc_label2->g_grid_remove();
        $lbc_btn->g_grid_remove();
    }
    if ($cscheme eq "None") {
        $ncolors_cb->g_grid_remove();
        $ncolors_na_label->g_grid();
    } else {
        $ncolors_na_label->g_grid_remove();
        $ncolors_cb->g_grid();
        if ($cscheme =~ /CoolWarm|Turbo|Viridis/) {
            $ncolors_cb->configure(-values => [ (8 .. 100) ]);
        } else {
            $ncolors_cb->configure(-values => [ (16, 18, 20, 22, 24, 30, 34, 38, 42, 46) ]);
            if ($ncolors < 16) {
                $ncolors = 16;
            } elsif ($ncolors > 46) {
                $ncolors = 46;
            } else {
                foreach $n (reverse @valid_nc) {
                    if ($ncolors >= 2 *$n) {
                        $ncolors = 2 *$n;
                        last;
                    }
                }
            }
        }
    }
    $f->g_grid_columnconfigure(3, -weight => 2);

    Tkx::wm_resizable($wdzone_setup_menu,0,0);
    &adjust_window_position($wdzone_setup_menu);
    $wdzone_setup_menu->g_focus;
}


sub make_wd_zone {
    my ($canv, $id, $props_updated) = @_;
    my (
        $anc, $b_ref, $bot, $box_id, $cmap_image, $cs_max, $cs_min,
        $cs_range, $cs_rev, $cscheme1, $cscheme2, $data_available, $date_id,
        $date_label, $do_calcs, $dsize, $dt, $dt2, $el1, $el2, $el3, $first,
        $flow_data, $got_depth, $group_tags, $gtag, $h_ref, $height, $i,
        $id2, $ih, $item, $iw, $j, $k, $kb, $kmx, $kn_digits, $last_xp,
        $lastpt, $mi, $mismatch, $msg, $mult, $n, $ncolors, $new_graph,
        $nout, $np, $nww, $qmult, $qsum, $resized, $surf_elev, $tag, $top,
        $tout, $tsum, $update_cs, $wt1, $wt2, $wt3, $x1, $x2, $xp, $y1,
        $y2, $ymax, $ymin, $yp, $yp1, $yp2, $yrange,

        @b, @colors, @coords, @depths, @el, @elevations, @estr, @grp_tags,
        @h, @items, @kbsw, @ktsw, @lw, @mydates, @names, @noutlets,
        @nslots, @old_coords, @pt_elevations, @qout, @qstr, @qtot, @rho,
        @scale, @sw_alg, @t, @tags, @tstr, @valid_elevs, @valid_temps,
        @vtot, @ww_names,

        %axis_props, %bh_config, %bh_parms, %color_key_props, %ds_parms,
        %limits, %parms, %profile, %qdata, %qtot_data, %rel_data, %tdata,
        %temps, %vtot_data, %wsurf,
       );

#   For new plots, pop up a menu for file names and parameters
    if (! defined($props{$id}{files})) {
        return &setup_wd_zone($canv, $id);
    }

#   Make tag and get coordinates of graph frame
    $gtag   = "graph" . $id;
    @coords = @{ $props{$id}{coordlist} };
    ($x1, $y1, $x2, $y2) = @coords;

#   Determine whether group tags are present and save the list
    $group_tags = 0;
    @grp_tags   = ();
    @tags       = Tkx::SplitList($canv->itemcget($id, -tags));
    if (&list_search("group_", @tags) > -1) {
        $group_tags = 1;
        foreach $tag (@tags) {
            push (@grp_tags, $tag) if ($tag =~ /^group_/);
        }
    }

#   Read the data files, if not done already
    if (! defined($props{$id}{data})) {
        %parms    = %{ $props{$id}{parms} };
        %profile  = &read_profile($main, $props{$id}{wt_file});
        %rel_data = &read_release_rates($main, $props{$id}{flow_file});
        if ($profile{daily} != $rel_data{daily}) {
            $canv->delete($gtag);
            delete $props{$id};
            return &pop_up_error($main, "The input temperature and release-rate data\n"
                                      . "are not on the same time scale.  One is daily\n"
                                      . "and the other is subdaily.  Please start over.");
        }
        ($kmx, $kb, $h_ref, $b_ref) = &read_bth_slice($main, $props{$id}{seg}, $props{$id}{bth_file});
        @h  = @{ $h_ref };
        @b  = @{ $b_ref };
        @el = ();
        $el[$kmx] = $props{$id}{elbot};
        for ($k=$kmx-1; $k>=1; $k--) {
            $el[$k] = $el[$k+1] +$h[$k];
        }
        $profile{kmx} = $kmx;
        $profile{kb}  = $kb;
        $profile{b}   = [ @b  ];
        $profile{el}  = [ @el ];

        @ktsw = @{ $rel_data{ktsw} };
        @kbsw = @{ $rel_data{kbsw} };
        for ($n=0; $n<$rel_data{nout}; $n++) {
            $ktsw[$n] = $kb       if ($ktsw[$n] > $kb);                    # already >= 2
            $kbsw[$n] = $kb       if ($kbsw[$n] > $kb || $kbsw[$n] == 0);  # 0 if not in input file
            $kbsw[$n] = $ktsw[$n] if ($kbsw[$n] < $ktsw[$n]);
        }
        $profile{ktsw}   = [ @ktsw ];
        $profile{kbsw}   = [ @kbsw ];
        $profile{nout}   = $rel_data{nout};
        $profile{sw_alg} = $rel_data{sw_alg};
        $profile{names}  = $rel_data{names};
        $profile{estr}   = $rel_data{estr};
        $profile{lw}     = $rel_data{lw};
        $profile{qdata}  = $rel_data{qdata};

        %limits            = &find_data_limits($id, %profile);
        $profile{date_min} = $limits{date_min};
        $profile{date_max} = $limits{date_max};
        $profile{dpth_min} = $limits{dpth_min};
        $profile{dpth_max} = $limits{dpth_max};
        $profile{elev_min} = $limits{elev_min};
        $profile{elev_max} = $limits{elev_max};
        $profile{parm_min} = $limits{parm_min};
        $profile{parm_max} = $limits{parm_max};
        $profile{flow_min} = $limits{flow_min};
        $profile{flow_max} = $limits{flow_max};
        undef %limits;

        if ($props{$id}{wd_alg} eq "Libby Dam") {
            %bh_config          = &read_libby_config($main, $props{$id}{lbc_file});
            $profile{num_ww}    = $bh_config{num_ww};
            $profile{ww_names}  = $bh_config{ww_names};
            $profile{num_outs}  = $bh_config{num_outs};
            $profile{num_slots} = $bh_config{num_slots};
            $profile{num_rows}  = $bh_config{num_rows};
            $profile{bh_width}  = $bh_config{bh_width};
            $profile{bh_height} = $bh_config{bh_height};
            $profile{base_elev} = $bh_config{base_elev};
            $profile{hlc_base}  = $bh_config{hlc_base};
            $profile{hlc_inc}   = $bh_config{hlc_inc};
            $profile{bh_miss}   = $bh_config{bh_miss};

            @sw_alg = @{ $rel_data{sw_alg} };
            $nww = -1;
            for ($n=0; $n<=$#sw_alg; $n++) {
                $nww++ if ($sw_alg[$n] eq "LibbyDam");
            }
            if ($nww +1 != $bh_config{num_ww}) {
                return &pop_up_error($main,
                                  "Libby bulkhead configuration file is inconsistent with\n"
                                . "outflow release file in terms of the number of outlets\n"
                                . "using Libby-Dam-like wet-well selective withdrawal:\n"
                                . "  $props{$id}{lbc_file}\n  $props{$id}{flow_file}");
            }
            undef %bh_config;
        }

        $profile{yfont}     = $default_family;
        $profile{yl_size}   = &min(11, &max(8, int((abs($x2-$x1)+abs($y2-$y1))/2./41)));
        $profile{yt_size}   = $profile{yl_size} +2;
        $profile{yl_weight} = 'normal';
        $profile{yt_weight} = 'normal';
        $profile{ytype}     = $parms{ytype};
        $profile{yunits}    = $parms{yunits};
        $profile{ymin}      = $parms{ymin};
        $profile{ymax}      = $parms{ymax};
        $profile{ymajor}    = ($parms{ymajor} eq "") ? "auto" : $parms{ymajor};
        $profile{ypr_tics}  = "outside";
        $profile{yop_tics}  = "none";
        $profile{ytitle}    = $parms{ytype} . ", in " . $parms{yunits};

        $profile{xfont}     = $profile{yfont};
        $profile{xl_size}   = $profile{yl_size};
        $profile{xt_size}   = $profile{yt_size};
        $profile{xl_weight} = $profile{yl_weight};
        $profile{xt_weight} = $profile{yt_weight};
        $profile{xmin}      = 0;
        $profile{xmax}      = $parms{qmax};
        $profile{xmajor}    = $parms{qmajor};
        $profile{xpr_tics}  = "outside";
        $profile{xop_tics}  = "none";
        $profile{qunits}    = $parms{qunits};
        if ($parms{qunits} eq "cfs/ft") {
            $profile{xtitle} = "Release Rate, in cfs/(vert. ft)";
        } elsif ($parms{qunits} eq "cms/m") {
            $profile{xtitle} = "Release Rate, in cms/(vert. m)";
        } elsif ($parms{qunits} eq "ft/s") {
            $profile{xtitle} = "Velocity, in ft/s";
        } else {
            $profile{xtitle} = "Velocity, in m/s";
        }

        $profile{gtfont}    = $profile{yfont};
        $profile{gt_size}   = $profile{yt_size};
        $profile{gs_size}   = $profile{gt_size} -1;
        $profile{gt_weight} = 'bold';
        $profile{gs_weight} = $profile{gt_weight};
        $profile{gtitle}    = $parms{gtitle};

        $profile{keyfont}   = $default_family;
        $profile{keytitle}  = "Water temperature, in degrees " . $props{$id}{wt_units};
        $profile{kn_size}   = $profile{yl_size};
        $profile{kt_size}   = $profile{yl_size} +2;
        $profile{kt_weight} = 'normal';
        $profile{kn_weight} = 'normal';
        $profile{kn_digits} = 1;

        if ($props{$id}{wd_alg} eq "Libby Dam") {
            $profile{bh_show}   = ($parms{ytype} eq "Depth") ? 0 : 1;
            $profile{bh_docked} = 1;
            $profile{bh_xpos}   = -99;
            $profile{bh_ypos}   = -99;
            $profile{bh_bcellh} = -99;
            $profile{bh_font}   = $profile{yfont};
            $profile{bh_size}   = $profile{yl_size};
            $profile{bh_weight} = 'normal';
            $profile{bh_tcolor} = "black";
            $profile{bh_bwidth} = 1;
            $profile{bh_bcolor} = "black";
            $profile{bh_bcellw} = 18;
        }

        if ($parms{cscheme} eq "None") {
            $profile{add_cs}    =  0;
            $profile{cscheme1}  = "Blue";
            $profile{cscheme2}  = "Orange";
            $profile{ncolors}   = 20;
            $profile{cs_height} = &max(2, &min(18, int(($y2-$y1+1) /$profile{ncolors})));
        } else {
            $profile{add_cs}    =  1;
            $profile{cs_height} = &max(2, &min(18, int(($y2-$y1+1) /$parms{ncolors})));
            if ($parms{cscheme} eq "Blue to Orange") {
                $profile{cscheme1} = "Blue";
                $profile{cscheme2} = "Orange";
                $profile{ncolors}  = $parms{ncolors} /2;
            } elsif ($parms{cscheme} eq "Blue to Red") {
                $profile{cscheme1} = "Blue";
                $profile{cscheme2} = "Red";
                $profile{ncolors}  = $parms{ncolors} /2;
            } else {
                $profile{cscheme1} = $parms{cscheme};
                $profile{cscheme2} = "None";
                $profile{ncolors}  = $parms{ncolors};
            }
        }
        $profile{cs_min}   = $parms{wt_min};
        $profile{cs_max}   = $parms{wt_max};
        $profile{cs_rev}   =  0;
        $profile{cs_hide}  =  0;
        $profile{xleg_off} = 40;
        $profile{yleg_off} =  0;
        $profile{cs_width} = 24;
        $profile{cs_major} = "auto";

        $profile{cs_link} = 0;
        if ($profile{add_cs} && @animate_ids && $#animate_ids >= 0) {
            $update_cs = 0;
            foreach $item (@animate_ids) {
                next if ($props{$item}{meta} =~ /time_series|w2_wlevels/);
                next if ($props{$item}{meta} eq "w2_outflow" && ! $props{$item}{add_parm});
                if ($gr_props{$item}{cs_link} == 2) {
                    if ($props{$item}{meta} =~ /data_profile/
                         && $props{$item}{prof_type}  eq "standard"
                         && $props{$item}{parm}       eq "Temperature"
                         && $props{$item}{parm_units} eq $props{$id}{wt_units}) {
                        $update_cs = 1;
                        $id2 = $item;
                        last;
                    } elsif ($props{$item}{meta} =~ /w2_profile|w2_slice|w2_outflow/
                         && $props{$item}{parm}       eq "Temperature"
                         && $props{$item}{parm_div}   eq "None"
                         && $props{$item}{parm_units} eq $props{$id}{wt_units}) {
                        $update_cs = 1;
                        $id2 = $item;
                        last;
                    } elsif ($props{$item}{meta} eq "w2_tdmap"
                         && $props{$item}{map_type}   eq "standard"
                         && $props{$item}{parm_sav}   eq "Temperature"
                         && $props{$item}{pdiv_sav}   eq "None"
                         && $props{$item}{parm_units} eq $props{$id}{wt_units}) {
                        $update_cs = 1;
                        $id2 = $item;
                        last;
                    } elsif ($props{$item}{meta} =~ /vert_wd_zone/
                         && $props{$item}{wt_units} eq $props{$id}{wt_units}) {
                        $update_cs = 1;
                        $id2 = $item;
                        last;
                    }
                }
            }
            if (! $update_cs) {
                foreach $item (@animate_ids) {
                    next if ($props{$item}{meta}
                               =~ /w2_profile|w2_slice|w2_tdmap|w2_outflow|time_series|w2_wlevels/);
                    if ($gr_props{$item}{cs_link} == 1) {
                        if ($props{$item}{meta} =~ /vert_wd_zone/
                             && $props{$item}{wt_units} eq $props{$id}{wt_units}
                             && $props{$item}{wt_file}  eq $props{$id}{wt_file}) {
                            $update_cs = 1;
                            $id2 = $item;
                            last;
                        } elsif ($props{$item}{meta} =~ /data_profile/
                             && $props{$item}{prof_type}  eq "standard"
                             && $props{$item}{parm}       eq "Temperature"
                             && $props{$item}{parm_units} eq $props{$id}{wt_units}
                             && $props{$item}{src_file}   eq $props{$id}{wt_file}) {
                            $update_cs = 1;
                            $id2 = $item;
                            last;
                        }
                    }
                }
            }
            if ($update_cs) {
                $ncolors           = $profile{ncolors};
                $profile{cs_link}  = $gr_props{$id2}{cs_link};
                $profile{cscheme1} = $gr_props{$id2}{cscheme1};
                $profile{cscheme2} = $gr_props{$id2}{cscheme2};
                $profile{ncolors}  = $gr_props{$id2}{ncolors};
                $profile{cs_rev}   = $gr_props{$id2}{cs_rev};
                $profile{cs_min}   = $gr_props{$id2}{cs_min};
                $profile{cs_max}   = $gr_props{$id2}{cs_max};
                $profile{cs_major} = $gr_props{$id2}{cs_major};
                if ($profile{cs_height} *$ncolors > $y2-$y1+1 && $profile{cs_height} > 2) {
                    $profile{cs_height} = &max(2, &min(18, int(($y2-$y1+1) /$profile{ncolors})));
                }
            }
        }
        $profile{redraw}  = 1;
        $gr_props{$id}    = { %profile };
        $props{$id}{data} = 1;
        $props{$id}{gnum} = ++$graph_num;
        $resized = 0;
        undef %profile;

#   Or use previously read info.  If resized, delete graph and redraw
    } else {
        @old_coords = @{ $props{$id}{oldcoords} };
        $resized = 0;
        for ($i=0; $i<=$#coords; $i++) {
            if ($coords[$i] != $old_coords[$i]) {
                $resized = 1;
                last;
            }
        }
        return if (! $resized && ! $props_updated);
        $gr_props{$id}{redraw} = 1 if ($resized);

        $canv->delete($gtag . "_xaxis");
        $canv->delete($gtag . "_xaxisTitle");
        $canv->delete($gtag . "_yaxis");
        $canv->delete($gtag . "_yaxisTitle");
        $canv->delete($gtag . "_date");
        $canv->delete($gtag . "_gtitle");
        $canv->delete($gtag . "_colorKey");
        $canv->delete($gtag . "_colorKeyTitle");
        $canv->delete($gtag . "_openBH");
        if ($gr_props{$id}{redraw}) {
            $canv->delete($gtag . "_profile");
            $canv->delete($gtag . "_colorProfile");
        }
    }
    $props{$id}{oldcoords} = [ @coords ];

#   Set the list of dates or merge the dates array if necessary
#   Add the graph to the list of animated graphs, if necessary
    %wsurf = %{ $gr_props{$id}{ws_elev} };
    %temps = %{ $gr_props{$id}{pdata}   };
    if (! @animate_ids || &list_match($id, @animate_ids) == -1) {
        @mydates = sort keys %temps;
        if (@dates && @animate_ids && $#animate_ids >= 0) {
            $mismatch = 0;
            foreach $id2 (@animate_ids) {
#               next if ($id2 == $id);
                next if ($props{$id2}{meta}
                               =~ /data_profile_cmap|w2_profile_cmap|w2_profile_matrix|w2_tdmap|time_series/);
                if ($props{$id2}{meta} =~ /^(w2_profile|w2_slice|w2_outflow|w2_wlevels)$/
                     || ($props{$id2}{meta} eq "vert_wd_zone"
                         && $props{$id2}{wt_file} ne $props{$id}{wt_file})
                     || ($props{$id2}{meta} eq "data_profile"
                         && $props{$id2}{src_file} ne $props{$id}{wt_file})) {
                    $mismatch = 1;
                    last;
                }
            }
            if ($mismatch) {
                if (defined($animate_tb) && Tkx::winfo_exists($animate_tb)) {
                    if ($animate_tb->g_wm_title() eq "Animation toolbar") {
                        $animate_tb->g_destroy();
                        undef $animate_tb;
                    }
                }
                $dt      = $dates[$dti-1];
                @dates   = &merge_dates(\@dates, \@mydates);
                $dti_max = $#dates+1;
                $dti     = 1 + &nearest_dt_index($dt, @dates);
                $dti++ if ($dti == 0);
            }
        } else {
            @dates   = @mydates;
            $dti_max = $#dates+1;
            $dti     = 1;
            $delay   = 0.5;
        }
        $dti_old = $dti;
        push (@animate_ids, $id);
    }
    $dt = $dates[$dti-1];
    $export_menu->entryconfigure(3, -state => 'normal') if ($use_GS);
    $pref_menu->entryconfigure(0,   -state => 'normal');

#   Adjust the date slightly, or to a daily value, if necessary
    if (length($dt) == 12) {
        if ($gr_props{$id}{daily}) {
            $dt = substr($dt,0,8);
        } elsif (! defined($temps{$dt})) {
            for ($mi=1; $mi<=10; $mi++) {
                $dt2 = &adjust_dt($dt, $mi);
                if (defined($temps{$dt2})) {
                    $dt = $dt2;
                    last;
                }
                $dt2 = &adjust_dt($dt, -1 *$mi);
                if (defined($temps{$dt2})) {
                    $dt = $dt2;
                    last;
                }
            }
        }
    }

#   Plot a white rectangle below the graph frame
    @items     = Tkx::SplitList($canv->find_withtag($gtag . "_main"));
    $new_graph = ($#items >= 0) ? 0 : 1;
    if ($new_graph) {
        $box_id = $canv->create_rectangle($x1, $y1, $x2, $y2,
                             -outline => "",
                             -width   => 0,
                             -fill    => &get_rgb_code("white"),
                             -tags    => $gtag . " " . $gtag . "_main");
        $canv->lower($box_id, $id);
    } else {
        $canv->coords($gtag . "_main", @coords);
        $canv->raise($id, $gtag . "_main");
    }

#   Plot the date as a subtitle
    $xp = ($x1+$x2)/2.;
    $yp = ($gr_props{$id}{xop_tics} =~ /outside|cross/) ? $y1-14 : $y1-6;
    $date_label = &get_formatted_date($dt);
    $date_id = $canv->create_text($xp, $yp,
                       -anchor => 's',
                       -text   => $date_label,
                       -fill   => &get_rgb_code("black"),
                       -angle  => 0,
                       -tags   => $gtag . " " . $gtag . "_date",
                       -font   => [-family     => $gr_props{$id}{gtfont},
                                   -size       => $gr_props{$id}{gs_size},
                                   -weight     => $gr_props{$id}{gs_weight},
                                   -slant      => 'roman',
                                   -underline  => 0,
                                   -overstrike => 0,
                                  ]);
    @coords = Tkx::SplitList($canv->bbox($date_id));
    $dsize  = &max(10, abs($coords[3] - $coords[1]));

#   Plot the graph title
    $canv->create_text($xp, $yp-$dsize,
                       -anchor => 's', 
                       -text   => $gr_props{$id}{gtitle},
                       -fill   => &get_rgb_code("black"),
                       -angle  => 0,
                       -tags   => $gtag . " " . $gtag . "_gtitle",
                       -font   => [-family     => $gr_props{$id}{gtfont},
                                   -size       => $gr_props{$id}{gt_size},
                                   -weight     => $gr_props{$id}{gt_weight},
                                   -slant      => 'roman',
                                   -underline  => 0,
                                   -overstrike => 0,
                                  ]);

#   Plot the Y axis
    $axis_props{min}     = $gr_props{$id}{ymin};
    $axis_props{max}     = $gr_props{$id}{ymax};
    $axis_props{major}   = $gr_props{$id}{ymajor};
    $axis_props{pr_tics} = $gr_props{$id}{ypr_tics};
    $axis_props{op_tics} = $gr_props{$id}{yop_tics};
    $axis_props{minor}   = 1;
    $axis_props{reverse} = ($gr_props{$id}{ytype} eq "Depth") ? 1 : 0;
    $axis_props{title}   = $gr_props{$id}{ytitle};
    $axis_props{font}    = $gr_props{$id}{yfont};
    $axis_props{size1}   = $gr_props{$id}{yl_size};
    $axis_props{size2}   = $gr_props{$id}{yt_size};
    $axis_props{weight1} = $gr_props{$id}{yl_weight};
    $axis_props{weight2} = $gr_props{$id}{yt_weight};
    $axis_props{side}    = "left";
    $axis_props{tags}    = $gtag . " " . $gtag . "_yaxis";
    $axis_props{coords}  = [$x1, $y2, $x1, $y1];
    $axis_props{op_loc}  = $x2;
    &make_axis($canv, %axis_props);
    undef %axis_props;

#   Plot the X axis
    $axis_props{min}     = $gr_props{$id}{xmin};
    $axis_props{max}     = $gr_props{$id}{xmax};
    $axis_props{major}   = $gr_props{$id}{xmajor};
    $axis_props{pr_tics} = $gr_props{$id}{xpr_tics};
    $axis_props{op_tics} = $gr_props{$id}{xop_tics};
    $axis_props{minor}   = 1;
    $axis_props{reverse} = 0;
    $axis_props{title}   = $gr_props{$id}{xtitle};
    $axis_props{font}    = $gr_props{$id}{xfont};
    $axis_props{size1}   = $gr_props{$id}{xl_size};
    $axis_props{size2}   = $gr_props{$id}{xt_size};
    $axis_props{weight1} = $gr_props{$id}{xl_weight};
    $axis_props{weight2} = $gr_props{$id}{xt_weight};
    $axis_props{side}    = "bottom";
    $axis_props{tags}    = $gtag . " " . $gtag . "_xaxis";
    $axis_props{coords}  = [$x1, $y2, $x2, $y2];
    $axis_props{op_loc}  = $y1;
    &make_axis($canv, %axis_props);
    undef %axis_props;

#   Deal with optional color scheme and create optional color key
    if ($gr_props{$id}{add_cs}) {
        $cscheme1  = $gr_props{$id}{cscheme1};
        $cscheme2  = $gr_props{$id}{cscheme2};
        $ncolors   = $gr_props{$id}{ncolors};
        $cs_rev    = $gr_props{$id}{cs_rev};
        $cs_min    = $gr_props{$id}{cs_min};
        $cs_max    = $gr_props{$id}{cs_max};
        $kn_digits = $gr_props{$id}{kn_digits};
        if (&list_match($cscheme1, @color_scheme_names) == -1 ||
           (&list_match($cscheme1, @full_color_schemes) == -1 && &list_match($ncolors, @valid_nc) == -1) ||
           (&list_match($cscheme1, @full_color_schemes) >= 0 && &list_match($ncolors, @valid_nc_alt) == -1) ||
           ($cscheme2 ne "" && $cscheme2 ne "None" && &list_match($cscheme2, @color_scheme_names) == -1)) {
            $cscheme1  = $gr_props{$id}{cscheme1}  = "Blue";
            $cscheme2  = $gr_props{$id}{cscheme2}  = "Orange";
            $ncolors   = $gr_props{$id}{ncolors}   = 11;
            $cs_rev    = $gr_props{$id}{cs_rev}    =  0;
            $cs_min    = $gr_props{$id}{cs_min}    =  0;
            $cs_max    = $gr_props{$id}{cs_max}    = 22;
            $kn_digits = $gr_props{$id}{kn_digits} =  1;
        }
        $cs_range = $cs_max -$cs_min;
        @colors   = &make_color_scheme($ncolors, $cs_rev, $cscheme1, $cscheme2);
        @scale    = ();
        for ($i=0; $i<=$#colors+1; $i++) {
            $j = $#colors +1 -$i;
            $scale[$j] = $cs_min +$cs_range*$j/($#colors+1);
        }
        $gr_props{$id}{colors}    = [ @colors ];
        $gr_props{$id}{scale}     = [ @scale  ];

        $color_key_props{xleg}    = $x2 + $gr_props{$id}{xleg_off};
        $color_key_props{yleg}    = $y1 + $gr_props{$id}{yleg_off};
        $color_key_props{width}   = $gr_props{$id}{cs_width};
        $color_key_props{height}  = $gr_props{$id}{cs_height};
        $color_key_props{colors}  = [ @colors ];
        $color_key_props{scale}   = [ @scale  ];
        $color_key_props{title}   = $gr_props{$id}{keytitle};
        $color_key_props{font}    = $gr_props{$id}{keyfont};
        $color_key_props{size1}   = $gr_props{$id}{kn_size};
        $color_key_props{size2}   = $gr_props{$id}{kt_size};
        $color_key_props{weight1} = $gr_props{$id}{kn_weight};
        $color_key_props{weight2} = $gr_props{$id}{kt_weight};
        $color_key_props{digits}  = $kn_digits;
        $color_key_props{major}   = $gr_props{$id}{cs_major};
        $color_key_props{tags}    = $gtag . " " . $gtag . "_colorKey";
        &make_color_key($canv, %color_key_props);
        undef %color_key_props;

        if ($gr_props{$id}{cs_hide}) {
            $canv->itemconfigure($gtag . "_colorKey", -state => 'hidden');
        }
    }

#   Plot the number of bulkhead openings, if asked
    if ($props{$id}{wd_alg} eq "Libby Dam" && $gr_props{$id}{bh_show}) {
        $bh_parms{ymin}      = $gr_props{$id}{ymin};
        $bh_parms{ymax}      = $gr_props{$id}{ymax};
        $bh_parms{ytype}     = $gr_props{$id}{ytype};
        $bh_parms{yunits}    = $gr_props{$id}{yunits};
        $bh_parms{num_ww}    = $gr_props{$id}{num_ww};
        $bh_parms{ww_names}  = $gr_props{$id}{ww_names};
        $bh_parms{num_rows}  = $gr_props{$id}{num_rows};
        $bh_parms{bh_height} = $gr_props{$id}{bh_height};  # meters
        $bh_parms{base_elev} = $gr_props{$id}{base_elev};  # meters
        $bh_parms{surf_elev} = $wsurf{$dt};                # meters
        $bh_parms{bh_miss}   = $gr_props{$id}{bh_miss};
        $bh_parms{bh_font}   = $gr_props{$id}{bh_font};
        $bh_parms{bh_size}   = $gr_props{$id}{bh_size};
        $bh_parms{bh_weight} = $gr_props{$id}{bh_weight};
        $bh_parms{bh_tcolor} = $gr_props{$id}{bh_tcolor};
        $bh_parms{bh_bwidth} = $gr_props{$id}{bh_bwidth};
        $bh_parms{bh_bcolor} = $gr_props{$id}{bh_bcolor};
        $bh_parms{bh_bcellw} = $gr_props{$id}{bh_bcellw};
        $bh_parms{bh_docked} = $gr_props{$id}{bh_docked};
        $bh_parms{bh_xpos}   = $gr_props{$id}{bh_xpos};
        $bh_parms{bh_ypos}   = $gr_props{$id}{bh_ypos};
        $bh_parms{bh_bcellh} = $gr_props{$id}{bh_bcellh};

        &make_bulkhead_graphic($canv, $id, $dt, %bh_parms);
        undef %bh_parms;
    }

#   Don't recompute and redraw unless necessary
    if (! $gr_props{$id}{redraw}) {
        if ($gr_props{$id}{add_cs}) {
            $canv->lower($gtag . "_colorKey",      $id);
            $canv->lower($gtag . "_colorKeyTitle", $id);
            $canv->lower($gtag . "_colorProfile",  $id);
        }
        $canv->lower($gtag . "_date",       $id);
        $canv->lower($gtag . "_gtitle",     $id);
        $canv->lower($gtag . "_xaxisTitle", $id);
        $canv->lower($gtag . "_yaxisTitle", $id);
        $canv->lower($gtag . "_profile",    $id);
        $canv->lower($gtag . "_xaxis",      $id);
        $canv->lower($gtag . "_yaxis",      $id);
        if ($props{$id}{wd_alg} eq "Libby Dam" && $gr_props{$id}{bh_show}) {
            $canv->lower($gtag . "_openBH", $id);
        }
        if ($group_tags) {
            foreach $tag (@grp_tags) {
                $canv->addtag($tag, withtag => $gtag);
            }
        }
        return;
    }

#   Set some variables and populate some arrays and hashes
    $got_depth = ($gr_props{$id}{elv_dep} eq "elevation") ? 0 : 1;
    if ($got_depth) {
        @depths     = @{ $gr_props{$id}{depths} };
    } else {
        @elevations = @{ $gr_props{$id}{elevations} };
    }

#   Determine whether data are available on this date
    if (defined($wsurf{$dt}) && defined($temps{$dt})) {
        $data_available = $flow_data = 1;
    } else {
        $data_available = $flow_data = $np = 0;
    }

#   Populate the pt_elevations array.  Keep elevations and depths in meters.
    if ($data_available) {
        $surf_elev = ($wsurf{$dt} ne "na") ? $wsurf{$dt} : 0.0;
        $lastpt    = ($got_depth) ? $#depths : $#elevations;
        @pt_elevations = ();
        for ($i=0; $i<=$lastpt; $i++) {
            if ($got_depth) {
                push (@pt_elevations, $surf_elev - $depths[$i]);
            } else {
                push (@pt_elevations, $elevations[$i]);
            }
        }
        $mult   = ($gr_props{$id}{yunits} eq "feet") ? 3.28084 : 1.0;
        $ymin   = $gr_props{$id}{ymin} /$mult;
        $ymax   = $gr_props{$id}{ymax} /$mult;
        $yrange = $ymax -$ymin;
    }

#   Interpolate the WT profile to the model layers.  Keep temperature in Celsius for now.
    if ($data_available) {
        $kb = $gr_props{$id}{kb};
        @el = @{ $gr_props{$id}{el} };
        @t  = ();
        $np = 0;
        @valid_temps = ();
        @valid_elevs = ();
        for ($i=0; $i<=$lastpt; $i++) {
            next if ($temps{$dt}[$i] eq "na");
            next if ($pt_elevations[$i] > $surf_elev +0.1/3.28084);
            next if ($gr_props{$id}{ytype} ne "Depth" && $wsurf{$dt} eq "na");
            push (@valid_temps, $temps{$dt}[$i]);
            push (@valid_elevs, $pt_elevations[$i]);
            $np++;
        }
    }
    undef %temps;

    if ($np > 0) {
        for ($k=1; $k<=$kb; $k++) {
            if ($el[$k+1] >= $surf_elev) {
                $t[$k] = -999.;
                next;
            }

#           Elevation range of interest is deeper than deepest measurement
            if ($el[$k] <= $valid_elevs[$np-1]) {
                $t[$k] = $valid_temps[$np-1];

            } else {
                if ($el[$k] > $surf_elev) {
                    $height = $surf_elev -$el[$k+1];
                } else {
                    $height = $el[$k] -$el[$k+1];
                }
                $first = 1;
                for ($i=0; $i<$np; $i++) {
                    next if ($valid_elevs[$i] > $surf_elev +0.1/3.28084);
                    $el1 = $valid_elevs[$i];
                    $el2 = $valid_elevs[$i+1] if ($i < $np-1);
                    $el3 = $valid_elevs[$i-1] if ($i > 0 && ! $first);
                    $wt1 = $valid_temps[$i];
                    $wt2 = $valid_temps[$i+1] if ($i < $np-1);
                    $wt3 = $valid_temps[$i-1] if ($i > 0 && ! $first);

#                   Elevation is shallower than first measurement
                    if ($first && $el1 <= $el[$k+1]) {
                        $t[$k] = $wt1;
                        last;

#                   Measurement is in the elevation range of interest
                    } elsif ($el1 < $el[$k] && $el1 >= $el[$k+1]) {

#                       Shallowest measurement in elevation range of interest
                        if ($first) {
                            $bot   = $wt1 + ($wt2-$wt1)*($el1-$el[$k+1])/($el1-$el2);
                            $t[$k] = ($wt1*(&min($el[$k], $surf_elev)-$el1)
                                    +(($wt1+$bot)/2.)*($el1-$el[$k+1]))/$height;
                            last;

#                       Deepest measurement in elevation range of interest
                        } elsif ($i == $np-1) {
                            $top   = $wt3 + ($wt1-$wt3)*($el3-$el[$k])/($el3-$el1);
                            $t[$k] = ((($top+$wt1)/2.)*($el[$k]-$el1)
                                    +$wt1*($el1-$el[$k+1]))/$height;
                            last;

#                       Not shallowest, not deepest, in range of interest
                        } else {
                            $top   = $wt3 + ($wt1-$wt3)*($el3-$el[$k])/($el3-$el1);
                            $bot   = $wt1 + ($wt2-$wt1)*($el1-$el[$k+1])/($el1-$el2);
                            $t[$k] = ((($top+$wt1)/2.)*($el[$k]-$el1)
                                    +(($wt1+$bot)/2.)*($el1-$el[$k+1]))/$height;
                            last;
                        }

#                   One measurement above and one below the elevation range of interest
                    } elsif ($el1 >= $el[$k] && $el2 <= $el[$k+1]) {
                        $top   = $wt1 + ($wt2-$wt1)*($el1-$el[$k])  /($el1-$el2);
                        $bot   = $wt1 + ($wt2-$wt1)*($el1-$el[$k+1])/($el1-$el2);
                        $t[$k] = ($top+$bot)/2.;
                        last;
                    }
                    $first = 0;
                }
            }
        }

#       Determine whether flow data are available
#       and whether computations have already been completed for this date
        %qdata     = %{ $gr_props{$id}{qdata} };
        $flow_data = (defined($qdata{$dt})) ? 1 : 0;
        $do_calcs  = 0;
        if ($flow_data) {
            $do_calcs = 1;
            if (defined($gr_props{$id}{qtot_data})) {
                %tdata     = %{ $gr_props{$id}{tdata}     };
                %qtot_data = %{ $gr_props{$id}{qtot_data} };
                %vtot_data = %{ $gr_props{$id}{vtot_data} };
                if (defined($qtot_data{$dt})) {
                    $do_calcs = 0;                 # computations already done for this date
                    @qtot = @{ $qtot_data{$dt} };  # layer outflows in cms/m
                    @vtot = @{ $vtot_data{$dt} };  # layer velocities in m/s
                }
            } else {
                %tdata = %qtot_data = %vtot_data = ();
            }
        }

#       Do the outflow computations if not already completed
        if ($flow_data && $do_calcs) {
            @qstr = @{ $qdata{$dt} };
            @tstr = ();

#           Set parameters for computing vertical withdrawal zone
            @qtot = @vtot = ();
            for ($k=1; $k<=$kb; $k++) {
                $qtot[$k] = $vtot[$k] = 0;
            }
            $qsum   = 0;
            $tsum   = 0;
            $nout   = $gr_props{$id}{nout};
            @sw_alg = @{ $gr_props{$id}{sw_alg} };
            @names  = @{ $gr_props{$id}{names}  };
            @estr   = @{ $gr_props{$id}{estr}   };
            @lw     = @{ $gr_props{$id}{lw}     };
            @ktsw   = @{ $gr_props{$id}{ktsw}   };
            @kbsw   = @{ $gr_props{$id}{kbsw}   };
            @b      = @{ $gr_props{$id}{b}      };

#           Compute water densities
            @rho = ();
            for ($k=1; $k<=$kb; $k++) {
                next if ($t[$k] == -999.);
                $rho[$k] = ((((6.536332E-9*$t[$k]-1.120083E-6)*$t[$k]+1.001685E-4)*$t[$k]
                              -9.09529E-3)*$t[$k]+6.793952E-2)*$t[$k]+999.842594;
            }
            for ($k=$kb-1; $k>=1; $k--) {   # hopefully not needed
                if (! defined($rho[$k]) && defined($rho[$k+1])) {
                    $rho[$k] = $rho[$k+1];
                }
            }

#           Collect data needed for selective withdrawal routines
            $ds_parms{kb}   = $kb;
            $ds_parms{kmx}  = $gr_props{$id}{kmx};
            $ds_parms{wsel} = $surf_elev;      # meters
            $ds_parms{b}    = [ @b   ];        # meters
            $ds_parms{el}   = [ @el  ];        # meters
            $ds_parms{wt}   = [ @t   ];        # deg C
            $ds_parms{rho}  = [ @rho ];        # kg/cu.m.

            if ($props{$id}{wd_alg} eq "Libby Dam") {
                $ds_parms{num_rows}  = $gr_props{$id}{num_rows};
                $ds_parms{bh_width}  = $gr_props{$id}{bh_width};      # meters
                $ds_parms{bh_height} = $gr_props{$id}{bh_height};     # meters
                $ds_parms{base_elev} = $gr_props{$id}{base_elev};     # meters
                $ds_parms{hlc_base}  = $gr_props{$id}{hlc_base};
                $ds_parms{hlc_inc}   = $gr_props{$id}{hlc_inc};
                $ds_parms{bh_miss}   = $gr_props{$id}{bh_miss};
                @nslots              = @{ $gr_props{$id}{num_slots} };
                @ww_names            = @{ $gr_props{$id}{ww_names}  };
                @noutlets            = @{ $gr_props{$id}{num_outs}  };
            }

#           Loop over the outlets
            for ($n=0; $n<$nout; $n++) {
                if ($qstr[$n] == 0.) {
                    $tstr[$n] = -99.;
                    next;
                }
                $ds_parms{qstr} = $qstr[$n];         # cms
                $ds_parms{ktsw} = $ktsw[$n];
                $ds_parms{kbsw} = $kbsw[$n];

#               Compute flows to a discrete outlet using original W2 algorithm
                if ($sw_alg[$n] eq "W2orig") {
                    $ds_parms{estr} = $estr[$n];     # meters
                    $ds_parms{wstr} = $lw[$n];       # meters
                    ($tout, @qout)  = &downstream_withdrawal(%ds_parms);

#               Compute flows over/through bulkhead stacks to a wet well
#               using the new Libby Dam algorithm
                } elsif ($sw_alg[$n] eq "LibbyDam") {

#                   The wet well number is found by matching outlet names
                    $nww = &list_match($names[$n], @ww_names);
                    if ($nww == -1 || $nww > $gr_props{$id}{num_ww} -1) {
                        return &pop_up_error($main,
                                  "Failed to match the name of the wet well to\n"
                                . "one of the named outlets in the release rate file:\n"
                                . "  $props{$id}{lbc_file}\n  $props{$id}{flow_file}");
                    }
                    $ds_parms{nslots}   = $nslots[$nww];
                    $ds_parms{noutlets} = $noutlets[$nww];

                    ($tout, @qout) = &libby_calcs($nww, $dt, %ds_parms);
                }

                $qsum += $qstr[$n];          # Note: qstr[] and qout[] in cms
                $tsum += $qstr[$n] *$tout;   # and tout is in deg Celsius
                for ($k=1; $k<=$kb; $k++) {
                    $qtot[$k] += $qout[$k];
                }
                $tstr[$n] = $tout;
            }
            undef %ds_parms;

            $tstr[$nout] = ($qsum > 0) ? $tsum /$qsum : -99.;
            $tdata{$dt}  = [ @tstr ];
            $gr_props{$id}{tdata} = { %tdata };    # in deg Celsius

#           Adjust flow per unit height (cms/m) and compute velocity (m/s)
            for ($k=1; $k<=$kb; $k++) {
                next if ($el[$k+1] >= $surf_elev);
                $height    = &min($surf_elev, $el[$k]) -$el[$k+1];
                $vtot[$k]  = $qtot[$k] /($height *$b[$k]);
                $qtot[$k] /= $height;
            }
            $qtot_data{$dt} = [ @qtot ];
            $vtot_data{$dt} = [ @vtot ];
            $gr_props{$id}{qtot_data} = { %qtot_data };  # layer outflows in cms/m
            $gr_props{$id}{vtot_data} = { %vtot_data };  # layer velocities in m/s
        }
        undef %qdata;
    }

#   Plot the water surface and its indicator, if plotting elevations
    if ($data_available && $gr_props{$id}{ytype} ne "Depth" && $wsurf{$dt} ne "na") {
        $yp = $y2 -($y2-$y1)*($surf_elev-$ymin)/$yrange;
        if ($yp >= $y1 && $yp <= $y2) {
            $canv->create_line($x1, $yp, $x2, $yp,
                                -fill  => &get_rgb_code("gray60"),
                                -width => 1,
                                -arrow => 'none',
                                -tags  => $gtag . " " . $gtag . "_profile");
            $xp = $x1 + 0.9*($x2-$x1);
            $canv->create_polygon($xp, $yp, $xp-4, $yp-8, $xp+4, $yp-8,
                                -outline => &get_rgb_code("gray60"),
                                -width   => 1,
                                -fill    => &get_rgb_code("white"),
                                -tags    => $gtag . " " . $gtag . "_profile");
        }
    }

#   Plot a no-data message
    if ($np == 0 || ! $flow_data) {
        if ($data_available && $gr_props{$id}{ytype} ne "Depth" && $wsurf{$dt} ne "na") {
            $yp  = $y2 -($y2-$y1)*($surf_elev-$ymin)/$yrange +5;
            $anc = 'n';
            if ($yp < $y1 || $yp > $y2) {
                $yp  = ($y1 +$y2)/2.;
                $anc = 'center';
            }
        } else {
            $yp  = ($y1 +$y2)/2.;
            $anc = 'center';
        }
        $msg = ($np == 0) ? "No Data" : "No Outlet Flow Data";
        $canv->create_text(($x1+$x2)/2, $yp,
                            -anchor => $anc, 
                            -text   => $msg,
                            -fill   => &get_rgb_code("gray60"),
                            -angle  => 0,
                            -tags   => $gtag . " " . $gtag . "_profile",
                            -font   => [-family     => $gr_props{$id}{xfont},
                                        -size       => $gr_props{$id}{xl_size},
                                        -weight     => 'normal',
                                        -slant      => 'roman',
                                        -underline  => 0,
                                        -overstrike => 0,
                                       ]);
    }
    undef %wsurf;

#   Draw the layer-specific flow graph
    if ($np > 0 && $flow_data) {

#       Create an image to hold the color profile and recognize its methods
        if ($gr_props{$id}{add_cs}) {
            $iw = $x2 -$x1 +1;
            $ih = $y2 -$y1 +1;
            $cmap_image = Tkx::image_create_photo(-width => $iw, -height => $ih);
            $cmap_image = Tkx::widget->new($cmap_image);
        }

        if ($gr_props{$id}{qunits} eq "cfs/ft") {      # outflow per unit height
            $qmult = 10.763911;
        } elsif ($gr_props{$id}{qunits} eq "cms/m") {  # outflow per unit height
            $qmult = 1.0;
        } else {                                       # swap for velocity data
            @qtot  = @vtot;
            $qmult = ($gr_props{$id}{qunits} eq "ft/s") ? 3.28084 : 1.0;
        }
        @coords  = ();
        $last_xp = $x1;
        for ($k=1; $k<=$kb; $k++) {
            next if ($el[$k+1] >= $surf_elev);
            if ($gr_props{$id}{ytype} eq "Depth") {
                last if ($surf_elev -$el[$k] > $ymax);
            } else {
                next if ($el[$k+1] > $ymax);
                last if ($el[$k]   < $ymin);
            }
            if ($gr_props{$id}{add_cs}) {
                $xp = &round_to_int(&min($iw-1, ($iw-1)*$qtot[$k]*$qmult/$gr_props{$id}{xmax}));
                if ($xp > 0) {
                    if ($gr_props{$id}{ytype} eq "Depth") {
                        $yp1 = &round_to_int(($ih-1)*(&max(0.0, $surf_elev-$el[$k]))/$ymax);
                        $yp2 = &round_to_int(($ih-1)*($surf_elev-$el[$k+1])/$ymax);
                    } else {
                        $yp1 = &round_to_int($ih-1 -($ih-1)*(&min($surf_elev, $el[$k])-$ymin) /$yrange);
                        $yp2 = &round_to_int($ih-1 -($ih-1)*($el[$k+1]-$ymin)/$yrange);
                    }
                    $yp1 = &max(0, &min($ih-1, $yp1));
                    $yp2 = &max(0, &min($ih-1, $yp2));
                    if ($props{$id}{wt_units} eq "Fahrenheit") {
                        $j = int(($#colors+1) *(($t[$k] *1.8 +32)-$cs_min)/$cs_range);
                    } else {
                        $j = int(($#colors+1) *($t[$k]-$cs_min)/$cs_range);
                    }
                    $j = &max(0, &min($#colors, $j));
                    $cmap_image->put($colors[$j], -to => 0, $yp1, $xp, $yp2);
                }
            }
            $xp = &min($x2, $x1 +($x2-$x1)*$qtot[$k]*$qmult/$gr_props{$id}{xmax});
            if ($gr_props{$id}{ytype} eq "Depth") {
                $yp1 = $y1 +($y2-$y1)*(&max(0.0, $surf_elev-$el[$k]))/$ymax;
                $yp2 = $y1 +($y2-$y1)*($surf_elev-$el[$k+1])/$ymax;
            } else {
                $yp1 = $y2 -($y2-$y1)*(&min($surf_elev, $el[$k])-$ymin)/$yrange;
                $yp2 = $y2 -($y2-$y1)*($el[$k+1]-$ymin)/$yrange;
            }
            $yp1 = &max($y1, &min($y2, $yp1));
            $yp2 = &max($y1, &min($y2, $yp2));
            if ($xp == $last_xp) {
                push (@coords, $xp, $yp1) if ($#coords < 0);
                push (@coords, $xp, $yp2);
            } else {
                push (@coords, $last_xp, $yp1, $xp, $yp1, $xp, $yp2);
            }
            if ($k == $kb && $xp != $x1) {
                push (@coords, $x1, $yp2);
            }
            $last_xp = $xp;
            last if ($yp2 == $y2);
        }
        if ($gr_props{$id}{add_cs}) {
            $canv->create_image($x1, $y1, -anchor => 'nw',
                                          -image  => $cmap_image,
                                          -tags   => $gtag . " " . $gtag . "_colorProfile");
            undef $cmap_image;
        }

#       Plot the flow graph
        if ($#coords >= 3) {
            $canv->create_line(@coords, -fill  => &get_rgb_code("black"),
                                        -width => 1,
                                        -arrow => 'none',
                                        -tags  => $gtag . " " . $gtag . "_profile");
        }
    }

#   Place the graphic items in the proper order
    &raise_lower($canv, $id, "tiptop") if ($new_graph);
    if ($gr_props{$id}{add_cs}) {
        $canv->lower($gtag . "_colorKey",      $id);
        $canv->lower($gtag . "_colorKeyTitle", $id);
        $canv->lower($gtag . "_colorProfile",  $id);
    }
    $canv->lower($gtag . "_date",       $id);
    $canv->lower($gtag . "_gtitle",     $id);
    $canv->lower($gtag . "_xaxisTitle", $id);
    $canv->lower($gtag . "_yaxisTitle", $id);
    $canv->lower($gtag . "_profile",    $id);
    $canv->lower($gtag . "_xaxis",      $id);
    $canv->lower($gtag . "_yaxis",      $id);
    if ($props{$id}{wd_alg} eq "Libby Dam" && $gr_props{$id}{bh_show}) {
        $canv->lower($gtag . "_openBH", $id);
    }
    if ($group_tags) {
        foreach $tag (@grp_tags) {
            $canv->addtag($tag, withtag => $gtag);
        }
    }

#   Update any links
    &update_links($canv, $id, $dt);
}


sub generate_outflow_temps {
    my ($id, $ts_id) = @_;
    my (
        $bot, $dd, $dt, $el1, $el2, $el3, $first, $geom, $got_depth, $height,
        $i, $k, $kb, $lastpt, $n, $nout, $np, $nww, $pbar, $pbar_frame,
        $pbar_txt, $pbar_window, $qsum, $surf_elev, $top, $tout, $tsum,
        $wt1, $wt2, $wt3, $X, $x1, $x2, $Y, $y1, $y2,

        @b, @depths, @el, @elevations, @estr, @kbsw, @ktsw, @lw, @mydates,
        @names, @noutlets, @nslots, @pt_elevations, @qout, @qstr, @qtot,
        @rho, @sw_alg, @t, @tstr, @valid_elevs, @valid_temps, @vtot,
        @ww_names,

        %ds_parms, %qdata, %qtot_data, %tdata, %temps, %vtot_data, %wsurf,
       );

    $pbar_txt = "Computing outlet temperatures.";
    if (! defined($ts_id) || $ts_id == 0) {
        $ts_id = $id;
        $pbar_txt = "Computing layer outflows.";
    }

#   Set some variables and populate some arrays and hashes
    $got_depth = ($gr_props{$id}{elv_dep} eq "elevation") ? 0 : 1;
    if ($got_depth) {
        @depths     = @{ $gr_props{$id}{depths} };
    } else {
        @elevations = @{ $gr_props{$id}{elevations} };
    }
    if (defined($gr_props{$id}{qtot_data})) {
        %tdata     = %{ $gr_props{$id}{tdata}     };
        %qtot_data = %{ $gr_props{$id}{qtot_data} };
        %vtot_data = %{ $gr_props{$id}{vtot_data} };
    } else {
        %tdata = %qtot_data = %vtot_data = ();
    }
    $nout   = $gr_props{$id}{nout};
    $kb     = $gr_props{$id}{kb};
    @sw_alg = @{ $gr_props{$id}{sw_alg}  };
    @names  = @{ $gr_props{$id}{names}   };
    @estr   = @{ $gr_props{$id}{estr}    };
    @lw     = @{ $gr_props{$id}{lw}      };
    @ktsw   = @{ $gr_props{$id}{ktsw}    };
    @kbsw   = @{ $gr_props{$id}{kbsw}    };
    @b      = @{ $gr_props{$id}{b}       };
    @el     = @{ $gr_props{$id}{el}      };
    %qdata  = %{ $gr_props{$id}{qdata}   };
    %wsurf  = %{ $gr_props{$id}{ws_elev} };
    %temps  = %{ $gr_props{$id}{pdata}   };

#   Dates for computations
    @mydates = sort keys %temps;

#   Collect data needed for selective withdrawal routines
    %ds_parms       = ();
    $ds_parms{kb}   = $kb;
    $ds_parms{kmx}  = $gr_props{$id}{kmx};
    $ds_parms{b}    = [ @b  ];                                # meters
    $ds_parms{el}   = [ @el ];                                # meters
    if ($props{$id}{wd_alg} eq "Libby Dam") {
        $ds_parms{num_rows}  = $gr_props{$id}{num_rows};
        $ds_parms{bh_width}  = $gr_props{$id}{bh_width};      # meters
        $ds_parms{bh_height} = $gr_props{$id}{bh_height};     # meters
        $ds_parms{base_elev} = $gr_props{$id}{base_elev};     # meters
        $ds_parms{hlc_base}  = $gr_props{$id}{hlc_base};
        $ds_parms{hlc_inc}   = $gr_props{$id}{hlc_inc};
        $ds_parms{bh_miss}   = $gr_props{$id}{bh_miss};
        @nslots              = @{ $gr_props{$id}{num_slots} };
        @ww_names            = @{ $gr_props{$id}{ww_names}  };
        @noutlets            = @{ $gr_props{$id}{num_outs}  };
    }

#   Create a progress bar
    ($x1, $y1, $x2, $y2) = @{ $props{$ts_id}{coordlist} };
    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $geom = sprintf("+%d+%d", $X+($x1+$x2)/2-150, $Y+($y1+$y2)/2);

    $pbar_window = $main->new_toplevel();
    $pbar_window->g_wm_transient($main);
    $pbar_window->g_wm_title($pbar_txt . "..");
    $pbar_window->g_wm_geometry($geom);
    $pbar_window->configure(-cursor => $cursor_wait);

    $pbar_frame = $pbar_window->new_frame(
                        -borderwidth => 2,
                        -relief      => 'groove');
    $pbar_frame->g_pack(-anchor => 'nw', -expand => 1, -fill => 'x');
    ($pbar = $pbar_frame->new_ttk__progressbar(
                        -orient  => 'horizontal',
                        -length  => 300,
                        -mode    => 'determinate',
                        -value   => 0,
                        -maximum => $#mydates,
                        ))->g_pack();

#   Move mouse cursor to ensure that it changes to cursor_wait
    if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
        $canvas->g_bind("<Motion>", "");
        Tkx::event_generate($main, "<Motion>", -warp => 1, -x => ($x1+$x2)/2, -y => ($y1+$y2)/2);
        $canvas->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"), $canvas, "menu" ]);
    }

#   Change the mouse cursor to alert the user to be patient
    $status_line = $pbar_txt . "  Please wait...";
    $canvas->configure(-cursor => $cursor_wait);
    $pbar_window->g_focus;
    Tkx::tk_busy_hold($main, -cursor => $cursor_wait);
    Tkx::update();
    Tkx::wm_resizable($pbar_window,0,0);

#   Loop over the dates for this graph
    for ($dd=0; $dd<=$#mydates; $dd++) {
        $dt = $mydates[$dd];
        $pbar->configure(-value => $dd);  # update the progress bar
        Tkx::update_idletasks();
        next if (! defined($wsurf{$dt}) || ! defined($temps{$dt}) || ! defined($qdata{$dt}));
        next if ($wsurf{$dt} eq "na");
        next if (defined($tdata{$dt}));

#       Initialize the temperature array for each outlet
        @tstr = ();
        for ($n=0; $n<=$nout; $n++) {
            $tstr[$n] = -99.;
        }

#       Populate the pt_elevations array.  Keep elevations and depths in meters.
        $surf_elev = $wsurf{$dt};
        $lastpt    = ($got_depth) ? $#depths : $#elevations;
        @pt_elevations = ();
        for ($i=0; $i<=$lastpt; $i++) {
            if ($got_depth) {
                push (@pt_elevations, $surf_elev - $depths[$i]);
            } else {
                push (@pt_elevations, $elevations[$i]);
            }
        }

#       Test for sufficient temperature data to proceed
        $np = 0;
        @valid_temps = ();
        @valid_elevs = ();
        for ($i=0; $i<=$lastpt; $i++) {
            next if ($temps{$dt}[$i] eq "na");
            next if ($pt_elevations[$i] > $surf_elev +0.1/3.28084);
            push (@valid_temps, $temps{$dt}[$i]);
            push (@valid_elevs, $pt_elevations[$i]);
            $np++;
        }
        if ($np == 0) {
            $tdata{$dt} = [ @tstr ];
            next;
        }

#       Interpolate the WT profile to the model layers
        @t = ();
        for ($k=1; $k<=$kb; $k++) {
            if ($el[$k+1] >= $surf_elev) {
                $t[$k] = -999.;
                next;
            }

#           Elevation range of interest is deeper than deepest measurement
            if ($el[$k] <= $valid_elevs[$np-1]) {
                $t[$k] = $valid_temps[$np-1];

            } else {
                if ($el[$k] > $surf_elev) {
                    $height = $surf_elev -$el[$k+1];
                } else {
                    $height = $el[$k] -$el[$k+1];
                }
                $first = 1;
                for ($i=0; $i<=$lastpt; $i++) {
                    next if ($valid_elevs[$i] > $surf_elev +0.1/3.28084);
                    $el1 = $valid_elevs[$i];
                    $el2 = $valid_elevs[$i+1] if ($i < $np-1);
                    $el3 = $valid_elevs[$i-1] if ($i > 0 && ! $first);
                    $wt1 = $valid_temps[$i];
                    $wt2 = $valid_temps[$i+1] if ($i < $np-1);
                    $wt3 = $valid_temps[$i-1] if ($i > 0 && ! $first);

#                   Elevation is shallower than first measurement
                    if ($first && $el1 <= $el[$k+1]) {
                        $t[$k] = $wt1;
                        last;

#                   Measurement is in the elevation range of interest
                    } elsif ($el1 < $el[$k] && $el1 >= $el[$k+1]) {

#                       Shallowest measurement in elevation range of interest
                        if ($first) {
                            $bot   = $wt1 + ($wt2-$wt1)*($el1-$el[$k+1])/($el1-$el2);
                            $t[$k] = ($wt1*(&min($el[$k], $surf_elev)-$el1)
                                    +(($wt1+$bot)/2.)*($el1-$el[$k+1]))/$height;
                            last;

#                       Deepest measurement in elevation range of interest
                        } elsif ($i == $np-1) {
                            $top   = $wt3 + ($wt1-$wt3)*($el3-$el[$k])/($el3-$el1);
                            $t[$k] = ((($top+$wt1)/2.)*($el[$k]-$el1)
                                    +$wt1*($el1-$el[$k+1]))/$height;
                            last;

#                       Not shallowest, not deepest, in range of interest
                        } else {
                            $top   = $wt3 + ($wt1-$wt3)*($el3-$el[$k])/($el3-$el1);
                            $bot   = $wt1 + ($wt2-$wt1)*($el1-$el[$k+1])/($el1-$el2);
                            $t[$k] = ((($top+$wt1)/2.)*($el[$k]-$el1)
                                    +(($wt1+$bot)/2.)*($el1-$el[$k+1]))/$height;
                            last;
                        }

#                   One measurement above and one below the elevation range of interest
                    } elsif ($el1 >= $el[$k] && $el2 <= $el[$k+1]) {
                        $top   = $wt1 + ($wt2-$wt1)*($el1-$el[$k])  /($el1-$el2);
                        $bot   = $wt1 + ($wt2-$wt1)*($el1-$el[$k+1])/($el1-$el2);
                        $t[$k] = ($top+$bot)/2.;
                        last;
                    }
                    $first = 0;
                }
            }
        }

#       Compute water densities
        @rho = ();
        for ($k=1; $k<=$kb; $k++) {
            next if ($t[$k] == -999.);
            $rho[$k] = ((((6.536332E-9*$t[$k]-1.120083E-6)*$t[$k]+1.001685E-4)*$t[$k]
                          -9.09529E-3)*$t[$k]+6.793952E-2)*$t[$k]+999.842594;
        }
        for ($k=$kb-1; $k>=1; $k--) {   # hopefully not needed
            if (! defined($rho[$k]) && defined($rho[$k+1])) {
                $rho[$k] = $rho[$k+1];
            }
        }

#       Collect data needed for selective withdrawal routines
        $ds_parms{wsel} = $surf_elev;    # meters
        $ds_parms{wt}   = [ @t   ];      # deg C
        $ds_parms{rho}  = [ @rho ];      # kg/cu.m.

#       Compute outflow temperatures for each outlet
        $qsum = 0;
        $tsum = 0;
        @qstr = @{ $qdata{$dt} };
        @qtot = @vtot = ();
        for ($k=1; $k<=$kb; $k++) {
            $qtot[$k] = $vtot[$k] = 0;
        }

#       Loop over the outlets
        for ($n=0; $n<$nout; $n++) {
            next if ($qstr[$n] == 0.);
            $ds_parms{qstr} = $qstr[$n];         # cms
            $ds_parms{ktsw} = $ktsw[$n];
            $ds_parms{kbsw} = $kbsw[$n];

#           Compute flows to a discrete outlet using original W2 algorithm
            if ($sw_alg[$n] eq "W2orig") {
                $ds_parms{estr} = $estr[$n];     # meters
                $ds_parms{wstr} = $lw[$n];       # meters
                ($tout, @qout)  = &downstream_withdrawal(%ds_parms);

#           Compute flows over/through bulkhead stacks to a wet well
#           using the new Libby Dam algorithm
            } elsif ($sw_alg[$n] eq "LibbyDam") {

#               The wet well number is found by matching outlet names
                $nww = &list_match($names[$n], @ww_names);
                if ($nww == -1 || $nww > $gr_props{$id}{num_ww} -1) {
                    return &pop_up_error($main,
                              "Failed to match the name of the wet well to\n"
                            . "one of the named outlets in the release rate file:\n"
                            . "  $props{$id}{lbc_file}\n  $props{$id}{flow_file}");
                }
                $ds_parms{nslots}   = $nslots[$nww];
                $ds_parms{noutlets} = $noutlets[$nww];

                ($tout, @qout) = &libby_calcs($nww, $dt, %ds_parms);
            }

            $qsum += $qstr[$n];          # Note: qstr[] and qout[] in cms
            $tsum += $qstr[$n] *$tout;   # and tout is in deg Celsius
            for ($k=1; $k<=$kb; $k++) {
                $qtot[$k] += $qout[$k];
            }
            $tstr[$n] = $tout;
        }
        $tstr[$nout] = ($qsum > 0) ? $tsum /$qsum : -99.;
        $tdata{$dt}  = [ @tstr ];

#       Adjust flow per unit height (cms/m) and compute velocity (m/s)
        for ($k=1; $k<=$kb; $k++) {
            next if ($el[$k+1] >= $surf_elev);
            $height    = &min($surf_elev, $el[$k]) -$el[$k+1];
            $vtot[$k]  = $qtot[$k] /($height *$b[$k]);
            $qtot[$k] /= $height;
        }
        $qtot_data{$dt} = [ @qtot ];
        $vtot_data{$dt} = [ @vtot ];
    }
    undef %ds_parms;
    undef %qdata;
    undef %temps;
    undef %wsurf;

#   Restore mouse cursor and remove the progress bar
    $canvas->configure(-cursor => $cursor_norm);
    $pbar_window->g_destroy();
    $status_line = "";
    Tkx::tk_busy_forget($main);

#   Save results
    $gr_props{$id}{tdata}     = { %tdata     };  # outlet temps in deg C
    $gr_props{$id}{qtot_data} = { %qtot_data };  # layer outflows in cms/m
    $gr_props{$id}{vtot_data} = { %vtot_data };  # layer velocities in m/s
}


sub make_bulkhead_graphic {
    my ($canv, $id, $dt, %parms) = @_;
    my (
        $base_elev, $bh_bcellh, $bh_bcellw, $bh_bcolor, $bh_bwidth,
        $bh_docked, $bh_font, $bh_height, $bh_size, $bh_tcolor, $bh_weight,
        $bh_xpos, $bh_ypos, $bhd, $bhd_tmp, $bhdt, $dt_tmp, $first, $gtag,
        $last_bhd, $mult, $n, $nr, $nrows, $num_ww, $surf_elev, $tags,
        $x1, $x2, $xp, $y1, $y2, $ymax, $ymin, $yp, $yp1, $yp2, $ytype,

        @nopen_bh, @ww_names,

        %bh_miss,
       );

    $mult      = ($parms{yunits} eq "feet") ? 3.28084 : 1.0;
    $ytype     = $parms{ytype};
    $ymin      = $parms{ymin} /$mult;   # do calcs in meters
    $ymax      = $parms{ymax} /$mult;
    $num_ww    = $parms{num_ww};
    $nrows     = $parms{num_rows};
    $bh_height = $parms{bh_height};
    $base_elev = $parms{base_elev};
    $surf_elev = $parms{surf_elev};
    $bh_font   = $parms{bh_font};
    $bh_size   = $parms{bh_size};
    $bh_weight = $parms{bh_weight};
    $bh_tcolor = $parms{bh_tcolor};
    $bh_bwidth = $parms{bh_bwidth};
    $bh_bcolor = $parms{bh_bcolor};
    $bh_bcellw = $parms{bh_bcellw};
    $bh_docked = $parms{bh_docked};
    $bh_xpos   = $parms{bh_xpos};
    $bh_ypos   = $parms{bh_ypos};
    $bh_bcellh = $parms{bh_bcellh};

    @ww_names = @{ $parms{ww_names} };
    %bh_miss  = %{ $parms{bh_miss}  };

    $dt_tmp = (length($dt) == 8) ? $dt . "0000" : $dt;
    $first  = 1;
    foreach $bhd (sort keys %bh_miss) {
        $bhdt    = $bhd;
        $bhd_tmp = (length($bhd) == 8) ? $bhd . "0000" : $bhd;
        if ($bhd_tmp > $dt_tmp) {
            $bhdt = ($first) ? $bhd : $last_bhd;
            last;
        }
        $last_bhd = $bhd;
        $first = 0;
    }
    @nopen_bh = @{ $bh_miss{$bhdt} };

    $gtag = "graph" . $id;
    if ($bh_docked) {
        $tags = $gtag . " " . $gtag . "_openBH";
    } else {
        $tags = $gtag . "_openBH";
    }
    ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
    if ($ytype eq "Depth") {
        if (defined($surf_elev) && $surf_elev ne "na") {
            $yp1 = $y1 +($y2 -$y1) *($surf_elev -($base_elev +$nrows *$bh_height)) /$ymax;
            $yp2 = $y1 +($y2 -$y1) *($surf_elev -$base_elev) /$ymax;
        } else {
            return;
        }
    } else {
        $yp1 = $y1 +($y2 -$y1) *($ymax -($base_elev +$nrows *$bh_height)) /($ymax -$ymin);
        $yp2 = $y1 +($y2 -$y1) *($ymax -$base_elev) /($ymax -$ymin);
    }
    if ($bh_docked || $bh_xpos == -99 || $bh_ypos == -99 || $bh_bcellh == -99) {
        $bh_xpos   = $gr_props{$id}{bh_xpos}   = $x2 -$num_ww *$bh_bcellw;
        $bh_ypos   = $gr_props{$id}{bh_ypos}   = $yp2;
        $bh_bcellh = $gr_props{$id}{bh_bcellh} = ($yp2 -$yp1)/$nrows;
    }
    $canv->create_rectangle($bh_xpos, $bh_ypos, $bh_xpos +$num_ww *$bh_bcellw, $bh_ypos -$nrows *$bh_bcellh,
                            -outline => &get_rgb_code($bh_bcolor),
                            -width   => $bh_bwidth,
                            -fill    => "",
                            -tags    => $tags);
    for ($n=1; $n<$num_ww; $n++) {
        $xp = $bh_xpos +$n *$bh_bcellw;
        $canv->create_line($xp, $bh_ypos, $xp, $bh_ypos -$nrows *$bh_bcellh,
                            -fill  => &get_rgb_code($bh_bcolor),
                            -width => $bh_bwidth,
                            -arrow => 'none',
                            -tags  => $tags);
    }
    for ($nr=1; $nr<$nrows; $nr++) {
        $yp = $bh_ypos -$nr *$bh_bcellh;
        $canv->create_line($bh_xpos, $yp, $bh_xpos +$num_ww *$bh_bcellw, $yp,
                            -fill  => &get_rgb_code($bh_bcolor),
                            -width => $bh_bwidth,
                            -arrow => 'none',
                            -tags  => $tags);
    }
    for ($n=0; $n<$num_ww; $n++) {
        $xp = $bh_xpos +($n +0.5) *$bh_bcellw;
        for ($nr=0; $nr<$nrows; $nr++) {
            $yp = $bh_ypos -($nr +0.5) *$bh_bcellh;
            $canv->create_text($xp, $yp,
                               -anchor => 'center',
                               -text   => $nopen_bh[$n][$nr],
                               -fill   => &get_rgb_code($bh_tcolor),
                               -angle  => 0,
                               -tags   => $tags,
                               -font   => [-family     => $bh_font,
                                           -size       => $bh_size,
                                           -weight     => $bh_weight,
                                           -slant      => 'roman',
                                           -underline  => 0,
                                           -overstrike => 0,
                                          ]);
        }
    }
}


sub setup_w2_outflow {
    my ($canv, $id) = @_;
    my (
        $bth_file, $bth_file_btn, $byear, $byear_cb, $con_file, $elev_base,
        $f, $frame, $geom, $gr_type, $gtitle, $jd_skip, $jd_skip_active,
        $jd_skip_explain, $jd_skip_frame, $jd_skip_label, $nwb,
        $offset_frame, $ok_btn, $qaxis_units, $qaxis_units_cb, $qla_file,
        $qla_file_btn, $qla_lines, $row, $segnum, $segnum_txt, $title,
        $tz_offset, $wdof_msg, $X, $x1, $x2, $xmajor, $xmajor_entry,
        $xmax, $xmax_entry, $Y, $y1, $y2, $yaxis_type, $yaxis_type_cb,
        $yaxis_units, $yaxis_units_label, $ymajor, $ymajor_entry,
        $ymajor_label, $ymax, $ymax_entry, $ymax_label, $ymin, $ymin_entry,
        $ymin_label, $ymin_units_label, $yr_max, $yr_min,

        @be, @bs, @ds, @jd_skip_opts, @us,
       );

    ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $X += $x1 +30;
    $Y += $y1 +50;
    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($w2outflow_setup_menu) && Tkx::winfo_exists($w2outflow_setup_menu)) {
        if ($w2outflow_setup_menu->g_wm_title() eq "W2 Layer Outflows Setup") {
            $w2outflow_setup_menu->g_destroy();
            undef $w2outflow_setup_menu;
        }
    }
    $w2outflow_setup_menu = $main->new_toplevel();
    $w2outflow_setup_menu->g_wm_transient($main);
    $w2outflow_setup_menu->g_wm_title("W2 Layer Outflows Setup");
    $w2outflow_setup_menu->configure(-cursor => $cursor_norm);
    $w2outflow_setup_menu->g_wm_geometry($geom);

#   Try to keep the nascent graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

    $con_file    = $qla_file = $bth_file = "";
    $qla_lines   = 0;
    $yaxis_units = "feet";
    $yaxis_type  = "Elevation";
    $elev_base   = -999;
    $segnum      = "";
    $segnum_txt  = "";
    $qaxis_units = "cfs/ft";
    $wdof_msg    = "";
    $gr_type     = "Release Rates Only";
    $tz_offset   = "+00:00";

    $yr_max = (localtime(time))[5] +1900;
    $yr_min = $yr_max -25;
    $byear  = $yr_max;
    $ymin   = $ymax   = $ymajor = "";
    $xmax   = $xmajor = "";
    $title  = "Release Rate, in cfs/(vert. ft)";
    $gtitle = "Modeled Withdrawal Zone";

    $jd_skip_active = $jd_skip = 0;
    @jd_skip_opts = ("(keep all)", "(keep every other)", "(keep every 3rd)", "(keep every 4th)",
                     "(keep every 5th)",  "(keep every 6th)",  "(keep every 7th)",  "(keep every 8th)",
                     "(keep every 9th)",  "(keep every 10th)", "(keep every 11th)", "(keep every 12th)",
                     "(keep every 13th)", "(keep every 14th)", "(keep every 15th)", "(keep every 16th)",
                     "(keep every 17th)", "(keep every 18th)", "(keep every 19th)", "(keep every 20th)",
                     "(keep every 21st)", "(keep every 22nd)", "(keep every 23rd)", "(keep every 24th)",
                     "(keep every 25th)", "(keep every 26th)", "(keep every 27th)", "(keep every 28th)",
                     "(keep every 29th)", "(keep every 30th)", "(keep every 31st)", "(keep every 32nd)",
                     "(keep every 33rd)", "(keep every 34th)", "(keep every 35st)", "(keep every 36th)",
                     "(keep every 37th)", "(keep every 38th)", "(keep every 39th)", "(keep every 40th)",
                     "(keep every 41st)", "(keep every 42nd)", "(keep every 43rd)", "(keep every 44th)",
                     "(keep every 45th)", "(keep every 46th)", "(keep every 47th)", "(keep every 48th)",
                     "(keep every 49th)", "(keep every 50th)");
    $jd_skip_explain = $jd_skip_opts[$jd_skip];

#   Begin the menu
    $frame = $w2outflow_setup_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -state   => 'disabled',
            -command => sub { my ($add_parm, %parms);
                              if ($con_file eq "" || ! -e $con_file) {
                                  return &pop_up_error($w2outflow_setup_menu,
                                  "W2 Control file not set or does not exist:\n$con_file");
                              }
                              if ($qla_file eq "" || ! -e $qla_file) {
                                  return &pop_up_error($w2outflow_setup_menu,
                                  "W2 Layer Outflow file not set or does not exist:\n$qla_file");
                              }
                              if ($bth_file eq "" || ! -e $bth_file) {
                                  return &pop_up_error($w2outflow_setup_menu,
                                  "W2 Bathymetry file not set or does not exist:\n$bth_file");
                              }
                              if ($xmax eq "") {
                                  return &pop_up_error($w2outflow_setup_menu,
                                  "Please provide a maximum layer outflow rate.");
                              }
                              if ($yaxis_type eq "Elevation") {
                                  if ($ymin eq "" || $ymax eq "") {
                                      return &pop_up_error($w2outflow_setup_menu,
                                      "Please provide both a min and max elevation.");
                                  }
                                  if ($ymin >= $ymax) {
                                      return &pop_up_error($w2outflow_setup_menu,
                                      "The minimum elevation must be less than the maximum elevation.");
                                  }
                              } else {
                                  if ($ymax eq "") {
                                      return &pop_up_error($w2outflow_setup_menu,
                                      "Please provide a maximum depth.");
                                  }
                              }
                              if ($segnum eq "" || $segnum <= 0) {
                                  return &pop_up_error($w2outflow_setup_menu,
                                  "W2 segment number must be numeric and positive.");
                              }
                              $gtitle =~ s/^\s+//;
                              $gtitle =~ s/\s+$//;
                              $add_parm = ($gr_type eq "With Parameter Color Scheme") ? 1 : 0;

                              %parms             = ();
                              $parms{xmax}       = $xmax;
                              $parms{xmajor}     = $xmajor;
                              $parms{qunits}     = $qaxis_units;
                              $parms{ymin}       = $ymin;
                              $parms{ymax}       = $ymax;
                              $parms{ymajor}     = $ymajor;
                              $parms{ytype}      = $yaxis_type;
                              $parms{yunits}     = $yaxis_units;
                              $parms{gtitle}     = $gtitle;
                              $props{$id}{parms} = { %parms };

                              $props{$id}{files}     = 1;
                              $props{$id}{con_file}  = $con_file;
                              $props{$id}{bth_file}  = $bth_file;
                              $props{$id}{qla_file}  = $qla_file;
                              $props{$id}{qla_lines} = $qla_lines;
                              $props{$id}{add_parm}  = $add_parm;
                              $props{$id}{seg}       = $segnum;
                              $props{$id}{byear}     = $byear;
                              $props{$id}{tz_offset} = $tz_offset;
                              $props{$id}{jd_skip}   = $jd_skip;

                              $w2outflow_setup_menu->g_bind('<Destroy>', "");
                              if ($add_parm) {
                                  $geom = $w2outflow_setup_menu->g_wm_geometry();
                                  (undef, $X, $Y) = split(/\+/, $geom);
                                  &setup_w2_outflow_part2($canv, $id, $X, $Y, 0);
                              } else {
                                  $w2outflow_setup_menu->g_destroy();
                                  undef $w2outflow_setup_menu;
                                  &reset_bindings;
                                  &make_w2_outflow($canv, $id, 0);
                              }
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $w2outflow_setup_menu->g_bind('<Destroy>', "");
                              $w2outflow_setup_menu->g_destroy();
                              undef $w2outflow_setup_menu;
                              $canv->delete("graph" . $id);
                              delete $props{$id};
                              delete $grid{$id} if (defined($grid{$id}));
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Delete graph if this menu is destroyed by other than the Cancel button
    $w2outflow_setup_menu->g_bind('<Destroy>' => sub { undef $w2outflow_setup_menu;
                                                       $canv->delete("graph" . $id);
                                                       delete $props{$id}; 
                                                       delete $grid{$id} if (defined($grid{$id}));
                                                       &reset_bindings;
                                                     });

    $f = $w2outflow_setup_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "W2 Control File: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$con_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);
    $f->new_button(
            -text    => "Browse",
            -command => sub { my ($file, $i, $wdof_max, $wdof_min, @wdof);
                              $file = Tkx::tk___getOpenFile(
                                      -parent           => $w2outflow_setup_menu,
                                      -title            => "Select W2 Control File",
                                      -initialdir       => abs_path(),
                                      -filetypes => [ ['All Files',  '*'],
                                                      ['CSV (comma delimited)', '.csv'],
                                                      ['NPT (W2 input file)', '.npt'],
                                                    ],
                                      );
                              if (defined($file) && -e $file) {
                                  $con_file = File::Spec->rel2abs($file);
                                  &read_con($main, $id, $con_file);

                                  $nwb   = $grid{$id}{nwb};
                                  @bs    = @{ $grid{$id}{bs}   };
                                  @be    = @{ $grid{$id}{be}   };
                                  @us    = @{ $grid{$id}{us}   };
                                  @ds    = @{ $grid{$id}{ds}   };
                                  @wdof  = @{ $grid{$id}{wdof} };
                                  $byear = $grid{$id}{byear};
                                  if ($byear <= $yr_min) {
                                      $yr_min = $byear -10;
                                      $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                  }
                                  $byear_cb->configure(-state => 'readonly');
                                  $qla_file_btn->configure(-state => 'normal');
                                  $bth_file_btn->configure(-state => 'normal');
                              } else {
                                  $con_file = "";
                                  $byear_cb->configure(-state => 'disabled');
                                  $qla_file_btn->configure(-state => 'disabled');
                                  $bth_file_btn->configure(-state => 'disabled');
                              }
                              $qla_file = $bth_file = $segnum = $segnum_txt = "";
                              $jd_skip_active = 0;
                              $wdof_min =  9.E6;
                              $wdof_max = -9.E6;
                              for ($i=1; $i<=$#wdof; $i++) {
                                  next if ($wdof[$i] eq "na");
                                  $jd_skip_active = 1 if ($wdof[$i] < 1.0);
                                  $wdof_min = $wdof[$i] if ($wdof[$i] < $wdof_min);
                                  $wdof_max = $wdof[$i] if ($wdof[$i] > $wdof_max);
                              }
                              if ($wdof_min != 9.E6 && $wdof_max != -9.E6) {
                                  if ($wdof_min == $wdof_max) {
                                      $wdof_msg = " [Outflow frequency is " . $wdof_min;
                                  } else {
                                      $wdof_msg = " [Outflow frequency range: "
                                                . $wdof_min . " - " . $wdof_max;
                                  }
                                  $wdof_msg .= ($wdof_max > 1.0) ? " days.]" : " day.]";
                              } else {
                                  $wdof_msg = " [Outflow frequency: na]";
                              }
                              if ($jd_skip_active) {
                                  $jd_skip = 0 if ($jd_skip < 0 || $jd_skip > 49);
                                  $jd_skip_explain = $jd_skip_opts[$jd_skip];
                                  $jd_skip_label->g_grid();
                                  $jd_skip_frame->g_grid();
                              } else {
                                  $jd_skip_label->g_grid_remove();
                                  $jd_skip_frame->g_grid_remove();
                              }
                              $ok_btn->configure(-state => 'disabled');
                            }
            )->g_grid(-row => $row, -column => 4, -sticky => 'ew', -padx => 2, -pady => 2);

    $row++;
    $f->new_label(
            -text => "W2 QLayers File: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$qla_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);
    ($qla_file_btn = $f->new_button(
            -text    => "Browse",
            -state   => 'disabled',
            -command => sub { my ($file, $ftype, $jb, $jw, $wb_txt, @parms);
                              $file = Tkx::tk___getOpenFile(
                                      -parent           => $w2outflow_setup_menu,
                                      -title            => "Select QLayers File",
                                    # -initialdir       => abs_path(),
                                      -filetypes => [ ['All Files', '*'],
                                                      ['W2 Output Files', '.opt'],
                                                      ['CSV (comma delimited)', '.csv'],
                                                    ],
                                      );
                              if (defined($file) && -e $file) {
                                  $qla_file = File::Spec->rel2abs($file);
                                  ($ftype, $qla_lines, @parms)
                                      = &determine_ts_type($w2outflow_setup_menu, $qla_file, 1);
                                  if ($ftype ne "W2 Layer Outflow CSV format") {
                                      $qla_file = "";
                                      $ok_btn->configure(-state => 'disabled');
                                      return &pop_up_error($w2outflow_setup_menu,
                                        "The specified file is not a W2 Layer Outflow file:\n$file");
                                  }
                                  ($segnum = $parms[0]) =~ s/^Total Outflow, segment (\d+)/$1/;
                                  $wb_txt = "";
                                  for ($jw=1; $jw<=$nwb; $jw++) {
                                      for ($jb=$bs[$jw]; $jb<=$be[$jw]; $jb++) {
                                          if ($segnum >= $us[$jb] && $segnum <= $ds[$jb]) {
                                              $wb_txt = " (waterbody $jw, branch $jb)";
                                              last;
                                          }
                                      }
                                      last if ($wb_txt ne "");
                                  }
                                  $segnum_txt = sprintf("%d", $segnum) . $wb_txt;
                                  if ($bth_file ne "" && -e $bth_file) {
                                      $ok_btn->configure(-state => 'normal');
                                  }
                              } else {
                                  $ok_btn->configure(-state => 'disabled');
                              }
                            },
            ))->g_grid(-row => $row, -column => 4, -sticky => 'ew', -padx => 2, -pady => 2);

    $row++;
    $f->new_label(
            -text => "W2 Bathymetry File: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$bth_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);
    ($bth_file_btn = $f->new_button(
            -text    => "Browse",
            -state   => 'disabled',
            -command => sub { my ($file);
                              $file = Tkx::tk___getOpenFile(
                                      -parent           => $w2outflow_setup_menu,
                                      -title            => "Select W2 Bathymetry File",
                                    # -initialdir       => abs_path(),
                                      -defaultextension => ".csv",
                                      -filetypes => [ ['CSV (comma delimited)', '.csv'],
                                                      ['NPT (W2 input file)', '.npt'],
                                                      ['All Files',  '*'],
                                                    ],
                                      );
                              if (defined($file) && -e $file) {
                                  $bth_file = File::Spec->rel2abs($file);
                                  if ($qla_file ne "" && -e $qla_file) {
                                      $ok_btn->configure(-state => 'normal');
                                  }
                              } else {
                                  $ok_btn->configure(-state => 'disabled');
                              }
                            },
            ))->g_grid(-row => $row, -column => 4, -sticky => 'ew', -padx => 2, -pady => 2);

    $row++;
    $f->new_label(
            -text => "Segment: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$segnum_txt,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Base Year: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($byear_cb = $f->new_ttk__combobox(
            -textvariable => \$byear,
            -values       => [ reverse($yr_min .. $yr_max) ],
            -state        => 'disabled',
            -width        => 5,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $byear_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($byear == $yr_min) {
                                $yr_min -= 10;
                                $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                            }
                          });
    $f->new_label(
            -text   => " for JDAY = 1.0",
            -anchor => 'w',
            -font   => 'default',
            )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Time Offset: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($offset_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    $offset_frame->new_ttk__combobox(
            -textvariable => \$tz_offset,
            -values       => [ @tz_offsets ],
            -justify      => 'right',
            -state        => 'readonly',
            -width        => 6,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $offset_frame->new_label(
            -text   => " time zone adjustment ",
            -anchor => 'w',
            -font   => 'default',
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $offset_frame->new_button(
            -text    => "Help",
            -command => sub { &pop_up_info($w2outflow_setup_menu,
                                    "The time offset allows the user to add or subtract a time\n"
                                  . "offset if the W2 model was run with a non-local time zone.\n\n"
                                  . "For example, if W2 was run in UTC but the local time zone\n"
                                  . "is PST, an offset of -08:00 would convert the model date/time\n"
                                  . "to a local standard time of PST. This offset does not make\n"
                                  . "any adjustments related to daylight saving time. In general,\n"
                                  . "W2 is best run in the local standard time.\n\n"
                                  . "Leave the time offset at +00:00 for no adjustment.",
                                    "Time Offset Notice");
                            },
            )->g_pack(-side => 'left', -anchor => 'w', -padx => 2);

    $row++;
    $f->new_label(
            -text => "Release Rate Units: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($qaxis_units_cb = $f->new_ttk__combobox(
            -textvariable => \$qaxis_units,
            -values       => [ ("cfs/ft", "cms/m", "ft/s", "m/s") ],
            -state        => 'readonly',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $qaxis_units_cb->g_bind("<<ComboboxSelected>>",
                             sub { if ($qaxis_units eq "cfs/ft") {
                                       $title = "Release Rate, in cfs/(vert. ft)";
                                   } elsif ($qaxis_units eq "cms/m") {
                                       $title = "Release Rate, in cms/(vert. m)";
                                   } elsif ($qaxis_units eq "ft/s") {
                                       $title = "Velocity, in ft/s";
                                   } else {
                                       $title = "Velocity, in m/s";
                                   }
                                 });

    $row++;
    $f->new_label(
            -text => "X Axis Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$title,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "X Axis Max: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($xmax_entry = $f->new_entry(
            -textvariable => \$xmax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $xmax_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($xmax_entry);
                                              $xmax =~ s/^-//;
                                            });

    $row++;
    $f->new_label(
            -text => "X Axis Major: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($xmajor_entry = $f->new_entry(
            -textvariable => \$xmajor,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $xmajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($xmajor_entry, 1);
                                                $xmajor =~ s/^-//;
                                              });

    $row++;
    $f->new_label(
            -text => "Y Axis Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($yaxis_type_cb = $f->new_ttk__combobox(
            -textvariable => \$yaxis_type,
            -values       => [ ("Elevation", "Depth") ],
            -state        => 'readonly',
            -width        => 10,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $yaxis_type_cb->g_bind("<<ComboboxSelected>>",
                           sub { if ($yaxis_type eq "Elevation") {
                                     $ymin_label->g_grid();
                                     $ymin_entry->g_grid();
                                     $ymin_units_label->g_grid();
                                     $ymax_label->configure(-text => "Elevation Max: ");
                                     $ymajor_label->configure(-text => "Elevation Major: ");
                                     $yaxis_units_label->configure(-text => "Elevation Units: ");
                                     if ($elev_base != -999 && $ymax ne "") {
                                         $ymin  = $elev_base;
                                         $ymax += $elev_base;
                                     } else {
                                         $ymin = "";
                                     }
                                 } else {
                                     $ymin_label->g_grid_remove();
                                     $ymin_entry->g_grid_remove();
                                     $ymin_units_label->g_grid_remove();
                                     $ymax_label->configure(-text => "Depth Max: ");
                                     $ymajor_label->configure(-text => "Depth Major: ");
                                     $yaxis_units_label->configure(-text => "Depth Units: ");
                                     if ($ymax ne "" && $ymin ne "" && $ymax -$ymin != 0) {
                                         $elev_base = &min($ymin, $ymax);
                                         $ymax      = abs($ymax -$ymin);
                                     } else {
                                         $ymax = "";
                                     }
                                     $ymin = 0;
                                 }
                               }
                          );

    $row++;
    ($ymin_label = $f->new_label(
            -text => "Elevation Min: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ymin_entry = $f->new_entry(
            -textvariable => \$ymin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $ymin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $ymin_entry ]);
    ($ymin_units_label = $f->new_label(
            -textvariable => \$yaxis_units,
            -font         => 'default',
            -anchor       => 'w',
            ))->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    ($ymax_label = $f->new_label(
            -text => "Elevation Max: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ymax_entry = $f->new_entry(
            -textvariable => \$ymax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $ymax_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($ymax_entry);
                                              $ymax =~ s/^-// if ($yaxis_type eq "Depth");
                                            });
    $f->new_label(
            -textvariable => \$yaxis_units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    ($ymajor_label = $f->new_label(
            -text => "Elevation Major: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ymajor_entry = $f->new_entry(
            -textvariable => \$ymajor,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $ymajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($ymajor_entry, 1);
                                                $ymajor =~ s/^-//;
                                              });
    $f->new_label(
            -textvariable => \$yaxis_units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    ($yaxis_units_label = $f->new_label(
            -text => "Elevation Units: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_ttk__combobox(
            -textvariable => \$yaxis_units,
            -values       => [ ("feet", "meters") ],
            -state        => 'readonly',
            -width        => 7,
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    ($jd_skip_label = $f->new_label(
            -text => "Skip Dates: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($jd_skip_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    $jd_skip_frame->new_spinbox(
            -textvariable => \$jd_skip,
            -state        => 'readonly',
            -font         => 'default',
            -from         => 0,
            -to           => 49,
            -increment    => 1,
            -width        => 4,
            -command      => sub { $jd_skip_explain = $jd_skip_opts[$jd_skip]; },
            )->g_pack(-side => 'left', -anchor => 'w');
    $jd_skip_frame->new_label(
            -textvariable => \$jd_skip_explain,
            -font         => 'default',
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $jd_skip_frame->new_label(
            -textvariable => \$wdof_msg,
            -font         => 'default',
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $jd_skip_label->g_grid_remove();
    $jd_skip_frame->g_grid_remove();

    $row++;
    $f->new_label(
            -text => "Graph Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_ttk__combobox(
            -textvariable => \$gr_type,
            -values       => [ ("Release Rates Only", "With Parameter Color Scheme") ],
            -state        => 'readonly',
            -width        => 28,
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Graph Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gtitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'ew', -pady => 2);

    $f->g_grid_columnconfigure(3, -weight => 2);

    Tkx::wm_resizable($w2outflow_setup_menu,0,0);
    &adjust_window_position($w2outflow_setup_menu);
    $w2outflow_setup_menu->g_focus;
}


sub setup_w2_outflow_part2 {
    my ($canv, $id, $X, $Y, $graph_exists) = @_;
    my (
        $conv_add, $conv_add_entry, $conv_mult, $conv_mult_entry, $conv_type,
        $conv_type_cb, $conv_type_na_label, $cpl_msg, $cplf_max, $cplf_min,
        $cscheme, $cscheme_cb, $custom_frame, $f, $frame, $ftype, $geom,
        $i, $imx, $jb, $jd_skip, $jd_skip_active, $jd_skip_explain,
        $jd_skip_frame, $jd_skip_parm, $jd_skip_parm_active,
        $jd_skip_parm_explain, $jd_skip_parm_frame, $jd_skip_parm_label,
        $jw, $lcon_freq, $lcon_msg, $meta, $msg_label, $n, $ncolors,
        $ncolors_cb, $nwb, $ok, $ok_btn, $old_units, $oldparm,
        $oldparm_short, $oldsrc_type, $parm, $parm_cb, $parm_chars,
        $parm_div, $parm_div_cb, $parm_div_label, $parm_frame, $parm_short,
        $parms_ref, $pmax, $pmax_entry, $pmin, $pmin_entry, $ptitle, $row,
        $segnum, $segnum_txt, $spr_msg, $sprf_max, $sprf_min, $src_file,
        $src_file_btn, $src_file_label, $src_lines, $src_parm, $src_type,
        $src_type_cb, $tecplot, $tol, $tol_frame, $units, $units_cb,
        $units_entry, $vplf_max, $vplf_min, $vpl_msg, $wb_txt, $wdo_msg,
        $wdof_max, $wdof_min,

        @be, @bs, @cmaps, @cplf, @ds, @jd_skip_opts, @ncpl, @nspr, @nvpl,
        @parm_divlist, @parmlist, @slope, @sprf, @us, @vplf, @wdof,

        %parms,
       );

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($w2outflow_setup_menu) && Tkx::winfo_exists($w2outflow_setup_menu)) {
        if ($w2outflow_setup_menu->g_wm_title() eq "W2 Layer Outflows Setup") {
            $w2outflow_setup_menu->g_destroy();
            undef $w2outflow_setup_menu;
        }
    }
    $w2outflow_setup_menu = $main->new_toplevel();
    $w2outflow_setup_menu->g_wm_transient($main);
    $w2outflow_setup_menu->g_wm_title("W2 Layer Outflows Setup");
    $w2outflow_setup_menu->configure(-cursor => $cursor_norm);
    $w2outflow_setup_menu->g_wm_geometry($geom);

#   Try to keep the nascent graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

#   De-select graph if it already exists
    if (defined($props{$id}{old_jd_skip})) {
        &end_select($canv, $id, 1);
    }

#   If the graph exists, ensure that the parms entry to the properties hash exists.
    if ($graph_exists) {
        %parms             = ();
        $parms{xmax}       = $gr_props{$id}{xmax};
        $parms{xmajor}     = $gr_props{$id}{xmajor};
        $parms{qunits}     = $gr_props{$id}{qunits};
        $parms{ymin}       = $gr_props{$id}{ymin};
        $parms{ymax}       = $gr_props{$id}{ymax};
        $parms{ymajor}     = $gr_props{$id}{ymajor};
        $parms{ytype}      = $gr_props{$id}{ytype};
        $parms{yunits}     = $gr_props{$id}{yunits};
        $parms{gtitle}     = $gr_props{$id}{gtitle};
        $props{$id}{parms} = { %parms };
        undef %parms;
    }

#   If this routine was called to change the color-display parameter
    if ($graph_exists && defined($props{$id}{src_type})) {
        $src_type      = $props{$id}{src_type};
        $src_file      = $props{$id}{src_file};
        $src_lines     = ($src_type =~ /Vector/i) ? 0 : $props{$id}{src_lines};
        $tecplot       = ($src_type =~ /Contour/i) ? $props{$id}{tplot} : 0;
        $parm          = $props{$id}{parm};
        $parm_div      = $props{$id}{parm_div};
        $units         = $props{$id}{parm_units};
        $conv_type     = $props{$id}{parm_ctype};
        $jd_skip_parm  = $props{$id}{parm_skip};
        $tol           = $props{$id}{match_tol};

        $pmin          = $gr_props{$id}{cs_min};
        $pmax          = $gr_props{$id}{cs_max};
        $ncolors       = $gr_props{$id}{ncolors};
        if ($gr_props{$id}{cscheme1} =~ /CoolWarm|Turbo|Viridis/) {
            $cscheme   = $gr_props{$id}{cscheme1};
            $ncolors   = &max(8, &min(100, $ncolors));
        } elsif ($gr_props{$id}{cscheme1} eq "Blue" && $gr_props{$id}{cscheme2} eq "Orange") {
            $cscheme   = "Blue to Orange";
            $ncolors  *= 2;
            $ncolors   = &max(16, &min(46, $ncolors));
            foreach $n (reverse @valid_nc) {
                if ($ncolors >= 2 *$n) {
                    $ncolors = 2 *$n;
                    last;
                }
            }
        } elsif ($gr_props{$id}{cscheme1} eq "Blue" && $gr_props{$id}{cscheme2} eq "Red") {
            $cscheme   = "Blue to Red";
            $ncolors  *= 2;
            $ncolors   = &max(16, &min(46, $ncolors));
            foreach $n (reverse @valid_nc) {
                if ($ncolors >= 2 *$n) {
                    $ncolors = 2 *$n;
                    last;
                }
            }
        } else {
            $cscheme = "Blue to Orange";
            $ncolors = 20;
        }
        if ($conv_type =~ /Custom/) {
            ($conv_type, $conv_mult, $conv_add) = split(/,/, $conv_type);
        } else {
            $conv_mult = 1.0;
            $conv_add  = 0.0;
        }
        if ($src_type =~ /Spreadsheet/i) {
            ($ok, undef, undef, $parms_ref)
                      = &scan_w2_spr_file($w2outflow_setup_menu, $src_file, "");
            @parmlist = @{ $parms_ref };

        } elsif ($src_type =~ /Contour/i) {
            ($tecplot, undef, $jw, $parms_ref, undef, undef)
                      = &scan_w2_cpl_file($w2outflow_setup_menu, $src_file, $id, 0, "");
            @parmlist = @{ $parms_ref };

        } elsif ($src_type =~ /Vector/i) {
            ($ok, $parms_ref, undef, undef, undef)
                      = &scan_w2_vector_file($w2outflow_setup_menu, $src_file, $id, 0);
            @parmlist = @{ $parms_ref };

        } elsif ($src_type =~ /LakeCon/i) {
            ($ftype, $src_parm, $meta, undef)
                      = &scan_w2_rlcon_file($w2outflow_setup_menu, $src_file, "");
            @parmlist = ($src_parm);
            (undef, $lcon_freq) = split(/_/, $meta);
            if ($lcon_freq < 1.0 && length($lcon_freq) > 6) {
                $lcon_freq = sprintf("%0.4f", $lcon_freq);
            }
        }
        $lcon_freq  = "" if ($src_type !~ /LakeCon/i);
        $parm_chars = length($parmlist[0]);
        for ($i=1; $i<=$#parmlist; $i++) {
            $parm_chars = &max($parm_chars, length($parmlist[$i]));
        }
        $parm_chars += 2;
        if (&list_match($parm, @parmlist) == -1) {
            $parm  = $parmlist[0];
            $parm  =~ s/^\s+//;
            $parm  =~ s/\s+$//;
            $units = "";
        }
        $parm_short = $parm;
        if ($parm eq "Temperature") {
            $units  = "Celsius" if ($units !~ /(Celsius|Fahrenheit)/);
            $ptitle = "Temperature, in degrees " . $units;
        } else {
            $parm_short =~ s/\(ms-1\)//i;
            $parm_short =~ s/\(m3s-1\)//i;
            $parm_short =~ s/ [kmu]?g\/L\/day//i;
            $parm_short =~ s/ [kmu]?g\/m2\/day//i;
            $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
            $parm_short =~ s/ [kmu]?g\/L//i;
            $parm_short =~ s/ [kmu]?g\/m3//i;
            $parm_short =~ s/ [kmu]?g\/m\^3//i;
            $parm_short =~ s/, days//i;
            $parm_short =~ s/ days//i;
            $parm_short =~ s/,$//;
            $ptitle = $parm_short . ", in " . $units;
        }
        @parm_divlist = ("None");
        for ($i=0; $i<=$#parmlist; $i++) {
            if ($parm ne $parmlist[$i]) {
                push (@parm_divlist, $parmlist[$i]);
            }
        }

#   Otherwise, fall back on some defaults
    } else {
        $src_file = $src_type = $pmin = $pmax = $ptitle = "";
        $src_lines       = 0;
        $tecplot         = 0;
        $parm            = "Unknown";
        $parm_short      = $parm;
        @parmlist        = ();
        $parmlist[0]     = $parm;
        $parm_chars      = length($parm) +2;
        $parm_div        = "None";
        @parm_divlist    = ();
        $parm_divlist[0] = $parm_div;
        $units           = "";
        $cscheme         = "Blue to Orange";
        $ncolors         = 20;
        $tol             = 10;
        $conv_type       = $conv_types[0];
        $conv_mult       = 1.0;
        $conv_add        = 0.0;
        $lcon_freq       = "";
        $jd_skip_parm    = 0;
    }
    $oldsrc_type   = $src_type;
    $oldparm       = $parm;
    $oldparm_short = $parm_short;
    $old_units     = $units;

    $nwb   = $grid{$id}{nwb};
    $imx   = $grid{$id}{imx};
    @bs    = @{ $grid{$id}{bs}    };
    @be    = @{ $grid{$id}{be}    };
    @us    = @{ $grid{$id}{us}    };
    @ds    = @{ $grid{$id}{ds}    };
    @slope = @{ $grid{$id}{slope} };
    @nspr  = @{ $grid{$id}{nspr}  };
    @sprf  = @{ $grid{$id}{sprf}  };
    @ncpl  = @{ $grid{$id}{ncpl}  };
    @cplf  = @{ $grid{$id}{cplf}  };
    @nvpl  = @{ $grid{$id}{nvpl}  };
    @vplf  = @{ $grid{$id}{vplf}  };
    @wdof  = @{ $grid{$id}{wdof}  };

    $segnum = $props{$id}{seg};
    $wb_txt = "";
    for ($jw=1; $jw<=$nwb; $jw++) {
        for ($jb=$bs[$jw]; $jb<=$be[$jw]; $jb++) {
            if ($segnum >= $us[$jb] && $segnum <= $ds[$jb]) {
                $wb_txt = " (waterbody $jw, branch $jb)";
                last;
            }
        }
        last if ($wb_txt ne "");
    }
    $segnum_txt = sprintf("%d", $segnum) . $wb_txt;

    $jd_skip_active = $jd_skip_parm_active = 0;
    $jd_skip = $props{$id}{jd_skip};
    $jd_skip = 0 if ($jd_skip < 0 || $jd_skip > 49);
    for ($i=1; $i<=$#wdof; $i++) {
        next if ($wdof[$i] eq "na");
        if ($wdof[$i] < 1.0) {
            $jd_skip_active = 1;
            last;
        }
    }
    @jd_skip_opts = ("(keep all)", "(keep every other)", "(keep every 3rd)", "(keep every 4th)",
                     "(keep every 5th)",  "(keep every 6th)",  "(keep every 7th)",  "(keep every 8th)",
                     "(keep every 9th)",  "(keep every 10th)", "(keep every 11th)", "(keep every 12th)",
                     "(keep every 13th)", "(keep every 14th)", "(keep every 15th)", "(keep every 16th)",
                     "(keep every 17th)", "(keep every 18th)", "(keep every 19th)", "(keep every 20th)",
                     "(keep every 21st)", "(keep every 22nd)", "(keep every 23rd)", "(keep every 24th)",
                     "(keep every 25th)", "(keep every 26th)", "(keep every 27th)", "(keep every 28th)",
                     "(keep every 29th)", "(keep every 30th)", "(keep every 31st)", "(keep every 32nd)",
                     "(keep every 33rd)", "(keep every 34th)", "(keep every 35st)", "(keep every 36th)",
                     "(keep every 37th)", "(keep every 38th)", "(keep every 39th)", "(keep every 40th)",
                     "(keep every 41st)", "(keep every 42nd)", "(keep every 43rd)", "(keep every 44th)",
                     "(keep every 45th)", "(keep every 46th)", "(keep every 47th)", "(keep every 48th)",
                     "(keep every 49th)", "(keep every 50th)");
    $jd_skip_explain = $jd_skip_opts[$jd_skip];

    $wdof_min = $sprf_min = $cplf_min = $vplf_min =  9.E6;
    $wdof_max = $sprf_max = $cplf_max = $vplf_max = -9.E6;
    for ($i=1; $i<=$#wdof; $i++) {
        next if ($wdof[$i] eq "na");
        $wdof_min = $wdof[$i] if ($wdof[$i] < $wdof_min);
        $wdof_max = $wdof[$i] if ($wdof[$i] > $wdof_max);
    }
    if ($wdof_min != 9.E6 && $wdof_max != -9.E6) {
        if ($wdof_min == $wdof_max) {
            $wdo_msg = "Outflow frequency is " . $wdof_min;
        } else {
            $wdo_msg = "Outflow frequency range: " . $wdof_min . " - " . $wdof_max;
        }
        $wdo_msg .= ($wdof_max > 1.0) ? " days." : " day.";
    } else {
        $wdo_msg = "Outflow frequency: na";
    }

    for ($i=1; $i<=$nspr[$jw]; $i++) {
        next if ($sprf[$i][$jw] eq "na");
        $sprf_min = $sprf[$i][$jw] if ($sprf[$i][$jw] < $sprf_min);
        $sprf_max = $sprf[$i][$jw] if ($sprf[$i][$jw] > $sprf_max);
    }
    if ($sprf_min != 9.E6 && $sprf_max != -9.E6) {
        if ($sprf_min == $sprf_max) {
            $spr_msg = "Spreadsheet frequency is " . $sprf_min;
        } else {
            $spr_msg = "Spreadsheet frequency range: " . $sprf_min . " - " . $sprf_max;
        }
        $spr_msg .= ($sprf_max > 1.0) ? " days." : " day.";
    } else {
        $spr_msg = "Spreadsheet frequency: na";
    }

    for ($i=1; $i<=$ncpl[$jw]; $i++) {
        next if ($cplf[$i][$jw] eq "na");
        $cplf_min = $cplf[$i][$jw] if ($cplf[$i][$jw] < $cplf_min);
        $cplf_max = $cplf[$i][$jw] if ($cplf[$i][$jw] > $cplf_max);
    }
    if ($cplf_min != 9.E6 && $cplf_max != -9.E6) {
        if ($cplf_min == $cplf_max) {
            $cpl_msg = "Contour frequency is " . $cplf_min;
        } else {
            $cpl_msg = "Contour frequency range: " . $cplf_min . " - " . $cplf_max;
        }
        $cpl_msg .= ($cplf_max > 1.0) ? " days." : " day.";
    } else {
        $cpl_msg = "Contour frequency: na";
    }

    for ($i=1; $i<=$nvpl[$jw]; $i++) {
        next if ($vplf[$i][$jw] eq "na");
        $vplf_min = $vplf[$i][$jw] if ($vplf[$i][$jw] < $vplf_min);
        $vplf_max = $vplf[$i][$jw] if ($vplf[$i][$jw] > $vplf_max);
    }
    if ($vplf_min != 9.E6 && $vplf_max != -9.E6) {
        if ($vplf_min == $vplf_max) {
            $vpl_msg = "Vector frequency is " . $vplf_min;
        } else {
            $vpl_msg = "Vector frequency range: " . $vplf_min . " - " . $vplf_max;
        }
        $vpl_msg .= ($vplf_max > 1.0) ? " days." : " day.";
    } else {
        $vpl_msg = "Vector frequency: na";
    }

    if ($lcon_freq eq "") {
        $lcon_msg = "Lake Contour frequency is unknown.";
    } else {
        $lcon_msg = "Lake Contour frequency is " . $lcon_freq . " day.";
    }

    if ($src_type =~ /Spreadsheet/i) {
        $jd_skip_parm_active = 1 if ($sprf_min < 1.0);
    } elsif ($src_type =~ /Contour/i) {
        $jd_skip_parm_active = 1 if ($cplf_min < 1.0);
    } elsif ($src_type =~ /Vector/i) {
        $jd_skip_parm_active = 1 if ($vplf_min < 1.0);
    } elsif ($src_type =~ /LakeCon/i) {
        $jd_skip_parm_active = 1 if ($lcon_freq ne "" && $lcon_freq < 1.0);
    }
    $jd_skip_parm_explain = $jd_skip_opts[$jd_skip_parm];

#   Available initial colormaps
    @cmaps = ("Blue to Orange", "Blue to Red", "CoolWarm", "Turbo", "Viridis");

#   Set up the menu
    $frame = $w2outflow_setup_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -state   => 'disabled',
            -command => sub { my ($confirm_type, %parms);
                              if ($src_type =~ /Spreadsheet/i) {
                                  if ($src_file eq "" || ! -e $src_file) {
                                      return &pop_up_error($w2outflow_setup_menu,
                                      "W2 Spreadsheet file not set or does not exist:\n$src_file");
                                  }
                              } elsif ($src_type =~ /Contour/i) {
                                  if ($src_file eq "" || ! -e $src_file) {
                                      return &pop_up_error($w2outflow_setup_menu,
                                      "W2 Contour file not set or does not exist:\n$src_file");
                                  }
                              } elsif ($src_type =~ /Vector/i) {
                                  if ($src_file eq "" || ! -e $src_file) {
                                      return &pop_up_error($w2outflow_setup_menu,
                                      "W2 Vector file not set or does not exist:\n$src_file");
                                  }
                              } elsif ($src_type =~ /LakeCon/i) {
                                  if ($src_file eq "" || ! -e $src_file) {
                                      return &pop_up_error($w2outflow_setup_menu,
                                      "W2 Lake Contour file not set or does not exist:\n$src_file");
                                  }
                              }
                              $confirm_type = &confirm_w2_ftype($w2outflow_setup_menu, $src_file);
                              if ($src_type =~ /Spreadsheet/i && $confirm_type ne "spr") {
                                  return &pop_up_error($w2outflow_setup_menu,
                                      "The W2 source file is not a W2 Spreadsheet file:\n$src_file");
                              } elsif ($src_type =~ /Contour/i && $confirm_type ne "cpl") {
                                  return &pop_up_error($w2outflow_setup_menu,
                                      "The W2 source file is not a W2 Contour file:\n$src_file");
                              } elsif ($src_type =~ /Vector/i && $confirm_type ne "w2l") {
                                  return &pop_up_error($w2outflow_setup_menu,
                                      "The W2 source file is not a W2 Vector (w2l) file:\n$src_file");
                              } elsif ($src_type =~ /LakeCon/i && $confirm_type ne "lcon1") {
                                  return &pop_up_error($w2outflow_setup_menu,
                                      "The W2 source file is not an acceptable\n"
                                    . "W2 Lake Contour (format 1) file:\n$src_file");
                              }
                              if ($pmin eq "" || $pmax eq "") {
                                  return &pop_up_error($w2outflow_setup_menu,
                                  "Please provide both a min and max for your parameter.");
                              }
                              if ($pmin >= $pmax) {
                                  return &pop_up_error($w2outflow_setup_menu,
                                      "The minimum parameter value must be\n"
                                    . "less than the maximum parameter value.");
                              }
                              if ($conv_type eq "Custom") {
                                  $conv_type = sprintf("Custom,%s,%s", $conv_mult, $conv_add);
                              }

                              %parms             = %{ $props{$id}{parms} };
                              $parms{pmin}       = $pmin;
                              $parms{pmax}       = $pmax;
                              $parms{cscheme}    = $cscheme;
                              $parms{ncolors}    = $ncolors;
                              $props{$id}{parms} = { %parms };

                              $props{$id}{data}       = 0;
                              $props{$id}{add_parm}   = 1;
                              $props{$id}{src_type}   = $src_type;
                              $props{$id}{src_file}   = $src_file;
                              $props{$id}{src_lines}  = $src_lines;
                              $props{$id}{tplot}      = $tecplot;
                              $props{$id}{parm}       = $parm;
                              $props{$id}{parm_div}   = $parm_div;
                              $props{$id}{parm_units} = $units;
                              $props{$id}{parm_ctype} = $conv_type;
                              $props{$id}{jd_skip}    = $jd_skip;
                              $props{$id}{parm_skip}  = $jd_skip_parm;
                              $props{$id}{match_tol}  = $tol;

                              $w2outflow_setup_menu->g_bind('<Destroy>', "");
                              $w2outflow_setup_menu->g_destroy();
                              undef $w2outflow_setup_menu;
                              &reset_bindings;

                              &make_w2_outflow($canv, $id, 0);
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $w2outflow_setup_menu->g_bind('<Destroy>', "");
                              $w2outflow_setup_menu->g_destroy();
                              undef $w2outflow_setup_menu;
                              if (! $graph_exists) {
                                  $canv->delete("graph" . $id);
                                  delete $props{$id};
                                  delete $grid{$id} if (defined($grid{$id}));
                              }
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Delete graph if this menu is destroyed by other than the Cancel button
    $w2outflow_setup_menu->g_bind('<Destroy>' => sub { undef $w2outflow_setup_menu;
                                                       if (! $graph_exists) {
                                                           $canv->delete("graph" . $id);
                                                           delete $props{$id}; 
                                                           delete $grid{$id} if (defined($grid{$id}));
                                                       }
                                                       &reset_bindings;
                                                     });

    $f = $w2outflow_setup_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "Please provide profile data from a W2 Spreadsheet, "
                     . "Contour, Vector, or Lake Contour file.",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -columnspan => 5, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Segment: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -text => $segnum_txt,
            -font => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "W2 Source Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($src_type_cb = $f->new_ttk__combobox(
            -textvariable => \$src_type,
            -values       => [ ("W2 Spreadsheet File", "W2 Contour File",
                                "W2 Vector File", "W2 LakeCon File") ],
            -state        => 'readonly',
            -width        => 20,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w', -pady => 2);
    $src_type_cb->g_bind("<<ComboboxSelected>>",
                          sub { return if ($src_type eq $oldsrc_type);
                                $oldsrc_type     = $src_type;
                                $src_file        = $ptitle = $units = $old_units = "";
                                $parm            = "Unknown";
                                $oldparm         = $parm;
                                $parm_short      = $parm;
                                $oldparm_short   = $parm;
                                @parmlist        = ();
                                $parmlist[0]     = $parm;
                                $parm_chars      = length($parm) +2;
                                $parm_div        = "None";
                                @parm_divlist    = ();
                                $parm_divlist[0] = $parm_div;
                                $parm_cb->configure(-values => [ @parmlist ],
                                                    -width  => $parm_chars);
                                $parm_div_cb->configure(-values => [ @parm_divlist ],
                                                        -width  => $parm_chars);
                                $units_cb->g_grid_remove();
                                $units_entry->g_grid();
                                $conv_type_na_label->g_grid_remove();
                                $custom_frame->g_grid() if ($conv_type eq "Custom");
                                $conv_type_cb->g_grid();
                                $ok_btn->configure(-state => 'disabled');

                                if ($src_type =~ /Spreadsheet|Contour|Vector|LakeCon/i) {
                                    $src_file_label->configure(-text => $src_type . ": ");
                                    $src_file_btn->configure(-state => 'normal');
                                    if ($slope[$jb] > 0.0) {
                                        if ($src_type =~ /Spreadsheet/i) {
                                            return &pop_up_info($w2outflow_setup_menu,
                                                    "Branch $jb has a nonzero slope.\n"
                                                  . "W2 spreadsheet outputs may not\n"
                                                  . "work well for nonzero branch slopes.\n"
                                                  . "Consider using the W2 Contour File\n"
                                                  . "or W2 Vector File output option.");
                                        } elsif ($src_type =~ /LakeCon/i) {
                                            return &pop_up_info($w2outflow_setup_menu,
                                                    "Branch $jb has a nonzero slope.\n"
                                                  . "W2 Lake Contour outputs may not\n"
                                                  . "work well for nonzero branch slopes.\n"
                                                  . "Consider using the W2 Contour File\n"
                                                  . "or W2 Vector File output option.");
                                        }
                                    }
                                } else {
                                    $src_file_label->configure(-text => "W2 Output File: ");
                                    $src_file_btn->configure(-state => 'disabled');
                                }
                                $jd_skip_parm_active = 0;
                                if ($src_type =~ /Spreadsheet/i) {
                                    $jd_skip_parm_active = 1 if ($sprf_min < 1.0);
                                } elsif ($src_type =~ /Contour/i) {
                                    $jd_skip_parm_active = 1 if ($cplf_min < 1.0);
                                } elsif ($src_type =~ /Vector/i) {
                                    $jd_skip_parm_active = 1 if ($vplf_min < 1.0);
                                } elsif ($src_type =~ /LakeCon/i) {
                                    $jd_skip_parm_active = 1;  # placeholder
                                }
                                if ($jd_skip_parm_active) {
                                    $jd_skip_parm_explain = $jd_skip_opts[$jd_skip_parm];
                                    $jd_skip_parm_label->g_grid();
                                    $jd_skip_parm_frame->g_grid();
                                    $msg_label->g_grid();
                                } else {
                                    $jd_skip_parm_label->g_grid_remove();
                                    $jd_skip_parm_frame->g_grid_remove();
                                    if ($jd_skip_active) {
                                        $msg_label->g_grid();
                                    } else {
                                        $msg_label->g_grid_remove();
                                    }
                                }
                              });

    $row++;
    ($src_file_label = $f->new_label(
            -text => "W2 Output File: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$src_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);
    ($src_file_btn = $f->new_button(
            -text    => "Browse",
            -state   => 'disabled',
            -command => sub { my ($confirm_type, $file, $i, $jjb, $jw_check,
                                  $pbar, $pbar_img, $pbar_win, $seg, $segs_ref, @segs);
                              $file = Tkx::tk___getOpenFile(
                                      -parent           => $w2outflow_setup_menu,
                                      -title            => "Select $src_type",
                                    # -initialdir       => abs_path(),
                                      -filetypes => [ ['All Files',  '*'],
                                                      ['CSV (comma delimited)', '.csv'],
                                                      ['W2 Output Files', '.opt'],
                                                      ['W2 Vector Files', '.w2l'],
                                                    ],
                                      );
                              if (defined($file) && -e $file) {
                                  $src_file        = File::Spec->rel2abs($file);
                                  $ptitle          = $units = $old_units = "";
                                  $parm            = "Unknown";
                                  $oldparm         = $parm;
                                  $parm_short      = $parm;
                                  $oldparm_short   = $parm;
                                  @parmlist        = ();
                                  $parmlist[0]     = $parm;
                                  $parm_chars      = length($parm) +2;
                                  $parm_div        = "None";
                                  @parm_divlist    = ();
                                  $parm_divlist[0] = $parm_div;
                                  $parm_cb->configure(-values => [ @parmlist ],
                                                      -width  => $parm_chars);
                                  $parm_div_cb->configure(-values => [ @parm_divlist ],
                                                          -width  => $parm_chars);
                                  $units_cb->g_grid_remove();
                                  $units_entry->g_grid();
                                  $conv_type_na_label->g_grid_remove();
                                  $custom_frame->g_grid() if ($conv_type eq "Custom");
                                  $conv_type_cb->g_grid();

                                  $confirm_type = &confirm_w2_ftype($w2outflow_setup_menu, $src_file);
                                  if ($src_type =~ /Spreadsheet/i && $confirm_type ne "spr") {
                                      $src_file = "";
                                      $ok_btn->configure(-state => 'disabled');
                                      return &pop_up_error($w2outflow_setup_menu,
                                          "The specified file is not a W2 Spreadsheet file:\n$file");
                                  } elsif ($src_type =~ /Contour/i && $confirm_type ne "cpl") {
                                      $src_file = "";
                                      $ok_btn->configure(-state => 'disabled');
                                      return &pop_up_error($w2outflow_setup_menu,
                                          "The specified file is not a W2 Contour file:\n$file");
                                  } elsif ($src_type =~ /Vector/i && $confirm_type ne "w2l") {
                                      $src_file = "";
                                      $ok_btn->configure(-state => 'disabled');
                                      return &pop_up_error($w2outflow_setup_menu,
                                          "The specified file is not a W2 Vector (w2l) file:\n$file");
                                  } elsif ($src_type =~ /LakeCon/i && $confirm_type ne "lcon1") {
                                      return &pop_up_error($w2outflow_setup_menu,
                                          "The specified file is not an acceptable\n"
                                        . "W2 Lake Contour (format 1) file:\n$file");
                                  }
                                  if ($src_type =~ /Spreadsheet/i) {
                                      ($pbar_win, $pbar, $pbar_img)
                                          = &create_alt_progress_bar($main, $id,
                                                                     "Scanning W2 spreadsheet file...");
                                      ($ok, $src_lines, $segs_ref, $parms_ref)
                                          = &scan_w2_spr_file($w2outflow_setup_menu, $src_file, $pbar_img);
                                      &destroy_progress_bar($main, $pbar_win);

                                      if ($ok ne "okay") {
                                          $src_file = "";
                                          $ok_btn->configure(-state => 'disabled');
                                          return &pop_up_error($w2outflow_setup_menu,
                                              "The specified file is not a W2 Spreadsheet file:\n$file");
                                      }
                                      @parmlist = @{ $parms_ref };
                                      @segs     = @{ $segs_ref  };
                                      if (&list_match($segnum, @segs) == -1) {
                                          $src_file = "";
                                          $ok_btn->configure(-state => 'disabled');
                                          return &pop_up_error($w2outflow_setup_menu,
                                              "The specified W2 Spreadsheet file does not\n"
                                            . "contain data for segment $segnum:\n$file");
                                      }

                                  } elsif ($src_type =~ /Contour/i) {
                                      ($pbar_win, $pbar, $pbar_img)
                                          = &create_alt_progress_bar($main, $id,
                                                                     "Scanning W2 contour file...");
                                      ($tecplot, $src_lines, $jw_check, $parms_ref, undef, undef)
                                          = &scan_w2_cpl_file($w2outflow_setup_menu, $src_file,
                                                              $id, 0, $pbar_img);
                                      &destroy_progress_bar($main, $pbar_win);

                                      if ($tecplot == -1) {
                                          $src_file = "";
                                          $ok_btn->configure(-state => 'disabled');
                                          return &pop_up_error($w2outflow_setup_menu,
                                              "The specified file is not a W2 Contour output file:\n$file");
                                      }
                                      if ($tecplot == 0 && $jw_check != $jw) {
                                          $src_file = "";
                                          $ok_btn->configure(-state => 'disabled');
                                          return &pop_up_error($w2outflow_setup_menu,
                                              "The specified W2 Contour file is not\n"
                                            . "from the correct waterbody ($jw):\n$file");
                                      }
                                      @segs = ();
                                      for ($jjb=$bs[$jw]; $jjb<=$be[$jw]; $jjb++) {
                                          push (@segs, ($us[$jjb] .. $ds[$jjb]));
                                      }
                                      if (&list_match($segnum, @segs) == -1) {
                                          $src_file = "";
                                          $ok_btn->configure(-state => 'disabled');
                                          return &pop_up_error($w2outflow_setup_menu,
                                              "The specified W2 Contour file does not\n"
                                            . "contain data for segment $segnum:\n$file");
                                      }
                                      @parmlist = @{ $parms_ref };

                                  } elsif ($src_type =~ /Vector/i) {
                                      $status_line = "Scanning W2 vector file...";
                                      ($ok, $parms_ref, undef, undef, undef)
                                              = &scan_w2_vector_file($w2outflow_setup_menu,
                                                                     $src_file, $id, 0);
                                      $status_line = "";

                                      if ($ok ne "okay") {
                                          $src_file = "";
                                          $ok_btn->configure(-state => 'disabled');
                                          return &pop_up_error($w2outflow_setup_menu,
                                              "The specified file is not a W2 Vector (w2l) file:\n$file");
                                      }
                                      if ($segnum > $imx) {
                                          $src_file = "";
                                          $ok_btn->configure(-state => 'disabled');
                                          return &pop_up_error($w2outflow_setup_menu,
                                              "The specified W2 Vector file does not\n"
                                            . "contain data for segment $segnum:\n$file");
                                      }
                                      @parmlist = @{ $parms_ref };

                                  } elsif ($src_type =~ /LakeCon/i) {
                                      ($pbar_win, $pbar, $pbar_img)
                                          = &create_alt_progress_bar($main, $id,
                                                                     "Scanning W2 Lake Contour file...");
                                      ($ftype, $src_parm, $meta, $src_lines)
                                          = &scan_w2_rlcon_file($w2outflow_setup_menu, $src_file, $pbar_img);
                                      &destroy_progress_bar($main, $pbar_win);

                                      if ($ftype ne "lcon1") {
                                          $src_file = "";
                                          $ok_btn->configure(-state => 'disabled');
                                          return &pop_up_error($w2outflow_setup_menu,
                                              "The specified file is not an acceptable\n"
                                            . "W2 Lake Contour (format 1) file:\n$file");
                                      }
                                      @parmlist = ($src_parm);
                                      ($seg, $lcon_freq) = split(/_/, $meta);
                                      if ($seg != $segnum) {
                                          $src_file = "";
                                          $ok_btn->configure(-state => 'disabled');
                                          return &pop_up_error($w2outflow_setup_menu,
                                              "The specified W2 Lake Contour file does not\n"
                                            . "contain data for segment $segnum:\n$file");
                                      }
                                      if ($lcon_freq < 1.0 && length($lcon_freq) > 6) {
                                          $lcon_freq = sprintf("%0.4f", $lcon_freq);
                                      }
                                      $lcon_msg = "Lake Contour frequency is " . $lcon_freq . " day.";
                                      $msg_label->configure(-text => $wdo_msg . "\n" . $spr_msg . "\n"
                                                                   . $cpl_msg . "\n" . $vpl_msg . "\n"
                                                                   . $lcon_msg);
                                      $jd_skip_parm_active = ($lcon_freq < 1.0) ? 1 : 0;
                                      if ($jd_skip_parm_active) {
                                          $jd_skip_parm_explain = $jd_skip_opts[$jd_skip_parm];
                                          $jd_skip_parm_label->g_grid();
                                          $jd_skip_parm_frame->g_grid();
                                          $msg_label->g_grid();
                                      } else {
                                          $jd_skip_parm_label->g_grid_remove();
                                          $jd_skip_parm_frame->g_grid_remove();
                                          if ($jd_skip_active) {
                                              $msg_label->g_grid();
                                          } else {
                                              $msg_label->g_grid_remove();
                                          }
                                      }
                                  }
                                  $parm_chars = length($parmlist[0]);
                                  for ($i=1; $i<=$#parmlist; $i++) {
                                      $parm_chars = &max($parm_chars, length($parmlist[$i]));
                                  }
                                  $parm_chars += 2;
                                  $parm_cb->configure(-values => [ @parmlist ],
                                                      -width  => $parm_chars);
                                  if (&list_match($parm, @parmlist) == -1) {
                                      $parm = $parmlist[0];
                                      $parm =~ s/^\s+//;
                                      $parm =~ s/\s+$//;
                                  }
                                  $parm_short = $parm;
                                  if ($parm eq "Temperature") {
                                      $units  = "Celsius" if ($units !~ /(Celsius|Fahrenheit)/);
                                      $ptitle = "Temperature, in degrees " . $units;
                                      $units_cb->g_grid();
                                      $units_entry->g_grid_remove();
                                      $conv_type_na_label->g_grid();
                                      $custom_frame->g_grid_remove();
                                      $conv_type_cb->g_grid_remove();
                                      $conv_type = "None";
                                  } else {
                                      $units = "";
                                      $parm_short =~ s/\(ms-1\)//i;
                                      $parm_short =~ s/\(m3s-1\)//i;
                                      $parm_short =~ s/ [kmu]?g\/L\/day//i;
                                      $parm_short =~ s/ [kmu]?g\/m2\/day//i;
                                      $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
                                      $parm_short =~ s/ [kmu]?g\/L//i;
                                      $parm_short =~ s/ [kmu]?g\/m3//i;
                                      $parm_short =~ s/ [kmu]?g\/m\^3//i;
                                      $parm_short =~ s/, days//i;
                                      $parm_short =~ s/ days//i;
                                      $parm_short =~ s/,$//;
                                      if ($parm eq "Horizontal Velocity" || $parm eq "Vertical Velocity") {
                                          $units  = "m/s";
                                          $ptitle = $parm_short . ", in m/s";
                                      } elsif ($parm eq "Horizontal Layer Flow") {
                                          $units  = "m3/s";
                                          $ptitle = $parm_short . ", in m3/s";
                                      } elsif ($parm eq "Density") {
                                          $units  = "kg/m3";
                                          $ptitle = $parm_short . ", in kg/m3";
                                      } else {
                                          $ptitle = $parm_short . ", in ";
                                      }
                                      $units_cb->g_grid_remove();
                                      $units_entry->g_grid();
                                      $conv_type_na_label->g_grid_remove();
                                      $custom_frame->g_grid() if ($conv_type eq "Custom");
                                      $conv_type_cb->g_grid();
                                  }
                                  $old_units     = $units;
                                  $oldparm       = $parm;
                                  $oldparm_short = $parm_short;
                                  @parm_divlist  = ("None");
                                  for ($i=0; $i<=$#parmlist; $i++) {
                                      next if ($parmlist[$i] eq "Horizontal Velocity"
                                               || $parmlist[$i] eq "Vertical Velocity"
                                               || $parmlist[$i] eq "Horizontal Layer Flow"
                                               || $parmlist[$i] eq "Density"
                                               || $parmlist[$i] eq "Habitat");
                                      if ($parm ne $parmlist[$i]) {
                                          push (@parm_divlist, $parmlist[$i]);
                                      }
                                  }
                                  $parm_div_cb->configure(-values => [ @parm_divlist ],
                                                          -width  => $parm_chars);
                                  if (&list_match($parm_div, @parm_divlist) == -1) {
                                      $parm_div = "None";
                                  }
                                  if ($parm eq "Temperature" || $parm eq "Horizontal Velocity"
                                        || $parm eq "Vertical Velocity" || $parm eq "Density"
                                        || $parm eq "Horizontal Layer Flow"
                                        || $parm eq "Habitat" || $#parm_divlist == 0) {
                                      $parm_div_label->g_pack_forget();
                                      $parm_div_cb->g_pack_forget();
                                      $parm_div = "None";
                                  } else {
                                      $parm_div_label->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                                      $parm_div_cb->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                                  }
                                  $ok_btn->configure(-state => 'normal');
                              } else {
                                  $ok_btn->configure(-state => 'disabled');
                              }
                            },
            ))->g_grid(-row => $row, -column => 4, -sticky => 'ew', -padx => 2, -pady => 2);

    $row++;
    $f->new_label(
            -text => "Parameter: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($parm_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    ($parm_cb = $parm_frame->new_ttk__combobox(
            -textvariable => \$parm,
            -values       => [ @parmlist ],
            -state        => 'readonly',
            -width        => $parm_chars,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $parm_cb->g_bind("<<ComboboxSelected>>",
                         sub { my ($i);
                               return if ($parm eq $oldparm);
                               $parm_short = $parm;
                               if ($parm eq "Temperature") {
                                   $units  = "Celsius" if ($units !~ /(Celsius|Fahrenheit)/);
                                   $ptitle = "Temperature, in degrees " . $units;
                                   $units_cb->g_grid();
                                   $units_entry->g_grid_remove();
                                   $conv_type_na_label->g_grid();
                                   $custom_frame->g_grid_remove();
                                   $conv_type_cb->g_grid_remove();
                                   $conv_type = "None";
                               } else {
                                   $units = "";
                                   $parm_short =~ s/\(ms-1\)//i;
                                   $parm_short =~ s/\(m3s-1\)//i;
                                   $parm_short =~ s/ [kmu]?g\/L\/day//i;
                                   $parm_short =~ s/ [kmu]?g\/m2\/day//i;
                                   $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
                                   $parm_short =~ s/ [kmu]?g\/L//i;
                                   $parm_short =~ s/ [kmu]?g\/m3//i;
                                   $parm_short =~ s/ [kmu]?g\/m\^3//i;
                                   $parm_short =~ s/, days//i;
                                   $parm_short =~ s/ days//i;
                                   $parm_short =~ s/,$//;
                                   if ($parm eq "Horizontal Velocity" || $parm eq "Vertical Velocity") {
                                       $units  = "m/s";
                                       $ptitle = $parm_short . ", in m/s";
                                   } elsif ($parm eq "Horizontal Layer Flow") {
                                       $units  = "m3/s";
                                       $ptitle = $parm_short . ", in m3/s";
                                   } elsif ($parm eq "Density") {
                                       $units  = "kg/m3";
                                       $ptitle = $parm_short . ", in kg/m3";
                                   } else {
                                       $ptitle = $parm_short . ", in ";
                                   }
                                   $units_cb->g_grid_remove();
                                   $units_entry->g_grid();
                                   $conv_type_na_label->g_grid_remove();
                                   $custom_frame->g_grid() if ($conv_type eq "Custom");
                                   $conv_type_cb->g_grid();
                               }
                               $old_units     = $units;
                               $oldparm       = $parm;
                               $oldparm_short = $parm_short;
                               @parm_divlist  = ("None");
                               for ($i=0; $i<=$#parmlist; $i++) {
                                   next if ($parmlist[$i] eq "Horizontal Velocity"
                                            || $parmlist[$i] eq "Vertical Velocity"
                                            || $parmlist[$i] eq "Horizontal Layer Flow"
                                            || $parmlist[$i] eq "Density"
                                            || $parmlist[$i] eq "Habitat");
                                   if ($parm ne $parmlist[$i]) {
                                       push (@parm_divlist, $parmlist[$i]);
                                   }
                               }
                               $parm_div_cb->configure(-values => [ @parm_divlist ]);
                               if (&list_match($parm_div, @parm_divlist) == -1) {
                                   $parm_div = "None";
                               }
                               if ($parm eq "Temperature" || $parm eq "Horizontal Velocity"
                                       || $parm eq "Vertical Velocity" || $parm eq "Density"
                                       || $parm eq "Horizontal Layer Flow"
                                       || $parm eq "Habitat" || $#parm_divlist == 0) {
                                   $parm_div_label->g_pack_forget();
                                   $parm_div_cb->g_pack_forget();
                                   $parm_div = "None";
                               } else {
                                   $parm_div_label->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                                   $parm_div_cb->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                               }
                             });
    ($parm_div_label = $parm_frame->new_label(
            -text => " divided by ",
            -font => 'default',
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    ($parm_div_cb = $parm_frame->new_ttk__combobox(
            -textvariable => \$parm_div,
            -values       => [ @parm_divlist ],
            -state        => 'readonly',
            -width        => $parm_chars,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Conversion: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($conv_type_na_label = $f->new_label(
            -text => "n/a",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $conv_type_na_label->g_grid_remove();
    ($conv_type_cb = $f->new_ttk__combobox(
            -textvariable => \$conv_type,
            -values       => [ @conv_types ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $conv_type_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($conv_type eq "Custom") {
                                $custom_frame->g_grid();
                            } else {
                                $custom_frame->g_grid_remove();
                            }
                          }
                      );
    $row++;
    ($custom_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    $custom_frame->new_label(
            -text => "Multiply by: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_mult_entry = $custom_frame->new_entry(
            -textvariable => \$conv_mult,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_mult_entry->g_bind("<KeyRelease>",
                              sub { &numeric_entry_only($conv_mult_entry);
                                    my $chars = &max(7, length($conv_mult));
                                    $conv_mult_entry->configure(-width => $chars);
                                  });
    $custom_frame->new_label(
            -text => "  Then add: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_add_entry = $custom_frame->new_entry(
            -textvariable => \$conv_add,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_add_entry->g_bind("<KeyRelease>",
                             sub { &numeric_entry_only($conv_add_entry);
                                   my $chars = &max(7, length($conv_add));
                                   $conv_add_entry->configure(-width => $chars);
                                 });

    $row++;
    $f->new_label(
            -text => "Parameter Units: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($units_cb = $f->new_ttk__combobox(
            -textvariable => \$units,
            -values       => [ ("Celsius", "Fahrenheit") ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $units_cb->g_bind("<<ComboboxSelected>>",
                       sub { return if ($units eq $old_units);
                             $old_units = $units;
                             $pmin = 0 if ($pmin eq "-");
                             $pmax = 0 if ($pmax eq "-");
                             if ($units eq "Celsius") {
                                 $pmin = &floor(($pmin -32) /1.8) if ($pmin ne "");
                                 $pmax = &ceil(($pmax  -32) /1.8) if ($pmax ne "");
                             } elsif ($units eq "Fahrenheit") {
                                 $pmin = &floor($pmin *1.8 +32) if ($pmin ne "");
                                 $pmax = &ceil($pmax  *1.8 +32) if ($pmax ne "");
                             }
                             $ptitle = "Temperature, in degrees " . $units;
                           });
    $units_cb->g_grid_remove();
    ($units_entry = $f->new_entry(
            -textvariable => \$units,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $units_entry->g_bind("<KeyRelease>",
                         sub { my $chars = &max(7, length($units));
                               $units_entry->configure(-width => $chars);
                               if ($parm eq "Temperature") {
                                   $ptitle = "Temperature, in degrees " . $units;
                               } else {
                                   $ptitle = $parm_short . ", in " . $units;
                               }
                             });

    $row++;
    $f->new_label(
            -text => "Parameter Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$ptitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Parameter Min: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmin_entry = $f->new_entry(
            -textvariable => \$pmin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmin_entry ]);

    $row++;
    $f->new_label(
            -text => "Parameter Max: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmax_entry = $f->new_entry(
            -textvariable => \$pmax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmax_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmax_entry ]);

    $row++;
    $f->new_label(
            -text => "Color Scheme: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($cscheme_cb = $f->new_ttk__combobox(
            -textvariable => \$cscheme,
            -values       => [ @cmaps ],
            -state        => 'readonly',
            -width        => 15,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $cscheme_cb->g_bind("<<ComboboxSelected>>",
                           sub { my ($n);
                                 if ($cscheme =~ /CoolWarm|Turbo|Viridis/) {
                                     $ncolors_cb->configure(-values => [ (8 .. 100) ]);
                                 } else {
                                     $ncolors_cb->configure(-values =>
                                         [ (16, 18, 20, 22, 24, 30, 34, 38, 42, 46) ]);
                                     if ($ncolors < 16) {
                                         $ncolors = 16;
                                     } elsif ($ncolors > 46) {
                                         $ncolors = 46;
                                     } else {
                                         foreach $n (reverse @valid_nc) {
                                             if ($ncolors >= 2 *$n) {
                                                 $ncolors = 2 *$n;
                                                 last;
                                             }
                                         }
                                     }
                                 }
                               });

    $row++;
    $f->new_label(
            -text => "Number of Colors: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ncolors_cb = $f->new_ttk__combobox(
            -textvariable => \$ncolors,
            -values       => [ (16, 18, 20, 22, 24, 30, 34, 38, 42, 46) ],
            -state        => 'readonly',
            -width        => 4,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    if ($jd_skip_active) {
        $row++;
        $f->new_label(
                -text => "Outflow Skip: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($jd_skip_frame = $f->new_frame(
                -borderwidth => 0,
                -relief      => 'flat',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
        $jd_skip_frame->new_spinbox(
                -textvariable => \$jd_skip,
                -state        => 'readonly',
                -font         => 'default',
                -from         => 0,
                -to           => 49,
                -increment    => 1,
                -width        => 4,
                -command      => sub { $jd_skip_explain = $jd_skip_opts[$jd_skip]; },
                )->g_pack(-side => 'left', -anchor => 'w');
        $jd_skip_frame->new_label(
                -textvariable => \$jd_skip_explain,
                -font         => 'default',
                )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    }

    $row++;
    ($jd_skip_parm_label = $f->new_label(
            -text => "Parameter Skip: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($jd_skip_parm_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    $jd_skip_parm_frame->new_spinbox(
            -textvariable => \$jd_skip_parm,
            -state        => 'readonly',
            -font         => 'default',
            -from         => 0,
            -to           => 49,
            -increment    => 1,
            -width        => 4,
            -command      => sub { $jd_skip_parm_explain = $jd_skip_opts[$jd_skip_parm]; },
            )->g_pack(-side => 'left', -anchor => 'w');
    $jd_skip_parm_frame->new_label(
            -textvariable => \$jd_skip_parm_explain,
            -font         => 'default',
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);

    $row++;
    ($msg_label = $f->new_label(
            -text    => $wdo_msg . "\n" . $spr_msg . "\n" . $cpl_msg . "\n" . $vpl_msg . "\n" . $lcon_msg,
            -font    => 'default',
            -justify => 'left',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');

    $row++;
    $f->new_label(
            -text => "Match Tolerance: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($tol_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w');
    $tol_frame->new_spinbox(
            -textvariable => \$tol,
            -state        => 'readonly',
            -font         => 'default',
            -from         => 0,
            -to           => 60,
            -increment    => 1,
            -width        => 3,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $tol_frame->new_label(
            -text => " minutes",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');

    if ($jd_skip_parm_active) {
        $jd_skip_parm_label->g_grid();
        $jd_skip_parm_frame->g_grid();
        $msg_label->g_grid();
    } else {
        $jd_skip_parm_label->g_grid_remove();
        $jd_skip_parm_frame->g_grid_remove();
        if ($jd_skip_active) {
            $msg_label->g_grid();
        } else {
            $msg_label->g_grid_remove();
        }
    }
    if ($src_type =~ /Spreadsheet|Contour|Vector|LakeCon/i) {
        $src_file_label->configure(-text => $src_type . ": ");
        $src_file_btn->configure(-state => 'normal');
        $ok_btn->configure(-state => 'normal');
    }
    if ($parm eq "Temperature") {
        $units_cb->g_grid();
        $units_entry->g_grid_remove();
        $conv_type_na_label->g_grid();
        $custom_frame->g_grid_remove();
        $conv_type_cb->g_grid_remove();
        $conv_type = "None";
        $parm_div  = "None";
    } else {
        $units_cb->g_grid_remove();
        $units_entry->g_grid();
        $conv_type_na_label->g_grid_remove();
        $custom_frame->g_grid() if ($conv_type eq "Custom");
        $conv_type_cb->g_grid();
    }
    if ($parm eq "Temperature" || $parm eq "Horizontal Velocity" || $parm eq "Vertical Velocity"
                               || $parm eq "Horizontal Layer Flow" || $parm eq "Density"
                               || $parm eq "Habitat" || $#parm_divlist == 0 || $src_type =~ /LakeCon/i) {
        $parm_div_label->g_pack_forget();
        $parm_div_cb->g_pack_forget();
    } else {
        $parm_div_label->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        $parm_div_cb->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    }
    if ($conv_type ne "Custom") {
        $custom_frame->g_grid_remove();
    }
    if ($cscheme =~ /CoolWarm|Turbo|Viridis/) {
        $ncolors_cb->configure(-values => [ (8 .. 100) ]);
    } else {
        $ncolors_cb->configure(-values => [ (16, 18, 20, 22, 24, 30, 34, 38, 42, 46) ]);
        if ($ncolors < 16) {
            $ncolors = 16;
        } elsif ($ncolors > 46) {
            $ncolors = 46;
        } else {
            foreach $n (reverse @valid_nc) {
                if ($ncolors >= 2 *$n) {
                    $ncolors = 2 *$n;
                    last;
                }
            }
        }
    }
    $f->g_grid_columnconfigure(3, -weight => 2);

    Tkx::wm_resizable($w2outflow_setup_menu,0,0);
    &adjust_window_position($w2outflow_setup_menu);
    $w2outflow_setup_menu->g_focus;
}


sub make_w2_outflow {
    my ($canv, $id, $props_updated) = @_;
    my (
        $box_id, $cmap_image, $cs_max, $cs_min, $cs_range, $cs_rev,
        $cscheme1, $cscheme2, $data_available, $date_id, $date_label, $dsize,
        $dt, $dt2, $dt_parm, $dt_parm2, $elev_ref, $first, $found, $geom,
        $group_tags, $gtag, $i, $id2, $ih, $item, $iw, $j, $j2, $j3, $j4,
        $jj, $jw, $k, $kalt, $kn_digits, $kmx, $kt, $kt_parm, $kt_ref,
        $last_xp, $mi, $mismatch, $mult, $n, $ncolors, $new_graph, $np,
        $nwb, $parm_ref, $parm_short, $pbar, $pbar_window, $pval, $pval3,
        $pval4, $q_ref, $qmult, $refresh_menus, $resized, $seg, $surf_elev,
        $tabid, $tag, $tol, $update_cs, $v_ref, $X, $x1, $x2, $xmax, $xp,
        $Y, $y1, $y2, $ymax, $ymin, $yp, $yp1, $yp1i, $yp2, $yp3, $yp3i,
        $yp4, $yp4i, $ypi, $yrange, $yval,

        @be, @bs, @colors, @coords, @cpl_files, @ds, @el, @elws, @flows,
        @grp_tags, @items, @kb, @mydates, @old_coords, @pdata, @scale,
        @tags, @us, @wbs,

        %axis_props, %color_key_props, %data, %elev_data, %kt_data, %limits,
        %parm_data, %parms, %profile, %qdata, %vdata,
       );

#   For new plots, pop up a menu for file names and parameters
    if (! defined($props{$id}{files})) {
        return &setup_w2_outflow($canv, $id);
    }

#   Make tag and get coordinates of graph frame
    $gtag   = "graph" . $id;
    @coords = @{ $props{$id}{coordlist} };
    ($x1, $y1, $x2, $y2) = @coords;

#   Determine whether group tags are present and save the list
    $group_tags = 0;
    @grp_tags   = ();
    @tags       = Tkx::SplitList($canv->itemcget($id, -tags));
    if (&list_search("group_", @tags) > -1) {
        $group_tags = 1;
        foreach $tag (@tags) {
            push (@grp_tags, $tag) if ($tag =~ /^group_/);
        }
    }

#   Read the data files, if not done already
    if (! defined($props{$id}{data}) || ! $props{$id}{data}) {
        %parms = %{ $props{$id}{parms} };
        $seg   = $props{$id}{seg};

#       Set up some variables previously read from the control file
        $nwb = $grid{$id}{nwb};
        @bs  = @{ $grid{$id}{bs} };
        @be  = @{ $grid{$id}{be} };
        @us  = @{ $grid{$id}{us} };
        @ds  = @{ $grid{$id}{ds} };
        for ($jw=1; $jw<=$nwb; $jw++) {
            last if ($seg >= $us[$bs[$jw]] && $seg <= $ds[$be[$jw]]);
        }

#       Don't change most graph attributes if just changing color parameters.
#       Also don't need to re-read the bathymetry file.
        if ($props{$id}{add_parm} && defined($gr_props{$id})) {
            %profile = %{ $gr_props{$id} };
        } else {
            %profile = ();

#           Set some variables and read the bathymetry file
            &read_bth($main, $id, $jw, $props{$id}{bth_file});
            &get_grid_elevations($main, $id, $jw);
        }

#       Don't need to re-read the layer outflows file if just changing color parameters
#       and the jd_skip parameter hasn't changed.
        if ($props{$id}{add_parm} && defined($gr_props{$id}) && defined($props{$id}{old_jd_skip})
             && $props{$id}{jd_skip} == $props{$id}{old_jd_skip}) {
            %qdata = %{ $profile{qdata} };
            %vdata = %{ $profile{vdata} };

        } else {
#           Move mouse cursor on first creation, to ensure that it changes to cursor_wait
            if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
                $canv->g_bind("<Motion>", "");
                Tkx::event_generate($main, "<Motion>", -warp => 1, -x => ($x1+$x2)/2, -y => ($y1+$y2)/2);
                $canv->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"), $canv, "menu" ]);
            }

#           Read the Layer Outflows file
            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $props{$id}{qla_lines},
                                                     "Reading W2 Layer Outflow file...");
            ($q_ref, $v_ref) = &read_w2_layer_outflow($main, $id, $props{$id}{qla_file}, $seg,
                                                      $props{$id}{byear}, $props{$id}{tz_offset},
                                                      $props{$id}{jd_skip}, $pbar);
            &destroy_progress_bar($main, $pbar_window);

            %qdata          = %{ $q_ref };
            %vdata          = %{ $v_ref };
            $profile{qdata} = { %qdata };
            $profile{vdata} = { %vdata };

#           Find minimum and maximum elevation and layer outflow values
            %limits = &find_w2_outflow_limits($id, $seg, \%qdata, \%vdata);
            $profile{date_min} = $limits{date_min};
            $profile{date_max} = $limits{date_max};
            $profile{dpth_min} = $limits{dpth_min};
            $profile{dpth_max} = $limits{dpth_max};
            $profile{elev_min} = $limits{elev_min};
            $profile{elev_max} = $limits{elev_max};
            $profile{flow_min} = $limits{flow_min};
            $profile{flow_max} = $limits{flow_max};
            $profile{vel_min}  = $limits{vel_min};
            $profile{vel_max}  = $limits{vel_max};
            undef %limits;
        }

#       Read the added parameter source file, if needed
        if ($props{$id}{add_parm}) {
            if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
                $canv->g_bind("<Motion>", "");
                Tkx::event_generate($main, "<Motion>", -warp => 1, -x => ($x1+$x2)/2, -y => ($y1+$y2)/2);
                $canv->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"), $canv, "menu" ]);
            }

            if ($props{$id}{src_type} =~ /Spreadsheet/i) {
                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $props{$id}{src_lines},
                                                             "Reading W2 spreadsheet file...");
                ($kt_ref, $elev_ref, $parm_ref)
                        = &read_w2_spr_file($main, $id, $props{$id}{src_file}, $props{$id}{parm},
                                            $props{$id}{parm_div}, $props{$id}{byear}, $seg,
                                            $props{$id}{tz_offset}, $props{$id}{parm_skip}, $pbar);
                &destroy_progress_bar($main, $pbar_window);

                %kt_data   = %{ $kt_ref   };
                %elev_data = %{ $elev_ref };
                %parm_data = %{ $parm_ref };

            } elsif ($props{$id}{src_type} =~ /Contour/i) {
                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $props{$id}{src_lines},
                                                             "Reading W2 contour file...");
                %data = &read_w2_cpl_file($main, $id, $jw, $props{$id}{src_file}, $props{$id}{tplot},
                                          $seg, $props{$id}{parm}, $props{$id}{parm_div},
                                          $props{$id}{byear}, $props{$id}{tz_offset},
                                          $props{$id}{parm_skip}, $pbar);
                &destroy_progress_bar($main, $pbar_window);

                %kt_data   = ();
                %elev_data = ();
                %parm_data = ();
                @mydates = keys %data;
                for ($j=0; $j<=$#mydates; $j++) {
                    $dt    = $mydates[$j];
                    $kt    = $data{$dt}{kt};
                    @elws  = @{ $data{$dt}{elws}      };
                    @pdata = @{ $data{$dt}{parm_data} };
                    if (defined($elws[$seg])) {
                        $elev_data{$dt} = $elws[$seg];
                        for ($k=$kt; $k<=$#pdata; $k++) {
                            $parm_data{$dt}[$k-$kt] = $pdata[$k][$seg];
                        }
                    }
                    $kt_data{$dt} = $kt;
                }
                undef %data;

            } elsif ($props{$id}{src_type} =~ /Vector/i) {
                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, -s $props{$id}{src_file},
                                                             "Reading W2 vector file...");
                $status_line = "Reading W2 vector file... Date = 1";
                %data = &read_w2_vector_file($main, $id, $props{$id}{src_file}, $seg,
                                             $props{$id}{parm}, $props{$id}{parm_div}, $props{$id}{byear},
                                             $props{$id}{tz_offset}, $props{$id}{parm_skip}, $pbar);
                &destroy_progress_bar($main, $pbar_window);

                %kt_data   = ();
                %elev_data = ();
                %parm_data = ();
                @kb        = @{ $grid{$id}{kb} };
                @mydates   = keys %data;
                for ($j=0; $j<=$#mydates; $j++) {
                    $dt    = $mydates[$j];
                    $kt    = $data{$dt}{kt};
                    @pdata = @{ $data{$dt}{parm_data} };
                    if (defined($data{$dt}{elws}) && $data{$dt}{elws} != -99) {
                        $elev_data{$dt} = $data{$dt}{elws};
                        for ($k=$kt; $k<=$#pdata; $k++) {
                            $parm_data{$dt}[$k-$kt] = $pdata[$k];
                            last if ($k >= $kb[$seg]);
                        }
                    }
                    $kt_data{$dt} = $kt;
                }
                undef %data;

            } elsif ($props{$id}{src_type} =~ /LakeCon/i) {
                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $props{$id}{src_lines},
                                                             "Reading W2 Lake Contour file...");
                ($kt_ref, $elev_ref, $parm_ref)
                        = &read_w2_lakecon_file($main, $id, $props{$id}{src_file}, $seg, $props{$id}{parm},
                                                $props{$id}{byear}, $props{$id}{tz_offset},
                                                $props{$id}{parm_skip}, $pbar);
                &destroy_progress_bar($main, $pbar_window);

                %kt_data   = %{ $kt_ref   };
                %elev_data = %{ $elev_ref };
                %parm_data = %{ $parm_ref };
            }

            if (&list_match($props{$id}{parm_ctype}, @conv_types) > 0
                  || $props{$id}{parm_ctype} =~ /^Custom,/) {
                $status_line = "Converting units...";
                Tkx::update_idletasks();
                %parm_data = &convert_timeseries($main, $props{$id}{parm_ctype}, 1, %parm_data);
                $status_line = "";
                Tkx::update_idletasks();
            }

#           Find minimum and maximum elevation and parameter values
            %limits = &find_w2_profile_limits($id, $seg, \%elev_data, \%parm_data);
            $profile{parm_min}  = $limits{parm_min};
            $profile{parm_max}  = $limits{parm_max};
            undef %limits;

            $profile{kt_data}   = { %kt_data   };
            $profile{elev_data} = { %elev_data };
            $profile{parm_data} = { %parm_data };
        }

#       Don't change most graph attributes if just changing color parameters
        if (! $props{$id}{add_parm} || ! defined($props{$id}{old_jd_skip})) {
            $profile{yfont}     = $default_family;
            $profile{yl_size}   = &min(11, &max(8, int((abs($x2-$x1)+abs($y2-$y1))/2./41)));
            $profile{yt_size}   = $profile{yl_size} +2;
            $profile{yl_weight} = 'normal';
            $profile{yt_weight} = 'normal';
            $profile{ytype}     = $parms{ytype};
            $profile{yunits}    = $parms{yunits};
            $profile{ymin}      = ($parms{ymin} ne "") ? $parms{ymin} : 0;
            $profile{ymax}      = $parms{ymax};
            $profile{ymajor}    = ($parms{ymajor} eq "") ? "auto" : $parms{ymajor};
            $profile{ypr_tics}  = "outside";
            $profile{yop_tics}  = "none";
            $profile{ytitle}    = $parms{ytype} . ", in " . $parms{yunits};

            $profile{xfont}     = $profile{yfont};
            $profile{xl_size}   = $profile{yl_size};
            $profile{xt_size}   = $profile{yt_size};
            $profile{xl_weight} = $profile{yl_weight};
            $profile{xt_weight} = $profile{yt_weight};
            $profile{xmin}      = 0;
            $profile{xmax}      = $parms{xmax};
            $profile{xmajor}    = ($parms{xmajor} eq "") ? "auto" : $parms{xmajor};
            $profile{xpr_tics}  = "outside";
            $profile{xop_tics}  = "none";
            $profile{qunits}    = $parms{qunits};
            if ($parms{qunits} eq "cfs/ft") {
                $profile{xtitle} = "Release Rate, in cfs/(vert. ft)";
            } elsif ($parms{qunits} eq "cms/m") {
                $profile{xtitle} = "Release Rate, in cms/(vert. m)";
            } elsif ($parms{qunits} eq "ft/s") {
                $profile{xtitle} = "Velocity, in ft/s";
            } else {
                $profile{xtitle} = "Velocity, in m/s";
            }

            $profile{gtfont}    = $profile{yfont};
            $profile{gt_size}   = $profile{yt_size};
            $profile{gs_size}   = $profile{gt_size} -1;
            $profile{gt_weight} = 'bold';
            $profile{gs_weight} = $profile{gt_weight};
            $profile{gtitle}    = $parms{gtitle};

            $profile{cs_rev}    =  0;
            $profile{cs_hide}   =  0;
            $profile{xleg_off}  = 40;
            $profile{yleg_off}  =  0;
            $profile{cs_width}  = 24;
            $profile{cs_major}  = "auto";
            $profile{pc_style}  = "By Layer";
        }

        if (! $props{$id}{add_parm}) {
            undef $profile{add_cs} if (defined($profile{add_cs}));
        } else {
            if ($props{$id}{parm} eq "Temperature") {
                $profile{keytitle} = "Water temperature, in degrees " . $props{$id}{parm_units};
            } else {
                $parm_short = $props{$id}{parm};
                $parm_short =~ s/\(ms-1\)//i;
                $parm_short =~ s/\(m3s-1\)//i;
                $parm_short =~ s/ [kmu]?g\/L\/day//i;
                $parm_short =~ s/ [kmu]?g\/m2\/day//i;
                $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
                $parm_short =~ s/ [kmu]?g\/L//i;
                $parm_short =~ s/ [kmu]?g\/m3//i;
                $parm_short =~ s/ [kmu]?g\/m\^3//i;
                $parm_short =~ s/, days//i;
                $parm_short =~ s/ days//i;
                $parm_short =~ s/,$//;
                $profile{keytitle} = $parm_short . ", in " . $props{$id}{parm_units};
            }
            if (! defined($profile{keyfont})) {
                $profile{keyfont}   = $default_family;
                $profile{kn_size}   = $profile{yl_size};
                $profile{kt_size}   = $profile{yl_size} +2;
                $profile{kt_weight} = 'normal';
                $profile{kn_weight} = 'normal';
                $profile{kn_digits} = 1;
            }
            $profile{add_cs}    = 1;
            $profile{cs_height} = &max(2, &min(18, int(($y2-$y1+1) /$parms{ncolors})));
            if ($parms{cscheme} eq "Blue to Orange") {
                $profile{cscheme1} = "Blue";
                $profile{cscheme2} = "Orange";
                $profile{ncolors}  = $parms{ncolors} /2;
            } elsif ($parms{cscheme} eq "Blue to Red") {
                $profile{cscheme1} = "Blue";
                $profile{cscheme2} = "Red";
                $profile{ncolors}  = $parms{ncolors} /2;
            } else {
                $profile{cscheme1} = $parms{cscheme};
                $profile{cscheme2} = "None";
                $profile{ncolors}  = $parms{ncolors};
            }
            $profile{cs_min}  = $parms{pmin};
            $profile{cs_max}  = $parms{pmax};
            $profile{cs_link} = 0;

            if (@animate_ids && $#animate_ids >= 0) {
                $update_cs = 0;
                foreach $item (@animate_ids) {
                    next if ($item == $id);
                    next if ($props{$item}{meta} =~ /time_series|w2_wlevels/);
                    next if ($props{$item}{meta} eq "w2_outflow" && ! $props{$item}{add_parm});
                    if ($gr_props{$item}{cs_link} == 2) {
                        if ($props{$item}{meta} =~ /(w2_profile|w2_slice|w2_outflow)/
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$item}{parm_div}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                            $id2 = $item;
                            last;
                        } elsif ($props{$item}{meta} eq "w2_tdmap"
                             && $props{$item}{map_type}   eq "standard"
                             && $props{$item}{parm_sav}   eq $props{$id}{parm}
                             && $props{$item}{pdiv_sav}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                            $id2 = $item;
                            last;
                        } elsif ($props{$item}{meta} =~ /data_profile/
                             && $props{$item}{prof_type}  eq "standard"
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$id}{parm_div}     eq "None"
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                            $id2 = $item;
                            last;
                        } elsif ($props{$item}{meta} =~ /vert_wd_zone/
                             && $props{$id}{parm}       eq "Temperature"
                             && $props{$id}{parm_div}   eq "None"
                             && $props{$item}{wt_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                            $id2 = $item;
                            last;
                        }
                    }
                }
                if (! $update_cs) {
                    foreach $item (@animate_ids) {
                        next if ($item == $id);
                        next if ($props{$item}{meta} =~ /data_profile|vert_wd_zone|time_series|w2_wlevels/);
                        next if ($props{$item}{meta} eq "w2_outflow" && ! $props{$item}{add_parm});
                        next if ($props{$item}{meta} =~ /w2_slice|w2_tdmap/
                                  && $props{$item}{src_type} ne $props{$id}{src_type});
                        if ($gr_props{$item}{cs_link} == 1) {
                            if ($props{$item}{meta} =~ /w2_profile|w2_outflow/
                                 && $props{$item}{parm}       eq $props{$id}{parm}
                                 && $props{$item}{parm_div}   eq $props{$id}{parm_div}
                                 && $props{$item}{parm_units} eq $props{$id}{parm_units}
                                 && $props{$item}{src_file}   eq $props{$id}{src_file}) {
                                $update_cs = 1;
                                $id2 = $item;
                                last;
                            } elsif (($props{$item}{meta} =~ /w2_slice/
                                      && $props{$item}{parm}       eq $props{$id}{parm}
                                      && $props{$item}{parm_div}   eq $props{$id}{parm_div}
                                      && $props{$item}{parm_units} eq $props{$id}{parm_units})
                                  || ($props{$item}{meta} eq "w2_tdmap"
                                      && $props{$item}{map_type}   eq "standard"
                                      && $props{$item}{parm_sav}   eq $props{$id}{parm}
                                      && $props{$item}{pdiv_sav}   eq $props{$id}{parm_div}
                                      && $props{$item}{parm_units} eq $props{$id}{parm_units})) {
                                if ($props{$item}{src_type} =~ /Contour/i) {
                                    @wbs       = split(/,/, $props{$item}{wb_list});
                                    @cpl_files = @{ $props{$item}{cpl_files} };
                                    for ($n=0; $n<=$#wbs; $n++) {
                                        if ($cpl_files[$n] eq $props{$id}{src_file}) {
                                            $update_cs = 1;
                                            $id2 = $item;
                                            last;
                                        }
                                    }
                                    last if ($update_cs);
                                } elsif ($props{$item}{src_type} =~ /Vector/i) {
                                    if ($props{$item}{w2l_file} eq $props{$id}{src_file}) {
                                        $update_cs = 1;
                                        $id2 = $item;
                                        last;
                                    }
                                }
                            }
                        }
                    }
                }
                if ($update_cs) {
                    $ncolors           = $profile{ncolors};
                    $profile{cs_link}  = $gr_props{$id2}{cs_link};
                    $profile{cscheme1} = $gr_props{$id2}{cscheme1};
                    $profile{cscheme2} = $gr_props{$id2}{cscheme2};
                    $profile{ncolors}  = $gr_props{$id2}{ncolors};
                    $profile{cs_rev}   = $gr_props{$id2}{cs_rev};
                    $profile{cs_min}   = $gr_props{$id2}{cs_min};
                    $profile{cs_max}   = $gr_props{$id2}{cs_max};
                    $profile{cs_major} = $gr_props{$id2}{cs_major};
                    if ($profile{cs_height} *$ncolors > $y2-$y1+1 && $profile{cs_height} > 2) {
                        $profile{cs_height} = &max(2, &min(18, int(($y2-$y1+1) /$profile{ncolors})));
                    }
                }
            }
        }
        $profile{redraw}  = 1;
        $gr_props{$id}    = { %profile };
        $props{$id}{data} = 1;
        $props{$id}{gnum} = ++$graph_num if (! defined($props{$id}{oldcoords}));
        $resized          = 0;
        $refresh_menus    = 0;
        undef %profile;

#       Rebuild the @dates array if the color-display parameter
#       was changed and the jd_skip value was also changed
        if ($props{$id}{add_parm} && defined($props{$id}{old_jd_skip})) {
            if ($props{$id}{jd_skip} != $props{$id}{old_jd_skip}) {
                &rebuild_datelist;
            }
            $refresh_menus = 1;
            $canv->delete($gtag . "_xaxis");
            $canv->delete($gtag . "_xaxisTitle");
            $canv->delete($gtag . "_yaxis");
            $canv->delete($gtag . "_yaxisTitle");
            $canv->delete($gtag . "_date");
            $canv->delete($gtag . "_gtitle");
            $canv->delete($gtag . "_colorKey");
            $canv->delete($gtag . "_colorKeyTitle");
            $canv->delete($gtag . "_profile");
            $canv->delete($gtag . "_colorProfile");
        }
        undef %parms;

#   Or use previously read info.  If resized, delete graph and redraw
    } else {
        @old_coords    = @{ $props{$id}{oldcoords} };
        $refresh_menus = 0;
        $resized       = 0;
        for ($i=0; $i<=$#coords; $i++) {
            if ($coords[$i] != $old_coords[$i]) {
                $resized = 1;
                last;
            }
        }
        return if (! $resized && ! $props_updated);
        $gr_props{$id}{redraw} = 1 if ($resized);

        $seg   = $props{$id}{seg};
        %qdata = %{ $gr_props{$id}{qdata} };
        %vdata = %{ $gr_props{$id}{vdata} };
        if ($props{$id}{add_parm} && $gr_props{$id}{add_cs}) {
            %kt_data   = %{ $gr_props{$id}{kt_data}   };
            %parm_data = %{ $gr_props{$id}{parm_data} };
        }
        $canv->delete($gtag . "_xaxis");
        $canv->delete($gtag . "_xaxisTitle");
        $canv->delete($gtag . "_yaxis");
        $canv->delete($gtag . "_yaxisTitle");
        $canv->delete($gtag . "_date");
        $canv->delete($gtag . "_gtitle");
        $canv->delete($gtag . "_colorKey");
        $canv->delete($gtag . "_colorKeyTitle");
        if ($gr_props{$id}{redraw}) {
            $canv->delete($gtag . "_profile");
            $canv->delete($gtag . "_colorProfile");
        }
    }
    $props{$id}{oldcoords}   = [ @coords ];
    $props{$id}{old_jd_skip} = $props{$id}{jd_skip};

#   Set the list of dates or merge the dates array if necessary
#   Add the graph to the list of animated graphs, if necessary
    if (! @animate_ids || &list_match($id, @animate_ids) == -1) {
        @mydates = sort keys %qdata;
        if (@dates && @animate_ids && $#animate_ids >= 0) {
            $mismatch = 0;
            foreach $id2 (@animate_ids) {
#               next if ($id2 == $id);
                next if ($props{$id2}{meta}
                               =~ /data_profile_cmap|w2_profile_cmap|w2_profile_matrix|w2_tdmap|time_series/);
                if ($props{$id2}{meta} =~ /data_profile|w2_profile|w2_slice|w2_wlevels|vert_wd_zone/) {
                    $mismatch = 1;
                    last;
                } elsif ($props{$id2}{meta} eq "w2_outflow") {
                    if ($props{$id2}{qla_file}     ne $props{$id}{qla_file}
                        || $props{$id2}{byear}     != $props{$id}{byear}
                        || $props{$id2}{tz_offset} ne $props{$id}{tz_offset} 
                        || $props{$id2}{jd_skip}   != $props{$id}{jd_skip}) {
                        $mismatch = 1;
                        last;
                    }
                }
            }
            if ($mismatch) {
                if (defined($animate_tb) && Tkx::winfo_exists($animate_tb)) {
                    if ($animate_tb->g_wm_title() eq "Animation toolbar") {
                        $animate_tb->g_destroy();
                        undef $animate_tb;
                    }
                }
                $dt      = $dates[$dti-1];
                @dates   = &merge_dates(\@dates, \@mydates);
                $dti_max = $#dates+1;
                $dti     = 1 + &nearest_dt_index($dt, @dates);
                $dti++ if ($dti == 0);
            }
        } else {
            @dates   = @mydates;
            $dti_max = $#dates+1;
            $dti     = 1;
            $delay   = 0.5;
        }
        $dti_old = $dti;
        push (@animate_ids, $id);
    }
    $dt = $dates[$dti-1];              # Define current date/time
    if (! defined($qdata{$dt})) {      # Adjust by up to 10 minutes, if needed
        for ($mi=1; $mi<=10; $mi++) {
            $dt2 = &adjust_dt($dt, $mi);
            if (defined($qdata{$dt2})) {
                $dt = $dt2;
                last;
            }
            $dt2 = &adjust_dt($dt, -1 *$mi);
            if (defined($qdata{$dt2})) {
                $dt = $dt2;
                last;
            }
        }
    }
    $export_menu->entryconfigure(3, -state => 'normal') if ($use_GS);
    $pref_menu->entryconfigure(0,   -state => 'normal');

#   Plot a white rectangle below the graph frame
    @items     = Tkx::SplitList($canv->find_withtag($gtag . "_main"));
    $new_graph = ($#items >= 0) ? 0 : 1;
    if ($new_graph) {
        $box_id = $canv->create_rectangle($x1, $y1, $x2, $y2,
                             -outline => "",
                             -width   => 0,
                             -fill    => &get_rgb_code("white"),
                             -tags    => $gtag . " " . $gtag . "_main");
        $canv->lower($box_id, $id);
    } else {
        $canv->coords($gtag . "_main", @coords);
        $canv->raise($id, $gtag . "_main");
    }

#   Plot the date as a subtitle
    $xp = ($x1+$x2)/2.;
    $yp = ($gr_props{$id}{xop_tics} =~ /outside|cross/) ? $y1-14 : $y1-6;
    $date_label = &get_formatted_date($dt);
    $date_id = $canv->create_text($xp, $yp,
                       -anchor => 's',
                       -text   => $date_label,
                       -fill   => &get_rgb_code("black"),
                       -angle  => 0,
                       -tags   => $gtag . " " . $gtag . "_date",
                       -font   => [-family     => $gr_props{$id}{gtfont},
                                   -size       => $gr_props{$id}{gs_size},
                                   -weight     => $gr_props{$id}{gs_weight},
                                   -slant      => 'roman',
                                   -underline  => 0,
                                   -overstrike => 0,
                                  ]);
    @coords = Tkx::SplitList($canv->bbox($date_id));
    $dsize  = &max(10, abs($coords[3] - $coords[1]));

#   Plot the graph title
    $canv->create_text($xp, $yp-$dsize,
                       -anchor => 's',
                       -text   => $gr_props{$id}{gtitle},
                       -fill   => &get_rgb_code("black"),
                       -angle  => 0,
                       -tags   => $gtag . " " . $gtag . "_gtitle",
                       -font   => [-family     => $gr_props{$id}{gtfont},
                                   -size       => $gr_props{$id}{gt_size},
                                   -weight     => $gr_props{$id}{gt_weight},
                                   -slant      => 'roman',
                                   -underline  => 0,
                                   -overstrike => 0,
                                  ]);

#   Plot Y axis
    $axis_props{min}     = $gr_props{$id}{ymin};
    $axis_props{max}     = $gr_props{$id}{ymax};
    $axis_props{major}   = $gr_props{$id}{ymajor};
    $axis_props{pr_tics} = $gr_props{$id}{ypr_tics};
    $axis_props{op_tics} = $gr_props{$id}{yop_tics};
    $axis_props{minor}   = 1;
    $axis_props{reverse} = ($gr_props{$id}{ytype} eq "Depth") ? 1 : 0;
    $axis_props{title}   = $gr_props{$id}{ytitle};
    $axis_props{font}    = $gr_props{$id}{yfont};
    $axis_props{size1}   = $gr_props{$id}{yl_size};
    $axis_props{size2}   = $gr_props{$id}{yt_size};
    $axis_props{weight1} = $gr_props{$id}{yl_weight};
    $axis_props{weight2} = $gr_props{$id}{yt_weight};
    $axis_props{side}    = "left";
    $axis_props{tags}    = $gtag . " " . $gtag . "_yaxis";
    $axis_props{coords}  = [$x1, $y2, $x1, $y1];
    $axis_props{op_loc}  = $x2;
    &make_axis($canv, %axis_props);
    undef %axis_props;

#   Plot X axis
    $axis_props{min}     = $gr_props{$id}{xmin};
    $axis_props{max}     = $gr_props{$id}{xmax};
    $axis_props{major}   = $gr_props{$id}{xmajor};
    $axis_props{pr_tics} = $gr_props{$id}{xpr_tics};
    $axis_props{op_tics} = $gr_props{$id}{xop_tics};
    $axis_props{minor}   = 1;
    $axis_props{reverse} = 0;
    $axis_props{title}   = $gr_props{$id}{xtitle};
    $axis_props{font}    = $gr_props{$id}{xfont};
    $axis_props{size1}   = $gr_props{$id}{xl_size};
    $axis_props{size2}   = $gr_props{$id}{xt_size};
    $axis_props{weight1} = $gr_props{$id}{xl_weight};
    $axis_props{weight2} = $gr_props{$id}{xt_weight};
    $axis_props{side}    = "bottom";
    $axis_props{tags}    = $gtag . " " . $gtag . "_xaxis";
    $axis_props{coords}  = [$x1, $y2, $x2, $y2];
    $axis_props{op_loc}  = $y1;
    &make_axis($canv, %axis_props);
    undef %axis_props;

#   Deal with optional color scheme and create optional color key
    if ($props{$id}{add_parm} && $gr_props{$id}{add_cs}) {
        $cscheme1  = $gr_props{$id}{cscheme1};
        $cscheme2  = $gr_props{$id}{cscheme2};
        $ncolors   = $gr_props{$id}{ncolors};
        $cs_rev    = $gr_props{$id}{cs_rev};
        $cs_min    = $gr_props{$id}{cs_min};
        $cs_max    = $gr_props{$id}{cs_max};
        $kn_digits = $gr_props{$id}{kn_digits};
        if (&list_match($cscheme1, @color_scheme_names) == -1 ||
           (&list_match($cscheme1, @full_color_schemes) == -1 && &list_match($ncolors, @valid_nc) == -1) ||
           (&list_match($cscheme1, @full_color_schemes) >= 0 && &list_match($ncolors, @valid_nc_alt) == -1) ||
           ($cscheme2 ne "" && $cscheme2 ne "None" && &list_match($cscheme2, @color_scheme_names) == -1)) {
            $cscheme1  = $gr_props{$id}{cscheme1}  = "Blue";
            $cscheme2  = $gr_props{$id}{cscheme2}  = "Orange";
            $ncolors   = $gr_props{$id}{ncolors}   = 11;
            $cs_rev    = $gr_props{$id}{cs_rev}    =  0;
            $cs_min    = $gr_props{$id}{cs_min}    =  0;
            $cs_max    = $gr_props{$id}{cs_max}    = 22;
            $kn_digits = $gr_props{$id}{kn_digits} =  1;
        }
        $cs_range = $cs_max -$cs_min;
        @colors   = &make_color_scheme($ncolors, $cs_rev, $cscheme1, $cscheme2);
        @scale    = ();
        for ($i=0; $i<=$#colors+1; $i++) {
            $j = $#colors +1 -$i;
            $scale[$j] = $cs_min +$cs_range*$j/($#colors+1);
        }
        $gr_props{$id}{colors}    = [ @colors ];
        $gr_props{$id}{scale}     = [ @scale  ];

        $color_key_props{xleg}    = $x2 + $gr_props{$id}{xleg_off};
        $color_key_props{yleg}    = $y1 + $gr_props{$id}{yleg_off};
        $color_key_props{width}   = $gr_props{$id}{cs_width};
        $color_key_props{height}  = $gr_props{$id}{cs_height};
        $color_key_props{colors}  = [ @colors ];
        $color_key_props{scale}   = [ @scale  ];
        $color_key_props{title}   = $gr_props{$id}{keytitle};
        $color_key_props{font}    = $gr_props{$id}{keyfont};
        $color_key_props{size1}   = $gr_props{$id}{kn_size};
        $color_key_props{size2}   = $gr_props{$id}{kt_size};
        $color_key_props{weight1} = $gr_props{$id}{kn_weight};
        $color_key_props{weight2} = $gr_props{$id}{kt_weight};
        $color_key_props{digits}  = $kn_digits;
        $color_key_props{major}   = $gr_props{$id}{cs_major};
        $color_key_props{tags}    = $gtag . " " . $gtag . "_colorKey";
        &make_color_key($canv, %color_key_props);
        undef %color_key_props;

        if ($gr_props{$id}{cs_hide}) {
            $canv->itemconfigure($gtag . "_colorKey", -state => 'hidden');
        }
    }

#   Refresh the Graph Properties menu and Object Information box, if present
    if ($refresh_menus) {
        if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
            if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
                $tabid = $grprops_notebook->index('current');
                $geom  = $graph_props_menu->g_wm_geometry();
                (undef, $X, $Y) = split(/\+/, $geom);
                &edit_graph_props($id, $X, $Y, $tabid);
            }
        }
        if (defined($object_infobox) && Tkx::winfo_exists($object_infobox)) {
            if ($object_infobox->g_wm_title() =~ /Object Info/) {
                $geom = $object_infobox->g_wm_geometry();
                (undef, $X, $Y) = split(/\+/, $geom);
                &show_info($canv, $id, $X, $Y);
            }
        }
    }

#   Don't recompute and redraw unless necessary
    if (! $gr_props{$id}{redraw}) {
        if ($props{$id}{add_parm} && $gr_props{$id}{add_cs}) {
            $canv->lower($gtag . "_colorKey",      $id);
            $canv->lower($gtag . "_colorKeyTitle", $id);
            $canv->lower($gtag . "_colorProfile",  $id);
        }
        $canv->lower($gtag . "_date",       $id);
        $canv->lower($gtag . "_gtitle",     $id);
        $canv->lower($gtag . "_xaxisTitle", $id);
        $canv->lower($gtag . "_yaxisTitle", $id);
        $canv->lower($gtag . "_profile",    $id);
        $canv->lower($gtag . "_xaxis",      $id);
        $canv->lower($gtag . "_yaxis",      $id);
        if ($group_tags) {
            foreach $tag (@grp_tags) {
                $canv->addtag($tag, withtag => $gtag);
            }
        }
        return;
    }

#   Determine whether layer outflow data are available on this date
#   and set the water-surface elevation
    if (defined($qdata{$dt})) {
        $data_available = 1;
    } else {
        $data_available = $np = 0;
    }

#   Get coordinates for the layer outflows
    if ($data_available) {
        if ($gr_props{$id}{qunits} eq "cfs/ft") {
            @flows = @{ $qdata{$dt} };
            $qmult = 10.763911;
        } elsif ($gr_props{$id}{qunits} eq "cms/m") {
            @flows = @{ $qdata{$dt} };
            $qmult = 1.0;
        } else {
            @flows = @{ $vdata{$dt} };
            $qmult = ($gr_props{$id}{qunits} eq "ft/s") ? 3.28084 : 1.0;
        }
        $surf_elev = $flows[1];                    # second member is WS elevation (m)
        $mult      = ($gr_props{$id}{yunits} eq "feet") ? 3.28084 : 1.0;
        $ymin      = $gr_props{$id}{ymin} /$mult;
        $ymax      = $gr_props{$id}{ymax} /$mult;  # keep depths & elevations in meters
        $yrange    = $ymax -$ymin;
        $kmx       = $grid{$id}{kmx};
        @el        = @{ $grid{$id}{el} };
        @kb        = @{ $grid{$id}{kb} };
        $xmax      = $gr_props{$id}{xmax};
        @coords    = ();
        $np        = 0;
        $first     = 1;
        $last_xp   = $x1;
        for ($k=2; $k<=$kmx; $k++) {
            next if (! defined($flows[$k]) || $flows[$k] eq "");
            if ($first) {
                $yval  = $surf_elev;
                $kt    = $k;
                $first = 0;
            } else {
                $yval  = $el[$k][$seg];
            }
            $xp = $x1 +($x2-$x1) *$flows[$k]*$qmult/$xmax;
            $xp = &max($x1, &min($x2, $xp));
            if ($gr_props{$id}{ytype} eq "Depth") {
                $yp1 = $y1 +($y2-$y1)*($surf_elev-$yval)/$ymax;
            } else {
                $yp1 = $y2 -($y2-$y1)*($yval-$ymin)/$yrange;
            }
            last if ($yp1 >= $y2);
            $yp1  = &max($y1, &min($y2, $yp1));
            $kalt = ($k == $kt && $kt > $kb[$seg]) ? $kb[$seg] : $k;
            if ($gr_props{$id}{ytype} eq "Depth") {
                $yp2 = $y1 +($y2-$y1)*($surf_elev-$el[$kalt+1][$seg])/$ymax;
            } else {
                $yp2 = $y2 -($y2-$y1)*($el[$kalt+1][$seg]-$ymin)/$yrange;
            }
            next if ($yp2 <= $y1);
            $yp2 = &max($y1, &min($y2, $yp2));
            if ($xp == $last_xp) {
                push (@coords, $xp, $yp1) if ($#coords < 0);
                push (@coords, $xp, $yp2);
            } else {
                push (@coords, $last_xp, $yp1, $xp, $yp1, $xp, $yp2);
            }
            if (! defined($flows[$k+1]) && $xp != $x1) {
                push (@coords, $x1, $yp2);
            }
            $np++ if ($xp > $x1);
            $last_xp = $xp;
            last if ($yp2 >= $y2);
        }

#       Work on a parameter-based color fill
        if ($np >= 1 && $props{$id}{add_parm} && $gr_props{$id}{add_cs}) {

#           Find a date match for the parameter-based color bars
            $dt_parm = $dt;
            $tol     = $props{$id}{match_tol};
            $found   = 0;
            if (defined($parm_data{$dt_parm})) {
                $found = 1;
            } elsif ($tol > 0) {
                for ($mi=1; $mi<=$tol; $mi++) {
                    $dt_parm2 = &adjust_dt($dt_parm, $mi);
                    if (defined($parm_data{$dt_parm2})) {
                        $dt_parm = $dt_parm2;
                        $found   = 1;
                        last;
                    }
                    $dt_parm2 = &adjust_dt($dt_parm, -1 *$mi);
                    if (defined($parm_data{$dt_parm2})) {
                        $dt_parm = $dt_parm2;
                        $found   = 1;
                        last;
                    }
                }
            }

#           If a match was found, create the color profile image
            if ($found) {
                $iw = $x2 -$x1 +1;
                $ih = $y2 -$y1 +1;
                $cmap_image = Tkx::image_create_photo(-width => $iw, -height => $ih);
                $cmap_image = Tkx::widget->new($cmap_image);
                $yp2 = $yp4 = $yp4i = $pval4 = $j4 = $last_xp = 0;
                $kt_parm = $kt_data{$dt_parm};

#               By Layer option
                if ($gr_props{$id}{pc_style} =~ /by layer/i || $kt >= $kb[$seg]) {
                    if ($gr_props{$id}{ytype} ne "Depth") {
                        $yp2 = &round_to_int(($ih-1)*(1.-($surf_elev-$ymin)/$yrange));
                        $yp2 = &max(0, &min($ih-1, $yp2));
                    }
                    for ($k=$kt; $k<=$kmx; $k++) {
                        $flows[$k] = 0.0 if (! defined($flows[$k]) || $flows[$k] eq "");
                        $xp   = &round_to_int(($iw-1) *$flows[$k]*$qmult/$xmax);
                        $xp   = &max(0, &min($iw-1, $xp));
                        $yp1  = $yp2;
                        last if ($yp1 >= $ih-1);
                        $kalt = ($k == $kt && $kt > $kb[$seg]) ? $kb[$seg] : $k;
                        if ($gr_props{$id}{ytype} eq "Depth") {
                            $yp2 = &round_to_int(($ih-1)*($surf_elev-$el[$kalt+1][$seg])/$ymax);
                        } else {
                            $yp2 = &round_to_int(($ih-1)*(1.-($el[$kalt+1][$seg]-$ymin)/$yrange));
                        }
                        if ($yp2 < 0) {
                            $yp2 = 0;
                            next;
                        }
                        $yp2 = &min($ih-1, $yp2);
                        if ($xp > 0) {
                            $i = &max(0, $k -$kt_parm);
                            if (defined($parm_data{$dt_parm}[$i])) {
                                $pval = $parm_data{$dt_parm}[$i];
                                $pval = $pval *1.8 +32 if ($props{$id}{parm}       eq "Temperature" &&
                                                           $props{$id}{parm_units} eq "Fahrenheit");
                                $j = &max(0, &min($#colors, int(($#colors+1) *($pval-$cs_min)/$cs_range)));
                                $cmap_image = &image_put_color($cmap_image, $colors[$j],
                                                               0, $yp1, $xp, $yp2);
                            }
                        }
                        last if ($yp2 >= $ih-1);
                        last if ($k >= $kb[$seg]);   # ensures once-through, for kt > kb[i]
                    }

#               Max Interpolation option
                } elsif ($gr_props{$id}{pc_style} =~ /max interp/i) {
                    if ($gr_props{$id}{ytype} ne "Depth") {
                        $yp2 = ($ih-1)*(1.-($surf_elev-$ymin)/$yrange);
                    }
                    $yp1i = &max(0, &min($ih-1, &round_to_int($yp2)));
                    for ($k=$kt; $k<=$kmx; $k++) {
                        $flows[$k] = 0.0 if (! defined($flows[$k]) || $flows[$k] eq "");
                        $xp    = &round_to_int(($iw-1) *$flows[$k]*$qmult/$xmax);
                        $xp    = &max(0, &min($iw-1, $xp));
                        $yp1   = $yp2;
                        $yp3   = $yp4;
                        $yp3i  = $yp4i;
                        $pval3 = $pval4;
                        $j3    = $j4;
                        last if ($k == $kt && $yp1 >= $ih-1);
                        last if ($k >  $kt && $yp3 >= $ih-1);
                        $kalt  = ($k == $kt && $k > $kb[$seg]) ? $kb[$seg] : $k;
                        if ($gr_props{$id}{ytype} eq "Depth") {
                            $yp2 = ($ih-1)*($surf_elev-$el[$kalt+1][$seg])/$ymax;
                        } else {
                            $yp2 = ($ih-1)*(1.-($el[$kalt+1][$seg]-$ymin)/$yrange);
                        }
                        $i = &max(0, $k -$kt_parm);
                        if (defined($parm_data{$dt_parm}[$i])) {
                            $pval4 = $parm_data{$dt_parm}[$i];
                            $pval4 = $pval4 *1.8 +32 if ($props{$id}{parm}       eq "Temperature" &&
                                                         $props{$id}{parm_units} eq "Fahrenheit");
                            $j4    = &max(0, &min($#colors, int(($#colors+1) *($pval4-$cs_min)/$cs_range)));
                        }
                        $yp4  = 0.5*($yp1+$yp2);
                        $yp4i = &max(0, &min($ih-1, &round_to_int($yp4)));
                        if (&round_to_int($yp4) < 0) {
                            $last_xp = $xp;
                            next;
                        }
                        if ($k==$kt) {
                            if ($xp > 0 && defined($parm_data{$dt_parm}[$i])) {
                                $cmap_image = &image_put_color($cmap_image, $colors[$j4],
                                                               0, $yp1i, $xp, $yp4i);
                            }
                            last if ($yp4i >= $ih-1);
                        } else {
                            if (defined($parm_data{$dt_parm}[$i]) && defined($parm_data{$dt_parm}[$i-1])) {
                                $yp1i = &max(0, &min($ih-1, &round_to_int($yp1)));
                                if ($j4 == $j3) {
                                    if ($last_xp > 0) {
                                        $cmap_image = &image_put_color($cmap_image, $colors[$j4],
                                                                       0, $yp3i, $last_xp, $yp1i);
                                    }
                                    if ($xp > 0) {
                                        $cmap_image = &image_put_color($cmap_image, $colors[$j4],
                                                                       0, $yp1i, $xp, $yp4i);
                                    }
                                } else {
                                    $jj = ($j3 < $j4) ? 1 : -1;
                                    for ($j=$j3*$jj; $j<=$j4*$jj; $j++) {
                                        $pval = ($j3 < $j4) ? $scale[$j+1] : $scale[$j*$jj];
                                        $yp   = $yp3 +($yp4-$yp3)*($pval-$pval3)/($pval4-$pval3);
                                        $yp   = &max($yp3, &min($yp4, $yp));
                                        next if (&round_to_int($yp) < 0);
                                        $ypi  = &max(0, &min($ih-1, &round_to_int($yp)));
                                        if ($ypi <= $yp1i) {
                                            if ($last_xp > 0) {
                                                $cmap_image = &image_put_color($cmap_image, $colors[$j*$jj],
                                                                               0, $yp3i, $last_xp, $ypi);
                                            }
                                        } elsif ($yp3i >= $yp1i) {
                                            if ($xp > 0) {
                                                $cmap_image = &image_put_color($cmap_image, $colors[$j*$jj],
                                                                               0, $yp3i, $xp, $ypi);
                                            }
                                        } else {
                                            if ($last_xp > 0) {
                                                $cmap_image = &image_put_color($cmap_image, $colors[$j*$jj],
                                                                               0, $yp3i, $last_xp, $yp1i);
                                            }
                                            if ($xp > 0) {
                                                $cmap_image = &image_put_color($cmap_image, $colors[$j*$jj],
                                                                               0, $yp1i, $xp, $ypi);
                                            }
                                        }
                                        $yp3i = $ypi;
                                        last if ($yp >= $ih-1);
                                    }
                                    $yp4i = $yp3i;
                                }
                            }
                        }
                        if ($k >= $kb[$seg]) {
                            $yp2 = &round_to_int($yp2);
                            last if ($yp2 < 0);
                            $yp2 = &min($ih-1, $yp2);
                            if ($xp > 0 && defined($parm_data{$dt_parm}[$i])) {
                                $cmap_image = &image_put_color($cmap_image, $colors[$j4],
                                                               0, $yp4i, $xp, $yp2);
                            }
                        }
                        last if ($k >= $kb[$seg]);   # ensures once-through, for kt > kb[i]
                        $last_xp = $xp;
                    }

#               Interpolation option
                } else {
                    if ($gr_props{$id}{ytype} ne "Depth") {
                        $yp2 = ($ih-1)*(1.-($surf_elev-$ymin)/$yrange);
                    }
                    for ($k=$kt; $k<=$kmx; $k++) {
                        $flows[$k] = 0.0 if (! defined($flows[$k]) || $flows[$k] eq "");
                        $xp   = &round_to_int(($iw-1) *$flows[$k]*$qmult/$xmax);
                        $xp   = &max(0, &min($iw-1, $xp));
                        $yp1  = $yp2;
                        $yp3  = $yp4;
                        $kalt = ($k == $kt && $kt > $kb[$seg]) ? $kb[$seg] : $k;
                        if ($gr_props{$id}{ytype} eq "Depth") {
                            $yp2 = ($ih-1)*($surf_elev-$el[$kalt+1][$seg])/$ymax;
                        } else {
                            $yp2 = ($ih-1)*(1.-($el[$kalt+1][$seg]-$ymin)/$yrange);
                        }
                        $i = &max(0, $k -$kt_parm);
                        if (defined($parm_data{$dt_parm}[$i])) {
                            $pval = $parm_data{$dt_parm}[$i];
                            $pval = $pval *1.8 +32 if ($props{$id}{parm}       eq "Temperature" &&
                                                       $props{$id}{parm_units} eq "Fahrenheit");
                            $j = &max(0, &min($#colors, int(($#colors+1) *($pval-$cs_min)/$cs_range)));
                        }
                        if ($k==$kt) {
                            $yp4 = &round_to_int(0.25*$yp1 +0.75*$yp2);
                            $yp1 = &max(0, &min($ih-1, &round_to_int($yp1)));
                            last if ($yp1 >= $ih-1);
                            if ($yp4 < 0) {
                                $yp4 = 0;
                                $last_xp = $xp;
                                next;
                            }
                            $yp4 = &min($ih-1, $yp4);
                            if ($xp > 0 && defined($parm_data{$dt_parm}[$i])) {
                                $cmap_image = &image_put_color($cmap_image, $colors[$j],
                                                               0, $yp1, $xp, $yp4);
                            }
                        } else {
                            $yp4 = &round_to_int(0.75*$yp1 +0.25*$yp2);
                            if ($yp4 < 0) {
                                $yp4 = 0;
                                $last_xp = $xp;
                                next;
                            }
                            $yp4 = &min($ih-1, $yp4);
                            if (defined($parm_data{$dt_parm}[$i]) && defined($parm_data{$dt_parm}[$i-1])) {
                                $pval = 0.5*($parm_data{$dt_parm}[$i] +$parm_data{$dt_parm}[$i-1]);
                                $pval = $pval *1.8 +32 if ($props{$id}{parm}       eq "Temperature" &&
                                                           $props{$id}{parm_units} eq "Fahrenheit");
                                $j2   = &max(0, &min($#colors, int(($#colors+1) *($pval-$cs_min)/$cs_range)));
                                $yp1i = &max(0, &min($ih-1, &round_to_int($yp1)));
                                if ($last_xp > 0) {
                                    $cmap_image = &image_put_color($cmap_image, $colors[$j2],
                                                                   0, $yp3, $last_xp, $yp1i);
                                }
                                if ($xp > 0) {
                                    $cmap_image = &image_put_color($cmap_image, $colors[$j2],
                                                                   0, $yp1i, $xp, $yp4);
                                }
                            }
                            last if ($yp4 >= $ih-1);
                            $yp3 = $yp4;
                            $yp4 = &round_to_int(0.25*$yp1 +0.75*$yp2);
                            if ($yp4 < 0) {
                                $yp4 = 0;
                                $last_xp = $xp;
                                next;
                            }
                            $yp4 = &min($ih-1, $yp4);
                            if ($xp > 0 && defined($parm_data{$dt_parm}[$i])) {
                                $cmap_image = &image_put_color($cmap_image, $colors[$j],
                                                               0, $yp3, $xp, $yp4);
                            }
                        }
                        last if ($yp4 >= $ih-1);
                        if ($k >= $kb[$seg]) {
                            $yp2 = &round_to_int($yp2);
                            last if ($yp2 < 0);
                            $yp2 = &min($ih-1, $yp2);
                            if ($xp > 0 && defined($parm_data{$dt_parm}[$i])) {
                                $cmap_image = &image_put_color($cmap_image, $colors[$j],
                                                               0, $yp4, $xp, $yp2);
                            }
                        }
                        last if ($k >= $kb[$seg]);   # ensures once-through, for kt > kb[i]
                        $last_xp = $xp;
                    }
                }
                $canv->create_image($x1, $y1, -anchor => 'nw',
                                              -image  => $cmap_image,
                                              -tags   => $gtag . " " . $gtag . "_colorProfile");
                undef $cmap_image;
            }
        }
        if ($props{$id}{add_parm} && $gr_props{$id}{add_cs}) {
            undef %kt_data;
            undef %parm_data;
        }

#       Plot the water surface and its indicator, if plotting elevations
        if ($gr_props{$id}{ytype} ne "Depth") {
            $yp = $y2 -($y2-$y1)*($surf_elev-$ymin)/$yrange;
            if ($yp >= $y1 && $yp <= $y2) {
                $canv->create_line($x1, $yp, $x2, $yp,
                                    -fill  => &get_rgb_code("gray60"),
                                    -width => 1,
                                    -arrow => 'none',
                                    -tags  => $gtag . " " . $gtag . "_profile");
                $xp = $x1 + 0.9*($x2-$x1);
                $canv->create_polygon($xp, $yp, $xp-4, $yp-8, $xp+4, $yp-8,
                                    -outline => &get_rgb_code("gray60"),
                                    -width   => 1,
                                    -fill    => &get_rgb_code("white"),
                                    -tags    => $gtag . " " . $gtag . "_profile");
            }
        }

#       Plot the profile
        if ($np >= 1) {
            $canv->create_line(@coords, -fill  => &get_rgb_code("black"),
                                        -width => 1,
                                        -arrow => 'none',
                                        -tags  => $gtag . " " . $gtag . "_profile");
        }
    }
    undef %qdata;
    undef %vdata;

#   Plot a no-data message
    if (! $data_available || $np < 1) {
        $canv->create_text(($x1+$x2)/2., ($y1+$y2)/2.,
                           -anchor => 'center',
                           -text   => "No Data",
                           -fill   => &get_rgb_code("gray60"),
                           -angle  => 0,
                           -tags   => $gtag . " " . $gtag . "_profile",
                           -font   => [-family     => $gr_props{$id}{xfont},
                                       -size       => $gr_props{$id}{xl_size},
                                       -weight     => 'normal',
                                       -slant      => 'roman',
                                       -underline  => 0,
                                       -overstrike => 0,
                                      ]);
    }

#   Place the graphic items in the proper order
    &raise_lower($canv, $id, "tiptop") if ($new_graph);
    if ($props{$id}{add_parm} && $gr_props{$id}{add_cs}) {
        $canv->lower($gtag . "_colorKey",      $id);
        $canv->lower($gtag . "_colorKeyTitle", $id);
        $canv->lower($gtag . "_colorProfile",  $id);
    }
    $canv->lower($gtag . "_date",       $id);
    $canv->lower($gtag . "_gtitle",     $id);
    $canv->lower($gtag . "_xaxisTitle", $id);
    $canv->lower($gtag . "_yaxisTitle", $id);
    $canv->lower($gtag . "_profile",    $id);
    $canv->lower($gtag . "_xaxis",      $id);
    $canv->lower($gtag . "_yaxis",      $id);
    if ($group_tags) {
        foreach $tag (@grp_tags) {
            $canv->addtag($tag, withtag => $gtag);
        }
    }

#   Update any links
    &update_links($canv, $id, $dt);
}


sub setup_w2_wlevels_part2 {
    my ($canv, $id, $X, $Y) = @_;
    my (
        $fr, $frame, $frame2, $geom, $jw, $n, $ok_btn, $oldsrc_type, $row,
        $sc_canv, $sc_fr, $src_btn, $src_file, $src_label1, $src_label2,
        $src_type, $src_type_cb, $txt, $vscroll, $w2l_file, $wl_file,
        $wl_lines,

        @bth_files, @cbtn, @clab1, @clab2, @cpl_fdates, @cpl_files,
        @cpl_ldates, @cpl_lines, @f, @tecplot, @wbs,
       );

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($w2levels_setup_menu) && Tkx::winfo_exists($w2levels_setup_menu)) {
        if ($w2levels_setup_menu->g_wm_title() eq "W2 Water Levels Graph Setup"
             || $w2levels_setup_menu->g_wm_title() eq "Modify W2 Water Levels Graph") {
            $w2levels_setup_menu->g_destroy();
            undef $w2levels_setup_menu;
        }
    }
    $w2levels_setup_menu = $main->new_toplevel();
    $w2levels_setup_menu->g_wm_transient($main);
    $w2levels_setup_menu->g_wm_title("W2 Water Levels Graph Setup");
    $w2levels_setup_menu->configure(-cursor => $cursor_norm);
    $w2levels_setup_menu->g_wm_geometry($geom);

#   Try to keep the nascent graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

    @wbs         = split(/,/, $props{$id}{wb_list});
    @cpl_files   = @cpl_lines = @cpl_fdates = @cpl_ldates = @tecplot = @bth_files = ();
    $src_type    = "W2 Contour File";
    $oldsrc_type = $src_type;
    $src_file    = $w2l_file = $wl_file = "";
    $wl_lines    = 0;
    for ($n=0; $n<=$#wbs; $n++) {
        $cpl_files[$n] = "          ";
        $bth_files[$n] = "";
    }

#   Set up the menu
    $frame = $w2levels_setup_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -state   => 'disabled',
            -command => sub { my ($i, $j, $jw1, $jw2, $mismatch, $n,
                                  @cpld, @cplf, @ncpl, %parms);
                              %parms = ();
                              if ($src_type =~ /Contour/i) {
                                  for ($n=0; $n<=$#wbs; $n++) {
                                      if ($cpl_files[$n] eq "" || $cpl_files[$n] eq "          "
                                                               || ! -e $cpl_files[$n]) {
                                          return &pop_up_error($w2levels_setup_menu,
                                          "W2 Contour file not set or does not exist:\n$cpl_files[$n]");
                                      }
                                  }

#                                 Ensure contour dates and frequencies are identical for all waterbodies
                                  if ($#wbs > 0) {
                                      @ncpl = @{ $grid{$id}{ncpl} };
                                      @cpld = @{ $grid{$id}{cpld} };
                                      @cplf = @{ $grid{$id}{cplf} };
                                      $mismatch = 0;
                                      for ($j=0; $j<=$#wbs; $j++) {
                                          $jw1 = $wbs[$j];
                                          for ($n=$j+1; $n<=$#wbs; $n++) {
                                              $jw2 = $wbs[$n];
                                              if ($ncpl[$jw1] != $ncpl[$jw2]) {
                                                  $mismatch = 1;
                                                  last;
                                              }
                                              for ($i=1; $i<=$ncpl[$jw1]; $i++) {
                                                  if ($cpld[$i][$jw1] != $cpld[$i][$jw2]) {
                                                      $mismatch = 1;
                                                      last;
                                                  }
                                              }
                                              if ($cplf[$i][$jw1] eq "na" || $cplf[$i][$jw2] eq "na") {
                                                  if ($cplf[$i][$jw1] ne $cplf[$i][$jw2]) {
                                                      $mismatch = 1;
                                                      last;
                                                  }
                                              } else {
                                                  if ($cplf[$i][$jw1] != $cplf[$i][$jw2]) {
                                                      $mismatch = 1;
                                                      last;
                                                  }
                                              }
                                              last if ($mismatch);
                                          }
                                          last if ($mismatch);
                                      }
                                      if ($mismatch) {
                                          return &pop_up_error($w2levels_setup_menu,
                                              "The contour plot output dates and frequencies for\n"
                                            . "the chosen waterbodies do not match. Please try again.");
                                      }
                                      $mismatch = 0;
                                      for ($j=0; $j<=$#wbs; $j++) {
                                          for ($n=$j+1; $n<=$#wbs; $n++) {
                                              if (abs($cpl_fdates[$j] -$cpl_fdates[$n]) > 0.0007 ||
                                                  abs($cpl_ldates[$j] -$cpl_ldates[$n]) > 0.0007) {
                                                  $mismatch = 1;
                                                  last;
                                              }
                                          }
                                          last if ($mismatch);
                                      }
                                      if ($mismatch) {
                                          return &pop_up_error($w2levels_setup_menu,
                                              "The contour plot output start and end dates for the\n"
                                            . "chosen waterbodies do not match. Please try again.");
                                      }
                                  }
                                  $props{$id}{tecplot}   = [ @tecplot   ];
                                  $props{$id}{cpl_lines} = [ @cpl_lines ];
                                  $props{$id}{cpl_files} = [ @cpl_files ];

                              } elsif ($src_type =~ /Vector/i) {
                                  if ($w2l_file eq "" || ! -e $w2l_file) {
                                      return &pop_up_error($w2levels_setup_menu,
                                      "W2 Vector file not set or does not exist:\n$w2l_file");
                                  }
                                  $props{$id}{w2l_file} = $w2l_file;

                              } elsif ($src_type =~ /Water Level/i) {
                                  if ($wl_file eq "" || ! -e $wl_file) {
                                      return &pop_up_error($w2levels_setup_menu,
                                      "W2 Water Level file not set or does not exist:\n$wl_file");
                                  }
                                  $props{$id}{wl_file}  = $wl_file;
                                  $props{$id}{wl_lines} = $wl_lines;
                              }

                              for ($n=0; $n<=$#wbs; $n++) {
                                  if ($bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                      return &pop_up_error($w2levels_setup_menu,
                                      "W2 Bathymetry file not set or does not exist:\n$bth_files[$n]");
                                  }
                              }
                              $props{$id}{files}     = 1;
                              $props{$id}{src_type}  = $src_type;
                              $props{$id}{bth_files} = [ @bth_files ];

                              $geom = $w2levels_setup_menu->g_wm_geometry();
                              (undef, $X, $Y) = split(/\+/, $geom);

                              $w2levels_setup_menu->g_bind('<Destroy>', "");
                              $w2levels_setup_menu->g_destroy();
                              undef $w2levels_setup_menu;

                              &setup_w2_wlevels_part3($canv, $id, $X, $Y, "");
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);

    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $w2levels_setup_menu->g_bind('<Destroy>', "");
                              $w2levels_setup_menu->g_destroy();
                              undef $w2levels_setup_menu;
                              $canv->delete("graph" . $id);
                              delete $props{$id};
                              delete $grid{$id};
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Delete graph if this menu is destroyed by other than the Cancel button
    $w2levels_setup_menu->g_bind('<Destroy>' => sub { undef $w2levels_setup_menu;
                                                      $canv->delete("graph" . $id);
                                                      delete $props{$id}; 
                                                      delete $grid{$id};
                                                      &reset_bindings;
                                                    });

#   Need a scrollable container, and a canvas is about the only container that works.
#   Create a parent frame (sc_fr) for the canvas (sc_canv) and scrollbar (vscroll).
#   Then put a frame inside the canvas (fr) as a widget window to hold other menu items.
    ($sc_fr = $w2levels_setup_menu->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_pack(-side => 'top', -expand => 1, -fill => 'both');
    ($vscroll = $sc_fr->new_scrollbar(
            -orient => 'vertical',
            -width  => 15,
            ))->g_grid(-row => 0, -column => 1, -sticky => 'nse');
    ($sc_canv = $sc_fr->new_tk__canvas(
            -highlightthickness => 0,
            -yscrollcommand => [$vscroll, 'set'],
            ))->g_grid(-row => 0, -column => 0, -sticky => 'nsew');
    $vscroll->configure(-command => [$sc_canv, 'yview']);

    $fr = $sc_canv->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );

#   Source type
    $row = 0;
    $fr->new_label(
            -text => "W2 Source Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($src_type_cb = $fr->new_ttk__combobox(
            -textvariable => \$src_type,
            -values       => [ ("W2 Contour File", "W2 Vector File", "W2 Water Level File") ],
            -width        => 20,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $src_type_cb->g_bind("<<ComboboxSelected>>",
                          sub { my ($n, $status);
                                return if ($src_type eq $oldsrc_type);
                                $oldsrc_type = $src_type;
                                $status      = 'normal';
                                if ($src_type =~ /Contour/i) {
                                    $src_label1->g_grid_remove();
                                    $src_label2->g_grid_remove();
                                    $src_btn->g_grid_remove();
                                    for ($n=0; $n<=$#wbs; $n++) {
                                        $clab1[$n]->g_grid();
                                        $clab2[$n]->g_grid();
                                        $cbtn[$n]->g_grid();
                                    }
                                    $frame2->g_grid() if ($#wbs > 0);
                                    for ($n=0; $n<=$#wbs; $n++) {
                                        if ($cpl_files[$n] eq "          " ||
                                            $cpl_files[$n] eq "" || ! -e $cpl_files[$n] ||
                                            $bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                            $status = 'disabled';
                                            last;
                                        }
                                    }
                                } else {
                                    $frame2->g_grid_remove() if ($#wbs > 0);
                                    for ($n=0; $n<=$#wbs; $n++) {
                                        $clab1[$n]->g_grid_remove();
                                        $clab2[$n]->g_grid_remove();
                                        $cbtn[$n]->g_grid_remove();
                                    }
                                    $src_label1->g_grid();
                                    $src_label2->g_grid();
                                    $src_btn->g_grid();
                                    if ($src_type =~ /Vector/i) {
                                        $src_label1->configure(-text => "W2 Vector File: ");
                                        $src_file = $w2l_file;
                                    } else {
                                        $src_label1->configure(-text => "W2 Water Level File: ");
                                        $src_file = $wl_file;
                                    }
                                    if ($src_file eq "" || ! -e $src_file) {
                                        $status = 'disabled';
                                    } else {
                                        for ($n=0; $n<=$#wbs; $n++) {
                                            if ($bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                                $status = 'disabled';
                                                last;
                                            }
                                        }
                                    }
                                }
                                $ok_btn->configure(-state => $status);
                                &update_scrollable_menu($w2levels_setup_menu, $sc_fr, $sc_canv,
                                                        'scrollable', $vscroll);
                              });

#   Input fields for W2 Vector file
    $row++;
    $txt = ($src_type =~ /Vector/i) ? "W2 Vector File: " : "W2 Water Level File: ";
    ($src_label1 = $fr->new_label(
            -text => $txt,
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($src_label2 = $fr->new_label(
            -textvariable => \$src_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
    ($src_btn = $fr->new_button(
            -text    => "Browse",
            -command =>
               sub { my ($confirm_type, $file, $n, $ok, $pbar, $pbar_img, $pbar_win, $status);
                     if ($src_type =~ /Vector/i) {
                         $file = Tkx::tk___getOpenFile(
                                 -parent    => $w2levels_setup_menu,
                                 -title     => "Select W2 Vector Output File",
                                 -filetypes => [ ['All Files', '*'],
                                                 ['W2L (W2 Vector)', '.w2l'],
                                               ],
                                 );
                     } else {
                         $file = Tkx::tk___getOpenFile(
                                 -parent    => $w2levels_setup_menu,
                                 -title     => "Select W2 Water Levels File",
                                 -filetypes => [ ['All Files', '*'],
                                                 ['CSV (comma delimited)', '.csv'],
                                                 ['OPT (W2 output files)', '.opt'],
                                               ],
                                 );
                     }
                     if (defined($file) && -e $file) {
                         $src_file = File::Spec->rel2abs($file);
                         &update_scrollable_menu($w2levels_setup_menu,
                                                 $sc_fr, $sc_canv, 'scrollable', $vscroll);
                         if ($src_type =~ /Vector/i) {
                             $status_line = "Scanning W2 vector file...";  # no progress bar needed
                             Tkx::update_idletasks();
                             ($ok, undef, undef, undef, undef)
                                 = &scan_w2_vector_file($w2levels_setup_menu, $src_file, $id, 1);
                             $status_line = "";
                             if ($ok ne "okay") {
                                 $w2l_file = $src_file = "";
                                 $ok_btn->configure(-state => 'disabled');
                                 &update_scrollable_menu($w2levels_setup_menu,
                                                         $sc_fr, $sc_canv, 'scrollable', $vscroll);
                                 return &pop_up_error($w2levels_setup_menu,
                                                "The specified file is not a W2 Vector (w2l) file:\n$file");
                             }
                             $w2l_file = $src_file;
                         } else {
                             ($pbar_win, $pbar, $pbar_img)
                                 = &create_alt_progress_bar($main, $id, "Scanning W2 water level file...");
                             $confirm_type = &confirm_w2_ftype($w2levels_setup_menu, $src_file);
                             if ($confirm_type ne "wl") {
                                 $wl_file  = $src_file = "";
                                 $wl_lines = 0;
                                 &destroy_progress_bar($main, $pbar_win);
                                 $ok_btn->configure(-state => 'disabled');
                                 &update_scrollable_menu($w2levels_setup_menu,
                                                         $sc_fr, $sc_canv, 'scrollable', $vscroll);
                                 return &pop_up_error($w2levels_setup_menu,
                                          "The specified file is not a W2 Water Levels (wl) file:\n$file");
                             }
                             $wl_file = $src_file;
                             (undef, undef, $wl_lines)
                                      = &scan_w2_wlevel($w2levels_setup_menu, $wl_file, $pbar_img);
                             &destroy_progress_bar($main, $pbar_win);
                         }
                         $status = 'normal';
                         for ($n=0; $n<=$#wbs; $n++) {
                             if ($bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                 $status = 'disabled';
                                 last;
                             }
                         }
                         $ok_btn->configure(-state => $status);
                     } else {
                         $ok_btn->configure(-state => 'disabled');
                     }
                     &update_scrollable_menu($w2levels_setup_menu, $sc_fr, $sc_canv, 'scrollable', $vscroll);
                   },
            ))->g_grid(-row => $row, -column => 2, -sticky => 'ew', -padx => 2, -pady => 2);

    $fr->g_grid_columnconfigure(1, -weight => 2);
    $src_label1->g_grid_remove();
    $src_label2->g_grid_remove();
    $src_btn->g_grid_remove();

#   Loop over the required waterbodies
    for ($n=0; $n<=$#wbs; $n++) {
        $jw = $wbs[$n];

        $row++;
        ($f[$n] = $fr->new_labelframe(
                    -borderwidth => 1,
                    -relief      => 'groove',
                    -text        => "Waterbody $jw",
                ))->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew', -pady => 2);

        ($clab1[$n] = $f[$n]->new_label(
                -text => "W2 Contour File: ",
                -font => 'default',
                ))->g_grid(-row => 0, -column => 0, -sticky => 'e', -pady => 2);
        ($clab2[$n] = $f[$n]->new_label(
                -textvariable => \$cpl_files[$n],
                -anchor       => 'w',
                -font         => 'default',
                -background   => 'white',
                -relief       => 'sunken',
                -borderwidth  => 1,
                ))->g_grid(-row => 0, -column => 1, -sticky => 'ew', -pady => 2);
        ($cbtn[$n] = $f[$n]->new_button(
                -text    => "Browse",
                -command =>
                 [ sub { my ($n) = @_;
                         my ($file, $first_jd, $jw_src, $last_jd, $nlines,
                             $pbar, $pbar_img, $pbar_win, $status, $tecplot,
                            );
                         $file = Tkx::tk___getOpenFile(
                                 -parent    => $w2levels_setup_menu,
                                 -title     => "Select W2 Contour Output File",
                                 -filetypes => [ ['All Files', '*'],
                                                 ['CSV (comma delimited)', '.csv'],
                                                 ['OPT (W2 output files)', '.opt'],
                                               ],
                                 );
                         if (defined($file) && -e $file) {
                             $cpl_files[$n] = File::Spec->rel2abs($file);
                             &update_scrollable_menu($w2levels_setup_menu, $sc_fr, $sc_canv,
                                                     'scrollable', $vscroll);
                             ($pbar_win, $pbar, $pbar_img)
                                 = &create_alt_progress_bar($main, $id,
                                                            "Scanning W2 contour file...");
                             ($tecplot, $nlines, $jw_src, undef, $first_jd, $last_jd)
                                 = &scan_w2_cpl_file($w2levels_setup_menu, $cpl_files[$n], $id, 1, $pbar_img);
                             &destroy_progress_bar($main, $pbar_win);

                             if ($tecplot == -1) {
                                 $cpl_files[$n] = "          ";
                                 $ok_btn->configure(-state => 'disabled');
                                 &update_scrollable_menu($w2levels_setup_menu, $sc_fr, $sc_canv,
                                                         'scrollable', $vscroll);
                                 return &pop_up_error($w2levels_setup_menu,
                                     "Specified file is not a W2 Contour output file:\n$file");
                             }
                             if ($tecplot == 0 && $jw_src != $wbs[$n]) {
                                 $cpl_files[$n] = "          ";
                                 $ok_btn->configure(-state => 'disabled');
                                 &update_scrollable_menu($w2levels_setup_menu, $sc_fr, $sc_canv,
                                                         'scrollable', $vscroll);
                                 return &pop_up_error($w2levels_setup_menu,
                                         "The specified W2 Contour output file does not\n"
                                       . "appear to be from the correct waterbody:\n"
                                       . "(" . $jw_src . " rather than " . $wbs[$n] . "):\n$file");
                             }
                             $tecplot[$n]    = $tecplot;
                             $cpl_lines[$n]  = $nlines;
                             $cpl_fdates[$n] = $first_jd;
                             $cpl_ldates[$n] = $last_jd;

                             $status = 'normal';
                             for ($n=0; $n<=$#wbs; $n++) {
                                 if ($cpl_files[$n] eq "          " ||
                                     $cpl_files[$n] eq "" || ! -e $cpl_files[$n] ||
                                     $bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                     $status = 'disabled';
                                     last;
                                 }
                             }
                             $ok_btn->configure(-state => $status);
                         } else {
                             $ok_btn->configure(-state => 'disabled');
                         }
                         &update_scrollable_menu($w2levels_setup_menu, $sc_fr, $sc_canv,
                                                 'scrollable', $vscroll);
                       }, $n ],
                ))->g_grid(-row => 0, -column => 2, -sticky => 'ew', -padx => 2, -pady => 2);

        $f[$n]->new_label(
                -text => "W2 Bathymetry File: ",
                -font => 'default',
                )->g_grid(-row => 1, -column => 0, -sticky => 'e', -pady => 2);
        $f[$n]->new_label(
                -textvariable => \$bth_files[$n],
                -anchor       => 'w',
                -font         => 'default',
                -background   => 'white',
                -relief       => 'sunken',
                -borderwidth  => 1,
                )->g_grid(-row => 1, -column => 1, -sticky => 'ew', -pady => 2);
        $f[$n]->new_button(
                -text    => "Browse",
                -command =>
                 [ sub { my ($n) = @_;
                         my ($file, $status);
                         $file = Tkx::tk___getOpenFile(
                                 -parent           => $w2levels_setup_menu,
                                 -title            => "Select W2 Bathymetry File",
                                 -defaultextension => ".csv",
                                 -filetypes => [ ['CSV (comma delimited)', '.csv'],
                                                 ['NPT (W2 input files)', '.npt'],
                                                 ['All Files', '*'],
                                               ],
                                 );
                         if (defined($file) && -e $file) {
                             $bth_files[$n] = File::Spec->rel2abs($file);
                             $status = 'normal';
                             for ($n=0; $n<=$#wbs; $n++) {
                                 if ($src_type =~ /Contour/i) {
                                     if ($cpl_files[$n] eq "          " ||
                                         $cpl_files[$n] eq "" || ! -e $cpl_files[$n] ||
                                         $bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                         $status = 'disabled';
                                         last;
                                     }
                                 } else {
                                     if ($src_file      eq "" || ! -e $src_file ||
                                         $bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                         $status = 'disabled';
                                         last;
                                     }
                                 }
                             }
                             $ok_btn->configure(-state => $status);
                         } else {
                             $ok_btn->configure(-state => 'disabled');
                         }
                         &update_scrollable_menu($w2levels_setup_menu, $sc_fr, $sc_canv,
                                                 'scrollable', $vscroll);
                       }, $n ],
                )->g_grid(-row => 1, -column => 2, -sticky => 'ew', -padx => 2, -pady => 2);

        $f[$n]->g_grid_columnconfigure(1, -weight => 2);
    }

    if ($#wbs > 0) {
        $row++;
        ($frame2 = $fr->new_frame(
                    -borderwidth => 1,
                    -relief      => 'groove',
                ))->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew');

        $txt = "Note that this program works best when the contour output files from\n"
             . "each waterbody are assigned the same output dates and output frequencies.\n"
             . "In addition, each is required to include data for the parameter being plotted.";
        $frame2->new_label(
                -text    => $txt,
                -font    => 'default',
                -justify => 'left',
                )->g_pack(-side => 'left', -anchor => 'n', -expand => 1, -fill => 'x', -pady => 2);
    }

    $sc_canv->create_window(0, 0,
            -anchor => 'nw',
            -window => $fr,
            -tags   => 'scrollable',
            );
    &update_scrollable_menu($w2levels_setup_menu, $sc_fr, $sc_canv, 'scrollable', $vscroll);
    $sc_fr->g_grid_columnconfigure(0, -weight => 1);

    Tkx::wm_resizable($w2levels_setup_menu,0,0);
    &adjust_window_position($w2levels_setup_menu);
    $w2levels_setup_menu->g_focus;
}


sub setup_w2_wlevels_part3 {
    my ($canv, $id, $X, $Y, $change) = @_;
    my (
        $ask_about_checks, $byear, $byear_cb, $code, $color_btn, $extra_chk,
        $f, $fg, $frame, $geom, $gtitle, $i, $jb, $jd_skip, $jd_skip_active,
        $jd_skip_explain, $jw, $nbr, $new_graph, $offset_frame, $old_units,
        $row, $title, $tz_offset, $units, $units_cb, $wl_color, $wl_grid,
        $wl_gridc, $wl_gridc_btn, $wl_style, $xaxis_flip, $xaxis_frame,
        $xaxis_units, $ymajor, $ymajor_entry, $ymax, $ymax_entry, $ymin,
        $ymin_entry, $yr_max, $yr_min,

        @cplf, @ds, @jd_skip_opts, @ncpl, @nvpl, @seg_limits, @slope,
        @tsrf, @uhs, @us, @vplf, @wbs,
       );

    $change = "" if (! defined($change) || $change ne "misc");
    $geom   = sprintf("+%d+%d", $X, $Y);

    if (defined($w2levels_setup_menu) && Tkx::winfo_exists($w2levels_setup_menu)) {
        if ($w2levels_setup_menu->g_wm_title() eq "W2 Water Levels Graph Setup"
             || $w2levels_setup_menu->g_wm_title() eq "Modify W2 Water Levels Graph") {
            $w2levels_setup_menu->g_destroy();
            undef $w2levels_setup_menu;
        }
    }
    $w2levels_setup_menu = $main->new_toplevel();
    $w2levels_setup_menu->g_wm_transient($main);
    if ($change eq "misc") {
        $w2levels_setup_menu->g_wm_title("Modify W2 Water Levels Graph");
    } else {
        $w2levels_setup_menu->g_wm_title("W2 Water Levels Graph Setup");
    }
    $w2levels_setup_menu->configure(-cursor => $cursor_norm);
    $w2levels_setup_menu->g_wm_geometry($geom);

#   Try to keep the nascent graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

#   Retrieve parameter values if this graph already exists.
    $new_graph = (defined($props{$id}{oldcoords})) ? 0 : 1;
    if (! $new_graph) {
        &end_select($canv, $id, 1);
        $byear       = $props{$id}{byear};
        $tz_offset   = $props{$id}{tz_offset};
        $extra_chk   = $props{$id}{extra_chk};
        $jd_skip     = $props{$id}{jd_skip};
        $jd_skip     = 0 if ($jd_skip < 0 || $jd_skip > 49);
    } else {
        $byear       = $grid{$id}{byear};
        $tz_offset   = "+00:00";
        $jd_skip     = 0;
        $extra_chk   = ($props{$id}{src_type} =~ /Water Level/i) ? 1 : 0;
        $units       = "feet";
        $xaxis_units = "miles";
        $xaxis_flip  = 0;
        $gtitle      = "Water Levels Plot";
        $wl_color    = "black";
        $wl_style    = "Flat surface";
        $wl_grid     = 0;
        $wl_gridc    = "#D0D0D0";
        $title       = "Water Level, in " . $units;
        $old_units   = $units;
    }
    $yr_max = (localtime(time))[5] +1900;
    $yr_min = $yr_max -25;
    $yr_min = $byear -10 if ($byear <= $yr_min);
    $yr_max = $byear +10 if ($byear >= $yr_max);
    $ymax   = $ymin = $ymajor = "";

#   Skip some dates?
    $jd_skip_active = 0;
    if ($props{$id}{src_type} =~ /Contour/i) {
        @ncpl = @{ $grid{$id}{ncpl} };
        @cplf = @{ $grid{$id}{cplf} };
        @wbs  = split(/,/, $props{$id}{wb_list});
        foreach $jw (@wbs) {
            for ($i=1; $i<=$ncpl[$jw]; $i++) {
                next if ($cplf[$i][$jw] eq "na");
                if ($cplf[$i][$jw] < 1.0) {
                    $jd_skip_active = 1;
                    last;
                }
            }
            last if ($jd_skip_active);
        }
        undef @ncpl;
        undef @cplf;
        undef @wbs;
    } elsif ($props{$id}{src_type} =~ /Vector/i) {
        @nvpl = @{ $grid{$id}{nvpl} };
        @vplf = @{ $grid{$id}{vplf} };
        @wbs  = split(/,/, $props{$id}{wb_list});
        foreach $jw (@wbs) {
            for ($i=1; $i<=$nvpl[$jw]; $i++) {
                next if ($vplf[$i][$jw] eq "na");
                if ($vplf[$i][$jw] < 1.0) {
                    $jd_skip_active = 1;
                    last;
                }
            }
            last if ($jd_skip_active);
        }
        undef @nvpl;
        undef @vplf;
        undef @wbs;
    } else {
        if (defined($grid{$id}{wlf})) {
            $jd_skip_active = 1 if ($grid{$id}{wlf} ne "na" && $grid{$id}{wlf} < 1.0);
        } else {
            @tsrf = @{ $grid{$id}{tsrf} };
            for ($i=1; $i<=$grid{$id}{ntsr}; $i++) {
                next if ($tsrf[$i] eq "na");
                if ($tsrf[$i] < 1.0) {
                    $jd_skip_active = 1.0;
                    last;
                }
            }
            undef @tsrf;
        }
    }
    @jd_skip_opts = ("(keep all)", "(keep every other)", "(keep every 3rd)", "(keep every 4th)",
                     "(keep every 5th)",  "(keep every 6th)",  "(keep every 7th)",  "(keep every 8th)",
                     "(keep every 9th)",  "(keep every 10th)", "(keep every 11th)", "(keep every 12th)",
                     "(keep every 13th)", "(keep every 14th)", "(keep every 15th)", "(keep every 16th)",
                     "(keep every 17th)", "(keep every 18th)", "(keep every 19th)", "(keep every 20th)",
                     "(keep every 21st)", "(keep every 22nd)", "(keep every 23rd)", "(keep every 24th)",
                     "(keep every 25th)", "(keep every 26th)", "(keep every 27th)", "(keep every 28th)",
                     "(keep every 29th)", "(keep every 30th)", "(keep every 31st)", "(keep every 32nd)",
                     "(keep every 33rd)", "(keep every 34th)", "(keep every 35st)", "(keep every 36th)",
                     "(keep every 37th)", "(keep every 38th)", "(keep every 39th)", "(keep every 40th)",
                     "(keep every 41st)", "(keep every 42nd)", "(keep every 43rd)", "(keep every 44th)",
                     "(keep every 45th)", "(keep every 46th)", "(keep every 47th)", "(keep every 48th)",
                     "(keep every 49th)", "(keep every 50th)");
    $jd_skip_explain = $jd_skip_opts[$jd_skip];

#   Determine whether extra checks might be needed
    $ask_about_checks = 0;
    if ($props{$id}{src_type} =~ /Water Level/i) {
        $nbr        = $grid{$id}{nbr};
        @us         = @{ $grid{$id}{us}    };
        @ds         = @{ $grid{$id}{ds}    };
        @uhs        = @{ $grid{$id}{uhs}   };
        @slope      = @{ $grid{$id}{slope} };
        @seg_limits = split(/,|-/, $props{$id}{seg_list});
        for ($i=0; $i<=$#seg_limits; $i+=2) {
            for ($jb=1; $jb<=$nbr; $jb++) {
                last if ($seg_limits[$i] >= $us[$jb] && $seg_limits[$i] <= $ds[$jb]);
            }
            if ($slope[$jb] == 0. && $uhs[$jb] == 0) {
                $ask_about_checks = 1;
                last;
            }
        }
        $extra_chk = 0 if ($new_graph && ! $ask_about_checks);
    }

#   Set up the menu
    $frame = $w2levels_setup_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    $frame->new_button(
            -text    => "OK",
            -command => sub { my ($result, %parms);
                              %parms = ();
                              if ($change ne "misc") {
                                  if ($ymin eq "" || $ymax eq "") {
                                      return &pop_up_error($w2levels_setup_menu,
                                        "Please provide both a min and max elevation.");
                                  }
                                  if ($ymin >= $ymax) {
                                      return &pop_up_error($w2levels_setup_menu,
                                        "The minimum elevation must be less than the maximum elevation.");
                                  }
                                  $gtitle =~ s/^\s+//;
                                  $gtitle =~ s/\s+$//;

                                  $parms{xunits}   = $xaxis_units;
                                  $parms{xflip}    = $xaxis_flip;
                                  $parms{ymin}     = $ymin;
                                  $parms{ymax}     = $ymax;
                                  $parms{ymajor}   = $ymajor;
                                  $parms{yunits}   = $units;
                                  $parms{wl_color} = $wl_color;
                                  $parms{wl_style} = $wl_style;
                                  $parms{wl_grid}  = $wl_grid;
                                  $parms{wl_gridc} = $wl_gridc;
                                  $parms{gtitle}   = $gtitle;
                              }
                              $parms{change} = $change;

#                             Rebuild the dates array if different segment, jd_skip, or byear
                              if (! $new_graph) {
                                  $parms{rebuild} = ($byear     != $props{$id}{byear}     ||
                                                     $tz_offset ne $props{$id}{tz_offset} ||
                                                     $jd_skip   != $props{$id}{jd_skip}) ? 1 : 0;
                                  if (! $parms{rebuild} && $extra_chk == $props{$id}{extra_chk}) {
                                      $result = &pop_up_question($w2levels_setup_menu,
                                                                 "No changes were made. Try again?");
                                      return if (lc($result) eq "yes");
                                      $w2levels_setup_menu->g_bind('<Destroy>', "");
                                      $w2levels_setup_menu->g_destroy();
                                      undef $w2levels_setup_menu;
                                      &reset_bindings;
                                      return;
                                  }
                              }
                              $props{$id}{parms}     = { %parms };
                              $props{$id}{data}      = 0;
                              $props{$id}{files}     = 1;
                              $props{$id}{byear}     = $byear;
                              $props{$id}{tz_offset} = $tz_offset;
                              $props{$id}{jd_skip}   = $jd_skip;
                              $props{$id}{extra_chk} = $extra_chk;

                              $w2levels_setup_menu->g_bind('<Destroy>', "");
                              $w2levels_setup_menu->g_destroy();
                              undef $w2levels_setup_menu;
                              &reset_bindings;

                              &make_w2_wlevels($canv, $id, 0);
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $w2levels_setup_menu->g_bind('<Destroy>', "");
                              $w2levels_setup_menu->g_destroy();
                              undef $w2levels_setup_menu;
                              if ($new_graph) {
                                  $canv->delete("graph" . $id);
                                  delete $props{$id};
                                  delete $grid{$id};
                              }
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Delete graph if this menu is destroyed by other than the Cancel button
    $w2levels_setup_menu->g_bind('<Destroy>' => sub { undef $w2levels_setup_menu;
                                                      if ($new_graph) {
                                                          $canv->delete("graph" . $id);
                                                          delete $props{$id};
                                                          delete $grid{$id};
                                                      }
                                                      &reset_bindings;
                                                    });

    ($f = $w2levels_setup_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_pack(-side => 'top');

    $row = -1;
    if ($change ne "misc") {
        $row++;
        $f->new_label(
                -text => "Water Level Units: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($units_cb = $f->new_ttk__combobox(
                -textvariable => \$units,
                -values       => [ ("feet", "meters") ],
                -state        => 'readonly',
                -width        => 8,
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $units_cb->g_bind("<<ComboboxSelected>>",
                           sub { return if ($units eq $old_units);
                                 $old_units = $units;
                                 $title = "Water Level, in " . $units;
                               });

        $row++;
        $f->new_label(
                -text => "Axis Title: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $f->new_label(
                -textvariable => \$title,
                -font         => 'default',
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

        $row++;
        $f->new_label(
                -text => "Water Level Min: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($ymin_entry = $f->new_entry(
                -textvariable => \$ymin,
                -font         => 'default',
                -width        => 7,
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $ymin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $ymin_entry ]);
        $f->new_label(
                -textvariable => \$units,
                -font         => 'default',
                -anchor       => 'w',
                )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

        $row++;
        $f->new_label(
                -text => "Water Level Max: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($ymax_entry = $f->new_entry(
                -textvariable => \$ymax,
                -font         => 'default',
                -width        => 7,
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $ymax_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $ymax_entry ]);
        $f->new_label(
                -textvariable => \$units,
                -font         => 'default',
                -anchor       => 'w',
                )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

        $row++;
        $f->new_label(
                -text => "Water Level Major: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($ymajor_entry = $f->new_entry(
                -textvariable => \$ymajor,
                -font         => 'default',
                -width        => 7,
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $ymajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($ymajor_entry, 1);
                                                    $ymajor =~ s/^-//;
                                                  });
        $f->new_label(
                -textvariable => \$units,
                -font         => 'default',
                -anchor       => 'w',
                )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

        $row++;
        $f->new_label(
                -text => "X Axis Units: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($xaxis_frame = $f->new_frame(
                -borderwidth => 0,
                -relief      => 'flat',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
        $xaxis_frame->new_ttk__combobox(
                -textvariable => \$xaxis_units,
                -values       => [ ("miles", "kilometers") ],
                -state        => 'readonly',
                -width        => 10,
                )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        $xaxis_frame->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "Flip Axis",
                -font     => 'default',
                -variable => \$xaxis_flip,
                )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    }

    $row++;
    $f->new_label(
            -text => "Base Year: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($byear_cb = $f->new_ttk__combobox(
            -textvariable => \$byear,
            -values       => [ reverse($yr_min .. $yr_max) ],
            -state        => 'readonly',
            -width        => 5,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $byear_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($byear == $yr_min || $byear == $yr_max) {
                                $yr_min -= 10 if ($byear == $yr_min);
                                $yr_max += 10 if ($byear == $yr_max);
                                $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                            }
                          }
                     );
    $f->new_label(
            -text   => " for JDAY = 1.0",
            -anchor => 'w',
            -font   => 'default',
            )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Time Offset: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($offset_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $offset_frame->new_ttk__combobox(
            -textvariable => \$tz_offset,
            -values       => [ @tz_offsets ],
            -justify      => 'right',
            -state        => 'readonly',
            -width        => 6,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $offset_frame->new_label(
            -text   => " time zone adjustment ",
            -anchor => 'w',
            -font   => 'default',
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $offset_frame->new_button(
            -text    => "Help",
            -command => sub { &pop_up_info($w2levels_setup_menu,
                                    "The time offset allows the user to add or subtract a time\n"
                                  . "offset if the W2 model was run with a non-local time zone.\n\n"
                                  . "For example, if W2 was run in UTC but the local time zone\n"
                                  . "is PST, an offset of -08:00 would convert the model date/time\n"
                                  . "to a local standard time of PST. This offset does not make\n"
                                  . "any adjustments related to daylight saving time. In general,\n"
                                  . "W2 is best run in the local standard time.\n\n"
                                  . "Leave the time offset at +00:00 for no adjustment.",
                                    "Time Offset Notice");
                            },
            )->g_pack(-side => 'left', -anchor => 'w', -padx => 2);

    if ($jd_skip_active) {
        $row++;
        $f->new_label(
                -text => "Skip Dates: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $f->new_spinbox(
                -textvariable => \$jd_skip,
                -state        => 'readonly',
                -font         => 'default',
                -from         => 0,
                -to           => 49,
                -increment    => 1,
                -width        => 4,
                -command      => sub { $jd_skip_explain = $jd_skip_opts[$jd_skip]; },
                )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $f->new_label(
                -textvariable => \$jd_skip_explain,
                -font         => 'default',
                )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);
    }

    if ($ask_about_checks) {
        $row++;
        $f->new_label(
                -text => "Filters: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $f->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "Extra checks for inactive segments",
                -font     => 'default',
                -variable => \$extra_chk,
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    }

    if ($change ne "misc") {
        $row++;
        $f->new_label(
                -text => "Line Style: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $f->new_ttk__combobox(
                -textvariable => \$wl_style,
                -values       => [("Flat surface", "Interpolate", "Branch slope")],
                -width        => 14,
                -state        => 'readonly',
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

        $row++;
        $f->new_label(
                -text => "Line Color: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);

        $code     = &get_rgb_code($wl_color);
        $wl_color = &get_rgb_name($code);
        $fg       = &get_rgb_code("White");
        if ($code =~ /^\#[0-9a-f]/i) {
            $fg = &get_rgb_code(&get_bw_contrast($code));
        }
        ($color_btn = $f->new_button(
                -textvariable => \$wl_color,
                -background   => $code,
                -foreground   => $fg,
                -width        => -7,
                -command => sub { my ($newc);
                                  $code = &get_rgb_code($wl_color);
                                  $newc = Tkx::tk___chooseColor(
                                             -initialcolor => $code,
                                             -parent       => $w2levels_setup_menu);
                                  if ($newc) {
                                      $code     = &get_rgb_code($newc);
                                      $wl_color = &get_rgb_name($code);
                                      $fg       = &get_rgb_code("black");
                                      if ($code =~ /^#?[0-9a-f]/i) {
                                          $fg = &get_rgb_code(&get_bw_contrast($code));
                                      }
                                      $color_btn->configure(-foreground => $fg,
                                                            -background => $code);
                                  }
                                }
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

        $row++;
        $f->new_label(
                -text => "Grid Layers: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $f->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "Show",
                -font     => 'default',
                -variable => \$wl_grid,
                -command  => sub { my $status = ($wl_grid) ? 'normal' : 'disabled';
                                   $wl_gridc_btn->configure(-state => $status);
                                 },
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

        $row++;
        $f->new_label(
                -text => "Grid Line Color: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);

        $code     = &get_rgb_code($wl_gridc);
        $wl_gridc = &get_rgb_name($code);
        $fg       = &get_rgb_code("black");
        if ($code =~ /^\#[0-9a-f]/i) {
            $fg = &get_rgb_code(&get_bw_contrast($code));
        }
        ($wl_gridc_btn = $f->new_button(
                -textvariable => \$wl_gridc,
                -background   => $code,
                -foreground   => $fg,
                -width        => -7,
                -command => sub { my ($newc);
                                  $code = &get_rgb_code($wl_gridc);
                                  $newc = Tkx::tk___chooseColor(
                                             -initialcolor => $code,
                                             -parent       => $w2levels_setup_menu);
                                  if ($newc) {
                                      $code     = &get_rgb_code($newc);
                                      $wl_gridc = &get_rgb_name($code);
                                      $fg       = &get_rgb_code("black");
                                      if ($code =~ /^#?[0-9a-f]/i) {
                                          $fg = &get_rgb_code(&get_bw_contrast($code));
                                      }
                                      $wl_gridc_btn->configure(-foreground => $fg,
                                                               -background => $code);
                                  }
                                }
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        if (! $wl_grid) {
            $wl_gridc_btn->configure(-state => 'disabled');
        }

        $row++;
        $f->new_label(
                -text => "Graph Title: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $f->new_entry(
                -textvariable => \$gtitle,
                -font         => 'default',
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
    }
    $f->g_grid_columnconfigure(2, -weight => 2);

    Tkx::wm_resizable($w2levels_setup_menu,0,0);
    &adjust_window_position($w2levels_setup_menu);
    $w2levels_setup_menu->g_focus;
}


sub make_w2_wlevels {
    my ($canv, $id, $props_updated) = @_;
    my (
        $add_pt0, $add_pt3, $box_id, $confirm_type, $data_available,
        $date_id, $date_label, $dsize, $dsum, $dt, $dt2, $geom,
        $group_tags, $gtag, $i, $id2, $j, $jb, $jw, $k, $kmx, $last_jb,
        $last_seg, $last_xp, $last_yp, $mi, $mismatch, $mult, $n, $nd,
        $nbr, $new_graph, $np, $ns, $pbar, $pbar_window, $refresh_menus,
        $resized, $seg_dn, $seg_up, $src_type, $tabid, $tag, $wsel, $X,
        $x1, $x2, $xbase, $xd1, $xd2, $xdistance, $xmax, $xmin, $xmult,
        $xp, $xp0, $xp1, $xp2, $xp3, $xrange, $Y, $y1, $y2, $yexag, $ymax,
        $ymin, $yp, $yp0, $yp1, $yp2, $yp3, $yrange,

        @be, @bs, @bth_files, @coords, @cpl_files, @cpl_lines, @cus,
        @dlx, @ds, @el, @elws, @grp_tags, @items, @mydates, @old_coords,
        @seg_limits, @seglist, @slope, @tags, @tecplot, @us, @xdist, @wbs,

        %axis_props, %limits, %parms, %profile, %sdata, %wl_data,
       );

#   For new plots, pop up a menu for file names and parameters
    if (! defined($props{$id}{files})) {
        return &setup_w2_slice_or_tdmap_or_wlevels($canv, $id);
    }

#   Make tag and get coordinates of graph frame
    $gtag   = "graph" . $id;
    @coords = @{ $props{$id}{coordlist} };
    ($x1, $y1, $x2, $y2) = @coords;

#   Determine whether group tags are present and save the list
    $group_tags = 0;
    @grp_tags   = ();
    @tags       = Tkx::SplitList($canv->itemcget($id, -tags));
    if (&list_search("group_", @tags) > -1) {
        $group_tags = 1;
        foreach $tag (@tags) {
            push (@grp_tags, $tag) if ($tag =~ /^group_/);
        }
    }

#   Read the data file, if not done already
    if (! defined($props{$id}{data}) || ! $props{$id}{data}) {
        %parms    = %{ $props{$id}{parms} };
        @wbs      = split(/,/, $props{$id}{wb_list});
        $src_type = $props{$id}{src_type};

        if (defined($props{$id}{oldcoords})) {
            %profile   = %{ $gr_props{$id} };
            $new_graph = 0;
        } else {
            %profile   = ();
            $new_graph = 1;
        }

#       Validate the source type and input source file(s)
        if ($src_type =~ /Contour/i) {
            @cpl_files = @{ $props{$id}{cpl_files} };
            for ($n=0; $n<=$#wbs; $n++) {
                $confirm_type = &confirm_w2_ftype($main, $cpl_files[$n]);
                if ($confirm_type ne "cpl") {
                    return &pop_up_error($main,
                            "The W2 source file is not a W2 Contour file:\n$cpl_files[$n]");
                }
            }
        } elsif ($src_type =~ /Vector/i) {
            $confirm_type = &confirm_w2_ftype($main, $props{$id}{w2l_file});
            if ($confirm_type ne "w2l") {
                return &pop_up_error($main,
                        "The W2 source file is not a W2 Vector (w2l) file:\n$props{$id}{w2l_file}");
            }
        } else {
            $confirm_type = &confirm_w2_ftype($main, $props{$id}{wl_file});
            if ($confirm_type ne "wl") {
                return &pop_up_error($main,
                        "The W2 source file is not a W2 Water Levels (wl) file:\n$props{$id}{wl_file}");
            }
        }

#       Read bathymetry files, as necessary
#       Required for all source file types. Vector (w2l) files don't have a good kb value.
        if ($new_graph) {
            $status_line = "Reading bathymetry files...";
            Tkx::update_idletasks();
            @bth_files = @{ $props{$id}{bth_files} };
            for ($n=0; $n<=$#wbs; $n++) {
                &read_bth($main, $id, $wbs[$n], $bth_files[$n]);
                &get_grid_elevations($main, $id, $wbs[$n]);
            }
            $status_line = "";
            Tkx::update_idletasks();
        }

        if ($src_type =~ /Contour|Vector/i) {
            $nbr = $grid{$id}{nbr};
            @bs  = @{ $grid{$id}{bs} };
            @be  = @{ $grid{$id}{be} };
            @us  = @{ $grid{$id}{us} };
            @ds  = @{ $grid{$id}{ds} };
        }

#       Move mouse cursor on first creation, to ensure that it changes to cursor_wait
        if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
            $canv->g_bind("<Motion>", "");
            Tkx::event_generate($main, "<Motion>", -warp => 1, -x => ($x1+$x2)/2, -y => ($y1+$y2)/2);
            $canv->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"), $canv, "menu" ]);
        }

#       Read the contour files, if needed.
#       Water level is part of the normal return data; ask for Temperature then toss it.
        if ($src_type =~ /Contour/i) {
            @tecplot   = @{ $props{$id}{tecplot}   };
            @cpl_lines = @{ $props{$id}{cpl_lines} };
            @cpl_files = @{ $props{$id}{cpl_files} };
            for ($n=0; $n<=$#wbs; $n++) {
                $jw = $wbs[$n];
                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $cpl_lines[$n],
                                                             "Reading W2 contour file...");
                %sdata = &read_w2_cpl_file($main, $id, $jw, $cpl_files[$n], $tecplot[$n], 0,
                                           "Temperature", "None", $props{$id}{byear},
                                           $props{$id}{tz_offset}, $props{$id}{jd_skip}, $pbar);
                $nd      = 0;
                @mydates = sort keys %sdata;
                $pbar_window->g_wm_title("Processing data...");
                $status_line = "";
                Tkx::update_idletasks();
                &reset_progress_bar($pbar, $#mydates +1, "Processing data... Date = 1");

#               Consolidate data from different waterbodies
                if ($#wbs == 0 || $n == 0) {
                    $dsum    = &sum(@mydates);
                    %wl_data = ();
                    foreach $dt (@mydates) {
                        &update_progress_bar($pbar, ++$nd, $dt);
                        @cus  = @{ $sdata{$dt}{cus}  };
                        @elws = @{ $sdata{$dt}{elws} };
                        for ($jb=$bs[$jw]; $jb<=$be[$jw]; $jb++) {
                            for ($i=$us[$jb]; $i<=$ds[$jb]; $i++) {
                                if (! defined($cus[$jb]) || ! defined($elws[$i]) || $i < $cus[$jb]) {
                                    $wl_data{$dt}[$i] = -999;
                                } else {
                                    $wl_data{$dt}[$i] = $elws[$i];
                                }
                            }
                        }
                    }
                } else {
                    if ($dsum != &sum(@mydates)) {
                        &pop_up_info($main, "Contour file dates for waterbody " . $wbs[$n] . "\n"
                                          . "do not match those for waterbody " . $wbs[0] . "\n"
                                          . "This could lead to visualization problems.");
                    }
                    foreach $dt (@mydates) {
                        &update_progress_bar($pbar, ++$nd, $dt);
                        @cus  = @{ $sdata{$dt}{cus}  };
                        @elws = @{ $sdata{$dt}{elws} };
                        for ($jb=$bs[$jw]; $jb<=$be[$jw]; $jb++) {
                            for ($i=$us[$jb]; $i<=$ds[$jb]; $i++) {
                                if (! defined($cus[$jb]) || ! defined($elws[$i]) || $i < $cus[$jb]) {
                                    $wl_data{$dt}[$i] = -999;
                                } else {
                                    $wl_data{$dt}[$i] = $elws[$i];
                                }
                            }
                        }
                    }
                }
                &destroy_progress_bar($main, $pbar_window);
                $status_line = "Cleaning up...                           ";
                Tkx::update_idletasks();
                undef %sdata;
                undef @cus;
                undef @elws;
            }

#       Read the vector file, if needed.
#       Water level is part of the normal return data; ask for Temperature then toss it.
        } elsif ($src_type =~ /Vector/i) {
            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, -s $props{$id}{w2l_file},
                                                         "Reading W2 vector file...");
            $status_line = "Reading W2 vector file... Date = 1";
            %sdata = &read_w2_vector_file($main, $id, $props{$id}{w2l_file}, 0,
                                          "Temperature", "None", $props{$id}{byear},
                                          $props{$id}{tz_offset}, $props{$id}{jd_skip}, $pbar);
            @mydates = sort keys %sdata;
            $pbar_window->g_wm_title("Processing data...");
            $status_line = "";
            Tkx::update_idletasks();
            &reset_progress_bar($pbar, $#mydates +1, "Processing data... Date = 1");

            $nd      = 0;
            %wl_data = ();
            foreach $dt (@mydates) {
                &update_progress_bar($pbar, ++$nd, $dt);
                @cus  = @{ $sdata{$dt}{cus}  };
                @elws = @{ $sdata{$dt}{elws} };
                for ($jb=1; $jb<=$nbr; $jb++) {
                    for ($i=$us[$jb]; $i<=$ds[$jb]; $i++) {
                        if (! defined($cus[$jb]) || ! defined($elws[$i]) || $i < $cus[$jb]) {
                            $wl_data{$dt}[$i] = -999;
                        } else {
                            $wl_data{$dt}[$i] = $elws[$i];
                        }
                    }
                }
            }
            &destroy_progress_bar($main, $pbar_window);
            $status_line = "Cleaning up...                           ";
            Tkx::update_idletasks();
            undef %sdata;
            undef @cus;
            undef @elws;

#       Read the water levels file
#       See the read_w2_wlevel subroutine in w2anim_w2subs.pl for how inactive segments are detected
        } else {
            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $props{$id}{wl_lines},
                                                         "Reading W2 water levels file...");
            %wl_data = &read_w2_wlevel($main, $id, $props{$id}{wl_file}, $props{$id}{byear},
                                       $props{$id}{tz_offset}, "all", $props{$id}{jd_skip},
                                       $props{$id}{extra_chk}, $pbar);
            &destroy_progress_bar($main, $pbar_window);
        }
        $profile{wl_data} = { %wl_data };

#       Find minimum and maximum dates and water levels
        %limits = &find_w2_wlevel_limits($id, %wl_data);
        $profile{date_min} = $limits{date_min};
        $profile{date_max} = $limits{date_max};
        $profile{elev_min} = $limits{elev_min};    # in meters, or n/a
        $profile{elev_max} = $limits{elev_max};    # in meters, or n/a
        undef %limits;

        if ($new_graph) {
            $profile{yfont}     = $default_family;
            $profile{yl_size}   = &min(11, &max(8, int((abs($x2-$x1)+abs($y2-$y1))/2./41)));
            $profile{yt_size}   = $profile{yl_size} +2;
            $profile{yl_weight} = 'normal';
            $profile{yt_weight} = 'normal';
            $profile{yunits}    = $parms{yunits};
            $profile{ymin}      = ($parms{ymin} ne "") ? $parms{ymin} : 0;
            $profile{ymax}      = $parms{ymax};
            $profile{ymajor}    = ($parms{ymajor} eq "") ? "auto" : $parms{ymajor};
            $profile{ypr_tics}  = "outside";
            $profile{yop_tics}  = "none";
            $profile{ytitle}    = "Water Level, in " . $parms{yunits};

            $profile{xfont}     = $profile{yfont};
            $profile{xl_size}   = $profile{yl_size};
            $profile{xt_size}   = $profile{yt_size};
            $profile{xl_weight} = $profile{yl_weight};
            $profile{xt_weight} = $profile{yt_weight};
            $profile{xunits}    = $parms{xunits};
            $profile{xflip}     = $parms{xflip};
            $profile{xbase}     = 0;
            $profile{xmin}      = 0;
            $profile{xfirst}    = 0;
            $profile{xmax}      = 0;
            $profile{x_km}      = 0;
            $profile{xmajor}    = "auto";
            $profile{xpr_tics}  = "outside";
            $profile{xop_tics}  = "none";
            $profile{xmax_auto} = 1;
            if ($parms{xunits} eq "kilometers") {
                $profile{xtitle} = "River Kilometer";
            } else {
                $profile{xtitle} = "River Mile";
            }

            $profile{stype}     = "none";
            $profile{sfont}     = $default_family;
            $profile{st_size}   = $profile{xt_size};
            $profile{sl_size}   = $profile{xl_size};
            $profile{st_weight} = $profile{xt_weight};
            $profile{sl_weight} = $profile{xl_weight};
            $profile{smajor}    = "auto";
            $profile{spr_tics}  = "outside";
            $profile{sop_tics}  = "none";
            $profile{stic_loc}  = "upstream edge";
            $profile{sgrid}     = 0;
            $profile{sgrid_col} = '#C0C0C0';
            $profile{bgrid}     = 0;
            $profile{bgrid_col} = '#FF8040';
            $profile{stitle}    = "Segment Number";

            $profile{gtfont}    = $profile{yfont};
            $profile{gt_size}   = $profile{yt_size};
            $profile{gt_weight} = 'bold';
            $profile{gs_size}   = $profile{gt_size} -1;
            $profile{gs_weight} = $profile{gt_weight};
            $profile{gtitle}    = $parms{gtitle};

            $profile{wl_color}  = $parms{wl_color};
            $profile{wl_style}  = $parms{wl_style};
            $profile{wl_grid}   = $parms{wl_grid};
            $profile{wl_gridc}  = $parms{wl_gridc};
        }
        $profile{redraw}  = 1;
        $gr_props{$id}    = { %profile };
        $props{$id}{data} = 1;
        $props{$id}{gnum} = ++$graph_num if (! defined($props{$id}{oldcoords}));
        $resized          = 0;
        $refresh_menus    = 0;
        undef %profile;

#       Rebuild the dates array if different jd_skip or byear.
#       The rebuild option is determined in setup_w2_wlevels_part3.
        if (! $new_graph) {
            &rebuild_datelist if ($parms{rebuild});
            $refresh_menus = 1;
            $canv->delete($gtag . "_xaxis");
            $canv->delete($gtag . "_xaxisTitle");
            $canv->delete($gtag . "_yaxis");
            $canv->delete($gtag . "_yaxisTitle");
            $canv->delete($gtag . "_saxis");
            $canv->delete($gtag . "_saxisTitle");
            $canv->delete($gtag . "_sgrid");
            $canv->delete($gtag . "_date");
            $canv->delete($gtag . "_gtitle");
            $canv->delete($gtag . "_wlgrid");
            $canv->delete($gtag . "_wlevels");
        }
        undef %parms;

#   Or use previously read info.  If resized, delete graph and redraw
    } else {
        @old_coords    = @{ $props{$id}{oldcoords} };
        $refresh_menus = 0;
        $resized       = 0;
        for ($i=0; $i<=$#coords; $i++) {
            if ($coords[$i] != $old_coords[$i]) {
                $resized = 1;
                last;
            }
        }
        return if (! $resized && ! $props_updated);
        $gr_props{$id}{redraw} = 1 if ($resized);

        %wl_data = %{ $gr_props{$id}{wl_data} };

        $canv->delete($gtag . "_xaxis");
        $canv->delete($gtag . "_xaxisTitle");
        $canv->delete($gtag . "_yaxis");
        $canv->delete($gtag . "_yaxisTitle");
        $canv->delete($gtag . "_saxis");
        $canv->delete($gtag . "_saxisTitle");
        $canv->delete($gtag . "_sgrid");
        $canv->delete($gtag . "_date");
        $canv->delete($gtag . "_gtitle");
        if ($gr_props{$id}{redraw}) {
            $canv->delete($gtag . "_wlgrid");
            $canv->delete($gtag . "_wlevels");
        }
    }
    $props{$id}{oldcoords} = [ @coords ];

#   Set the list of dates or merge the dates array if necessary
#   Add the graph to the list of animated graphs, if necessary
#   For first creation, ensure mouse cursor is on canvas so it can be changed
    @mydates = sort keys %wl_data;
    if (! @animate_ids || &list_match($id, @animate_ids) == -1) {
        if (@dates && @animate_ids && $#animate_ids >= 0) {
            $mismatch = 0;
            foreach $id2 (@animate_ids) {
                next if ($props{$id2}{meta}
                               =~ /data_profile_cmap|w2_profile_cmap|w2_profile_matrix|w2_tdmap|time_series/);
                if ($props{$id2}{meta} =~ /data_profile|vert_wd_zone|w2_outflow/) {
                    $mismatch = 1;
                    last;
                } elsif ($props{$id2}{meta} eq "w2_profile") {
                    if ($props{$id2}{src_type}      ne $props{$id}{src_type}
                         || $props{$id2}{byear}     != $props{$id}{byear}
                         || $props{$id2}{tz_offset} ne $props{$id}{tz_offset}
                         || $props{$id2}{jd_skip}   != $props{$id}{jd_skip}) {
                        $mismatch = 1;
                        last;
                    } elsif ($props{$id2}{src_type} =~ /Contour/i) {
                        @cpl_files = @{ $props{$id}{cpl_files} };
                        $mismatch  = 1;
                        for ($n=0; $n<=$#wbs; $n++) {
                            if ($cpl_files[$n] eq $props{$id2}{src_file}) {
                                $mismatch = 0;
                                last;
                            }
                        }
                        last if ($mismatch);
                    } elsif ($props{$id2}{src_type} =~ /Vector/i) {
                        if ($props{$id2}{src_file} ne $props{$id}{w2l_file}) {
                            $mismatch = 1;
                            last;
                        }
                    }
                } elsif ($props{$id2}{meta} =~ /w2_slice|w2_wlevels/) {
                    if ($props{$id2}{con_file}      ne $props{$id}{con_file}
                         || $props{$id2}{src_type}  ne $props{$id}{src_type}
                         || $props{$id2}{byear}     != $props{$id}{byear}
                         || $props{$id2}{tz_offset} ne $props{$id}{tz_offset}
                         || $props{$id2}{jd_skip}   != $props{$id}{jd_skip}) {
                        $mismatch = 1;
                        last;
                    }
                }
            }
            if ($mismatch) {
                if (defined($animate_tb) && Tkx::winfo_exists($animate_tb)) {
                    if ($animate_tb->g_wm_title() eq "Animation toolbar") {
                        $animate_tb->g_destroy();
                        undef $animate_tb;
                    }
                }
                $dt    = $dates[$dti-1];
                @dates = &merge_dates(\@dates, \@mydates);
                $dti   = 1 + &nearest_dt_index($dt, @dates);
                $dti++ if ($dti == 0);
            }
        } else {
            @dates = @mydates;
            $dti   = 1;
            $delay = 0.5;
        }
        if ($global_dt_limits) {     # Truncate date range if global limits
            $dt    = $dates[$dti-1];
            @dates = &truncate_dates($global_dt_begin, $global_dt_end, @dates);
            $dti   = 1 + &nearest_dt_index($dt, @dates);
            $dti++ if ($dti == 0);
        }
        $dti_max = $#dates+1;
        $dti_old = $dti;
        push (@animate_ids, $id);
    }
    $dt = $dates[$dti-1];              # Define current date/time
    if (! defined($wl_data{$dt})) {  # Adjust by up to 10 minutes, if needed
        for ($mi=1; $mi<=10; $mi++) {
            $dt2 = &adjust_dt($dt, $mi);
            if (defined($wl_data{$dt2})) {
                $dt = $dt2;
                last;
            }
            $dt2 = &adjust_dt($dt, -1 *$mi);
            if (defined($wl_data{$dt2})) {
                $dt = $dt2;
                last;
            }
        }
    }
    $export_menu->entryconfigure(3, -state => 'normal') if ($use_GS);
    $pref_menu->entryconfigure(0,   -state => 'normal');

#   Plot a white rectangle below the graph frame
    @items     = Tkx::SplitList($canv->find_withtag($gtag . "_main"));
    $new_graph = ($#items >= 0) ? 0 : 1;
    if ($new_graph) {
        $box_id = $canv->create_rectangle($x1, $y1, $x2, $y2,
                             -outline => "",
                             -width   => 0,
                             -fill    => &get_rgb_code("white"),
                             -tags    => $gtag . " " . $gtag . "_main");
        $canv->lower($box_id, $id);
    } else {
        $canv->coords($gtag . "_main", @coords);
        $canv->raise($id, $gtag . "_main");
    }

#   Plot Y axis
    $axis_props{min}     = $gr_props{$id}{ymin};
    $axis_props{max}     = $gr_props{$id}{ymax};
    $axis_props{major}   = $gr_props{$id}{ymajor};
    $axis_props{pr_tics} = $gr_props{$id}{ypr_tics};
    $axis_props{op_tics} = $gr_props{$id}{yop_tics};
    $axis_props{minor}   = 1;
    $axis_props{reverse} = 0;
    $axis_props{title}   = $gr_props{$id}{ytitle};
    $axis_props{font}    = $gr_props{$id}{yfont};
    $axis_props{size1}   = $gr_props{$id}{yl_size};
    $axis_props{size2}   = $gr_props{$id}{yt_size};
    $axis_props{weight1} = $gr_props{$id}{yl_weight};
    $axis_props{weight2} = $gr_props{$id}{yt_weight};
    $axis_props{side}    = "left";
    $axis_props{tags}    = $gtag . " " . $gtag . "_yaxis";
    $axis_props{coords}  = [$x1, $y2, $x1, $y1];
    $axis_props{op_loc}  = $x2;
    &make_axis($canv, %axis_props);
    undef %axis_props;

#   Plot the date as a subtitle
    $xp = ($x1+$x2)/2.;
    if (($gr_props{$id}{stype} ne "none"    && $gr_props{$id}{sop_tics} =~ /outside|cross/) ||
        ($gr_props{$id}{stype} ne "replace" && $gr_props{$id}{xop_tics} =~ /outside|cross/)) {
        $yp = $y1-14;
    } else {
        $yp = $y1-6;
    }
    $date_label = &get_formatted_date($dt);
    $date_id = $canv->create_text($xp, $yp,
                       -anchor => 's',
                       -text   => $date_label,
                       -fill   => &get_rgb_code("black"),
                       -angle  => 0,
                       -tags   => $gtag . " " . $gtag . "_date",
                       -font   => [-family     => $gr_props{$id}{gtfont},
                                   -size       => $gr_props{$id}{gs_size},
                                   -weight     => $gr_props{$id}{gs_weight},
                                   -slant      => 'roman',
                                   -underline  => 0,
                                   -overstrike => 0,
                                  ]);
    @coords = Tkx::SplitList($canv->bbox($date_id));
    $dsize  = &max(10, abs($coords[3] - $coords[1]));

#   Plot the graph title
    $canv->create_text($xp, $yp-$dsize,
                       -anchor => 's',
                       -text   => $gr_props{$id}{gtitle},
                       -fill   => &get_rgb_code("black"),
                       -angle  => 0,
                       -tags   => $gtag . " " . $gtag . "_gtitle",
                       -font   => [-family     => $gr_props{$id}{gtfont},
                                   -size       => $gr_props{$id}{gt_size},
                                   -weight     => $gr_props{$id}{gt_weight},
                                   -slant      => 'roman',
                                   -underline  => 0,
                                   -overstrike => 0,
                                  ]);

#   Get segment list and downstream distance.
    $nbr   = $grid{$id}{nbr};
    @us    = @{ $grid{$id}{us}    };
    @ds    = @{ $grid{$id}{ds}    };
    @dlx   = @{ $grid{$id}{dlx}   };
    @slope = @{ $grid{$id}{slope} };

    if (defined($gr_props{$id}{xdist}) && defined($gr_props{$id}{seglist})) {
        @seglist = @{ $gr_props{$id}{seglist} };
        @xdist   = @{ $gr_props{$id}{xdist}   };  # saved in units of kilometers
    } else {
        @seg_limits = reverse split(/,|-/, $props{$id}{seg_list});  # reverse the order: ds to us
        @seglist    = ();
        $xdistance  = $last_seg = $last_jb = 0;
        for ($j=0; $j<=$#seg_limits; $j+=2) {
            $seg_dn = $seg_limits[$j];
            $seg_up = $seg_limits[$j+1];
            for ($jb=1; $jb<=$nbr; $jb++) {
                last if ($seg_dn >= $us[$jb] && $seg_dn <= $ds[$jb]);
            }
            if ($j > 1 && $last_seg != $us[$last_jb]) {
                $xdistance       -= $dlx[$last_seg] /2. *0.001;   # km
                $xdist[$last_seg] = $xdistance;
            }
            for ($i=$seg_dn; $i>=$seg_up; $i--) {
                $xdistance += $dlx[$i] *0.001;    # km
                $xdist[$i]  = $xdistance;
                push (@seglist, $i);
            }
            $last_seg = $seg_up;
            $last_jb  = $jb;
        }
        $gr_props{$id}{seglist} = [ @seglist ];
        $gr_props{$id}{xdist}   = [ @xdist   ];
    }
    $xmult = ($gr_props{$id}{xunits} eq "miles") ? 3280.84/5280. : 1.0;
    $xmin  = $gr_props{$id}{xmin};
    $xbase = $gr_props{$id}{xbase};
    if ($gr_props{$id}{xmax_auto}) {
        $xdistance = &round_to_int(1000.*$xdist[$seglist[$#seglist]] *$xmult)/1000.;
        $gr_props{$id}{xmax} = $xmax = $xbase +$xdistance;
    } else {
        $xmax = $gr_props{$id}{xmax};
    }
    $gr_props{$id}{x_km} = $xdist[$seglist[$#seglist]];

#   Update the Y axis exaggeration factor. Revert Y units to meters.
    $mult  = ($gr_props{$id}{yunits} eq "feet") ? 3.28084 : 1.0;
    $ymin  = $gr_props{$id}{ymin} /$mult;
    $ymax  = $gr_props{$id}{ymax} /$mult;
    $yexag = abs( (($xmax -$xmin) /$xmult  /($x2-$x1))
                 /(($ymax -$ymin) /1000.   /($y2-$y1)));
    $props{$id}{yexag_fac} = sprintf("%.4f", $yexag);

#   Plot X axis
    if ($gr_props{$id}{stype} ne "replace") {
        $axis_props{min}     = $xmin;
        $axis_props{max}     = $xmax;
        $axis_props{first}   = $gr_props{$id}{xfirst};
        $axis_props{major}   = $gr_props{$id}{xmajor};
        $axis_props{pr_tics} = $gr_props{$id}{xpr_tics};
        $axis_props{op_tics} = $gr_props{$id}{xop_tics};
        $axis_props{minor}   = 1;
        $axis_props{reverse} = 0;
        $axis_props{title}   = $gr_props{$id}{xtitle};
        $axis_props{font}    = $gr_props{$id}{xfont};
        $axis_props{size1}   = $gr_props{$id}{xl_size};
        $axis_props{size2}   = $gr_props{$id}{xt_size};
        $axis_props{weight1} = $gr_props{$id}{xl_weight};
        $axis_props{weight2} = $gr_props{$id}{xt_weight};
        $axis_props{side}    = "bottom";
        $axis_props{tags}    = $gtag . " " . $gtag . "_xaxis";
        $axis_props{coords}  = ($gr_props{$id}{xflip}) ? [$x2, $y2, $x1, $y2] : [$x1, $y2, $x2, $y2];
        $axis_props{op_loc}  = $y1;
        &make_axis($canv, %axis_props);
        undef %axis_props;
    }
    if ($gr_props{$id}{stype} ne "none") {
        $axis_props{base}     = $xbase /$xmult;           # convert to km
        $axis_props{min}      = $xmin  /$xmult;           # convert to km
        $axis_props{max}      = $xmax  /$xmult;           # convert to km
        $axis_props{dist}     = $gr_props{$id}{xdist};    # distance array in km
        $axis_props{seglist}  = $gr_props{$id}{seglist};  # list of segments, from ds to us
        $axis_props{type}     = $gr_props{$id}{stype};
        $axis_props{major}    = $gr_props{$id}{smajor};
        $axis_props{pr_tics}  = $gr_props{$id}{spr_tics};
        $axis_props{op_tics}  = $gr_props{$id}{sop_tics};
        $axis_props{title}    = $gr_props{$id}{stitle};
        $axis_props{font}     = $gr_props{$id}{sfont};
        $axis_props{size1}    = $gr_props{$id}{sl_size};
        $axis_props{size2}    = $gr_props{$id}{st_size};
        $axis_props{weight1}  = $gr_props{$id}{sl_weight};
        $axis_props{weight2}  = $gr_props{$id}{st_weight};
        $axis_props{tic_loc}  = $gr_props{$id}{stic_loc};
        $axis_props{grid}     = $gr_props{$id}{sgrid};
        $axis_props{gridcol}  = $gr_props{$id}{sgrid_col};
        $axis_props{bgrid}    = $gr_props{$id}{bgrid};
        $axis_props{bgridcol} = $gr_props{$id}{bgrid_col};
        $axis_props{grcoord}  = [$y1, $y2];
        $axis_props{side}     = "bottom";
        $axis_props{tags}     = $gtag . " " . $gtag . "_saxis";
        $axis_props{coords}   = ($gr_props{$id}{xflip}) ? [$x2, $y2, $x1, $y2] : [$x1, $y2, $x2, $y2];
        $axis_props{op_loc}   = $y1;
        &make_seg_axis($canv, %axis_props);
        undef %axis_props;
    }

#   Refresh the Graph Properties menu and Object Information box, if present
    if ($refresh_menus) {
        if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
            if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
                $tabid = $grprops_notebook->index('current');
                $geom  = $graph_props_menu->g_wm_geometry();
                (undef, $X, $Y) = split(/\+/, $geom);
                &edit_graph_props($id, $X, $Y, $tabid);
            }
        }
        if (defined($object_infobox) && Tkx::winfo_exists($object_infobox)) {
            if ($object_infobox->g_wm_title() =~ /Object Info/) {
                $geom = $object_infobox->g_wm_geometry();
                (undef, $X, $Y) = split(/\+/, $geom);
                &show_info($canv, $id, $X, $Y);
            }
        }
    }

#   Don't recompute and redraw unless necessary
    if (! $gr_props{$id}{redraw}) {
        $canv->lower($gtag . "_date",       $id);
        $canv->lower($gtag . "_gtitle",     $id);
        $canv->lower($gtag . "_wlgrid",     $id);
        $canv->lower($gtag . "_sgrid",      $id);
        $canv->lower($gtag . "_xaxisTitle", $id);
        $canv->lower($gtag . "_saxisTitle", $id);
        $canv->lower($gtag . "_yaxisTitle", $id);
        $canv->lower($gtag . "_wlevels",    $id);
        $canv->lower($gtag . "_xaxis",      $id);
        $canv->lower($gtag . "_saxis",      $id);
        $canv->lower($gtag . "_yaxis",      $id);
        if ($group_tags) {
            foreach $tag (@grp_tags) {
                $canv->addtag($tag, withtag => $gtag);
            }
        }
        return;
    }

#   Set some length variables
    $xmin  /= $xmult;        # revert to km
    $xmax  /= $xmult;        # revert to km
    $xbase /= $xmult;        # revert to km
    $xrange = $xmax -$xmin;  # km
    $yrange = $ymax -$ymin;  # meters

#   Plot the grid layers, if requested
    if ($gr_props{$id}{wl_grid}) {
        @seg_limits = reverse split(/,|-/, $props{$id}{seg_list});
        $kmx        = $grid{$id}{kmx};
        @el         = @{ $grid{$id}{el} };
        for ($j=0; $j<=$#seg_limits; $j+=2) {
            $seg_dn = $seg_limits[$j];
            $seg_up = $seg_limits[$j+1];
            for ($jb=1; $jb<=$nbr; $jb++) {
                last if ($seg_dn >= $us[$jb] && $seg_dn <= $ds[$jb]);
            }
            $xd1 = ($j == 0) ? 0 : $xdist[$seg_limits[$j-1]];
            $xd2 = $xdist[$seg_up];
            $xp1 = $x1 +($x2-$x1)*($xd1 +$xbase -$xmin)/$xrange;
            $xp2 = $x1 +($x2-$x1)*($xd2 +$xbase -$xmin)/$xrange;
            next if ($xp2 <= $x1);
            last if ($xp1 >= $x2);

            if ($slope[$jb] == 0) {
                $xp1 = &max($x1, &min($x2, $xp1));
                $xp2 = &max($x1, &min($x2, $xp2));
                $xp1 = $x2 -($xp1 -$x1) if ($gr_props{$id}{xflip});
                $xp2 = $x2 -($xp2 -$x1) if ($gr_props{$id}{xflip});
                for ($k=2; $k<=$kmx; $k++) {
                    $yp0 = $y2 -($y2-$y1)*($el[$k][$seg_dn]-$ymin)/$yrange;
                    next if ($yp0 <= $y1 || $yp0 >= $y2);
                    $canv->create_line($xp1, $yp0, $xp2, $yp0,
                                       -fill  => &get_rgb_code($gr_props{$id}{wl_gridc}),
                                       -width => 1,
                                       -arrow => 'none',
                                       -tags  => $gtag . " " . $gtag . "_wlgrid");
                }
            } else {
                for ($k=2; $k<=$kmx; $k++) {
                    $yp0 = $y2 -($y2-$y1)*($el[$k][$seg_dn]-0.5*$dlx[$seg_dn]*$slope[$jb]-$ymin)/$yrange;
                    if ($j+1 != $#seg_limits && $seg_up != $us[$jb]) {
                        $yp3 = $y2 -($y2-$y1)*($el[$k][$seg_up]-$ymin)/$yrange;
                    } else {
                        $yp3 = $y2 -($y2-$y1)*($el[$k][$seg_up]+0.5*$dlx[$seg_up]*$slope[$jb]-$ymin)/$yrange;
                    }
                    next if (($yp0 <= $y1 && $yp3 <= $y1) || ($yp0 >= $y2 && $yp3 >= $y2));

                    $xp0 = $xp1;
                    $xp3 = $xp2;
                    if ($xp0 < $x1) {
                        $yp0 = ($yp3-$yp0)*($x1-$xp0)/($xp3-$xp0)+$yp0;
                        $xp0 = $x1;
                    }
                    if ($xp3 > $x2) {
                        $yp3 = ($yp3-$yp0)*($x2-$xp0)/($xp3-$xp0)+$yp0;
                        $xp3 = $x2;
                    }
                    next if (($yp0 <= $y1 && $yp3 <= $y1) || ($yp0 >= $y2 && $yp3 >= $y2));

                    if ($yp0 < $y1) {
                        $xp0 = ($xp3-$xp0)*($y1-$yp0)/($yp3-$yp0)+$xp0;
                        $yp0 = $y1;
                    } elsif ($yp0 > $y2) {
                        $xp0 = ($xp3-$xp0)*($y2-$yp0)/($yp3-$yp0)+$xp0;
                        $yp0 = $y2;
                    }
                    if ($yp3 < $y1) {
                        $xp3 = ($xp3-$xp0)*($y1-$yp0)/($yp3-$yp0)+$xp0;
                        $yp3 = $y1;
                    } elsif ($yp3 > $y2) {
                        $xp3 = ($xp3-$xp0)*($y2-$yp0)/($yp3-$yp0)+$xp0;
                        $yp3 = $y2;
                    }
                    $xp0 = $x2 -($xp0 -$x1) if ($gr_props{$id}{xflip});
                    $xp3 = $x2 -($xp3 -$x1) if ($gr_props{$id}{xflip});
                    $canv->create_line($xp0, $yp0, $xp3, $yp3,
                                       -fill  => &get_rgb_code($gr_props{$id}{wl_gridc}),
                                       -width => 1,
                                       -arrow => 'none',
                                       -tags  => $gtag . " " . $gtag . "_wlgrid");
                }
            }
        }
    }

#   Plot the water levels, if data are available for this date/time
    $np = 0;
    $data_available = (defined($wl_data{$dt})) ? 1 : 0;

    if ($data_available) {
        @coords = ();

#       Loop over the segment list
        for ($ns=0; $ns<=$#seglist; $ns++) {
            $i    = $seglist[$ns];
            $wsel = $wl_data{$dt}[$i];
            if ($wsel == -999) {
                if ($#coords > 2) {
                    if ($gr_props{$id}{xflip}) {   # Flip the x values, if necessary
                        for ($n=0; $n<$#coords; $n+=2) {
                            $coords[$n] = $x2 -($coords[$n] -$x1);
                        }
                    }
                    $canv->create_line(@coords,
                                       -fill  => &get_rgb_code($gr_props{$id}{wl_color}),
                                       -width => 1,
                                       -arrow => 'none',
                                       -tags  => $gtag . " " . $gtag . "_wlevels");
                }
                @coords = ();
                next;
            }
            $xd1 = ($ns == 0) ? 0 : $xdist[$seglist[$ns-1]];
            $xd2 = $xdist[$i];
            $xp1 = $x1 +($x2-$x1)*($xd1 +$xbase -$xmin)/$xrange;
            $xp2 = $x1 +($x2-$x1)*($xd2 +$xbase -$xmin)/$xrange;
            next if ($xp2 < $x1);
            last if ($xp1 > $x2);

            $add_pt0 = $add_pt3 = 0;
            for ($jb=1; $jb<=$nbr; $jb++) {
                last if ($i >= $us[$jb] && $i <= $ds[$jb]);
            }
            if ($gr_props{$id}{wl_style} =~ /Interpolate/i) {
#               When a branch joins mid-segment, need to account for that.
#               Array seglist is ds to us, so normal progression is to decreasing segment numbers.
                if ($ns < $#seglist && $i != $us[$jb] && $seglist[$ns+1] != $i-1) {
                    $xp3 = $xp2;
                } else {
                    $xp3 = 0.5*($xp1+$xp2);
                }
                $yp3 = $y2 -($y2-$y1)*($wsel-$ymin)/$yrange;

                if ($xp3 < $x1) {
                    $last_xp = $xp3;
                    $last_yp = $yp3;
                    next;
                }
                if ($#coords == -1) {
                    last if ($xp1 == $x2);
                    $yp3 = $y1 if ($yp3 < $y1);
                    $yp3 = $y2 if ($yp3 > $y2);
                    $last_xp = &max($x1, $xp1);
                    $last_yp = $yp3;
                    push (@coords, $last_xp, $last_yp);
                }
                if ($yp3 < $y1 && $last_yp <= $y1) {
                    $yp3 = $y1;
                } elsif ($yp3 > $y2 && $last_yp >= $y2) {
                    $yp3 = $y2;
                }
                if ($xp3 > $x2) {
                    $yp3 = ($yp3-$last_yp)*($x2-$last_xp)/($xp3-$last_xp)+$last_yp;
                    $xp3 = $x2;
                }
                if ($yp3 < $y1) {
                    $xp0 = ($xp3-$last_xp)*($y1-$last_yp)/($yp3-$last_yp)+$last_xp;
                    $yp0 = $yp3 = $y1;
                    $add_pt0 = 1;
                } elsif ($yp3 > $y2) {
                    $xp0 = ($xp3-$last_xp)*($y2-$last_yp)/($yp3-$last_yp)+$last_xp;
                    $yp0 = $yp3 = $y2;
                    $add_pt0 = 1;
                }
                push (@coords, $xp0, $yp0) if ($add_pt0);
                push (@coords, $xp3, $yp3);
                if ($ns == $#seglist && $xp3 != $x2 && $xp2 > $xp3) {
                    push (@coords, &min($x2, $xp2), $yp3);
                }
                $np++;
                $last_xp = $xp3;
                $last_yp = $yp3;
                last if ($xp3 >= $x2);

            } else {
                if ($slope[$jb] == 0 || $gr_props{$id}{wl_style} =~ /Flat surface/i) {
                    $yp1 = $y2 -($y2-$y1)*($wsel-$ymin)/$yrange;
                    $xp1 = &max($x1, &min($x2, $xp1));
                    $xp2 = &max($x1, &min($x2, $xp2));
                    $yp1 = $yp2 = &max($y1, &min($y2, $yp1));
                } else {
#                   When a branch joins mid-segment, need to account for that.
#                   Array seglist is ds to us, so normal progression is to decreasing segment numbers.
                    if ($ns < $#seglist && $i != $us[$jb] && $seglist[$ns+1] != $i-1) {
                        $yp1 = $y2 -($y2-$y1)*($wsel-($xd2-$xd1)*1000.*$slope[$jb]-$ymin)/$yrange;
                        $yp2 = $y2 -($y2-$y1)*($wsel-$ymin)/$yrange;
                    } else {
                        $yp1 = $y2 -($y2-$y1)*($wsel-0.5*($xd2-$xd1)*1000.*$slope[$jb]-$ymin)/$yrange;
                        $yp2 = $y2 -($y2-$y1)*($wsel+0.5*($xd2-$xd1)*1000.*$slope[$jb]-$ymin)/$yrange;
                    }
                    if ($xp1 < $x1) {
                        $yp1 = ($yp2-$yp1)*($x1-$xp1)/($xp2-$xp1)+$yp1;
                        $xp1 = $x1;
                    }
                    if ($xp2 > $x2) {
                        $yp2 = ($yp2-$yp1)*($x2-$xp1)/($xp2-$xp1)+$yp1;
                        $xp2 = $x2;
                    }
                    if ($yp1 < $y1 && $yp2 < $y1) {
                        $yp1 = $yp2 = $y1;
                    } elsif ($yp1 > $y2 && $yp2 > $y2) {
                        $yp1 = $yp2 = $y2;
                    }
                    if ($yp1 < $y1) {
                        $xp0 = $xp1;
                        $yp0 = $y1;
                        $xp1 = ($xp2-$xp1)*($y1-$yp1)/($yp2-$yp1)+$xp1;
                        $yp1 = $y1;
                        $add_pt0 = 1;
                    } elsif ($yp1 > $y2) {
                        $xp0 = $xp1;
                        $yp0 = $y2;
                        $xp1 = ($xp2-$xp1)*($y2-$yp1)/($yp2-$yp1)+$xp1;
                        $yp1 = $y2;
                        $add_pt0 = 1;
                    }
                    if ($yp2 < $y1) {
                        $xp3 = $xp1;
                        $yp3 = $y1;
                        $xp2 = ($xp2-$xp1)*($y1-$yp1)/($yp2-$yp1)+$xp1;
                        $yp2 = $y1;
                        $add_pt3 = 1;
                    } elsif ($yp2 > $y2) {
                        $xp3 = $xp1;
                        $yp3 = $y2;
                        $xp2 = ($xp2-$xp1)*($y2-$yp1)/($yp2-$yp1)+$xp1;
                        $yp2 = $y2;
                        $add_pt3 = 1;
                    }
                }
                push (@coords, $xp0, $yp0) if ($add_pt0);
                push (@coords, $xp1, $yp1, $xp2, $yp2);
                push (@coords, $xp3, $yp3) if ($add_pt3);
                $np++;
            }
        }
        if ($#coords > 2) {
            if ($gr_props{$id}{xflip}) {   # Flip the x values, if necessary
                for ($n=0; $n<$#coords; $n+=2) {
                    $coords[$n] = $x2 -($coords[$n] -$x1);
                }
            }
            $canv->create_line(@coords, -fill  => &get_rgb_code($gr_props{$id}{wl_color}),
                                        -width => 1,
                                        -arrow => 'none',
                                        -tags  => $gtag . " " . $gtag . "_wlevels");
        }
    }
    undef %wl_data;

#   Plot a no-data message
    if (! $data_available || $np == 0) {
        $canv->create_text(($x1+$x2)/2., ($y1 +$y2)/2.,
                           -anchor => 'center',
                           -text   => "No Data",
                           -fill   => &get_rgb_code("gray60"),
                           -angle  => 0,
                           -tags   => $gtag . " " . $gtag . "_wlevels",
                           -font   => [-family     => $gr_props{$id}{xfont},
                                       -size       => $gr_props{$id}{xl_size},
                                       -weight     => 'normal',
                                       -slant      => 'roman',
                                       -underline  => 0,
                                       -overstrike => 0,
                                      ]);
    }

#   Place the graphic items in the proper order
    &raise_lower($canv, $id, "tiptop") if ($new_graph);
    $canv->lower($gtag . "_date",       $id);
    $canv->lower($gtag . "_gtitle",     $id);
    $canv->lower($gtag . "_wlgrid",     $id);
    $canv->lower($gtag . "_sgrid",      $id);
    $canv->lower($gtag . "_xaxisTitle", $id);
    $canv->lower($gtag . "_saxisTitle", $id);
    $canv->lower($gtag . "_yaxisTitle", $id);
    $canv->lower($gtag . "_wlevels",    $id);
    $canv->lower($gtag . "_xaxis",      $id);
    $canv->lower($gtag . "_saxis",      $id);
    $canv->lower($gtag . "_yaxis",      $id);
    if ($group_tags) {
        foreach $tag (@grp_tags) {
            $canv->addtag($tag, withtag => $gtag);
        }
    }

#   Update any links
#xxx &update_links($canv, $id, $dt);
}


sub make_ts_graph {
    my ($canv, $id, $props_updated) = @_;
    my (
        $add_date_pts, $add_dateline, $base_jd, $box_id, $date, $dt,
        $flow, $group_tags, $gtag, $i, $id2, $jd, $jd_max, $jd_min,
        $link_id, $min_major, $n, $ne, $new_graph, $num_hidden, $power,
        $range, $resized, $tag, $ts_state, $ws_elev, $wt, $x1, $x2, $xp,
        $y1, $y2, $ymax, $ymin, $yp, $yr_max, $yr_min,

        @add_ts_byear, @add_ts_color, @add_ts_ctype, @add_ts_file,
        @add_ts_ftype, @add_ts_lines, @add_ts_param, @add_ts_seg,
        @add_ts_setnum, @add_ts_show, @add_ts_text, @add_ts_tzoff,
        @add_ts_width, @color, @coords, @flows, @grp_tags, @items,
        @legend_entry, @names, @old_coords, @points, @qstr, @show, @tags,
        @tstr, @width,

        %add_ts_parms, %axis_props, %legend_props, %parms, %profile,
        %qdata, %tdata, %wsurf,
       );

    %profile = ();

#   Make tag and get coordinates of graph frame
    $gtag   = "graph" . $id;
    @coords = @{ $props{$id}{coordlist} };
    ($x1, $y1, $x2, $y2) = @coords;

#   Determine whether group tags are present and save the list
    $group_tags = 0;
    @grp_tags   = ();
    @tags       = Tkx::SplitList($canv->itemcget($id, -tags));
    if (&list_search("group_", @tags) > -1) {
        $group_tags = 1;
        foreach $tag (@tags) {
            push (@grp_tags, $tag) if ($tag =~ /^group_/);
        }
    }

#   Unpack some parameters
    %parms = %{ $props{$id}{ts_parms} };
    if (defined($props{$id}{add_ts_parms})) {
        %add_ts_parms  = %{ $props{$id}{add_ts_parms} };
        @add_ts_setnum = @{ $add_ts_parms{ts_setnum}  };
        @add_ts_file   = @{ $add_ts_parms{ts_file}    };
        @add_ts_show   = @{ $add_ts_parms{ts_show}    };
        @add_ts_width  = @{ $add_ts_parms{ts_width}   };
        @add_ts_color  = @{ $add_ts_parms{ts_color}   };
        @add_ts_text   = @{ $add_ts_parms{ts_text}    };
        @add_ts_ftype  = @{ $add_ts_parms{ts_ftype}   };
        @add_ts_lines  = @{ $add_ts_parms{ts_lines}   };
        @add_ts_param  = @{ $add_ts_parms{ts_param}   };
        @add_ts_byear  = @{ $add_ts_parms{ts_byear}   };
        @add_ts_tzoff  = @{ $add_ts_parms{ts_tzoff}   };
        @add_ts_seg    = @{ $add_ts_parms{ts_seg}     };
        @add_ts_ctype  = @{ $add_ts_parms{ts_ctype}   };
    }

#   Make sure a linked time-series graph is tagged with its linked source
    if ($props{$id}{meta} eq "linked_time_series") {
        $link_id = $props{$id}{link_id};
        @show    = @{ $parms{show}  };
        @width   = @{ $parms{width} };
        @color   = @{ $parms{color} };
        $canv->addtag("tslink_gr" . $link_id, withtag => $id);
    }

#   First time here
    if (! defined($props{$id}{data}) || ! $props{$id}{data}) {
        if (defined($parms{ts_type}) && $parms{ts_type} ne "") {
            if ($parms{ts_type} eq "Temperature") {
                $profile{ytitle} = "Temperature, in degrees " . $parms{units};
            } else {
                $profile{ytitle} = $parms{ts_type} . ", in " . $parms{units};
            }
            $profile{gtitle} = $parms{ts_type} . " Time Series";
        } else {
            $profile{ytitle} = "";
            $profile{gtitle} = "";
        }
        $profile{ymin}      = $parms{ymin};
        $profile{ymax}      = $parms{ymax};
        $profile{xmin}      = $parms{xmin};
        $profile{xmax}      = $parms{xmax};
        $profile{base_yr}   = $parms{base_yr} if (defined($parms{base_yr}));
        $profile{xtype}     = (defined($parms{xtype})) ? $parms{xtype} : "Date/Time";
        if ($profile{xtype} eq "Julian Date") {
            $profile{xtitle} = "Julian Date";
            $profile{xmajor} = "auto";
        }
        $profile{gap_tol}   = 2.0;

        $profile{yfont}     = $default_family;
        $profile{yl_size}   = &min(11, &max(8, int((abs($x2-$x1)+abs($y2-$y1))/2./41)));
        $profile{yt_size}   = $profile{yl_size} +2;
        $profile{yl_weight} = 'normal';
        $profile{yt_weight} = 'normal';
        $profile{ymajor}    = "auto";
        $profile{ypr_tics}  = "outside";
        $profile{yop_tics}  = "none";

        $profile{xfont}     = $profile{yfont};
        $profile{xl_size}   = $profile{yl_size};
        $profile{xt_size}   = $profile{yt_size};
        $profile{xl_weight} = $profile{yl_weight};
        $profile{xt_weight} = $profile{yt_weight};
        $profile{xmajor}    = "auto";
        $profile{xpr_tics}  = "outside";
        $profile{xop_tics}  = "none";
        if (&datelabel2jdate($profile{xmax}) - &datelabel2jdate($profile{xmin}) > 365 *4) {
            $profile{datefmt} = "Year";
        } else {
            $profile{datefmt} = "Month";
        }
        $profile{dateline}  = 0;
        $profile{datelinec} = "black";

        $profile{gtfont}    = $profile{yfont};
        $profile{gt_size}   = $profile{yt_size};
        $profile{gt_weight} = 'bold';

        $profile{legfont}   = $default_family;
        $profile{le_size}   = $profile{yl_size};
        $profile{lt_size}   = $profile{yl_size} +2;
        $profile{le_weight} = 'normal';
        $profile{lt_weight} = 'bold';
        $profile{le_edge}   = 0;
        $profile{le_edgec}  = "black";
        $profile{le_fill}   = 0;
        $profile{le_fillc}  = "white";
        $profile{xleg_off}  = 18;
        $profile{yleg_off}  =  0;
        $profile{legtitle}  = "";

        $profile{gridx}     = 0;
        $profile{gridy}     = 0;
        $profile{gridwidth} = 1;
        $profile{gridcolor} = '#C0C0C0';

        $profile{redraw}    = 1;
        $gr_props{$id}      = { %profile };
        $props{$id}{data}   = 1;
        $props{$id}{gnum}   = ++$graph_num;
        $resized = 0;
        undef %profile;

#   Or use previously saved info.  If resized, delete graph and redraw
    } else {
        @old_coords = @{ $props{$id}{oldcoords} };
        $resized = 0;
        for ($i=0; $i<=$#coords; $i++) {
            if ($coords[$i] != $old_coords[$i]) {
                $resized = 1;
                last;
            }
        }
        return if (! $resized && ! $props_updated);
        $gr_props{$id}{redraw} = 1 if ($resized);

        $canv->delete($gtag . "_xaxis");
        $canv->delete($gtag . "_xaxisTitle");
        $canv->delete($gtag . "_yaxis");
        $canv->delete($gtag . "_yaxisTitle");
        $canv->delete($gtag . "_grid");
        $canv->delete($gtag . "_gtitle");
        $canv->delete($gtag . "_legend");
        $canv->delete($gtag . "_dateline");
        if ($gr_props{$id}{redraw}) {
            $canv->delete($gtag . "_tsData");
            $canv->delete($gtag . "_datePoint");
        }
    }
    $props{$id}{oldcoords} = [ @coords ];

#   Keep track of graphs that can be animated
#   Linked time-series graphs only get a bit of animation
#   Regular time-series graphs may get a vertical dateline
    if ($props{$id}{meta} =~ /^(linked_time_series|time_series)$/) {
        if (&list_match($id, @animate_ids) == -1) {
            push (@animate_ids, $id);
        }
    }

#   Plot a white rectangle below the graph frame
    @items     = Tkx::SplitList($canv->find_withtag($gtag . "_main"));
    $new_graph = ($#items >= 0) ? 0 : 1;
    if ($new_graph) {
        $box_id = $canv->create_rectangle($x1, $y1, $x2, $y2,
                             -outline => "",
                             -width   => 0,
                             -fill    => &get_rgb_code("white"),
                             -tags    => $gtag . " " . $gtag . "_main");
        $canv->lower($box_id, $id);
    } else {
        $canv->coords($gtag . "_main", @coords);
        $canv->raise($id, $gtag . "_main");
    }

#   Plot the graph title
    $xp = ($x1+$x2)/2.;
    $yp = ($gr_props{$id}{xop_tics} =~ /outside|cross/) ? $y1-18 : $y1-10;
    $canv->create_text($xp, $yp,
                       -anchor => 's', 
                       -text   => $gr_props{$id}{gtitle},
                       -fill   => &get_rgb_code("black"),
                       -angle  => 0,
                       -tags   => $gtag . " " . $gtag . "_gtitle",
                       -font   => [-family     => $gr_props{$id}{gtfont},
                                   -size       => $gr_props{$id}{gt_size},
                                   -weight     => $gr_props{$id}{gt_weight},
                                   -slant      => 'roman',
                                   -underline  => 0,
                                   -overstrike => 0,
                                  ]);

#   Determine an optimal Y major tick spacing, if needed
    if ($gr_props{$id}{ymajor} eq "auto") {
        $range     = $gr_props{$id}{ymax} -$gr_props{$id}{ymin};
        $power     = (&log10($range) < 1) ? abs(&floor(&log10($range))) +1 : 0;
        $range    *= 10**$power;
        $min_major = int($range *($gr_props{$id}{yl_size} *3) /abs($y2-$y1) +0.0000001);
        $min_major = 1 if ($min_major == 0);
        for ($i=$min_major; $i<=$range/5; $i++) {
            $gr_props{$id}{ymajor} = $i /(10**$power) if (&round_to_int($range) % $i == 0);
        }
        $gr_props{$id}{ymajor} = $min_major /(10**$power) if ($gr_props{$id}{ymajor} eq "auto");
    }

#   Plot Y axis
    $axis_props{min}     = $gr_props{$id}{ymin};
    $axis_props{max}     = $gr_props{$id}{ymax};
    $axis_props{major}   = $gr_props{$id}{ymajor};
    $axis_props{pr_tics} = $gr_props{$id}{ypr_tics};
    $axis_props{op_tics} = $gr_props{$id}{yop_tics};
    $axis_props{minor}   = 1;
    $axis_props{reverse} = 0;
    $axis_props{grid}    = $gr_props{$id}{gridy};
    $axis_props{grwidth} = $gr_props{$id}{gridwidth};
    $axis_props{grcolor} = $gr_props{$id}{gridcolor};
    $axis_props{grcoord} = [$x1, $x2];
    $axis_props{title}   = $gr_props{$id}{ytitle};
    $axis_props{font}    = $gr_props{$id}{yfont};
    $axis_props{size1}   = $gr_props{$id}{yl_size};
    $axis_props{size2}   = $gr_props{$id}{yt_size};
    $axis_props{weight1} = $gr_props{$id}{yl_weight};
    $axis_props{weight2} = $gr_props{$id}{yt_weight};
    $axis_props{side}    = "left";
    $axis_props{tags}    = $gtag . " " . $gtag . "_yaxis";
    $axis_props{coords}  = [$x1, $y2, $x1, $y1];
    $axis_props{op_loc}  = $x2;
    &make_axis($canv, %axis_props);
    undef %axis_props;

#   Plot X axis -- Date/Time or Julian Date
    $axis_props{major}   = $gr_props{$id}{xmajor};
    $axis_props{pr_tics} = $gr_props{$id}{xpr_tics};
    $axis_props{op_tics} = $gr_props{$id}{xop_tics};
    $axis_props{minor}   = 1;
    $axis_props{reverse} = 0;
    $axis_props{grid}    = $gr_props{$id}{gridx};
    $axis_props{grwidth} = $gr_props{$id}{gridwidth};
    $axis_props{grcolor} = $gr_props{$id}{gridcolor};
    $axis_props{grcoord} = [$y1, $y2];
    $axis_props{font}    = $gr_props{$id}{xfont};
    $axis_props{size1}   = $gr_props{$id}{xl_size};
    $axis_props{size2}   = $gr_props{$id}{xt_size};
    $axis_props{weight1} = $gr_props{$id}{xl_weight};
    $axis_props{weight2} = $gr_props{$id}{xt_weight};
    $axis_props{side}    = "bottom";
    $axis_props{tags}    = $gtag . " " . $gtag . "_xaxis";
    $axis_props{coords}  = [$x1, $y2, $x2, $y2];
    $axis_props{op_loc}  = $y1;
    if ($gr_props{$id}{xtype} eq "Date/Time") {
        $jd_min = &datelabel2jdate($gr_props{$id}{xmin});
        $jd_max = &datelabel2jdate($gr_props{$id}{xmax});
        $yr_min = substr($gr_props{$id}{xmin},7,4);
        $yr_max = substr($gr_props{$id}{xmax},7,4);
        $yr_max-- if (substr($gr_props{$id}{xmax},0,3) eq "Jan" &&
                      substr($gr_props{$id}{xmax},4,2) eq "01");
        if ($yr_min == $yr_max) {
            $gr_props{$id}{xtitle} = "Date in $yr_min";
        } else {
            $gr_props{$id}{xtitle} = "Date ($yr_min-$yr_max)";
        }
        $axis_props{min}     = $jd_min;
        $axis_props{max}     = $jd_max;
        $axis_props{title}   = $gr_props{$id}{xtitle};
        $axis_props{datefmt} = $gr_props{$id}{datefmt};
        &make_date_axis($canv, %axis_props);
    } else {
        $axis_props{min}   = $gr_props{$id}{xmin};
        $axis_props{max}   = $gr_props{$id}{xmax};
        $axis_props{title} = $gr_props{$id}{xtitle};

        if ($gr_props{$id}{xmajor} eq "auto") {
            $range     = $gr_props{$id}{xmax} -$gr_props{$id}{xmin};
            $power     = (&log10($range) < 1) ? abs(&floor(&log10($range))) +1 : 0;
            $range    *= 10**$power;
            $min_major = int($range *($gr_props{$id}{xl_size} *3) /abs($x2-$x1) +0.0000001);
            $min_major = 1 if ($min_major == 0);
            for ($i=$min_major; $i<=$range/5; $i++) {
                $gr_props{$id}{xmajor} = $i /(10**$power) if (&round_to_int($range) % $i == 0);
            }
            $gr_props{$id}{xmajor} = $min_major /(10**$power) if ($gr_props{$id}{xmajor} eq "auto");
        }
        &make_axis($canv, %axis_props);

        $base_jd = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
        $jd_min  = $gr_props{$id}{xmin} +$base_jd -1;
        $jd_max  = $gr_props{$id}{xmax} +$base_jd -1;
    }
    undef %axis_props;

#   Add a legend
    $legend_props{xpos}    = $x2 +$gr_props{$id}{xleg_off};
    $legend_props{ypos}    = $y1 +$gr_props{$id}{yleg_off};
    $legend_props{title}   = $gr_props{$id}{legtitle};
    $legend_props{font}    = $gr_props{$id}{legfont};
    $legend_props{esize}   = $gr_props{$id}{le_size};
    $legend_props{tsize}   = $gr_props{$id}{lt_size};
    $legend_props{eweight} = $gr_props{$id}{le_weight};
    $legend_props{tweight} = $gr_props{$id}{lt_weight};
    $legend_props{edge}    = $gr_props{$id}{le_edge};
    $legend_props{edgec}   = $gr_props{$id}{le_edgec};
    $legend_props{fill}    = $gr_props{$id}{le_fill};
    $legend_props{fillc}   = $gr_props{$id}{le_fillc};

    $ne = 0;
    @legend_entry = ();
    if ($props{$id}{meta} eq "linked_time_series") {
        if ($parms{ts_type} eq "Water Surface Elevation") {
            $legend_entry[0]{text}  = "WS Elev";
            $legend_entry[0]{width} = $width[0];
            $legend_entry[0]{color} = $color[0];
            $ne = 1;
        } else {
            if ($props{$link_id}{meta} eq "vert_wd_zone") {
                @names = @{ $gr_props{$link_id}{names} };
                push (@names, "All Outlets");
            } elsif ($props{$link_id}{meta} eq "w2_outflow") {
                @names = ("All Outlets");
            }
            for ($n=0; $n<=$#names; $n++) {
                if ($show[$n]) {
                    $legend_entry[$ne]{text}  = ($#names > 0) ? $names[$n] : $parms{ts_type};
                    $legend_entry[$ne]{width} = $width[$n];
                    $legend_entry[$ne]{color} = $color[$n];
                    $ne++;
                }
            }
        }
    }
    $legend_props{num}     = $ne;
    $legend_props{entries} = [ @legend_entry ];
    $legend_props{tags}    = $gtag . " " . $gtag . "_legend";
    &make_ts_legend($canv, %legend_props);
    undef %legend_props;

#   Plot the optional dateline
    if ($gr_props{$id}{dateline}) {
        $add_dateline = 0;
        for ($i=0; $i<=$#animate_ids; $i++) {
            $id2 = $animate_ids[$i];
            next if ($id2 == $id);
            next if ($props{$id2}{meta}
                       !~ /^(data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)$/);
            if ($dti != 1) {
                $add_dateline = 1;
                last;
            }
        }
        if ($add_dateline) {
            $jd = &date2jdate($dates[$dti-1]);
            if ($jd >= $jd_min && $jd <= $jd_max) {
                $xp = $x1 +($x2 -$x1) *($jd -$jd_min)/($jd_max -$jd_min);
                $canv->create_line($xp, $y1, $xp, $y2,
                                   -fill  => &get_rgb_code($gr_props{$id}{datelinec}),
                                   -width => 1,
                                   -arrow => 'none',
                                   -tags  => $gtag . " " . $gtag . "_dateline");
            }
        }
    }

#   Don't recompute and redraw unless necessary
    if (! $gr_props{$id}{redraw}) {

#       Update widths and colors, if needed
        if ($props{$id}{meta} eq "linked_time_series") {
            if ($parms{ts_type} eq "Water Surface Elevation") {
                @items = Tkx::SplitList($canv->find_withtag($gtag . "_dataset0"));
                if ($#items >= 0) {
                    $canv->itemconfigure($gtag . "_dataset0",
                                         -width => $width[0],
                                         -fill  => &get_rgb_code($color[0]));
                }
                @items = Tkx::SplitList($canv->find_withtag($gtag . "_dataPoint0"));
                if ($#items >= 0) {
                    $canv->itemconfigure($gtag . "_dataPoint0",
                                         -fill  => &get_rgb_code($color[0]));
                }
            } else {
                for ($n=0; $n<=$#names; $n++) {
                    $ts_state = ($show[$n]) ? 'normal' : 'hidden';
                    @items = Tkx::SplitList($canv->find_withtag($gtag . "_dataset" . $n));
                    if ($#items >= 0) {
                        $canv->itemconfigure($gtag . "_dataset" . $n,
                                             -state => $ts_state,
                                             -width => $width[$n],
                                             -fill  => &get_rgb_code($color[$n]));
                    }
                    @items = Tkx::SplitList($canv->find_withtag($gtag . "_dataPoint" . $n));
                    if ($#items >= 0) {
                        $canv->itemconfigure($gtag . "_dataPoint" . $n,
                                             -state => $ts_state,
                                             -fill  => &get_rgb_code($color[$n]));
                    }
                }
            }
        }

#       Add legend entries and update widths and colors of other datasets, if needed
        if (defined($props{$id}{add_ts_parms})) {
            $num_hidden = 0;
            for ($i=0; $i<=$#add_ts_setnum; $i++) {
                $n = $add_ts_setnum[$i];
                if ($add_ts_show[$i]) {
                    $xp  = $x2 +$gr_props{$id}{xleg_off};
                    $yp  = $y1 +$gr_props{$id}{yleg_off};
                    $yp += $gr_props{$id}{lt_size} *1.5 if ($gr_props{$id}{legtitle} ne "");
                    $yp += ($i -$num_hidden +$ne) *$gr_props{$id}{le_size} *1.5;
                    $canv->create_line($xp, $yp, $xp+20, $yp,
                                       -fill   => &get_rgb_code($add_ts_color[$i]),
                                       -width  => $add_ts_width[$i],
                                       -arrow  => 'none',
                                       -tags   => $gtag . " " . $gtag . "_legend");
                    $canv->create_text($xp+25, $yp,
                                       -anchor => 'w',
                                       -text   => $add_ts_text[$i],
                                       -fill   => &get_rgb_code("black"),
                                       -angle  => 0,
                                       -tags   => $gtag . " " . $gtag . "_legend",
                                       -font   => [-family     => $gr_props{$id}{legfont},
                                                   -size       => $gr_props{$id}{le_size},
                                                   -weight     => $gr_props{$id}{le_weight},
                                                   -slant      => 'roman',
                                                   -underline  => 0,
                                                   -overstrike => 0,
                                                  ]);
                    $canv->itemconfigure($gtag . "_dataLine" . $n,
                                         -state => 'normal',
                                         -width => $add_ts_width[$i],
                                         -fill  => &get_rgb_code($add_ts_color[$i]));
                    $canv->itemconfigure($gtag . "_dataPoint" . $n,
                                         -state   => 'normal',
                                         -outline => &get_rgb_code($add_ts_color[$i]),
                                         -fill    => "");
                } else {
                    $num_hidden++;
                    $canv->itemconfigure($gtag . "_dataset" . $n,
                                         -state => 'hidden');
                }
            }

#           Update the legend box, if needed
            &update_legend_box($canv, $id);
        }
        $canv->lower($gtag . "_gtitle",     $id);
        $canv->lower($gtag . "_grid",       $id);
        $canv->lower($gtag . "_xaxisTitle", $id);
        $canv->lower($gtag . "_yaxisTitle", $id);
        $canv->lower($gtag . "_dateline",   $id);
        $canv->lower($gtag . "_legend",     $id);
        $canv->lower($gtag . "_tsData",     $id);
        $canv->lower($gtag . "_datePoint",  $id);
        $canv->lower($gtag . "_xaxis",      $id);
        $canv->lower($gtag . "_yaxis",      $id);
        @items = Tkx::SplitList($canv->find_withtag($gtag . "_legend"));
        if ($#items >= 0) {
            $canv->lower($gtag . "_legendBox", $gtag . "_legend");
        }
        @items = Tkx::SplitList($canv->find_withtag($gtag . "_tsData"));
        if ($#items >= 0) {
            $canv->lower($id, $gtag . "_tsData");    # plot datasets above graph frame
        }
        if ($group_tags) {
            foreach $tag (@grp_tags) {
                $canv->addtag($tag, withtag => $gtag);
            }
        }
        return;
    }

#   Plot the data
    $ymin = $gr_props{$id}{ymin};
    $ymax = $gr_props{$id}{ymax};

    if ($props{$id}{meta} eq "linked_time_series") {
        if ($parms{ts_type} eq "Water Surface Elevation") {
            if ($props{$link_id}{meta} =~ /^(data_profile|vert_wd_zone)$/) {
                %wsurf = %{ $gr_props{$link_id}{ws_elev} };
            } elsif ($props{$link_id}{meta} eq "w2_profile") {
                %wsurf = %{ $gr_props{$link_id}{elev_data} };
            } elsif ($props{$link_id}{meta} eq "w2_outflow") {
                %qdata = %{ $gr_props{$link_id}{qdata} };
                %wsurf = ();
                foreach $date (keys %qdata) {
                    @flows = @{ $qdata{$date} };
                    $wsurf{$date} = $flows[1];
                }
                undef %qdata;
                undef @flows;
            }
            @points = ();
            foreach $date (@dates) {
                $jd = &date2jdate($date);
                next if ($jd < $jd_min);
                last if ($jd > $jd_max);
                $xp = $x1 +($x2 -$x1) *($jd -$jd_min) /($jd_max -$jd_min);
                if (defined($wsurf{$date}) && $wsurf{$date} ne "na") {
                    $ws_elev  = $wsurf{$date};
                    $ws_elev *= 3.28084 if ($parms{units} eq "ft");
                    $yp = $y2 -($y2 -$y1) *($ws_elev -$ymin) /($ymax -$ymin);
                    $yp = &min($y2, &max($y1, $yp));
                    push (@points, $xp, $yp);
                } else {
                    if ($#points > 1) {
                        $canv->create_line(@points,
                                        -fill  => &get_rgb_code($color[0]),
                                        -width => $width[0],
                                        -arrow => 'none',
                                        -tags  => $gtag . " " . $gtag . "_tsData"
                                                        . " " . $gtag . "_dataset0");
                    }
                    @points = ();
                }
            }
            if ($#points > 1) {
                $canv->create_line(@points,
                                -fill  => &get_rgb_code($color[0]),
                                -width => $width[0],
                                -arrow => 'none',
                                -tags  => $gtag . " " . $gtag . "_tsData"
                                                . " " . $gtag . "_dataset0");
            }

        } elsif ($parms{ts_type} eq "Release Rate") {
            %qdata = %{ $gr_props{$link_id}{qdata} };
            for ($n=0; $n<=$#names; $n++) {
                $ts_state = ($show[$n]) ? 'normal' : 'hidden';
                @points = ();
                foreach $date (@dates) {
                    $jd = &date2jdate($date);
                    next if ($jd < $jd_min);
                    last if ($jd > $jd_max);
                    $xp = $x1 +($x2 -$x1) *($jd -$jd_min) /($jd_max -$jd_min);
                    if (defined($qdata{$date})) {
                        @qstr = @{ $qdata{$date} };
                        if ($props{$link_id}{meta} eq "w2_outflow") {
                            $flow = $qstr[0];
                        } else {
                            if ($names[$n] eq "All Outlets") {
                                $flow = &sum(@qstr);
                            } else {
                                $flow = $qstr[$n];
                            }
                        }
                        $flow *= 35.31467 if ($parms{units} eq "cfs");
                        $yp = $y2 -($y2 -$y1) *($flow -$ymin) /($ymax -$ymin);
                        $yp = &min($y2, &max($y1, $yp));
                        push (@points, $xp, $yp);
                    } else {
                        if ($#points > 1) {
                            $canv->create_line(@points,
                                            -fill  => &get_rgb_code($color[$n]),
                                            -width => $width[$n],
                                            -arrow => 'none',
                                            -state => $ts_state,
                                            -tags  => $gtag . " " . $gtag . "_tsData"
                                                            . " " . $gtag . "_dataset" . $n);
                        }
                        @points = ();
                    }
                }
                if ($#points > 1) {
                    $canv->create_line(@points,
                                    -fill  => &get_rgb_code($color[$n]),
                                    -width => $width[$n],
                                    -arrow => 'none',
                                    -state => $ts_state,
                                    -tags  => $gtag . " " . $gtag . "_tsData"
                                                    . " " . $gtag . "_dataset" . $n);
                }
            }

        } elsif ($parms{ts_type} eq "Temperature") {      # only for vert_wd_zone
            if (! defined($gr_props{$link_id}{tready})) {
                &generate_outflow_temps($link_id, $id);   # generate the temps, if needed
                $gr_props{$link_id}{tready} = 1;
            }
            %tdata = %{ $gr_props{$link_id}{tdata} };
            for ($n=0; $n<=$#names; $n++) {
                $ts_state = ($show[$n]) ? 'normal' : 'hidden';
                @points = ();
                foreach $date (@dates) {
                    $jd = &date2jdate($date);
                    next if ($jd < $jd_min);
                    last if ($jd > $jd_max);
                    $xp = $x1 +($x2 -$x1) *($jd -$jd_min) /($jd_max -$jd_min);
                    if (defined($tdata{$date})) {
                        @tstr = @{ $tdata{$date} };
                        $wt = $tstr[$n];
                        if ($wt > -99) {
                            $wt = 1.8 *$wt +32 if ($parms{units} eq "Fahrenheit");
                            $yp = $y2 -($y2 -$y1) *($wt -$ymin) /($ymax -$ymin);
                            $yp = &min($y2, &max($y1, $yp));
                            push (@points, $xp, $yp);
                        } else {
                            if ($#points > 1) {
                                $canv->create_line(@points,
                                                -fill  => &get_rgb_code($color[$n]),
                                                -width => $width[$n],
                                                -arrow => 'none',
                                                -state => $ts_state,
                                                -tags  => $gtag . " " . $gtag . "_tsData"
                                                                . " " . $gtag . "_dataset" . $n);
                            }
                            @points = ();
                        }
                    } else {
                        if ($#points > 1) {
                            $canv->create_line(@points,
                                            -fill  => &get_rgb_code($color[$n]),
                                            -width => $width[$n],
                                            -arrow => 'none',
                                            -state => $ts_state,
                                            -tags  => $gtag . " " . $gtag . "_tsData"
                                                            . " " . $gtag . "_dataset" . $n);
                        }
                        @points = ();
                    }
                }
                if ($#points > 1) {
                    $canv->create_line(@points,
                                    -fill  => &get_rgb_code($color[$n]),
                                    -width => $width[$n],
                                    -arrow => 'none',
                                    -state => $ts_state,
                                    -tags  => $gtag . " " . $gtag . "_tsData"
                                                    . " " . $gtag . "_dataset" . $n);
                }
            }
        }
    }

#   Add any other datasets previously provided by the user
    if (defined($props{$id}{add_ts_parms})) {
        for ($i=0; $i<=$#add_ts_setnum; $i++) {
            &plot_ts_data($canv, $id, $new_graph, $add_ts_show[$i], $add_ts_setnum[$i],
                          $add_ts_file[$i],  $add_ts_lines[$i], $add_ts_ftype[$i], $add_ts_param[$i],
                          $add_ts_width[$i], $add_ts_color[$i], $add_ts_text[$i],
                          $add_ts_byear[$i], $add_ts_tzoff[$i], $add_ts_seg[$i], $add_ts_ctype[$i]);
        }
    }

#   Add date highlighting, if necessary
    if ($props{$id}{meta} eq "linked_time_series") {
        $add_date_pts = 0;
        for ($i=0; $i<=$#animate_ids; $i++) {
            $id2 = $animate_ids[$i];
            next if ($id2 == $id);
            if ($props{$id2}{meta} =~ /^(data_profile|vert_wd_zone|w2_profile|w2_outflow)$/) {
                if ($props{$id}{link_id} == $id2 && $dti != 1) {
                    $add_date_pts = 1;
                    last;
                }
            }
        }
        if ($add_date_pts) {
            $dt = $dates[$dti-1];
            $jd = &date2jdate($dt);
            if ($jd >= $jd_min && $jd <= $jd_max) {
                $xp = $x1 +($x2 -$x1) *($jd -$jd_min)/($jd_max -$jd_min);

                if ($parms{ts_type} eq "Water Surface Elevation") {
                    if (defined($wsurf{$dt}) && $wsurf{$dt} ne "na") {
                        $ws_elev  = $wsurf{$dt};
                        $ws_elev *= 3.28084 if ($parms{units} eq "ft");
                        $yp = $y2 -($y2 -$y1) *($ws_elev -$ymin) /($ymax -$ymin);
                        $yp = &min($y2, &max($y1, $yp));
                        $canv->create_oval($xp-3, $yp-3, $xp+3, $yp+3,
                                        -outline => "#000000",
                                        -width   => 1,
                                        -fill    => &get_rgb_code($color[0]),
                                        -tags    => $gtag . " " . $gtag . "_tsData"
                                                          . " " . $gtag . "_datePoint"
                                                          . " " . $gtag . "_dataPoint0");
                    }
                } elsif ($parms{ts_type} eq "Release Rate") {
                    for ($n=0; $n<=$#names; $n++) {
                        $ts_state = ($show[$n]) ? 'normal' : 'hidden';
                        if (defined($qdata{$dt})) {
                            @qstr = @{ $qdata{$dt} };
                            if ($props{$link_id}{meta} eq "w2_outflow") {
                                $flow = $qstr[0];
                            } else {
                                if ($names[$n] eq "All Outlets") {
                                    $flow = &sum(@qstr);
                                } else {
                                    $flow = $qstr[$n];
                                }
                            }
                            $flow *= 35.31467 if ($parms{units} eq "cfs");
                            $yp = $y2 -($y2 -$y1) *($flow -$ymin) /($ymax -$ymin);
                            $yp = &min($y2, &max($y1, $yp));
                            $canv->create_oval($xp-3, $yp-3, $xp+3, $yp+3,
                                            -outline => "#000000",
                                            -width   => 1,
                                            -fill    => &get_rgb_code($color[$n]),
                                            -state   => $ts_state,
                                            -tags    => $gtag . " " . $gtag . "_tsData"
                                                              . " " . $gtag . "_datePoint"
                                                              . " " . $gtag . "_dataPoint" . $n);
                        }
                    }
                } elsif ($parms{ts_type} eq "Temperature") {
                    for ($n=0; $n<=$#names; $n++) {
                        $ts_state = ($show[$n]) ? 'normal' : 'hidden';
                        if (defined($tdata{$dt})) {
                            @tstr = @{ $tdata{$dt} };
                            $wt   = $tstr[$n];
                            if ($wt > -99) {
                                $wt = 1.8 *$wt +32 if ($parms{units} eq "Fahrenheit");
                                $yp = $y2 -($y2 -$y1) *($wt -$ymin) /($ymax -$ymin);
                                $yp = &min($y2, &max($y1, $yp));
                                $canv->create_oval($xp-3, $yp-3, $xp+3, $yp+3,
                                                -outline => "#000000",
                                                -width   => 1,
                                                -fill    => &get_rgb_code($color[$n]),
                                                -state   => $ts_state,
                                                -tags    => $gtag . " " . $gtag . "_tsData"
                                                                  . " " . $gtag . "_datePoint"
                                                                  . " " . $gtag . "_dataPoint" . $n);
                            }
                        }
                    }
                }
            }
        }
    }

#   Place the graphic items in the proper order
    &raise_lower($canv, $id, "tiptop") if ($new_graph);
    $canv->lower($gtag . "_gtitle",     $id);
    $canv->lower($gtag . "_grid",       $id);
    $canv->lower($gtag . "_xaxisTitle", $id);
    $canv->lower($gtag . "_yaxisTitle", $id);
    $canv->lower($gtag . "_dateline",   $id);
    $canv->lower($gtag . "_legend",     $id);
    $canv->lower($gtag . "_tsData",     $id);
    $canv->lower($gtag . "_datePoint",  $id);
    $canv->lower($gtag . "_xaxis",      $id);
    $canv->lower($gtag . "_yaxis",      $id);
    @items = Tkx::SplitList($canv->find_withtag($gtag . "_legend"));
    if ($#items >= 0) {
        $canv->lower($gtag . "_legendBox", $gtag . "_legend");
    }
    @items = Tkx::SplitList($canv->find_withtag($gtag . "_tsData"));
    if ($#items >= 0) {
        $canv->lower($id, $gtag . "_tsData");    # plot datasets above graph frame
    }
    if ($group_tags) {
        foreach $tag (@grp_tags) {
            $canv->addtag($tag, withtag => $gtag);
        }
    }
}


sub add_ts_data {
    my ($canv, $id, $X, $Y) = @_;
    my (
        $byear, $byear_cb, $byear_label, $byear_label2, $code, $color,
        $color_btn, $conv_add, $conv_add_entry, $conv_mult, $conv_mult_entry,
        $conv_type, $conv_type_cb, $create_btn, $custom_frame, $data_file,
        $data_type, $fg, $fmt, $frame, $geom, $indx, $item, $legend_txt,
        $link_id, $n, $new_data, $nlines, $offset_frame, $parm, $parm_cb,
        $parm_chars, $parm_label, $row, $segnum, $segnum_cb, $segnum_label,
        $setnum, $show_data, $ts_frame, $tz_offset, $tzoff_label, $width,
        $yr_max, $yr_min,

        @items, @names, @parmlist, @segs, @tags,

        %ts_parms,
       );

    &end_select($canv, $id, 1);

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($add_ts_data_menu) && Tkx::winfo_exists($add_ts_data_menu)) {
        if ($add_ts_data_menu->g_wm_title() eq "Add Time Series Data") {
            $add_ts_data_menu->g_destroy();
            undef $add_ts_data_menu;
        }
    }
    $add_ts_data_menu = $main->new_toplevel();
    $add_ts_data_menu->g_wm_transient($main);
    $add_ts_data_menu->g_wm_title("Add Time Series Data");
    $add_ts_data_menu->configure(-cursor => $cursor_norm);
    $add_ts_data_menu->g_wm_geometry($geom);

    %ts_parms    = %{ $props{$id}{ts_parms} };
    $data_type   = $ts_parms{ts_type};
    $data_file   = "";
    $width       = 1;
    $color       = 'red';
    $legend_txt  = "Add Legend";
    $segnum      = "";
    $setnum      = 0;
    $new_data    = 1;
    $show_data   = 1;
    $yr_max      = (localtime(time))[5] +1900;
    $yr_min      = $yr_max -25;
    $byear       = $yr_max;
    $tz_offset   = "+00:00";
    $nlines      = 0;
    $conv_type   = $conv_types[0];
    $conv_mult   = 1.0;
    $conv_add    = 0.0;
    $fmt         = "Undetermined";
    $parm        = "Unknown";
    @parmlist    = ();
    $parmlist[0] = $parm;
    $parm_chars  = length($parm) +2;
    @segs        = ();

#   Determine the dataset number for the time-series graph.
#   First count up the minimum number of potential datasets.
#   Then check to see if any other user-added datasets increases the number.
    if ($props{$id}{meta} eq "linked_time_series") {
        if ($data_type eq "Water Surface Elevation") {
            $setnum = 1;
        } elsif ($data_type eq "Release Rate") {
            $link_id = $props{$id}{link_id};
            if ($props{$link_id}{meta} eq "vert_wd_zone") {
                @names  = @{ $gr_props{$link_id}{names} };
                $setnum = $#names +2;
            } elsif ($props{$link_id}{meta} eq "w2_outflow") {
                @names  = ("All Outlets");
                $setnum = $#names +1;
            }
        } else {
            $link_id = $props{$id}{link_id};
            @names   = @{ $gr_props{$link_id}{names} };
            $setnum  = $#names +2;
        }
    }
    @items = Tkx::SplitList($canv->find_withtag("graph" . $id . "_tsData"));
    foreach $item (@items) {
        @tags = Tkx::SplitList($canv->gettags($item));
        $indx = &list_search("graph" . $id . "_dataset", @tags);
        if ($indx > -1) {
            ($n = $tags[$indx]) =~ s/graph${id}_dataset(\d+)/$1/;
            $setnum = $n +1 if ($n >= $setnum);
        }
    }

#   Create input menu
    $frame = $add_ts_data_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($create_btn = $frame->new_button(
            -text    => "Create",
            -state   => 'disabled',
            -command => sub { my ($tag, @tags);
                              if ($legend_txt eq "Add Legend" || $legend_txt eq "") {
                                  return &pop_up_error($add_ts_data_menu,
                                                       "Please add or edit the legend text.");
                              }
                              $add_ts_data_menu->g_destroy();
                              undef $add_ts_data_menu;
                              if ($conv_type eq "Custom") {
                                  $conv_type = sprintf("Custom,%s,%s", $conv_mult, $conv_add);
                              }
                              &plot_ts_data($canv, $id, $new_data, $show_data, $setnum,
                                            $data_file, $nlines, $fmt, $parm, $width, $color,
                                            $legend_txt, $byear, $tz_offset, $segnum, $conv_type);

#                             Add group tags
                              @tags = Tkx::SplitList($canv->itemcget($id, -tags));
                              if (&list_search("group_", @tags) > -1) {
                                  foreach $tag (@tags) {
                                      if ($tag =~ /^group_/) {
                                          $canv->addtag($tag, withtag => "graph" . $id);
                                      }
                                  }
                              }

#                             Refresh the Object Information box, if present
                              if (defined($object_infobox) && Tkx::winfo_exists($object_infobox)) {
                                  if ($object_infobox->g_wm_title() =~ /Object Info/) {
                                      $geom = $object_infobox->g_wm_geometry();
                                      (undef, $X, $Y) = split(/\+/, $geom);
                                      &show_info($canv, $id, $X, $Y);
                                  }
                              }
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $add_ts_data_menu->g_destroy();
                              undef $add_ts_data_menu; },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

    $ts_frame = $add_ts_data_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $ts_frame->g_pack(-side => 'top');

    $row = 0;
    $ts_frame->new_label(
            -text => "Data Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $ts_frame->new_label(
            -text   => $data_type,
            -font   => 'default',
            -anchor => 'w',
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');

    $row++;
    $ts_frame->new_label(
            -text => "Data File: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $ts_frame->new_label(
            -textvariable => \$data_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew');
    $ts_frame->new_button(
            -text    => "Browse",
            -command => sub { my ($file, $i, $segwidth, $segmax);
                              $file = Tkx::tk___getOpenFile(
                                      -parent     => $add_ts_data_menu,
                                      -title      => "Select Data File",
                                      -initialdir => abs_path(),
                                      -filetypes  => [ ['All Files',  '*'],
                                                       ['CSV (comma delimited)', '.csv'],
                                                     ],
                                      );
                              if ( $^O =~ /MSWin32/i ) {
                                  if (defined($file) && $file ne "") {
                                      $file =~ s/\//\\/g;
                                  }
                              }
                              if (defined($file) && $file ne "") {
                                  $data_file = $file;
                                  ($fmt, $nlines, @parmlist)
                                      = &determine_ts_type($add_ts_data_menu, $file);
                                  if ($fmt eq "") {
                                      $fmt         = "Undetermined";
                                      $parm        = "Unknown";
                                      @parmlist    = ();
                                      $parmlist[0] = $parm;
                                      $nlines      = 0;
                                      $data_file   = "";
                                  } else {
                                      $parm = $parmlist[0];
                                      $create_btn->configure(-state => 'normal');
                                  }
                                  $parm_chars = length($parmlist[0]);
                                  for ($i=1; $i<=$#parmlist; $i++) {
                                      if (length($parmlist[$i]) > $parm_chars) {
                                          $parm_chars = length($parmlist[$i]);
                                      }
                                  }
                                  $parm_chars += 2;
                                  $parm_cb->configure(-values => [ @parmlist ],
                                                      -width  => $parm_chars);
                                  if ($fmt !~ /^W2 /) {
                                      $byear_label->g_grid_remove();
                                      $byear_label2->g_grid_remove();
                                      $byear_cb->g_grid_remove();
                                      $tzoff_label->g_grid_remove();
                                      $offset_frame->g_grid_remove();
                                      $segnum_label->g_grid_remove();
                                      $segnum_cb->g_grid_remove();
                                      $parm_label->g_grid_remove();
                                      $parm_cb->g_grid();
                                  } else {
                                      $byear_label->g_grid();
                                      $byear_label2->g_grid();
                                      $byear_cb->g_grid();
                                      $tzoff_label->g_grid();
                                      $offset_frame->g_grid();
                                      if ($fmt eq "W2 Heat Fluxes format"
                                            || $fmt eq "W2 Water Level (wl) format"
                                            || $fmt =~ /^W2 .*daily .*Temp2?\.dat format$/i) {
                                          $segnum_label->g_grid();
                                          $segnum_cb->g_grid();
                                      } else {
                                          $segnum_label->g_grid_remove();
                                          $segnum_cb->g_grid_remove();
                                      }
                                      if ($fmt eq "W2 Heat Fluxes format"
                                            || $fmt =~ /^W2 .*daily .*Temp2?\.dat format$/i) {
                                          ($segmax, @segs) = &scan_w2_file4segs($add_ts_data_menu,
                                                                                $data_file, $fmt);
                                          $segwidth = 5;
                                          if ($#segs >= 0 && $segmax > 0) {
                                              $segwidth = &max(5, length($segmax));
                                          }
                                          $segnum_cb->configure(-values => [ @segs ],
                                                                -width  => $segwidth);
                                          if (&list_match($segnum, @segs) == -1) {
                                              $segnum = $segs[0];
                                          }
                                      }
                                      if ($fmt eq "W2 Water Level (wl) format") {
                                          @segs = @parmlist;
                                          $segnum_cb->configure(-values => [ @segs ],
                                                                -width  => $parm_chars);
                                          if (&list_match($segnum, @segs) == -1) {
                                              $segnum = $segs[0];
                                          }
                                          $parm_cb->g_grid_remove();
                                          $parm_label->g_grid();
                                          $parm = "Water Level";
                                      } else {
                                          $parm_label->g_grid_remove();
                                          $parm_cb->g_grid();
                                      }
                                  }
                              } else {
                                  $create_btn->configure(-state => 'disabled');
                              }
                            },
            )->g_grid(-row => $row, -column => 4, -sticky => 'ew', -padx => 2);

    $row++;
    $ts_frame->new_label(
            -text => "File Format: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $ts_frame->new_label(
            -textvariable => \$fmt,
            -anchor       => 'w',
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    ($segnum_label = $ts_frame->new_label(
            -text => "Segment: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($segnum_cb = $ts_frame->new_ttk__combobox(
            -textvariable => \$segnum,
            -values       => [ @segs ],
            -state        => 'readonly',
            -width        => 5,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    $ts_frame->new_label(
            -text => "Parameter: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($parm_label = $ts_frame->new_label(
            -text => "Water Level",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $parm_label->g_grid_remove();
    ($parm_cb = $ts_frame->new_ttk__combobox(
            -textvariable => \$parm,
            -values       => [ @parmlist ],
            -state        => 'readonly',
            -width        => $parm_chars,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    $ts_frame->new_label(
            -text => "Conversion: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($conv_type_cb = $ts_frame->new_ttk__combobox(
            -textvariable => \$conv_type,
            -values       => [ @conv_types ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $conv_type_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($conv_type eq "Custom") {
                                $custom_frame->g_grid();
                            } else {
                                $custom_frame->g_grid_remove();
                            }
                          }
                      );
    $row++;
    ($custom_frame = $ts_frame->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    $custom_frame->new_label(
            -text => "Multiply by: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_mult_entry = $custom_frame->new_entry(
            -textvariable => \$conv_mult,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_mult_entry->g_bind("<KeyRelease>",
                              sub { &numeric_entry_only($conv_mult_entry);
                                    my $chars = &max(7, length($conv_mult));
                                    $conv_mult_entry->configure(-width => $chars);
                                  });
    $custom_frame->new_label(
            -text => "  Then add: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_add_entry = $custom_frame->new_entry(
            -textvariable => \$conv_add,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_add_entry->g_bind("<KeyRelease>",
                             sub { &numeric_entry_only($conv_add_entry);
                                   my $chars = &max(7, length($conv_add));
                                   $conv_add_entry->configure(-width => $chars);
                                 });

    $row++;
    ($byear_label = $ts_frame->new_label(
            -text => "Base Year: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($byear_cb = $ts_frame->new_ttk__combobox(
            -textvariable => \$byear,
            -values       => [ reverse($yr_min .. $yr_max) ],
            -state        => 'readonly',
            -width        => 5,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $byear_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($byear == $yr_min) {
                                $yr_min -= 10;
                                $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                            }
                          }
                     );
    ($byear_label2 = $ts_frame->new_label(
            -text   => " for JDAY = 1.0",
            -anchor => 'w',
            -font   => 'default',
            ))->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    ($tzoff_label = $ts_frame->new_label(
            -text => "Time Offset: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($offset_frame = $ts_frame->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    $offset_frame->new_ttk__combobox(
            -textvariable => \$tz_offset,
            -values       => [ @tz_offsets ],
            -justify      => 'right',
            -state        => 'readonly',
            -width        => 6,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $offset_frame->new_label(
            -text   => " time zone adjustment ",
            -anchor => 'w',
            -font   => 'default',
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $offset_frame->new_button(
            -text    => "Help",
            -command => sub { &pop_up_info($add_ts_data_menu,
                                    "The time offset allows the user to add or subtract a time\n"
                                  . "offset if the W2 model was run with a non-local time zone.\n\n"
                                  . "For example, if W2 was run in UTC but the local time zone\n"
                                  . "is PST, an offset of -08:00 would convert the model date/time\n"
                                  . "to a local standard time of PST. This offset does not make\n"
                                  . "any adjustments related to daylight saving time. In general,\n"
                                  . "W2 is best run in the local standard time.\n\n"
                                  . "Leave the time offset at +00:00 for no adjustment.",
                                    "Time Offset Notice");
                            },
            )->g_pack(-side => 'left', -anchor => 'w', -padx => 2);

    $row++;
    $ts_frame->new_label(
            -text => "Line Width: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $ts_frame->new_spinbox(
            -textvariable => \$width,
            -state        => 'readonly',
            -font         => 'default',
            -from         => 1,
            -to           => 10,
            -increment    => 1,
            -width        => 3,
            )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    $row++;
    $ts_frame->new_label(
            -text => "Line Color: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $code  = &get_rgb_code($color);
    $color = &get_rgb_name($code);
    $fg    = &get_rgb_code("black");
    if ($code =~ /^\#[0-9a-f]/i) {
        $fg = &get_rgb_code(&get_bw_contrast($code));
    }
    ($color_btn = $ts_frame->new_button(
            -textvariable => \$color,
            -background   => $code,
            -foreground   => $fg,
            -width        => -7,
            -command => sub { my ($newc, $code, $fg);
                              $code = &get_rgb_code($color);
                              $newc = Tkx::tk___chooseColor(
                                         -initialcolor => $code,
                                         -parent       => $add_ts_data_menu);
                              if ($newc) {
                                  $code  = &get_rgb_code($newc);
                                  $color = &get_rgb_name($code);
                                  $fg    = &get_rgb_code("black");
                                  if ($code =~ /^#?[0-9a-f]/i) {
                                      $fg = &get_rgb_code(&get_bw_contrast($code));
                                  }
                                  $color_btn->configure(-foreground => $fg,
                                                        -background => $code);
                              }
                            }
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    $ts_frame->new_label(
            -text => "Legend Entry: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $ts_frame->new_entry(
            -textvariable => \$legend_txt,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'ew', -pady => 2);

    if ($fmt !~ /^W2 /) {
        $byear_label->g_grid_remove();
        $byear_label2->g_grid_remove();
        $byear_cb->g_grid_remove();
        $tzoff_label->g_grid_remove();
        $offset_frame->g_grid_remove();
    }
    if ($fmt ne "W2 Heat Fluxes format" && $fmt ne "W2 Water Level (wl) format"
                                        && $fmt !~ /^W2 .*daily .*Temp2?\.dat format$/i) {
        $segnum_label->g_grid_remove();
        $segnum_cb->g_grid_remove();
    }
    if ($fmt eq "W2 Water Level (wl) format") {
        $parm_cb->g_grid_remove();
        $parm_label->g_grid();
    }
    if ($conv_type ne "Custom") {
        $custom_frame->g_grid_remove();
    }
    $ts_frame->g_grid_columnconfigure(3, -weight => 2);

    Tkx::wm_resizable($add_ts_data_menu,0,0);
    &adjust_window_position($add_ts_data_menu);
    $add_ts_data_menu->g_focus;
}


sub plot_ts_data {
    my ($canv, $id, $new_data, $show_data, $setnum, $data_file, $nlines, $file_type,
        $parm, $width, $color, $legend_txt, $byear, $tzoff, $segnum, $conv_type) = @_;
    my (
        $base_jd, $datemax, $datemin, $dt, $gap_tol, $geom, $gtag, $i, $jd,
        $jd_max, $jd_min, $link_id, $missing, $n, $num_hidden, $num_plotted,
        $num_possible, $pbar, $pbar_window, $pmax, $pmin, $tabid, $ts_state,
        $val, $X, $x1, $x2, $xp, $Y, $y1, $y2, $ymax, $ymin, $yp,

        @add_ts_byear, @add_ts_color, @add_ts_ctype, @add_ts_file,
        @add_ts_ftype, @add_ts_limits, @add_ts_lines, @add_ts_param,
        @add_ts_seg, @add_ts_setnum, @add_ts_show, @add_ts_text,
        @add_ts_tsdata, @add_ts_tzoff, @add_ts_width, @fmt_group1,
        @fmt_group2, @items, @jds, @names, @points, @show, @tmp, @ts_dates,

        %add_ts_parms, %parms, %ts_data, %ts_limits,
       );

    $pbar     = "";
    $ts_state = ($show_data) ? 'normal' : 'hidden';
    $byear    = "n/a"    if (! defined($byear) || $file_type !~ /^W2 /);
    $tzoff    = "+00:00" if (! defined($tzoff) || $file_type !~ /^W2 /);
    $segnum   = "n/a"    if (! defined($segnum)
                             || ($file_type ne "W2 Heat Fluxes format" &&
                                 $file_type ne "W2 Water Level (wl) format" &&
                                 $file_type !~ /^W2 .*daily .*Temp2?\.dat format$/i));
    $missing   = "na";
    %ts_limits = ();

#   Get some info about the time-series graph
    ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
    $gtag = "graph" . $id;
    $ymin = $gr_props{$id}{ymin};
    $ymax = $gr_props{$id}{ymax};
    if (! defined($gr_props{$id}{xtype}) || $gr_props{$id}{xtype} eq "Date/Time") {
        $jd_min = &datelabel2jdate($gr_props{$id}{xmin});
        $jd_max = &datelabel2jdate($gr_props{$id}{xmax});
    } else {
        $base_jd = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
        $jd_min  = $gr_props{$id}{xmin} +$base_jd -1;
        $jd_max  = $gr_props{$id}{xmax} +$base_jd -1;
    }
    $gap_tol = $gr_props{$id}{gap_tol};

#   Read the time-series data
    if ($new_data) {
        @fmt_group1 = ("USGS getData format",
                       "Aquarius Time-Series format",
                       "Dataquery format",
                       "USGS Water Services format",
                       "USGS Data Grapher format",
                       "CSV format",
                      );
        @fmt_group2 = ("W2 TSR format",
                       "W2 Outflow CSV format",
                       "W2 Layer Outflow CSV format",
                       "W2 CSV format",
                       "W2 column format",
                      );
        if ($nlines <= 0) {
            (undef, $nlines, undef) = &determine_ts_type($main, $data_file);
        }
        if ($nlines > 4000) {
            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $nlines,
                                                         "Reading time-series file...");
        }
        if (&list_match($file_type, @fmt_group1) >= 0) {
            %ts_data = &read_timeseries($main, $data_file, $file_type, $parm, $pbar);

        } elsif (&list_match($file_type, @fmt_group2) >= 0) {
            %ts_data = &read_w2_timeseries($main, $data_file, $file_type, $parm, $byear, $tzoff, $pbar);

        } elsif ($file_type eq "W2 Heat Fluxes format") {
            %ts_data = &read_w2_heatfluxes($main, $data_file, $parm, $byear, $tzoff, $segnum, $pbar);

        } elsif ($file_type =~ /W2 .*aily .*Temp2?\.dat format/) {
            %ts_data = &read_w2_flowtemp($main, $data_file, $parm, $byear, $tzoff, $segnum, $pbar);

        } elsif ($file_type eq "W2 Water Level (wl) format") {
            %ts_data = &read_w2_wlevel($main, $id, $data_file, $byear, $tzoff, $segnum, 0, 0, $pbar);
        }
        if ($nlines > 4000) {
            &destroy_progress_bar($main, $pbar_window);
        }
        if (&list_match($conv_type, @conv_types) > 0 || $conv_type =~ /^Custom,/) {
            %ts_data = &convert_timeseries($main, $conv_type, 0, %ts_data);
        }
        @ts_dates = sort keys %ts_data;
        $datemin  = substr($ts_dates[0],0,8);
        $datemax  = substr($ts_dates[$#ts_dates],0,8);
        $pmin     =  9.E6;
        $pmax     = -9.E6;
        foreach $dt (@ts_dates) {
            next if ($ts_data{$dt} eq $missing);
            $pmin = $ts_data{$dt} if ($ts_data{$dt} < $pmin);
            $pmax = $ts_data{$dt} if ($ts_data{$dt} > $pmax);
        }
        $ts_limits{date_min} = $datemin;
        $ts_limits{date_max} = $datemax;
        $ts_limits{parm_min} = $pmin;
        $ts_limits{parm_max} = $pmax;
        if ($props{$id}{meta} eq "time_series") {
            if (! defined($ts_datemin)) {
                $ts_datemin = $datemin;
                $ts_datemax = $datemax;
            } else {
                $ts_datemin = $datemin if ($datemin < $ts_datemin);
                $ts_datemax = $datemax if ($datemax > $ts_datemax);
            }
        }
    } else {
        %add_ts_parms  = %{ $props{$id}{add_ts_parms} };
        @add_ts_setnum = @{ $add_ts_parms{ts_setnum}  };
        @add_ts_tsdata = @{ $add_ts_parms{ts_data}    };
        for ($n=0; $n<=$#add_ts_setnum; $n++) {
            if ($setnum == $add_ts_setnum[$n]) {
                %ts_data = %{ $add_ts_tsdata[$n] };
                last;
            }
        }
    }

#   Plot the time-series data
    @points = @jds = ();
    foreach $dt (sort keys %ts_data) {
        $jd = &date2jdate($dt);
        next if ($jd < $jd_min);
        last if ($jd > $jd_max);
        $val = $ts_data{$dt};
        next if ($val eq $missing);
        $xp = $x1 +($x2 -$x1) *($jd -$jd_min)/($jd_max -$jd_min);
        $yp = $y2 -($y2 -$y1) *($val -$ymin) /($ymax -$ymin);
#xxx interpolate to boundary?
        $yp = &min($y2, &max($y1, $yp));
        push (@points, $xp, $yp);
        push (@jds, $jd);
    }
    if ($#points > 0) {
        if ($gap_tol == 0.) {
            for ($i=0; $i<$#points; $i+=2) {
                $xp = $points[$i];
                $yp = $points[$i+1];
                $canv->create_rectangle($xp-2, $yp-2, $xp+2, $yp+2,
                                        -outline => &get_rgb_code($color),
                                        -width   => $width,
                                        -fill    => "",
                                        -state   => $ts_state,
                                        -tags    => $gtag . " " . $gtag . "_tsData"
                                                          . " " . $gtag . "_dataset"   . $setnum
                                                          . " " . $gtag . "_dataPoint" . $setnum);
            }
        } else {
            @tmp = ($points[0], $points[1]);
            for ($i=1; $i<=$#jds; $i++) {
                if ($jds[$i] -$jds[$i-1] <= $gap_tol) {
                    push (@tmp, $points[2*$i], $points[2*$i+1]);
                }
                if ($jds[$i] -$jds[$i-1] > $gap_tol || $#tmp >= 499) {
                    if ($#tmp > 1) {
                        $canv->create_line(@tmp, -fill  => &get_rgb_code($color),
                                                 -width => $width,
                                                 -arrow => 'none',
                                                 -state => $ts_state,
                                                 -tags  => $gtag . " " . $gtag . "_tsData"
                                                                 . " " . $gtag . "_dataset"  . $setnum
                                                                 . " " . $gtag . "_dataLine" . $setnum);
                    } elsif ($#tmp > 0) {
                        $canv->create_rectangle($tmp[0]-2, $tmp[1]-2, $tmp[0]+2, $tmp[1]+2,
                                                -outline => &get_rgb_code($color),
                                                -width   => $width,
                                                -fill    => "",
                                                -state   => $ts_state,
                                                -tags    => $gtag . " " . $gtag . "_tsData"
                                                                  . " " . $gtag . "_dataset"   . $setnum
                                                                  . " " . $gtag . "_dataPoint" . $setnum);
                    }
                    @tmp = ($points[2*$i], $points[2*$i+1]);
                }
            }
            if ($#tmp > 1) {
                $canv->create_line(@tmp, -fill  => &get_rgb_code($color),
                                         -width => $width,
                                         -arrow => 'none',
                                         -state => $ts_state,
                                         -tags  => $gtag . " " . $gtag . "_tsData"
                                                         . " " . $gtag . "_dataset"  . $setnum
                                                         . " " . $gtag . "_dataLine" . $setnum);
            } elsif ($#tmp > 0) {
                $canv->create_rectangle($tmp[0]-2, $tmp[1]-2, $tmp[0]+2, $tmp[1]+2,
                                        -outline => &get_rgb_code($color),
                                        -width   => $width,
                                        -fill    => "",
                                        -state   => $ts_state,
                                        -tags    => $gtag . " " . $gtag . "_tsData"
                                                          . " " . $gtag . "_dataset"   . $setnum
                                                          . " " . $gtag . "_dataPoint" . $setnum);
            }
        }
    }

#   Add a legend entry, but only if the dataset is visible
    if ($show_data) {

#       Determine how many of the baseline datasets are being plotted
        $num_possible = $num_plotted = 0;
        if ($props{$id}{meta} eq "linked_time_series") {
            %parms = %{ $props{$id}{ts_parms} };
            if ($parms{ts_type} eq "Water Surface Elevation") {
                $num_possible = 1;
                $num_plotted  = 1;
            } elsif ($parms{ts_type} eq "Release Rate") {
                $link_id = $props{$id}{link_id};
                if ($props{$link_id}{meta} eq "vert_wd_zone") {
                    @show  = @{ $parms{show} };
                    @names = @{ $gr_props{$link_id}{names} };
                    push (@names, "All Outlets");
                    $num_possible = $#names +1;
                    for ($n=0; $n<=$#names; $n++) {
                        $num_plotted++ if ($show[$n]);
                    }
                } elsif ($props{$link_id}{meta} eq "w2_outflow") {
                    $num_possible = 1;
                    $num_plotted  = 1;
                }
            } else {
                @show    = @{ $parms{show} };
                $link_id = $props{$id}{link_id};
                @names   = @{ $gr_props{$link_id}{names} };
                push (@names, "All Outlets");
                $num_possible = $#names +1;
                for ($n=0; $n<=$#names; $n++) {
                    $num_plotted++ if ($show[$n]);
                }
            }
        }

#       Determine how many of the previously added datasets are hidden
        $num_hidden = 0;
        if (defined($props{$id}{add_ts_parms})) {
            %add_ts_parms  = %{ $props{$id}{add_ts_parms} };
            @add_ts_show   = @{ $add_ts_parms{ts_show}    };
            @add_ts_setnum = @{ $add_ts_parms{ts_setnum}  };
            for ($n=0; $n<=$#add_ts_setnum; $n++) {
                last if ($setnum <= $add_ts_setnum[$n]);
                $num_hidden++ if (! $add_ts_show[$n]);
            }
        }

#       Plot the legend entry
        $xp  = $x2 +$gr_props{$id}{xleg_off};
        $yp  = $y1 +$gr_props{$id}{yleg_off};
        $yp += $gr_props{$id}{lt_size} *1.5 if ($gr_props{$id}{legtitle} ne "");
        $yp += ($setnum -$num_hidden -$num_possible +$num_plotted) *$gr_props{$id}{le_size} *1.5;
        $canv->create_line($xp, $yp, $xp+20, $yp,
                           -fill   => &get_rgb_code($color),
                           -width  => $width,
                           -arrow  => 'none',
                           -tags   => $gtag . " " . $gtag . "_legend");
        $canv->create_text($xp+25, $yp,
                           -anchor => 'w',
                           -text   => $legend_txt,
                           -fill   => &get_rgb_code("black"),
                           -angle  => 0,
                           -tags   => $gtag . " " . $gtag . "_legend",
                           -font   => [-family     => $gr_props{$id}{legfont},
                                       -size       => $gr_props{$id}{le_size},
                                       -weight     => $gr_props{$id}{le_weight},
                                       -slant      => 'roman',
                                       -underline  => 0,
                                       -overstrike => 0,
                                      ]);
    }

#   Update the legend box, if needed
    &update_legend_box($canv, $id);

#   Put things in the correct order
    $canv->lower($gtag . "_legend",    $id);
    $canv->lower($gtag . "_tsData",    $id);
    $canv->lower($gtag . "_datePoint", $id);
    $canv->lower($gtag . "_xaxis",     $id);
    $canv->lower($gtag . "_yaxis",     $id);
    @items = Tkx::SplitList($canv->find_withtag($gtag . "_legend"));
    if ($#items >= 0) {
        $canv->lower($gtag . "_legendBox", $gtag . "_legend");
    }

#   Add the time-series object and its attributes to the graph's properties.
    if ($new_data) {
        if (defined($props{$id}{add_ts_parms})) {
            %add_ts_parms  = %{ $props{$id}{add_ts_parms} };
            @add_ts_setnum = @{ $add_ts_parms{ts_setnum}  };
            @add_ts_file   = @{ $add_ts_parms{ts_file}    };
            @add_ts_show   = @{ $add_ts_parms{ts_show}    };
            @add_ts_width  = @{ $add_ts_parms{ts_width}   };
            @add_ts_color  = @{ $add_ts_parms{ts_color}   };
            @add_ts_text   = @{ $add_ts_parms{ts_text}    };
            @add_ts_ftype  = @{ $add_ts_parms{ts_ftype}   };
            @add_ts_lines  = @{ $add_ts_parms{ts_lines}   };
            @add_ts_param  = @{ $add_ts_parms{ts_param}   };
            @add_ts_byear  = @{ $add_ts_parms{ts_byear}   };
            @add_ts_tzoff  = @{ $add_ts_parms{ts_tzoff}   };
            @add_ts_seg    = @{ $add_ts_parms{ts_seg}     };
            @add_ts_ctype  = @{ $add_ts_parms{ts_ctype}   };
            @add_ts_limits = @{ $add_ts_parms{ts_limits}  };
            @add_ts_tsdata = @{ $add_ts_parms{ts_data}    };
            $n = &list_match($setnum, @add_ts_setnum);
            $n = $#add_ts_setnum +1 if ($n == -1);
        } else {
            @add_ts_setnum = @add_ts_file   = @add_ts_show   = ();
            @add_ts_width  = @add_ts_color  = @add_ts_text   = ();
            @add_ts_ftype  = @add_ts_param  = @add_ts_byear  = ();
            @add_ts_seg    = @add_ts_ctype  = @add_ts_tsdata = ();
            @add_ts_lines  = @add_ts_limits = @add_ts_tzoff  = ();
            $n = 0;
        }
        $add_ts_setnum[$n] = $setnum;
        $add_ts_file[$n]   = $data_file;
        $add_ts_show[$n]   = $show_data;
        $add_ts_width[$n]  = $width;
        $add_ts_color[$n]  = $color;
        $add_ts_text[$n]   = $legend_txt;
        $add_ts_ftype[$n]  = $file_type;
        $add_ts_lines[$n]  = $nlines;
        $add_ts_param[$n]  = $parm;
        $add_ts_byear[$n]  = $byear;
        $add_ts_tzoff[$n]  = $tzoff;
        $add_ts_seg[$n]    = $segnum;
        $add_ts_ctype[$n]  = $conv_type;
        $add_ts_limits[$n] = { %ts_limits };
        $add_ts_tsdata[$n] = { %ts_data   };

        $add_ts_parms{ts_setnum}  = [ @add_ts_setnum ];
        $add_ts_parms{ts_file}    = [ @add_ts_file   ];
        $add_ts_parms{ts_show}    = [ @add_ts_show   ];
        $add_ts_parms{ts_width}   = [ @add_ts_width  ];
        $add_ts_parms{ts_color}   = [ @add_ts_color  ];
        $add_ts_parms{ts_text}    = [ @add_ts_text   ];
        $add_ts_parms{ts_ftype}   = [ @add_ts_ftype  ];
        $add_ts_parms{ts_lines}   = [ @add_ts_lines  ];
        $add_ts_parms{ts_param}   = [ @add_ts_param  ];
        $add_ts_parms{ts_byear}   = [ @add_ts_byear  ];
        $add_ts_parms{ts_tzoff}   = [ @add_ts_tzoff  ];
        $add_ts_parms{ts_seg}     = [ @add_ts_seg    ];
        $add_ts_parms{ts_ctype}   = [ @add_ts_ctype  ];
        $add_ts_parms{ts_limits}  = [ @add_ts_limits ];
        $add_ts_parms{ts_data}    = [ @add_ts_tsdata ];
        $props{$id}{add_ts_parms} = { %add_ts_parms  };

#       Refresh the Graph Properties menu, if present
        if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
            if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
                $tabid = $grprops_notebook->index('current');
                $geom  = $graph_props_menu->g_wm_geometry();
                (undef, $X, $Y) = split(/\+/, $geom);
                &edit_graph_props($id, $X, $Y, $tabid);
            }
        }
    }
    undef %ts_data;
}


sub add_ts_graph {
    my ($canv, $id) = @_;
    my (
        $bdate_frame, $bdate_label, $bday, $bday_cb, $bm, $bmon, $bmon_cb,
        $byear, $byear_cb, $byear_label, $byear_label2, $byr, $byr_cb,
        $code, $color, $color_btn, $conv_add, $conv_add_entry, $conv_mult,
        $conv_mult_entry, $conv_type, $conv_type_cb, $create_btn,
        $custom_frame, $data_file, $data_type, $data_type_entry,
        $edate_frame, $edate_label, $eday, $eday_cb, $em, $emon, $emon_cb,
        $eyr, $eyr_cb, $fg, $fmt, $frame, $geom, $legend_txt, $nlines,
        $offset_frame, $parm, $parm_cb, $parm_label, $parm_chars,
        $row, $segnum, $segnum_cb, $segnum_label, $setnum, $ts_frame,
        $tz_offset, $tzoff_label, $units, $units_entry, $width, $X, $x1,
        $x2, $xaxis_type, $xaxis_type_cb, $xmax, $xmax_entry, $xmax_label,
        $xmin, $xmin_entry, $xmin_label, $Y, $y1, $y2, $ymax, $ymax_entry,
        $ymin, $ymin_entry, $yr_max, $yr_min, $ytitle,

        @parmlist, @segs,
       );

    &end_select($canv, $id, 1);

    ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $geom = sprintf("+%d+%d", $X+$x1+50, $Y+$y1+60);

    if (defined($add_ts_graph_menu) && Tkx::winfo_exists($add_ts_graph_menu)) {
        if ($add_ts_graph_menu->g_wm_title() eq "Add Time Series Graph") {
            $add_ts_graph_menu->g_destroy();
            undef $add_ts_graph_menu;
        }
    }
    $add_ts_graph_menu = $main->new_toplevel();
    $add_ts_graph_menu->g_wm_transient($main);
    $add_ts_graph_menu->g_wm_title("Add Time Series Graph");
    $add_ts_graph_menu->configure(-cursor => $cursor_norm);
    $add_ts_graph_menu->g_wm_geometry($geom);

#   Try to keep the nascent graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

    $data_file   = "";
    $data_type   = "";
    $units       = "";
    $xaxis_type  = "Date/Time";
    $setnum      = 0;
    $width       = 1;
    $color       = 'red';
    $legend_txt  = "Add Legend";
    $segnum      = "";
    $nlines      = 0;
    $tz_offset   = "+00:00";
    $conv_type   = $conv_types[0];
    $conv_mult   = 1.0;
    $conv_add    = 0.0;
    $fmt         = "Undetermined";
    $parm        = "Unknown";
    @parmlist    = ();
    $parmlist[0] = $parm;
    $parm_chars  = length($parm) +2;
    @segs        = ();

    $bm     = 0;
    $bmon   = $mon_names[$bm];
    $em     = 11;
    $emon   = $mon_names[$em];
    $bday   = 1;
    $eday   = $days_in_month[$em];
    $yr_max = (localtime(time))[5] +1900;
    $yr_min = $yr_max -25;
    $byear  = $byr  = $eyr = $yr_max;
    $ymin   = $ymax = "";
    $xmin   = $xmax = "";

#   Create input menu
    $frame = $add_ts_graph_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($create_btn = $frame->new_button(
            -text    => "Create",
            -state   => 'disabled',
            -command => sub { my (%add_ts_parms, %parms);
                              if ($legend_txt eq "Add Legend" || $legend_txt eq "") {
                                  return &pop_up_error($add_ts_graph_menu,
                                                       "Please add or edit the legend text.");
                              }
                              if ($ymin eq "" || $ymax eq "") {
                                  return &pop_up_error($add_ts_graph_menu,
                                  "Please provide both a minimum and maximum Y axis value.");
                              }
                              if ($ymin >= $ymax) {
                                  return &pop_up_error($add_ts_graph_menu,
                                      "The minimum Y axis value must be\n"
                                    . "less than the maximum Y axis value.");
                              }
                              if ($xaxis_type eq "Date/Time") {
                                  if ($byr > $eyr || ($byr == $eyr && $bm > $em)
                                                  || ($byr == $eyr && $bm == $em && $bday >= $eday)) {
                                      return &pop_up_error($add_ts_graph_menu,
                                                           "Start date must be before end date.");
                                  }
                              } else {
                                  if ($xmin eq "" || $xmax eq "") {
                                      return &pop_up_error($add_ts_graph_menu,
                                      "Please provide both a minimum and maximum X axis value.");
                                  }
                                  if ($xmin >= $xmax) {
                                      return &pop_up_error($add_ts_graph_menu,
                                          "The minimum X axis value must be\n"
                                        . "less than the maximum X axis value.");
                                  }
                              }
                              $add_ts_graph_menu->g_bind('<Destroy>', "");
                              $add_ts_graph_menu->g_destroy();
                              undef $add_ts_graph_menu;
                              &reset_bindings;

                              %parms          = ();
                              $parms{ts_type} = $data_type;
                              $parms{units}   = $units;
                              $parms{ymin}    = $ymin;
                              $parms{ymax}    = $ymax;
                              $parms{base_yr} = $byear;
                              $parms{xtype}   = $xaxis_type;
                              if ($xaxis_type eq "Date/Time") {
                                  $parms{xmin} = sprintf("%s-%02d-%04d", $bmon, $bday, $byr);
                                  $parms{xmax} = sprintf("%s-%02d-%04d", $emon, $eday, $eyr);
                              } else {
                                  $parms{xmin} = $xmin;
                                  $parms{xmax} = $xmax;
                              }
                              $props{$id}{ts_parms} = { %parms };

                              if ($conv_type eq "Custom") {
                                  $conv_type = sprintf("Custom,%s,%s", $conv_mult, $conv_add);
                              }
                              %add_ts_parms             = ();
                              $add_ts_parms{ts_setnum}  = [ ( $setnum     ) ];
                              $add_ts_parms{ts_file}    = [ ( $data_file  ) ];
                              $add_ts_parms{ts_ftype}   = [ ( $fmt        ) ];
                              $add_ts_parms{ts_lines}   = [ ( $nlines     ) ];
                              $add_ts_parms{ts_show}    = [ ( 1           ) ];
                              $add_ts_parms{ts_width}   = [ ( $width      ) ];
                              $add_ts_parms{ts_color}   = [ ( $color      ) ];
                              $add_ts_parms{ts_text}    = [ ( $legend_txt ) ];
                              $add_ts_parms{ts_param}   = [ ( $parm       ) ];
                              $add_ts_parms{ts_byear}   = [ ( $byear      ) ];
                              $add_ts_parms{ts_tzoff}   = [ ( $tz_offset  ) ];
                              $add_ts_parms{ts_seg}     = [ ( $segnum     ) ];
                              $add_ts_parms{ts_ctype}   = [ ( $conv_type  ) ];
                              $add_ts_parms{ts_limits}  = [ (             ) ];
                              $add_ts_parms{ts_data}    = [ (             ) ];
                              $props{$id}{add_ts_parms} = { %add_ts_parms   };

                              &make_ts_graph($canv, $id, 0);
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $add_ts_graph_menu->g_bind('<Destroy>', "");
                              $add_ts_graph_menu->g_destroy();
                              undef $add_ts_graph_menu;
                              $canv->delete("graph" . $id);
                              delete $props{$id};
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Delete graph if this menu is destroyed by other than the Cancel button
    $add_ts_graph_menu->g_bind('<Destroy>' => sub { undef $add_ts_graph_menu;
                                                    $canv->delete("graph" . $id);
                                                    delete $props{$id}; 
                                                    &reset_bindings;
                                                  });

    $ts_frame = $add_ts_graph_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $ts_frame->g_pack(-side => 'top');

    $row = 0;
    $ts_frame->new_label(
            -text => "Data File: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $ts_frame->new_label(
            -textvariable => \$data_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew');
    $ts_frame->new_button(
            -text    => "Browse",
            -command => sub { my ($file, $i, $segwidth, $segmax);
                              $file = Tkx::tk___getOpenFile(
                                      -parent     => $add_ts_graph_menu,
                                      -title      => "Select Data File",
                                      -initialdir => abs_path(),
                                      -filetypes  => [ ['All Files',  '*'],
                                                       ['CSV (comma delimited)', '.csv'],
                                                     ],
                                      );
                              if ( $^O =~ /MSWin32/i ) {
                                  if (defined($file) && $file ne "") {
                                      $file =~ s/\//\\/g;
                                  }
                              }
                              if (defined($file) && $file ne "") {
                                  $data_file = $file;
                                  ($fmt, $nlines, @parmlist)
                                      = &determine_ts_type($add_ts_graph_menu, $file);
                                  if ($fmt eq "") {
                                      $fmt         = "Undetermined";
                                      $parm        = "Unknown";
                                      @parmlist    = ();
                                      $parmlist[0] = $parm;
                                      $nlines      = 0;
                                      $data_file   = "";
                                      $create_btn->configure(-state => 'disabled');
                                  } else {
                                      $parm = $parmlist[0];
                                      $create_btn->configure(-state => 'normal');
                                  }
                                  $legend_txt = "Add Legend";
                                  $data_type  = $units = $ytitle = $ymin = $ymax = "";
                                  $parm_chars = length($parmlist[0]);
                                  for ($i=1; $i<=$#parmlist; $i++) {
                                      if (length($parmlist[$i]) > $parm_chars) {
                                          $parm_chars = length($parmlist[$i]);
                                      }
                                  }
                                  $parm_chars += 2;
                                  $parm_cb->configure(-values => [ @parmlist ],
                                                      -width  => $parm_chars);
                                  if ($fmt !~ /^W2 /) {
                                      if ($xaxis_type eq "Date/Time") {
                                          $byear_label->g_grid_remove();
                                          $byear_label2->g_grid_remove();
                                          $byear_cb->g_grid_remove();
                                      } else {
                                          $byear_label->g_grid();
                                          $byear_label2->g_grid();
                                          $byear_cb->g_grid();
                                      }
                                      $tzoff_label->g_grid_remove();
                                      $offset_frame->g_grid_remove();
                                      $segnum_label->g_grid_remove();
                                      $segnum_cb->g_grid_remove();
                                      $parm_label->g_grid_remove();
                                      $parm_cb->g_grid();
                                  } else {
                                      $byear_label->g_grid();
                                      $byear_label2->g_grid();
                                      $byear_cb->g_grid();
                                      $tzoff_label->g_grid();
                                      $offset_frame->g_grid();
                                      if ($fmt eq "W2 Heat Fluxes format"
                                            || $fmt eq "W2 Water Level (wl) format"
                                            || $fmt =~ /^W2 .*daily .*Temp2?\.dat format$/i) {
                                          $segnum_label->g_grid();
                                          $segnum_cb->g_grid();
                                      } else {
                                          $segnum_label->g_grid_remove();
                                          $segnum_cb->g_grid_remove();
                                      }
                                      if ($fmt eq "W2 Heat Fluxes format"
                                            || $fmt =~ /^W2 .*daily .*Temp2?\.dat format$/i) {
                                          ($segmax, @segs) = &scan_w2_file4segs($add_ts_graph_menu,
                                                                                $data_file, $fmt);
                                          $segwidth = 5;
                                          if ($#segs >= 0 && $segmax > 0) {
                                              $segwidth = &max(5, length($segmax));
                                          }
                                          $segnum_cb->configure(-values => [ @segs ],
                                                                -width  => $segwidth);
                                          if (&list_match($segnum, @segs) == -1) {
                                              $segnum = $segs[0];
                                          }
                                      }
                                      if ($fmt eq "W2 Water Level (wl) format") {
                                          @segs = @parmlist;
                                          $segnum_cb->configure(-values => [ @segs ],
                                                                -width  => $parm_chars);
                                          if (&list_match($segnum, @segs) == -1) {
                                              $segnum = $segs[0];
                                          }
                                          $parm_cb->g_grid_remove();
                                          $parm_label->g_grid();
                                          $parm = "Water Level";
                                      } else {
                                          $parm_label->g_grid_remove();
                                          $parm_cb->g_grid();
                                      }
                                  }
                              } else {
                                  if (! defined($data_file) || $data_file eq "" || ! -e $data_file) {
                                      $legend_txt = "Add Legend";
                                      $data_file  = $data_type = $units = "";
                                      $ytitle     = $ymin      = $ymax  = "";
                                      $create_btn->configure(-state => 'disabled');
                                  }
                              }
                            },
            )->g_grid(-row => $row, -column => 4, -sticky => 'ew', -padx => 2);

    $row++;
    $ts_frame->new_label(
            -text => "File Format: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $ts_frame->new_label(
            -textvariable => \$fmt,
            -anchor       => 'w',
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    ($segnum_label = $ts_frame->new_label(
            -text => "Segment: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($segnum_cb = $ts_frame->new_ttk__combobox(
            -textvariable => \$segnum,
            -values       => [ @segs ],
            -state        => 'readonly',
            -width        => 5,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    $ts_frame->new_label(
            -text => "Parameter: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($parm_label = $ts_frame->new_label(
            -text => "Water Level",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w', -pady => 2);
    $parm_label->g_grid_remove();
    ($parm_cb = $ts_frame->new_ttk__combobox(
            -textvariable => \$parm,
            -values       => [ @parmlist ],
            -state        => 'readonly',
            -width        => $parm_chars,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    $ts_frame->new_label(
            -text => "Conversion: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($conv_type_cb = $ts_frame->new_ttk__combobox(
            -textvariable => \$conv_type,
            -values       => [ @conv_types ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w', -pady => 2);
    $conv_type_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($conv_type eq "Custom") {
                                $custom_frame->g_grid();
                            } else {
                                $custom_frame->g_grid_remove();
                            }
                          }
                      );
    $row++;
    ($custom_frame = $ts_frame->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w');
    $custom_frame->new_label(
            -text => "Multiply by: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_mult_entry = $custom_frame->new_entry(
            -textvariable => \$conv_mult,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_mult_entry->g_bind("<KeyRelease>",
                              sub { &numeric_entry_only($conv_mult_entry);
                                    my $chars = &max(7, length($conv_mult));
                                    $conv_mult_entry->configure(-width => $chars);
                                  });
    $custom_frame->new_label(
            -text => "  Then add: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_add_entry = $custom_frame->new_entry(
            -textvariable => \$conv_add,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_add_entry->g_bind("<KeyRelease>",
                             sub { &numeric_entry_only($conv_add_entry);
                                   my $chars = &max(7, length($conv_add));
                                   $conv_add_entry->configure(-width => $chars);
                                 });

    $row++;
    $ts_frame->new_label(
            -text => "Data Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($data_type_entry = $ts_frame->new_entry(
            -textvariable => \$data_type,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w', -pady => 2);
    $data_type_entry->g_bind("<KeyRelease>",
                             sub { my $chars = &max(7, length($data_type));
                                   $data_type_entry->configure(-width => $chars);
                                   if ($data_type eq "Temperature") {
                                       $ytitle = "Temperature, in degrees " . $units;
                                   } else {
                                       $ytitle = $data_type . ", in " . $units;
                                   }
                                 });
    $row++;
    $ts_frame->new_label(
            -text => "Data Units: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($units_entry = $ts_frame->new_entry(
            -textvariable => \$units,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w', -pady => 2);
    $units_entry->g_bind("<KeyRelease>",
                         sub { my $chars = &max(7, length($units));
                               $units_entry->configure(-width => $chars);
                               if ($data_type eq "Temperature") {
                                   $ytitle = "Temperature, in degrees " . $units;
                               } else {
                                   $ytitle = $data_type . ", in " . $units;
                               }
                             });

    $row++;
    $ts_frame->new_label(
            -text => "Y Axis Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $ts_frame->new_label(
            -textvariable => \$ytitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    $ts_frame->new_label(
            -text => "Y Axis Min: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ymin_entry = $ts_frame->new_entry(
            -textvariable => \$ymin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $ymin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $ymin_entry ]);

    $row++;
    $ts_frame->new_label(
            -text => "Y Axis Max: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ymax_entry = $ts_frame->new_entry(
            -textvariable => \$ymax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $ymax_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $ymax_entry ]);

    $row++;
    $ts_frame->new_label(
            -text => "X Axis Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($xaxis_type_cb = $ts_frame->new_ttk__combobox(
            -textvariable => \$xaxis_type,
            -values       => [ ("Date/Time", "Julian Date") ],
            -state        => 'readonly',
            -width        => 12,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w', -pady => 2);
    $xaxis_type_cb->g_bind("<<ComboboxSelected>>",
                            sub { if ($xaxis_type eq "Date/Time") {
                                      $xmin_label->g_grid_remove();
                                      $xmin_entry->g_grid_remove();
                                      $xmax_label->g_grid_remove();
                                      $xmax_entry->g_grid_remove();
                                      $bdate_label->g_grid();
                                      $bdate_frame->g_grid();
                                      $edate_label->g_grid();
                                      $edate_frame->g_grid();
                                      if ($fmt !~ /^W2 /) {
                                          $byear_label->g_grid_remove();
                                          $byear_label2->g_grid_remove();
                                          $byear_cb->g_grid_remove();
                                      } else {
                                          $byear_label->g_grid();
                                          $byear_label2->g_grid();
                                          $byear_cb->g_grid();
                                      }
                                  } else {
                                      $xmin_label->g_grid();
                                      $xmin_entry->g_grid();
                                      $xmax_label->g_grid();
                                      $xmax_entry->g_grid();
                                      $bdate_label->g_grid_remove();
                                      $bdate_frame->g_grid_remove();
                                      $edate_label->g_grid_remove();
                                      $edate_frame->g_grid_remove();
                                      $byear_label->g_grid();
                                      $byear_label2->g_grid();
                                      $byear_cb->g_grid();
                                  }
                                  if ($fmt !~ /^W2 /) {
                                      $tzoff_label->g_grid_remove();
                                      $offset_frame->g_grid_remove();
                                  } else {
                                      $tzoff_label->g_grid();
                                      $offset_frame->g_grid();
                                  }
                                }
                           );

    $row++;
    ($byear_label = $ts_frame->new_label(
            -text => "Base Year: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($byear_cb = $ts_frame->new_ttk__combobox(
            -textvariable => \$byear,
            -values       => [ reverse($yr_min .. $yr_max) ],
            -state        => 'readonly',
            -width        => 5,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $byear_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($byear == $yr_min) {
                                $yr_min -= 10;
                                $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                $byr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                $eyr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                            }
                          }
                     );
    ($byear_label2 = $ts_frame->new_label(
            -text   => " for JDAY = 1.0",
            -anchor => 'w',
            -font   => 'default',
            ))->g_grid(-row => $row, -column => 2, -columnspan => 2, -sticky => 'w', -pady => 2);

    $row++;
    ($tzoff_label = $ts_frame->new_label(
            -text => "Time Offset: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($offset_frame = $ts_frame->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w');
    $offset_frame->new_ttk__combobox(
            -textvariable => \$tz_offset,
            -values       => [ @tz_offsets ],
            -justify      => 'right',
            -state        => 'readonly',
            -width        => 6,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $offset_frame->new_label(
            -text   => " time zone adjustment ",
            -anchor => 'w',
            -font   => 'default',
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $offset_frame->new_button(
            -text    => "Help",
            -command => sub { &pop_up_info($add_ts_graph_menu,
                                    "The time offset allows the user to add or subtract a time\n"
                                  . "offset if the W2 model was run with a non-local time zone.\n\n"
                                  . "For example, if W2 was run in UTC but the local time zone\n"
                                  . "is PST, an offset of -08:00 would convert the model date/time\n"
                                  . "to a local standard time of PST. This offset does not make\n"
                                  . "any adjustments related to daylight saving time. In general,\n"
                                  . "W2 is best run in the local standard time.\n\n"
                                  . "Leave the time offset at +00:00 for no adjustment.",
                                    "Time Offset Notice");
                            },
            )->g_pack(-side => 'left', -anchor => 'w', -padx => 2);

    $row++;
    ($bdate_label = $ts_frame->new_label(
            -text => "X Axis Start: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($bdate_frame = $ts_frame->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w');
    ($bmon_cb = $bdate_frame->new_ttk__combobox(
            -textvariable => \$bmon,
            -values       => [ @mon_names ],
            -state        => 'readonly',
            -width        => 4,
            ))->g_pack(-side => 'left');
    $bmon_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($byr);
                          $bm = &list_match($bmon, @mon_names);
                          $bday_cb->configure(-values => [ 1 .. $days_in_month[$bm] ]);
                          $bday = $days_in_month[$bm] if ($bday > $days_in_month[$bm]);
                        }
                    );
    $bdate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($bday_cb = $bdate_frame->new_ttk__combobox(
            -textvariable => \$bday,
            -values       => [ 1 .. $days_in_month[$bm] ],
            -state        => 'readonly',
            -width        => 3,
            ))->g_pack(-side => 'left');
    $bdate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($byr_cb = $bdate_frame->new_ttk__combobox(
            -textvariable => \$byr,
            -values       => [ reverse($yr_min .. $yr_max) ],
            -state        => 'readonly',
            -width        => 5,
            ))->g_pack(-side => 'left');
    $byr_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($byr);
                          $bm = &list_match($bmon, @mon_names);
                          if ($bm == 1) {
                              $bday_cb->configure(-values => [ 1 .. $days_in_month[$bm] ]);
                              $bday = $days_in_month[$bm] if ($bday > $days_in_month[$bm]);
                          }
                          if ($byr == $yr_min) {
                              $yr_min -= 10;
                              $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                              $byr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                              $eyr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                          }
                        }
                    );

    $row++;
    ($edate_label = $ts_frame->new_label(
            -text => "X Axis End: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($edate_frame = $ts_frame->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w');
    ($emon_cb = $edate_frame->new_ttk__combobox(
            -textvariable => \$emon,
            -values       => [ @mon_names ],
            -state        => 'readonly',
            -width        => 4,
            ))->g_pack(-side => 'left');
    $emon_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($eyr);
                          $em = &list_match($emon, @mon_names);
                          $eday_cb->configure(-values => [ 1 .. $days_in_month[$em] ]);
                          $eday = $days_in_month[$em] if ($eday > $days_in_month[$em]);
                        }
                    );
    $edate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($eday_cb = $edate_frame->new_ttk__combobox(
            -textvariable => \$eday,
            -values       => [ 1 .. $days_in_month[$em] ],
            -state        => 'readonly',
            -width        => 3,
            ))->g_pack(-side => 'left');
    $edate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($eyr_cb = $edate_frame->new_ttk__combobox(
            -textvariable => \$eyr,
            -values       => [ reverse($yr_min .. $yr_max) ],
            -state        => 'readonly',
            -width        => 5,
            ))->g_pack(-side => 'left');
    $eyr_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($eyr);
                          $em = &list_match($emon, @mon_names);
                          if ($em == 1) {
                              $eday_cb->configure(-values => [ 1 .. $days_in_month[$em] ]);
                              $eday = $days_in_month[$em] if ($eday > $days_in_month[$em]);
                          }
                          if ($eyr == $yr_min) {
                              $yr_min -= 10;
                              $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                              $byr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                              $eyr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                          }
                        }
                    );

    $row++;
    ($xmin_label = $ts_frame->new_label(
            -text => "X Axis Min: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($xmin_entry = $ts_frame->new_entry(
            -textvariable => \$xmin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $xmin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $xmin_entry ]);

    $row++;
    ($xmax_label = $ts_frame->new_label(
            -text => "X Axis Max: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($xmax_entry = $ts_frame->new_entry(
            -textvariable => \$xmax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $xmax_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $xmax_entry ]);

    $row++;
    $ts_frame->new_label(
            -text => "Line Width: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $ts_frame->new_spinbox(
            -textvariable => \$width,
            -state        => 'readonly',
            -font         => 'default',
            -from         => 1,
            -to           => 10,
            -increment    => 1,
            -width        => 3,
            )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    $row++;
    $ts_frame->new_label(
            -text => "Line Color: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $code  = &get_rgb_code($color);
    $color = &get_rgb_name($code);
    $fg    = &get_rgb_code("black");
    if ($code =~ /^\#[0-9a-f]/i) {
        $fg = &get_rgb_code(&get_bw_contrast($code));
    }
    ($color_btn = $ts_frame->new_button(
            -textvariable => \$color,
            -background   => $code,
            -foreground   => $fg,
            -width        => -7,
            -command => sub { my ($newc, $code, $fg);
                              $code = &get_rgb_code($color);
                              $newc = Tkx::tk___chooseColor(
                                         -initialcolor => $code,
                                         -parent       => $add_ts_graph_menu);
                              if ($newc) {
                                  $code  = &get_rgb_code($newc);
                                  $color = &get_rgb_name($code);
                                  $fg    = &get_rgb_code("black");
                                  if ($code =~ /^#?[0-9a-f]/i) {
                                      $fg = &get_rgb_code(&get_bw_contrast($code));
                                  }
                                  $color_btn->configure(-foreground => $fg,
                                                        -background => $code);
                              }
                            }
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    $ts_frame->new_label(
            -text => "Legend Entry: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $ts_frame->new_entry(
            -textvariable => \$legend_txt,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'ew', -pady => 2);

    $xmin_label->g_grid_remove();
    $xmin_entry->g_grid_remove();
    $xmax_label->g_grid_remove();
    $xmax_entry->g_grid_remove();
    if ($fmt !~ /^W2 /) {
        $byear_label->g_grid_remove();
        $byear_label2->g_grid_remove();
        $byear_cb->g_grid_remove();
        $tzoff_label->g_grid_remove();
        $offset_frame->g_grid_remove();
    }
    if ($fmt ne "W2 Heat Fluxes format" && $fmt ne "W2 Water Level (wl) format"
                                        && $fmt !~ /^W2 .*daily .*Temp2?\.dat format$/i) {
        $segnum_label->g_grid_remove();
        $segnum_cb->g_grid_remove();
    }
    if ($fmt eq "W2 Water Level (wl) format") {
        $parm_cb->g_grid_remove();
        $parm_label->g_grid();
    }
    if ($conv_type ne "Custom") {
        $custom_frame->g_grid_remove();
    }
    $ts_frame->g_grid_columnconfigure(3, -weight => 2);

    Tkx::wm_resizable($add_ts_graph_menu,0,0);
    &adjust_window_position($add_ts_graph_menu);
    $add_ts_graph_menu->g_focus;
}


sub add_ref_data {
    my ($canv, $id, $X, $Y) = @_;
    my (
        $code, $color_btn, $conv_add, $conv_add_entry, $conv_mult,
        $conv_mult_entry, $conv_type, $conv_type_cb, $conv_type_label,
        $custom_frame, $data_parm, $data_parm_label, $f, $fg, $frame,
        $geom, $ok_btn, $ref_color, $ref_file, $ref_linew, $ref_size,
        $ref_tol, $row, $tol_frame, $txt, $txt_chars, $x1, $x2, $y1, $y2,
       );

    &end_select($canv, $id, 1);

    ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $geom = sprintf("+%d+%d", $X+$x1+50, $Y+$y1+60);

    if (defined($add_ref_data_menu) && Tkx::winfo_exists($add_ref_data_menu)) {
        if ($add_ref_data_menu->g_wm_title() eq "Add Reference Profile Data") {
            $add_ref_data_menu->g_destroy();
            undef $add_ref_data_menu;
        }
    }
    $add_ref_data_menu = $main->new_toplevel();
    $add_ref_data_menu->g_wm_transient($main);
    $add_ref_data_menu->g_wm_title("Add Reference Profile Data");
    $add_ref_data_menu->configure(-cursor => $cursor_norm);
    $add_ref_data_menu->g_wm_geometry($geom);

#   Try to keep the nascent graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

    $ref_file = "";
    if ($props{$id}{parm} eq "Temperature") {
        $txt = "Temperature, in degrees " . $props{$id}{parm_units};
    } else {
        $txt = $props{$id}{parm} . ", in " . $props{$id}{parm_units};
    }
    $txt_chars = &max(25, length($txt));
    $data_parm = "";
    $ref_tol   = 10;
    $ref_color = "black";
    $ref_size  = "Medium";
    $ref_linew = 1;

#   Conversion types and factors (@conv_types is global)
    $conv_type = $conv_types[0];
    $conv_mult = 1.0;
    $conv_add  = 0.0;

#   Create input menu
    $frame = $add_ref_data_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -state   => 'disabled',
            -command => sub { my ($geom, $tabid, $X, $Y);
                              if ($ref_file eq "" || ! -e $ref_file) {
                                  return &pop_up_error($add_ref_data_menu,
                                  "Reference data file not set or does not exist:\n$ref_file");
                              }
                              if ($conv_type eq "Custom") {
                                  $conv_type = sprintf("Custom,%s,%s", $conv_mult, $conv_add);
                              }
                              $add_ref_data_menu->g_bind('<Destroy>', "");
                              $add_ref_data_menu->g_destroy();
                              undef $add_ref_data_menu;
                              &reset_bindings;

                              $props{$id}{ref_file}  = $ref_file;
                              $props{$id}{ref_ctype} = $conv_type;
                              $props{$id}{ref_tol}   = $ref_tol;
                              $props{$id}{ref_color} = $ref_color;
                              $props{$id}{ref_size}  = $ref_size;
                              $props{$id}{ref_linew} = $ref_linew;
                              $props{$id}{ref_hide}  = 0;

                              &plot_ref_profile($canv, $id, 1, 0);
                              &build_profile_match_list();
                              &update_links($canv, $id, $dates[$dti-1]);

                            # Rebuild Object Info box for this graph, if necessary
                              if (defined($object_infobox) && Tkx::winfo_exists($object_infobox)) {
                                  if ($object_infobox->g_wm_title() eq "Object Info, ID $id") {
                                      $geom = $object_infobox->g_wm_geometry();
                                      (undef, $X, $Y) = split(/\+/, $geom);
                                      &show_info($canv, $id, $X, $Y);
                                  }
                              }

                            # Rebuild the animation toolbar, if present
                              if (defined($animate_tb) && Tkx::winfo_exists($animate_tb)) {
                                  if ($animate_tb->g_wm_title() eq "Animation toolbar") {
                                      $geom = $animate_tb->g_wm_geometry();
                                      (undef, $X, $Y) = split(/\+/, $geom);
                                      $animate_tb->g_destroy();
                                      undef $animate_tb;
                                      &animate_toolbar($X, $Y, -1);
                                  }
                              }

                            # Refresh the Graph Properties menu, if present
                              if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
                                  if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
                                      $tabid = $grprops_notebook->index('current');
                                      $geom  = $graph_props_menu->g_wm_geometry();
                                      (undef, $X, $Y) = split(/\+/, $geom);
                                      &edit_graph_props($id, $X, $Y, $tabid);
                                  }
                              }
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $add_ref_data_menu->g_bind('<Destroy>', "");
                              $add_ref_data_menu->g_destroy();
                              undef $add_ref_data_menu;
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Clean up if this menu is destroyed by other than the Cancel button
    $add_ref_data_menu->g_bind('<Destroy>' => sub { undef $add_ref_data_menu;
                                                    &reset_bindings;
                                                  });

    ($f = $add_ref_data_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "Please provide a reference data file with measured profiles.",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -columnspan => 4, -sticky => 'w');

    $row++;
    $f->new_label(
            -text => "Model Parameter: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $f->new_label(
            -text   => $txt,
            -font   => 'default',
            -anchor => 'w',
            -width  => $txt_chars,
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');

    $row++;
    $f->new_label(
            -text => "Profile Data File: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$ref_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
    $f->new_button(
            -text    => "Browse",
            -command => sub { my ($file, $i, $status, $str, %meta);
                              $file = Tkx::tk___getOpenFile(
                                      -parent           => $add_ref_data_menu,
                                      -title            => "Select Reference Profile File",
                                      -initialdir       => abs_path(),
                                      -filetypes => [ ['CSV (comma delimited)', '.csv'],
                                                      ['All Files',  '*'],
                                                    ],
                                      );
                              if (defined($file) && -e $file) {
                                  $ref_file = File::Spec->rel2abs($file);
                                  ($status, %meta) = &scan_profile($add_ref_data_menu, $ref_file);
                                  if ($status ne "okay") {
                                      $ref_file = "";
                                      $ok_btn->configure(-state => 'disabled');
                                      return &pop_up_error($add_ref_data_menu,
                                            "Specified file is not a profile data file "
                                          . "or is incomplete:\n$file");
                                  }
                                  if (lc($meta{parm}) ne lc($props{$id}{parm})) {
                                      $ref_file = "";
                                      $ok_btn->configure(-state => 'disabled');
                                      return &pop_up_error($add_ref_data_menu,
                                            "Parameter name from the profile data file\n("
                                          . $meta{parm} . ") does not match the expected\n"
                                          . "parameter (" . $props{$id}{parm} . ").");
                                  } 
                                  $conv_type = "None";
                                  $custom_frame->g_grid_remove();
                                  if ($meta{parm} eq "Temperature") {
                                      $conv_type_label->g_grid();
                                      $conv_type_cb->g_grid_remove();
                                      $data_parm = $meta{parm};
                                  } else {
                                      $conv_type_label->g_grid_remove();
                                      $conv_type_cb->g_grid();
                                      $data_parm = $meta{parm} . ", in " . $meta{parm_units};
                                      if (lc($props{$id}{parm_units}) ne lc($meta{parm_units})
                                           && &list_search($meta{parm_units}, @conv_types) >= 0
                                           && &list_search($props{$id}{parm_units}, @conv_types) >= 0) {
                                          $str = $meta{parm_units} . " to " . $props{$id}{parm_units};
                                          $i   = &list_match($str, @conv_types);
                                          $conv_type = $conv_types[$i] if ($i >= 0);
                                      }
                                  }
                                  $ok_btn->configure(-state => 'normal');
                              } else {
                                  $ref_file  = "";
                                  $conv_type = "None";
                                  $custom_frame->g_grid_remove();
                                  $ok_btn->configure(-state => 'disabled');
                              }
                            },
            )->g_grid(-row => $row, -column => 3, -sticky => 'ew', -padx => 2, -pady => 2);

    $row++;
    $f->new_label(
            -text => "Data Parameter: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    ($data_parm_label = $f->new_label(
            -textvariable => \$data_parm,
            -anchor       => 'w',
            -font         => 'default',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');

    $row++;
    $f->new_label(
            -text => "Conversion: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($conv_type_label = $f->new_label(
            -text => "none necessary",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $conv_type_label->g_grid_remove();
    ($conv_type_cb = $f->new_ttk__combobox(
            -textvariable => \$conv_type,
            -values       => [ @conv_types ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $conv_type_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($conv_type eq "Custom") {
                                $custom_frame->g_grid();
                            } else {
                                $custom_frame->g_grid_remove();
                            }
                          }
                      );
    $row++;
    ($custom_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $custom_frame->new_label(
            -text => "Multiply by: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_mult_entry = $custom_frame->new_entry(
            -textvariable => \$conv_mult,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_mult_entry->g_bind("<KeyRelease>",
                              sub { &numeric_entry_only($conv_mult_entry);
                                    my $chars = &max(7, length($conv_mult));
                                    $conv_mult_entry->configure(-width => $chars);
                                  });
    $custom_frame->new_label(
            -text => "  Then add: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_add_entry = $custom_frame->new_entry(
            -textvariable => \$conv_add,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_add_entry->g_bind("<KeyRelease>",
                             sub { &numeric_entry_only($conv_add_entry);
                                   my $chars = &max(7, length($conv_add));
                                   $conv_add_entry->configure(-width => $chars);
                                 });

    $row++;
    $f->new_label(
            -text => "Match Tolerance: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($tol_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $tol_frame->new_spinbox(
            -textvariable => \$ref_tol,
            -state        => 'readonly',
            -font         => 'default',
            -from         => 0,
            -to           => 180,
            -increment    => 1,
            -width        => 4,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $tol_frame->new_label(
            -text => " minutes",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');

    $row++;
    $f->new_label(
            -text => "Data Point Size: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_ttk__combobox(
            -textvariable => \$ref_size,
            -values       => [("Small", "Medium", "Large", "Extra Large")],
            -width        => 9,
            -state        => 'readonly',
            )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Line Color: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);

    $code      = &get_rgb_code($ref_color);
    $ref_color = &get_rgb_name($code);
    $fg        = &get_rgb_code("black");
    if ($code =~ /^\#[0-9a-f]/i) {
        $fg = &get_rgb_code(&get_bw_contrast($code));
    }
    ($color_btn = $f->new_button(
               -textvariable => \$ref_color,
               -background   => $code,
               -foreground   => $fg,
               -width        => -7,
               -command => sub { my ($newc, $code, $fg);
                                 $code = &get_rgb_code($ref_color);
                                 $newc = Tkx::tk___chooseColor(
                                            -initialcolor => $code,
                                            -parent       => $add_ref_data_menu);
                                 if ($newc) {
                                   $code      = &get_rgb_code($newc);
                                   $ref_color = &get_rgb_name($code);
                                   $fg        = &get_rgb_code("black");
                                   if ($code =~ /^\#[0-9a-f]/i) {
                                       $fg = &get_rgb_code(&get_bw_contrast($code));
                                   }
                                   $color_btn->configure(-foreground => $fg,
                                                         -background => $code);
                                 }
                               }
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Line Width: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_spinbox(
            -textvariable => \$ref_linew,
            -state        => 'readonly',
            -font         => 'default',
            -from         => 1,
            -to           => 2,
            -increment    => 1,
            -width        => 3,
            )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    if ($conv_type ne "Custom") {
        $custom_frame->g_grid_remove();
    }
    $f->g_grid_columnconfigure(2, -weight => 2);

    Tkx::wm_resizable($add_ref_data_menu,0,0);
    &adjust_window_position($add_ref_data_menu);
    $add_ref_data_menu->g_focus;
}


sub plot_ref_profile {
    my ($canv, $id, $new, $matrix_pos) = @_;
    my (
        $cs_max, $cs_min, $data_daily, $dt, $dt_ref, $dt_ref2, $found,
        $got_depth, $gtag, $i, $ih, $img_data, $iw, $j, $lastpt, $mi,
        $mult, $nb, $nc, $ncols, $np, $nr, $nrows, $pix, $pt1_in, $pt2_in,
        $ref_ctype, $ref_daily, $ref_image, $ref_img, $status, $sumb,
        $surf_elev, $tol, $val, $x1, $x2, $xmax, $xmin, $xp, $xp1, $xp2,
        $y1, $y2, $ymax, $ymin, $yp, $yp1, $yp2, $yrange, $ytype, $yunits,

        @blanks, @chosen_dates, @colors, @coords, @depths, @elevations,
        @estimated, @items, @keys_ref, @pdata, @pt_color, @pt_elevations,
        @valid_elevs, @valid_pdata,

        %elev_data, %pt_size, %ref_data, %ref_profile, %wsurf,
       );

    ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };

    if ($props{$id}{meta} eq "w2_profile") {
        $dt = $dates[$dti-1];
    } else {
        ($nrows, $ncols) = split(/x/, $gr_props{$id}{matrix});
        @chosen_dates    = @{ $gr_props{$id}{pdates} };
        @blanks          = @{ $gr_props{$id}{blanks} };
        $sumb = 0;
        for ($nr=0; $nr<$nrows; $nr++) {
            for ($nc=0; $nc<$ncols; $nc++) {
                $nb = $nr *$ncols +$nc;
                if ($blanks[$nb]) {
                    $sumb++;
                    next;
                }
                if ($nb == $matrix_pos) {
                    $xp1 = $x1 + &round_to_int($nc    *($x2 -$x1)/$ncols);
                    $xp2 = $x1 + &round_to_int(($nc+1)*($x2 -$x1)/$ncols);
                    $yp1 = $y1 + &round_to_int($nr    *($y2 -$y1)/$nrows);
                    $yp2 = $y1 + &round_to_int(($nr+1)*($y2 -$y1)/$nrows);
                    $x1  = $xp1;
                    $x2  = $xp2;
                    $y1  = $yp1;
                    $y2  = $yp2;
                    $dt  = $chosen_dates[$nb-$sumb];
                    last;
                }
            }
            last if ($nb == $matrix_pos);
        }
    }
    $gtag    = "graph" . $id;
    $tol     = $props{$id}{ref_tol};
    %pt_size = ("Small", 2, "Medium", 3, "Large", 4, "Extra Large", 5);

    if ($new) {
        %ref_profile = &read_profile($main, $props{$id}{ref_file});
        %ref_data    = %{ $ref_profile{pdata} };
        $ref_ctype   = $props{$id}{ref_ctype};

        if (&list_match($ref_ctype, @conv_types) > 0 || $ref_ctype =~ /^Custom,/) {
            %ref_data = &convert_timeseries($main, $ref_ctype, 1, %ref_data);
            $ref_profile{pdata} = { %ref_data };
        }
        $gr_props{$id}{ref_data} = { %ref_profile };
    } else {
        %ref_profile = %{ $gr_props{$id}{ref_data} };
        %ref_data    = %{ $ref_profile{pdata}      };
    }

#   Get the modeled water-surface elevation, just in case it is needed
    %elev_data = %{ $gr_props{$id}{elev_data} };

#   Set the date and see if a match exists in the reference data profile
    @keys_ref   = keys %ref_data;
    $data_daily = (length($dt)          == 12) ? 0 : 1;
    $ref_daily  = (length($keys_ref[0]) == 12) ? 0 : 1;

    $dt_ref = $dt;
    if ($data_daily != $ref_daily) {
        if ($ref_daily) {
            $dt_ref = &nearest_daily_dt($dt);
            return if (&get_dt_diff($dt, 10000 *$dt_ref) > $tol || ! defined($ref_data{$dt_ref}));
        } else {
            $dt_ref .= "0000";
        }
    }
    if (! defined($ref_data{$dt_ref})) {
        return if (($data_daily && $ref_daily) || $tol == 0);
        $found = 0;
        for ($mi=1; $mi<=$tol; $mi++) {
            $dt_ref2 = &adjust_dt($dt_ref, $mi);
            if (defined($ref_data{$dt_ref2})) {
                $dt_ref = $dt_ref2;
                $found  = 1;
                last;
            }
            $dt_ref2 = &adjust_dt($dt_ref, -1 *$mi);
            if (defined($ref_data{$dt_ref2})) {
                $dt_ref = $dt_ref2;
                $found  = 1;
                last;
            }
        }
        return if (! $found);
    }

#   Get some graph parameters
    if ($gr_props{$id}{add_cs}) {
        $cs_min = $gr_props{$id}{cs_min};
        $cs_max = $gr_props{$id}{cs_max};
        @colors = @{ $gr_props{$id}{colors} };
    }
    $status = ($props{$id}{ref_hide}) ? 'hidden' : 'normal';
    $ytype  = $gr_props{$id}{ytype};
    $yunits = $gr_props{$id}{yunits};
    $mult   = ($yunits eq "feet") ? 3.28084 : 1.0;
    $ymin   = $gr_props{$id}{ymin} /$mult;
    $ymax   = $gr_props{$id}{ymax} /$mult;
    $yrange = $ymax -$ymin;
    $xmin   = $gr_props{$id}{xmin};
    $xmax   = $gr_props{$id}{xmax};

#   Set some variables and populate some arrays and hashes
    %wsurf     = %{ $ref_profile{ws_elev}   };
    @estimated = @{ $ref_profile{estimated} };
    $got_depth = ($ref_profile{elv_dep} eq "elevation") ? 0 : 1;
    if ($got_depth) {
        @depths     = @{ $ref_profile{depths} };
    } else {
        @elevations = @{ $ref_profile{elevations} };
    }
    $surf_elev = ($wsurf{$dt_ref} ne "na") ? $wsurf{$dt_ref} : $elev_data{$dt};
    $lastpt    = ($got_depth) ? $#depths : $#elevations;
    @pt_elevations = ();
    for ($i=0; $i<=$lastpt; $i++) {
        if ($got_depth) {
            push (@pt_elevations, $surf_elev -$depths[$i]);
        } else {
            push (@pt_elevations, $elevations[$i]);
        }
    }
    undef %wsurf;
    undef %elev_data;

#   Translate the data to the graph coordinates
    @pdata = @{ $ref_data{$dt_ref} };
    if ($ref_profile{parm} eq "Temperature" && $props{$id}{parm_units} eq "Fahrenheit") {
        for ($i=0; $i<=$lastpt; $i++) {
            next if ($pdata[$i] eq "na");
            $pdata[$i] = $pdata[$i] *1.8 +32;
        }
    }
    @coords   = @valid_pdata = ();
    @pt_color = @valid_elevs = ();
    for ($i=0; $i<=$lastpt; $i++) {
        next if ($pdata[$i] eq "na");
        next if ($pt_elevations[$i] > $surf_elev +0.1/3.28084);
        $xp = $x1 +($x2-$x1)*($pdata[$i]-$xmin)/($xmax-$xmin);
        if ($ytype eq "Depth") {
            $yp = $y1 +($y2-$y1)*($surf_elev-$pt_elevations[$i])/$ymax;
        } else {
            $yp = $y2 -($y2-$y1)*($pt_elevations[$i]-$ymin)/$yrange;
        }
        push (@coords, $xp, $yp);
        push (@valid_pdata, $pdata[$i]);
        push (@valid_elevs, $pt_elevations[$i]);
        if ($estimated[$i]) {
            push (@pt_color, "DarkGray");
        } else {
            push (@pt_color, $props{$id}{ref_color});
        }
    }
    $np = ($#coords +1)/2;

#   Set up an image to hold the measured vertical profile graphic
    if ($np >= 1) {
        $iw = $x2 -$x1 +1;
        $ih = $y2 -$y1 +1;
        $ref_img = Imager->new(xsize => $iw, ysize => $ih, channels => 4);
    }

#   Plot the measured vertical profile
    if ($np > 1) {
        for ($i=1; $i<$np; $i++) {
            $xp1 = $coords[2*$i-2];
            $yp1 = $coords[2*$i-1];
            $xp2 = $coords[2*$i];
            $yp2 = $coords[2*$i+1];
            $pt1_in = ($xp1 >= $x1 && $xp1 <= $x2 &&
                       $yp1 >= $y1 && $yp1 <= $y2) ? 1 : 0;
            $pt2_in = ($xp2 >= $x1 && $xp2 <= $x2 &&
                       $yp2 >= $y1 && $yp2 <= $y2) ? 1 : 0;
            next if (! $pt1_in && ! $pt2_in);
            if (! $pt1_in) {
                if ($xp1 < $x1) {
                    $yp = $yp1 +($yp2-$yp1) *($x1-$xp1) /($xp2-$xp1);
                    $xp = $x1;
                } elsif ($xp1 > $x2) {
                    $yp = $yp1 +($yp2-$yp1) *($x2-$xp1) /($xp2-$xp1);
                    $xp = $x2;
                } else {
                    $xp = $xp1 +($xp2-$xp1) *($y1-$yp1) /($yp2-$yp1);
                    $yp = $y1;
                }
                if ($yp < $y1) {
                    $xp = $xp1 +($xp2-$xp1) *($y1-$yp1) /($yp2-$yp1);
                    $yp = $y1;
                }
                $xp1 = $xp;
                $yp1 = $yp;
            } elsif (! $pt2_in) {
                if ($xp2 < $x1) {
                    $yp = $yp1 +($yp2-$yp1) *($x1-$xp1) /($xp2-$xp1);
                    $xp = $x1;
                } elsif ($xp2 > $x2) {
                    $yp = $yp1 +($yp2-$yp1) *($x2-$xp1) /($xp2-$xp1);
                    $xp = $x2;
                } else {
                    $xp = $xp1 +($xp2-$xp1) *($y2-$yp1) /($yp2-$yp1);
                    $yp = $y2;
                }
                if ($yp > $y2) {
                    $xp = $xp1 +($xp2-$xp1) *($y2-$yp1) /($yp2-$yp1);
                    $yp = $y2;
                }
                $xp2 = $xp;
                $yp2 = $yp;
            }
            $ref_img->line(x1 => $xp1 -$x1, x2 => $xp2 -$x1,
                           y1 => $yp1 -$y1, y2 => $yp2 -$y1,
                           aa => 1,
                           color => &get_rgb_code($pt_color[$i]),
                          );
        }
    }

#   Plot the measured points
    $pix = $pt_size{$props{$id}{ref_size}};
    for ($i=0; $i<$np; $i++) {
        $xp = $coords[2*$i];
        $yp = $coords[2*$i+1];
        if ($xp >= $x1 && $xp <= $x2 && $yp >= $y1 && $yp <= $y2) {
            if ($gr_props{$id}{add_cs}) {
                $val = $valid_pdata[$i];
                $j   = int(($#colors+1) *($val-$cs_min)/($cs_max-$cs_min));
                $j   = &max(0, &min($#colors, $j));
                $ref_img->circle(x => $xp -$x1, y => $yp -$y1, r => $pix, aa => 1,
                                 color => &get_rgb_code($pt_color[$i]),
                                 fill  => { solid => $colors[$j] },
                                );
                $ref_img->circle(x => $xp -$x1, y => $yp -$y1, r => $pix, aa => 1,
                                 color  => &get_rgb_code($pt_color[$i]),
                                 filled => 0,
                                );
            } else {
                $ref_img->circle(x => $xp -$x1, y => $yp -$y1, r => $pix, aa => 1,
                                 color => &get_rgb_code($pt_color[$i]),
                                 fill  => { solid => &get_rgb_code("white") },
                                );
                $ref_img->circle(x => $xp -$x1, y => $yp -$y1, r => $pix, aa => 1,
                                 color  => &get_rgb_code($pt_color[$i]),
                                 filled => 0,
                                );
            }
        }
    }

#   Finalize and plot the image graphic
    if ($np >= 1) {
        $ref_img->write(data => \$img_data, type => 'png');
        $ref_image = Tkx::image_create_photo(-data => $img_data);
        $canv->create_image($x1, $y1, -anchor => 'nw',
                                      -image  => $ref_image,
                                      -state  => $status,
                                      -tags   => $gtag . " " . $gtag . "_refData");
        undef $ref_img;
        undef $ref_image;
        undef $img_data;
        @items = Tkx::SplitList($canv->find_withtag($gtag . "_profile"));
        if ($#items >= 0) {
            $canv->raise($gtag . "_refData", $gtag . "_profile");
        }
    }
}


################################################################################
#
#  Statistics and Differences
#
################################################################################

sub convert_to_diffs {
    my ($canv, $id, $X, $Y) = @_;
    my (
        $byear, $byear_cb, $byear_label1, $byear_label2, $conv_add,
        $conv_add_entry, $conv_mult, $conv_mult_entry, $conv_type,
        $conv_type_cb, $conv_type_label, $custom_frame, $diff_major,
        $diff_major_entry, $diff_max, $diff_max_entry, $diff_min,
        $diff_min_entry, $f, $frame, $geom, $offset_frame, $old_ref_type,
        $ok_btn, $parm_label, $ref_file, $ref_file_btn, $ref_file_label1,
        $ref_file_label2, $ref_ftype, $ref_lines, $ref_parm, $ref_parm_cb,
        $ref_parm_label1, $ref_parm_label2, $ref_tol, $ref_type,
        $ref_type_cb, $ref_val, $ref_val_entry, $ref_val_label, $row,
        $temp_msg_label, $title, $title_txt, $tol_frame, $tol_label, $txt,
        $txt_chars, $tz_offset, $tzoff_label, $units, $yr_max, $yr_min,

        @all_fmts, @fmt_grp1, @fmt_grp2, @parmlist,
       );

    &end_select($canv, $id, 1);
    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($convert_diff_menu) && Tkx::winfo_exists($convert_diff_menu)) {
        if ($convert_diff_menu->g_wm_title() eq "Convert to Difference") {
            $convert_diff_menu->g_destroy();
            undef $convert_diff_menu;
        }
    }
    $convert_diff_menu = $main->new_toplevel();
    $convert_diff_menu->g_wm_transient($main);
    $convert_diff_menu->g_wm_title("Convert to Difference");
    $convert_diff_menu->configure(-cursor => $cursor_norm);
    $convert_diff_menu->g_wm_geometry($geom);

#   Try to keep the nascent graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

    $ref_type  = "Constant";
    $ref_val   = $ref_lines = 0;
    $ref_file  = $ref_ftype = $ref_parm = "";
    $ref_tol   = 10;
    $yr_max    = (localtime(time))[5] +1900;
    $yr_min    = $yr_max -25;
    $byear     = $yr_max;
    $tz_offset = "+00:00";
    @parmlist  = ();

    $parmlist[0]  = $ref_parm;
    $old_ref_type = $ref_type;

    if ($props{$id}{meta} eq "data_profile") {
        $diff_min   = $gr_props{$id}{xmin};
        $diff_max   = $gr_props{$id}{xmax};
        $diff_major = $gr_props{$id}{xmajor};
        $title      = $gr_props{$id}{xtitle};
    } else {
        $diff_min   = $gr_props{$id}{cs_min};
        $diff_max   = $gr_props{$id}{cs_max};
        $title      = $gr_props{$id}{keytitle};
    }
    if ($props{$id}{parm} eq "Temperature") {
        $title =~ s/Temperature/Temperature Difference/;
        $title =~ s/temperature/temperature difference/;
        $txt   = "Temperature Difference, in degrees " . $props{$id}{parm_units};
        $units = "\N{U+00B0}" . substr($props{$id}{parm_units},0,1);
    } else {
        $title =~ s/$props{$id}{parm}/$props{$id}{parm} Difference/;
        $txt   = $props{$id}{parm} . " Difference, in " . $props{$id}{parm_units};
        $units = $props{$id}{parm_units};
    }
    $txt_chars = &max(25, length($txt));

#   Accepted file types
    @fmt_grp1 = ("USGS getData format",
                 "Aquarius Time-Series format",
                 "Dataquery format",
                 "USGS Water Services format",
                 "USGS Data Grapher format",
                 "CSV format",
                );
    @fmt_grp2 = ("W2 TSR format",
                 "W2 Outflow CSV format",
                 "W2 CSV format",
                 "W2 column format",
                );
    @all_fmts = (@fmt_grp1, @fmt_grp2);

#   Conversion types and factors (@conv_types is global)
    $conv_type = $conv_types[0];
    $conv_mult = 1.0;
    $conv_add  = 0.0;

#   Create input menu
    $frame = $convert_diff_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -command => sub { my ($tabid);
                              if ($ref_type =~ /Time-Series/i &&
                                  ($ref_file eq "" || ! -e $ref_file)) {
                                  return &pop_up_error($convert_diff_menu,
                                  "Reference time-series file not set or does not exist:\n$ref_file");
                              }
                              if ($diff_min eq "" || $diff_max eq "") {
                                  return &pop_up_error($convert_diff_menu,
                                  "Please provide both a minimum and maximum value.");
                              }
                              if ($diff_min >= $diff_max) {
                                  return &pop_up_error($convert_diff_menu,
                                  "The minimum value must be less than the maximum value.");
                              }
                              if ($conv_type eq "Custom") {
                                  $conv_type = sprintf("Custom,%s,%s", $conv_mult, $conv_add);
                              }
                              $props{$id}{dref_type}  = $ref_type;
                              $props{$id}{dref_val}   = $ref_val;
                              $props{$id}{dref_file}  = $ref_file;
                              $props{$id}{dref_ftype} = $ref_ftype;
                              $props{$id}{dref_lines} = $ref_lines;
                              $props{$id}{dref_parm}  = $ref_parm;
                              $props{$id}{dref_byear} = $byear;
                              $props{$id}{dref_tzoff} = $tz_offset;
                              $props{$id}{dref_ctype} = $conv_type;
                              $props{$id}{dref_tol}   = $ref_tol;
                              $props{$id}{prof_type}  = "difference";

                              if ($props{$id}{meta} eq "data_profile") {
                                  $gr_props{$id}{orig_xmin}   = $gr_props{$id}{xmin};
                                  $gr_props{$id}{orig_xmax}   = $gr_props{$id}{xmax};
                                  $gr_props{$id}{orig_xmajor} = $gr_props{$id}{xmajor};
                                  $gr_props{$id}{orig_xtitle} = $gr_props{$id}{xtitle};
                                  $gr_props{$id}{xmin}   = $diff_min;
                                  $gr_props{$id}{xmax}   = $diff_max;
                                  $gr_props{$id}{xmajor} = $diff_major;
                                  $gr_props{$id}{xtitle} = $title;
                              }
                              $gr_props{$id}{orig_cs_min}   = $gr_props{$id}{cs_min};
                              $gr_props{$id}{orig_cs_max}   = $gr_props{$id}{cs_max};
                              $gr_props{$id}{orig_keytitle} = $gr_props{$id}{keytitle};
                              $gr_props{$id}{cs_min}   = $diff_min;
                              $gr_props{$id}{cs_max}   = $diff_max;
                              $gr_props{$id}{cs_major} = "auto";
                              $gr_props{$id}{keytitle} = $title;
                              $gr_props{$id}{redraw}   = 1;

                              $convert_diff_menu->g_bind('<Destroy>', "");
                              $convert_diff_menu->g_destroy();
                              undef $convert_diff_menu;
                              &reset_bindings;

                              &calculate_diffs($id);
                              &make_data_profile($canv, $id, 1);

#                             Refresh the Graph Properties menu, if present
                              if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
                                  if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
                                      $tabid = $grprops_notebook->index('current');
                                      $geom  = $graph_props_menu->g_wm_geometry();
                                      (undef, $X, $Y) = split(/\+/, $geom);
                                      &edit_graph_props($id, $X, $Y, $tabid);
                                  }
                              }

#                             Refresh the Object Information box, if present
                              if (defined($object_infobox) && Tkx::winfo_exists($object_infobox)) {
                                  if ($object_infobox->g_wm_title() =~ /Object Info/) {
                                      $geom = $object_infobox->g_wm_geometry();
                                      (undef, $X, $Y) = split(/\+/, $geom);
                                      &show_info($canv, $id, $X, $Y);
                                  }
                              }
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $convert_diff_menu->g_bind('<Destroy>', "");
                              $convert_diff_menu->g_destroy();
                              undef $convert_diff_menu;
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Clean up if this menu is destroyed by other than the Cancel button
    $convert_diff_menu->g_bind('<Destroy>' => sub { undef $convert_diff_menu;
                                                    &reset_bindings;
                                                  });

    ($f = $convert_diff_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "Please provide a constant or time-series as the basis for a difference.",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -columnspan => 4, -sticky => 'w');

    $row++;
    $f->new_label(
            -text => "Reference Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ref_type_cb = $f->new_ttk__combobox(
            -textvariable => \$ref_type,
            -values       => [ ("Constant", "Time-Series") ],
            -width        => 12,
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $ref_type_cb->g_bind("<<ComboboxSelected>>",
                          sub { return if ($ref_type eq $old_ref_type);
                                $old_ref_type = $ref_type;
                                $ok_btn->configure(-state => 'normal');
                                if ($ref_type =~ /Constant/i) {
                                    $ref_val_label->g_grid();
                                    $ref_val_entry->g_grid();
                                    $ref_file_label1->g_grid_remove();
                                    $ref_file_label2->g_grid_remove();
                                    $ref_file_btn->g_grid_remove();
                                    $ref_parm_label1->g_grid_remove();
                                    $ref_parm_label2->g_grid_remove();
                                    $ref_parm_cb->g_grid_remove();
                                    $temp_msg_label->g_grid_remove();
                                    $conv_type_label->g_grid_remove();
                                    $conv_type_cb->g_grid_remove();
                                    $custom_frame->g_grid_remove();
                                    $tol_label->g_grid_remove();
                                    $tol_frame->g_grid_remove();
                                    $byear_label1->g_grid_remove();
                                    $byear_label2->g_grid_remove();
                                    $byear_cb->g_grid_remove();
                                    $tzoff_label->g_grid_remove();
                                    $offset_frame->g_grid_remove();
                                    if ($props{$id}{parm} eq "Temperature") {
                                        $txt = "Temperature Difference, in degrees "
                                             . $props{$id}{parm_units};
                                    } else {
                                        $txt = $props{$id}{parm} . " Difference, in "
                                             . $props{$id}{parm_units};
                                    }
                                    $txt_chars = &max(25, length($txt));
                                    $parm_label->configure(-text => $txt, -width => $txt_chars);
                                } else {
                                    $ref_val_label->g_grid_remove();
                                    $ref_val_entry->g_grid_remove();
                                    $ref_file_label1->g_grid();
                                    $ref_file_label2->g_grid();
                                    $ref_file_btn->g_grid();
                                    $ref_parm_label1->g_grid();
                                    if ($#parmlist == 0) {
                                        $ref_parm_label2->g_grid();
                                    } else {
                                        $ref_parm_cb->g_grid();
                                    }
                                    if ($ref_parm =~ /Temperature/i) {
                                        $temp_msg_label->g_grid();
                                    } else {
                                        $temp_msg_label->g_grid_remove();
                                    }
                                    $conv_type_label->g_grid();
                                    $conv_type_cb->g_grid();
                                    $custom_frame->g_grid() if ($conv_type ne "None");
                                    $tol_label->g_grid();
                                    $tol_frame->g_grid();
                                    if ($ref_ftype =~ /^W2 /) {
                                        $byear_label1->g_grid();
                                        $byear_label2->g_grid();
                                        $byear_cb->g_grid();
                                        $tzoff_label->g_grid();
                                        $offset_frame->g_grid();
                                    }
                                    if ($props{$id}{parm} eq "Temperature") {
                                        $txt = "Temperature, in degrees " . $props{$id}{parm_units};
                                    } else {
                                        $txt = $props{$id}{parm} . ", in " . $props{$id}{parm_units};
                                    }
                                    $txt_chars = &max(25, length($txt));
                                    $parm_label->configure(-text => $txt, -width => $txt_chars);
                                    if ($ref_file eq "" || ! -e $ref_file) {
                                        $ok_btn->configure(-state => 'disabled');
                                    }
                                }
                              });

    $row++;
    ($ref_val_label = $f->new_label(
            -text => "Reference Value: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ref_val_entry = $f->new_entry(
            -textvariable => \$ref_val,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $ref_val_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $ref_val_entry ]);

    $row++;
    $f->new_label(
            -text => "Data Parameter: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    ($parm_label = $f->new_label(
            -text   => $txt,
            -font   => 'default',
            -anchor => 'w',
            -width  => $txt_chars,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');

    $row++;
    ($ref_file_label1 = $f->new_label(
            -text => "Reference Data File: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ref_file_label2 = $f->new_label(
            -textvariable => \$ref_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
    ($ref_file_btn = $f->new_button(
            -text    => "Browse",
            -command => sub { my ($file);
                              $ok_btn->configure(-state => 'disabled');
                              $file = Tkx::tk___getOpenFile(
                                      -parent           => $convert_diff_menu,
                                      -title            => "Select Reference Time-Series",
                                      -initialdir       => abs_path(),
                                      -filetypes => [ ['All Files',  '*'],
                                                      ['CSV (comma delimited)', '.csv'],
                                                      ['NPT (W2 input file)', '.npt'],
                                                    ],
                                      );
                              if (defined($file) && -e $file) {
                                  $ref_file = File::Spec->rel2abs($file);
                                  ($ref_ftype, $ref_lines, @parmlist)
                                      = &determine_ts_type($convert_diff_menu, $ref_file);
                                  if (&list_match($ref_ftype, @all_fmts) == -1) {
                                      $ref_file = $ref_ftype = $ref_parm = "";
                                      $ref_lines   = 0;
                                      @parmlist    = ();
                                      $parmlist[0] = $ref_parm;
                                      $ref_parm_label2->g_grid();
                                      $ref_parm_cb->g_grid_remove();
                                      $byear_label1->g_grid_remove();
                                      $byear_label2->g_grid_remove();
                                      $byear_cb->g_grid_remove();
                                      $tzoff_label->g_grid_remove();
                                      $offset_frame->g_grid_remove();
                                      return &pop_up_error($convert_diff_menu,
                                            "Specified file format is not recognized "
                                          . "or is not honored:\n$file");
                                  }
                                  $ref_parm = $parmlist[0];
                                  if ($#parmlist > 0) {
                                      $ref_parm_label2->g_grid_remove();
                                      $ref_parm_cb->g_grid();
                                      $ref_parm_cb->configure(-values => [ @parmlist ]);
                                  } else {
                                      $ref_parm_label2->g_grid();
                                      $ref_parm_cb->g_grid_remove();
                                  }
                                  if ($ref_parm =~ /Temperature/i) {
                                      $temp_msg_label->g_grid();
                                  } else {
                                      $temp_msg_label->g_grid_remove();
                                  }
                                  $conv_type = "None";
                                  $custom_frame->g_grid_remove();

                                  if ($ref_ftype =~ /^W2 /) {
                                      $byear_label1->g_grid();
                                      $byear_label2->g_grid();
                                      $byear_cb->g_grid();
                                      $tzoff_label->g_grid();
                                      $offset_frame->g_grid();
                                  } else {
                                      $byear_label1->g_grid_remove();
                                      $byear_label2->g_grid_remove();
                                      $byear_cb->g_grid_remove();
                                      $tzoff_label->g_grid_remove();
                                      $offset_frame->g_grid_remove();
                                  }
                                  $ok_btn->configure(-state => 'normal');
                              } else {
                                  $ref_file = $ref_ftype = $ref_parm = "";
                                  $ref_lines   = 0;
                                  @parmlist    = ();
                                  $parmlist[0] = $ref_parm;
                                  $conv_type   = "None";
                                  $custom_frame->g_grid_remove();
                                  $ref_parm_label2->g_grid();
                                  $ref_parm_cb->g_grid_remove();
                                  $byear_label1->g_grid_remove();
                                  $byear_label2->g_grid_remove();
                                  $byear_cb->g_grid_remove();
                                  $tzoff_label->g_grid_remove();
                                  $offset_frame->g_grid_remove();
                              }
                            },
            ))->g_grid(-row => $row, -column => 3, -sticky => 'ew', -padx => 2, -pady => 2);

    $row++;
    ($ref_parm_label1 = $f->new_label(
            -text => "Ref. Parameter: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e');
    ($ref_parm_label2 = $f->new_label(
            -textvariable => \$ref_parm,
            -anchor       => 'w',
            -font         => 'default',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $ref_parm_label2->g_grid_remove();
    ($ref_parm_cb = $f->new_ttk__combobox(
            -textvariable => \$ref_parm,
            -values       => [ @parmlist ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $ref_parm_cb->g_bind("<<ComboboxSelected>>",
                          sub { if ($ref_parm =~ /Temperature/i) {
                                    $temp_msg_label->g_grid();
                                } else {
                                    $temp_msg_label->g_grid_remove();
                                }
                              });

    $row++;
    ($temp_msg_label = $f->new_label(
            -text => "(Please ensure temperature is in deg. Celsius.)",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

    $row++;
    ($conv_type_label = $f->new_label(
            -text => "Conversion: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($conv_type_cb = $f->new_ttk__combobox(
            -textvariable => \$conv_type,
            -values       => [ @conv_types ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $conv_type_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($conv_type eq "Custom") {
                                $custom_frame->g_grid();
                            } else {
                                $custom_frame->g_grid_remove();
                            }
                          }
                      );
    $row++;
    ($custom_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $custom_frame->new_label(
            -text => "Multiply by: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_mult_entry = $custom_frame->new_entry(
            -textvariable => \$conv_mult,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_mult_entry->g_bind("<KeyRelease>",
                              sub { &numeric_entry_only($conv_mult_entry);
                                    my $chars = &max(7, length($conv_mult));
                                    $conv_mult_entry->configure(-width => $chars);
                                  });
    $custom_frame->new_label(
            -text => "  Then add: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_add_entry = $custom_frame->new_entry(
            -textvariable => \$conv_add,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_add_entry->g_bind("<KeyRelease>",
                             sub { &numeric_entry_only($conv_add_entry);
                                   my $chars = &max(7, length($conv_add));
                                   $conv_add_entry->configure(-width => $chars);
                                 });

    $row++;
    ($tol_label = $f->new_label(
            -text => "Match Tolerance: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($tol_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $tol_frame->new_spinbox(
            -textvariable => \$ref_tol,
            -state        => 'readonly',
            -font         => 'default',
            -from         => 0,
            -to           => 60,
            -increment    => 1,
            -width        => 3,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $tol_frame->new_label(
            -text => " minutes",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');

    $row++;
    $f->new_label(
            -text => "Difference Min: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($diff_min_entry = $f->new_entry(
            -textvariable => \$diff_min,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $diff_min_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $diff_min_entry ]);
    $f->new_label(
            -textvariable => \$units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Difference Max: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($diff_max_entry = $f->new_entry(
            -textvariable => \$diff_max,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $diff_max_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $diff_max_entry ]);
    $f->new_label(
            -textvariable => \$units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

    if ($props{$id}{meta} eq "data_profile") {
        $row++;
        $f->new_label(
                -text => "Difference Major: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($diff_major_entry = $f->new_entry(
                -textvariable => \$diff_major,
                -font         => 'default',
                -width        => 7,
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $diff_major_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($diff_major_entry, 1);
                                                        $diff_major =~ s/^-//;
                                                      });
        $f->new_label(
                -textvariable => \$units,
                -font         => 'default',
                -anchor       => 'w',
                )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);
    }

    $row++;
    ($byear_label1 = $f->new_label(
            -text => "Base Year: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($byear_cb = $f->new_ttk__combobox(
            -textvariable => \$byear,
            -values       => [ reverse($yr_min .. $yr_max) ],
            -width        => 5,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $byear_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($byear == $yr_min) {
                                $yr_min -= 10;
                                $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                            }
                          });
    ($byear_label2 = $f->new_label(
            -text   => " for JDAY = 1.0",
            -anchor => 'w',
            -font   => 'default',
            ))->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

    $row++;
    ($tzoff_label = $f->new_label(
            -text => "Time Offset: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($offset_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w');
    $offset_frame->new_ttk__combobox(
            -textvariable => \$tz_offset,
            -values       => [ @tz_offsets ],
            -justify      => 'right',
            -state        => 'readonly',
            -width        => 6,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $offset_frame->new_label(
            -text   => " time zone adjustment ",
            -anchor => 'w',
            -font   => 'default',
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $offset_frame->new_button(
            -text    => "Help",
            -command => sub { &pop_up_info($convert_diff_menu,
                                    "The time offset allows the user to add or subtract a time\n"
                                  . "offset if the W2 model was run with a non-local time zone.\n\n"
                                  . "For example, if W2 was run in UTC but the local time zone\n"
                                  . "is PST, an offset of -08:00 would convert the model date/time\n"
                                  . "to a local standard time of PST. This offset does not make\n"
                                  . "any adjustments related to daylight saving time. In general,\n"
                                  . "W2 is best run in the local standard time.\n\n"
                                  . "Leave the time offset at +00:00 for no adjustment.",
                                    "Time Offset Notice");
                            },
            )->g_pack(-side => 'left', -anchor => 'w', -padx => 2);

    $row++;
    $title_txt = ($props{$id}{meta} eq "data_profile") ? "Axis Title: " : "Key Title: ";
    $f->new_label(
            -text => $title_txt,
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$title,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);

    $ref_file_label1->g_grid_remove();
    $ref_file_label2->g_grid_remove();
    $ref_file_btn->g_grid_remove();
    $ref_parm_label1->g_grid_remove();
    $ref_parm_label2->g_grid_remove();
    $ref_parm_cb->g_grid_remove();
    $temp_msg_label->g_grid_remove();
    $conv_type_label->g_grid_remove();
    $conv_type_cb->g_grid_remove();
    $custom_frame->g_grid_remove();
    $tol_label->g_grid_remove();
    $tol_frame->g_grid_remove();
    $byear_label1->g_grid_remove();
    $byear_label2->g_grid_remove();
    $byear_cb->g_grid_remove();
    $tzoff_label->g_grid_remove();
    $offset_frame->g_grid_remove();

    $f->g_grid_columnconfigure(2, -weight => 2);

    Tkx::wm_resizable($convert_diff_menu,0,0);
    &adjust_window_position($convert_diff_menu);
    $convert_diff_menu->g_focus;
}


sub calculate_diffs {
    my ($id) = @_;
    my (
        $byear, $conv_type, $data_daily, $ref_file, $ref_type, $dt, $dt_ref,
        $dt_ref2, $found, $ftype, $mi, $n, $nd, $nlines, $parm, $pbar,
        $pbar_window, $pmax, $pmin, $ref_daily, $ref_val, $tol, $tzoff,

        @all_fmts, @data, @fmt_grp1, @fmt_grp2, @keys_dat, @keys_ref,

        %pdata, %ref_data,
       );

    $ref_type = $props{$id}{dref_type};
    if ($ref_type =~ /Constant/i) {
        $ref_val   = $props{$id}{dref_val};
    } else {
        $ref_file  = $props{$id}{dref_file};
        $ftype     = $props{$id}{dref_ftype};
        $nlines    = $props{$id}{dref_lines};
        $conv_type = $props{$id}{dref_ctype};
        $parm      = $props{$id}{dref_parm};
        $tol       = $props{$id}{dref_tol};

        @fmt_grp1 = ("USGS getData format",
                     "Aquarius Time-Series format",
                     "Dataquery format",
                     "USGS Water Services format",
                     "USGS Data Grapher format",
                     "CSV format",
                    );
        @fmt_grp2 = ("W2 TSR format",
                     "W2 Outflow CSV format",
                     "W2 CSV format",
                     "W2 column format",
                    );
        @all_fmts = (@fmt_grp1, @fmt_grp2);
    }
    $pbar = "";
    $pmax = -9.E6;
    $pmin =  9.E6;

#   Get and save the original parameter data and limits
    $gr_props{$id}{orig_parm_min} = $gr_props{$id}{parm_min};
    $gr_props{$id}{orig_parm_max} = $gr_props{$id}{parm_max};
    $gr_props{$id}{orig_pdata}    = $gr_props{$id}{pdata};
    %pdata = %{ $gr_props{$id}{pdata} };

#   Read the reference time series
    if ($ref_type !~ /Constant/i) {
        if ($nlines > 4000 && &list_match($ftype, @all_fmts) >= 0) {
            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $nlines,
                                                         "Reading time-series file...");
        }
        if (&list_match($ftype, @fmt_grp1) >= 0) {
            %ref_data = &read_timeseries($main, $ref_file, $ftype, $parm, $pbar);

        } elsif (&list_match($ftype, @fmt_grp2) >= 0) {
            $byear    = $props{$id}{dref_byear};
            $tzoff    = $props{$id}{dref_tzoff};
            %ref_data = &read_w2_timeseries($main, $ref_file, $ftype, $parm, $byear, $tzoff, $pbar);

        } else {
            return &pop_up_error($main, "Reference time-series file format not honored.");
        }
        if ($nlines > 4000 && &list_match($ftype, @all_fmts) >= 0) {
            &destroy_progress_bar($main, $pbar_window);
        }
        if (&list_match($conv_type, @conv_types) > 0 || $conv_type =~ /^Custom,/) {
            %ref_data = &convert_timeseries($main, $conv_type, 0, %ref_data);
        }
    }

#   Set up a progress bar using the number of dates
    $nd = 0;
    @keys_dat = keys %pdata;
    ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $#keys_dat +1,
                                                 "Calculating differences...");
    &reset_progress_bar($pbar, $#keys_dat +1, "Calculating differences... Date = 1");

#   Convert values using a constant reference
    if ($ref_type =~ /Constant/i) {
        foreach $dt (sort @keys_dat) {
            &update_progress_bar($pbar, ++$nd, $dt);
            next if (! defined($pdata{$dt}));
            @data = @{ $pdata{$dt} };
            for ($n=0; $n<=$#data; $n++) {
                next if $data[$n] eq "na";
                $data[$n] -= $ref_val;
                $pmin = $data[$n] if ($data[$n] < $pmin);
                $pmax = $data[$n] if ($data[$n] > $pmax);
            }
            $pdata{$dt} = [ @data ];
        }

#   Convert values using a time-series reference
    } else {
        @keys_ref   = keys %ref_data;
        $data_daily = (length($keys_dat[0]) == 12) ? 0 : 1;
        $ref_daily  = (length($keys_ref[0]) == 12) ? 0 : 1;

        foreach $dt (sort @keys_dat) {
            &update_progress_bar($pbar, ++$nd, $dt);
            delete $pdata{$dt} if (! defined($pdata{$dt}));
            $dt_ref = $dt;
            if ($data_daily != $ref_daily) {
                if ($ref_daily) {
                    $dt_ref = &nearest_daily_dt($dt);
                    if (&get_dt_diff($dt, 10000 *$dt_ref) > $tol || ! defined($ref_data{$dt_ref})) {
                        delete $pdata{$dt};
                        next;
                    }
                } else {
                    $dt_ref .= "0000";
                }
            }
            if (! defined($ref_data{$dt_ref})) {
                if (($data_daily && $ref_daily) || $tol == 0) {
                    delete $pdata{$dt};
                    next;
                }
                $found = 0;
                for ($mi=1; $mi<=$tol; $mi++) {
                    $dt_ref2 = &adjust_dt($dt_ref, $mi);
                    if (defined($ref_data{$dt_ref2})) {
                        $dt_ref = $dt_ref2;
                        $found  = 1;
                        last;
                    }
                    $dt_ref2 = &adjust_dt($dt_ref, -1 *$mi);
                    if (defined($ref_data{$dt_ref2})) {
                        $dt_ref = $dt_ref2;
                        $found  = 1;
                        last;
                    }
                }
                if (! $found) {
                    delete $pdata{$dt};
                    next;
                }
            }

#           Compute differences
            @data = @{ $pdata{$dt} };
            for ($n=0; $n<=$#data; $n++) {
                next if $data[$n] eq "na";
                $data[$n] -= $ref_data{$dt_ref};
                $pmin = $data[$n] if ($data[$n] < $pmin);
                $pmax = $data[$n] if ($data[$n] > $pmax);
            }
            $pdata{$dt} = [ @data ];
        }
    }

#   Kill the progress bar and save the data
    &destroy_progress_bar($main, $pbar_window);

#   Save the modified data and the new parameter limits
    $gr_props{$id}{parm_min} = $pmin;
    $gr_props{$id}{parm_max} = $pmax;
    $gr_props{$id}{pdata}    = { %pdata };
}


sub undo_diffs {
    my ($canv, $id, $X, $Y) = @_;
    my (
        $f, $frame, $geom, $pmax, $pmax_entry, $pmin, $pmin_entry, $row,
        $title, $title_chars, $title_txt, $units, $xmajor, $xmajor_entry,
        $xmax, $xmax_entry, $xmin, $xmin_entry,
       );

    &end_select($canv, $id, 1);
    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($undo_diff_menu) && Tkx::winfo_exists($undo_diff_menu)) {
        if ($undo_diff_menu->g_wm_title() eq "Undo Difference") {
            $undo_diff_menu->g_destroy();
            undef $undo_diff_menu;
        }
    }
    $undo_diff_menu = $main->new_toplevel();
    $undo_diff_menu->g_wm_transient($main);
    $undo_diff_menu->g_wm_title("Undo Difference");
    $undo_diff_menu->configure(-cursor => $cursor_norm);
    $undo_diff_menu->g_wm_geometry($geom);

#   Try to keep the nascent graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

    if ($props{$id}{meta} eq "data_profile") {
        if (defined($gr_props{$id}{orig_xmin})) {
            $xmin   = $gr_props{$id}{orig_xmin};
            $xmax   = $gr_props{$id}{orig_xmax};
            $xmajor = $gr_props{$id}{orig_xmajor};
            $pmin   = $gr_props{$id}{orig_cs_min};
            $pmax   = $gr_props{$id}{orig_cs_max};
            $title  = $gr_props{$id}{orig_xtitle};
        } else {
            $xmin   = $gr_props{$id}{xmin};
            $xmax   = $gr_props{$id}{xmax};
            $xmajor = $gr_props{$id}{xmajor};
            $pmin   = $gr_props{$id}{cs_min};
            $pmax   = $gr_props{$id}{cs_max};
            $title  = $gr_props{$id}{xtitle};
        }
    } else {
        if (defined($gr_props{$id}{orig_cs_min})) {
            $pmin   = $gr_props{$id}{orig_cs_min};
            $pmax   = $gr_props{$id}{orig_cs_max};
            $title  = $gr_props{$id}{orig_keytitle};
        } else {
            $pmin   = $gr_props{$id}{cs_min};
            $pmax   = $gr_props{$id}{cs_max};
            $title  = $gr_props{$id}{keytitle};
        }
    }
    if ($props{$id}{parm} eq "Temperature") {
        $title =~ s/Temperature Difference/Temperature/;
        $title =~ s/temperature difference/temperature/;
        $units = "\N{U+00B0}" . substr($props{$id}{parm_units},0,1);
    } else {
        $title =~ s/$props{$id}{parm} Difference/$props{$id}{parm}/;
        $title =~ s/$props{$id}{parm} difference/$props{$id}{parm}/;
        $units = $props{$id}{parm_units};
    }
    $title_chars = &max(25, length($title));

#   Create input menu
    $frame = $undo_diff_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    $frame->new_button(
            -text    => "OK",
            -command => sub { my ($tabid);
                              if ($pmin eq "" || $pmax eq "") {
                                  return &pop_up_error($undo_diff_menu,
                                  "Please provide both a minimum and maximum value.");
                              }
                              if ($pmin >= $pmax) {
                                  return &pop_up_error($undo_diff_menu,
                                  "The minimum value must be less than the maximum value.");
                              }
                              if ($props{$id}{meta} eq "data_profile") {
                                  if ($xmin eq "" || $xmax eq "") {
                                      return &pop_up_error($undo_diff_menu,
                                      "Please provide both a minimum and maximum X axis value.");
                                  }
                                  if ($xmin >= $xmax) {
                                      return &pop_up_error($undo_diff_menu,
                                          "The minimum X axis value must be\n"
                                        . "less than the maximum X axis value.");
                                  }
                                  if ($xmajor eq "" || $xmajor == 0) {
                                      return &pop_up_error($undo_diff_menu,
                                      "Please provide a nonzero X axis major spacing.");
                                  }
                                  $gr_props{$id}{xmin}   = $xmin;
                                  $gr_props{$id}{xmax}   = $xmax;
                                  $gr_props{$id}{xmajor} = $xmajor;
                                  $gr_props{$id}{xtitle} = $title;
                              }
                              $gr_props{$id}{cs_min}   = $pmin;
                              $gr_props{$id}{cs_max}   = $pmax;
                              $gr_props{$id}{cs_major} = "auto";
                              $gr_props{$id}{keytitle} = $title;

                              $gr_props{$id}{parm_min} = $gr_props{$id}{orig_parm_min};
                              $gr_props{$id}{parm_max} = $gr_props{$id}{orig_parm_max};
                              $gr_props{$id}{pdata}    = $gr_props{$id}{orig_pdata};
                              $props{$id}{prof_type}   = "standard";
                              $gr_props{$id}{redraw}   = 1;

                              $undo_diff_menu->g_bind('<Destroy>', "");
                              $undo_diff_menu->g_destroy();
                              undef $undo_diff_menu;
                              &reset_bindings;

                              &make_data_profile($canv, $id, 1);

#                             Refresh the Graph Properties menu, if present
                              if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
                                  if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
                                      $tabid = $grprops_notebook->index('current');
                                      $geom  = $graph_props_menu->g_wm_geometry();
                                      (undef, $X, $Y) = split(/\+/, $geom);
                                      &edit_graph_props($id, $X, $Y, $tabid);
                                  }
                              }

#                             Refresh the Object Information box, if present
                              if (defined($object_infobox) && Tkx::winfo_exists($object_infobox)) {
                                  if ($object_infobox->g_wm_title() =~ /Object Info/) {
                                      $geom = $object_infobox->g_wm_geometry();
                                      (undef, $X, $Y) = split(/\+/, $geom);
                                      &show_info($canv, $id, $X, $Y);
                                  }
                              }
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $undo_diff_menu->g_bind('<Destroy>', "");
                              $undo_diff_menu->g_destroy();
                              undef $undo_diff_menu;
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Clean up if this menu is destroyed by other than the Cancel button
    $undo_diff_menu->g_bind('<Destroy>' => sub { undef $undo_diff_menu;
                                                 &reset_bindings;
                                               });

    ($f = $undo_diff_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_pack(-side => 'top');

    $row = -1;
    if ($props{$id}{meta} eq "data_profile") {
        $row++;
        $f->new_label(
                -text => "X Axis Min: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($xmin_entry = $f->new_entry(
                -textvariable => \$xmin,
                -font         => 'default',
                -width        => 7,
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $xmin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $xmin_entry ]);
        $f->new_label(
                -textvariable => \$units,
                -font         => 'default',
                -anchor       => 'w',
                )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);
        $row++;
        $f->new_label(
                -text => "X Axis Max: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($xmax_entry = $f->new_entry(
                -textvariable => \$xmax,
                -font         => 'default',
                -width        => 7,
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $xmax_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $xmax_entry ]);
        $f->new_label(
                -textvariable => \$units,
                -font         => 'default',
                -anchor       => 'w',
                )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);
        $row++;
        $f->new_label(
                -text => "X Axis Major: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($xmajor_entry = $f->new_entry(
                -textvariable => \$xmajor,
                -font         => 'default',
                -width        => 7,
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $xmajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($xmajor_entry, 1);
                                                    $xmajor =~ s/^-//;
                                                  });
        $f->new_label(
                -textvariable => \$units,
                -font         => 'default',
                -anchor       => 'w',
                )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);
    }

    $row++;
    $f->new_label(
            -text => "Scale Min: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmin_entry = $f->new_entry(
            -textvariable => \$pmin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmin_entry ]);
    $f->new_label(
            -textvariable => \$units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Scale Max: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmax_entry = $f->new_entry(
            -textvariable => \$pmax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmax_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmax_entry ]);
    $f->new_label(
            -textvariable => \$units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

    $row++;
    $title_txt = ($props{$id}{meta} eq "data_profile") ? "Axis Title: " : "Key Title: ";
    $f->new_label(
            -text => $title_txt,
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$title,
            -font         => 'default',
            -width        => $title_chars,
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);

    $f->g_grid_columnconfigure(2, -weight => 2);

    Tkx::wm_resizable($undo_diff_menu,0,0);
    &adjust_window_position($undo_diff_menu);
    $undo_diff_menu->g_focus;
}


sub find_data_limits {
    my ($id, %profile) = @_;
    my (
        $dmax, $dmin, $dt, $dt2, $dtmax, $dtmin, $emax, $emin, $got_depth,
        $i, $k, $kb, $maxdepth, $pmax, $pmin, $qmax, $qmin, $qsum, $qtot_max,
        $qtot_min, $vtot_max, $vtot_min,

        @depths, @elevations, @flow, @pdata, @qstr, @velo,
        %limits, %parm_data, %qdata, %qtot_data, %vtot_data, %wsurf,
       );

    %wsurf     = %{ $profile{ws_elev} };
    %parm_data = %{ $profile{pdata}   };
    %limits    = ();

    $dtmin = $dtmax = -999;
    $pmax  = $emax  = $dmax = -9.E6;
    $pmin  = $emin  = $dmin =  9.E6;
    $got_depth = ($profile{elv_dep} eq "elevation") ? 0 : 1;
    if ($got_depth) {
        @depths     = @{ $profile{depths} };
        $maxdepth   = &max(@depths);
        $dmin       = &min(@depths);
        $dmax       = $maxdepth;
    } else {
        @elevations = @{ $profile{elevations} };
        $emin       = &min(@elevations);
    }
    foreach $dt (keys %wsurf) {
        next if ($wsurf{$dt} eq "na");
        $emax = $wsurf{$dt} if ($wsurf{$dt} > $emax);
        if ($got_depth) {
            $emin = $wsurf{$dt} -$maxdepth if ($wsurf{$dt} -$maxdepth < $emin);
        } else {
            $dmax = $wsurf{$dt} -$emin if ($wsurf{$dt} -$emin > $dmax);
            for ($i=0; $i<=$#elevations; $i++) {
                next if ($elevations[$i] > $wsurf{$dt} +0.1/3.28084);
                $dmin = $wsurf{$dt} -$elevations[$i] if ($wsurf{$dt} -$elevations[$i] < $dmin);
            }
        }
    }
    $dmin = &max(0.0, $dmin);
    foreach $dt (keys %parm_data) {
        @pdata = @{ $parm_data{$dt} };
        $dt2   = (length($dt) == 12) ? $dt : $dt *10000;
        $dtmin = $dt2 if ($dtmin == -999 || $dt2 < $dtmin);  # dates tied to profile{pdata}
        $dtmax = $dt2 if ($dtmax == -999 || $dt2 > $dtmax);
        for ($i=0; $i<=$#pdata; $i++) {
            next if ($pdata[$i] eq "na");
            if (! $got_depth && defined($wsurf{$dt})) {
                next if ($wsurf{$dt} eq "na");
                next if ($elevations[$i] > $wsurf{$dt} +0.1/3.28084);
            }
            $pmin = $pdata[$i] if ($pdata[$i] < $pmin);
            $pmax = $pdata[$i] if ($pdata[$i] > $pmax);
        }
    }
    $limits{date_min} = $dtmin;
    $limits{date_max} = $dtmax;
    $limits{dpth_min} = ($dmin <  9.E6) ? $dmin : "n/a";
    $limits{dpth_max} = ($dmax > -9.E6) ? $dmax : "n/a";
    $limits{elev_min} = ($emin <  9.E6) ? $emin : "n/a";
    $limits{elev_max} = ($emax > -9.E6) ? $emax : "n/a";
    $limits{parm_min} = ($pmin <  9.E6) ? $pmin : "n/a";
    $limits{parm_max} = ($pmax > -9.E6) ? $pmax : "n/a";

    if ($props{$id}{meta} eq "vert_wd_zone") {
        $qmax  = -9.E6;
        $qmin  =  9.E6;
        %qdata = %{ $profile{qdata} };
        foreach $dt (keys %qdata) {
            $dt2  = (length($dt) == 12) ? $dt : $dt *10000;
            next if ($dtmin == -999 || $dt2 < $dtmin || $dt2 > $dtmax);
            @qstr = @{ $qdata{$dt} };
            $qsum = &sum(@qstr);
            $qmin = $qsum if ($qsum < $qmin);
            $qmax = $qsum if ($qsum > $qmax);
        }
        $limits{flow_min} = ($qmin <  9.E6) ? $qmin : "n/a";
        $limits{flow_max} = ($qmax > -9.E6) ? $qmax : "n/a";

#       Assess the layer-specific flows and velocities, if available
        if (defined($profile{qtot_data})) {
            $kb        = $profile{kb};
            $qtot_max  = $vtot_max = -9.E6;
            $qtot_min  = $vtot_min =  9.E6;
            %qtot_data = %{ $profile{qtot_data} };
            %vtot_data = %{ $profile{vtot_data} };
            foreach $dt (keys %qtot_data) {
                $dt2  = (length($dt) == 12) ? $dt : $dt *10000;
                next if ($dtmin == -999 || $dt2 < $dtmin || $dt2 > $dtmax);
                @flow = @{ $qtot_data{$dt} };
                @velo = @{ $vtot_data{$dt} };
                for ($k=1; $k<=$kb; $k++) {
                    $qtot_min = $flow[$k] if ($flow[$k] < $qtot_min);
                    $qtot_max = $flow[$k] if ($flow[$k] > $qtot_max);
                    $vtot_min = $velo[$k] if ($velo[$k] < $vtot_min);
                    $vtot_max = $velo[$k] if ($velo[$k] > $vtot_max);
                }
            }
            $limits{qtot_min} = ($qtot_min <  9.E6) ? $qtot_min : "n/a";
            $limits{qtot_max} = ($qtot_max > -9.E6) ? $qtot_max : "n/a";
            $limits{vtot_min} = ($vtot_min <  9.E6) ? $vtot_min : "n/a";
            $limits{vtot_max} = ($vtot_max > -9.E6) ? $vtot_max : "n/a";
        } else {
            $limits{qtot_min} = "not determined";
            $limits{qtot_max} = "not determined";
            $limits{vtot_min} = "not determined";
            $limits{vtot_max} = "not determined";
        }
    }
    return %limits;
}


sub find_w2_profile_limits {
    my ($id, $seg, $elev_ref, $pdata_ref) = @_;
    my ($dt, $dtmax, $dtmin, $emax, $emin, $i, $pmax, $pmin,
        @el, @kb, @pdata,
        %elev_data, %limits, %parm_data,
       );

    %elev_data = %{ $elev_ref  };
    %parm_data = %{ $pdata_ref };
    %limits    = ();

    @el   = @{ $grid{$id}{el} };
    @kb   = @{ $grid{$id}{kb} };
    $emin = $el[$kb[$seg]+1][$seg];
    $pmax = $emax = $dtmin = $dtmax = -999.;
    $pmin = 9.E6;
    foreach $dt (keys %elev_data) {
        $emax = $elev_data{$dt} if ($elev_data{$dt} > $emax);
    }
    foreach $dt (keys %parm_data) {
        @pdata = @{ $parm_data{$dt} };
        $dtmin = $dt if ($dtmin == -999 || $dt < $dtmin);
        $dtmax = $dt if ($dtmax == -999 || $dt > $dtmax);
        for ($i=0; $i<=$#pdata; $i++) {
            $pmin = $pdata[$i] if ($pdata[$i] < $pmin);
            $pmax = $pdata[$i] if ($pdata[$i] > $pmax);
        }
    }
    $dtmin *= 10000 if ($dtmin != -999 && length($dtmin) == 8);
    $dtmax *= 10000 if ($dtmax != -999 && length($dtmax) == 8);
    $limits{date_min} = $dtmin;
    $limits{date_max} = $dtmax;
    $limits{dpth_min} = 0.0;
    $limits{dpth_max} = $emax -$emin;
    $limits{elev_min} = $emin;
    $limits{elev_max} = $emax;
    $limits{parm_min} = $pmin;
    $limits{parm_max} = $pmax;

    return %limits;
}


sub find_w2_outflow_limits {
    my ($id, $seg, $qdata_ref, $vdata_ref) = @_;
    my (
        $dt, $dtmax, $dtmin, $emax, $emin, $k, $kmx, $nd, $pbar,
        $pbar_window, $qmax, $qmin, $vmax, $vmin,
        @el, @kb, @flow, @qdates, @velo,
        %limits, %qdata, %vdata,
       );

    %qdata  = %{ $qdata_ref     };
    %vdata  = %{ $vdata_ref     };
    @el     = @{ $grid{$id}{el} };
    @kb     = @{ $grid{$id}{kb} };
    $kmx    = $grid{$id}{kmx};
    $emin   = $el[$kb[$seg]+1][$seg];   # elevation in meters
    $dtmin  = $dtmax = -999;
    $qmax   = $vmax  = $emax = -9.E6;
    $qmin   = $vmin  = 9.E6;
    %limits = ();

    @qdates = sort keys %qdata;
    ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $#qdates +1,
                                                 "Finding outflow limits...");
    &reset_progress_bar($pbar, $#qdates +1, "Finding outflow limits... Date = 1");

    for ($nd=0; $nd<=$#qdates; $nd++) {
        $dt    = $qdates[$nd];
        $dtmin = $dt if ($dtmin == -999 || $dt < $dtmin);
        $dtmax = $dt if ($dtmax == -999 || $dt > $dtmax);
        &update_progress_bar($pbar, $nd, $dt) if ($nd % 10 == 0);

        @flow = @{ $qdata{$dt} };
        @velo = @{ $vdata{$dt} };
        $emax = $flow[1] if ($flow[1] > $emax);  # $flow[1] is WS elevation
        for ($k=2; $k<=$kmx; $k++) {
            next if (! defined($flow[$k]) || $flow[$k] eq "");
            $vmin = $velo[$k] if ($velo[$k] < $vmin);
            $vmax = $velo[$k] if ($velo[$k] > $vmax);
            $qmin = $flow[$k] if ($flow[$k] < $qmin);
            $qmax = $flow[$k] if ($flow[$k] > $qmax);
        }
    }
    $dtmin *= 10000 if ($dtmin != -999 && length($dtmin) == 8);
    $dtmax *= 10000 if ($dtmax != -999 && length($dtmax) == 8);
    $limits{date_min} = $dtmin;
    $limits{date_max} = $dtmax;
    $limits{dpth_min} = 0.0;          # units: meters
    $limits{dpth_max} = $emax -$emin;
    $limits{elev_min} = $emin;        # units: meters
    $limits{elev_max} = $emax;
    $limits{flow_min} = $qmin;        # units: cms per vertical meter
    $limits{flow_max} = $qmax;
    $limits{vel_min}  = $vmin;        # units: m/s
    $limits{vel_max}  = $vmax;
    &destroy_progress_bar($main, $pbar_window);

    return %limits;
}


sub find_w2_slice_limits {
    my ($id, %profile) = @_;
    my (
        $dmax, $dt, $dtmax, $dtmin, $emax, $emin, $i, $jb, $jw, $k, $kmx,
        $kt, $n, $nbr, $nd, $ns, $nwb, $pbar, $pbar_window, $pmax, $pmin,
        $seg_dn, $seg_up, $src_type,

        @be, @bs, @cus, @ds, @el, @elws, @kb, @pdata, @sdates, @seg_br,
        @seg_limits, @seg_wb, @seglist, @slice_data, @us, @wbs,

        %limits, %sdata,
       );

    $src_type   = $props{$id}{src_type};        # contour or vector
    @slice_data = @{ $profile{slice_data} };
    %limits     = ();

    @wbs   = split(/,/, $props{$id}{wb_list});
    $nwb   = $grid{$id}{nwb};
    $nbr   = $grid{$id}{nbr};
    $kmx   = $grid{$id}{kmx};
    @bs    = @{ $grid{$id}{bs}  };
    @be    = @{ $grid{$id}{be}  };
    @us    = @{ $grid{$id}{us}  };
    @ds    = @{ $grid{$id}{ds}  };
    @kb    = @{ $grid{$id}{kb}  };
    @el    = @{ $grid{$id}{el}  };
    $pmax  = $emax = $dmax = -9.E6;
    $pmin  = $emin = 9.E6;
    $dtmin = $dtmax = -999;

    @seg_limits = reverse split(/,|-/, $props{$id}{seg_list});
    @seglist    = ();
    @seg_wb     = ();
    @seg_br     = ();
    for ($n=0; $n<$#seg_limits; $n+=2) {
        $seg_dn = $seg_limits[$n];
        $seg_up = $seg_limits[$n+1];
        for ($jb=1; $jb<=$nbr; $jb++) {
            last if ($seg_dn >= $us[$jb] && $seg_dn <= $ds[$jb]);
        }
        for ($jw=1; $jw<=$nwb; $jw++) {
            last if ($jb >= $bs[$jw] && $jb <= $be[$jw]);
        }
        for ($i=$seg_dn; $i>=$seg_up; $i--) {
            $seg_wb[$i] = $jw;
            $seg_br[$i] = $jb;
            push (@seglist, $i);
            $emin = $el[$kb[$i]+1][$i] if ($el[$kb[$i]+1][$i] < $emin);
        }
    }

#   Set up a progress bar.  It will reset itself for each waterbody.
    @sdates = keys %{ $slice_data[0] };
    ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $#sdates +1,
                                                 "Finding parameter limits...");
    &reset_progress_bar($pbar, $#sdates +1, "Finding parameter limits... Date = 1");

    for ($n=0; $n<=$#wbs; $n++) {
        $jw = $wbs[$n];
        if ($n == 0 || $src_type =~ /Contour/i) {
            %sdata  = %{ $slice_data[$n] };
            @sdates = sort keys %sdata;
        }
        for ($nd=0; $nd<=$#sdates; $nd++) {
            $dt    = $sdates[$nd];
            $dtmin = $dt if ($dtmin == -999 || $dt < $dtmin);
            $dtmax = $dt if ($dtmax == -999 || $dt > $dtmax);
            &update_progress_bar($pbar, $nd, $dt);

            if ($src_type =~ /Contour/i) {
                $kt = $sdata{$dt}{kt};
            } else {
                $kt = $sdata{$dt}{kt}[$jw];       # vector file has kt values in array
            }
            @cus   = @{ $sdata{$dt}{cus}       };
            @elws  = @{ $sdata{$dt}{elws}      };
            @pdata = @{ $sdata{$dt}{parm_data} };
            for ($ns=0; $ns<=$#seglist; $ns++) {
                $i = $seglist[$ns];
                next if ($jw != $seg_wb[$i]);
                next if (! defined($cus[$seg_br[$i]]) || $cus[$seg_br[$i]] == 0 || $i < $cus[$seg_br[$i]]);
                $emax = $elws[$i] if ($elws[$i] > $emax);
                $dmax = $elws[$i] -$el[$kb[$i]+1][$i] if ($elws[$i] -$el[$kb[$i]+1][$i] > $dmax);
                for ($k=$kt; $k<=$kmx; $k++) {
                    last if (! defined($pdata[$k][$i]));               # cannot count on kb for sloped grid
                    last if ($src_type =~ /Vector/i && $pdata[$k][$i] == -99); # vector flag, inactive cell
                    $pmin = $pdata[$k][$i] if ($pdata[$k][$i] < $pmin);
                    $pmax = $pdata[$k][$i] if ($pdata[$k][$i] > $pmax);
                }
            }
        }
    }
    $dtmin *= 10000 if ($dtmin != -999 && length($dtmin) == 8);
    $dtmax *= 10000 if ($dtmax != -999 && length($dtmax) == 8);
    $limits{date_min} = $dtmin;
    $limits{date_max} = $dtmax;
    $limits{dpth_min} = 0.0;
    $limits{dpth_max} = $dmax;
    $limits{elev_min} = $emin;
    $limits{elev_max} = $emax;
    $limits{parm_min} = $pmin;
    $limits{parm_max} = $pmax;
    &destroy_progress_bar($main, $pbar_window);

    return %limits;
}


sub find_w2_tdmap_limits {
    my ($id, %data) = @_;
    my (
        $dt, $dtmax, $dtmin, $j, $nd, $pbar, $pbar_window, $pmax, $pmin,
        $seg, $skip,
        @seg_limits, @td_dates,
        %limits,
       );

    $nd     =     0;
    $pmax   = -9.E6;
    $pmin   =  9.E6;
    $dtmin  = $dtmax = -999;
    %limits = ();

    @seg_limits = split(/,|-/, $props{$id}{seg_list});

#   Set up a progress bar.  It will reset itself for each waterbody.
    @td_dates = keys %data;
    ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $#td_dates +1,
                                                 "Finding parameter limits...");
    &reset_progress_bar($pbar, $#td_dates +1, "Finding parameter limits... Date = 1");

#   Loop over the dates
    foreach $dt (sort @td_dates) {
        $nd++;
        $dtmin = $dt if ($dtmin == -999 || $dt < $dtmin);
        $dtmax = $dt if ($dtmax == -999 || $dt > $dtmax);
        &update_progress_bar($pbar, $nd, $dt);

#       Loop over the segments
        foreach $seg (keys %{ $data{$dt} }) {
            $skip = 1;
            for ($j=0; $j<$#seg_limits; $j+=2) {
                if ($seg >= $seg_limits[$j] && $seg <= $seg_limits[$j+1]) {
                    $skip = 0;
                    last;
                }
            }
            next if ($skip);                                         # segment not included
            next if ($data{$dt}{$seg} == -99);                       # inactive cell
            $pmin = $data{$dt}{$seg} if ($data{$dt}{$seg} < $pmin);
            $pmax = $data{$dt}{$seg} if ($data{$dt}{$seg} > $pmax);
        }
    }
    $dtmin *= 10000 if ($dtmin != -999 && length($dtmin) == 8);
    $dtmax *= 10000 if ($dtmax != -999 && length($dtmax) == 8);
    $limits{date_min} = $dtmin;
    $limits{date_max} = $dtmax;
    $limits{parm_min} = ($pmin <  9.E6) ? $pmin : "n/a";
    $limits{parm_max} = ($pmax > -9.E6) ? $pmax : "n/a";
    &destroy_progress_bar($main, $pbar_window);

    return %limits;
}


sub find_w2_wlevel_limits {
    my ($id, %data) = @_;
    my (
        $dt, $dtmax, $dtmin, $emax, $emin, $i, $n, $nd, $pbar, $pbar_window,
        $seg,
        @seg_limits, @seglist, @wl_dates,
        %limits,
       );

    $nd     = -1;
    $emax   = -9.E6;
    $emin   =  9.E6;
    $dtmin  = $dtmax = -999;
    %limits = ();

#   Set up segment list
    @seg_limits = split(/,|-/, $props{$id}{seg_list});
    @seglist    = ();
    for ($n=0; $n<$#seg_limits; $n+=2) {
        for ($i=$seg_limits[$n]; $i<=$seg_limits[$n+1]; $i++) {
            push (@seglist, $i);
        }
    }

#   Set up a progress bar
    @wl_dates = keys %data;
    ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $#wl_dates +1,
                                                 "Finding parameter limits...");
    &reset_progress_bar($pbar, $#wl_dates +1, "Finding parameter limits... Date = 1");

#   Loop over the dates
    foreach $dt (sort @wl_dates) {
        $dtmin = $dt if ($dtmin == -999 || $dt < $dtmin);
        $dtmax = $dt if ($dtmax == -999 || $dt > $dtmax);
        if (++$nd %10 == 0) {
            &update_progress_bar($pbar, $nd, $dt);
        }

#       Loop over the segments
        for ($i=0; $i<=$#seglist; $i++) {
            $seg  = $seglist[$i];
            next if ($data{$dt}[$seg] == -999);
            $emin = $data{$dt}[$seg] if ($data{$dt}[$seg] < $emin);
            $emax = $data{$dt}[$seg] if ($data{$dt}[$seg] > $emax);
        }
    }
    $dtmin *= 10000 if ($dtmin != -999 && length($dtmin) == 8);
    $dtmax *= 10000 if ($dtmax != -999 && length($dtmax) == 8);
    $limits{date_min} = $dtmin;
    $limits{date_max} = $dtmax;
    $limits{elev_min} = ($emin <  9.E6) ? $emin : "n/a";
    $limits{elev_max} = ($emax > -9.E6) ? $emax : "n/a";
    &destroy_progress_bar($main, $pbar_window);

    return %limits;
}


sub find_ts_limits {
    my ($id, $vonly, $dtlo, $dthi) = @_;
    my (
        $dt, $dt2, $dtmax, $dtmin, $link_id, $mult, $n, $nsets, $pmax,
        $pmin, $sum, $wt,

        @add_ts_limits, @add_ts_show, @add_ts_tsdata, @flows, @names,
        @qstr, @show, @tstr,

        %add_ts_parms, %limits, %parms, %qdata, %tdata, %ts_data, %wsurf,
       );

#   vonly is a flag telling this routine to evaluate limits only for non-hidden datasets
#   dtlo is an optional date (YYYYMMDDHHmm) constraining the minimum date for the search
#   dthi is an optional date (YYYYMMDDHHmm) constraining the maximum date for the search

    $pmin  =  9.E6;
    $pmax  = -9.E6;
    $dtmin = $dtmax = -999;
    $dtlo  = -9.E12 if (! defined($dtlo) || $dtlo eq "");
    $dthi  =  9.E12 if (! defined($dthi) || $dthi eq "");
    $vonly = 0 if (! defined($vonly) || $vonly eq "" || $vonly ne "1");

#   For linked time-series, start by finding the limits of the linked data
    if ($props{$id}{meta} eq "linked_time_series") {
        $link_id = $props{$id}{link_id};
        %parms   = %{ $props{$id}{ts_parms} };
        @show    = @{ $parms{show} };
        if ($parms{ts_type} eq "Water Surface Elevation") {
            if ($props{$link_id}{meta} =~ /^(data_profile|vert_wd_zone)$/) {
                %wsurf = %{ $gr_props{$link_id}{ws_elev} };
            } elsif ($props{$link_id}{meta} eq "w2_profile") {
                %wsurf = %{ $gr_props{$link_id}{elev_data} };
            } elsif ($props{$link_id}{meta} eq "w2_outflow") {
                %qdata = %{ $gr_props{$link_id}{qdata} };
                %wsurf = ();
                foreach $dt (keys %qdata) {
                    @flows = @{ $qdata{$dt} };
                    $wsurf{$dt} = $flows[1];
                }
                undef %qdata;
                undef @flows;
            }
            $mult  = ($parms{units} eq "ft") ? 3.28084 : 1.0;
            foreach $dt (sort keys %wsurf) {
                next if (! defined($wsurf{$dt}) || $wsurf{$dt} eq "na");
                $dt2 = (length($dt) == 12) ? $dt : $dt *10000;
                next if ($dt2 < $dtlo);
                last if ($dt2 > $dthi);
                $dtmin = $dt2 if ($dtmin == -999 || $dt2 < $dtmin);
                $dtmax = $dt2 if ($dtmax == -999 || $dt2 > $dtmax);
                $pmin  = $wsurf{$dt} *$mult if ($wsurf{$dt} *$mult < $pmin);
                $pmax  = $wsurf{$dt} *$mult if ($wsurf{$dt} *$mult > $pmax);
            }
            undef %wsurf;

        } elsif ($parms{ts_type} eq "Release Rate") {
            %qdata = %{ $gr_props{$link_id}{qdata} };
            $mult  = ($parms{units} eq "cfs") ? 35.31467 : 1.0;
            if ($props{$link_id}{meta} eq "vert_wd_zone") {
                @names = @{ $gr_props{$link_id}{names} };
            } elsif ($props{$link_id}{meta} eq "w2_outflow") {
                @names = ("All Outlets");
            }
            if (! $vonly || &sum(@show) > 0) {
                foreach $dt (sort keys %qdata) {
                    next if (! defined($qdata{$dt}));
                    $dt2 = (length($dt) == 12) ? $dt : $dt *10000;
                    if ($gr_props{$link_id}{date_min} != -999) {
                        next if ($dt2 < $gr_props{$link_id}{date_min});
                        last if ($dt2 > $gr_props{$link_id}{date_max});
                    }
                    next if ($dt2 < $dtlo);
                    last if ($dt2 > $dthi);
                    $dtmin = $dt2 if ($dtmin == -999 || $dt2 < $dtmin);
                    $dtmax = $dt2 if ($dtmax == -999 || $dt2 > $dtmax);
                    @qstr  = @{ $qdata{$dt} };
                    if (! $vonly || $show[$#show]) {
                        if ($props{$link_id}{meta} eq "w2_outflow") {
                            $sum = $qstr[0];
                        } else {
                            $sum = &sum(@qstr);
                        }
                        $pmax = $sum *$mult if ($sum *$mult > $pmax);
                    }
                    for ($n=0; $n<=$#names; $n++) {
                        next if ($vonly && ! $show[$n]);
                        $pmin = $qstr[$n] *$mult if ($qstr[$n] *$mult < $pmin);
                        $pmax = $qstr[$n] *$mult if ($qstr[$n] *$mult > $pmax);
                    }
                }
            }
            undef %qdata;

        } elsif ($parms{ts_type} eq "Temperature") {
            %tdata = %{ $gr_props{$link_id}{tdata} };
            @names = @{ $gr_props{$link_id}{names} };
            push (@names, "All Outlets");
            if (! $vonly || &sum(@show) > 0) {
                foreach $dt (sort keys %tdata) {
                    next if (! defined($tdata{$dt}));
                    $dt2 = (length($dt) == 12) ? $dt : $dt *10000;
                    if ($gr_props{$link_id}{date_min} != -999) {
                        next if ($dt2 < $gr_props{$link_id}{date_min});
                        last if ($dt2 > $gr_props{$link_id}{date_max});
                    }
                    next if ($dt2 < $dtlo);
                    last if ($dt2 > $dthi);
                    @tstr = @{ $tdata{$dt} };
                    for ($n=0; $n<=$#names; $n++) {
                        next if ($vonly && ! $show[$n]);
                        $wt = $tstr[$n];
                        if ($wt > -99) {
                            $wt    = 1.8 *$wt +32 if ($parms{units} eq "Fahrenheit");
                            $dtmin = $dt2 if ($dtmin == -999 || $dt2 < $dtmin);
                            $dtmax = $dt2 if ($dtmax == -999 || $dt2 > $dtmax);
                            $pmin  = $wt if ($wt < $pmin);
                            $pmax  = $wt if ($wt > $pmax);
                        }
                    }
                }
            }
            undef %tdata;
        }
    }

#   Check limits of other time-series datasets.  No need to check units.
    if (defined($props{$id}{add_ts_parms})) {
        %add_ts_parms = %{ $props{$id}{add_ts_parms} };
        @add_ts_show  = @{ $add_ts_parms{ts_show} };
        if ($dtlo > -9.E12 && $dthi < 9.E12) {             # check each point
            @add_ts_tsdata = @{ $add_ts_parms{ts_data} };
            $nsets = $#add_ts_tsdata +1;
            for ($n=0; $n<$nsets; $n++) {
                next if ($vonly && ! $add_ts_show[$n]);
                %ts_data = %{ $add_ts_tsdata[$n] };
                foreach $dt (sort keys %ts_data) {
                    $dt2 = (length($dt) == 12) ? $dt : $dt *10000;
                    next if ($dt2 < $dtlo);
                    last if ($dt2 > $dthi);
                    next if ($ts_data{$dt} eq "na");
                    $dtmin = $dt2 if ($dtmin == -999 || $dt2 < $dtmin);
                    $dtmax = $dt2 if ($dtmax == -999 || $dt2 > $dtmax);
                    $pmin  = $ts_data{$dt} if ($ts_data{$dt} < $pmin);
                    $pmax  = $ts_data{$dt} if ($ts_data{$dt} > $pmax);
                }
            }
        } else {                                           # just check the limits
            @add_ts_limits = @{ $add_ts_parms{ts_limits} };
            $nsets = $#add_ts_limits +1;
            for ($n=0; $n<$nsets; $n++) {
                next if ($vonly && ! $add_ts_show[$n]);
                %limits = %{ $add_ts_limits[$n] };
                $dtmin = $limits{date_min} if ($dtmin == -999 || $limits{date_min} < $dtmin);
                $dtmax = $limits{date_max} if ($dtmax == -999 || $limits{date_max} > $dtmax);
                $pmin  = $limits{parm_min} if ($limits{parm_min} < $pmin);
                $pmax  = $limits{parm_max} if ($limits{parm_max} > $pmax);
            }
        }
    }
    return ($dtmin, $dtmax, $pmin, $pmax);
}


sub setup_ref_stats {
    my ($canv, $id, $X, $Y) = @_;
    my (
        $bdate_frame, $bday, $bday_alt, $bday_cb, $bday_sav, $bm, $bm_alt,
        $bmon, $bmon_alt, $bmon_cb, $bmon_sav, $byr, $byr_alt, $byr_cb,
        $byr_sav, $dates_cb, $dates_opt, $dates_opt_sav, $dt_begin, $dt_end,
        $edate_frame, $eday, $eday_alt, $eday_cb, $eday_sav, $em, $em_alt,
        $emon, $emon_alt, $emon_cb, $emon_sav, $eyr, $eyr_alt, $eyr_cb,
        $eyr_sav, $f, $frame, $geom, $got_depth, $interp, $interp_txt,
        $monthly, $row, $yr_max, $yr_min,

        @date_ops, @keys_data,
        %parm_data, %ref_profile,
       );

    &end_select($canv, $id, 1);

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($ref_stats_menu) && Tkx::winfo_exists($ref_stats_menu)) {
        if ($ref_stats_menu->g_wm_title() eq "Choose Profile Fit Statistics") {
            $ref_stats_menu->g_destroy();
            undef $ref_stats_menu;
        }
    }
    $ref_stats_menu = $main->new_toplevel();
    $ref_stats_menu->g_wm_transient($main);
    $ref_stats_menu->g_wm_title("Choose Profile Fit Statistics");
    $ref_stats_menu->configure(-cursor => $cursor_norm);
    $ref_stats_menu->g_wm_geometry($geom);

#   Try to keep any objects from being selected. Reset bindings later.
    $canvas->g_bind("<Motion>", "");

    $monthly   = 1;
    $interp    = 1;
    $dates_opt = $dates_opt_sav = "Include all dates";
    if (defined($gr_props{$id}{date_min})) {
        $dt_begin = $gr_props{$id}{date_min};
        $dt_end   = $gr_props{$id}{date_max};
    } else {
        %parm_data = %{ $gr_props{$id}{parm_data} };
        @keys_data = sort keys %parm_data;
        $dt_begin  = $keys_data[0];
        $dt_end    = $keys_data[$#keys_data];
        $dt_begin *= 10000 if (length($dt_begin) == 8);
        $dt_end   *= 10000 if (length($dt_end)   == 8);
        undef %parm_data;
        undef @keys_data;
    }
    %ref_profile = %{ $gr_props{$id}{ref_data} };
    $got_depth   = ($ref_profile{elv_dep} eq "elevation") ? 0 : 1;
    if ($got_depth) {
        $interp_txt = "Interpolate profile to measured depths";
    } else {
        $interp_txt = "Interpolate profile to measured elevations";
    }
    undef %ref_profile;

    ($bm, $bday, $byr) = &parse_date($dt_begin, 1);
    ($em, $eday, $eyr) = &parse_date(&jdate2date(&ceil(&date2jdate($dt_end))), 1);
    $bm--;
    $em--;
    $bday    += 0;
    $eday    += 0;
    $bmon     = $mon_names[$bm];
    $emon     = $mon_names[$em];
    $bday_sav = $bday;
    $eday_sav = $eday;
    $bmon_sav = $bmon;
    $emon_sav = $emon;
    $byr_sav  = $byr;
    $eyr_sav  = $eyr;
    $yr_max   = (localtime(time))[5] +1900;
    $yr_min   = $yr_max -25;
    $yr_min   = $byr if ($byr < $yr_min);
    $yr_max   = $eyr if ($eyr > $yr_max);

    if ($global_dt_limits) {
        ($bm_alt, $bday_alt, $byr_alt) = &parse_date($global_dt_begin, 1);
        ($em_alt, $eday_alt, $eyr_alt) = &parse_date($global_dt_end,   1);
        $bday_alt += 0;
        $eday_alt += 0;
        $bmon_alt  = $mon_names[$bm_alt-1];
        $emon_alt  = $mon_names[$em_alt-1];
        $yr_min    = $byr_alt if ($byr_alt < $yr_min);
        $yr_max    = $eyr_alt if ($eyr_alt > $yr_max);
        @date_ops  = ("Include all dates", "Use global date limits", "Custom date range");
    } else {
        @date_ops  = ("Include all dates", "Custom date range");
    }

#   Build the menu.
    $frame = $ref_stats_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    $frame->new_button(
            -text    => "OK",
            -command => sub { my ($m);
                              if ($dates_opt eq "Include all dates") {
                                  $dt_begin = $dt_end = -999;
                              } elsif ($global_dt_limits && $dates_opt eq "Use global date limits") {
                                  $dt_begin = $global_dt_begin;
                                  $dt_end   = $global_dt_end;
                              } else {
                                  $m        = &list_match($bmon, @mon_names);
                                  $dt_begin = sprintf("%04d%02d%02d0000", $byr, $m+1, $bday);
                                  $m        = &list_match($emon, @mon_names);
                                  $dt_end   = sprintf("%04d%02d%02d0000", $eyr, $m+1, $eday);
                                  if ($dt_begin > $dt_end) {
                                      return &pop_up_error($ref_stats_menu,
                                                  "The start date is after the end date.\n"
                                                . "Please adjust and try again.");
                                  } elsif ($dt_begin == $dt_end) {
                                      return &pop_up_error($ref_stats_menu,
                                                  "The start date is equal to the end date.\n"
                                                . "Please adjust and try again.");
                                  }
                              }

                              $ref_stats_menu->g_bind('<Destroy>', "");
                              $ref_stats_menu->g_destroy();
                              undef $ref_stats_menu;
                              &reset_bindings;

                              &show_ref_stats($id, $interp, $monthly, $dt_begin, $dt_end);
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $ref_stats_menu->g_bind('<Destroy>', "");
                              $ref_stats_menu->g_destroy();
                              undef $ref_stats_menu;
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2); 

#   Reset bindings if this menu is destroyed by other than the Cancel button
    $ref_stats_menu->g_bind('<Destroy>' => sub { undef $ref_stats_menu;
                                                 &reset_bindings;
                                               });

    ($f = $ref_stats_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_pack(-side => 'top', -expand => 1, -fill => 'both');

    $row = 0;
    $f->new_label(
            -text => "Choose a set of options for the goodness-of-fit statistics:",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -columnspan => 2, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Options: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $f->new_checkbutton(
            -onvalue  => 1,
            -offvalue => 0,
            -text     => $interp_txt,
            -font     => 'default',
            -variable => \$interp,
            )->g_grid(-row => $row, -column => 1, -sticky => 'w');

    $row++;
    $f->new_checkbutton(
            -onvalue  => 1,
            -offvalue => 0,
            -text     => "Include stats by month",
            -font     => 'default',
            -variable => \$monthly,
            )->g_grid(-row => $row, -column => 1, -sticky => 'w');

    $row++;
    $f->new_label(
            -text => "Date Range: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($dates_cb = $f->new_ttk__combobox(
            -textvariable => \$dates_opt,
            -values       => [ @date_ops ],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w');
    $dates_cb->g_bind("<<ComboboxSelected>>",
                       sub { return if ($dates_opt eq $dates_opt_sav);
                             if ($dates_opt eq "Custom date range") {
                                 $bmon_cb->configure(-state => 'readonly');
                                 $bday_cb->configure(-state => 'readonly');
                                 $byr_cb->configure(-state  => 'readonly');
                                 $emon_cb->configure(-state => 'readonly');
                                 $eday_cb->configure(-state => 'readonly');
                                 $eyr_cb->configure(-state  => 'readonly');
                             } else {
                                 $bmon_cb->configure(-state => 'disabled');
                                 $bday_cb->configure(-state => 'disabled');
                                 $byr_cb->configure(-state  => 'disabled');
                                 $emon_cb->configure(-state => 'disabled');
                                 $eday_cb->configure(-state => 'disabled');
                                 $eyr_cb->configure(-state  => 'disabled');
                                 if ($dates_opt eq "Use global date limits") {
                                     $bmon = $bmon_alt;
                                     $bday = $bday_alt;
                                     $byr  = $byr_alt;
                                     $emon = $emon_alt;
                                     $eday = $eday_alt;
                                     $eyr  = $eyr_alt;
                                 } else {
                                     $bmon = $bmon_sav;
                                     $bday = $bday_sav;
                                     $byr  = $byr_sav;
                                     $emon = $emon_sav;
                                     $eday = $eday_sav;
                                     $eyr  = $eyr_sav;
                                 }
                             }
                             $dates_opt_sav = $dates_opt;
                           }
                     );

    $row++;
    $f->new_label(
            -text => "Start Date: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($bdate_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w');
    ($bmon_cb = $bdate_frame->new_ttk__combobox(
            -textvariable => \$bmon,
            -values       => [ @mon_names ],
            -state        => 'readonly',
            -width        => 4,
            ))->g_pack(-side => 'left');
    $bmon_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($byr);
                          $bm = &list_match($bmon, @mon_names);
                          $bday_cb->configure(-values => [ 1 .. $days_in_month[$bm] ]);
                          $bday = $days_in_month[$bm] if ($bday > $days_in_month[$bm]);
                        }
                    );
    $bdate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($bday_cb = $bdate_frame->new_ttk__combobox(
            -textvariable => \$bday,
            -values       => [ 1 .. $days_in_month[$bm] ],
            -state        => 'readonly',
            -width        => 3,
            ))->g_pack(-side => 'left');
    $bdate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($byr_cb = $bdate_frame->new_ttk__combobox(
            -textvariable => \$byr,
            -values       => [ reverse($yr_min .. $yr_max) ],
            -state        => 'readonly',
            -width        => 5,
            ))->g_pack(-side => 'left');
    $byr_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($byr);
                          $bm = &list_match($bmon, @mon_names);
                          if ($bm == 1) {
                              $bday_cb->configure(-values => [ 1 .. $days_in_month[$bm] ]);
                              $bday = $days_in_month[$bm] if ($bday > $days_in_month[$bm]);
                          }
                          if ($byr == $yr_min || $byr == $yr_max) {
                              $yr_min -= 10 if ($byr == $yr_min);
                              $yr_max += 10 if ($byr == $yr_max);
                              $byr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                              $eyr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                          }
                        }
                    );

    $row++;
    $f->new_label(
            -text => "End Date: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($edate_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w');
    ($emon_cb = $edate_frame->new_ttk__combobox(
            -textvariable => \$emon,
            -values       => [ @mon_names ],
            -state        => 'readonly',
            -width        => 4,
            ))->g_pack(-side => 'left');
    $emon_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($eyr);
                          $em = &list_match($emon, @mon_names);
                          $eday_cb->configure(-values => [ 1 .. $days_in_month[$em] ]);
                          $eday = $days_in_month[$em] if ($eday > $days_in_month[$em]);
                        }
                    );
    $edate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($eday_cb = $edate_frame->new_ttk__combobox(
            -textvariable => \$eday,
            -values       => [ 1 .. $days_in_month[$em] ],
            -state        => 'readonly',
            -width        => 3,
            ))->g_pack(-side => 'left');
    $edate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($eyr_cb = $edate_frame->new_ttk__combobox(
            -textvariable => \$eyr,
            -values       => [ reverse($yr_min .. $yr_max) ],
            -state        => 'readonly',
            -width        => 5,
            ))->g_pack(-side => 'left');
    $eyr_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($eyr);
                          $em = &list_match($emon, @mon_names);
                          if ($em == 1) {
                              $eday_cb->configure(-values => [ 1 .. $days_in_month[$em] ]);
                              $eday = $days_in_month[$em] if ($eday > $days_in_month[$em]);
                          }
                          if ($eyr == $yr_min || $eyr == $yr_max) {
                              $yr_min -= 10 if ($eyr == $yr_min);
                              $yr_max += 10 if ($eyr == $yr_max);
                              $byr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                              $eyr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                          }
                        }
                    );

    $f->g_grid_columnconfigure(1, -weight => 1);

    $bmon_cb->configure(-state => 'disabled');
    $bday_cb->configure(-state => 'disabled');
    $byr_cb->configure(-state  => 'disabled');
    $emon_cb->configure(-state => 'disabled');
    $eday_cb->configure(-state => 'disabled');
    $eyr_cb->configure(-state  => 'disabled');

    Tkx::wm_resizable($ref_stats_menu,0,0);
    &adjust_window_position($ref_stats_menu);
    $ref_stats_menu->g_focus;
}


sub show_ref_stats {
    my ($id, $interp, $monthly, $dt_begin, $dt_end) = @_;
    my (
        $col, $estat_ref, $f, $frame, $geom, $m, $mon, $pstat_ref,
        $pstat2_ref, $ref_window, $row, $seg, $tol, $txt, $X, $x1, $x2,
        $Y, $y1, $y2,

        %elev_data, %parm_data, %ref_profile, %estats, %pstats, %pstats2,
       );

    $monthly     = 1    if (! defined($monthly)  || $monthly ne "0");
    $interp      = 0    if (! defined($interp)   || $interp  ne "1");
    $dt_begin    = -999 if (! defined($dt_begin) || $dt_begin !~ /^[12][0-9][0-9][0-9][01][0-9][0-3][0-9]/);
    $dt_end      = -999 if (! defined($dt_end)   || $dt_end   !~ /^[12][0-9][0-9][0-9][01][0-9][0-3][0-9]/);
    $tol         = $props{$id}{ref_tol};
    $seg         = $props{$id}{seg};
    %elev_data   = %{ $gr_props{$id}{elev_data} };
    %parm_data   = %{ $gr_props{$id}{parm_data} };
    %ref_profile = %{ $gr_props{$id}{ref_data}  };

    $status_line = "Computing fit statistics...";
    Tkx::update();

    ($pstat_ref, $pstat2_ref, $estat_ref)
            = &get_stats_ref_profile($id, $seg, $monthly, $tol, $interp, $dt_begin, $dt_end,
                                     \%elev_data, \%parm_data, \%ref_profile);
    undef %elev_data;
    undef %parm_data;
    undef %ref_profile;

    %pstats  = %{ $pstat_ref  };
    %pstats2 = %{ $pstat2_ref };
    %estats  = %{ $estat_ref  };
    $status_line = "";

#   Convert units, if needed
    if ($props{$id}{parm} eq "Temperature" && $props{$id}{parm_units} eq "Fahrenheit") {
        if ($pstats{n}{all} > 0) {
            $pstats{me}{all}   *= 1.8;
            $pstats{mae}{all}  *= 1.8;
            $pstats{rmse}{all} *= 1.8;
            if ($monthly) {
                for ($m=0; $m<12; $m++) {
                    $mon = $mon_names[$m];
                    if ($pstats{n}{$mon} > 0) {
                        $pstats{me}{$mon}   *= 1.8;
                        $pstats{mae}{$mon}  *= 1.8;
                        $pstats{rmse}{$mon} *= 1.8;
                    }
                }
            }
        }
        if ($pstats2{n}{all} > 0) {
            $pstats2{me}{all}   *= 1.8;
            $pstats2{mae}{all}  *= 1.8;
            $pstats2{rmse}{all} *= 1.8;
            if ($monthly) {
                for ($m=0; $m<12; $m++) {
                    $mon = $mon_names[$m];
                    if ($pstats2{n}{$mon} > 0) {
                        $pstats2{me}{$mon}   *= 1.8;
                        $pstats2{mae}{$mon}  *= 1.8;
                        $pstats2{rmse}{$mon} *= 1.8;
                    }
                }
            }
        }
    }
    if ($gr_props{$id}{yunits} eq "feet") {
        if ($estats{n}{all} > 0) {
            $estats{me}{all}   *= 3.28084;
            $estats{mae}{all}  *= 3.28084;
            $estats{rmse}{all} *= 3.28084;
            if ($monthly) {
                for ($m=0; $m<12; $m++) {
                    $mon = $mon_names[$m];
                    if ($estats{n}{$mon} > 0) {
                        $estats{me}{$mon}   *= 3.28084;
                        $estats{mae}{$mon}  *= 3.28084;
                        $estats{rmse}{$mon} *= 3.28084;
                    }
                }
            }
        }
    }

    ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $geom = sprintf("+%d+%d", $X+$x1+50, $Y+$y1+60);

    if ($interp) {
        if (defined($ref_stats_interp_window) && Tkx::winfo_exists($ref_stats_interp_window)) {
            if ($ref_stats_interp_window->g_wm_title()
                    eq "Profile Goodness-of-Fit Statistics (Vertically Interpolated)") {
                $ref_stats_interp_window->g_destroy();
                undef $ref_stats_interp_window;
            }
        }
        $ref_stats_interp_window = $main->new_toplevel();
        $ref_stats_interp_window->g_wm_transient($main);
        $ref_stats_interp_window->g_wm_title("Profile Goodness-of-Fit Statistics (Vertically Interpolated)");
        $ref_window = $ref_stats_interp_window;
    } else {
        if (defined($ref_stats_window) && Tkx::winfo_exists($ref_stats_window)) {
            if ($ref_stats_window->g_wm_title() eq "Profile Goodness-of-Fit Statistics") {
                $ref_stats_window->g_destroy();
                undef $ref_stats_window;
            }
        }
        $ref_stats_window = $main->new_toplevel();
        $ref_stats_window->g_wm_transient($main);
        $ref_stats_window->g_wm_title("Profile Goodness-of-Fit Statistics");
        $ref_window = $ref_stats_window;
    }
    $ref_window->configure(-cursor => $cursor_norm);
    $ref_window->g_wm_geometry($geom);

    $frame = $ref_window->new_frame();
    $frame->g_pack(-side => 'bottom');
    $frame->new_button(
            -text    => "OK",
            -command => sub { $ref_window->g_destroy();
                              undef $ref_window;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Save",
            -command => sub { my ($dir, $file, $fname, $m, $mon, $project_path, $vol);
                              $file = Tkx::tk___getSaveFile(
                                  -parent           => $ref_window,
                                  -title            => "Save Profile Statistics",
                                  -initialdir       => abs_path(),
                                  -defaultextension => ".txt",
                                  -filetypes => [ ['Text Files', '.txt'],
                                                  ['All Files',  '*'],
                                                ],
                                  );
                              if (defined($file) && $file ne "") {
                                  open (OUT, ">", $file)
                                      || return &pop_up_error($ref_window, "Unable to open\n$file");
                                  print OUT "# W2 Animator, version $version\n";
                                  print OUT "# File created: ", &get_datetime, "\n";
                                  if ($savefile ne "") {
                                      ($vol, $dir, $fname) = File::Spec->splitpath($savefile);
                                      $project_path = $vol . $dir;
                                      $file = File::Spec->rel2abs($savefile, $project_path);
                                      print OUT "# W2Anim project: $file\n";
                                  }
                                  if ($interp) {
                                      $txt = "# Modeled profiles were vertically interpolated to "
                                           . "match the measured vertical profile measurement points "
                                           . "for each comparison.\n";
                                  } else {
                                      $txt = "# Modeled profiles were NOT vertically interpolated. "
                                           . "Measured points were compared to modeled values for "
                                           . "the appropriate model layer.\n";
                                  }
                                  if ($dt_begin != -999 && $dt_end != -999) {
                                      $txt .= "# All\* = Dates in the range "
                                            . &date2datelabel($dt_begin, "Mon-DD-YYYY") . " to "
                                            . &date2datelabel($dt_end,   "Mon-DD-YYYY") . "\n\n";
                                  } else {
                                      $txt .= "# All\* = All available dates\n\n";
                                  }
                                  print OUT $txt;
                                  if ($estats{n}{all} > 0) {
                                      print OUT "\tGoodness-of-Fit Statistics";
                                      print OUT "\t\t\t\tMean Fit Statistics By Profile";
                                      print OUT "\t\t\t\tGoodness-of-Fit Statistics\n";
                                      print OUT "\t", $props{$id}{parm};
                                      print OUT "\t\t\t\t", $props{$id}{parm};
                                      print OUT "\t\t\t\tWater-Surface Elevation\n";
                                      print OUT "\t(", $props{$id}{parm_units}, ")";
                                      print OUT "\t\t\t\t(", $props{$id}{parm_units}, ")";
                                      print OUT "\t\t\t\t(", $gr_props{$id}{yunits}, ")\n";
                                      print OUT "\tn\tME\tMAE\tRMSE\tn\tME\tMAE\tRMSE\tn\tME\tMAE\tRMSE\n";
                                      print OUT "All\*\t", $pstats{n}{all};
                                      if ($pstats{me}{all} eq "na") {
                                          print OUT "\tna\tna\tna";
                                      } else {
                                          print OUT "\t", sprintf("%.4f",$pstats{me}{all});
                                          print OUT "\t", sprintf("%.4f",$pstats{mae}{all});
                                          print OUT "\t", sprintf("%.4f",$pstats{rmse}{all});
                                      }
                                      print OUT "\t", $pstats2{n}{all};
                                      if ($pstats2{me}{all} eq "na") {
                                          print OUT "\tna\tna\tna";
                                      } else {
                                          print OUT "\t", sprintf("%.4f",$pstats2{me}{all});
                                          print OUT "\t", sprintf("%.4f",$pstats2{mae}{all});
                                          print OUT "\t", sprintf("%.4f",$pstats2{rmse}{all});
                                      }
                                      print OUT "\t", $estats{n}{all};
                                      if ($estats{me}{all} eq "na") {
                                          print OUT "\tna\tna\tna\n";
                                      } else {
                                          print OUT "\t", sprintf("%.4f",$estats{me}{all});
                                          print OUT "\t", sprintf("%.4f",$estats{mae}{all});
                                          print OUT "\t", sprintf("%.4f",$estats{rmse}{all}), "\n";
                                      }
                                      if ($monthly) {
                                          for ($m=0; $m<12; $m++) {
                                              $mon = $mon_names[$m];
                                              print OUT "$mon\t", $pstats{n}{$mon};
                                              if ($pstats{me}{$mon} eq "na") {
                                                  print OUT "\tna\tna\tna";
                                              } else {
                                                  print OUT "\t", sprintf("%.4f",$pstats{me}{$mon});
                                                  print OUT "\t", sprintf("%.4f",$pstats{mae}{$mon});
                                                  print OUT "\t", sprintf("%.4f",$pstats{rmse}{$mon});
                                              }
                                              print OUT "\t", $pstats2{n}{$mon};
                                              if ($pstats2{me}{$mon} eq "na") {
                                                  print OUT "\tna\tna\tna";
                                              } else {
                                                  print OUT "\t", sprintf("%.4f",$pstats2{me}{$mon});
                                                  print OUT "\t", sprintf("%.4f",$pstats2{mae}{$mon});
                                                  print OUT "\t", sprintf("%.4f",$pstats2{rmse}{$mon});
                                              }
                                              print OUT "\t", $estats{n}{$mon};
                                              if ($estats{me}{$mon} eq "na") {
                                                  print OUT "\tna\tna\tna\n";
                                              } else {
                                                  print OUT "\t", sprintf("%.4f",$estats{me}{$mon});
                                                  print OUT "\t", sprintf("%.4f",$estats{mae}{$mon});
                                                  print OUT "\t", sprintf("%.4f",$estats{rmse}{$mon}), "\n";
                                              }
                                          }
                                      }
                                  } else {
                                      print OUT "\tGoodness-of-Fit Statistics";
                                      print OUT "\t\t\t\tMean Fit Statistics By Profile\n";
                                      print OUT "\t", $props{$id}{parm};
                                      print OUT "\t\t\t\t", $props{$id}{parm}, "\n";
                                      print OUT "\t(", $props{$id}{parm_units}, ")";
                                      print OUT "\t\t\t\t(", $props{$id}{parm_units}, ")\n";
                                      print OUT "\tn\tME\tMAE\tRMSE";
                                      print OUT "\tn\tME\tMAE\tRMSE\n";
                                      print OUT "All\*\t", $pstats{n}{all};
                                      if ($pstats{me}{all} eq "na") {
                                          print OUT "\tna\tna\tna";
                                      } else {
                                          print OUT "\t", sprintf("%.4f",$pstats{me}{all});
                                          print OUT "\t", sprintf("%.4f",$pstats{mae}{all});
                                          print OUT "\t", sprintf("%.4f",$pstats{rmse}{all});
                                      }
                                      print OUT "\t", $pstats2{n}{all};
                                      if ($pstats2{me}{all} eq "na") {
                                          print OUT "\tna\tna\tna\n";
                                      } else {
                                          print OUT "\t", sprintf("%.4f",$pstats2{me}{all});
                                          print OUT "\t", sprintf("%.4f",$pstats2{mae}{all});
                                          print OUT "\t", sprintf("%.4f",$pstats2{rmse}{all}), "\n";
                                      }
                                      if ($monthly) {
                                          for ($m=0; $m<12; $m++) {
                                              $mon = $mon_names[$m];
                                              print OUT "$mon\t", $pstats{n}{$mon};
                                              if ($pstats{me}{$mon} eq "na") {
                                                  print OUT "\tna\tna\tna";
                                              } else {
                                                  print OUT "\t", sprintf("%.4f",$pstats{me}{$mon});
                                                  print OUT "\t", sprintf("%.4f",$pstats{mae}{$mon});
                                                  print OUT "\t", sprintf("%.4f",$pstats{rmse}{$mon});
                                              }
                                              print OUT "\t", $pstats2{n}{$mon};
                                              if ($pstats2{me}{$mon} eq "na") {
                                                  print OUT "\tna\tna\tna\n";
                                              } else {
                                                  print OUT "\t", sprintf("%.4f",$pstats2{me}{$mon});
                                                  print OUT "\t", sprintf("%.4f",$pstats2{mae}{$mon});
                                                  print OUT "\t", sprintf("%.4f",$pstats2{rmse}{$mon}), "\n";
                                              }
                                          }
                                      }
                                  }
                                  close (OUT)
                                      || return &pop_up_error($ref_window, "Trouble closing\n$file");
                              }
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

    ($f = $ref_window->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_pack(-side => 'top');

    $row = 0;
    $col = 1;
    $f->new_label(
            -text   => "Goodness-of-Fit Statistics",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+1, -columnspan => 4);
    $row++;
    $f->new_label(
            -text   => $props{$id}{parm},
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+1, -columnspan => 4);
    $row++;
    $f->new_label(
            -text   => "(" . $props{$id}{parm_units} . ")",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+1, -columnspan => 4);

    $row++;
    if ($monthly) {
        $f->new_ttk__separator(
                -orient => 'vertical',
                )->g_grid(-row => $row, -rowspan => 17, -column => $col, -sticky => 'ns');
    } else {
        $f->new_ttk__separator(
                -orient => 'vertical',
                )->g_grid(-row => $row, -rowspan => 5, -column => $col, -sticky => 'ns');
    }
    $f->new_label(
            -text   => "n",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+1, -sticky => 's', -ipadx => 3, -pady => 2);
    $f->new_label(
            -text   => "Mean\nError",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+2, -sticky => 's', -ipadx => 3, -pady => 2);
    $f->new_label(
            -text   => "Mean\nAbsolute\nError",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+3, -sticky => 's', -ipadx => 3, -pady => 2);
    $f->new_label(
            -text   => "Root\nMean\nSquared\nError",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+4, -sticky => 's', -ipadx => 3, -pady => 2);

    $row++;
    $f->new_ttk__separator(
            -orient => 'horizontal',
            )->g_grid(-row => $row, -column => $col-1, -columnspan => 6, -sticky => 'ew');

    $row++;
    $f->new_label(
            -text   => "All\*",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col-1, -ipadx => 2, -pady => 2);
    $f->new_label(
            -text   => $pstats{n}{all},
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+1, -ipadx => 2, -pady => 2);
    $f->new_label(
            -text   => ($pstats{me}{all} eq "na") ? "na" : sprintf("%.4f",$pstats{me}{all}),
            -anchor => 'e',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+2, -ipadx => 2, -pady => 2);
    $f->new_label(
            -text   => ($pstats{mae}{all} eq "na") ? "na" : sprintf("%.4f",$pstats{mae}{all}),
            -anchor => 'e',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+3, -ipadx => 2, -pady => 2);
    $f->new_label(
            -text   => ($pstats{rmse}{all} eq "na") ? "na" : sprintf("%.4f",$pstats{rmse}{all}),
            -anchor => 'e',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+4, -ipadx => 2, -pady => 2);

    $row++;
    $f->new_ttk__separator(
            -orient => 'horizontal',
            )->g_grid(-row => $row, -column => $col-1, -columnspan => 6, -sticky => 'ew');

    if ($monthly) {
        for ($m=0; $m<12; $m++) {
            $mon = $mon_names[$m];
            $row++;
            $f->new_label(
                    -text   => $mon,
                    -anchor => 'center',
                    -font   => 'default',
                    )->g_grid(-row => $row, -column => $col-1, -ipadx => 2, -pady => 2);
            $f->new_label(
                    -text   => $pstats{n}{$mon},
                    -anchor => 'center',
                    -font   => 'default',
                    )->g_grid(-row => $row, -column => $col+1, -ipadx => 2, -pady => 2);
            $f->new_label(
                    -text   => ($pstats{me}{$mon} eq "na") ? "na" : sprintf("%.4f",$pstats{me}{$mon}),
                    -anchor => 'e',
                    -font   => 'default',
                    )->g_grid(-row => $row, -column => $col+2, -ipadx => 2, -pady => 2);
            $f->new_label(
                    -text   => ($pstats{mae}{$mon} eq "na") ? "na" : sprintf("%.4f",$pstats{mae}{$mon}),
                    -anchor => 'e',
                    -font   => 'default',
                    )->g_grid(-row => $row, -column => $col+3, -ipadx => 2, -pady => 2);
            $f->new_label(
                    -text   => ($pstats{rmse}{$mon} eq "na") ? "na" : sprintf("%.4f",$pstats{rmse}{$mon}),
                    -anchor => 'e',
                    -font   => 'default',
                    )->g_grid(-row => $row, -column => $col+4, -ipadx => 2, -pady => 2);
        }
        $row++;
        $f->new_ttk__separator(
                -orient => 'horizontal',
                )->g_grid(-row => $row, -column => $col-1, -columnspan => 6, -sticky => 'ew');
    }

    $row  = 0;
    $col += 5;
    $f->new_label(
            -text   => "Mean Fit Statistics By Profile",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+1, -columnspan => 4);
    $row++;
    $f->new_label(
            -text   => $props{$id}{parm},
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+1, -columnspan => 4);
    $row++;
    $f->new_label(
            -text   => "(" . $props{$id}{parm_units} . ")",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+1, -columnspan => 4);

    $row++;
    if ($monthly) {
        $f->new_ttk__separator(
                -orient => 'vertical',
                )->g_grid(-row => $row, -rowspan => 17, -column => $col, -sticky => 'ns');
    } else {
        $f->new_ttk__separator(
                -orient => 'vertical',
                )->g_grid(-row => $row, -rowspan => 5, -column => $col, -sticky => 'ns');
    }
    $f->new_label(
            -text   => "n",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+1, -sticky => 's', -ipadx => 3, -pady => 2);
    $f->new_label(
            -text   => "Mean\nError",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+2, -sticky => 's', -ipadx => 3, -pady => 2);
    $f->new_label(
            -text   => "Mean\nAbsolute\nError",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+3, -sticky => 's', -ipadx => 3, -pady => 2);
    $f->new_label(
            -text   => "Root\nMean\nSquared\nError",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+4, -sticky => 's', -ipadx => 3, -pady => 2);

    $row++;
    $f->new_ttk__separator(
            -orient => 'horizontal',
            )->g_grid(-row => $row, -column => $col, -columnspan => 5, -sticky => 'ew');

    $row++;
    $f->new_label(
            -text   => $pstats2{n}{all},
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+1, -ipadx => 2, -pady => 2);
    $f->new_label(
            -text   => ($pstats2{me}{all} eq "na") ? "na" : sprintf("%.4f",$pstats2{me}{all}),
            -anchor => 'e',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+2, -ipadx => 2, -pady => 2);
    $f->new_label(
            -text   => ($pstats2{mae}{all} eq "na") ? "na" : sprintf("%.4f",$pstats2{mae}{all}),
            -anchor => 'e',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+3, -ipadx => 2, -pady => 2);
    $f->new_label(
            -text   => ($pstats2{rmse}{all} eq "na") ? "na" : sprintf("%.4f",$pstats2{rmse}{all}),
            -anchor => 'e',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+4, -ipadx => 2, -pady => 2);

    $row++;
    $f->new_ttk__separator(
            -orient => 'horizontal',
            )->g_grid(-row => $row, -column => $col, -columnspan => 5, -sticky => 'ew');

    if ($monthly) {
        for ($m=0; $m<12; $m++) {
            $mon = $mon_names[$m];
            $row++;
            $f->new_label(
                    -text   => $pstats2{n}{$mon},
                    -anchor => 'center',
                    -font   => 'default',
                    )->g_grid(-row => $row, -column => $col+1, -ipadx => 2, -pady => 2);
            $f->new_label(
                    -text   => ($pstats2{me}{$mon} eq "na") ? "na" : sprintf("%.4f",$pstats2{me}{$mon}),
                    -anchor => 'e',
                    -font   => 'default',
                    )->g_grid(-row => $row, -column => $col+2, -ipadx => 2, -pady => 2);
            $f->new_label(
                    -text   => ($pstats2{mae}{$mon} eq "na") ? "na" : sprintf("%.4f",$pstats2{mae}{$mon}),
                    -anchor => 'e',
                    -font   => 'default',
                    )->g_grid(-row => $row, -column => $col+3, -ipadx => 2, -pady => 2);
            $f->new_label(
                    -text   => ($pstats2{rmse}{$mon} eq "na") ? "na" : sprintf("%.4f",$pstats2{rmse}{$mon}),
                    -anchor => 'e',
                    -font   => 'default',
                    )->g_grid(-row => $row, -column => $col+4, -ipadx => 2, -pady => 2);
        }
        $row++;
        $f->new_ttk__separator(
                -orient => 'horizontal',
                )->g_grid(-row => $row, -column => $col, -columnspan => 5, -sticky => 'ew');
    }

    if ($estats{n}{all} > 0) {
        $row  = 0;
        $col += 5;
        $f->new_label(
                -text   => "Goodness-of-Fit Statistics",
                -anchor => 'center',
                -font   => 'default',
                )->g_grid(-row => $row, -column => $col+1, -columnspan => 4);
        $row++;
        $f->new_label(
                -text   => "Water-Surface Elevation",
                -anchor => 'center',
                -font   => 'default',
                )->g_grid(-row => $row, -column => $col+1, -columnspan => 4);
        $row++;
        $f->new_label(
                -text   => "(" . $gr_props{$id}{yunits} . ")",
                -anchor => 'center',
                -font   => 'default',
                )->g_grid(-row => $row, -column => $col+1, -columnspan => 4);

        $row++;
        if ($monthly) {
            $f->new_ttk__separator(
                    -orient => 'vertical',
                    )->g_grid(-row => $row, -rowspan => 17, -column => $col, -sticky => 'ns');
        } else {
            $f->new_ttk__separator(
                    -orient => 'vertical',
                    )->g_grid(-row => $row, -rowspan => 5, -column => $col, -sticky => 'ns');
        }
        $f->new_label(
                -text   => "n",
                -anchor => 'center',
                -font   => 'default',
                )->g_grid(-row => $row, -column => $col+1, -sticky => 's', -ipadx => 3, -pady => 2);
        $f->new_label(
                -text   => "Mean\nError",
                -anchor => 'center',
                -font   => 'default',
                )->g_grid(-row => $row, -column => $col+2, -sticky => 's', -ipadx => 3, -pady => 2);
        $f->new_label(
                -text   => "Mean\nAbsolute\nError",
                -anchor => 'center',
                -font   => 'default',
                )->g_grid(-row => $row, -column => $col+3, -sticky => 's', -ipadx => 3, -pady => 2);
        $f->new_label(
                -text   => "Root\nMean\nSquared\nError",
                -anchor => 'center',
                -font   => 'default',
                )->g_grid(-row => $row, -column => $col+4, -sticky => 's', -ipadx => 3, -pady => 2);

        $row++;
        $f->new_ttk__separator(
                -orient => 'horizontal',
                )->g_grid(-row => $row, -column => $col, -columnspan => 5, -sticky => 'ew');

        $row++;
        $f->new_label(
                -text   => $estats{n}{all},
                -anchor => 'center',
                -font   => 'default',
                )->g_grid(-row => $row, -column => $col+1, -ipadx => 2, -pady => 2);
        $f->new_label(
                -text   => ($estats{me}{all} eq "na") ? "na" : sprintf("%.4f",$estats{me}{all}),
                -anchor => 'e',
                -font   => 'default',
                )->g_grid(-row => $row, -column => $col+2, -ipadx => 2, -pady => 2);
        $f->new_label(
                -text   => ($estats{mae}{all} eq "na") ? "na" : sprintf("%.4f",$estats{mae}{all}),
                -anchor => 'e',
                -font   => 'default',
                )->g_grid(-row => $row, -column => $col+3, -ipadx => 2, -pady => 2);
        $f->new_label(
                -text   => ($estats{rmse}{all} eq "na") ? "na" : sprintf("%.4f",$estats{rmse}{all}),
                -anchor => 'e',
                -font   => 'default',
                )->g_grid(-row => $row, -column => $col+4, -ipadx => 2, -pady => 2);

        $row++;
        $f->new_ttk__separator(
                -orient => 'horizontal',
                )->g_grid(-row => $row, -column => $col, -columnspan => 5, -sticky => 'ew');

        if ($monthly) {
            for ($m=0; $m<12; $m++) {
                $mon = $mon_names[$m];
                $row++;
                $f->new_label(
                        -text   => $estats{n}{$mon},
                        -anchor => 'center',
                        -font   => 'default',
                        )->g_grid(-row => $row, -column => $col+1, -ipadx => 2, -pady => 2);
                $f->new_label(
                        -text   => ($estats{me}{$mon} eq "na") ? "na" : sprintf("%.4f",$estats{me}{$mon}),
                        -anchor => 'e',
                        -font   => 'default',
                        )->g_grid(-row => $row, -column => $col+2, -ipadx => 2, -pady => 2);
                $f->new_label(
                        -text   => ($estats{mae}{$mon} eq "na") ? "na" : sprintf("%.4f",$estats{mae}{$mon}),
                        -anchor => 'e',
                        -font   => 'default',
                        )->g_grid(-row => $row, -column => $col+3, -ipadx => 2, -pady => 2);
                $f->new_label(
                        -text   => ($estats{rmse}{$mon} eq "na") ? "na" : sprintf("%.4f",$estats{rmse}{$mon}),
                        -anchor => 'e',
                        -font   => 'default',
                        )->g_grid(-row => $row, -column => $col+4, -ipadx => 2, -pady => 2);
            }
            $row++;
            $f->new_ttk__separator(
                    -orient => 'horizontal',
                    )->g_grid(-row => $row, -column => $col, -columnspan => 5, -sticky => 'ew');
        }
    }

#   Footer info
    $row = ($monthly) ? 20 : 7;
    if ($interp) {
        $txt = "Modeled profiles were vertically interpolated to match the measured\n"
             . "vertical profile measurement points for each comparison.\n";
    } else {
        $txt = "Modeled profiles were NOT vertically interpolated.  Measured points\n"
             . "were compared to modeled values for the appropriate model layer.\n";
    }
    if ($dt_begin != -999 && $dt_end != -999) {
        $txt .= "\*All = Dates in the range "
              . &date2datelabel($dt_begin, "Mon-DD-YYYY") . " to "
              . &date2datelabel($dt_end,   "Mon-DD-YYYY");
    } else {
        $txt .= "\*All = All available dates.";
    }
    $f->new_ttk__separator(
            -orient => 'vertical',
            )->g_grid(-row => $row, -column => 1, -sticky => 'ns');
    $f->new_label(
            -text    => $txt,
            -anchor  => 'w',
            -justify => 'left',
            -font    => 'default',
            )->g_grid(-row => $row, -column => 2, -columnspan => 9, -ipadx => 2, -pady => 2);
    $f->new_ttk__separator(
            -orient => 'vertical',
            )->g_grid(-row => $row, -column => 11, -sticky => 'ns');

    Tkx::wm_resizable($ref_window,0,0);
    &adjust_window_position($ref_window);
    $ref_window->g_focus;
}


sub choose_datasets {
    my ($canv, $id, $X, $Y) = @_;
    my (
        $bdate_frame, $bday, $bday_alt, $bday_cb, $bday_sav, $bm, $bm_alt,
        $bmon, $bmon_alt, $bmon_cb, $bmon_sav, $byr, $byr_alt, $byr_cb,
        $byr_sav, $dat_color_label, $dat_choice, $dat_choice_cb, $dat_indx,
        $dat_show_label, $dates_cb, $dates_opt, $dates_opt_sav, $dt_begin,
        $dt_end, $edate_frame, $eday, $eday_alt, $eday_cb, $eday_sav, $em,
        $em_alt, $emon, $emon_alt, $emon_cb, $emon_sav, $eyr, $eyr_alt,
        $eyr_cb, $eyr_sav, $f, $frame, $geom, $link_id, $monthly, $n,
        $nsets, $ref_color_label, $ref_choice, $ref_choice_cb, $ref_indx,
        $ref_show_label, $row, $tol, $tol_frame, $ts_chars, $yr_max, $yr_min,

        @add_ts_text, @add_ts_color, @add_ts_show, @color, @date_ops,
        @names, @ref_text, @show, @ts_color, @ts_show, @ts_text,

        %add_ts_parms, %parms,
       );

    &end_select($canv, $id, 1);

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($choose_sets_menu) && Tkx::winfo_exists($choose_sets_menu)) {
        if ($choose_sets_menu->g_wm_title() eq "Choose Datasets for Fit Statistics") {
            $choose_sets_menu->g_destroy();
            undef $choose_sets_menu;
        }
    }
    $choose_sets_menu = $main->new_toplevel();
    $choose_sets_menu->g_wm_transient($main);
    $choose_sets_menu->g_wm_title("Choose Datasets for Fit Statistics");
    $choose_sets_menu->configure(-cursor => $cursor_norm);
    $choose_sets_menu->g_wm_geometry($geom);

#   Try to keep the nascent graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

#   Set variable for dataset selection
    %add_ts_parms = %{ $props{$id}{add_ts_parms} };
    @add_ts_text  = @{ $add_ts_parms{ts_text}    };
    @add_ts_color = @{ $add_ts_parms{ts_color}   };
    @add_ts_show  = @{ $add_ts_parms{ts_show}    };

    $monthly   = 1;
    $tol       = 10;
    $dat_indx  = $ts_chars = 0;
    @ts_text   = @ts_color = @ts_show = ();
    $dates_opt = $dates_opt_sav = "Include all dates";

    ($dt_begin, $dt_end, undef, undef) = &find_ts_limits($id);
    ($bm, $bday, $byr) = &parse_date($dt_begin, 1);
    ($em, $eday, $eyr) = &parse_date(&jdate2date(&ceil(&date2jdate($dt_end))), 1);
    $bm--;
    $em--;
    $bday    += 0;
    $eday    += 0;
    $bmon     = $mon_names[$bm];
    $emon     = $mon_names[$em];
    $bday_sav = $bday;
    $eday_sav = $eday;
    $bmon_sav = $bmon;
    $emon_sav = $emon;
    $byr_sav  = $byr;
    $eyr_sav  = $eyr;
    $yr_max   = (localtime(time))[5] +1900;
    $yr_min   = $yr_max -25;
    $yr_min   = $byr if ($byr < $yr_min);
    $yr_max   = $eyr if ($eyr > $yr_max);

    if ($global_dt_limits) {
        ($bm_alt, $bday_alt, $byr_alt) = &parse_date($global_dt_begin, 1);
        ($em_alt, $eday_alt, $eyr_alt) = &parse_date($global_dt_end,   1);
        $bday_alt += 0;
        $eday_alt += 0;
        $bmon_alt  = $mon_names[$bm_alt-1];
        $emon_alt  = $mon_names[$em_alt-1];
        $yr_min    = $byr_alt if ($byr_alt < $yr_min);
        $yr_max    = $eyr_alt if ($eyr_alt > $yr_max);
        @date_ops  = ("Include all dates", "Use global date limits", "Custom date range");
    } else {
        @date_ops  = ("Include all dates", "Custom date range");
    }

    $nsets = -1;
    if ($props{$id}{meta} eq "linked_time_series") {
        $link_id = $props{$id}{link_id};
        %parms   = %{ $props{$id}{ts_parms} };
        @show    = @{ $parms{show}  };
        @color   = @{ $parms{color} };
        if ($parms{ts_type} eq "Water Surface Elevation") {
            $nsets++;
            $ts_text[$nsets]  = "WS Elev";
            $ts_color[$nsets] = $color[0];
            $ts_show[$nsets]  = ($show[0]) ? "active" : "hidden";
            $ts_chars         = 7;

        } elsif ($parms{ts_type} =~ /Release Rate|Temperature/) {
            if ($props{$link_id}{meta} eq "vert_wd_zone") {
                @names = @{ $gr_props{$link_id}{names} };
                push (@names, "All Outlets");
            } elsif ($props{$link_id}{meta} eq "w2_outflow") {
                @names = ("All Outlets");
            }
            for ($n=0; $n<=$#names; $n++) {
                $nsets++;
                $ts_text[$nsets]  = ($#names > 0) ? $names[$n] : $parms{ts_type};
                $ts_color[$nsets] = $color[$n];
                $ts_show[$nsets]  = ($show[$n]) ? "active" : "hidden";
                $ts_chars = length($ts_text[$nsets]) if (length($ts_text[$nsets]) > $ts_chars);
            }
        }
    }
    for ($n=0; $n<=$#add_ts_text; $n++) {
        $nsets++;
        $ts_text[$nsets]  = $add_ts_text[$n];
        $ts_color[$nsets] = $add_ts_color[$n];
        $ts_show[$nsets]  = ($add_ts_show[$n]) ? "active" : "hidden";
        $ts_chars = length($add_ts_text[$n]) if (length($add_ts_text[$n]) > $ts_chars);
        $ref_indx = $nsets if (($n == 0 && $props{$id}{meta} eq "linked_time_series") ||
                               ($n == 1 && $props{$id}{meta} eq "time_series"));
    }

#   Exit early if insufficient datasets present
    if ($nsets < 1) {
        $choose_sets_menu->g_destroy();
        undef $choose_sets_menu;
        &reset_bindings;
        return;
    }

#   Set the initial choices
    @ref_text   = @ts_text[1..$nsets];
    $dat_choice = $ts_text[$dat_indx];
    $ref_choice = $ts_text[$ref_indx];

#   Make the menu and its options
    $frame = $choose_sets_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    $frame->new_button(
            -text    => "OK",
            -command => sub { my ($m);
                              if ($dates_opt eq "Include all dates") {
                                  $dt_begin = $dt_end = -999;
                              } elsif ($global_dt_limits && $dates_opt eq "Use global date limits") {
                                  $dt_begin = $global_dt_begin;
                                  $dt_end   = $global_dt_end;
                              } else {
                                  $m        = &list_match($bmon, @mon_names);
                                  $dt_begin = sprintf("%04d%02d%02d0000", $byr, $m+1, $bday);
                                  $m        = &list_match($emon, @mon_names);
                                  $dt_end   = sprintf("%04d%02d%02d0000", $eyr, $m+1, $eday);
                                  if ($dt_begin > $dt_end) {
                                      return &pop_up_error($choose_sets_menu,
                                                  "The start date is after the end date.\n"
                                                . "Please adjust and try again.");
                                  } elsif ($dt_begin == $dt_end) {
                                      return &pop_up_error($choose_sets_menu,
                                                  "The start date is equal to the end date.\n"
                                                . "Please adjust and try again.");
                                  }
                              }

                              $choose_sets_menu->g_bind('<Destroy>', "");
                              $choose_sets_menu->g_destroy();
                              undef $choose_sets_menu;
                              &reset_bindings;

                              &show_ts_stats($id, $dat_indx, $ref_indx, $tol, $monthly, $dt_begin, $dt_end);
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $choose_sets_menu->g_bind('<Destroy>', "");
                              $choose_sets_menu->g_destroy();
                              undef $choose_sets_menu;
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Clean up if this menu is destroyed by other than the Cancel button
    $choose_sets_menu->g_bind('<Destroy>' => sub { undef $choose_sets_menu;
                                                   &reset_bindings;
                                                 });

    ($f = $choose_sets_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "Choose datasets and options for fit statistic computation:",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Test Dataset: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($dat_choice_cb = $f->new_ttk__combobox(
            -textvariable => \$dat_choice,
            -values       => [ @ts_text ],
            -width        => $ts_chars,
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $dat_choice_cb->g_bind("<<ComboboxSelected>>",
                            sub { $dat_indx = &list_match($dat_choice, @ts_text);
                                  $dat_color_label->configure(-background
                                                              => &get_rgb_code($ts_color[$dat_indx]));
                                  $dat_show_label->configure(-text => $ts_show[$dat_indx]);
                                  @ref_text = ();
                                  for ($n=0; $n<=$#ts_text; $n++) {
                                      push (@ref_text, $ts_text[$n]) if ($n != $dat_indx);
                                  }
                                  $ref_choice_cb->configure(-values => [ @ref_text ]);
                                  if ($ref_indx == $dat_indx) {
                                      if ($ref_indx < $nsets) {
                                          $ref_indx++;
                                      } else {
                                          $ref_indx--;
                                      }
                                      $ref_choice = $ts_text[$ref_indx];
                                      $ref_color_label->configure(-background
                                                                  => &get_rgb_code($ts_color[$ref_indx]));
                                      $ref_show_label->configure(-text => $ts_show[$ref_indx]);
                                  }
                                });
    ($dat_color_label = $f->new_label(
            -text        => " ",
            -width       => 5,
            -anchor      => 'w',
            -font        => 'sm',
            -background  => &get_rgb_code($ts_color[$dat_indx]),
            -relief      => 'flat',
            -borderwidth => 0,
            ))->g_grid(-row => $row, -column => 2, -sticky => 'ew', -padx => 3, -pady => 2);
    ($dat_show_label = $f->new_label(
            -text => $ts_show[$dat_indx],
            -font => 'default',
            ))->g_grid(-row => $row, -column => 3, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Reference Dataset: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ref_choice_cb = $f->new_ttk__combobox(
            -textvariable => \$ref_choice,
            -values       => [ @ref_text ],
            -width        => $ts_chars,
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $ref_choice_cb->g_bind("<<ComboboxSelected>>",
                            sub { $ref_indx = &list_match($ref_choice, @ts_text);
                                  $ref_color_label->configure(-background
                                                              => &get_rgb_code($ts_color[$ref_indx]));
                                  $ref_show_label->configure(-text => $ts_show[$ref_indx]);
                                });
    ($ref_color_label = $f->new_label(
            -text        => " ",
            -width       => 5,
            -anchor      => 'w',
            -font        => 'sm',
            -background  => &get_rgb_code($ts_color[$ref_indx]),
            -relief      => 'flat',
            -borderwidth => 0,
            ))->g_grid(-row => $row, -column => 2, -sticky => 'ew', -padx => 3, -pady => 2);
    ($ref_show_label = $f->new_label(
            -text => $ts_show[$ref_indx],
            -font => 'default',
            ))->g_grid(-row => $row, -column => 3, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Match Tolerance: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($tol_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w');
    $tol_frame->new_spinbox(
            -textvariable => \$tol,
            -state        => 'readonly',
            -font         => 'default',
            -from         => 0,
            -to           => 60,
            -increment    => 1,
            -width        => 3,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $tol_frame->new_label(
            -text => " minutes",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');

    $row++;
    $f->new_label(
            -text => "Options: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $f->new_checkbutton(
            -onvalue  => 1,
            -offvalue => 0,
            -text     => "Include stats by month",
            -font     => 'default',
            -variable => \$monthly,
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w');

    $row++;
    $f->new_label(
            -text => "Date Range: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($dates_cb = $f->new_ttk__combobox(
            -textvariable => \$dates_opt,
            -values       => [ @date_ops ],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w');
    $dates_cb->g_bind("<<ComboboxSelected>>",
                       sub { return if ($dates_opt eq $dates_opt_sav);
                             if ($dates_opt eq "Custom date range") {
                                 $bmon_cb->configure(-state => 'readonly');
                                 $bday_cb->configure(-state => 'readonly');
                                 $byr_cb->configure(-state  => 'readonly');
                                 $emon_cb->configure(-state => 'readonly');
                                 $eday_cb->configure(-state => 'readonly');
                                 $eyr_cb->configure(-state  => 'readonly');
                             } else {
                                 $bmon_cb->configure(-state => 'disabled');
                                 $bday_cb->configure(-state => 'disabled');
                                 $byr_cb->configure(-state  => 'disabled');
                                 $emon_cb->configure(-state => 'disabled');
                                 $eday_cb->configure(-state => 'disabled');
                                 $eyr_cb->configure(-state  => 'disabled');
                                 if ($dates_opt eq "Use global date limits") {
                                     $bmon = $bmon_alt;
                                     $bday = $bday_alt;
                                     $byr  = $byr_alt;
                                     $emon = $emon_alt;
                                     $eday = $eday_alt;
                                     $eyr  = $eyr_alt;
                                 } else {
                                     $bmon = $bmon_sav;
                                     $bday = $bday_sav;
                                     $byr  = $byr_sav;
                                     $emon = $emon_sav;
                                     $eday = $eday_sav;
                                     $eyr  = $eyr_sav;
                                 }
                             }
                             $dates_opt_sav = $dates_opt;
                           }
                     );

    $row++;
    $f->new_label(
            -text => "Start Date: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($bdate_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w');
    ($bmon_cb = $bdate_frame->new_ttk__combobox(
            -textvariable => \$bmon,
            -values       => [ @mon_names ],
            -state        => 'readonly',
            -width        => 4,
            ))->g_pack(-side => 'left');
    $bmon_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($byr);
                          $bm = &list_match($bmon, @mon_names);
                          $bday_cb->configure(-values => [ 1 .. $days_in_month[$bm] ]);
                          $bday = $days_in_month[$bm] if ($bday > $days_in_month[$bm]);
                        }
                    );
    $bdate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($bday_cb = $bdate_frame->new_ttk__combobox(
            -textvariable => \$bday,
            -values       => [ 1 .. $days_in_month[$bm] ],
            -state        => 'readonly',
            -width        => 3,
            ))->g_pack(-side => 'left');
    $bdate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($byr_cb = $bdate_frame->new_ttk__combobox(
            -textvariable => \$byr,
            -values       => [ reverse($yr_min .. $yr_max) ],
            -state        => 'readonly',
            -width        => 5,
            ))->g_pack(-side => 'left');
    $byr_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($byr);
                          $bm = &list_match($bmon, @mon_names);
                          if ($bm == 1) {
                              $bday_cb->configure(-values => [ 1 .. $days_in_month[$bm] ]);
                              $bday = $days_in_month[$bm] if ($bday > $days_in_month[$bm]);
                          }
                          if ($byr == $yr_min || $byr == $yr_max) {
                              $yr_min -= 10 if ($byr == $yr_min);
                              $yr_max += 10 if ($byr == $yr_max);
                              $byr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                              $eyr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                          }
                        }
                    );

    $row++;
    $f->new_label(
            -text => "End Date: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($edate_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w');
    ($emon_cb = $edate_frame->new_ttk__combobox(
            -textvariable => \$emon,
            -values       => [ @mon_names ],
            -state        => 'readonly',
            -width        => 4,
            ))->g_pack(-side => 'left');
    $emon_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($eyr);
                          $em = &list_match($emon, @mon_names);
                          $eday_cb->configure(-values => [ 1 .. $days_in_month[$em] ]);
                          $eday = $days_in_month[$em] if ($eday > $days_in_month[$em]);
                        }
                    );
    $edate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($eday_cb = $edate_frame->new_ttk__combobox(
            -textvariable => \$eday,
            -values       => [ 1 .. $days_in_month[$em] ],
            -state        => 'readonly',
            -width        => 3,
            ))->g_pack(-side => 'left');
    $edate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($eyr_cb = $edate_frame->new_ttk__combobox(
            -textvariable => \$eyr,
            -values       => [ reverse($yr_min .. $yr_max) ],
            -state        => 'readonly',
            -width        => 5,
            ))->g_pack(-side => 'left');
    $eyr_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($eyr);
                          $em = &list_match($emon, @mon_names);
                          if ($em == 1) {
                              $eday_cb->configure(-values => [ 1 .. $days_in_month[$em] ]);
                              $eday = $days_in_month[$em] if ($eday > $days_in_month[$em]);
                          }
                          if ($eyr == $yr_min || $eyr == $yr_max) {
                              $yr_min -= 10 if ($eyr == $yr_min);
                              $yr_max += 10 if ($eyr == $yr_max);
                              $byr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                              $eyr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                          }
                        }
                    );

    $f->g_grid_columnconfigure(3, -weight => 2);

    $bmon_cb->configure(-state => 'disabled');
    $bday_cb->configure(-state => 'disabled');
    $byr_cb->configure(-state  => 'disabled');
    $emon_cb->configure(-state => 'disabled');
    $eday_cb->configure(-state => 'disabled');
    $eyr_cb->configure(-state  => 'disabled');

    Tkx::wm_resizable($choose_sets_menu,0,0);
    &adjust_window_position($choose_sets_menu);
    $choose_sets_menu->g_focus;
}


sub show_ts_stats {
    my ($id, $dat_indx, $ref_indx, $tol, $monthly, $dt_begin, $dt_end) = @_;
    my (
        $dat_text, $dt, $f, $frame, $geom, $link_id, $m, $mon, $mult, $n,
        $nsets, $ref_text, $row, $txt, $wt, $X, $x1, $x2, $Y, $y1, $y2,

        @add_ts_text, @add_ts_tsdata, @flows, @names, @qstr, @tstr,

        %add_ts_parms, %data, %parms, %qdata, %ref_data, %stats, %tdata,
        %tmp,
       );

    $monthly  = 1    if (! defined($monthly)  || $monthly ne "0");
    $dt_begin = -999 if (! defined($dt_begin) || $dt_begin !~ /^[12][0-9][0-9][0-9][01][0-9][0-3][0-9]/);
    $dt_end   = -999 if (! defined($dt_end)   || $dt_end   !~ /^[12][0-9][0-9][0-9][01][0-9][0-3][0-9]/);

#   Find and set the datasets in date/time-indexed hashes
    $nsets = -1;
    if ($props{$id}{meta} eq "linked_time_series") {
        $link_id = $props{$id}{link_id};
        %parms   = %{ $props{$id}{ts_parms} };
        if ($parms{ts_type} eq "Water Surface Elevation") {
            $nsets++;
            if ($nsets == $dat_indx || $nsets == $ref_indx) {
                if ($props{$link_id}{meta} =~ /^(data_profile|vert_wd_zone)$/) {
                    %tmp = %{ $gr_props{$link_id}{ws_elev} };
                } elsif ($props{$link_id}{meta} eq "w2_profile") {
                    %tmp = %{ $gr_props{$link_id}{elev_data} };
                } elsif ($props{$link_id}{meta} eq "w2_outflow") {
                    %qdata = %{ $gr_props{$link_id}{qdata} };
                    %tmp = ();
                    foreach $dt (keys %qdata) {
                        @flows = @{ $qdata{$dt} };
                        $tmp{$dt} = $flows[1];
                    }
                    undef %qdata;
                    undef @flows;
                }
                if ($parms{units} eq "ft") {
                    foreach $dt (keys %tmp) {
                        $tmp{$dt} *= 3.28084 if (defined($tmp{$dt}) && $tmp{$dt} ne "na");
                    }
                }
                if ($nsets == $dat_indx) {
                    %data     = %tmp;
                    $dat_text = "WS Elev (" . $parms{units} . ")";
                } else {
                    %ref_data = %tmp;
                    $ref_text = "WS Elev (" . $parms{units} . ")";
                }
            }

        } elsif ($parms{ts_type} eq "Release Rate") {
            %qdata = %{ $gr_props{$link_id}{qdata} };
            if ($props{$link_id}{meta} eq "vert_wd_zone") {
                @names = @{ $gr_props{$link_id}{names} };
                push (@names, "All Outlets");
            } elsif ($props{$link_id}{meta} eq "w2_outflow") {
                @names = ("All Outlets");
            }
            for ($n=0; $n<=$#names; $n++) {
                $nsets++;
                if ($nsets == $dat_indx || $nsets == $ref_indx) {
                    $mult = ($parms{units} eq "cfs") ? 35.31467 : 1.0;
                    %tmp  = ();
                    foreach $dt (keys %qdata) {
                        next if (! defined($qdata{$dt}));
                        @qstr = @{ $qdata{$dt} };
                        if ($props{$link_id}{meta} eq "w2_outflow") {
                            $tmp{$dt} = $qstr[0] *$mult;
                        } else {
                            if ($names[$n] eq "All Outlets") {
                                $tmp{$dt} = &sum(@qstr) *$mult;
                            } else {
                                $tmp{$dt} = $qstr[$n] *$mult;
                            }
                        }
                    }
                    if ($nsets == $dat_indx) {
                        %data     = %tmp;
                        $dat_text = "Flow (" . $parms{units} . ") - " . $names[$n];
                    } else {
                        %ref_data = %tmp;
                        $ref_text = "Flow (" . $parms{units} . ") - " . $names[$n];
                    }
                }
            }
            undef %qdata;

        } elsif ($parms{ts_type} eq "Temperature") {
            %tdata = %{ $gr_props{$link_id}{tdata} };
            @names = @{ $gr_props{$link_id}{names} };
            push (@names, "All Outlets");
            for ($n=0; $n<=$#names; $n++) {
                $nsets++;
                if ($nsets == $dat_indx || $nsets == $ref_indx) {
                    %tmp = ();
                    foreach $dt (keys %tdata) {
                        next if (! defined($tdata{$dt}));
                        @tstr = @{ $tdata{$dt} };
                        $wt   = $tstr[$n];
                        if ($wt > -99) {
                            $wt = 1.8 *$wt +32 if ($parms{units} eq "Fahrenheit");
                            $tmp{$dt} = $wt;
                        }
                    }
                    if ($nsets == $dat_indx) {
                        %data     = %tmp;
                        $dat_text = "Temperature (" . substr($parms{units},0,1) . ") - " . $names[$n];
                    } else {
                        %ref_data = %tmp;
                        $ref_text = "Temperature (" . substr($parms{units},0,1) . ") - " . $names[$n];
                    }
                }
            }
            undef %tdata;
        }
    }

    %add_ts_parms  = %{ $props{$id}{add_ts_parms} };
    @add_ts_text   = @{ $add_ts_parms{ts_text}    };
    @add_ts_tsdata = @{ $add_ts_parms{ts_data}    };
    for ($n=0; $n<=$#add_ts_tsdata; $n++) {
        $nsets++;
        if ($nsets == $dat_indx) {
            %data     = %{ $add_ts_tsdata[$n] };
            $dat_text = $add_ts_text[$n];
        } elsif ($nsets == $ref_indx) {
            %ref_data = %{ $add_ts_tsdata[$n] };
            $ref_text = $add_ts_text[$n];
        }
    }

#   Calculate the goodness-of-fit statistics
    %stats = &get_ts_stats(\%data, \%ref_data, $monthly, $tol, $dt_begin, $dt_end);
    undef %data;
    undef %ref_data;

#   Report the stats to the user
    ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $geom = sprintf("+%d+%d", $X+$x1+50, $Y+$y1+60);

    if (defined($ts_stats_window) && Tkx::winfo_exists($ts_stats_window)) {
        if ($ts_stats_window->g_wm_title() eq "TS Goodness-of-Fit Statistics") {
            $ts_stats_window->g_destroy();
            undef $ts_stats_window;
        }
    }
    $ts_stats_window = $main->new_toplevel();
    $ts_stats_window->g_wm_transient($main);
    $ts_stats_window->g_wm_title("TS Goodness-of-Fit Statistics");
    $ts_stats_window->configure(-cursor => $cursor_norm);
    $ts_stats_window->g_wm_geometry($geom);

    $frame = $ts_stats_window->new_frame();
    $frame->g_pack(-side => 'bottom');
    $frame->new_button(
            -text    => "OK",
            -command => sub { $ts_stats_window->g_destroy();
                              undef $ts_stats_window;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Save",
            -command => sub { my ($dir, $file, $fname, $m, $mon, $project_path, $vol);
                              $file = Tkx::tk___getSaveFile(
                                  -parent           => $ts_stats_window,
                                  -title            => "Save Time-Series Statistics",
                                  -initialdir       => abs_path(),
                                  -defaultextension => ".txt",
                                  -filetypes => [ ['Text Files', '.txt'],
                                                  ['All Files',  '*'],
                                                ],
                                  );
                              if (defined($file)) {
                                  open (OUT, ">", $file)
                                      || return &pop_up_error($ts_stats_window, "Unable to open\n$file");
                                  print OUT "# W2 Animator, version $version\n";
                                  print OUT "# File created: ", &get_datetime, "\n";
                                  if ($savefile ne "") {
                                      ($vol, $dir, $fname) = File::Spec->splitpath($savefile);
                                      $project_path = $vol . $dir;
                                      $file = File::Spec->rel2abs($savefile, $project_path);
                                      print OUT "# W2Anim project: $file\n";
                                  }
                                  print OUT "# Time-Series Goodness-of-Fit Statistics\n";
                                  if ($dt_begin != -999 && $dt_end != -999) {
                                      print OUT "# All\* = Dates in the range "
                                            . &date2datelabel($dt_begin, "Mon-DD-YYYY") . " to "
                                            . &date2datelabel($dt_end,   "Mon-DD-YYYY") . "\n";
                                  } else {
                                      print OUT "# All\* = All available dates\n";
                                  }
                                  print OUT "#\n";
                                  print OUT "Goodness-of-Fit Statistics\n";
                                  print OUT "Test dataset:  $dat_text\n";
                                  print OUT "Reference dataset:  $ref_text\n";
                                  print OUT "\tn\tME\tMAE\tRMSE\n";
                                  print OUT "All\t", $stats{n}{all};
                                  if ($stats{me}{all} eq "na") {
                                      print OUT "\tna\tna\tna\n";
                                  } else {
                                      print OUT "\t", sprintf("%.4f",$stats{me}{all});
                                      print OUT "\t", sprintf("%.4f",$stats{mae}{all});
                                      print OUT "\t", sprintf("%.4f",$stats{rmse}{all}), "\n";
                                  }
                                  if ($monthly) {
                                      for ($m=0; $m<12; $m++) {
                                          $mon = $mon_names[$m];
                                          print OUT "$mon\t", $stats{n}{$mon};
                                          if ($stats{me}{$mon} eq "na") {
                                              print OUT "\tna\tna\tna\n";
                                          } else {
                                              print OUT "\t", sprintf("%.4f",$stats{me}{$mon});
                                              print OUT "\t", sprintf("%.4f",$stats{mae}{$mon});
                                              print OUT "\t", sprintf("%.4f",$stats{rmse}{$mon}), "\n";
                                          }
                                      }
                                  }
                                  close (OUT)
                                      || return &pop_up_error($ts_stats_window, "Trouble closing\n$file");
                              }
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

    ($f = $ts_stats_window->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text   => "Goodness-of-Fit Statistics",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => 0, -columnspan => 5);
    $row++;
    $f->new_label(
            -text   => "Test: " . $dat_text,
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => 0, -columnspan => 5);
    $row++;
    $f->new_label(
            -text   => "Reference: " . $ref_text,
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => 0, -columnspan => 5);

    $row++;
    $f->new_label(
            -text   => "n",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => 1, -sticky => 's', -ipadx => 3, -pady => 2);
    $f->new_label(
            -text   => "Mean\nError",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => 2, -sticky => 's', -ipadx => 3, -pady => 2);
    $f->new_label(
            -text   => "Mean\nAbsolute\nError",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => 3, -sticky => 's', -ipadx => 3, -pady => 2);
    $f->new_label(
            -text   => "Root\nMean\nSquared\nError",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => 4, -sticky => 's', -ipadx => 3, -pady => 2);

    $row++;
    $f->new_ttk__separator(
            -orient => 'horizontal',
            )->g_grid(-row => $row, -column => 0, -columnspan => 5, -sticky => 'ew');

    $row++;
    $f->new_label(
            -text   => "All\*",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => 0, -ipadx => 2, -pady => 2);
    $f->new_label(
            -text   => $stats{n}{all},
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => 1, -ipadx => 2, -pady => 2);
    $f->new_label(
            -text   => ($stats{me}{all} eq "na") ? "na" : sprintf("%.4f",$stats{me}{all}),
            -anchor => 'e',
            -font   => 'default',
            )->g_grid(-row => $row, -column => 2, -ipadx => 2, -pady => 2);
    $f->new_label(
            -text   => ($stats{mae}{all} eq "na") ? "na" : sprintf("%.4f",$stats{mae}{all}),
            -anchor => 'e',
            -font   => 'default',
            )->g_grid(-row => $row, -column => 3, -ipadx => 2, -pady => 2);
    $f->new_label(
            -text   => ($stats{rmse}{all} eq "na") ? "na" : sprintf("%.4f",$stats{rmse}{all}),
            -anchor => 'e',
            -font   => 'default',
            )->g_grid(-row => $row, -column => 4, -ipadx => 2, -pady => 2);
    $row++;
    $f->new_ttk__separator(
            -orient => 'horizontal',
            )->g_grid(-row => $row, -column => 0, -columnspan => 5, -sticky => 'ew');

    if ($monthly) {
        for ($m=0; $m<12; $m++) {
            $mon = $mon_names[$m];
            $row++;
            $f->new_label(
                    -text   => $mon,
                    -anchor => 'center',
                    -font   => 'default',
                    )->g_grid(-row => $row, -column => 0, -ipadx => 2, -pady => 2);
            $f->new_label(
                    -text   => $stats{n}{$mon},
                    -anchor => 'center',
                    -font   => 'default',
                    )->g_grid(-row => $row, -column => 1, -ipadx => 2, -pady => 2);
            $f->new_label(
                    -text   => ($stats{me}{$mon} eq "na") ? "na" : sprintf("%.4f",$stats{me}{$mon}),
                    -anchor => 'e',
                    -font   => 'default',
                    )->g_grid(-row => $row, -column => 2, -ipadx => 2, -pady => 2);
            $f->new_label(
                    -text   => ($stats{mae}{$mon} eq "na") ? "na" : sprintf("%.4f",$stats{mae}{$mon}),
                    -anchor => 'e',
                    -font   => 'default',
                    )->g_grid(-row => $row, -column => 3, -ipadx => 2, -pady => 2);
            $f->new_label(
                    -text   => ($stats{rmse}{$mon} eq "na") ? "na" : sprintf("%.4f",$stats{rmse}{$mon}),
                    -anchor => 'e',
                    -font   => 'default',
                    )->g_grid(-row => $row, -column => 4, -ipadx => 2, -pady => 2);
        }
        $row++;
        $f->new_ttk__separator(
                -orient => 'horizontal',
                )->g_grid(-row => $row, -column => 0, -columnspan => 5, -sticky => 'ew');
    }

#   Footer info
    $row++;
    if ($dt_begin != -999 && $dt_end != -999) {
        $txt = "Dates in the range\n" . &date2datelabel($dt_begin, "Mon-DD-YYYY") . " to "
                                      . &date2datelabel($dt_end,   "Mon-DD-YYYY");
        $f->new_label(
                -text => "\*All =",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'nw', -ipadx => 2, -pady => 2);
        $f->new_label(
                -text    => $txt,
                -justify => 'left',
                -font    => 'default',
                )->g_grid(-row => $row, -column => 1, -columnspan => 4,
                          -sticky => 'w', -ipadx => 2, -pady => 2);
    } else {
        $f->new_label(
                -text => "\*All = All available dates",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -columnspan => 5,
                          -sticky => 'w', -ipadx => 2, -pady => 2);
    }

    Tkx::wm_resizable($ts_stats_window,0,0);
    &adjust_window_position($ts_stats_window);
    $ts_stats_window->g_focus;
}


################################################################################
#
# Standard graph parts
#
################################################################################

sub make_axis {
    my ($canv, %axis_props) = @_;
    my (
        $add_minor, $anc, $ang, $axmax, $axmin, $clipmax, $clipmin, $d, $d1,
        $d2, $d3, $fac, $family, $first, $fmt, $gr1, $gr2, $grcolor, $grid,
        $gridtags, $grwidth, $i, $id, $label, $label_size, $label_weight,
        $labels, $major, $min_major, $minor, $nt, $op_loc, $op_tags,
        $op_tics, $orient, $power, $pr_tics, $range, $reverse, $side,
        $tag, $tags, $title, $title_size, $title_weight, $tmp, $tsize,
        $x1, $x2, $xp1, $xp1o, $xp2, $xp2o, $xp3, $xp4, $xp4o, $xp5, $xp5o,
        $y1, $y2, $yp1, $yp1o, $yp2, $yp2o, $yp3, $yp4, $yp4o, $yp5, $yp5o,

        @coords, @taglist,
       );

    $family       = $axis_props{font};
    $label_size   = $axis_props{size1};
    $title_size   = $axis_props{size2};
    $label_weight = $axis_props{weight1};
    $title_weight = $axis_props{weight2};

    $labels  = 1;
    $clipmin = $clipmax = 0;

    $axmin   = $axis_props{min};
    $axmax   = $axis_props{max};
    $clipmin = $axis_props{clipmin} if (defined($axis_props{clipmin}));
    $clipmax = $axis_props{clipmax} if (defined($axis_props{clipmax}));
    $first   = $axis_props{first}   if (defined($axis_props{first}));
    $major   = $axis_props{major};
    $minor   = $axis_props{minor};     # 0 = no, 1 = yes
    $reverse = $axis_props{reverse};   # 0 = no, 1 = yes
    $title   = $axis_props{title};
    $side    = $axis_props{side};      # left, right, top, bottom
    $pr_tics = $axis_props{pr_tics};   # primary side:   inside, outside, cross, none
    $op_tics = $axis_props{op_tics};   # opposite side:  inside, outside, cross, none
    $op_loc  = $axis_props{op_loc};    # opposite side coordinate
    $tags    = $axis_props{tags};
    $labels  = $axis_props{labels} if (defined($axis_props{labels}));

    if (defined($axis_props{grid})) {
        $grid        = $axis_props{grid};
        $grwidth     = $axis_props{grwidth};
        $grcolor     = $axis_props{grcolor};
        ($gr1, $gr2) = @{ $axis_props{grcoord} };
        ($gridtags = $tags) =~ s/_.axis$/_grid/;
    } else {
        $grid = 0;
    }
    if ($op_tics ne "none") {
        $op_tags = $tags;
        @taglist = split(/ /, $op_tags);
        foreach $tag (@taglist) {
            if ($tag =~ /_.axis$/) {
                $op_tags .= " " . $tag . "2";
                last;
            }
        }
    }
    $title =~ s/^"//;
    $title =~ s/"$//;
    $tsize =  0;

    ($x1, $y1, $x2, $y2) = @{ $axis_props{coords} };

    if ($axmin > $axmax) {
        $axmin = $axis_props{max};
        $axmax = $axis_props{min};
    } elsif ($axmin == $axmax) {
        &pop_up_error($main, "Axis minimum and maximum values are identical");
        return;
    }
    if ($reverse) {
        $first = $axmax if (! defined($first) || $first eq "");
    } else {
        $first = $axmin if (! defined($first) || $first eq "");
    }
    if ($major ne "auto") {
        $major *= -1     if ($major+0  < 0);
        $major  = "auto" if ($major+0 == 0);
    }
    $minor *= -1 if ($minor < 0);
    if ($y1 == $y2) {
        $orient = "horizontal";
        $side   = "bottom" if (! defined($side) || $side ne "top");
    } elsif ($x1 == $x2) {
        $orient = "vertical";
        $side   = "left" if (! defined($side) || $side ne "right");
    } else {
        &pop_up_error($main, "Invalid coordinates for axis");
        return;
    }
    if ($op_tics ne "none") {
        if ($orient eq "horizontal") {
            $op_tics = "none" if ($op_loc == $y1 || ($side eq "bottom" && $op_loc > $y1)
                                                 || ($side eq "top"    && $op_loc < $y1));
        } else {
            $op_tics = "none" if ($op_loc == $x1 || ($side eq "left"  && $op_loc < $x1)
                                                 || ($side eq "right" && $op_loc > $x1));
        }
    }

#   Determine an optimal major tick spacing, if needed
    if ($major eq "auto") {
        $range  = $axmax-$axmin;
        $power  = (&log10($range) < 1) ? abs(&floor(&log10($range))) +1 : 0;
        $range *= 10**$power;
        if ($orient eq "horizontal") {
            $min_major = int($range *($label_size *3) /abs($x2-$x1) +0.0000001);
        } else {
            $min_major = int($range *($label_size *3) /abs($y2-$y1) +0.0000001);
        }
        $min_major = 1 if ($min_major == 0);
        for ($i=$min_major; $i<=$range/5; $i++) {
            $major = $i /(10**$power) if (&round_to_int($range) % $i == 0);
        }
        $major = $min_major /(10**$power) if ($major eq "auto");
    }

#   Determine an optimal number of digits after decimal
    $d   = 0;
    $fac = 1;
    $tmp = $major;
    until (abs($tmp*$fac - int($tmp*$fac)) < 0.00001 || $d == 3) {
        $d++;
        $fac = (10**$d);
    }
    $tmp = abs($first);
    until (abs($tmp*$fac - int($tmp*$fac)) < 0.00001 || $d == 3) {
        $d++;
        $fac = (10**$d);
    }
    $fmt = ($d == 0) ? "%d" : "%.${d}f";

#   Make major tick marks and labels
#   Default is increasing value left to right or bottom to top
    $ang = 0;
    if ($orient eq "horizontal") {
        $anc = ($side eq "bottom") ? 'n' : 's';
        $d1  = ($pr_tics eq "cross")       ? 4 : 0;
        $d2  = ($pr_tics eq "inside")      ? 8 : 0;
        $d3  = ($pr_tics =~ /inside|none/) ? 6 : 0;
        $yp1 = ($side eq "bottom") ? $y1-2*$d1   : $y1+2*$d1;   # major ticks
        $yp2 = ($side eq "bottom") ? $y1+8-2*$d2 : $y1-8+2*$d2; # major ticks
        $yp3 = ($side eq "bottom") ? $y1+9-$d3   : $y1-9+$d3;   # tick labels
        $yp4 = ($side eq "bottom") ? $y1-$d1     : $y1+$d1;     # minor ticks
        $yp5 = ($side eq "bottom") ? $y1+4-$d2   : $y1-4+$d2;   # minor ticks
        if ($op_tics ne "none") {
            $d1   = ($op_tics eq "cross")  ? 4 : 0;
            $d2   = ($op_tics eq "inside") ? 8 : 0;
            $yp1o = ($side eq "bottom") ? $op_loc+2*$d1   : $op_loc-2*$d1;   # major ticks
            $yp2o = ($side eq "bottom") ? $op_loc-8+2*$d2 : $op_loc+8-2*$d2; # major ticks
            $yp4o = ($side eq "bottom") ? $op_loc+$d1     : $op_loc-$d1;     # minor ticks
            $yp5o = ($side eq "bottom") ? $op_loc-4+$d2   : $op_loc+4-$d2;   # minor ticks
        }
    } else {
        $anc = ($side eq "left") ? 'e' : 'w';
        $d1  = ($pr_tics eq "cross")       ? 4 : 0;
        $d2  = ($pr_tics eq "inside")      ? 8 : 0;
        $d3  = ($pr_tics =~ /inside|none/) ? 6 : 0;
        $xp1 = ($side eq "left") ? $x1+2*$d1   : $x1-2*$d1;   # major ticks
        $xp2 = ($side eq "left") ? $x1-8+2*$d2 : $x1+8-2*$d2; # major ticks
        $xp3 = ($side eq "left") ? $x1-10+$d3  : $x1+10-$d3;  # tick labels
        $xp4 = ($side eq "left") ? $x1+$d1     : $x1-$d1;     # minor ticks
        $xp5 = ($side eq "left") ? $x1-4+$d2   : $x1+4-$d2;   # minor ticks
        if ($op_tics ne "none") {
            $d1   = ($op_tics eq "cross")  ? 4 : 0;
            $d2   = ($op_tics eq "inside") ? 8 : 0;
            $xp1o = ($side eq "left") ? $op_loc-2*$d1   : $op_loc+2*$d1;   # major ticks
            $xp2o = ($side eq "left") ? $op_loc+8-2*$d2 : $op_loc-8+2*$d2; # major ticks
            $xp4o = ($side eq "left") ? $op_loc-$d1     : $op_loc+$d1;     # minor ticks
            $xp5o = ($side eq "left") ? $op_loc+4-$d2   : $op_loc-4+$d2;   # minor ticks
        }
    }
    if ($reverse) {
        for ($i=$first; $i>=$axmin*0.999999; $i-=$major) {
            $label = sprintf($fmt, $i);
            if ($orient eq "horizontal") {
                $xp1 = $x1 +($x2-$x1)*($axmax-$i)/($axmax-$axmin);
                $xp2 = $xp3 = $xp1o = $xp2o = $xp1;
            } else {
                $yp1 = $y1 +($y2-$y1)*($axmax-$i)/($axmax-$axmin);
                $yp2 = $yp3 = $yp1o = $yp2o = $yp1;
            }
            if ($grid && $i > $axmin && $i < $axmax) {
                if ($orient eq "horizontal") {
                    @coords = ($xp1, $gr1, $xp1, $gr2);
                } else {
                    @coords = ($gr1, $yp1, $gr2, $yp1);
                }
                $canv->create_line(@coords, -fill  => &get_rgb_code($grcolor),
                                            -width => $grwidth,
                                            -arrow => 'none',
                                            -tags  => $gridtags);
            }
            if ($pr_tics ne "none") {
                $canv->create_line($xp1, $yp1, $xp2, $yp2,
                                   -fill  => &get_rgb_code("black"),
                                   -width => 1,
                                   -arrow => 'none',
                                   -tags  => $tags);
            }
            if ($op_tics ne "none") {
                $canv->create_line($xp1o, $yp1o, $xp2o, $yp2o,
                                   -fill  => &get_rgb_code("black"),
                                   -width => 1,
                                   -arrow => 'none',
                                   -tags  => $op_tags);
            }
            if ($labels && (! $clipmin || $i >= $first -0.98*($first-$axmin)) &&
                           (! $clipmax || $i <= $first -0.02*($first-$axmin))) {
                $id = $canv->create_text($xp3, $yp3,
                                   -anchor => $anc,
                                   -text   => $label,
                                   -fill   => &get_rgb_code("black"),
                                   -angle  => $ang,
                                   -tags   => $tags,
                                   -font   => [-family     => $family,
                                               -size       => $label_size,
                                               -weight     => $label_weight,
                                               -slant      => 'roman',
                                               -underline  => 0,
                                               -overstrike => 0,
                                              ]);
                if ($i >= $first -$major || $i - 2* $major < $axmin) {
                    @coords = Tkx::SplitList($canv->bbox($id));
                    if ($orient eq "horizontal") {
                        $tsize = &max($tsize, abs($coords[3] - $coords[1]));
                    } else {
                        $tsize = &max($tsize, abs($coords[2] - $coords[0]));
                    }
                }
            }
        }
    } else {
        for ($i=$first; $i<=$axmax*1.000001; $i+=$major) {
            $label = sprintf($fmt, $i);
            if ($orient eq "horizontal") {
                $xp1 = $x1 +($x2-$x1)*($i-$axmin)/($axmax-$axmin);
                $xp2 = $xp3 = $xp1o = $xp2o = $xp1;
            } else {
                $yp1 = $y1 +($y2-$y1)*($i-$axmin)/($axmax-$axmin);
                $yp2 = $yp3 = $yp1o = $yp2o = $yp1;
            }
            if ($grid && $i > $axmin && $i < $axmax) {
                if ($orient eq "horizontal") {
                    @coords = ($xp1, $gr1, $xp1, $gr2);
                } else {
                    @coords = ($gr1, $yp1, $gr2, $yp1);
                }
                $canv->create_line(@coords, -fill  => &get_rgb_code($grcolor),
                                            -width => $grwidth,
                                            -arrow => 'none',
                                            -tags  => $gridtags);
            }
            if ($pr_tics ne "none") {
                $canv->create_line($xp1, $yp1, $xp2, $yp2,
                                   -fill  => &get_rgb_code("black"),
                                   -width => 1,
                                   -arrow => 'none',
                                   -tags  => $tags);
            }
            if ($op_tics ne "none") {
                $canv->create_line($xp1o, $yp1o, $xp2o, $yp2o,
                                   -fill  => &get_rgb_code("black"),
                                   -width => 1,
                                   -arrow => 'none',
                                   -tags  => $op_tags);
            }
            if ($labels && (! $clipmax || $i <= $first +0.98*($axmax-$first)) &&
                           (! $clipmin || $i >= $first +0.02*($axmax-$first))) {
                $id = $canv->create_text($xp3, $yp3,
                                   -anchor => $anc,
                                   -text   => $label,
                                   -fill   => &get_rgb_code("black"),
                                   -angle  => $ang,
                                   -tags   => $tags,
                                   -font   => [-family     => $family,
                                               -size       => $label_size,
                                               -weight     => $label_weight,
                                               -slant      => 'roman',
                                               -underline  => 0,
                                               -overstrike => 0,
                                              ]);
                if ($i <= $first +$major || $i + 2* $major > $axmax) {
                    @coords = Tkx::SplitList($canv->bbox($id));
                    if ($orient eq "horizontal") {
                        $tsize = &max($tsize, abs($coords[3] - $coords[1]));
                    } else {
                        $tsize = &max($tsize, abs($coords[2] - $coords[0]));
                    }
                }
            }
        }
    }
    if ($minor != 0 && ($pr_tics ne "none" || $op_tics ne "none")) {
        $nt = int(($axmax - $axmin)/$major +0.00001) +1;
        if ($orient eq "horizontal") {
            $add_minor = (abs($x2-$x1)/$nt > 30) ? 1 : 0;
        } else {
            $add_minor = (abs($y2-$y1)/$nt > 30) ? 1 : 0;
        }
        if ($add_minor) {
            if ($reverse) {
                for ($i=$first-$major/2.; $i>=$axmin; $i-=$major) {
                    if ($orient eq "horizontal") {
                        $xp4 = $x1 +($x2-$x1)*($axmax-$i)/($axmax-$axmin);
                        $xp5 = $xp4o = $xp5o = $xp4;
                    } else {
                        $yp4 = $y1 +($y2-$y1)*($axmax-$i)/($axmax-$axmin);
                        $yp5 = $yp4o = $yp5o = $yp4;
                    }
                    if ($pr_tics ne "none") {
                        $canv->create_line($xp4, $yp4, $xp5, $yp5,
                                           -fill  => &get_rgb_code("black"),
                                           -width => 1,
                                           -arrow => 'none',
                                           -tags  => $tags);
                    }
                    if ($op_tics ne "none") {
                        $canv->create_line($xp4o, $yp4o, $xp5o, $yp5o,
                                           -fill  => &get_rgb_code("black"),
                                           -width => 1,
                                           -arrow => 'none',
                                           -tags  => $op_tags);
                    }
                }
            } else {
                for ($i=$first+$major/2.; $i<=$axmax; $i+=$major) {
                    if ($orient eq "horizontal") {
                        $xp4 = $x1 +($x2-$x1)*($i-$axmin)/($axmax-$axmin);
                        $xp5 = $xp4o = $xp5o = $xp4;
                    } else {
                        $yp4 = $y1 +($y2-$y1)*($i-$axmin)/($axmax-$axmin);
                        $yp5 = $yp4o = $yp5o = $yp4;
                    }
                    if ($pr_tics ne "none") {
                        $canv->create_line($xp4, $yp4, $xp5, $yp5,
                                           -fill  => &get_rgb_code("black"),
                                           -width => 1,
                                           -arrow => 'none',
                                           -tags  => $tags);
                    }
                    if ($op_tics ne "none") {
                        $canv->create_line($xp4o, $yp4o, $xp5o, $yp5o,
                                           -fill  => &get_rgb_code("black"),
                                           -width => 1,
                                           -arrow => 'none',
                                           -tags  => $op_tags);
                    }
                }
            }
        }
    }
    if ($labels && $title ne "") {
        $tags .= "Title";
        if ($orient eq "horizontal") {
            $xp1 = ($x1+$x2)/2.;
            $ang = 0;
            $yp1 = ($side eq "bottom") ? $yp3+$tsize : $yp3-$tsize;
            $anc = ($side eq "bottom") ? 'n' : 's';
        } else {
            $yp1 = ($y1+$y2)/2.;
            $anc = 's';
            $xp1 = ($side eq "left") ? $xp3-2-$tsize : $xp3+2+$tsize;
            $ang = ($side eq "left") ? 90 : 270;
        }
        $canv->create_text($xp1, $yp1,
                           -anchor => $anc,
                           -text   => $title,
                           -fill   => &get_rgb_code("black"),
                           -angle  => $ang,
                           -tags   => $tags,
                           -font   => [-family     => $family,
                                       -size       => $title_size,
                                       -weight     => $title_weight,
                                       -slant      => 'roman',
                                       -underline  => 0,
                                       -overstrike => 0,
                                      ]);
    }
}


sub make_seg_axis {
    my ($canv, %axis_props) = @_;
    my (
        $anc, $ang, $axbase, $axis_tag, $axis_tag2, $axmax, $axmin, $bgrid,
        $bgrcolor, $d1, $d2, $d3, $dx, $dy, $family, $flipped, $gr1, $gr2,
        $grcolor, $grid, $gridtags, $gtag, $i, $id, $item, $label_size,
        $label_weight, $major, $min_major, $minor, $mstart, $nsegs, $op_loc,
        $op_tags, $op_tics, $orient, $pr_tics, $saxis_tag, $saxis_tag2,
        $side, $tag, $tags, $ticloc, $title, $title_size, $title_weight,
        $tsize, $type, $val, $x1, $x2, $xp1, $xp1o, $xp2, $xp2o, $xp3,
        $xp4, $xp4o, $xp5, $xp5o, $xtra, $y1, $y2, $yp1, $yp1o, $yp2,
        $yp2o, $yp3, $yp4, $yp4o, $yp5, $yp5o,

        @coords, @dist, @items, @seglist, @taglist,
       );

    $family       = $axis_props{font};
    $label_size   = $axis_props{size1};
    $title_size   = $axis_props{size2};
    $label_weight = $axis_props{weight1};
    $title_weight = $axis_props{weight2};

    $type    = $axis_props{type};           # above, below, replace
    $axbase  = $axis_props{base};           # km
    $axmin   = $axis_props{min};            # km
    $axmax   = $axis_props{max};            # km
    $major   = $axis_props{major};          # number of segments
    $grid    = $axis_props{grid};           # 0 = no, 1 = yes
    $bgrid   = $axis_props{bgrid};          # 0 = no, 1 = yes
    $title   = $axis_props{title};
    $ticloc  = $axis_props{tic_loc};        # center, upstream edge, downstream edge
    $side    = $axis_props{side};           # bottom, left, top, right
    $pr_tics = $axis_props{pr_tics};        # primary side:   inside, outside, cross, none
    $op_tics = $axis_props{op_tics};        # opposite side:  inside, outside, cross, none
    $op_loc  = $axis_props{op_loc};         # opposite side coordinate
    $tags    = $axis_props{tags};

    @seglist = @{ $axis_props{seglist} };   # list of segments, from ds to us
    @dist    = @{ $axis_props{dist}    };   # distance array in km

    if ($grid || $bgrid) {
        $grcolor     = $axis_props{gridcol} if ($grid);
        $bgrcolor    = $axis_props{bgridcol} if ($bgrid);
        ($gr1, $gr2) = @{ $axis_props{grcoord} };
        ($gridtags = $tags) =~ s/_saxis$/_sgrid/;
    }
    if ($op_tics ne "none") {
        $op_tags = $tags;
        @taglist = split(/ /, $op_tags);
        foreach $tag (@taglist) {
            if ($tag =~ /_saxis$/) {
                $op_tags .= " " . $tag . "2";
                last;
            }
        }
    }
    $title =~ s/^"//;
    $title =~ s/"$//;
    $tsize = 5;
    $dx = $dy = 0;

    ($x1, $y1, $x2, $y2) = @{ $axis_props{coords} };

    if ($axmin > $axmax) {
        $axmin = $axis_props{max};
        $axmax = $axis_props{min};
    } elsif ($axmin == $axmax) {
        &pop_up_error($main, "Axis minimum and maximum values are identical");
        return;
    }
    $major = "auto" if ($major eq "");
    if ($major ne "auto") {
        $major *= -1     if ($major+0  < 0);
        $major  = "auto" if ($major+0 == 0);
    }
    if ($y1 == $y2) {
        $orient  = "horizontal";
        $side    = "bottom" if (! defined($side) || $side ne "top");
        $flipped = ($x1 > $x2) ? 1 : 0;
    } elsif ($x1 == $x2) {
        $orient  = "vertical";
        $side    = "left" if (! defined($side) || $side ne "right");
        $flipped = ($y1 > $y2) ? 1 : 0;
    } else {
        &pop_up_error($main, "Invalid coordinates for segment axis");
        return;
    }
    if ($op_tics ne "none") {
        if ($orient eq "horizontal") {
            $op_tics = "none" if ($op_loc == $y1 || ($side eq "bottom" && $op_loc > $y1)
                                                 || ($side eq "top"    && $op_loc < $y1));
        } else {
            $op_tics = "none" if ($op_loc == $x1 || ($side eq "left"  && $op_loc < $x1)
                                                 || ($side eq "right" && $op_loc > $x1));
        }
    }

#   Calculate offset if segment axis is below X axis or left of Y axis
    if ($type eq "below") {
        @taglist = split(/ /, $tags);
        foreach $tag (@taglist) {
            if ($tag =~ /_saxis/) {
                if ($orient eq "horizontal") {
                    ($axis_tag = $tag) =~ s/_saxis/_xaxis/;
                } else {
                    ($axis_tag = $tag) =~ s/_saxis/_yaxis/;
                }
                $axis_tag2 = $axis_tag . "2";
                last;
            }
        }
        @items = Tkx::SplitList($canv->find_withtag($axis_tag));
        foreach $item (@items) {
            @taglist = Tkx::SplitList($canv->gettags($item));
            next if (&list_search($axis_tag2, @taglist) >= 0);
            $canv->addtag('group_axis', withtag => $item);
        }
        $canv->addtag('group_axis', withtag => $axis_tag . "Title");
        @coords = Tkx::SplitList($canv->bbox('group_axis'));
        $canv->dtag('group_axis');
        if ($orient eq "horizontal") {
            $dx = 0;
            if ($side eq "bottom") {
                $dy  = &max($coords[3], $coords[1]) -$y1 +7;
                $dy += 8 if ($pr_tics =~ /inside|cross/);
            } else {
                $dy  = &min($coords[3], $coords[1]) -$y1 -7;
                $dy -= 8 if ($pr_tics =~ /inside|cross/);
            }
        } else {
            $dy = 0;
            if ($side eq "left") {
                $dx  = &min($coords[2], $coords[0]) -$x1 -7;
                $dx -= 8 if ($pr_tics =~ /inside|cross/);
            } else {
                $dx  = &max($coords[2], $coords[0]) -$x1 +7;
                $dx += 8 if ($pr_tics =~ /inside|cross/);
            }
        }

      # Make an axis bar
        $canv->create_line($x1+$dx, $y1+$dy, $x2+$dx, $y2+$dy,
                           -fill  => &get_rgb_code("black"),
                           -width => 1,
                           -arrow => 'none',
                           -tags  => $tags);
    }

#   Figure out major spacing if set to "auto"
    $nsegs = $#seglist +1;
    if ($major eq "auto") {
        if ($orient eq "horizontal") {
            $min_major = int($nsegs *($label_size *4) /abs($x2-$x1) +0.0000001);
        } else {
            $min_major = int($nsegs *($label_size *4) /abs($y2-$y1) +0.0000001);
        }
        $major = &max(1, $min_major);
    }

#   Figure out minor spacing
    $minor = 0;
    if ($major > 1) {
        if ($major <= 5) {
            $minor = 1;
        } else {
            $mstart = &round_to_int($major /3.);
            for ($i=$mstart; $i<=$major; $i++) {
                if ($major % $i == 0) {
                    $minor = $i;
                    last;
                }
            }
            $minor = 0 if ($minor == $major);
        }
    }

#   Calculate locations of tick marks and labels
    $ang = 0;
    if ($orient eq "horizontal") {
        $anc = ($side eq "bottom") ? 'n' : 's';
        if ($ticloc =~ /down|up/) {
            if ($ticloc =~ /down/) {
                $xtra = ($flipped) ? 'e': 'w';
            } else {
                $xtra = ($flipped) ? 'w': 'e';
            }
            $anc .= $xtra;
        }
        $d1  = ($pr_tics eq "cross")       ? 4 : 0;
        $d2  = ($pr_tics eq "inside")      ? 8 : 0;
        $d3  = ($pr_tics =~ /inside|none/) ? 6 : 0;
        $yp1 = ($side eq "bottom") ? $y1-2*$d1   : $y1+2*$d1;   # major ticks
        $yp2 = ($side eq "bottom") ? $y1+8-2*$d2 : $y1-8+2*$d2; # major ticks
        $yp3 = ($side eq "bottom") ? $y1+9-$d3   : $y1-9+$d3;   # tick labels
        $yp4 = ($side eq "bottom") ? $y1-$d1     : $y1+$d1;     # minor ticks
        $yp5 = ($side eq "bottom") ? $y1+4-$d2   : $y1-4+$d2;   # minor ticks
        if ($op_tics ne "none") {
            $d1   = ($op_tics eq "cross")  ? 4 : 0;
            $d2   = ($op_tics eq "inside") ? 8 : 0;
            $yp1o = ($side eq "bottom") ? $op_loc+2*$d1   : $op_loc-2*$d1;   # major ticks
            $yp2o = ($side eq "bottom") ? $op_loc-8+2*$d2 : $op_loc+8-2*$d2; # major ticks
            $yp4o = ($side eq "bottom") ? $op_loc+$d1     : $op_loc-$d1;     # minor ticks
            $yp5o = ($side eq "bottom") ? $op_loc-4+$d2   : $op_loc+4-$d2;   # minor ticks
        }
    } else {
        $anc = ($side eq "left") ? 'e' : 'w';
        if ($ticloc =~ /down|up/) {
            if ($ticloc =~ /down/) {
                $xtra = ($flipped) ? 'n': 's';
            } else {
                $xtra = ($flipped) ? 's': 'n';
            }
            $anc = $xtra . $anc;
        }
        $d1  = ($pr_tics eq "cross")       ? 4 : 0;
        $d2  = ($pr_tics eq "inside")      ? 8 : 0;
        $d3  = ($pr_tics =~ /inside|none/) ? 6 : 0;
        $xp1 = ($side eq "left") ? $x1+2*$d1   : $x1-2*$d1;   # major ticks
        $xp2 = ($side eq "left") ? $x1-8+2*$d2 : $x1+8-2*$d2; # major ticks
        $xp3 = ($side eq "left") ? $x1-10+$d3  : $x1+10-$d3;  # tick labels
        $xp4 = ($side eq "left") ? $x1+$d1     : $x1-$d1;     # minor ticks
        $xp5 = ($side eq "left") ? $x1-4+$d2   : $x1+4-$d2;   # minor ticks
        if ($op_tics ne "none") {
            $d1   = ($op_tics eq "cross")  ? 4 : 0;
            $d2   = ($op_tics eq "inside") ? 8 : 0;
            $xp1o = ($side eq "left") ? $op_loc-2*$d1   : $op_loc+2*$d1;   # major ticks
            $xp2o = ($side eq "left") ? $op_loc+8-2*$d2 : $op_loc-8+2*$d2; # major ticks
            $xp4o = ($side eq "left") ? $op_loc-$d1     : $op_loc+$d1;     # minor ticks
            $xp5o = ($side eq "left") ? $op_loc+4-$d2   : $op_loc-4+$d2;   # minor ticks
        }
    }

#   Make grid lines, if requested
    if ($grid) {
        for ($i=$#seglist; $i>=0; $i-=$major) {
            if ($ticloc eq "upstream edge") {
                $val = $dist[$seglist[$i]];
            } elsif ($ticloc eq "downstream edge") {
                $val = ($i == 0) ? 0.0 : $dist[$seglist[$i-1]];
            } else {
                $val = ($i == 0) ? 0.5*$dist[$seglist[$i]] : 0.5*($dist[$seglist[$i]] +$dist[$seglist[$i-1]]);
            }
            $val += $axbase;
            next if ($val < $axmin -0.001 || $val > $axmax +0.001);
            if ($orient eq "horizontal") {
                $xp1 = $x1 +($x2-$x1)*($val-$axmin)/($axmax-$axmin);
                @coords = ($xp1, $gr1, $xp1, $gr2);
            } else {
                $yp1 = $y1 +($y2-$y1)*($val-$axmin)/($axmax-$axmin);
                @coords = ($gr1, $yp1, $gr2, $yp1);
            }
            $canv->create_line(@coords, -fill  => &get_rgb_code($grcolor),
                                        -width => 1,
                                        -arrow => 'none',
                                        -tags  => $gridtags);
        }
    }

#   Make branch boundary grid lines, if requested
    if ($bgrid) {
        for ($i=$#seglist; $i>0; $i--) {
            next if ($seglist[$i-1] == $seglist[$i] +1);
            $val  = $dist[$seglist[$i-1]];
            $val += $axbase;
            next if ($val < $axmin || $val > $axmax);
            if ($orient eq "horizontal") {
                $xp1 = $x1 +($x2-$x1)*($val-$axmin)/($axmax-$axmin);
                @coords = ($xp1, $gr1, $xp1, $gr2);
            } else {
                $yp1 = $y1 +($y2-$y1)*($val-$axmin)/($axmax-$axmin);
                @coords = ($gr1, $yp1, $gr2, $yp1);
            }
            $canv->create_line(@coords, -fill  => &get_rgb_code($bgrcolor),
                                        -width => 1,
                                        -arrow => 'none',
                                        -tags  => $gridtags);
        }
    }

#   Make major tick marks and labels
    for ($i=$#seglist; $i>=0; $i-=$major) {
        if ($ticloc eq "upstream edge") {
            $val = $dist[$seglist[$i]];
        } elsif ($ticloc eq "downstream edge") {
            $val = ($i == 0) ? 0.0 : $dist[$seglist[$i-1]];
        } else {
            $val = ($i == 0) ? 0.5* $dist[$seglist[$i]] : 0.5* ($dist[$seglist[$i]] +$dist[$seglist[$i-1]]);
        }
        $val += $axbase;
        next if ($val < $axmin -0.001 || $val > $axmax +0.001);
        if ($orient eq "horizontal") {
            $xp1 = $x1 +($x2-$x1)*($val-$axmin)/($axmax-$axmin);
            $xp2 = $xp3 = $xp1o = $xp2o = $xp1;
        } else {
            $yp1 = $y1 +($y2-$y1)*($val-$axmin)/($axmax-$axmin);
            $yp2 = $yp3 = $yp1o = $yp2o = $yp1;
        }
        if ($pr_tics ne "none") {
            $canv->create_line($xp1+$dx, $yp1+$dy, $xp2+$dx, $yp2+$dy,
                               -fill  => &get_rgb_code("black"),
                               -width => 1,
                               -arrow => 'none',
                               -tags  => $tags);
        }
        if ($op_tics ne "none") {
            $canv->create_line($xp1o, $yp1o, $xp2o, $yp2o,
                               -fill  => &get_rgb_code("black"),
                               -width => 1,
                               -arrow => 'none',
                               -tags  => $op_tags);
        }
        $id = $canv->create_text($xp3+$dx, $yp3+$dy,
                           -anchor => $anc,
                           -text   => $seglist[$i],
                           -fill   => &get_rgb_code("black"),
                           -angle  => $ang,
                           -tags   => $tags,
                           -font   => [-family     => $family,
                                       -size       => $label_size,
                                       -weight     => $label_weight,
                                       -slant      => 'roman',
                                       -underline  => 0,
                                       -overstrike => 0,
                                      ]);
        @coords = Tkx::SplitList($canv->bbox($id));
        if ($orient eq "horizontal") {
            $tsize = &max($tsize, abs($coords[3] - $coords[1]));
        } else {
            $tsize = &max($tsize, abs($coords[2] - $coords[0]));
        }
    }

#   Make minor tick marks
    if ($minor > 0 && ($pr_tics ne "none" || $op_tics ne "none")) {
        for ($i=$#seglist; $i>=0; $i-=$minor) {
            next if (($#seglist-$i) % $major == 0);
            if ($ticloc eq "upstream edge") {
                $val = $dist[$seglist[$i]];
            } elsif ($ticloc eq "downstream edge") {
                $val = ($i==0) ? 0.0 : $dist[$seglist[$i-1]];
            } else {
                $val = ($i==0) ? 0.5* $dist[$seglist[$i]] : 0.5* ($dist[$seglist[$i]] +$dist[$seglist[$i-1]]);
            }
            $val += $axbase;
            next if ($val < $axmin -0.0005 || $val > $axmax +0.0005);
            if ($orient eq "horizontal") {
                $xp4 = $x1 +($x2-$x1)*($val-$axmin)/($axmax-$axmin);
                $xp5 = $xp4o = $xp5o = $xp4;
            } else {
                $yp4 = $y1 +($y2-$y1)*($val-$axmin)/($axmax-$axmin);
                $yp5 = $yp4o = $yp5o = $yp4;
            }
            if ($pr_tics ne "none") {
                $canv->create_line($xp4+$dx, $yp4+$dy, $xp5+$dx, $yp5+$dy,
                                   -fill  => &get_rgb_code("black"),
                                   -width => 1,
                                   -arrow => 'none',
                                   -tags  => $tags);
            }
            if ($op_tics ne "none") {
                $canv->create_line($xp4o, $yp4o, $xp5o, $yp5o,
                                   -fill  => &get_rgb_code("black"),
                                   -width => 1,
                                   -arrow => 'none',
                                   -tags  => $op_tags);
            }
        }
    }

#   Segment axis title
    if ($title ne "") {
        $tags .= "Title";
        $d3    = ($pr_tics =~ /inside|none/) ? 6 : 0;
        if ($orient eq "horizontal") {
            $xp1 = ($x1+$x2)/2.;
            $ang = 0;
            $yp1 = ($side eq "bottom") ? $y1+9+$tsize-$d3 : $y1-9-$tsize+$d3;
            $anc = ($side eq "bottom") ? 'n' : 's';
        } else {
            $yp1 = ($y1+$y2)/2.;
            $anc = 's';
            $xp1 = ($side eq "left") ? $x1-12-$tsize+$d3 : $x1+12+$tsize-$d3;
            $ang = ($side eq "left") ? 90 : 270;
        }
        $canv->create_text($xp1+$dx, $yp1+$dy,
                           -anchor => $anc,
                           -text   => $title,
                           -fill   => &get_rgb_code("black"),
                           -angle  => $ang,
                           -tags   => $tags,
                           -font   => [-family     => $family,
                                       -size       => $title_size,
                                       -weight     => $title_weight,
                                       -slant      => 'roman',
                                       -underline  => 0,
                                       -overstrike => 0,
                                      ]);
    }

#   Move the regular axis if segment axis is above the regular axis.
#   At this point, the segment axis is restricted to orient=horizontal and side=bottom
#     and therefore the regular axis is the X axis.
    if ($type eq "above") {
        @taglist = split(/ /, $tags);
        foreach $tag (@taglist) {
            if ($tag =~ /_saxis/) {
                ($saxis_tag = $tag) =~ s/Title$//;
                if ($orient eq "horizontal") {
                    ($axis_tag = $saxis_tag) =~ s/_saxis/_xaxis/;
                } else {
                    ($axis_tag = $saxis_tag) =~ s/_saxis/_yaxis/;
                }
                $saxis_tag2 = $saxis_tag . "2";
                $axis_tag2  = $axis_tag  . "2";
                last;
            }
        }
      # Get bounding box for segment axis, tick, and title without opposite axis
        @items = Tkx::SplitList($canv->find_withtag($saxis_tag));
        foreach $item (@items) {
            @taglist = Tkx::SplitList($canv->gettags($item));
            next if (&list_search($saxis_tag2, @taglist) >= 0);
            $canv->addtag('group_axis', withtag => $item);
        }
        $canv->addtag('group_axis', withtag => $saxis_tag . "Title");
        @coords = Tkx::SplitList($canv->bbox('group_axis'));
        $canv->dtag('group_axis');
        if ($orient eq "horizontal") {
            $dx = 0;
            if ($side eq "bottom") {
                $dy = &max($coords[3], $coords[1]) -$y1 +7;
            } else {
                $dy = &min($coords[3], $coords[1]) -$y1 -7;
            }
        } else {
            $dy = 0;
            if ($side eq "left") {
                $dx = &min($coords[2], $coords[0]) -$x1 -7;
            } else {
                $dx = &max($coords[2], $coords[0]) -$x1 +7;
            }
        }
      # Get bounding box for regular axis, tick, and title without opposite axis
        @items = Tkx::SplitList($canv->find_withtag($axis_tag));
        foreach $item (@items) {
            @taglist = Tkx::SplitList($canv->gettags($item));
            next if (&list_search($axis_tag2, @taglist) >= 0);
            $canv->addtag('group_axis', withtag => $item);
        }
        $canv->addtag('group_axis', withtag => $axis_tag . "Title");
        @coords = Tkx::SplitList($canv->bbox('group_axis'));
        if ($orient eq "horizontal") {
            if ($side eq "bottom") {
                $dy += &max(0, $y1-&min($coords[3], $coords[1]));
            } else {
                $dy -= &max(0, &max($coords[3], $coords[1]) -$y1);
            }
        } else {
            if ($side eq "left") {
                $dx -= &max(0, &max($coords[2], $coords[0]) -$x1);
            } else {
                $dx += &max(0, $x1-&min($coords[2], $coords[0]));
            }
        }
        $canv->move('group_axis', $dx, $dy);
        $canv->dtag('group_axis');

      # Add an axis line for the regular axis
        ($gtag = $axis_tag) =~ s/_.axis//;
        $tags = $gtag . " " . $axis_tag;
        $canv->create_line($x1+$dx, $y1+$dy, $x2+$dx, $y2+$dy,
                           -fill  => &get_rgb_code("black"),
                           -width => 1,
                           -arrow => 'none',
                           -tags  => $tags);
    }
}


sub make_date_axis {
    my ($canv, %axis_props) = @_;
    my (

        $add_minor, $anc, $ang, $ax_pix, $axmax, $axmin, $d, $d1, $d2, $d3,
        $datefmt, $family, $fmt, $gr1, $gr2, $grcolor, $grid, $gridtags,
        $grwidth, $i, $id, $jd, $label, $label_size, $label_weight, $m,
        $major, $min_major, $minor, $next_jd, $nt, $on_tick, $op_loc,
        $op_tags, $op_tics, $orient, $pix_per_mon, $pix_per_yr, $pr_tics,
        $range, $reverse, $side, $tag, $tags, $title, $title_size,
        $title_weight, $tsize, $x1, $x2, $xp1, $xp1o, $xp2, $xp2o, $xp3,
        $xp4, $xp4o, $xp5, $xp5o, $xtra, $y, $y1, $y2, $yp1, $yp1o, $yp2,
        $yp2o, $yp3, $yp4, $yp4o, $yp5, $yp5o, $yr_max, $yr_min,

        @coords, @long_ticks, @major_ticks, @taglist, @tick_jd, @tick_jd2,
        @tick_labels, @tick_labels2,
       );

    $family       = $axis_props{font};
    $label_size   = $axis_props{size1};
    $title_size   = $axis_props{size2};
    $label_weight = $axis_props{weight1};
    $title_weight = $axis_props{weight2};

    $axmin   = $axis_props{min};
    $axmax   = $axis_props{max};
    $major   = $axis_props{major};
    $minor   = $axis_props{minor};     # 0 = no, 1 = yes
    $reverse = $axis_props{reverse};   # 0 = no, 1 = yes
    $datefmt = $axis_props{datefmt};   # Year, Month, Mon-DD, Mon-DD-YYYY
    $title   = $axis_props{title};
    $side    = $axis_props{side};      # left, right, top, bottom
    $pr_tics = $axis_props{pr_tics};   # primary side:   inside, outside, cross, none
    $op_tics = $axis_props{op_tics};   # opposite side:  inside, outside, cross, none
    $op_loc  = $axis_props{op_loc};    # opposite side coordinate
    $tags    = $axis_props{tags};

    if (defined($axis_props{grid})) {
        $grid        = $axis_props{grid};
        $grwidth     = $axis_props{grwidth};
        $grcolor     = $axis_props{grcolor};
        ($gr1, $gr2) = @{ $axis_props{grcoord} };
        ($gridtags = $tags) =~ s/_.axis$/_grid/;
    } else {
        $grid = 0;
    }
    if ($op_tics ne "none") {
        $op_tags = $tags;
        @taglist = split(/ /, $op_tags);
        foreach $tag (@taglist) {
            if ($tag =~ /_.axis$/) {
                $op_tags .= " " . $tag . "2";
                last;
            }
        }
    }
    $title =~ s/^"//;
    $title =~ s/"$//;
    $tsize =  0;

    ($x1, $y1, $x2, $y2) = @{ $axis_props{coords} };

    if ($axmin > $axmax) {
        $axmin = $axis_props{max};
        $axmax = $axis_props{min};
    } elsif ($axmin == $axmax) {
        &pop_up_error($main, "Axis minimum and maximum values are identical");
        return;
    }
    if ($major ne "auto") {
        $major *= -1     if ($major+0  < 0);
        $major  = "auto" if ($major+0 == 0);
    }
    $minor *= -1 if ($minor < 0);
    if ($y1 == $y2) {
        $orient = "horizontal";
        $side   = "bottom" if (! defined($side) || $side ne "top");
        $ax_pix = abs($x2-$x1);
    } elsif ($x1 == $x2) {
        $orient = "vertical";
        $side   = "left" if (! defined($side) || $side ne "right");
        $ax_pix = abs($y2-$y1);
    } else {
        &pop_up_error($main, "Invalid coordinates for axis");
        return;
    }
    if ($op_tics ne "none") {
        if ($orient eq "horizontal") {
            $op_tics = "none" if ($op_loc == $y1 || ($side eq "bottom" && $op_loc > $y1)
                                                 || ($side eq "top"    && $op_loc < $y1));
        } else {
            $op_tics = "none" if ($op_loc == $x1 || ($side eq "left"  && $op_loc < $x1)
                                                 || ($side eq "right" && $op_loc > $x1));
        }
    }

#   Determine an optimal major tick spacing for date axis
    $xtra    = 0;
    $on_tick = 0;
    @major_ticks  = ();
    @long_ticks   = ();
    @tick_jd      = ();
    @tick_jd2     = ();
    @tick_labels  = ();
    @tick_labels2 = ();
    if ($datefmt eq "Year") {
        $fmt = $datefmt;
        if ($orient eq "horizontal") {
            $ang = 0;
            $anc = ($side eq "bottom") ? 'n' : 's';
        } else {
            $ang = 90;
            $anc = ($side eq "left") ? 's' : 'n';
        }
        $pix_per_yr = $ax_pix /(($axmax-$axmin) /365.25);
        if ($pix_per_yr / $label_size <= 1.5) {    # Year on major tick mark, rotated; use major
            $on_tick = 1;
            if ($orient eq "horizontal") {
                $ang  = 90;
                $anc  = ($side eq "bottom") ? 'e' : 'w';
                $xtra = 2 if ($side eq "bottom");
            } else {
                $ang  = 0;
                $anc  = ($side eq "left") ? 'e' : 'w';
                $xtra = 2 if ($side eq "left");
            }
            ($yr_min, $m, $d) = split(/-/, &jdate2datelabel(&floor($axmin +0.0000001), ""));
            ($yr_max, $m, $d) = split(/-/, &jdate2datelabel($axmax, ""));
            $range = $yr_max -$yr_min;
            if ($major eq "auto") {
                if ($orient eq "horizontal") {
                    $min_major = int($range *($label_size *2.5) /abs($x2-$x1) +0.0000001);
                } else {
                    $min_major = int($range *($label_size *2.5) /abs($y2-$y1) +0.0000001);
                }
                $min_major = 1 if ($min_major == 0);
                for ($i=$range-1; $i>=$min_major; $i--) {
                    $major = $i if ($range % $i == 0);
                }
                $major = $min_major if ($major eq "auto");
            }
            $major = &min($range, $major);
        } elsif ($pix_per_yr /$label_size <= 4) {  # Year between tick marks, rotated
            $on_tick = 0;
            $minor   = 0;
            if ($orient eq "horizontal") {
                $ang  = 90;
                $anc  = ($side eq "bottom") ? 'e' : 'w';
                $xtra = 2 if ($side eq "bottom");
            } else {
                $ang  = 0;
                $anc  = ($side eq "left") ? 'e' : 'w';
                $xtra = 2 if ($side eq "left");
            }
        } else {                                   # Year between ticks, unrotated
            $on_tick = 0;
            $minor   = 0;
        }
        $jd = &floor($axmin +0.0000001);
        ($y, $m, $d) = split(/-/, &jdate2datelabel($jd, ""));
        if ($on_tick) {
            if ($m == 1 && $d == 1) {
                push (@major_ticks, $jd);
                push (@tick_labels, $y);
                $next_jd = &date2jdate(sprintf("%04d%s", $y+$major, "0101"));
                $y += $major;
            } else {
                $next_jd = &date2jdate(sprintf("%04d%s", $y+1, "0101"));
                $y++;
            }
            while ($next_jd <= $axmax) {
                $jd      = $next_jd;
                $next_jd = &date2jdate(sprintf("%04d%s", $y+$major, "0101"));
                if ($jd <= $axmax) {
                    push (@major_ticks, $jd);
                    push (@tick_labels, $y);
                }
                $y += $major;
            }
            @tick_jd = @major_ticks;
        } else {
            $next_jd = &date2jdate(sprintf("%04d%s", $y+1, "0101"));
            if ($m == 1 && $d == 1) {
                push (@major_ticks, $jd);
                push (@tick_labels, $y);
                push (@tick_jd, ($jd + &min($next_jd, $axmax))/2.);
            } elsif ($m <= 6) {
                push (@tick_labels, $y);
                push (@tick_jd, ($jd + &min($next_jd, $axmax))/2.);
            }
            $y++;
            while ($next_jd <= $axmax) {
                push (@major_ticks, $next_jd);
                $jd      = $next_jd;
                $next_jd = &date2jdate(sprintf("%04d%s", $y+1, "0101"));
                if ($next_jd <= $axmax) {
                    push (@tick_labels, $y);
                    push (@tick_jd, ($jd +$next_jd)/2.);
                }
                $y++;
            }
            if ($jd < $axmax) {
                ($y, $m, $d) = split(/-/, &jdate2datelabel($axmax, ""));
                if ($m >= 7) {
                    push (@tick_labels, $y);
                    push (@tick_jd, ($jd +$axmax)/2.);
                }
            }
        }

    } elsif ($datefmt eq "Month") {
        $minor = 0;
        if ($orient eq "horizontal") {
            $ang = 0;
            $anc = ($side eq "bottom") ? 'n' : 's';
        } else {
            $ang = 90;
            $anc = ($side eq "left") ? 's' : 'n';
        }
        $pix_per_mon = $ax_pix /(($axmax-$axmin) *12/365.25);
        if ($pix_per_mon /$label_size >= 8) {
            $fmt = "Month";
            $datefmt = "MonthDay" if (($axmax -$axmin) *1.9 *$label_size < $ax_pix);
        } elsif ($pix_per_mon /$label_size > 4) {
            $fmt = "Mon";
        } elsif ($pix_per_mon /$label_size > 1.5) {
            $fmt = "Mon";
            if ($orient eq "horizontal") {
                $ang  = 90;
                $anc  = ($side eq "bottom") ? 'e' : 'w';
                $xtra = 2 if ($side eq "bottom");
            } else {
                $ang  = 0;
                $anc  = ($side eq "left") ? 'e' : 'w';
                $xtra = 2 if ($side eq "left");
            }
        } else {
            $fmt = "M";
        }
        $jd = &floor($axmin +0.0000001);
        ($y, $m, $d) = split(/-/, &jdate2datelabel($jd, ""));
        push (@major_ticks, $jd) if ($d == 1);
        &set_leap_year($y);
        $next_jd = &min($axmax, $jd -$d +$days_in_month[$m-1] +1);
        if ($fmt eq "Month" && (($datefmt eq "MonthDay" && ($next_jd -$jd) < 10) ||
                                ($datefmt eq "Month"    && ($next_jd -$jd) < 20))) {
            $label = &jdate2datelabel($jd, "Mon");
        } else {
            $label = &jdate2datelabel($jd, $fmt);
        }
        if ($next_jd -$jd >= 17
             || 2 *length($label) *$label_size /$ax_pix < ($next_jd -$jd) /($axmax -$axmin)) {
            push (@tick_jd, ($jd + &min($next_jd, $axmax))/2.);
            push (@tick_labels, $label);
        }
        $next_jd = $jd -$d +$days_in_month[$m-1] +1;
        while ($next_jd <= $axmax) {
            $jd = $next_jd;
            push (@major_ticks, $jd);
            $m++;
            if ($m > 12) {
                $m = 1;
                $y++;
                &set_leap_year($y);
            }
            $next_jd = $jd +$days_in_month[$m-1];
            if ($next_jd <= $axmax) {
                push (@tick_jd,     ($jd +$next_jd)/2.);
                push (@tick_labels, &jdate2datelabel($jd, $fmt));
            }
        }
        if ($jd < $axmax) {
            ($y, $m, $d) = split(/-/, &jdate2datelabel($axmax, ""));
            if ($fmt eq "Month" && (($datefmt eq "MonthDay" && $d < 10) ||
                                    ($datefmt eq "Month"    && $d < 20))) {
                $label = &jdate2datelabel($jd, "Mon");
            } else {
                $label = &jdate2datelabel($jd, $fmt);
            }
            if ($d >= 17 || 2 *length($label) *$label_size /$ax_pix < ($d-1) /($axmax -$axmin)) {
                push (@tick_jd, ($jd +$axmax)/2.);
                push (@tick_labels, $label);
            }
        }
        if ($#tick_jd > 0 && $tick_jd[-1] == $tick_jd[-2]) {
            pop (@tick_jd);
            $tick_labels[-1] = pop (@tick_labels);
        }
        if ($datefmt eq "MonthDay") {
            @tick_jd2     = @tick_jd;
            @tick_labels2 = @tick_labels;
            for ($i=0; $i<=$#tick_jd2; $i++) {
                ($y, $m, $d) = split(/-/, &jdate2datelabel($tick_jd2[$i], ""));
                $tick_labels2[$i] .= ", $y";
            }
            @major_ticks = ();
            @tick_jd     = ();
            @tick_labels = ();
            $title = "" if ($#tick_labels2 >= 0);
            $jd    = &floor($axmin +0.0000001);
            ($y, $m, $d) = split(/-/, &jdate2datelabel($jd, ""));
            &set_leap_year($y);
            if ($d == 1) {
                push (@long_ticks, $jd);
            } else {
                push (@major_ticks, $jd);
            }
            while ($jd +1 <= $axmax) {
                push (@tick_jd,     $jd +0.5);
                push (@tick_labels, sprintf("%d", $d));
                $jd++;
                $d++;
                if ($d > $days_in_month[$m-1]) {
                    $d = 1;
                    $m++;
                    if ($m > 12) {
                        $m = 1;
                        $y++;
                        &set_leap_year($y);
                    }
                }
                if ($d == 1) {
                    push (@long_ticks, $jd);
                } else {
                    push (@major_ticks, $jd);
                }
            }
        }

    } else {                           # Mon-DD or Mon-DD-YYYY format
        $fmt = $datefmt;
        if ($orient eq "horizontal") {
            $ang  = 90;
            $anc  = ($side eq "bottom") ? 'e' : 'w';
            $xtra = 2 if ($side eq "bottom");
        } else {
            $ang  = 0;
            $anc  = ($side eq "left") ? 'e' : 'w';
            $xtra = 2 if ($side eq "left");
        }
        if ($major eq "auto") {
            $range = $axmax-$axmin;
            if ($orient eq "horizontal") {
                $min_major = int($range *($label_size *3) /abs($x2-$x1) +0.0000001);
            } else {
                $min_major = int($range *($label_size *3) /abs($y2-$y1) +0.0000001);
            }
            $min_major = 1 if ($min_major == 0);
            for ($i=$min_major; $i<=$range/12; $i++) {
                $major = $i if (&round_to_int($range) % $i == 0);
            }
            $major = $min_major if ($major eq "auto");
        }
        if ($reverse) {
            for ($i=$axmax; $i<=$axmin; $i-=$major) {
                push (@major_ticks, $i);
                push (@tick_labels, &jdate2datelabel($i, $fmt));
            }
        } else {
            for ($i=$axmin; $i<=$axmax; $i+=$major) {
                push (@major_ticks, $i);
                push (@tick_labels, &jdate2datelabel($i, $fmt));
            }
        }
        @tick_jd = @major_ticks;
    }

#   Make major tick marks and labels
    if ($orient eq "horizontal") {
        $d1  = ($pr_tics eq "cross")       ? 4 : 0;
        $d2  = ($pr_tics eq "inside")      ? 8 : 0;
        $d3  = ($pr_tics =~ /inside|none/) ? 6 : 0;
        $yp1 = ($side eq "bottom") ? $y1-2*$d1   : $y1+2*$d1;                # major ticks
        $yp2 = ($side eq "bottom") ? $y1+8-2*$d2 : $y1-8+2*$d2;              # major ticks
        $yp4 = ($side eq "bottom") ? $y1-$d1     : $y1+$d1;                  # minor ticks
        $yp5 = ($side eq "bottom") ? $y1+4-$d2   : $y1-4+$d2;                # minor ticks
        if ($fmt =~ /^(Month|Mon|M)$/ || ($fmt eq "Year" && ! $on_tick)) {
            $yp3 = ($side eq "bottom") ? $y1+5-(2/6*$d3)+$xtra : $y1-5+(2/6*$d3)-$xtra;
        } else {
            $yp3 = ($side eq "bottom") ? $y1+9-$d3+$xtra : $y1-9+$d3-$xtra;  # tick marks
        }
        if ($op_tics ne "none") {
            $d1   = ($op_tics eq "cross")  ? 4 : 0;
            $d2   = ($op_tics eq "inside") ? 8 : 0;
            $yp1o = ($side eq "bottom") ? $op_loc+2*$d1   : $op_loc-2*$d1;   # major ticks
            $yp2o = ($side eq "bottom") ? $op_loc-8+2*$d2 : $op_loc+8-2*$d2; # major ticks
            $yp4o = ($side eq "bottom") ? $op_loc+$d1     : $op_loc-$d1;     # minor ticks
            $yp5o = ($side eq "bottom") ? $op_loc-4+$d2   : $op_loc+4-$d2;   # minor ticks
        }
    } else {
        $d1  = ($pr_tics eq "cross")       ? 4 : 0;
        $d2  = ($pr_tics eq "inside")      ? 8 : 0;
        $d3  = ($pr_tics =~ /inside|none/) ? 6 : 0;
        $xp1 = ($side eq "left") ? $x1+2*$d1   : $x1-2*$d1;   # major ticks
        $xp2 = ($side eq "left") ? $x1-8+2*$d2 : $x1+8-2*$d2; # major ticks
        $xp4 = ($side eq "left") ? $x1+$d1     : $x1-$d1;     # minor ticks
        $xp5 = ($side eq "left") ? $x1-4+$d2   : $x1+4-$d2;   # minor ticks
        if ($fmt =~ /^(Month|Mon|M)$/ || ($fmt eq "Year" && ! $on_tick)) {
            $xp3 = ($side eq "left") ? $x1-5+(2/6*$d3)-$xtra : $x1+5-(2/6*$d3)+$xtra;
        } else {
            $xp3 = ($side eq "left") ? $x1-9+$d3-$xtra : $x1+9-$d3+$xtra;
        }
        if ($op_tics ne "none") {
            $d1   = ($op_tics eq "cross")  ? 4 : 0;
            $d2   = ($op_tics eq "inside") ? 8 : 0;
            $xp1o = ($side eq "left") ? $op_loc-2*$d1   : $op_loc+2*$d1;   # major ticks
            $xp2o = ($side eq "left") ? $op_loc+8-2*$d2 : $op_loc-8+2*$d2; # major ticks
            $xp4o = ($side eq "left") ? $op_loc-$d1     : $op_loc+$d1;     # minor ticks
            $xp5o = ($side eq "left") ? $op_loc+4-$d2   : $op_loc-4+$d2;   # minor ticks
        }
    }
    if ($grid || $pr_tics ne "none" || $op_tics ne "none") {
        for ($i=0; $i<=$#major_ticks; $i++) {
            $jd = $major_ticks[$i];
            if ($reverse) {
                if ($orient eq "horizontal") {
                    $xp1 = $x1 +($x2-$x1)*($axmax-$jd)/($axmax-$axmin);
                    $xp2 = $xp1o = $xp2o = $xp1;
                } else {
                    $yp1 = $y1 +($y2-$y1)*($axmax-$jd)/($axmax-$axmin);
                    $yp2 = $yp1o = $yp2o = $yp1;
                }
            } else {
                if ($orient eq "horizontal") {
                    $xp1 = $x1 +($x2-$x1)*($jd-$axmin)/($axmax-$axmin);
                    $xp2 = $xp1o = $xp2o = $xp1;
                } else {
                    $yp1 = $y1 +($y2-$y1)*($jd-$axmin)/($axmax-$axmin);
                    $yp2 = $yp1o = $yp2o = $yp1;
                }
            }
            if ($grid && $jd > $axmin && $jd < $axmax) {
                if ($orient eq "horizontal") {
                    @coords = ($xp1, $gr1, $xp1, $gr2);
                } else {
                    @coords = ($gr1, $yp1, $gr2, $yp1);
                }
                $canv->create_line(@coords, -fill  => &get_rgb_code($grcolor),
                                            -width => $grwidth,
                                            -arrow => 'none',
                                            -tags  => $gridtags);
            }
            if ($pr_tics ne "none") {
                $canv->create_line($xp1, $yp1, $xp2, $yp2,
                                   -fill  => &get_rgb_code("black"),
                                   -width => 1,
                                   -arrow => 'none',
                                   -tags  => $tags);
            }
            if ($op_tics ne "none") {
                $canv->create_line($xp1o, $yp1o, $xp2o, $yp2o,
                                   -fill  => &get_rgb_code("black"),
                                   -width => 1,
                                   -arrow => 'none',
                                   -tags  => $op_tags);
            }
        }
    }
    for ($i=0; $i<=$#tick_jd; $i++) {
        $jd    = $tick_jd[$i];
        $label = $tick_labels[$i];
        if ($reverse) {
            if ($orient eq "horizontal") {
                $xp3 = $x1 +($x2-$x1)*($axmax-$jd)/($axmax-$axmin);
            } else {
                $yp3 = $y1 +($y2-$y1)*($axmax-$jd)/($axmax-$axmin);
            }
        } else {
            if ($orient eq "horizontal") {
                $xp3 = $x1 +($x2-$x1)*($jd-$axmin)/($axmax-$axmin);
            } else {
                $yp3 = $y1 +($y2-$y1)*($jd-$axmin)/($axmax-$axmin);
            }
        }
        $id = $canv->create_text($xp3, $yp3,
                           -anchor => $anc,
                           -text   => $label,
                           -fill   => &get_rgb_code("black"),
                           -angle  => $ang,
                           -tags   => $tags,
                           -font   => [-family     => $family,
                                       -size       => $label_size,
                                       -weight     => $label_weight,
                                       -slant      => 'roman',
                                       -underline  => 0,
                                       -overstrike => 0,
                                      ]);
        if ($i == 0 || $i == $#tick_labels) {
            @coords = Tkx::SplitList($canv->bbox($id));
            if ($orient eq "horizontal") {
                $tsize = &max($tsize, abs($coords[3] - $coords[1]));
            } else {
                $tsize = &max($tsize, abs($coords[2] - $coords[0]));
            }
        }
    }
    if ($#long_ticks >= 0 && ($grid || $pr_tics ne "none" || $op_tics ne "none")) {
        if ($orient eq "horizontal") {
            $d1  = ($pr_tics eq "cross")  ? 12 : 0;
            $d2  = ($pr_tics eq "inside") ? 17+$tsize+$xtra : 0;
            $yp1 = ($side eq "bottom") ? $y1-$d1                : $y1+$d1;
            $yp2 = ($side eq "bottom") ? $y1+5+$tsize+$xtra-$d2 : $y1-5-$tsize-$xtra+$d2;
            if ($op_tics ne "none") {
                $d1   = ($op_tics eq "cross")  ? 12 : 0;
                $d2   = ($op_tics eq "inside") ? 24 : 0;
                $yp1o = ($side eq "bottom") ? $op_loc+$d1    : $op_loc-$d1;
                $yp2o = ($side eq "bottom") ? $op_loc-12+$d2 : $op_loc+12-$d2;
            }
        } else {
            $d1  = ($pr_tics eq "cross")  ? 12 : 0;
            $d2  = ($pr_tics eq "inside") ? 22+$tsize : 0;
            $xp1 = ($side eq "left") ? $x1+$d1           : $x1-$d1;
            $xp2 = ($side eq "left") ? $x1-10-$tsize+$d2 : $x1+10+$tsize-$d2;
            if ($op_tics ne "none") {
                $d1   = ($op_tics eq "cross")  ? 12 : 0;
                $d2   = ($op_tics eq "inside") ? 24 : 0;
                $xp1o = ($side eq "left") ? $op_loc-$d1    : $op_loc+$d1;
                $xp2o = ($side eq "left") ? $op_loc+12-$d2 : $op_loc-12+$d2;
            }
        }
        for ($i=0; $i<=$#long_ticks; $i++) {
            $jd = $long_ticks[$i];
            if ($reverse) {
                if ($orient eq "horizontal") {
                    $xp1 = $x1 +($x2-$x1)*($axmax-$jd)/($axmax-$axmin);
                    $xp2 = $xp1o = $xp2o = $xp1;
                } else {
                    $yp1 = $y1 +($y2-$y1)*($axmax-$jd)/($axmax-$axmin);
                    $yp2 = $yp1o = $yp2o = $yp1;
                }
            } else {
                if ($orient eq "horizontal") {
                    $xp1 = $x1 +($x2-$x1)*($jd-$axmin)/($axmax-$axmin);
                    $xp2 = $xp1o = $xp2o = $xp1;
                } else {
                    $yp1 = $y1 +($y2-$y1)*($jd-$axmin)/($axmax-$axmin);
                    $yp2 = $yp1o = $yp2o = $yp1;
                }
            }
            if ($grid && $jd > $axmin && $jd < $axmax) {
                if ($orient eq "horizontal") {
                    @coords = ($xp1, $gr1, $xp1, $gr2);
                } else {
                    @coords = ($gr1, $yp1, $gr2, $yp1);
                }
                $canv->create_line(@coords, -fill  => &get_rgb_code($grcolor),
                                            -width => $grwidth,
                                            -arrow => 'none',
                                            -tags  => $gridtags);
            }
            if ($pr_tics ne "none") {
                $canv->create_line($xp1, $yp1, $xp2, $yp2,
                                   -fill  => &get_rgb_code("black"),
                                   -width => 1,
                                   -arrow => 'none',
                                   -tags  => $tags);
            }
            if ($op_tics ne "none") {
                $canv->create_line($xp1o, $yp1o, $xp2o, $yp2o,
                                   -fill  => &get_rgb_code("black"),
                                   -width => 1,
                                   -arrow => 'none',
                                   -tags  => $op_tags);
            }
        }
    }
    if ($minor != 0 && ($pr_tics ne "none" || $op_tics ne "none")) {
        $nt = int(($axmax -$axmin)/$major +0.00001) +1;
        if ($orient eq "horizontal") {
            $add_minor = (abs($x2-$x1)/$nt > 30) ? 1 : 0;
        } else {
            $add_minor = (abs($y2-$y1)/$nt > 30) ? 1 : 0;
        }
        if ($add_minor) {
            if ($reverse) {
                for ($i=$axmax-$major/2.; $i>=$axmin; $i-=$major) {
                    if ($orient eq "horizontal") {
                        $xp4 = $x1 +($x2-$x1)*($axmax-$i)/($axmax-$axmin);
                        $xp5 = $xp4o = $xp5o = $xp4;
                    } else {
                        $yp4 = $y1 +($y2-$y1)*($axmax-$i)/($axmax-$axmin);
                        $yp5 = $yp4o = $yp5o = $yp4;
                    }
                    if ($pr_tics ne "none") {
                        $canv->create_line($xp4, $yp4, $xp5, $yp5,
                                           -fill  => &get_rgb_code("black"),
                                           -width => 1,
                                           -arrow => 'none',
                                           -tags  => $tags);
                    }
                    if ($op_tics ne "none") {
                        $canv->create_line($xp4o, $yp4o, $xp5o, $yp5o,
                                           -fill  => &get_rgb_code("black"),
                                           -width => 1,
                                           -arrow => 'none',
                                           -tags  => $op_tags);
                    }
                }
            } else {
                for ($i=$axmin+$major/2.; $i<=$axmax; $i+=$major) {
                    if ($orient eq "horizontal") {
                        $xp4 = $x1 +($x2-$x1)*($i-$axmin)/($axmax-$axmin);
                        $xp5 = $xp4o = $xp5o = $xp4;
                    } else {
                        $yp4 = $y1 +($y2-$y1)*($i-$axmin)/($axmax-$axmin);
                        $yp5 = $yp4o = $yp5o = $yp4;
                    }
                    if ($pr_tics ne "none") {
                        $canv->create_line($xp4, $yp4, $xp5, $yp5,
                                           -fill  => &get_rgb_code("black"),
                                           -width => 1,
                                           -arrow => 'none',
                                           -tags  => $tags);
                    }
                    if ($op_tics ne "none") {
                        $canv->create_line($xp4o, $yp4o, $xp5o, $yp5o,
                                           -fill  => &get_rgb_code("black"),
                                           -width => 1,
                                           -arrow => 'none',
                                           -tags  => $op_tags);
                    }
                }
            }
        }
    }
    for ($i=0; $i<=$#tick_jd2; $i++) {
        $jd    = $tick_jd2[$i];
        $label = $tick_labels2[$i];
        $d3    = ($pr_tics =~ /inside|none/) ? 6 : 0;
        if ($reverse) {
            if ($orient eq "horizontal") {
                $xp3 = $x1 +($x2-$x1)*($axmax-$jd)/($axmax-$axmin);
                $yp3 = ($side eq "bottom") ? $y1+9+$tsize+$xtra-$d3 : $y1-9-$tsize-$xtra+$d3;
            } else {
                $yp3 = $y1 +($y2-$y1)*($axmax-$jd)/($axmax-$axmin);
                $xp3 = ($side eq "left") ? $x1-12-$tsize+$d3 : $x1+12+$tsize-$d3;
            }
        } else {
            if ($orient eq "horizontal") {
                $xp3 = $x1 +($x2-$x1)*($jd-$axmin)/($axmax-$axmin);
                $yp3 = ($side eq "bottom") ? $y1+9+$tsize+$xtra-$d3 : $y1-9-$tsize-$xtra+$d3;
            } else {
                $yp3 = $y1 +($y2-$y1)*($jd-$axmin)/($axmax-$axmin);
                $xp3 = ($side eq "left") ? $x1-12-$tsize+$d3 : $x1+12+$tsize-$d3;
            }
        }
        $canv->create_text($xp3, $yp3,
                           -anchor => $anc,
                           -text   => $label,
                           -fill   => &get_rgb_code("black"),
                           -angle  => $ang,
                           -tags   => $tags,
                           -font   => [-family     => $family,
                                       -size       => $title_size,
                                       -weight     => $title_weight,
                                       -slant      => 'roman',
                                       -underline  => 0,
                                       -overstrike => 0,
                                      ]);
    }
    if ($title ne "" && $fmt ne "Mon-DD-YYYY") {
        $tags .= "Title";
        $d3    = ($pr_tics =~ /inside|none/) ? 6 : 0;
        if ($orient eq "horizontal") {
            $xp1 = ($x1+$x2)/2.;
            $ang = 0;
            $yp1 = ($side eq "bottom") ? $y1+9+$tsize+$xtra-$d3 : $y1-9-$tsize-$xtra+$d3;
            $anc = ($side eq "bottom") ? 'n' : 's';
        } else {
            $yp1 = ($y1+$y2)/2.;
            $anc = 's';
            $xp1 = ($side eq "left") ? $x1-12-$tsize+$d3 : $x1+12+$tsize-$d3;
            $ang = ($side eq "left") ? 90 : 270;
        }
        $canv->create_text($xp1, $yp1,
                           -anchor => $anc,
                           -text   => $title,
                           -fill   => &get_rgb_code("black"),
                           -angle  => $ang,
                           -tags   => $tags,
                           -font   => [-family     => $family,
                                       -size       => $title_size,
                                       -weight     => $title_weight,
                                       -slant      => 'roman',
                                       -underline  => 0,
                                       -overstrike => 0,
                                      ]);
    }
}


sub find_axis_limits {
    my ($axmin, $axmax) = @_;
    my (
        $i, $last_major, $last_ratio, $major, $power, $range, $ratio, $val,
        @mult,
       );

    @mult = (1, 2, 2.5, 3, 4, 5, 6, 7, 7.5, 8, 9, 10, 20, 25, 30, 40, 50);

    $axmin = 0. if ($axmin > 0 && $axmin < $axmax *0.2);
    $range = $axmax -$axmin;
    if ($range == 0.) {
        if ($axmin >= 0. && $axmin < 0.5) {
            $axmin = 0.0;
            $axmax = 1.0;
        } else {
            $axmin -= 0.5;
            $axmax += 0.5;
        }
        $major = 0.5;
        return ($axmin, $axmax, $major);
    }
    $power = &floor(&log10($range)) -1;
    $major = $mult[0] *(10**$power);
    $ratio = $range /$major;
    for ($i=1; $i<=$#mult; $i++) {
        $last_major = $major;
        $last_ratio = $ratio;
        $major = $mult[$i] *(10**$power);
        $ratio = $range /$major;
        if ($ratio < 5) {
            if (abs($ratio -5) < abs($last_ratio -5)) {
                last;
            } else {
                $major = $last_major;
                last;
            }
        }
    }
    $val = 0.;
    if ($axmin < 0) {
        while ($val > $axmin) {
            $val -= $major;
        }
    } else {
        while ($val +$major <= $axmin) {
            $val += $major;
        }
    }
    $axmin = $val;
    $val = 0.;
    if ($axmax < 0) {
        while ($val -$major >= $axmax) {
            $val -= $major;
        }
    } else {
        while ($val < $axmax) {
            $val += $major;
        }
    }
    $axmax = $val;

    return ($axmin, $axmax, $major);
}


sub make_color_key {
    my ($canv, %key_props) = @_;
    my (
        $ch, $clabel, $cmax, $cmin, $cw, $digits, $fmt, $fmt_w, $font,
        $i, $inc, $j, $range, $size1, $size2, $tag1, $tag2, $tags, $title,
        $weight1, $weight2, $xleg, $yleg, $ypos,

        @color, @scale,
       );

    $xleg    = $key_props{xleg};
    $yleg    = $key_props{yleg};
    $cw      = $key_props{width};
    $ch      = $key_props{height};
    $title   = $key_props{title};
    $font    = $key_props{font};
    $size1   = $key_props{size1};
    $size2   = $key_props{size2};
    $weight1 = $key_props{weight1};
    $weight2 = $key_props{weight2};
    $digits  = $key_props{digits};
    $tags    = $key_props{tags};
    @color   = @{ $key_props{colors} };
    @scale   = @{ $key_props{scale} };
    $range   = abs($scale[$#scale] -$scale[0]);

    if (defined($key_props{major}) && $key_props{major} ne "auto" && $key_props{major} ne "") {
        $inc = $key_props{major};
        if ($inc <= 0) {
            $inc = "auto";
        } elsif ($inc > $range) {
            $inc = $range;
        }
    } else {
        $inc = "auto";
    }

#   Format the scale numbers for display
    $fmt_w = length(int(&max(abs($scale[0]),abs($scale[$#scale]))));
    $fmt_w++ if ($scale[0] < 0 || $scale[$#scale] < 0);
    if ($digits > 0) {
        $fmt_w += $digits +1;
        $fmt = "%${fmt_w}.${digits}f";
    } else {
        $fmt = "%${fmt_w}d";
    }

#   Draw the color key
    for ($i=0; $i<=$#color; $i++) {
        $j = $#color -$i;
        $canv->create_rectangle($xleg, $yleg+$ch*$i, $xleg+$cw, $yleg+$ch*($i+1),
                         -outline => "",
                         -width   => 0,
                         -fill    => $color[$j],
                         -tags    => $tags);
    }

#   Add the numeric color labels
    if ($inc eq "auto") {
        for ($i=0; $i<=$#scale; $i++) {
            $scale[$i] = sprintf($fmt, $scale[$i]);
        }
        $inc = int($size1 /&max(1,$ch-2)) +1;
        for ($i=0; $i<=$#color+1; $i+=$inc) {
            $j = $#color +1 -$i;
            $canv->create_text($xleg+$cw+4, $yleg+$ch*$i,
                               -anchor  => 'w',
                               -text    => $scale[$j],
                               -fill    => &get_rgb_code("black"),
                               -angle   => 0,
                               -tags    => $tags,
                               -font    => [-family     => $font,
                                            -size       => $size1,
                                            -weight     => $weight1,
                                            -slant      => 'roman',
                                            -underline  => 0,
                                            -overstrike => 0,
                                           ]);
        }
    } else {
        $cmin = sprintf($fmt, $scale[0]);
        $cmax = sprintf($fmt, $scale[$#scale]);
        for ($i=$cmax; $i>=$cmin-0.000001; $i-=$inc) {
            $i = 0.0 if (abs($cmax-$cmin) > 0.00001 && abs($i) <= 0.000001);
            $clabel = sprintf($fmt, $i);
            $ypos = $yleg +$ch*($#color+1)*($cmax-$i)/$range;
            $canv->create_text($xleg+$cw+4, $ypos,
                               -anchor  => 'w',
                               -text    => $clabel,
                               -fill    => &get_rgb_code("black"),
                               -angle   => 0,
                               -tags    => $tags,
                               -font    => [-family     => $font,
                                            -size       => $size1,
                                            -weight     => $weight1,
                                            -slant      => 'roman',
                                            -underline  => 0,
                                            -overstrike => 0,
                                           ]);
        }
    }

#   Add the color key title
    if ($title ne "") {
        $tags .= "Title";
        $canv->create_text($xleg-5, $yleg+0.5*$ch*($#color+1),
                           -anchor  => 's',
                           -justify => 'center',
                           -text    => $title,
                           -fill    => &get_rgb_code("black"),
                           -angle   => 90,
                           -tags    => $tags,
                           -font    => [-family     => $font,
                                        -size       => $size2,
                                        -weight     => $weight2,
                                        -slant      => 'roman',
                                        -underline  => 0,
                                        -overstrike => 0,
                                       ]);
        ($tag1 = $tags) =~ s/.* //;
        $tag2 = substr($tag1,0,-5);
        $canv->addtag($tag2, withtag => $tag1);
    }
}


sub make_ts_legend {
    my ($canv, %legend_props) = @_;
    my (
        $box_tags, $edge, $edgec, $esize, $eweight, $fill, $fillc, $font,
        $leg_tag, $n, $ne, $tag, $tags, $title, $tsize, $tweight, $xpos,
        $ypos,
        @coords, @entries, @taglist,
       );

    $ne      = $legend_props{num};
    $xpos    = $legend_props{xpos};
    $ypos    = $legend_props{ypos};
    $title   = $legend_props{title};
    $font    = $legend_props{font};
    $esize   = $legend_props{esize};
    $tsize   = $legend_props{tsize};
    $eweight = $legend_props{eweight};
    $tweight = $legend_props{tweight};
    $edge    = $legend_props{edge};      # border: 0 = off, 1 = on
    $edgec   = $legend_props{edgec};     # border color
    $fill    = $legend_props{fill};      # fill: 0 = off, 1 = on
    $fillc   = $legend_props{fillc};     # fill color
    $tags    = $legend_props{tags};
    @entries = @{ $legend_props{entries} };

    $box_tags = $tags;
    @taglist = split(/ /, $box_tags);
    foreach $tag (@taglist) {
        if ($tag =~ /_legend$/) {
            $box_tags .= " " . $tag . "Box";
            $leg_tag   = $tag;
            last;
        }
    }

#   Create legend title
    if ($title ne "") {
        $canv->create_text($xpos, $ypos,
                           -anchor => 'w',
                           -text   => $title,
                           -fill   => &get_rgb_code("black"),
                           -angle  => 0,
                           -tags   => $tags,
                           -font   => [-family     => $font,
                                       -size       => $tsize,
                                       -weight     => $tweight,
                                       -slant      => 'roman',
                                       -underline  => 0,
                                       -overstrike => 0,
                                      ]);
        $ypos += $tsize *1.5;
    }

#   Create legend entries
    for ($n=0; $n<$ne; $n++) {
        $canv->create_line($xpos, $ypos, $xpos+20, $ypos,
                           -fill   => &get_rgb_code($entries[$n]{color}),
                           -width  => $entries[$n]{width},
                           -arrow  => 'none',
                           -tags   => $tags);
        $canv->create_text($xpos+25, $ypos,
                           -anchor => 'w',
                           -text   => $entries[$n]{text},
                           -fill   => &get_rgb_code("black"),
                           -angle  => 0,
                           -tags   => $tags,
                           -font   => [-family     => $font,
                                       -size       => $esize,
                                       -weight     => $eweight,
                                       -slant      => 'roman',
                                       -underline  => 0,
                                       -overstrike => 0,
                                      ]);
        $ypos += $esize *1.5;
    }

#   Create legend outline and fill, if requested
    if ((($edge && $edgec ne "") || ($fill && $fillc ne "")) && ($title ne "" || $ne > 0)) {
        @coords = Tkx::SplitList($canv->bbox($leg_tag));
        $coords[0] -= 5;
        $coords[1] -= 4;
        $coords[2] += 5;
        $coords[3] += 4;
        if ($edge && $edgec ne "" && $fill && $fillc ne "") {
            $canv->create_rectangle(@coords,
                           -outline => &get_rgb_code($edgec),
                           -width   => 1,
                           -fill    => &get_rgb_code($fillc),
                           -tags    => $box_tags);
        } elsif ($edge && $edgec ne "") {
            $canv->create_rectangle(@coords,
                           -outline => &get_rgb_code($edgec),
                           -width   => 1,
                           -fill    => "",
                           -tags    => $box_tags);
        } else {
            $canv->create_rectangle(@coords,
                           -outline => "",
                           -width   => 0,
                           -fill    => &get_rgb_code($fillc),
                           -tags    => $box_tags);
        }
    }
}


sub update_legend_box {
    my ($canv, $id) = @_;
    my (
        $box_exists, $box_tags, $edge, $edgec, $fill, $fillc, $gtag,
        $item, $legend_exists,
        @coords, @items, @taglist,
       );

    $edge  = $gr_props{$id}{le_edge};
    $edgec = $gr_props{$id}{le_edgec};
    $fill  = $gr_props{$id}{le_fill};
    $fillc = $gr_props{$id}{le_fillc};

    return if ((! $edge || $edgec eq "") && (! $fill || $fillc eq ""));

    $gtag = "graph" . $id;
    $legend_exists = $box_exists = 0;

    @items = Tkx::SplitList($canv->find_withtag($gtag . "_legend"));
    foreach $item (@items) {
        @taglist = Tkx::SplitList($canv->gettags($item));
        if (&list_search($gtag . "_legendBox", @taglist) >= 0) {
            $box_exists = 1;
            next;
        }
        $legend_exists = 1;
        $canv->addtag('group_legend', withtag => $item);
    }
    return if (! $legend_exists);

    @coords = Tkx::SplitList($canv->bbox('group_legend'));
    $canv->dtag('group_legend');
    $coords[0] -= 5;
    $coords[1] -= 4;
    $coords[2] += 5;
    $coords[3] += 4;
    if ($box_exists) {
        $canv->coords($gtag . "_legendBox", @coords);
    } else {
        $box_tags = $gtag . " " . $gtag . "_legend" . " " . $gtag . "_legendBox";
        if ($edge && $edgec ne "" && $fill && $fillc ne "") {
            $canv->create_rectangle(@coords,
                           -outline => &get_rgb_code($edgec),
                           -width   => 1,
                           -fill    => &get_rgb_code($fillc),
                           -tags    => $box_tags);
        } elsif ($edge && $edgec ne "") {
            $canv->create_rectangle(@coords,
                           -outline => &get_rgb_code($edgec),
                           -width   => 1,
                           -fill    => "",
                           -tags    => $box_tags);
        } else {
            $canv->create_rectangle(@coords,
                           -outline => "",
                           -width   => 0,
                           -fill    => &get_rgb_code($fillc),
                           -tags    => $box_tags);
        }
    }
}


sub image_put_color {
    my ($image, $cshade, $xp1, $yp1, $xp2, $yp2) = @_;
    my ($cvert, $xp, $yp, @cdata);

#   Single rows or columns won't plot with 4-arg -to option.
    if ($xp1 != $xp2 && $yp1 != $yp2) {
        $image->put($cshade, -to => $xp1, $yp1, $xp2, $yp2);

    } elsif ($xp1 != $xp2) {
        @cdata    = ();
        $cdata[0] = $cshade;
        if ($xp2 > $xp1) {
            for ($xp=$xp1+1; $xp<=$xp2; $xp++) {
                $cdata[0] .= " " . $cshade;
            }
            $image->put([ @cdata ], -to => $xp1, $yp1);  # horizontal line
        } else {
            for ($xp=$xp2+1; $xp<=$xp1; $xp++) {
                $cdata[0] .= " " . $cshade;
            }
            $image->put([ @cdata ], -to => $xp2, $yp1);  # horizontal line
        }
    } elsif ($yp1 != $yp2) {
        $cvert = $cshade;
        if ($yp2 > $yp1) {
            for ($yp=$yp1+1; $yp<=$yp2; $yp++) {
                $cvert .= " " . $cshade;
            }
            $image->put($cvert, -to => $xp1, $yp1);      # vertical line
        } else {
            for ($yp=$yp2+1; $yp<=$yp1; $yp++) {
                $cvert .= " " . $cshade;
            }
            $image->put($cvert, -to => $xp1, $yp2);      # vertical line
        }
    } else {
        $image->put($cshade, -to => $xp1, $yp1);         # single point
    }
    return $image;
}


sub paint_slice_cell {
    my ($image, $cshade, $ih, $dy_full, $xflip, $xp1, $yp1, $xp2, $yp2) = @_;
    my ($cvert, $dy, $xp, $yp, $yp1r, $yp2r, $yp_start);

#   If slope is insignificant, just paint the rectangular cell
    if (&round_to_int($yp1+0.5*$dy_full) == &round_to_int($yp1-0.5*$dy_full) &&
        &round_to_int($yp2+0.5*$dy_full) == &round_to_int($yp2-0.5*$dy_full)) {
        $yp1r  = &max(0, &min($ih-1, &round_to_int($yp1)));
        $yp2r  = &max(0, &min($ih-1, &round_to_int($yp2)));
        $image = &image_put_color($image, $cshade, $xp1, $yp1r, $xp2, $yp2r);

#   Slope is noticeable.
#   Single columns won't plot with 4-arg -to option. Plot vertical lines for each x.
    } else {
        if ($xflip) {
            for ($xp=$xp2; $xp<=$xp1; $xp++) {
                $dy    = $dy_full*(($xp-$xp2)/($xp1-$xp2) -0.5);
                $yp1r  = &round_to_int($yp1+$dy);
                $yp2r  = &round_to_int($yp2+$dy);
                $cvert = "";
                for ($yp=$yp1r; $yp<=$yp2r; $yp++) {
                    next if ($yp < 0 || $yp > $ih-1);
                    if ($cvert eq "") {
                        $yp_start = $yp;
                        $cvert    = $cshade;
                    } else {
                        $cvert .= " " . $cshade;
                    }
                }
                if ($cvert ne "") {
                    $image->put($cvert, -to => $xp, $yp_start);
                }
            }
        } else {
            for ($xp=$xp1; $xp<=$xp2; $xp++) {
                $dy    = $dy_full*(($xp-$xp1)/($xp2-$xp1) -0.5);
                $yp1r  = &round_to_int($yp1-$dy);
                $yp2r  = &round_to_int($yp2-$dy);
                $cvert = "";
                for ($yp=$yp1r; $yp<=$yp2r; $yp++) {
                    next if ($yp < 0 || $yp > $ih-1);
                    if ($cvert eq "") {
                        $yp_start = $yp;
                        $cvert    = $cshade;
                    } else {
                        $cvert .= " " . $cshade;
                    }
                }
                if ($cvert ne "") {
                    $image->put($cvert, -to => $xp, $yp_start);
                }
            }
        }
    }
    return $image;
}


################################################################################
#
# Date calculations
#
################################################################################

sub rebuild_datelist {
    my ($honor_global_limits) = @_;
    my ($dt, $first, $i, $id, $w2profile_present,
        @mydates, @slice_data,
        %pdata,
       );

    $honor_global_limits = 1 if (! defined($honor_global_limits) || $honor_global_limits eq ""
                                                                 || $honor_global_limits ne "0");
    $w2profile_present = 0;

#   Remove animation toolbar, because the number of frames may change
    if (defined($animate_tb) && Tkx::winfo_exists($animate_tb)) {
        if ($animate_tb->g_wm_title() eq "Animation toolbar") {
            $animate_tb->g_destroy();
            undef $animate_tb;
        }
    }
    $status_line = "Rebuilding animation dates list...";
    Tkx::update_idletasks();

#   Save the current date, and rebuild the dates array
    $dt    = $dates[$dti-1];
    @dates = ();
    $first = 1;
    for ($i=0; $i<=$#animate_ids; $i++) {
        $id = $animate_ids[$i];
        next if ($props{$id}{meta}
                     !~ /^(data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)$/);

        if ($props{$id}{meta} =~ /data_profile|vert_wd_zone/) {
            %pdata = %{ $gr_props{$id}{pdata} };

        } elsif ($props{$id}{meta} eq "w2_profile") {
            %pdata = %{ $gr_props{$id}{parm_data} };
            $w2profile_present = 1;

        } elsif ($props{$id}{meta} eq "w2_slice") {
            @slice_data = @{ $gr_props{$id}{slice_data} };
            %pdata      = %{ $slice_data[0] };

        } elsif ($props{$id}{meta} eq "w2_outflow") {
            %pdata = %{ $gr_props{$id}{qdata} };

        } elsif ($props{$id}{meta} eq "w2_wlevels") {
            %pdata = %{ $gr_props{$id}{wl_data} };
        }
        @mydates = sort keys %pdata;
        if ($first) {
            @dates = @mydates;
            $first = 0;
        } else {
            @dates = &merge_dates(\@dates, \@mydates);
        }
        undef %pdata;
    }
    if ($global_dt_limits && $honor_global_limits) {     # Truncate date range if global limits
        @dates = &truncate_dates($global_dt_begin, $global_dt_end, @dates);
    }
    $status_line = "";

#   Reset the date indices
    $dti_max = $#dates+1;
    $dti     = 1 + &nearest_dt_index($dt, @dates);
    $dti++ if ($dti == 0);
    $dti_old = $dti;
    $delta_dti = 1;

#   Rebuild the profile dates list
    &build_profile_match_list();
}


sub build_profile_match_list {
    my ($match_id) = @_;
    my (
        $data_daily, $dt, $dt2, $dt_ref, $dt_ref2, $dt_w2p, $got_depth,
        $i, $id, $indx, $j, $lastpt, $match, $match_id_dates, $mi, $npts,
        $ref_daily, $surf_elev, $tol,

        @depths, @elevations, @keys_ref, @pdata, @pt_elevations, @tmp, @uniq,

        %elev_data, %ref_data, %ref_profile, %seen, %wsurf,
       );

    $match_id        = 0 if (! defined($match_id) || $match_id eq "");
    $match_id_dates  = 0;
    $w2profile_data  = 0;
    @dtis_with_pdata = ();
    @tmp             = ();

    return 0 if (! defined($dates[0]));
    $data_daily  = (length($dates[0]) == 12) ? 0 : 1;
    $status_line = "Finding dates with profiles...";
    Tkx::update_idletasks();

    for ($i=0; $i<=$#animate_ids; $i++) {
        $id = $animate_ids[$i];
        next if ($props{$id}{meta} ne "w2_profile");
        next if (! defined($props{$id}{ref_file}));
        next if (! -e $props{$id}{ref_file});
        next if ($props{$id}{ref_hide});

#       Get the modeled water-surface elevation data
        %elev_data = %{ $gr_props{$id}{elev_data} };

#       Get the data and some parameters for the reference profile
        $tol         = $props{$id}{ref_tol};
        %ref_profile = %{ $gr_props{$id}{ref_data} };
        %ref_data    = %{ $ref_profile{pdata}      };
        @keys_ref    = keys %ref_data;
        $ref_daily   = (length($keys_ref[0]) == 12) ? 0 : 1;
        %wsurf       = %{ $ref_profile{ws_elev} };
        $got_depth   = ($ref_profile{elv_dep} eq "elevation") ? 0 : 1;
        if ($got_depth) {
            @depths = @{ $ref_profile{depths} };
            $lastpt = $#depths;
        } else {
            @elevations    = @{ $ref_profile{elevations} };
            $lastpt        = $#elevations;
            @pt_elevations = ();
            for ($j=0; $j<=$lastpt; $j++) {
                push (@pt_elevations, $elevations[$j]);
            }
        }

        for ($indx=1; $indx<=$#dates+1; $indx++) {
            $dt = $dt_w2p = $dt_ref = $dates[$indx-1];

#           Check first to see if W2 modeled profile data exist for this date
            if (! defined($elev_data{$dt})) {
                for ($mi=1; $mi<=10; $mi++) {
                    $dt2 = &adjust_dt($dt, $mi);
                    if (defined($elev_data{$dt2})) {
                        $dt_w2p = $dt2;
                        last;
                    }
                    $dt2 = &adjust_dt($dt, -1 *$mi);
                    if (defined($elev_data{$dt2})) {
                        $dt_w2p = $dt2;
                        last;
                    }
                }
                next if (! defined($elev_data{$dt_w2p}));
            }

#           Now check to see if reference data exist for this date
            $match = 0;
            if ($data_daily != $ref_daily) {
                if ($ref_daily) {
                    $dt_ref = &nearest_daily_dt($dt);
                    $match  = 1 if (defined($ref_data{$dt_ref}) &&
                                    &get_dt_diff($dt, 10000*$dt_ref) <= $tol);
                } else {
                    $dt_ref .= "0000";
                }
            }
            if (defined($ref_data{$dt_ref})) {
                $match = 1;
            } else {
                next if (($data_daily && $ref_daily) || $tol == 0);
                for ($mi=1; $mi<=$tol; $mi++) {
                    $dt_ref2 = &adjust_dt($dt_ref, $mi);
                    if (defined($ref_data{$dt_ref2})) {
                        $dt_ref = $dt_ref2;
                        $match  = 1;
                        last;
                    }
                    $dt_ref2 = &adjust_dt($dt_ref, -1 *$mi);
                    if (defined($ref_data{$dt_ref2})) {
                        $dt_ref = $dt_ref2;
                        $match  = 1;
                        last;
                    }
                }
            }

#           Dates match.  Check to ensure that sufficient reference profile data exist.
            if ($match) {
                if (defined($wsurf{$dt_ref}) && $wsurf{$dt_ref} ne "na") {
                    $surf_elev = $wsurf{$dt_ref};
                } else {
                    $surf_elev = $elev_data{$dt_w2p};
                }
                if ($got_depth) {
                    @pt_elevations = ();
                    for ($j=0; $j<=$lastpt; $j++) {
                        push (@pt_elevations, $surf_elev -$depths[$j]);
                    }
                }
                @pdata = @{ $ref_data{$dt_ref} };
                $npts  = 0;
                for ($j=0; $j<=$lastpt; $j++) {
                    next if ($pdata[$j] eq "na");
                    next if ($pt_elevations[$j] > $surf_elev +0.1/3.28084);
                    $npts++;
                    last if ($npts > 1);
                }
                if ($npts > 1) {
                    push (@tmp, $indx);
                    $match_id_dates++ if ($id == $match_id);
                }
            }
        }
        undef %ref_profile;
        undef %ref_data;
        undef %elev_data;
        undef %wsurf;
        undef @keys_ref;
        undef @pdata;
    }

#   Remove duplicates
    %seen = ();
    @uniq = ();
    if ($#tmp >= 0) {
        @uniq = grep { ! $seen{ $_ }++ } @tmp;  # use hash and grep to find unique array members
    }

#   Set global variables
    if ($#uniq >= 0) {
        $w2profile_data  = 1;
        @dtis_with_pdata = sort numerically @uniq;
    } else {
        $w2profile_data  = 0;
        @dtis_with_pdata = ();
    }
    $status_line = "";
    Tkx::update_idletasks();
    return $match_id_dates;
}


sub build_matrix_match_list {
    my ($id) = @_;
    my (
        $check_dt, $data_daily, $dt, $dt2, $dt_ref, $dt_ref2, $dt_w2p,
        $got_depth, $i, $indx, $lastpt, $match, $mi, $npts, $ref_daily,
        $surf_elev, $tol,

        @depths, @elevations, @keys_ref, @matrix_datelist, @pdata,
        @pt_elevations, @w2_dates,

        %elev_data, %ref_data, %ref_profile, %wsurf,
       );

    @matrix_datelist = ();

#   Get the modeled water-surface elevation data and the dates for those data
    %elev_data  = %{ $gr_props{$id}{elev_data} };

#   Set the dates to search.  If the global dates array exists, use it.
    if (@animate_ids && $#animate_ids >= 0 && defined($dates[0])) {
        @w2_dates = @dates;
        $check_dt = 1;
    } else {
        @w2_dates = sort numerically keys %elev_data;
        $check_dt = 0;
    }
    $data_daily = (length($w2_dates[0]) == 12) ? 0 : 1;

#   Get the data and some parameters for the reference profile
    $tol         = $props{$id}{ref_tol};
    %ref_profile = %{ $gr_props{$id}{ref_data} };
    %ref_data    = %{ $ref_profile{pdata}      };
    @keys_ref    = keys %ref_data;
    $ref_daily   = (length($keys_ref[0]) == 12) ? 0 : 1;
    %wsurf       = %{ $ref_profile{ws_elev} };
    $got_depth   = ($ref_profile{elv_dep} eq "elevation") ? 0 : 1;
    if ($got_depth) {
        @depths = @{ $ref_profile{depths} };
        $lastpt = $#depths;
    } else {
        @elevations    = @{ $ref_profile{elevations} };
        $lastpt        = $#elevations;
        @pt_elevations = ();
        for ($i=0; $i<=$lastpt; $i++) {
            push (@pt_elevations, $elevations[$i]);
        }
    }

#   Loop over the modeled dates looking for measured profile matches
    for ($indx=0; $indx<=$#w2_dates; $indx++) {
        $dt = $dt_w2p = $dt_ref = $w2_dates[$indx];

#       Check first to see if W2 modeled profile data exist for this date
        if ($check_dt && ! defined($elev_data{$dt})) {
            for ($mi=1; $mi<=10; $mi++) {
                $dt2 = &adjust_dt($dt, $mi);
                if (defined($elev_data{$dt2})) {
                    $dt_w2p = $dt2;
                    last;
                }
                $dt2 = &adjust_dt($dt, -1 *$mi);
                if (defined($elev_data{$dt2})) {
                    $dt_w2p = $dt2;
                    last;
                }
            }
            next if (! defined($elev_data{$dt_w2p}));
        }

#       Now check to see if reference data exist for this date
        $match = 0;
        if ($data_daily != $ref_daily) {
            if ($ref_daily) {
                $dt_ref = &nearest_daily_dt($dt);
                $match  = 1 if (defined($ref_data{$dt_ref}) &&
                                &get_dt_diff($dt, 10000*$dt_ref) <= $tol);
            } else {
                $dt_ref .= "0000";
            }
        }
        if (defined($ref_data{$dt_ref})) {
            $match = 1;
        } else {
            next if (($data_daily && $ref_daily) || $tol == 0);
            for ($mi=1; $mi<=$tol; $mi++) {
                $dt_ref2 = &adjust_dt($dt_ref, $mi);
                if (defined($ref_data{$dt_ref2})) {
                    $dt_ref = $dt_ref2;
                    $match  = 1;
                    last;
                }
                $dt_ref2 = &adjust_dt($dt_ref, -1 *$mi);
                if (defined($ref_data{$dt_ref2})) {
                    $dt_ref = $dt_ref2;
                    $match  = 1;
                    last;
                }
            }
        }

#       Dates match.  Check to ensure that sufficient reference profile data exist.
        if ($match) {
            if (defined($wsurf{$dt_ref}) && $wsurf{$dt_ref} ne "na") {
                $surf_elev = $wsurf{$dt_ref};
            } else {
                $surf_elev = $elev_data{$dt_w2p};
            }
            if ($got_depth) {
                @pt_elevations = ();
                for ($i=0; $i<=$lastpt; $i++) {
                    push (@pt_elevations, $surf_elev -$depths[$i]);
                }
            }
            @pdata = @{ $ref_data{$dt_ref} };
            $npts  = 0;
            for ($i=0; $i<=$lastpt; $i++) {
                next if ($pdata[$i] eq "na");
                next if ($pt_elevations[$i] > $surf_elev +0.1/3.28084);
                $npts++;
                last if ($npts > 1);
            }
            push (@matrix_datelist, $dt) if ($npts > 1);
        }
    }
    undef %ref_profile;
    undef %ref_data;
    undef %elev_data;
    undef %wsurf;
    undef @keys_ref;
    undef @w2_dates;
    undef @pdata;

    return @matrix_datelist;
}


sub set_global_date_limits {
    my ($X, $Y) = @_;
    my (
        $align_btn, $align_slices, $bd_narrow, $bdate_frame, $bday,
        $bday_cb, $bday_sav, $bm, $bm_narrow, $bmon, $bmon_cb, $bmon_sav,
        $by_narrow, $byr, $byr_cb, $byr_sav, $cancel_btn, $d, $dt_max,
        $dt_min, $ed_narrow, $edate_frame, $eday, $eday_cb, $eday_sav,
        $em, $em_narrow, $emon, $emon_cb, $emon_sav, $ey_narrow, $eyr,
        $eyr_cb, $eyr_sav, $f, $f2, $fr, $fr_row, $frame, $geom, $got_slice,
        $got_slice_limits, $id, $limit_dates, $limits_frame, $m, $max_dtmin,
        $min_dtmax, $narrow, $narrow_btn, $nobj, $ok_btn, $rm_slice_limits,
        $row, $row2, $sc_canv, $sc_fr, $txt, $type, $vscroll, $y, $yr_max,
        $yr_min,

        %date_max, %date_min,
       );

    if ($X == 0) {
        (undef, $X, $Y) = split(/\+/, $main->g_wm_geometry());
        $X += 100;
        $Y += 100;
    }
    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($date_limits_menu) && Tkx::winfo_exists($date_limits_menu)) {
        if ($date_limits_menu->g_wm_title() eq "Global Date Limits") {
            $date_limits_menu->g_destroy();
            undef $date_limits_menu;
        }
    }
    $date_limits_menu = $main->new_toplevel();
    $date_limits_menu->g_wm_transient($main);
    $date_limits_menu->g_wm_title("Global Date Limits");
    $date_limits_menu->configure(-cursor => $cursor_norm);
    $date_limits_menu->g_wm_geometry($geom);

#   Try to keep any objects from being selected. Reset bindings later.
    $canvas->g_bind("<Motion>", "");

#   Set some variables
    %date_min  = %date_max = ();
    $dt_min    = $dt_max   = $max_dtmin = $min_dtmax = -999;
    $narrow    = $nobj     = 0;
    $got_slice = $align_slices = $got_slice_limits = $rm_slice_limits = 0;

    if ($global_dt_limits && $global_dt_begin =~ /^[12][0-9][0-9][0-9][01][0-9][0-3][0-9]0000$/
                          && $global_dt_end   =~ /^[12][0-9][0-9][0-9][01][0-9][0-3][0-9]0000$/) {
        $limit_dates       = $global_dt_limits;
    } else {
        $limit_dates     = $global_dt_limits = 0;
        $global_dt_begin = $global_dt_end    = "na";
    }

    foreach $id (@animate_ids) {
        if ($props{$id}{meta} =~ /^(data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)$/) {
            $date_min{$id} = $gr_props{$id}{date_min};
            $date_max{$id} = $gr_props{$id}{date_max};
            if ($date_min{$id} != -999) {
                $dt_min        = $date_min{$id} if ($dt_min    == -999 || $dt_min    > $date_min{$id});
                $max_dtmin     = $date_min{$id} if ($max_dtmin == -999 || $max_dtmin < $date_min{$id});
                ($m, $d, $y)   = &parse_date($date_min{$id}, 1);
                $date_min{$id} = sprintf("%s-%02d-%04d", $mon_names[$m-1], $d, $y);
            }
            if ($date_max{$id} != -999) {
                $dt_max        = $date_max{$id} if ($dt_max    == -999 || $dt_max    < $date_max{$id});
                $min_dtmax     = $date_max{$id} if ($min_dtmax == -999 || $min_dtmax > $date_max{$id});
                ($m, $d, $y)   = &parse_date(&jdate2date(&ceil(&date2jdate($date_max{$id}))), 1);
                $date_max{$id} = sprintf("%s-%02d-%04d", $mon_names[$m-1], $d, $y);
            }
            if ($props{$id}{meta} eq "w2_slice") {
                $got_slice = 1;
                $got_slice_limits = 1 if ($props{$id}{dt_limits});
            }
            $nobj++;
        }
    }

#   Saved dates. _sav = initial; _narrow = minimum
    ($bm_narrow, $bd_narrow, $by_narrow) = &parse_date($max_dtmin, 1);
    ($em_narrow, $ed_narrow, $ey_narrow) = &parse_date(&jdate2date(&ceil(&date2jdate($min_dtmax))), 1);
    $bd_narrow += 0;
    $ed_narrow += 0;
    $bm_narrow  = $mon_names[$bm_narrow-1];
    $em_narrow  = $mon_names[$em_narrow-1];

    if ($limit_dates) {
        ($bm, $bday, $byr) = &parse_date($global_dt_begin, 1);
        ($em, $eday, $eyr) = &parse_date(&jdate2date(&ceil(&date2jdate($global_dt_end))),   1);
    } else {
        ($bm, $bday, $byr) = &parse_date($dt_min, 1);
        ($em, $eday, $eyr) = &parse_date(&jdate2date(&ceil(&date2jdate($dt_max))), 1);
    }
    $bday += 0;
    $eday += 0;
    $bm--;
    $em--;
    $bmon     = $mon_names[$bm];
    $emon     = $mon_names[$em];
    $bmon_sav = $bmon;
    $bday_sav = $bday;
    $byr_sav  = $byr;
    $emon_sav = $emon;
    $eday_sav = $eday;
    $eyr_sav  = $eyr;

    $yr_max = (localtime(time))[5] +1900;
    $yr_min = $yr_max -25;
    $yr_min = &min($yr_min, $by_narrow, $byr);
    $yr_max = &min($yr_max, $ey_narrow, $eyr);

#   Build the menu.
    $frame = $date_limits_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -command => sub { my (
                                  $anim_tb, $begin_jd, $dt, $dt_begin, $dt_end, $dt1, $dt2,
                                  $first_jd, $first_slice_dt, $height, $hr, $jd_offset, $jd1,
                                  $jd2, $last_jd, $last_slice_dt, $m, $maxrow, $mi, $n, $pbar,
                                  $pbar_img, $pbar_win, $pos, $result, $sav_dti, $width, $X, $Y,

                                  @cpl_files, @labels, @msgs, @sav_dates, @wbs,
                                  %parms,
                                 );

                              @msgs     = ();
                              $m        = &list_match($bmon, @mon_names);
                              $dt_begin = sprintf("%04d%02d%02d0000", $byr, $m+1, $bday);
                              $m        = &list_match($emon, @mon_names);
                              $dt_end   = sprintf("%04d%02d%02d0000", $eyr, $m+1, $eday);

                              if ((! $limit_dates && ! $global_dt_limits && ! $rm_slice_limits) ||
                                  ($limit_dates && $global_dt_limits
                                                && $dt_begin eq $global_dt_begin
                                                && $dt_end   eq $global_dt_end
                                                && ! $align_slices && ! $rm_slice_limits)) {
                                  $result = &pop_up_question($date_limits_menu,
                                                             "No changes were made. Try again?");
                                  return if (lc($result) eq "yes");
                                  $date_limits_menu->g_bind('<Destroy>', "");
                                  $date_limits_menu->g_destroy();
                                  undef $date_limits_menu;
                                  &reset_bindings;
                                  return;
                              }

                              if ($limit_dates) {
                                  if ($dt_begin > $dt_end) {
                                      return &pop_up_error($date_limits_menu,
                                                  "The start date is after the end date.\n"
                                                . "Please adjust and try again.");
                                  } elsif ($dt_begin == $dt_end) {
                                      return &pop_up_error($date_limits_menu,
                                                  "The start date is the same as the end date.\n"
                                                . "Please adjust and try again.");
                                  }
                              }

                              $anim_tb = 0;
                              if (defined($animate_tb) && Tkx::winfo_exists($animate_tb)) {
                                  if ($animate_tb->g_wm_title() eq "Animation toolbar") {
                                      $anim_tb = 1;
                                      (undef, $X, $Y) = split(/\+/, $animate_tb->g_wm_geometry());
                                  }
                              }
                              @sav_dates = @dates;
                              $sav_dti   = $dti;
                              if (! $limit_dates ||
                                  ($limit_dates && $global_dt_limits
                                     && ($dt_begin > $dt_min || $dt_end < $dt_max))) {
                                  &rebuild_datelist(0);  # don't honor global limits here
                                  push (@msgs, "Rebuilding animation dates list...");
                              }

#                             If removing slice date limits, need to know full date range.
#                             Use saved values or scan input files for full date range.
                              if (length($dates[0]) == 12) {
                                  $first_slice_dt = $dates[0];
                                  $last_slice_dt  = $dates[$#dates];
                              } else {
                                  $first_slice_dt = $dates[0] *10000;
                                  $last_slice_dt  = $dates[$#dates] *10000;
                              }
                              if ($limit_dates && $got_slice_limits && $rm_slice_limits) {
                                  foreach $id (@animate_ids) {
                                      next if ($props{$id}{meta} ne "w2_slice");
                                      if ($props{$id}{dt_limits}) {
                                          if (! defined($props{$id}{start_dt})) {
                                              push (@msgs, "Scanning slice $props{$id}{gnum} "
                                                         . "for full date range...");
                                              @wbs = split(/,/, $props{$id}{wb_list});
                                              if ($props{$id}{src_type} =~ /Contour/i) {
                                                  @cpl_files = @{ $props{$id}{cpl_files} };
                                                  ($pbar_win, $pbar, $pbar_img)
                                                      = &create_alt_progress_bar($main, $id,
                                                                            "Scanning W2 contour files...");
                                                  for ($n=0; $n<=$#wbs; $n++) {
                                                      (undef, undef, undef, undef, $jd1, $jd2)
                                                            = &scan_w2_cpl_file($main, $cpl_files[$n],
                                                                                $id, 1, $pbar_img);
                                                      if ($n == 0) {
                                                          $first_jd = $jd1;
                                                          $last_jd  = $jd2;
                                                      } else {
                                                          $first_jd = $jd1 if ($jd1 < $first_jd);
                                                          $last_jd  = $jd2 if ($jd2 > $last_jd);
                                                      }
                                                  }
                                                  &destroy_progress_bar($main, $pbar_win);

                                              } elsif ($props{$id}{src_type} =~ /Vector/i) {
                                                  $status_line = "Scanning W2 vector file...";
                                                  Tkx::update_idletasks();
                                                  (undef, undef, undef, $first_jd, $last_jd)
                                                      = &scan_w2_vector_file($main, $props{$id}{w2l_file},
                                                                             $id, 1);
                                                  $status_line = "";
                                                  Tkx::update_idletasks();
                                              }
                                              ($hr, $mi) = split(/:/, $props{$id}{tz_offset});
                                              $hr += 0;
                                              $mi += 0;
                                              $mi *= -1 if ($hr < 0);
                                              $jd_offset = $hr/24. +$mi/1440.;
                                              $begin_jd  = &date2jdate(sprintf("%04d%02d%02d",
                                                                               $props{$id}{byear}, 1, 1));
                                              $props{$id}{start_dt} = &jdate2date($first_jd +$jd_offset
                                                                                  +$begin_jd -1);
                                              $props{$id}{end_dt}   = &jdate2date($last_jd  +$jd_offset
                                                                                  +$begin_jd -1);
                                          }
                                          if ($first_slice_dt > $props{$id}{start_dt}) {
                                              $first_slice_dt = $props{$id}{start_dt};
                                          }
                                          if ($last_slice_dt < $props{$id}{end_dt}) {
                                              $last_slice_dt = $props{$id}{end_dt};
                                          }
                                      }
                                  }
                              }

#                             Check date ranges and set global limits
                              if ($limit_dates) {
                                  if (length($dates[0]) == 12) {
                                      if ((! $rm_slice_limits && $dt_begin > $dates[$#dates])
                                           || ($rm_slice_limits && $dt_begin > $last_slice_dt)) {
                                          @dates   = @sav_dates;
                                          $dti     = $dti_old = $sav_dti;
                                          $dti_max = $#dates+1;
                                          return &pop_up_error($date_limits_menu,
                                                      "The start date is after all available data.\n"
                                                    . "Please adjust and try again.");
                                      } elsif ((! $rm_slice_limits && $dt_end < $dates[0])
                                                || ($rm_slice_limits && $dt_end < $first_slice_dt)) {
                                          @dates   = @sav_dates;
                                          $dti     = $dti_old = $sav_dti;
                                          $dti_max = $#dates+1;
                                          return &pop_up_error($date_limits_menu,
                                                      "The end date is before all available data.\n"
                                                    . "Please adjust and try again.");
                                      } elsif ((! $rm_slice_limits && $dt_begin <= $dates[0]
                                                                   && $dt_end   >= $dates[$#dates])
                                              || ($rm_slice_limits && $dt_begin <= $first_slice_dt
                                                                   && $dt_end   >= $last_slice_dt)) {
                                          @dates   = @sav_dates;
                                          $dti     = $dti_old = $sav_dti;
                                          $dti_max = $#dates+1;
                                          return &pop_up_error($date_limits_menu,
                                                      "The start and end dates encompass all data.\n"
                                                    . "A global date restriction is unnecessary.\n"
                                                    . "Adjust and try again?");
                                      }
                                  } elsif (length($dates[0]) == 8) {
                                      if ((! $rm_slice_limits && $dt_begin/10000 > $dates[$#dates])
                                           || ($rm_slice_limits && $dt_begin > $last_slice_dt)) {
                                          @dates   = @sav_dates;
                                          $dti     = $dti_old = $sav_dti;
                                          $dti_max = $#dates+1;
                                          return &pop_up_error($date_limits_menu,
                                                      "The start date is after all available data.\n"
                                                    . "Please adjust and try again.");
                                      } elsif ((! $rm_slice_limits && $dt_end/10000 < $dates[0])
                                                || ($rm_slice_limits && $dt_end < $first_slice_dt)) {
                                          @dates   = @sav_dates;
                                          $dti     = $dti_old = $sav_dti;
                                          $dti_max = $#dates+1;
                                          return &pop_up_error($date_limits_menu,
                                                      "The end date is before all available data.\n"
                                                    . "Please adjust and try again.");
                                      } elsif ((! $rm_slice_limits && $dt_begin/10000 <= $dates[0]
                                                                   && $dt_end/10000   >= $dates[$#dates])
                                              || ($rm_slice_limits && $dt_begin <= $first_slice_dt
                                                                   && $dt_end   >= $last_slice_dt)) {
                                          @dates   = @sav_dates;
                                          $dti     = $dti_old = $sav_dti;
                                          $dti_max = $#dates+1;
                                          return &pop_up_error($date_limits_menu,
                                                      "The start and end dates encompass all data.\n"
                                                    . "A global date restriction is unnecessary.\n"
                                                    . "Adjust and try again?");
                                      }
                                  }
                                  $global_dt_limits = 1;
                                  $global_dt_begin  = $dt_begin;
                                  $global_dt_end    = $dt_end;
                              } else {
                                  $global_dt_limits = 0;
                                  $global_dt_begin  = $global_dt_end = "na"
                              }

#                             Make some space in the menu for some status messages
                              $ok_btn->configure(-state => 'disabled');
                              $cancel_btn->configure(-state => 'disabled');
                              ($width, $height, undef, undef)
                                  = split(/x|\+/, $date_limits_menu->g_wm_geometry());
                              $date_limits_menu->g_wm_minsize($width,$height);
                              $date_limits_menu->configure(-cursor => $cursor_wait);
                              $f2->g_grid_remove();
                              Tkx::update();
                              ($f2 = $f->new_frame(
                                      -borderwidth => 1,
                                      -relief      => 'flat',
                                      ))->g_grid(-row => $row, -column => 0, -columnspan => 2,
                                                 -sticky => 'nsew', -pady => 2);
                              $maxrow = $row2+1;
                              $row2   = -1;
                              @labels = ();
                              for ($n=0; $n<=$#msgs; $n++) {
                                  $row2++;
                                  ($labels[$row2] = $f2->new_label(
                                          -text => $msgs[$n],
                                          -font => 'default',
                                          ))->g_grid(-row => $row2, -column => 0, -sticky => 'w');
                              }
                              Tkx::update();

#                             If date restrictions for W2 slice graphs are being aligned to global limits
#                               or removed entirely, then each slice plot needs to have its limits re-set,
#                               the inputs re-read, and the graph re-made.
                              if (($limit_dates && $align_slices) || $rm_slice_limits) {
                                  foreach $id (@animate_ids) {
                                      next if ($props{$id}{meta} ne "w2_slice");
                                      if ($limit_dates && $align_slices) {
                                          $dt1 = sprintf("%s-%02d-%04d", $bmon, $bday, $byr);
                                          $dt2 = sprintf("%s-%02d-%04d", $emon, $eday, $eyr);
                                          next if ($props{$id}{dt_limits} && $dt1 eq $props{$id}{dt_begin}
                                                                          && $dt2 eq $props{$id}{dt_end});
                                          $props{$id}{dt_limits} = 1;
                                          $props{$id}{dt_begin}  = $dt1;
                                          $props{$id}{dt_end}    = $dt2;

                                      } elsif ($rm_slice_limits) {
                                          next if (! $props{$id}{dt_limits});
                                          $props{$id}{dt_limits} = 0;
                                          $props{$id}{dt_begin}  = "na";
                                          $props{$id}{dt_end}    = "na";
                                      }
                                      if ($row2 >= $maxrow) {
                                          $labels[$row2 -$maxrow]->g_grid_remove();
                                          Tkx::update();
                                      }
                                      $row2++;
                                      ($labels[$row2] = $f2->new_label(
                                              -text => "Rebuilding W2 slice $props{$id}{gnum}...",
                                              -font => 'default',
                                              ))->g_grid(-row => $row2, -column => 0, -sticky => 'w');
                                      $parms{rebuild}    = 1;
                                      $parms{pmin}       = $gr_props{$id}{cs_min};
                                      $parms{pmax}       = $gr_props{$id}{cs_max};
                                      $parms{pmajor}     = $gr_props{$id}{cs_major};
                                      $parms{gtitle}     = $gr_props{$id}{gtitle};
                                      $parms{change}     = "misc";
                                      $props{$id}{parms} = { %parms };
                                      $props{$id}{data}  = 0;
                                      &make_w2_slice($canvas, $id, 0);

                                      $date_limits_menu->g_raise();
                                      $date_limits_menu->g_focus;
                                  }
                              }

#                             Truncate the dates array and replot all animated features
                              if ($limit_dates) {
                                  if ($row2 >= $maxrow) {
                                      $labels[$row2 -$maxrow]->g_grid_remove();
                                      Tkx::update();
                                  }
                                  $row2++;
                                  ($labels[$row2] = $f2->new_label(
                                          -text => "Truncating animation date list...",
                                          -font => 'default',
                                          ))->g_grid(-row => $row2, -column => 0, -sticky => 'w');
                                  Tkx::update_idletasks();
                                  $dt    = $dates[$dti-1];
                                  @dates = &truncate_dates($dt_begin, $dt_end, @dates);
                                  $dti   = 1 + &nearest_dt_index($dt, @dates);
                                  $dti++ if ($dti == 0);
                                  $dti_old = $dti;
                                  $dti_max = $#dates+1;
                                  $dt      = $dates[$dti-1];
                                  $delta_dti = 1 if ($dti_max < 100);

                                  if ($row2 >= $maxrow) {
                                      $labels[$row2 -$maxrow]->g_grid_remove();
                                      Tkx::update();
                                  }
                                  $row2++;
                                  ($labels[$row2] = $f2->new_label(
                                          -text => "Updating graphs for date $dt...",
                                          -font => 'default',
                                          ))->g_grid(-row => $row2, -column => 0, -sticky => 'w');
                                  &update_animate(&get_formatted_date($dt));
                              }

#                             Rebuild the W2 profile date match list, if necessary
                              &build_profile_match_list();

#                             Rebuild the animation toolbar, if it was present
                              if ($anim_tb) {
                                  if (defined($animate_tb) && Tkx::winfo_exists($animate_tb)) {
                                      if ($animate_tb->g_wm_title() eq "Animation toolbar") {
                                          $animate_tb->g_destroy();
                                          undef $animate_tb;
                                      }
                                  }
                                  &animate_toolbar($X, $Y, -1);
                              }
                              $date_limits_menu->g_raise();
                              $date_limits_menu->g_focus;
                              Tkx::update();
                              sleep 1;

                              $date_limits_menu->g_bind('<Destroy>', "");
                              $date_limits_menu->g_destroy();
                              undef $date_limits_menu;
                              &reset_bindings;
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    ($cancel_btn = $frame->new_button(
            -text    => "Cancel",
            -command => sub { $date_limits_menu->g_bind('<Destroy>', "");
                              $date_limits_menu->g_destroy();
                              undef $date_limits_menu;
                              &reset_bindings;
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Reset bindings if this menu is destroyed by other than the Cancel button
    $date_limits_menu->g_bind('<Destroy>' => sub { undef $date_limits_menu;
                                                   &reset_bindings;
                                                 });

    ($f = $date_limits_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_pack(-side => 'top', -expand => 1, -fill => 'both');
    $row = 0;
    $f->new_label(
            -text => " Date ranges for animated objects:",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -columnspan => 2, -sticky => 'w', -pady => 2);

#   Need a scrollable container, and a canvas is about the only container that works.
#   Create a parent frame (sc_fr) for the canvas (sc_canv) and scrollbar (vscroll).
#   Then put a frame inside the canvas (fr) as a widget window to hold other menu items.
    $row++;
    ($sc_fr = $f->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_grid(-row => $row, -column => 0, -columnspan => 2, -sticky => 'nsew', -pady => 2);
    ($vscroll = $sc_fr->new_scrollbar(
            -orient => 'vertical',
            -width  => 15,
            ))->g_grid(-row => 0, -column => 1, -sticky => 'nse');
    ($sc_canv = $sc_fr->new_tk__canvas(
            -highlightthickness => 0,
            -yscrollcommand => [$vscroll, 'set'],
            ))->g_grid(-row => 0, -column => 0, -sticky => 'nsew');
    $vscroll->configure(-command => [$sc_canv, 'yview']);

    $fr = $sc_canv->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            );

    $fr_row = 0;
    $fr->new_label(
            -text => "#",
            -font => 'default',
            )->g_grid(-row => $fr_row, -column => 0, -padx => 2, -pady => 2);
    $fr->new_label(
            -text => "Object",
            -font => 'default',
            )->g_grid(-row => $fr_row, -column => 1, -padx => 2, -pady => 2);
    $fr->new_label(
            -text => "Start Date",
            -font => 'default',
            )->g_grid(-row => $fr_row, -column => 2, -padx => 2, -pady => 2);
    $fr->new_label(
            -text => "End Date",
            -font => 'default',
            )->g_grid(-row => $fr_row, -column => 3, -padx => 2, -pady => 2);
    if ($got_slice) {
        $fr->new_label(
                -text => "Date Limits",
                -font => 'default',
                )->g_grid(-row => $fr_row, -column => 4, -padx => 2, -pady => 2);
    }

    foreach $id (@animate_ids) {
        if ($props{$id}{meta} =~ /^(data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)$/) {
            ($type = $props{$id}{meta}) =~ s/_/ /g;
            $type = ucfirst($type);
            $fr_row++;
            $fr->new_label(
                    -text => $props{$id}{gnum},
                    -font => 'default',
                    )->g_grid(-row => $fr_row, -column => 0, -padx => 2, -pady => 2);
            $fr->new_label(
                    -text => $type,
                    -font => 'default',
                    )->g_grid(-row => $fr_row, -column => 1, -sticky => 'w', -padx => 2, -pady => 2);
            $fr->new_label(
                    -text => $date_min{$id},
                    -font => 'default',
                    )->g_grid(-row => $fr_row, -column => 2, -padx => 2, -pady => 2);
            $fr->new_label(
                    -text => $date_max{$id},
                    -font => 'default',
                    )->g_grid(-row => $fr_row, -column => 3, -padx => 2, -pady => 2);
            if ($got_slice) {
                if ($props{$id}{meta} eq "w2_slice" && $props{$id}{dt_limits}) {
                    $txt = "restricted";
                } else {
                    $txt = "none";
                }
                $fr->new_label(
                        -text => $txt,
                        -font => 'default',
                        )->g_grid(-row => $fr_row, -column => 4, -padx => 2, -pady => 2);
            }
        }
    }

    $sc_canv->create_window(0, 0,
            -anchor => 'nw',
            -window => $fr,
            -tags   => 'scrollable',
            );
    &update_scrollable_tab($date_limits_menu, $sc_fr, $sc_canv, 'scrollable', $vscroll);
    $sc_fr->g_grid_columnconfigure(0, -weight => 1);

    $row++;
    ($f2 = $f->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_grid(-row => $row, -column => 0, -columnspan => 2, -sticky => 'nsew', -pady => 2);

    $row2 = -1;
    if ($got_slice_limits) {
        $row2++;
        $f2->new_label(
                -text => "Slice Dates: ",
                -font => 'default',
                )->g_grid(-row => $row2, -column => 0, -sticky => 'e', -pady => 2);
        $f2->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "Remove all slice date restrictions",
                -font     => 'default',
                -variable => \$rm_slice_limits,
                -command  => sub { $align_slices = 0 if ($rm_slice_limits); },
                )->g_grid(-row => $row2, -column => 1, -sticky => 'w');
    }

    $row2++;
    $f2->new_label(
            -text => "Date Limits: ",
            -font => 'default',
            )->g_grid(-row => $row2, -column => 0, -sticky => 'e', -pady => 2);
    ($limits_frame = $f2->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row2, -column => 1, -sticky => 'w');
    $limits_frame->new_checkbutton(
            -onvalue  => 1,
            -offvalue => 0,
            -text     => "Impose global date limits ",
            -font     => 'default',
            -variable => \$limit_dates,
            -command  => sub { if ($limit_dates) {
                                   $bmon_cb->configure(-state => 'readonly');
                                   $bday_cb->configure(-state => 'readonly');
                                   $byr_cb->configure(-state  => 'readonly');
                                   $emon_cb->configure(-state => 'readonly');
                                   $eday_cb->configure(-state => 'readonly');
                                   $eyr_cb->configure(-state  => 'readonly');
                                   $align_btn->configure(-state => 'normal') if ($got_slice);
                                   $narrow_btn->configure(-state => 'normal') if ($max_dtmin < $min_dtmax
                                                                                  && $nobj > 1);
                                   if ($narrow) {
                                       $bmon = $bm_narrow;
                                       $bday = $bd_narrow;
                                       $byr  = $by_narrow;
                                       $emon = $em_narrow;
                                       $eday = $ed_narrow;
                                       $eyr  = $ey_narrow;
                                   } else {
                                       $bmon = $bmon_sav;
                                       $bday = $bday_sav;
                                       $byr  = $byr_sav;
                                       $emon = $emon_sav;
                                       $eday = $eday_sav;
                                       $eyr  = $eyr_sav;
                                   }
                               } else {
                                   $bmon_cb->configure(-state => 'disabled');
                                   $bday_cb->configure(-state => 'disabled');
                                   $byr_cb->configure(-state  => 'disabled');
                                   $emon_cb->configure(-state => 'disabled');
                                   $eday_cb->configure(-state => 'disabled');
                                   $eyr_cb->configure(-state  => 'disabled');
                                   $align_btn->configure(-state => 'disabled') if ($got_slice);
                                   $narrow_btn->configure(-state => 'disabled') if ($max_dtmin < $min_dtmax
                                                                                    && $nobj > 1);
                               }
                             },
            )->g_pack(-side => 'left', -anchor => 'w');
    $limits_frame->new_button(
            -text    => "Help",
            -command => sub { &pop_up_info($date_limits_menu,
                                    "Imposing global date limits will restrict the date range for\n"
                                  . "animatons. The global date restriction is independent of the\n"
                                  . "data stored with each animated object.\n\n"
                                  . "W2 Longitudinal Slice plots may have a separate date\n"
                                  . "restriction that affects the data stored with that object.\n"
                                  . "You may leave such restrictions in place, or modify them\n"
                                  . "here to align with a global date restriction. Such alignment\n"
                                  . "will force the data files for any W2 Longitudinal Slice plots\n"
                                  . "to be re-read and the slice images to be re-created.",
                                    "Global Date Limits");
                            },
            )->g_pack(-side => 'left', -anchor => 'w', -padx => 2);

    $row2++;
    $f2->new_label(
            -text => "Start Date: ",
            -font => 'default',
            )->g_grid(-row => $row2, -column => 0, -sticky => 'e', -pady => 2);
    ($bdate_frame = $f2->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row2, -column => 1, -sticky => 'w');
    ($bmon_cb = $bdate_frame->new_ttk__combobox(
            -textvariable => \$bmon,
            -values       => [ @mon_names ],
            -state        => 'readonly',
            -width        => 4,
            ))->g_pack(-side => 'left');
    $bmon_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($byr);
                          $bm = &list_match($bmon, @mon_names);
                          $bday_cb->configure(-values => [ 1 .. $days_in_month[$bm] ]);
                          $bday = $days_in_month[$bm] if ($bday > $days_in_month[$bm]);
                        }
                    );
    $bdate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($bday_cb = $bdate_frame->new_ttk__combobox(
            -textvariable => \$bday,
            -values       => [ 1 .. $days_in_month[$bm] ],
            -state        => 'readonly',
            -width        => 3,
            ))->g_pack(-side => 'left');
    $bdate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($byr_cb = $bdate_frame->new_ttk__combobox(
            -textvariable => \$byr,
            -values       => [ reverse($yr_min .. $yr_max) ],
            -state        => 'readonly',
            -width        => 5,
            ))->g_pack(-side => 'left');
    $byr_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($byr);
                          $bm = &list_match($bmon, @mon_names);
                          if ($bm == 1) {
                              $bday_cb->configure(-values => [ 1 .. $days_in_month[$bm] ]);
                              $bday = $days_in_month[$bm] if ($bday > $days_in_month[$bm]);
                          }
                          if ($byr == $yr_min || $byr == $yr_max) {
                              $yr_min -= 10 if ($byr == $yr_min);
                              $yr_max += 10 if ($byr == $yr_max);
                              $byr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                              $eyr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                          }
                        }
                    );

    $row2++;
    $f2->new_label(
            -text => "End Date: ",
            -font => 'default',
            )->g_grid(-row => $row2, -column => 0, -sticky => 'e', -pady => 2);
    ($edate_frame = $f2->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row2, -column => 1, -sticky => 'w');
    ($emon_cb = $edate_frame->new_ttk__combobox(
            -textvariable => \$emon,
            -values       => [ @mon_names ],
            -state        => 'readonly',
            -width        => 4,
            ))->g_pack(-side => 'left');
    $emon_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($eyr);
                          $em = &list_match($emon, @mon_names);
                          $eday_cb->configure(-values => [ 1 .. $days_in_month[$em] ]);
                          $eday = $days_in_month[$em] if ($eday > $days_in_month[$em]);
                        }
                    );
    $edate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($eday_cb = $edate_frame->new_ttk__combobox(
            -textvariable => \$eday,
            -values       => [ 1 .. $days_in_month[$em] ],
            -state        => 'readonly',
            -width        => 3,
            ))->g_pack(-side => 'left');
    $edate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($eyr_cb = $edate_frame->new_ttk__combobox(
            -textvariable => \$eyr,
            -values       => [ reverse($yr_min .. $yr_max) ],
            -state        => 'readonly',
            -width        => 5,
            ))->g_pack(-side => 'left');
    $eyr_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($eyr);
                          $em = &list_match($emon, @mon_names);
                          if ($em == 1) {
                              $eday_cb->configure(-values => [ 1 .. $days_in_month[$em] ]);
                              $eday = $days_in_month[$em] if ($eday > $days_in_month[$em]);
                          }
                          if ($eyr == $yr_min || $eyr == $yr_max) {
                              $yr_min -= 10 if ($eyr == $yr_min);
                              $yr_max += 10 if ($eyr == $yr_max);
                              $byr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                              $eyr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                          }
                        }
                    );

    if ($max_dtmin < $min_dtmax && $nobj > 1) {
        $row2++;
        $f2->new_label(
                -text => "Options: ",
                -font => 'default',
                )->g_grid(-row => $row2, -column => 0, -sticky => 'e', -pady => 2);
        ($narrow_btn = $f2->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "Choose most restricted limits",
                -font     => 'default',
                -variable => \$narrow,
                -command  => sub { if ($narrow) {
                                       $bmon = $bm_narrow;
                                       $bday = $bd_narrow;
                                       $byr  = $by_narrow;
                                       $emon = $em_narrow;
                                       $eday = $ed_narrow;
                                       $eyr  = $ey_narrow;
                                       $bmon_cb->configure(-state => 'disabled');
                                       $bday_cb->configure(-state => 'disabled');
                                       $byr_cb->configure(-state  => 'disabled');
                                       $emon_cb->configure(-state => 'disabled');
                                       $eday_cb->configure(-state => 'disabled');
                                       $eyr_cb->configure(-state  => 'disabled');
                                   } else {
                                       $bmon = $bmon_sav;
                                       $bday = $bday_sav;
                                       $byr  = $byr_sav;
                                       $emon = $emon_sav;
                                       $eday = $eday_sav;
                                       $eyr  = $eyr_sav;
                                       $bmon_cb->configure(-state => 'readonly');
                                       $bday_cb->configure(-state => 'readonly');
                                       $byr_cb->configure(-state  => 'readonly');
                                       $emon_cb->configure(-state => 'readonly');
                                       $eday_cb->configure(-state => 'readonly');
                                       $eyr_cb->configure(-state  => 'readonly');
                                   }
                                 },
                ))->g_grid(-row => $row2, -column => 1, -sticky => 'w');
    }

    if ($got_slice) {
        $row2++;
        if ($max_dtmin >= $min_dtmax || $nobj <= 1) {
            $f2->new_label(
                    -text => "Options: ",
                    -font => 'default',
                    )->g_grid(-row => $row2, -column => 0, -sticky => 'e', -pady => 2);
        }
        ($align_btn = $f2->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "Align slice restrictions to global limits",
                -font     => 'default',
                -variable => \$align_slices,
                -command  => sub { $rm_slice_limits = 0 if ($align_slices); },
                ))->g_grid(-row => $row2, -column => 1, -sticky => 'w');
    }

    if ($limit_dates) {
        $bmon_cb->configure(-state => 'readonly');
        $bday_cb->configure(-state => 'readonly');
        $byr_cb->configure(-state  => 'readonly');
        $emon_cb->configure(-state => 'readonly');
        $eday_cb->configure(-state => 'readonly');
        $eyr_cb->configure(-state  => 'readonly');
        $narrow_btn->configure(-state => 'normal') if ($max_dtmin < $min_dtmax && $nobj > 1);
        $align_btn->configure(-state => 'normal') if ($got_slice);
    } else {
        $bmon_cb->configure(-state => 'disabled');
        $bday_cb->configure(-state => 'disabled');
        $byr_cb->configure(-state  => 'disabled');
        $emon_cb->configure(-state => 'disabled');
        $eday_cb->configure(-state => 'disabled');
        $eyr_cb->configure(-state  => 'disabled');
        $narrow_btn->configure(-state => 'disabled') if ($max_dtmin < $min_dtmax && $nobj > 1);
        $align_btn->configure(-state => 'disabled') if ($got_slice);
    }
    $f2->g_grid_columnconfigure(1, -weight => 1);

    Tkx::wm_resizable($date_limits_menu,0,0);
    &adjust_window_position($date_limits_menu);
    $date_limits_menu->g_focus;
}


################################################################################
#
# Animation tools
#
################################################################################

sub animate_toolbar {
    my ($X, $Y, $id) = @_;
    my (
        $bkwd_btn, $date_label, $end_btn, $faster_btn, $faster_img, $frame,
        $fr_btns, $fr_msgs, $frame_label, $fwd_btn, $geom, $on_btn,
        $pause_img, $play_btn, $play_img, $repeat_btn, $repeat_img,
        $repeaton_img, $reverse_img, $rvrs_btn, $slower_btn, $slower_img,
        $step_bkw_img, $step_fwd_img, $stop_btn, $stop_img, $strt_btn,
        $tb_scale, $to_end_img, $to_start_img, $tooltip,
       );

    $geom = sprintf("+%d+%d", $X, $Y);
    &end_select($canvas, $id, 1) if (defined($id) && $id != -1);

    if (defined($animate_tb) && Tkx::winfo_exists($animate_tb)) {
        if ($animate_tb->g_wm_title() eq "Animation toolbar") {
            $animate_tb->g_wm_deiconify();
            $animate_tb->g_wm_geometry($geom);
            $animate_tb->g_raise();
            $animate_tb->g_focus;
            &adjust_window_position($animate_tb);
            return;
        }
    }
    $animate_tb = $main->new_toplevel();
    $animate_tb->g_wm_transient($main);
    $animate_tb->g_wm_title("Animation toolbar");
    $animate_tb->configure(-cursor => $cursor_norm);
    $animate_tb->g_wm_geometry($geom);

#   Stop animation if this menu is destroyed
    $animate_tb->g_bind('<Destroy>' => sub { $anim_tb_status = "stopped";
                                             &reset_bindings;
                                           });

#   Toolbar images
    $to_start_img = Tkx::image_create_photo(-file => "${prog_path}images/to_start.png");
    $step_bkw_img = Tkx::image_create_photo(-file => "${prog_path}images/step_bkw.png");
    $reverse_img  = Tkx::image_create_photo(-file => "${prog_path}images/reverse.png");
    $stop_img     = Tkx::image_create_photo(-file => "${prog_path}images/stop.png");
    $pause_img    = Tkx::image_create_photo(-file => "${prog_path}images/pause.png");
    $play_img     = Tkx::image_create_photo(-file => "${prog_path}images/play.png");
    $step_fwd_img = Tkx::image_create_photo(-file => "${prog_path}images/step_fwd.png");
    $to_end_img   = Tkx::image_create_photo(-file => "${prog_path}images/to_end.png");
    $faster_img   = Tkx::image_create_photo(-file => "${prog_path}images/plus.png");
    $slower_img   = Tkx::image_create_photo(-file => "${prog_path}images/minus.png");
    $repeat_img   = Tkx::image_create_photo(-file => "${prog_path}images/repeat.png");
    $repeaton_img = Tkx::image_create_photo(-file => "${prog_path}images/repeat_on.png");

    $anim_tb_status = "stopped";
    $tooltip = "";
    $on_btn  = "";

    ($frame = $animate_tb->new_frame(
                -borderwidth => 2,
                -relief      => 'groove',
                ))->g_pack(-anchor => 'nw', -expand => 1, -fill => 'x');
    ($fr_btns = $frame->new_frame(
                ))->g_grid(-row => 0, -column => 0, -sticky => 'nw', -padx => 0, -pady => 0);
    ($strt_btn = $fr_btns->new_button(
                -repeatdelay    => 10000,
                -repeatinterval => 10000,
                -image   => $to_start_img,
                -command => sub { $dti = 1;
                                  if ($anim_tb_status eq "playing") {
                                      $play_btn->configure(-image => $play_img);
                                      $stop_btn->configure(-state => 'disabled');
                                      $anim_tb_status = "stopped";
                                  } elsif ($anim_tb_status eq "reversing") {
                                      $rvrs_btn->configure(-image => $reverse_img);
                                      $stop_btn->configure(-state => 'disabled');
                                      $anim_tb_status = "stopped";
                                  }
                                  if ($dti != $dti_old) {
                                      ($frame_label, $date_label) = &get_animation_date;
                                      &update_animate($date_label);
                                      $dti_old = $dti;
                                  }
                                },
                ))->g_pack(-side => 'left', -padx => 0, -pady => 1);
    ($bkwd_btn = $fr_btns->new_button(
                -repeatdelay    => 400,
                -repeatinterval => 18,
                -image   => $step_bkw_img,
                -command => sub { if ($on_btn =~ /Shift/) {
                                      $on_btn = ($on_btn =~ /ShiftSpace/) ? "" : "bkwd";
                                      $dti = &next_profile_dti("bkwd");
                                  } else {
                                      if ($repeat_anim && $dti == 1) {
                                          $dti = $dti_max;
                                      } else {
                                          $dti--;
                                      }
                                  }
                                  if ($anim_tb_status eq "playing") {
                                      $play_btn->configure(-image => $play_img);
                                      $stop_btn->configure(-state => 'disabled');
                                      $anim_tb_status = "stopped";
                                  } elsif ($anim_tb_status eq "reversing") {
                                      $rvrs_btn->configure(-image => $reverse_img);
                                      $stop_btn->configure(-state => 'disabled');
                                      $anim_tb_status = "stopped";
                                  }
                                  if ($dti != $dti_old) {
                                      ($frame_label, $date_label) = &get_animation_date;
                                      &update_animate($date_label);
                                      $dti_old = $dti;
                                  }
                                },
                ))->g_pack(-side => 'left', -padx => 0, -pady => 1);
    ($rvrs_btn = $fr_btns->new_button(
                -repeatdelay    => 10000,
                -repeatinterval => 10000,
                -image   => $reverse_img,
                -command => sub { if ($anim_tb_status ne "reversing" && ($repeat_anim || $dti > 1)) {
                                      $rvrs_btn->configure(-image => $pause_img);
                                      $play_btn->configure(-image => $play_img);
                                      $stop_btn->configure(-state => 'normal');
                                      $anim_tb_status = "reversing";
                                      $tooltip = "Pause";
                                  } else {
                                      $rvrs_btn->configure(-image => $reverse_img);
                                      $stop_btn->configure(-state => 'disabled');
                                      $anim_tb_status = "stopped";
                                      $tooltip = "Reverse";
                                  }
                                  $canvas->g_bind("<Motion>", "");
                                  while ($anim_tb_status eq "reversing" && ($repeat_anim || $dti > 1)) {
                                      if ($repeat_anim && $dti -$delta_dti < 1) {
                                          $dti = $dti_max;
                                      } else {
                                          $dti -= $delta_dti;
                                          $dti = 1 if ($dti < 1);
                                      }
                                      ($frame_label, $date_label) = &get_animation_date;
                                      &update_animate($date_label);
                                      $dti_old = $dti;
                                      if (! $repeat_anim && $dti == 1) {
                                          $rvrs_btn->configure(-image => $reverse_img);
                                          $stop_btn->configure(-state => 'disabled');
                                          $anim_tb_status = "stopped";
                                          $tooltip = "";
                                      } else {
                                          Tkx::update();
                                          usleep($delay*1E6) if ($delay > 0);
                                      }
                                  }
                                  &reset_bindings;
                                },
                ))->g_pack(-side => 'left', -padx => 0, -pady => 1);
    ($stop_btn = $fr_btns->new_button(
                -repeatdelay    => 10000,
                -repeatinterval => 10000,
                -image   => $stop_img,
                -state   => 'disabled',
                -command => sub { $rvrs_btn->configure(-image => $reverse_img);
                                  $play_btn->configure(-image => $play_img);
                                  $stop_btn->configure(-state => 'disabled');
                                  $anim_tb_status = "stopped";
                                  $tooltip = "";
                                  ($frame_label, $date_label) = &get_animation_date;
                                  &reset_bindings;
                                },
                ))->g_pack(-side => 'left', -padx => 0, -pady => 1);
    ($play_btn = $fr_btns->new_button(
                -repeatdelay    => 10000,
                -repeatinterval => 10000,
                -image   => $play_img,
                -command => sub { if ($anim_tb_status ne "playing" && ($repeat_anim || $dti < $dti_max)) {
                                      $play_btn->configure(-image => $pause_img);
                                      $rvrs_btn->configure(-image => $reverse_img);
                                      $stop_btn->configure(-state => 'normal');
                                      $anim_tb_status = "playing";
                                      $tooltip = "Pause";
                                  } else {
                                      $play_btn->configure(-image => $play_img);
                                      $stop_btn->configure(-state => 'disabled');
                                      $anim_tb_status = "stopped";
                                      $tooltip = "Play";
                                  }
                                  $canvas->g_bind("<Motion>", "");
                                  while ($anim_tb_status eq "playing" && ($repeat_anim || $dti < $dti_max)) {
                                      if ($repeat_anim && $dti +$delta_dti > $dti_max) {
                                          $dti = 1;
                                      } else {
                                          $dti += $delta_dti;
                                          $dti = $dti_max if ($dti > $dti_max);
                                      }
                                      ($frame_label, $date_label) = &get_animation_date;
                                      &update_animate($date_label);
                                      $dti_old = $dti;
                                      if (! $repeat_anim && $dti == $dti_max) {
                                          $play_btn->configure(-image => $play_img);
                                          $stop_btn->configure(-state => 'disabled');
                                          $anim_tb_status = "stopped";
                                          $tooltip = "";
                                      } else {
                                          Tkx::update();
                                          usleep($delay*1E6) if ($delay > 0);
                                      }
                                  }
                                  &reset_bindings;
                                },
                ))->g_pack(-side => 'left', -padx => 0, -pady => 1);
    ($fwd_btn = $fr_btns->new_button(
                -repeatdelay    => 400,
                -repeatinterval => 18,
                -image   => $step_fwd_img,
                -command => sub { if ($on_btn =~ /Shift/) {
                                      $on_btn = ($on_btn =~ /ShiftSpace/) ? "" : "fwd";
                                      $dti = &next_profile_dti("fwd");
                                  } else {
                                      if ($repeat_anim && $dti == $dti_max) {
                                          $dti = 1;
                                      } else {
                                          $dti++;
                                      }
                                  }
                                  if ($anim_tb_status eq "playing") {
                                      $play_btn->configure(-image => $play_img);
                                      $stop_btn->configure(-state => 'disabled');
                                      $anim_tb_status = "stopped";
                                  } elsif ($anim_tb_status eq "reversing") {
                                      $rvrs_btn->configure(-image => $reverse_img);
                                      $stop_btn->configure(-state => 'disabled');
                                      $anim_tb_status = "stopped";
                                  }
                                  if ($dti != $dti_old) {
                                      ($frame_label, $date_label) = &get_animation_date;
                                      &update_animate($date_label);
                                      $dti_old = $dti;
                                  }
                                },
                ))->g_pack(-side => 'left', -padx => 0, -pady => 1);
    ($end_btn = $fr_btns->new_button(
                -repeatdelay    => 10000,
                -repeatinterval => 10000,
                -image   => $to_end_img,
                -command => sub { $dti = $dti_max;
                                  if ($anim_tb_status eq "playing") {
                                      $play_btn->configure(-image => $play_img);
                                      $stop_btn->configure(-state => 'disabled');
                                      $anim_tb_status = "stopped";
                                  } elsif ($anim_tb_status eq "reversing") {
                                      $rvrs_btn->configure(-image => $reverse_img);
                                      $stop_btn->configure(-state => 'disabled');
                                      $anim_tb_status = "stopped";
                                  }
                                  if ($dti != $dti_old) {
                                      ($frame_label, $date_label) = &get_animation_date;
                                      &update_animate($date_label);
                                      $dti_old = $dti;
                                  }
                                },
                ))->g_pack(-side => 'left', -padx => 0, -pady => 1);
    ($repeat_btn = $fr_btns->new_button(
                -repeatdelay    => 100000,
                -repeatinterval => 100000,
                -image   => ($repeat_anim) ? $repeaton_img : $repeat_img,
                -command => sub { if ($repeat_anim) {
                                      $repeat_anim = 0;
                                      $repeat_btn->configure(-image => $repeat_img);
                                  } else {
                                      $repeat_anim = 1;
                                      $repeat_btn->configure(-image => $repeaton_img);
                                  }
                                  $tooltip = ($repeat_anim) ? "Repeat: On" : "Repeat: Off";
                                },
                ))->g_pack(-side => 'left', -padx => 0, -pady => 1);

    ($tb_scale = $frame->new_scale(
                -orient       => 'horizontal',
                -from         => 1,
                -to           => $dti_max,
                -variable     => \$dti,
                -showvalue    => 'false',
                -width        => 12,
                -length       => 300,
                -sliderlength => 6,
                -takefocus    => 1,
                -command      => sub { if ($anim_tb_status eq "playing") {
                                           $play_btn->configure(-image => $play_img);
                                           $stop_btn->configure(-state => 'disabled');
                                           $anim_tb_status = "stopped";
                                       } elsif ($anim_tb_status eq "reversing") {
                                           $rvrs_btn->configure(-image => $reverse_img);
                                           $stop_btn->configure(-state => 'disabled');
                                           $anim_tb_status = "stopped";
                                       } 
                                       if ($dti != $dti_old) {
                                           ($frame_label, $date_label) = &get_animation_date;
                                           &update_animate($date_label);
                                           $dti_old = $dti;
                                           $anim_tb_status = "stopped";
                                       }
                                     },
                ))->g_grid(-row    =>   0,  -column => 1, -columnspan => 2,
                           -sticky => 'ew', -padx   => 2, -pady       => 0);

    ($frame_label, $date_label) = &get_animation_date;
    $fr_msgs = $frame->new_frame();
    $fr_msgs->g_grid(-row => 1, -column => 0, -sticky => 'nsew', -padx => 0, -pady => 0);
    $fr_msgs->new_label(
                -textvariable => \$tooltip,
                -justify      => 'left',
                -font         => 'default',
                )->g_pack(-side => 'left', -padx => 0, -pady => 1);
    ($slower_btn = $fr_msgs->new_button(
                -repeatdelay    => 400,
                -repeatinterval => 18,
                -image   => $slower_img,
                -command => sub { if ($delay < 0.05 || ($dti_max >= 100 && $delta_dti == 1)) {
                                      $faster_btn->configure(-state => 'normal');
                                  }
                                  if ($on_btn =~ /Shift.*Slower/) {
                                      if ($dti_max >= 100) {
                                          $delta_dti-- if ($delta_dti > 1);
                                          $tooltip = sprintf("Slower (skip date: %d)", $delta_dti);
                                      }
                                  } else {
                                      $delay += 0.1;
                                      $delay  = 10 if ($delay > 9.95);
                                      $tooltip = sprintf("Slower (delay %.1fs)", $delay);
                                  }
                                  if ($delay > 9.95 && ($dti_max < 100 || $delta_dti == 1)) {
                                      $slower_btn->configure(-state => 'disabled');
                                  }
                                },
                ))->g_pack(-side => 'right', -padx => 0, -pady => 1);
    ($faster_btn = $fr_msgs->new_button(
                -repeatdelay    => 400,
                -repeatinterval => 18,
                -image   => $faster_img,
                -command => sub { if ($delay > 9.95 || ($dti_max >= 100 && $delta_dti >= $dti_max /100.)) {
                                      $slower_btn->configure(-state => 'normal');
                                  }
                                  if ($on_btn =~ /Shift.*Faster/) {
                                      if ($dti_max >= 100) {
                                          $delta_dti++ if ($delta_dti < $dti_max /100.);
                                          $tooltip = sprintf("Faster (skip date: %d)", $delta_dti);
                                      }
                                  } else {
                                      $delay  -= 0.1;
                                      $delay   = 0 if ($delay < 0.05);
                                      $tooltip = sprintf("Faster (delay %.1fs)", $delay);
                                  }
                                  if ($delay == 0 && ($dti_max < 100 || $delta_dti >= $dti_max /100.)) {
                                      $faster_btn->configure(-state => 'disabled');
                                  }
                                },
                ))->g_pack(-side => 'right', -padx => 0, -pady => 1);

    $frame->new_label(
                -textvariable => \$frame_label,
                -justify      => 'left',
                -font         => 'default',
                )->g_grid(-row => 1, -column => 1, -sticky => 'sw', -padx => 1, -pady => 1);
    $frame->new_label(
                -textvariable => \$date_label,
                -justify      => 'right',
                -font         => 'default',
                )->g_grid(-row => 1, -column => 2, -sticky => 'se', -padx => 1, -pady => 1);

#   Bindings for normal mouse focus
    $strt_btn->g_bind("<Enter>",   sub { $on_btn  = "other"; $tooltip = "To Start"; });
    $bkwd_btn->g_bind("<Enter>",   sub { $on_btn  = "bkwd";  $tooltip = "Step Backward"; });
    $rvrs_btn->g_bind("<Enter>",   sub { $on_btn  = "other";
                                         $tooltip = ($anim_tb_status eq "reversing") ? "Pause"
                                                                                     : "Reverse"; });
    $stop_btn->g_bind("<Enter>",   sub { $on_btn  = "other";
                                         $tooltip = ($anim_tb_status eq "stopped") ? "" : "Stop"; });
    $play_btn->g_bind("<Enter>",   sub { $on_btn  = "other";
                                         $tooltip = ($anim_tb_status eq "playing") ? "Pause" : "Play"; });
    $fwd_btn->g_bind("<Enter>",    sub { $on_btn  = "fwd";   $tooltip = "Step Forward"; });
    $end_btn->g_bind("<Enter>",    sub { $on_btn  = "other"; $tooltip = "To End"; });
    $repeat_btn->g_bind("<Enter>", sub { $on_btn  = "other";
                                         $tooltip = ($repeat_anim) ? "Repeat: On" : "Repeat: Off"; });
    $faster_btn->g_bind("<Enter>", sub { $on_btn  = "faster";
                                         $tooltip = sprintf("Faster (delay %.1fs)", $delay); });
    $slower_btn->g_bind("<Enter>", sub { $on_btn  = "slower";
                                         $tooltip = sprintf("Slower (delay %.1fs)", $delay); });

    $strt_btn->g_bind("<Leave>",   sub { $tooltip = ""; $on_btn = ""; });
    $bkwd_btn->g_bind("<Leave>",   sub { $tooltip = ""; $on_btn = ""; });
    $rvrs_btn->g_bind("<Leave>",   sub { $tooltip = ""; $on_btn = ""; });
    $stop_btn->g_bind("<Leave>",   sub { $tooltip = ""; $on_btn = ""; });
    $play_btn->g_bind("<Leave>",   sub { $tooltip = ""; $on_btn = ""; });
    $fwd_btn->g_bind("<Leave>",    sub { $tooltip = ""; $on_btn = ""; });
    $end_btn->g_bind("<Leave>",    sub { $tooltip = ""; $on_btn = ""; });
    $repeat_btn->g_bind("<Leave>", sub { $tooltip = ""; $on_btn = ""; });
    $faster_btn->g_bind("<Leave>", sub { $tooltip = ""; $on_btn = ""; });
    $slower_btn->g_bind("<Leave>", sub { $tooltip = ""; $on_btn = ""; });

#   Bindings for keyboard focus. Slightly different if trapping for Shift functions.
    if ($dti_max < 100 && ! $w2profile_data) {
        $strt_btn->g_bind("<FocusIn>",   sub { $strt_btn->configure(-default => 'active');
                                               $tooltip = "To Start"; });
        $bkwd_btn->g_bind("<FocusIn>",   sub { $bkwd_btn->configure(-default => 'active');
                                               $tooltip = "Step Backward"; });
        $rvrs_btn->g_bind("<FocusIn>",   sub { $rvrs_btn->configure(-default => 'active');
                                               $tooltip = ($anim_tb_status eq "reversing") ? "Pause" :
                                                                                             "Reverse"; });
        $stop_btn->g_bind("<FocusIn>",   sub { $stop_btn->configure(-default => 'active');
                                               $tooltip = ($anim_tb_status eq "stopped") ? "" : "Stop"; });
        $play_btn->g_bind("<FocusIn>",   sub { $play_btn->configure(-default => 'active');
                                               $tooltip = ($anim_tb_status eq "playing") ? "Pause":"Play"; });
        $fwd_btn->g_bind("<FocusIn>",    sub { $fwd_btn->configure(-default => 'active');
                                               $tooltip = "Step Forward"; });
        $end_btn->g_bind("<FocusIn>",    sub { $end_btn->configure(-default => 'active');
                                               $tooltip = "To End"; });
        $repeat_btn->g_bind("<FocusIn>", sub { $repeat_btn->configure(-default => 'active');
                                               $tooltip = ($repeat_anim) ? "Repeat: On" : "Repeat: Off"; });
        $faster_btn->g_bind("<FocusIn>", sub { $faster_btn->configure(-default => 'active');
                                               $tooltip = sprintf("Faster (delay %.1fs)", $delay); });
        $slower_btn->g_bind("<FocusIn>", sub { $slower_btn->configure(-default => 'active');
                                               $tooltip = sprintf("Slower (delay %.1fs)", $delay); });
    } else {
        $strt_btn->g_bind("<FocusIn>",   sub { $strt_btn->configure(-default => 'active');
                                               $tooltip = "To Start";
                                               if ($on_btn ne "") {
                                                   $on_btn = "";
                                                   if (Tkx::winfo_pointerx($animate_tb) != -1
                                                         && Tkx::winfo_pointery($animate_tb) != -1) {
                                                       Tkx::event_generate($animate_tb, "<Motion>",
                                                                           -warp => 1, -x => 140, -y => -15);
                                                   }
                                               }
                                             });
        $bkwd_btn->g_bind("<FocusIn>",   sub { $bkwd_btn->configure(-default => 'active');
                                               $tooltip = "Step Backward";
                                               if ($on_btn ne "") {
                                                   $on_btn = "";
                                                   if (Tkx::winfo_pointerx($animate_tb) != -1
                                                         && Tkx::winfo_pointery($animate_tb) != -1) {
                                                       Tkx::event_generate($animate_tb, "<Motion>",
                                                                           -warp => 1, -x => 140, -y => -15);
                                                   }
                                               }
                                             });
        $rvrs_btn->g_bind("<FocusIn>",   sub { $rvrs_btn->configure(-default => 'active');
                                               $tooltip = ($anim_tb_status eq "reversing") ? "Pause" :
                                                                                             "Reverse";
                                               if ($on_btn ne "") {
                                                   $on_btn = "";
                                                   if (Tkx::winfo_pointerx($animate_tb) != -1
                                                         && Tkx::winfo_pointery($animate_tb) != -1) {
                                                       Tkx::event_generate($animate_tb, "<Motion>",
                                                                           -warp => 1, -x => 140, -y => -15);
                                                   }
                                               }
                                             });
        $stop_btn->g_bind("<FocusIn>",   sub { $stop_btn->configure(-default => 'active');
                                               $tooltip = ($anim_tb_status eq "stopped") ? "" : "Stop";
                                               if ($on_btn ne "") {
                                                   $on_btn = "";
                                                   if (Tkx::winfo_pointerx($animate_tb) != -1
                                                         && Tkx::winfo_pointery($animate_tb) != -1) {
                                                       Tkx::event_generate($animate_tb, "<Motion>",
                                                                           -warp => 1, -x => 140, -y => -15);
                                                   }
                                               }
                                             });
        $play_btn->g_bind("<FocusIn>",   sub { $play_btn->configure(-default => 'active');
                                               $tooltip = ($anim_tb_status eq "playing") ? "Pause" : "Play";
                                               if ($on_btn ne "") {
                                                   $on_btn = "";
                                                   if (Tkx::winfo_pointerx($animate_tb) != -1
                                                         && Tkx::winfo_pointery($animate_tb) != -1) {
                                                       Tkx::event_generate($animate_tb, "<Motion>",
                                                                           -warp => 1, -x => 140, -y => -15);
                                                   }
                                               }
                                             });
        $fwd_btn->g_bind("<FocusIn>",    sub { $fwd_btn->configure(-default => 'active');
                                               $tooltip = "Step Forward";
                                               if ($on_btn ne "") {
                                                   $on_btn = "";
                                                   if (Tkx::winfo_pointerx($animate_tb) != -1
                                                         && Tkx::winfo_pointery($animate_tb) != -1) {
                                                       Tkx::event_generate($animate_tb, "<Motion>",
                                                                           -warp => 1, -x => 140, -y => -15);
                                                   }
                                               }
                                             });
        $end_btn->g_bind("<FocusIn>",    sub { $end_btn->configure(-default => 'active');
                                               $tooltip = "To End";
                                               if ($on_btn ne "") {
                                                   $on_btn = "";
                                                   if (Tkx::winfo_pointerx($animate_tb) != -1
                                                         && Tkx::winfo_pointery($animate_tb) != -1) {
                                                       Tkx::event_generate($animate_tb, "<Motion>",
                                                                           -warp => 1, -x => 140, -y => -15);
                                                   }
                                               }
                                             });
        $repeat_btn->g_bind("<FocusIn>", sub { $repeat_btn->configure(-default => 'active');
                                               $tooltip = ($repeat_anim) ? "Repeat: On" : "Repeat: Off";
                                               if ($on_btn ne "") {
                                                   $on_btn = "";
                                                   if (Tkx::winfo_pointerx($animate_tb) != -1
                                                         && Tkx::winfo_pointery($animate_tb) != -1) {
                                                       Tkx::event_generate($animate_tb, "<Motion>",
                                                                           -warp => 1, -x => 140, -y => -15);
                                                   }
                                               }
                                             });
        $faster_btn->g_bind("<FocusIn>", sub { $faster_btn->configure(-default => 'active');
                                               $tooltip = sprintf("Faster (delay %.1fs)", $delay);
                                               if ($on_btn ne "") {
                                                   $on_btn = "";
                                                   if (Tkx::winfo_pointerx($animate_tb) != -1
                                                         && Tkx::winfo_pointery($animate_tb) != -1) {
                                                       Tkx::event_generate($animate_tb, "<Motion>",
                                                                           -warp => 1, -x => 140, -y => -15);
                                                   }
                                               }
                                             });
        $slower_btn->g_bind("<FocusIn>", sub { $slower_btn->configure(-default => 'active');
                                               $tooltip = sprintf("Slower (delay %.1fs)", $delay);
                                               if ($on_btn ne "") {
                                                   $on_btn = "";
                                                   if (Tkx::winfo_pointerx($animate_tb) != -1
                                                         && Tkx::winfo_pointery($animate_tb) != -1) {
                                                       Tkx::event_generate($animate_tb, "<Motion>",
                                                                           -warp => 1, -x => 140, -y => -15);
                                                   }
                                               }
                                             });
    }
    $tb_scale->g_bind("<FocusIn>",    sub { $tooltip = ""; });

    $strt_btn->g_bind("<FocusOut>",   sub { $strt_btn->configure(-default   => 'normal'); });
    $bkwd_btn->g_bind("<FocusOut>",   sub { $bkwd_btn->configure(-default   => 'normal'); });
    $rvrs_btn->g_bind("<FocusOut>",   sub { $rvrs_btn->configure(-default   => 'normal'); });
    $stop_btn->g_bind("<FocusOut>",   sub { $stop_btn->configure(-default   => 'normal'); });
    $play_btn->g_bind("<FocusOut>",   sub { $play_btn->configure(-default   => 'normal'); });
    $fwd_btn->g_bind("<FocusOut>",    sub { $fwd_btn->configure(-default    => 'normal'); });
    $end_btn->g_bind("<FocusOut>",    sub { $end_btn->configure(-default    => 'normal'); });
    $repeat_btn->g_bind("<FocusOut>", sub { $repeat_btn->configure(-default => 'normal'); });
    $faster_btn->g_bind("<FocusOut>", sub { $faster_btn->configure(-default => 'normal'); });
    $slower_btn->g_bind("<FocusOut>", sub { $slower_btn->configure(-default => 'normal'); });

#   Bindings to restore button shape after keyboard input is sustained
    $strt_btn->g_bind("<KeyPress>",   [\&restore_btn, Tkx::Ev("%k"), $strt_btn   ]);
    $bkwd_btn->g_bind("<KeyPress>",   [\&restore_btn, Tkx::Ev("%k"), $bkwd_btn   ]);
    $rvrs_btn->g_bind("<KeyPress>",   [\&restore_btn, Tkx::Ev("%k"), $rvrs_btn   ]);
    $stop_btn->g_bind("<KeyPress>",   [\&restore_btn, Tkx::Ev("%k"), $stop_btn   ]);
    $play_btn->g_bind("<KeyPress>",   [\&restore_btn, Tkx::Ev("%k"), $play_btn   ]);
    $fwd_btn->g_bind("<KeyPress>",    [\&restore_btn, Tkx::Ev("%k"), $fwd_btn    ]);
    $end_btn->g_bind("<KeyPress>",    [\&restore_btn, Tkx::Ev("%k"), $end_btn    ]);
    $repeat_btn->g_bind("<KeyPress>", [\&restore_btn, Tkx::Ev("%k"), $repeat_btn ]);
    $faster_btn->g_bind("<KeyPress>", [\&restore_btn, Tkx::Ev("%k"), $faster_btn ]);
    $slower_btn->g_bind("<KeyPress>", [\&restore_btn, Tkx::Ev("%k"), $slower_btn ]);

#   Bindings for Shift inputs on the faster and slower buttons, if necessary
    if ($dti_max >= 100) {
        $faster_btn->g_bind("<Enter>", sub { $on_btn  = "faster";
                                             $tooltip = sprintf("Faster (delay %.1fs)", $delay);
                                             $animate_tb->g_focus;
                                           });
        $slower_btn->g_bind("<Enter>", sub { $on_btn  = "slower";
                                             $tooltip = sprintf("Slower (delay %.1fs)", $delay);
                                             $animate_tb->g_focus;
                                           });
        $faster_btn->g_bind("<Shift-space>",    sub { $on_btn  = "ShiftSpaceFaster"; });
        $slower_btn->g_bind("<Shift-space>",    sub { $on_btn  = "ShiftSpaceSlower"; });
        $faster_btn->g_bind("<Shift-Button-1>", sub { $on_btn  = "ShiftBtnFaster";   });
        $slower_btn->g_bind("<Shift-Button-1>", sub { $on_btn  = "ShiftBtnSlower";   });
        $faster_btn->g_bind("<Shift-Enter>",    sub { $tooltip = sprintf("Faster (skip date: %d)",$delta_dti);
                                                      $on_btn  = "faster"; });
        $slower_btn->g_bind("<Shift-Enter>",    sub { $tooltip = sprintf("Slower (skip date: %d)",$delta_dti);
                                                      $on_btn  = "slower"; });

        $faster_btn->g_bind("<Shift_L>", sub { $tooltip = sprintf("Faster (skip date: %d)", $delta_dti); });
        $faster_btn->g_bind("<Shift_R>", sub { $tooltip = sprintf("Faster (skip date: %d)", $delta_dti); });
        $slower_btn->g_bind("<Shift_L>", sub { $tooltip = sprintf("Slower (skip date: %d)", $delta_dti); });
        $slower_btn->g_bind("<Shift_R>", sub { $tooltip = sprintf("Slower (skip date: %d)", $delta_dti); });

        $faster_btn->g_bind("<KeyRelease-Shift_L>", sub { $tooltip = sprintf("Faster (delay %.1fs)",$delay);
                                                          $on_btn  = "faster"; });
        $faster_btn->g_bind("<KeyRelease-Shift_R>", sub { $tooltip = sprintf("Faster (delay %.1fs)",$delay);
                                                          $on_btn  = "faster"; });
        $slower_btn->g_bind("<KeyRelease-Shift_L>", sub { $tooltip = sprintf("Slower (delay %.1fs)",$delay);
                                                          $on_btn  = "slower"; });
        $slower_btn->g_bind("<KeyRelease-Shift_R>", sub { $tooltip = sprintf("Slower (delay %.1fs)",$delay);
                                                          $on_btn  = "slower"; });

        $animate_tb->g_bind("<Shift_L>", sub { if ($on_btn =~ /faster/i) {
                                                   $tooltip = sprintf("Faster (skip date: %d)", $delta_dti);
                                               } elsif ($on_btn =~ /slower/i) {
                                                   $tooltip = sprintf("Slower (skip date: %d)", $delta_dti);
                                               }
                                             });
        $animate_tb->g_bind("<Shift_R>", sub { if ($on_btn =~ /faster/i) {
                                                   $tooltip = sprintf("Faster (skip date: %d)", $delta_dti);
                                               } elsif ($on_btn =~ /slower/i) {
                                                   $tooltip = sprintf("Slower (skip date: %d)", $delta_dti);
                                               }
                                             });
        $animate_tb->g_bind("<KeyRelease-Shift_L>",
                                         sub { if ($on_btn =~ /faster/i) {
                                                   $tooltip = sprintf("Faster (delay %.1fs)", $delay);
                                                   $on_btn  = "faster";
                                               } elsif ($on_btn =~ /slower/i) {
                                                   $tooltip = sprintf("Slower (delay %.1fs)", $delay);
                                                   $on_btn  = "slower";
                                               }
                                             });
        $animate_tb->g_bind("<KeyRelease-Shift_R>",
                                         sub { if ($on_btn =~ /faster/i) {
                                                   $tooltip = sprintf("Faster (delay %.1fs)", $delay);
                                                   $on_btn  = "faster";
                                               } elsif ($on_btn =~ /slower/i) {
                                                   $tooltip = sprintf("Slower (delay %.1fs)", $delay);
                                                   $on_btn  = "slower";
                                               }
                                             });
    }

#   Add more bindings if measured profiles are available for W2 Profile graphs
    if ($w2profile_data) {
        $bkwd_btn->g_bind("<Enter>", sub { $tooltip = "Step Backward";
                                           $on_btn  = "bkwd";
                                           $animate_tb->g_focus; });
        $fwd_btn->g_bind("<Enter>",  sub { $tooltip = "Step Forward";
                                           $on_btn  = "fwd";
                                           $animate_tb->g_focus; });

        $bkwd_btn->g_bind("<Shift-space>", sub { $on_btn = "ShiftSpaceBkwd"; });
        $fwd_btn->g_bind("<Shift-space>",  sub { $on_btn = "ShiftSpaceFwd";  });

        $bkwd_btn->g_bind("<Shift-Button-1>", sub { $on_btn = "ShiftBtnBkwd"; });
        $fwd_btn->g_bind("<Shift-Button-1>",  sub { $on_btn = "ShiftBtnFwd";  });

        $bkwd_btn->g_bind("<Shift-Enter>", sub { $tooltip = "To Previous Profile";
                                                 $on_btn  = "bkwd"; });
        $fwd_btn->g_bind("<Shift-Enter>",  sub { $tooltip = "To Next Profile";
                                                 $on_btn  = "fwd";  });

        $bkwd_btn->g_bind("<Shift_L>",     sub { $tooltip = "To Previous Profile"; });
        $bkwd_btn->g_bind("<Shift_R>",     sub { $tooltip = "To Previous Profile"; });
        $fwd_btn->g_bind("<Shift_L>",      sub { $tooltip = "To Next Profile";  });
        $fwd_btn->g_bind("<Shift_R>",      sub { $tooltip = "To Next Profile";  });

        $animate_tb->g_bind("<Shift_L>",   sub { if ($on_btn eq "bkwd") {
                                                     $tooltip = "To Previous Profile";
                                                 } elsif ($on_btn eq "fwd") {
                                                     $tooltip = "To Next Profile";
                                                 } elsif ($on_btn =~ /faster/i && $dti_max >= 100) {
                                                     $tooltip = sprintf("Faster (skip date: %d)", $delta_dti);
                                                 } elsif ($on_btn =~ /slower/i && $dti_max >= 100) {
                                                     $tooltip = sprintf("Slower (skip date: %d)", $delta_dti);
                                                 }
                                               });
        $animate_tb->g_bind("<Shift_R>",   sub { if ($on_btn eq "bkwd") {
                                                     $tooltip = "To Previous Profile";
                                                 } elsif ($on_btn eq "fwd") {
                                                     $tooltip = "To Next Profile";
                                                 } elsif ($on_btn =~ /faster/i && $dti_max >= 100) {
                                                     $tooltip = sprintf("Faster (skip date: %d)", $delta_dti);
                                                 } elsif ($on_btn =~ /slower/i && $dti_max >= 100) {
                                                     $tooltip = sprintf("Slower (skip date: %d)", $delta_dti);
                                                 }
                                               });

        $bkwd_btn->g_bind("<KeyRelease-Shift_L>",  sub { $tooltip = "Step Backward"; $on_btn = "bkwd"; });
        $bkwd_btn->g_bind("<KeyRelease-Shift_R>",  sub { $tooltip = "Step Backward"; $on_btn = "bkwd"; });
        $fwd_btn->g_bind("<KeyRelease-Shift_L>",   sub { $tooltip = "Step Forward";  $on_btn = "fwd";  });
        $fwd_btn->g_bind("<KeyRelease-Shift_R>",   sub { $tooltip = "Step Forward";  $on_btn = "fwd";  });

        $animate_tb->g_bind("<KeyRelease-Shift_L>",
                                           sub { if ($on_btn eq "bkwd") {
                                                     $tooltip = "Setp Backward";
                                                 } elsif ($on_btn eq "fwd") {
                                                     $tooltip = "Step Forward";
                                                 } elsif ($on_btn =~ /faster/i && $dti_max >= 100) {
                                                     $tooltip = sprintf("Faster (delay %.1fs)", $delay);
                                                     $on_btn  = "faster";
                                                 } elsif ($on_btn =~ /slower/i && $dti_max >= 100) {
                                                     $tooltip = sprintf("Slower (delay %.1fs)", $delay);
                                                     $on_btn  = "slower";
                                                 }
                                               });
        $animate_tb->g_bind("<KeyRelease-Shift_R>",
                                           sub { if ($on_btn eq "bkwd") {
                                                     $tooltip = "Setp Backward";
                                                 } elsif ($on_btn eq "fwd") {
                                                     $tooltip = "Step Forward";
                                                 } elsif ($on_btn =~ /faster/i && $dti_max >= 100) {
                                                     $tooltip = sprintf("Faster (delay %.1fs)", $delay);
                                                     $on_btn  = "faster";
                                                 } elsif ($on_btn =~ /slower/i && $dti_max >= 100) {
                                                     $tooltip = sprintf("Slower (delay %.1fs)", $delay);
                                                     $on_btn  = "slower";
                                                 }
                                               });
    }

    Tkx::wm_resizable($animate_tb,0,0);
    &adjust_window_position($animate_tb);
    $animate_tb->g_focus;
}


sub restore_btn {
    my ($k, $btn) = @_;
    if ($k == 32) {
        Tkx::update_idletasks();
        $btn->configure(-relief => 'raised');
    }
}


sub next_profile_dti {
    my ($direction) = @_;
    my ($dt_indx, $i);

    $dt_indx = $dti;
    if ($direction eq "fwd") {
        if ($dt_indx >= $dtis_with_pdata[-1]) {
            $dt_indx = $dtis_with_pdata[0] if ($repeat_anim);
        } else {
            for ($i=0; $i<=$#dtis_with_pdata; $i++) {
                next if ($dtis_with_pdata[$i] <= $dt_indx);
                $dt_indx = $dtis_with_pdata[$i];
                last;
            }
        }
    } else {
        if ($dt_indx <= $dtis_with_pdata[0]) {
            $dt_indx = $dtis_with_pdata[-1] if ($repeat_anim);
        } else {
            for ($i=$#dtis_with_pdata; $i>=0; $i--) {
                next if ($dtis_with_pdata[$i] >= $dt_indx);
                $dt_indx = $dtis_with_pdata[$i];
                last;
            }
        }
    }
    return $dt_indx;
}


sub get_animation_date {
    my ($frame_label, $date_label);

    $frame_label = "Frame $dti of $dti_max";
    $date_label  = &get_formatted_date($dates[$dti-1]);
    return ($frame_label, $date_label);
}


sub update_animate {
    my ($date_label) = @_;
    my (
        $add_pt0, $add_pt3, $anc, $base_jd, $blank_img, $bot, $cmap_image,
        $cs_max, $cs_min, $cs_range, $diff, $do_calcs, $dt, $dt_parm,
        $dt_parm2, $dt2, $dy, $el_limit, $el1, $el2, $el3, $elev, $first,
        $flow, $flow_data, $found, $got_depth, $group_tags, $gtag, $height,
        $jj, $i, $id, $id2, $ih, $in_yrange, $iw, $j, $j2, $j3, $j4, $jb,
        $jd, $jd_max, $jd_min, $k, $kalt, $kbot, $kmx, $kt, $kt_parm,
        $last_xp, $last_yp, $lastpt, $link_id, $mi, $msg, $mult, $n, $nbr,
        $nlayers, $nout, $np, $ns, $nww, $ok2animate, $old_elev, $pt1_in,
        $pt2_in, $pval, $pval1, $pval2, $pval3, $pval4, $qmult, $qsum,
        $seg, $surf_elev, $tag, $tol, $top, $tout, $ts_state, $tsum, $val,
        $wsel, $wt, $wt_max, $wt_min, $wt1, $wt2, $wt3, $x1, $x2, $xbase,
        $xd1, $xd2, $xmax, $xmin, $xmult, $xp, $xp0, $xp1, $xp2, $xp3,
        $xrange, $y1, $y2, $ymax, $ymin, $yp, $yp0, $yp1, $yp1i, $yp2,
        $yp3, $yp3i, $yp4, $yp4i, $ypi, $yrange, $yval,

        @b, @color, @colors, @coords, @depths, @ds, @el, @elevations,
        @estimated, @estr, @flows, @grp_tags, @items, @kb, @kbsw, @ktsw, @lw,
        @names, @noutlets, @nslots, @pdata, @pt_color, @pt_elevations, @qout,
        @qstr, @qtot, @rho, @scale, @seglist, @show, @slope, @sw_alg, @t,
        @tags, @tmp, @tstr, @us, @valid_elevs, @valid_temps, @valid_pdata,
        @vtot, @wtemps, @ww_names, @xdist,

        %bh_parms, %ds_parms, %elev_data, %kt_data, %parm_data, %parms,
        %qdata, %qtot_data, %tdata, %temps, %vdata, %vtot_data, %wl_data,
        %wsurf,
       );

#   Loop over each graph and do the appropriate animation
    foreach $id (@animate_ids) {
        next if ($props{$id}{meta} eq "w2_tdmap");            # No animation for time/distance maps
        next if ($props{$id}{meta} eq "w2_profile_matrix");   # No animation for W2 profile matrix plots

        $dt   = $dates[$dti-1];   # set each time, in case it is modified
        $gtag = "graph" . $id;

#       Determine whether group tags are present and save the list
        $group_tags = 0;
        @grp_tags   = ();
        @tags       = Tkx::SplitList($canvas->itemcget($id, -tags));
        if (&list_search("group_", @tags) > -1) {
            $group_tags = 1;
            foreach $tag (@tags) {
                push (@grp_tags, $tag) if ($tag =~ /^group_/);
            }
        }

#       For a W2 longitudinal slice, just swap the colormap frames
        if ($props{$id}{meta} eq "w2_slice") {
            $canvas->delete($gtag . "_noData");
            if (defined($gr_props{$id}{slice_img}{$dt})) {
                $canvas->itemconfigure($gtag . "_date",     -text  => $date_label);
                $canvas->itemconfigure($gtag . "_colorMap", -image => $gr_props{$id}{slice_img}{$dt});
            } else {
                for ($mi=1; $mi<=10; $mi++) {
                    $dt2 = &adjust_dt($dt, $mi);
                    if (defined($gr_props{$id}{slice_img}{$dt2})) {
                        $dt = $dt2;
                        last;
                    }
                    $dt2 = &adjust_dt($dt, -1 *$mi);
                    if (defined($gr_props{$id}{slice_img}{$dt2})) {
                        $dt = $dt2;
                        last;
                    }
                }
                if ($dt != $dates[$dti-1]) {
                    $canvas->itemconfigure($gtag . "_date",     -text  => &get_formatted_date($dt));
                    $canvas->itemconfigure($gtag . "_colorMap", -image => $gr_props{$id}{slice_img}{$dt});
                } else {
                    ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
                    $blank_img = Tkx::image_create_photo(-width => $x2-$x1+1, -height => $y2-$y1+1);
                    $canvas->itemconfigure($gtag . "_date",     -text  => $date_label);
                    $canvas->itemconfigure($gtag . "_colorMap", -image => $blank_img);
                    $canvas->create_text(($x1+$x2)/2, ($y1+$y2)/2,
                                       -anchor => 'center', 
                                       -text   => "No Data",
                                       -fill   => &get_rgb_code("gray60"),
                                       -angle  => 0,
                                       -tags   => $gtag . " " . $gtag . "_noData",
                                       -font   => [-family     => $gr_props{$id}{xfont},
                                                   -size       => $gr_props{$id}{xl_size},
                                                   -weight     => 'normal',
                                                   -slant      => 'roman',
                                                   -underline  => 0,
                                                   -overstrike => 0,
                                                  ]);
                    $canvas->lower($gtag . "_noData", $gtag . "_xaxis");
                    if ($group_tags) {
                        foreach $tag (@grp_tags) {
                            $canvas->addtag($tag, withtag => $gtag . "_noData");
                        }
                    }
                    undef $blank_img;
                }
            }
#xxx        &update_links($canvas, $id, $dt);
            next;
        }

#       Okay to do a simple animation for a colormap
#       in conjunction with a paired temperature profile
        if ($props{$id}{meta} =~ /(data_profile_cmap|w2_profile_cmap|time_series)/) {
            return if ($#animate_ids == 0);
            $ok2animate = ($gr_props{$id}{dateline}) ? 1 : 0;
            if (! $ok2animate && $props{$id}{meta} eq "linked_time_series") {
                for ($i=0; $i<=$#animate_ids; $i++) {
                    $id2 = $animate_ids[$i];
                    next if ($id2 == $id);
                    if ($props{$id2}{meta}
                           =~ /^(data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)$/) {
                        if ($props{$id}{link_id} == $id2) {
                            $ok2animate = 1;
                            last;
                        }
                    }
                }
            }
            next if (! $ok2animate);

            $jd = &date2jdate($dt);
            if ($gr_props{$id}{xtype} eq "Date/Time") {
                $jd_min = &datelabel2jdate($gr_props{$id}{xmin});
                $jd_max = &datelabel2jdate($gr_props{$id}{xmax});
            } else {
                $base_jd = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
                $jd_min  = $gr_props{$id}{xmin} +$base_jd -1;
                $jd_max  = $gr_props{$id}{xmax} +$base_jd -1;
            }
            if ($props{$id}{meta} =~ /profile_cmap/) {
                $canvas->delete($gtag . "_colorMapDateline");
            } elsif ($props{$id}{meta} eq "time_series") {
                $canvas->delete($gtag . "_dateline");
            } elsif ($props{$id}{meta} eq "linked_time_series") {
                $canvas->delete($gtag . "_dateline");
                $canvas->delete($gtag . "_datePoint");
            }
            next if ($jd <= $jd_min || $jd >= $jd_max);

            ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
            $xp = $x1 +($x2 -$x1) *($jd -$jd_min) /($jd_max -$jd_min);

#           For profile colormaps and time-series plots, draw a vertical line at the current date
            if ($props{$id}{meta} =~ /profile_cmap/ && $gr_props{$id}{dateline}) {
                $canvas->create_line($xp, $y1, $xp, $y2,
                                 -fill  => &get_rgb_code($gr_props{$id}{datelinec}),
                                 -width => 1,
                                 -arrow => 'none',
                                 -tags  => $gtag . " " . $gtag . "_colorMapDateline");
                $canvas->lower($gtag . "_colorMapDateline", $gtag . "_xaxis");
                if ($group_tags) {
                    foreach $tag (@grp_tags) {
                        $canvas->addtag($tag, withtag => $gtag . "_colorMapDateline");
                    }
                }
            } elsif ($props{$id}{meta} =~ /time_series/ && $gr_props{$id}{dateline}) {
                $canvas->create_line($xp, $y1, $xp, $y2,
                                 -fill  => &get_rgb_code($gr_props{$id}{datelinec}),
                                 -width => 1,
                                 -arrow => 'none',
                                 -tags  => $gtag . " " . $gtag . "_dateline");
                $canvas->lower($gtag . "_dateline", $gtag . "_xaxis");
                @items = Tkx::SplitList($canvas->find_withtag($gtag . "_legend"));
                if ($#items >= 0) {
                    $canvas->lower($gtag . "_dateline", $gtag . "_legend");
                }
                @items = Tkx::SplitList($canvas->find_withtag($gtag . "_legendBox"));
                if ($#items >= 0) {
                    $canvas->lower($gtag . "_dateline", $gtag . "_legendBox");
                }
                if ($group_tags) {
                    foreach $tag (@grp_tags) {
                        $canvas->addtag($tag, withtag => $gtag . "_dateline");
                    }
                }
            }

#           For linked time-series plots, highlight the points at current date
            if ($props{$id}{meta} eq "linked_time_series") {
                $link_id = $props{$id}{link_id};
                %parms   = %{ $props{$id}{ts_parms} };
                @show    = @{ $parms{show}  };
                @color   = @{ $parms{color} };
                $ymin    = $gr_props{$id}{ymin};
                $ymax    = $gr_props{$id}{ymax};

                if ($parms{ts_type} eq "Water Surface Elevation") {
                    if ($props{$link_id}{meta} =~ /^(data_profile|vert_wd_zone)$/) {
                        %wsurf = %{ $gr_props{$link_id}{ws_elev} };
                    } elsif ($props{$link_id}{meta} eq "w2_profile") {
                        %wsurf = %{ $gr_props{$link_id}{elev_data} };
                    } elsif ($props{$link_id}{meta} eq "w2_outflow") {
                        %qdata = %{ $gr_props{$link_id}{qdata} };
                        %wsurf = ();
                        if (defined($qdata{$dt})) {
                            @flows = @{ $qdata{$dt} };
                            $wsurf{$dt} = $flows[1];
                            undef @flows;
                        } else {
                            $wsurf{$dt} = "na";
                        }
                        undef %qdata;
                    }

#                   Adjust dt, if needed.
                    if ($props{$link_id}{meta} =~ /^(data_profile|vert_wd_zone)$/) {
                        if (length($dt) == 12) {
                            if ($gr_props{$link_id}{daily}) {
                                $dt = substr($dt,0,8);
                            } elsif (! defined($wsurf{$dt})) {
                                for ($mi=1; $mi<=10; $mi++) {
                                    $dt2 = &adjust_dt($dt, $mi);
                                    if (defined($wsurf{$dt2})) {
                                        $dt = $dt2;
                                        last;
                                    }
                                    $dt2 = &adjust_dt($dt, -1 *$mi);
                                    if (defined($wsurf{$dt2})) {
                                        $dt = $dt2;
                                        last;
                                    }
                                }
                            }
                        }
                    } else {
                        if (! defined($wsurf{$dt})) {
                            for ($mi=1; $mi<=10; $mi++) {
                                $dt2 = &adjust_dt($dt, $mi);
                                if (defined($wsurf{$dt2})) {
                                    $dt = $dt2;
                                    last;
                                }
                                $dt2 = &adjust_dt($dt, -1 *$mi);
                                if (defined($wsurf{$dt2})) {
                                    $dt = $dt2;
                                    last;
                                }
                            }
                        }
                    }
                    if (defined($wsurf{$dt}) && $wsurf{$dt} ne "na") {
                        $surf_elev  = $wsurf{$dt};
                        $surf_elev *= 3.28084 if ($parms{units} eq "ft");
                        $yp = $y2 -($y2 -$y1) *($surf_elev -$ymin) /($ymax -$ymin);
                        $yp = &min($y2, &max($y1, $yp));
                        $canvas->create_oval($xp-3, $yp-3, $xp+3, $yp+3,
                                        -outline => "#000000",
                                        -width   => 1,
                                        -fill    => &get_rgb_code($color[0]),
                                        -tags    => $gtag . " " . $gtag . "_tsData"
                                                          . " " . $gtag . "_datePoint"
                                                          . " " . $gtag . "_dataPoint0");
                    }
                    undef %wsurf;

                } elsif ($parms{ts_type} eq "Release Rate") {
                    %qdata = %{ $gr_props{$link_id}{qdata} };

#                   Adjust dt, if needed. Link_id is vert_wd_zone.
                    if ($props{$link_id}{meta} eq "vert_wd_zone") {
                        @names = @{ $gr_props{$link_id}{names} };
                        push (@names, "All Outlets");
                        if (length($dt) == 12) {
                            if ($gr_props{$link_id}{daily}) {
                                $dt = substr($dt,0,8);
                            } elsif (! defined($qdata{$dt})) {
                                for ($mi=1; $mi<=10; $mi++) {
                                    $dt2 = &adjust_dt($dt, $mi);
                                    if (defined($qdata{$dt2})) {
                                        $dt = $dt2;
                                        last;
                                    }
                                    $dt2 = &adjust_dt($dt, -1 *$mi);
                                    if (defined($qdata{$dt2})) {
                                        $dt = $dt2;
                                        last;
                                    }
                                }
                            }
                        }
                    } else {
                        @names = ("All Outlets");
                        if (! defined($qdata{$dt})) {
                            for ($mi=1; $mi<=10; $mi++) {
                                $dt2 = &adjust_dt($dt, $mi);
                                if (defined($qdata{$dt2})) {
                                    $dt = $dt2;
                                    last;
                                }
                                $dt2 = &adjust_dt($dt, -1 *$mi);
                                if (defined($qdata{$dt2})) {
                                    $dt = $dt2;
                                    last;
                                }
                            }
                        }
                    }
                    for ($n=0; $n<=$#names; $n++) {
                        $ts_state = ($show[$n]) ? 'normal' : 'hidden';
                        if (defined($qdata{$dt})) {
                            @qstr = @{ $qdata{$dt} };
                            if ($props{$link_id}{meta} eq "w2_outflow") {
                                $flow = $qstr[0];
                            } else {
                                if ($names[$n] eq "All Outlets") {
                                    $flow = &sum(@qstr);
                                } else {
                                    $flow = $qstr[$n];
                                }
                            }
                            $flow *= 35.31467 if ($parms{units} eq "cfs");
                            $yp = $y2 -($y2 -$y1) *($flow -$ymin) /($ymax -$ymin);
                            $yp = &min($y2, &max($y1, $yp));
                            $canvas->create_oval($xp-3, $yp-3, $xp+3, $yp+3,
                                            -outline => "#000000",
                                            -width   => 1,
                                            -fill    => &get_rgb_code($color[$n]),
                                            -state   => $ts_state,
                                            -tags    => $gtag . " " . $gtag . "_tsData"
                                                              . " " . $gtag . "_datePoint"
                                                              . " " . $gtag . "_dataPoint" . $n);
                        }
                    }
                    undef %qdata;

                } elsif ($parms{ts_type} eq "Temperature") {
                    %tdata = %{ $gr_props{$link_id}{tdata} };
                    @names = @{ $gr_props{$link_id}{names} };
                    push (@names, "All Outlets");

#                   Adjust dt, if needed. Link_id is vert_wd_zone.
                    if (length($dt) == 12) {
                        if ($gr_props{$link_id}{daily}) {
                            $dt = substr($dt,0,8);
                        } elsif (! defined($tdata{$dt})) {
                            for ($mi=1; $mi<=10; $mi++) {
                                $dt2 = &adjust_dt($dt, $mi);
                                if (defined($tdata{$dt2})) {
                                    $dt = $dt2;
                                    last;
                                }
                                $dt2 = &adjust_dt($dt, -1 *$mi);
                                if (defined($tdata{$dt2})) {
                                    $dt = $dt2;
                                    last;
                                }
                            }
                        }
                    }
                    for ($n=0; $n<=$#names; $n++) {
                        $ts_state = ($show[$n]) ? 'normal' : 'hidden';
                        if (defined($tdata{$dt})) {
                            @tstr = @{ $tdata{$dt} };
                            $wt   = $tstr[$n];
                            if ($wt > -99) {
                                $wt = 1.8 *$wt +32 if ($parms{units} eq "Fahrenheit");
                                $yp = $y2 -($y2 -$y1) *($wt -$ymin) /($ymax -$ymin);
                                $yp = &min($y2, &max($y1, $yp));
                                $canvas->create_oval($xp-3, $yp-3, $xp+3, $yp+3,
                                                -outline => "#000000",
                                                -width   => 1,
                                                -fill    => &get_rgb_code($color[$n]),
                                                -state   => $ts_state,
                                                -tags    => $gtag . " " . $gtag . "_tsData"
                                                                  . " " . $gtag . "_datePoint"
                                                                  . " " . $gtag . "_dataPoint" . $n);
                            }
                        }
                    }
                    undef %tdata;
                }
                $canvas->lower($gtag . "_datePoint", $id);
                if ($group_tags) {
                    foreach $tag (@grp_tags) {
                        $canvas->addtag($tag, withtag => $gtag . "_datePoint");
                    }
                }
                undef %parms;
            }
            next;
        }

#       The remainder of this subroutine deals with the other animated graphs:
#         data_profile, vert_wd_zone, w2_profile, w2_outflow, w2_wlevels
        ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };

#       Delete the old profile and set up variables
        $canvas->delete($gtag . "_profile");
        $canvas->delete($gtag . "_colorProfile");
        $canvas->delete($gtag . "_refData");
        $canvas->delete($gtag . "_wlevels");

#       Populate some common hashes
        if ($props{$id}{meta} eq "data_profile") {
            %parm_data = %{ $gr_props{$id}{pdata}   };
            %wsurf     = %{ $gr_props{$id}{ws_elev} };
        } elsif ($props{$id}{meta} eq "vert_wd_zone") {
            %temps = %{ $gr_props{$id}{pdata}   };
            %wsurf = %{ $gr_props{$id}{ws_elev} };
        } elsif ($props{$id}{meta} eq "w2_profile") {
            %kt_data   = %{ $gr_props{$id}{kt_data}   };
            %elev_data = %{ $gr_props{$id}{elev_data} };
            %parm_data = %{ $gr_props{$id}{parm_data} };
        } elsif ($props{$id}{meta} eq "w2_outflow") {
            %qdata = %{ $gr_props{$id}{qdata} };
            %vdata = %{ $gr_props{$id}{vdata} };
            if ($props{$id}{add_parm} && $gr_props{$id}{add_cs}) {
                %kt_data   = %{ $gr_props{$id}{kt_data}   };
                %parm_data = %{ $gr_props{$id}{parm_data} };
            }
        } elsif ($props{$id}{meta} eq "w2_wlevels") {
            %wl_data = %{ $gr_props{$id}{wl_data} };
        }

#       Plot the number of bulkhead openings, if asked
        if ($props{$id}{meta} eq "vert_wd_zone") {
            if ($props{$id}{wd_alg} eq "Libby Dam" && $gr_props{$id}{bh_show}) {
                $bh_parms{ymin}      = $gr_props{$id}{ymin};
                $bh_parms{ymax}      = $gr_props{$id}{ymax};
                $bh_parms{ytype}     = $gr_props{$id}{ytype};
                $bh_parms{yunits}    = $gr_props{$id}{yunits};
                $bh_parms{num_ww}    = $gr_props{$id}{num_ww};
                $bh_parms{ww_names}  = $gr_props{$id}{ww_names};
                $bh_parms{num_rows}  = $gr_props{$id}{num_rows};
                $bh_parms{bh_height} = $gr_props{$id}{bh_height};  # meters
                $bh_parms{base_elev} = $gr_props{$id}{base_elev};  # meters
                $bh_parms{surf_elev} = $wsurf{$dt};                # meters
                $bh_parms{bh_miss}   = $gr_props{$id}{bh_miss};
                $bh_parms{bh_font}   = $gr_props{$id}{bh_font};
                $bh_parms{bh_size}   = $gr_props{$id}{bh_size};
                $bh_parms{bh_weight} = $gr_props{$id}{bh_weight};
                $bh_parms{bh_tcolor} = $gr_props{$id}{bh_tcolor};
                $bh_parms{bh_bwidth} = $gr_props{$id}{bh_bwidth};
                $bh_parms{bh_bcolor} = $gr_props{$id}{bh_bcolor};
                $bh_parms{bh_bcellw} = $gr_props{$id}{bh_bcellw};
                $bh_parms{bh_docked} = $gr_props{$id}{bh_docked};
                $bh_parms{bh_xpos}   = $gr_props{$id}{bh_xpos};
                $bh_parms{bh_ypos}   = $gr_props{$id}{bh_ypos};
                $bh_parms{bh_bcellh} = $gr_props{$id}{bh_bcellh};

                $canvas->delete($gtag . "_openBH");
                &make_bulkhead_graphic($canvas, $id, $dt, %bh_parms);
                undef %bh_parms;
                $canvas->lower($gtag . "_openBH", $id);
            }
        }

#       Adjust target date to daily, or by up to 10 minutes, if needed
        if ($props{$id}{meta} =~ /^(data_profile|vert_wd_zone)$/) {
            if (length($dt) == 12) {
                if ($gr_props{$id}{daily}) {
                    $dt = substr($dt,0,8);
                } elsif ($props{$id}{meta} eq "data_profile") {
                    if (! defined($parm_data{$dt})) {
                        for ($mi=1; $mi<=10; $mi++) {
                            $dt2 = &adjust_dt($dt, $mi);
                            if (defined($parm_data{$dt2})) {
                                $dt = $dt2;
                                last;
                            }
                            $dt2 = &adjust_dt($dt, -1 *$mi);
                            if (defined($parm_data{$dt2})) {
                                $dt = $dt2;
                                last;
                            }
                        }
                    }
                } elsif ($props{$id}{meta} eq "vert_wd_zone") {
                    if (! defined($temps{$dt})) {
                        for ($mi=1; $mi<=10; $mi++) {
                            $dt2 = &adjust_dt($dt, $mi);
                            if (defined($temps{$dt2})) {
                                $dt = $dt2;
                                last;
                            }
                            $dt2 = &adjust_dt($dt, -1 *$mi);
                            if (defined($temps{$dt2})) {
                                $dt = $dt2;
                                last;
                            }
                        }
                    }
                }
            }
        } elsif ($props{$id}{meta} eq "w2_profile") {
            if (! defined($parm_data{$dt})) {
                for ($mi=1; $mi<=10; $mi++) {
                    $dt2 = &adjust_dt($dt, $mi);
                    if (defined($parm_data{$dt2})) {
                        $dt = $dt2;
                        last;
                    }
                    $dt2 = &adjust_dt($dt, -1 *$mi);
                    if (defined($parm_data{$dt2})) {
                        $dt = $dt2;
                        last;
                    }
                }
            }
        } elsif ($props{$id}{meta} eq "w2_outflow") {
            if (! defined($qdata{$dt})) {
                for ($mi=1; $mi<=10; $mi++) {
                    $dt2 = &adjust_dt($dt, $mi);
                    if (defined($qdata{$dt2})) {
                        $dt = $dt2;
                        last;
                    }
                    $dt2 = &adjust_dt($dt, -1 *$mi);
                    if (defined($qdata{$dt2})) {
                        $dt = $dt2;
                        last;
                    }
                }
            }
        } elsif ($props{$id}{meta} eq "w2_wlevels") {
            if (! defined($wl_data{$dt})) {
                for ($mi=1; $mi<=10; $mi++) {
                    $dt2 = &adjust_dt($dt, $mi);
                    if (defined($wl_data{$dt2})) {
                        $dt = $dt2;
                        last;
                    }
                    $dt2 = &adjust_dt($dt, -1 *$mi);
                    if (defined($wl_data{$dt2})) {
                        $dt = $dt2;
                        last;
                    }
                }
            }
        }

#       Update the date subtitle
        if ($dt != $dates[$dti-1]) {
            $canvas->itemconfigure($gtag . "_date", -text => &get_formatted_date($dt));
        } else {
            $canvas->itemconfigure($gtag . "_date", -text => $date_label);
        }

#       Exit early if data are unavailable on this date
        if (($props{$id}{meta} eq "data_profile"
              && (! defined($wsurf{$dt}) || ! defined($parm_data{$dt})))
           || ($props{$id}{meta} eq "vert_wd_zone"
                && (! defined($wsurf{$dt}) || ! defined($temps{$dt})))
           || ($props{$id}{meta} eq "w2_outflow" && ! defined($qdata{$dt}))
           || ($props{$id}{meta} eq "w2_wlevels" && ! defined($wl_data{$dt}))
           || ($props{$id}{meta} eq "w2_profile"
                && (! defined($elev_data{$dt}) || ! defined($parm_data{$dt})))) {
            if ($props{$id}{meta} eq "w2_wlevels") {
                $tag = $gtag . "_wlevels";
            } else {
                $tag = $gtag . "_profile";
            }
            $canvas->create_text(($x1+$x2)/2, ($y1+$y2)/2,
                               -anchor => 'center', 
                               -text   => "No Data",
                               -fill   => &get_rgb_code("gray60"),
                               -angle  => 0,
                               -tags   => $gtag . " " . $tag,
                               -font   => [-family     => $gr_props{$id}{xfont},
                                           -size       => $gr_props{$id}{xl_size},
                                           -weight     => 'normal',
                                           -slant      => 'roman',
                                           -underline  => 0,
                                           -overstrike => 0,
                                          ]);
            $canvas->lower($tag, $id);
            if ($group_tags) {
                foreach $tag (@grp_tags) {
                    $canvas->addtag($tag, withtag => $tag);
                }
            }

#           Free up some memory before moving on
            if ($props{$id}{meta} eq "data_profile") {
                undef %parm_data;
                undef %wsurf;
            } elsif ($props{$id}{meta} eq "vert_wd_zone") {
                undef %temps;
                undef %wsurf;
            } elsif ($props{$id}{meta} eq "w2_profile") {
                undef %kt_data;
                undef %elev_data;
                undef %parm_data;
            } elsif ($props{$id}{meta} eq "w2_outflow") {
                undef %qdata;
                undef %vdata;
                if ($props{$id}{add_parm} && $gr_props{$id}{add_cs}) {
                    undef %kt_data;
                    undef %parm_data;
                }
            } elsif ($props{$id}{meta} eq "w2_wlevels") {
                undef %wl_data;
            }

#           Update any links before moving on
            if ($props{$id}{meta} =~ /^(data_profile|vert_wd_zone|w2_profile|w2_outflow)$/) {
                &update_links($canvas, $id, $dt);
            }

            next;
        }

#       Continue with the update...
        $mult   = ($gr_props{$id}{yunits} eq "feet") ? 3.28084 : 1.0;
        $ymin   = $gr_props{$id}{ymin} /$mult;
        $ymax   = $gr_props{$id}{ymax} /$mult;   # Use meters for depths and elevations
        $yrange = $ymax -$ymin;

        if ($props{$id}{meta} =~ /^(data_profile|vert_wd_zone)$/) {
            $surf_elev = ($wsurf{$dt} ne "na") ? $wsurf{$dt} : 0.0;
            $got_depth = ($gr_props{$id}{elv_dep} eq "elevation") ? 0 : 1;
            if ($got_depth) {
                @depths     = @{ $gr_props{$id}{depths} };
            } else {
                @elevations = @{ $gr_props{$id}{elevations} };
            }
            $lastpt = ($got_depth) ? $#depths : $#elevations;
            @pt_elevations = ();
            for ($i=0; $i<=$lastpt; $i++) {
                if ($got_depth) {
                    push (@pt_elevations, $surf_elev - $depths[$i]);
                } else {
                    push (@pt_elevations, $elevations[$i]);
                }
            }
        } elsif ($props{$id}{meta} eq "w2_profile") {
            @el        = @{ $grid{$id}{el} };
            @kb        = @{ $grid{$id}{kb} };
            $nlayers   = $#{ $parm_data{$dt} } +1;
            $surf_elev = $elev_data{$dt};
            $seg       = $props{$id}{seg};
            $kt        = $kt_data{$dt};
            $kt        = $kb[$seg] if ($kt > $kb[$seg] && $nlayers == 1);
        } elsif ($props{$id}{meta} eq "w2_outflow") {
            $kmx       = $grid{$id}{kmx};
            @el        = @{ $grid{$id}{el} };
            @kb        = @{ $grid{$id}{kb} };
            if ($gr_props{$id}{qunits} eq "cfs/ft") {
                @flows = @{ $qdata{$dt} };
                $qmult = 10.763911;
            } elsif ($gr_props{$id}{qunits} eq "cms/m") {
                @flows = @{ $qdata{$dt} };
                $qmult = 1.0;
            } else {
                @flows = @{ $vdata{$dt} };
                $qmult = ($gr_props{$id}{qunits} eq "ft/s") ? 3.28084 : 1.0;
            }
            $surf_elev = $flows[1];           # second member is WS elevation (m)
        }
        if (defined($gr_props{$id}{add_cs}) && $gr_props{$id}{add_cs}) {
            @colors   = @{ $gr_props{$id}{colors} };
            @scale    = @{ $gr_props{$id}{scale}  };
            $cs_min   = $gr_props{$id}{cs_min};
            $cs_max   = $gr_props{$id}{cs_max};
            $cs_range = $cs_max -$cs_min;
        }

#       W2 profile plot
        if ($props{$id}{meta} eq "w2_profile") {
            $xmin   = $gr_props{$id}{xmin};
            $xmax   = $gr_props{$id}{xmax};
            $xrange = $xmax -$xmin;
            @coords = @tmp = ();
            if ($gr_props{$id}{pr_style} =~ /stairstep/i || $nlayers == 1) {
                for ($i=0; $i<$nlayers; $i++) {
                    $pval = $parm_data{$dt}[$i];
                    $pval = $pval *1.8 +32 if ($props{$id}{parm}       eq "Temperature" &&
                                               $props{$id}{parm_units} eq "Fahrenheit");
                    $xp   = &max($x1, &min($x2, $x1 +($x2-$x1)*($pval-$xmin)/$xrange));
                    if ($i == 0) {
                        $yval = $surf_elev;
                    } else {
                        $yval = $el[$kt+$i][$seg];
                    }
                    if ($gr_props{$id}{ytype} eq "Depth") {
                        $yp1 = $y1 +($y2-$y1)*($surf_elev-$yval)/$ymax;
                    } else {
                        $yp1 = $y2 -($y2-$y1)*($yval-$ymin)/$yrange;
                    }
                    last if ($yp1 >= $y2);
                    $yp1  = &max($y1, &min($y2, $yp1));
                    $yval = $el[$kt+$i+1][$seg];
                    if ($gr_props{$id}{ytype} eq "Depth") {
                        $yp2 = $y1 +($y2-$y1)*($surf_elev-$yval)/$ymax;
                    } else {
                        $yp2 = $y2 -($y2-$y1)*($yval-$ymin)/$yrange;
                    }
                    next if ($yp2 <= $y1);
                    $yp2 = &max($y1, &min($y2, $yp2));
                    push (@coords, $xp, $yp1, $xp, $yp2);
                    last if ($yp2 >= $y2);
                }
                $np = ($#coords +1)/2;
                $in_yrange = ($np > 1) ? 1 : 0;
            } else {
                for ($i=0; $i<$nlayers; $i++) {
                    $pval = $parm_data{$dt}[$i];
                    $pval = $pval *1.8 +32 if ($props{$id}{parm}       eq "Temperature" &&
                                               $props{$id}{parm_units} eq "Fahrenheit");
                    $xp   = $x1 +($x2-$x1)*($pval-$xmin)/$xrange;
                    if ($i == 0) {
                        if ($gr_props{$id}{ytype} eq "Depth") {
                            $yp1 = $y1;
                            $yp2 = $y1 +($y2-$y1)*($surf_elev-0.5*($surf_elev+$el[$kt+1][$seg]))/$ymax;
                        } else {
                            $yp1 = $y2 -($y2-$y1)*($surf_elev-$ymin)/$yrange;
                            $yp2 = $y2 -($y2-$y1)*(0.5*($surf_elev+$el[$kt+1][$seg])-$ymin)/$yrange;
                        }
                        last if ($yp1 >= $y2);
                        push (@tmp, $xp, $yp1, $xp, $yp2);
                    } else {
                        $yval = 0.5*($el[$kt+$i][$seg] +$el[$kt+$i+1][$seg]);
                        if ($gr_props{$id}{ytype} eq "Depth") {
                            $yp = $y1 +($y2-$y1)*($surf_elev-$yval)/$ymax;
                        } else {
                            $yp = $y2 -($y2-$y1)*($yval-$ymin)/$yrange;
                        }
                        push (@tmp, $xp, $yp);
                    }
                    if ($i == $nlayers-1) {
                        if ($gr_props{$id}{ytype} eq "Depth") {
                            $yp = $y1 +($y2-$y1)*($surf_elev-$el[$kt+$i+1][$seg])/$ymax;
                        } else {
                            $yp = $y2 -($y2-$y1)*($el[$kt+$i+1][$seg]-$ymin)/$yrange;
                        }
                        push (@tmp, $xp, $yp);
                    }
                }

              # Remove points outside of graph view and interpolate others to graph edges
                ($in_yrange, @coords) = &clip_profile($x1, $x2, $y1, $y2, @tmp);
                $np = ($#coords +1)/2;
            }

#           Plot optional color profile with depth
            if ($gr_props{$id}{add_cs} && $in_yrange) {

#               Create an image to hold the color profile and recognize its methods
                $iw = $x2 -$x1 +1;
                $ih = $y2 -$y1 +1;
                $cmap_image = Tkx::image_create_photo(-width => $iw, -height => $ih);
                $cmap_image = Tkx::widget->new($cmap_image);
                $xp1 = $yp2 = $yp4 = $yp4i = $pval4 = $j4 = 0;
                $xp2 = $iw -1;

#               By Layer option
                if ($gr_props{$id}{pc_style} =~ /by layer/i || $nlayers == 1) {
                    if ($gr_props{$id}{ytype} ne "Depth") {
                        $yp2 = &round_to_int($ih-1 -($ih-1)*($surf_elev-$ymin)/$yrange);
                        $yp2 = &max(0, &min($ih-1, $yp2));
                    }
                    for ($i=0; $i<$nlayers; $i++) {
                        $yp1  = $yp2;
                        last if ($yp1 >= $ih-1);
                        $yval = $el[$kt+$i+1][$seg];
                        if ($gr_props{$id}{ytype} eq "Depth") {
                            $yp2 = &round_to_int(($ih-1)*($surf_elev-$yval)/$ymax);
                        } else {
                            $yp2 = &round_to_int($ih-1 -($ih-1)*($yval-$ymin)/$yrange);
                        }
                        if ($yp2 < 0) {
                            $yp2 = 0;
                            next;
                        }
                        $yp2  = &min($ih-1, $yp2);
                        $pval = $parm_data{$dt}[$i];
                        $pval = $pval *1.8 +32 if ($props{$id}{parm}       eq "Temperature" &&
                                                   $props{$id}{parm_units} eq "Fahrenheit");
                        $j    = &max(0, &min($#colors, int(($#colors+1) *($pval-$cs_min)/$cs_range)));
                        $cmap_image = &image_put_color($cmap_image, $colors[$j],
                                                       $xp1, $yp1, $xp2, $yp2);
                        last if ($yp2 >= $ih-1);
                    }

#               Max Interpolation option
                } elsif ($gr_props{$id}{pc_style} =~ /max interp/i) {
                    if ($gr_props{$id}{ytype} ne "Depth") {
                        $yp2 = $ih-1 -($ih-1)*($surf_elev-$ymin)/$yrange;
                    }
                    $yp1i = &max(0, &min($ih-1, &round_to_int($yp2)));
                    for ($i=0; $i<$nlayers; $i++) {
                        $yp1   = $yp2;
                        $yp3   = $yp4;
                        $yp3i  = $yp4i;
                        $pval3 = $pval4;
                        $j3    = $j4;
                        last if ($i == 0 && $yp1 >= $ih-1);
                        last if ($i >  0 && $yp3 >= $ih-1);
                        if ($gr_props{$id}{ytype} eq "Depth") {
                            $yp2 = ($ih-1)*($surf_elev-$el[$kt+$i+1][$seg])/$ymax;
                        } else {
                            $yp2 = $ih-1 -($ih-1)*($el[$kt+$i+1][$seg]-$ymin)/$yrange;
                        }
                        $pval4 = $parm_data{$dt}[$i];
                        $pval4 = $pval4 *1.8 +32 if ($props{$id}{parm}       eq "Temperature" &&
                                                     $props{$id}{parm_units} eq "Fahrenheit");
                        $j4    = &max(0, &min($#colors, int(($#colors+1) *($pval4-$cs_min)/$cs_range)));
                        $yp4   = 0.5*($yp1+$yp2);
                        $yp4i  = &max(0, &min($ih-1, &round_to_int($yp4)));
                        next if (&round_to_int($yp4) < 0);
                        if ($i==0) {
                            $cmap_image = &image_put_color($cmap_image, $colors[$j4],
                                                           $xp1, $yp1i, $xp2, $yp4i);
                            last if ($yp4i >= $ih-1);
                        } else {
                            if ($j4 == $j3) {
                                $cmap_image = &image_put_color($cmap_image, $colors[$j4],
                                                               $xp1, $yp3i, $xp2, $yp4i);
                            } else {
                                $jj = ($j3 < $j4) ? 1 : -1;
                                for ($j=$j3*$jj; $j<=$j4*$jj; $j++) {
                                    $pval = ($j3 < $j4) ? $scale[$j+1] : $scale[$j*$jj];
                                    $yp   = $yp3 +($yp4-$yp3)*($pval-$pval3)/($pval4-$pval3);
                                    $yp   = &max($yp3, &min($yp4, $yp));
                                    next if (&round_to_int($yp) < 0);
                                    $ypi  = &max(0, &min($ih-1, &round_to_int($yp)));
                                    $cmap_image = &image_put_color($cmap_image, $colors[$j*$jj],
                                                                   $xp1, $yp3i, $xp2, $ypi);
                                    $yp3i = $ypi;
                                    last if ($yp >= $ih-1);
                                }
                                $yp4i = $yp3i;
                            }
                        }
                        if ($i==$nlayers-1) {
                            $yp2 = &round_to_int($yp2);
                            last if ($yp2 < 0);
                            $yp2 = &min($ih-1, $yp2);
                            $cmap_image = &image_put_color($cmap_image, $colors[$j4],
                                                           $xp1, $yp4i, $xp2, $yp2);
                        }
                    }

#               Interpolation option
                } else {
                    if ($gr_props{$id}{ytype} ne "Depth") {
                        $yp2 = $ih-1 -($ih-1)*($surf_elev-$ymin)/$yrange;
                    }
                    for ($i=0; $i<$nlayers; $i++) {
                        $yp1 = $yp2;
                        $yp3 = $yp4;
                        if ($gr_props{$id}{ytype} eq "Depth") {
                            $yp2 = ($ih-1)*($surf_elev-$el[$kt+$i+1][$seg])/$ymax;
                        } else {
                            $yp2 = $ih-1 -($ih-1)*($el[$kt+$i+1][$seg]-$ymin)/$yrange;
                        }
                        $pval = $parm_data{$dt}[$i];
                        $pval = $pval *1.8 +32 if ($props{$id}{parm}       eq "Temperature" &&
                                                   $props{$id}{parm_units} eq "Fahrenheit");
                        $j    = &max(0, &min($#colors, int(($#colors+1) *($pval-$cs_min)/$cs_range)));
                        if ($i==0) {
                            $yp4 = &round_to_int(0.25*$yp1 +0.75*$yp2);
                            $yp1 = &round_to_int($yp1);
                            last if ($yp1 >= $ih-1);
                            if ($yp4 < 0) {
                                $yp4 = 0;
                                next;
                            }
                            $yp4 = &min($ih-1, $yp4);
                            $cmap_image = &image_put_color($cmap_image, $colors[$j],
                                                           $xp1, $yp1, $xp2, $yp4);
                        } else {
                            $pval = 0.5*($parm_data{$dt}[$i-1] +$parm_data{$dt}[$i]);
                            $pval = $pval *1.8 +32 if ($props{$id}{parm}       eq "Temperature" &&
                                                       $props{$id}{parm_units} eq "Fahrenheit");
                            $j2   = &max(0, &min($#colors, int(($#colors+1) *($pval-$cs_min)/$cs_range)));
                            $yp4  = &round_to_int(0.75*$yp1 +0.25*$yp2);
                            if ($yp4 < 0) {
                                $yp4 = 0;
                                next;
                            }
                            $yp4 = &min($ih-1, $yp4);
                            $cmap_image = &image_put_color($cmap_image, $colors[$j2],
                                                           $xp1, $yp3, $xp2, $yp4);
                            last if ($yp4 >= $ih-1);
                            $yp3 = $yp4;
                            $yp4 = &round_to_int(0.25*$yp1 +0.75*$yp2);
                            if ($yp4 < 0) {
                                $yp4 = 0;
                                next;
                            }
                            $yp4 = &min($ih-1, $yp4);
                            $cmap_image = &image_put_color($cmap_image, $colors[$j],
                                                           $xp1, $yp3, $xp2, $yp4);
                        }
                        last if ($yp4 >= $ih-1);
                        if ($i==$nlayers-1) {
                            $yp2 = &round_to_int($yp2);
                            last if ($yp2 < 0);
                            $yp2 = &min($ih-1, $yp2);
                            $cmap_image = &image_put_color($cmap_image, $colors[$j],
                                                           $xp1, $yp4, $xp2, $yp2);
                        }
                    }
                }
                $canvas->create_image($x1, $y1, -anchor => 'nw',
                                                -image  => $cmap_image,
                                                -tags   => $gtag . " " . $gtag . "_colorProfile");
                undef $cmap_image;
            }
            undef %kt_data;
            undef %elev_data;
            undef %parm_data;

#           Plot the water surface and its indicator, if plotting elevations
            if ($gr_props{$id}{ytype} ne "Depth") {
                $yp = $y2 -($y2-$y1)*($surf_elev-$ymin)/$yrange;
                if ($yp >= $y1 && $yp <= $y2) {
                    $canvas->create_line($x1, $yp, $x2, $yp,
                                        -fill  => &get_rgb_code("gray60"),
                                        -width => 1,
                                        -arrow => 'none',
                                        -tags  => $gtag . " " . $gtag . "_profile");
                    $xp = $x1 + 0.9*($x2-$x1);
                    $canvas->create_polygon($xp, $yp, $xp-4, $yp-8, $xp+4, $yp-8,
                                        -outline => &get_rgb_code("gray60"),
                                        -width   => 1,
                                        -fill    => &get_rgb_code("white"),
                                        -tags    => $gtag . " " . $gtag . "_profile");
                }
            }

#           Plot the profile
            if ($np > 1) {
                if ($gr_props{$id}{pr_style} =~ /stairstep/i || &list_search("-999", @coords) == -1) {
                    $canvas->create_line(@coords, -fill  => &get_rgb_code($gr_props{$id}{pr_linec}),
                                                  -width => $gr_props{$id}{pr_linew},
                                                  -arrow => 'none',
                                                  -tags  => $gtag . " " . $gtag . "_profile");
                } else {
                    @tmp = ();
                    for ($i=0; $i<$#coords; $i+=2) {
                        if ($coords[$i] != -999 && $coords[$i+1] != -999) {
                            push (@tmp, $coords[$i], $coords[$i+1]);
                        } else {
                            if ($#tmp > 1) {
                                $canvas->create_line(@tmp,
                                                     -fill  => &get_rgb_code($gr_props{$id}{pr_linec}),
                                                     -width => $gr_props{$id}{pr_linew},
                                                     -arrow => 'none',
                                                     -tags  => $gtag . " " . $gtag . "_profile");
                            }
                            @tmp = ();
                        }
                    }
                    if ($#tmp > 1) {
                        $canvas->create_line(@tmp,
                                             -fill  => &get_rgb_code($gr_props{$id}{pr_linec}),
                                             -width => $gr_props{$id}{pr_linew},
                                             -arrow => 'none',
                                             -tags  => $gtag . " " . $gtag . "_profile");
                    }
                }
            }

#           Plot a no-data message
            if (! $in_yrange) {
                if ($gr_props{$id}{ytype} eq "Depth") {
                    $yp  = ($y1+$y2)/2;
                    $anc = 'center';
                } else {
                    $yp  = $y2 -($y2-$y1)*($surf_elev-$ymin)/$yrange +5;
                    $anc = 'n';
                    if ($yp < $y1 || $yp > $y2) {
                        $yp  = ($y1+$y2)/2;
                        $anc = 'center';
                    }
                }
                $canvas->create_text(($x1+$x2)/2., $yp,
                                   -anchor => $anc, 
                                   -text   => "No Data",
                                   -fill   => &get_rgb_code("gray60"),
                                   -angle  => 0,
                                   -tags   => $gtag . " " . $gtag . "_profile",
                                   -font   => [-family     => $gr_props{$id}{xfont},
                                               -size       => $gr_props{$id}{xl_size},
                                               -weight     => 'normal',
                                               -slant      => 'roman',
                                               -underline  => 0,
                                               -overstrike => 0,
                                              ]);
            }

#           Add any measured profile data
            if (defined($props{$id}{ref_file})) {
                &plot_ref_profile($canvas, $id, 0, 0);
            }

#       W2 layer outflow profile
        } elsif ($props{$id}{meta} eq "w2_outflow") {
            $seg     = $props{$id}{seg};
            $xmax    = $gr_props{$id}{xmax};
            @coords  = ();
            $np      = 0;
            $first   = 1;
            $last_xp = $x1;
            for ($k=2; $k<=$kmx; $k++) {
                next if (! defined($flows[$k]) || $flows[$k] eq "");
                if ($first) {
                    $yval  = $surf_elev;
                    $kt    = $k;
                    $first = 0;
                } else {
                    $yval  = $el[$k][$seg];
                }
                $xp = $x1 +($x2-$x1) *$flows[$k]*$qmult/$xmax;
                $xp = &max($x1, &min($x2, $xp));
                if ($gr_props{$id}{ytype} eq "Depth") {
                    $yp1 = $y1 +($y2-$y1)*($surf_elev-$yval)/$ymax;
                } else {
                    $yp1 = $y2 -($y2-$y1)*($yval-$ymin)/$yrange;
                }
                last if ($yp1 >= $y2);
                $yp1  = &max($y1, &min($y2, $yp1));
                $kalt = ($k == $kt && $kt > $kb[$seg]) ? $kb[$seg] : $k;
                if ($gr_props{$id}{ytype} eq "Depth") {
                    $yp2 = $y1 +($y2-$y1)*($surf_elev-$el[$kalt+1][$seg])/$ymax;
                } else {
                    $yp2 = $y2 -($y2-$y1)*($el[$kalt+1][$seg]-$ymin)/$yrange;
                }
                next if ($yp2 <= $y1);
                $yp2 = &max($y1, &min($y2, $yp2));
                if ($xp == $last_xp) {
                    push (@coords, $xp, $yp1) if ($#coords < 0);
                    push (@coords, $xp, $yp2);
                } else {
                    push (@coords, $last_xp, $yp1, $xp, $yp1, $xp, $yp2);
                }
                if (! defined($flows[$k+1]) && $xp != $x1) {
                    push (@coords, $x1, $yp2);
                }
                $np++ if ($xp > $x1);
                $last_xp = $xp;
                last if ($yp2 >= $y2);
            }

#           Work on a parameter-based color fill
            if ($np >= 1 && $props{$id}{add_parm} && $gr_props{$id}{add_cs}) {

#               Find a date match for the parameter-based color bars
                $dt_parm = $dt;
                $tol     = $props{$id}{match_tol};
                $found   = 0;
                if (defined($parm_data{$dt_parm})) {
                    $found = 1;
                } elsif ($tol > 0) {
                    for ($mi=1; $mi<=$tol; $mi++) {
                        $dt_parm2 = &adjust_dt($dt_parm, $mi);
                        if (defined($parm_data{$dt_parm2})) {
                            $dt_parm = $dt_parm2;
                            $found   = 1;
                            last;
                        }
                        $dt_parm2 = &adjust_dt($dt_parm, -1 *$mi);
                        if (defined($parm_data{$dt_parm2})) {
                            $dt_parm = $dt_parm2;
                            $found   = 1;
                            last;
                        }
                    }
                }

#               If a match was found, create the color profile image
                if ($found) {
                    $iw = $x2 -$x1 +1;
                    $ih = $y2 -$y1 +1;
                    $cmap_image = Tkx::image_create_photo(-width => $iw, -height => $ih);
                    $cmap_image = Tkx::widget->new($cmap_image);
                    $yp2 = $yp4 = $yp4i = $pval4 = $j4 = $last_xp = 0;
                    $kt_parm = $kt_data{$dt_parm};

#                   By Layer option
                    if ($gr_props{$id}{pc_style} =~ /by layer/i || $kt >= $kb[$seg]) {
                        if ($gr_props{$id}{ytype} ne "Depth") {
                            $yp2 = &round_to_int(($ih-1)*(1.-($surf_elev-$ymin)/$yrange));
                            $yp2 = &max(0, &min($ih-1, $yp2));
                        }
                        for ($k=$kt; $k<=$kmx; $k++) {
                            $flows[$k] = 0.0 if (! defined($flows[$k]) || $flows[$k] eq "");
                            $xp   = &round_to_int(($iw-1) *$flows[$k]*$qmult/$xmax);
                            $xp   = &max(0, &min($iw-1, $xp));
                            $yp1  = $yp2;
                            $kalt = ($k == $kt && $kt > $kb[$seg]) ? $kb[$seg] : $k;
                            if ($gr_props{$id}{ytype} eq "Depth") {
                                $yp2 = &round_to_int(($ih-1)*($surf_elev-$el[$kalt+1][$seg])/$ymax);
                            } else {
                                $yp2 = &round_to_int(($ih-1)*(1.-($el[$kalt+1][$seg]-$ymin)/$yrange));
                            }
                            if ($yp2 < 0) {
                                $yp2 = 0;
                                next;
                            }
                            $yp2 = &min($ih-1, $yp2);
                            if ($xp > 0) {
                                $i = &max(0, $k -$kt_parm);
                                if (defined($parm_data{$dt_parm}[$i])) {
                                    $pval = $parm_data{$dt_parm}[$i];
                                    $pval = $pval *1.8 +32 if ($props{$id}{parm}       eq "Temperature" &&
                                                               $props{$id}{parm_units} eq "Fahrenheit");
                                    $j = &max(0, &min($#colors, int(($#colors+1)*($pval-$cs_min)/$cs_range)));
                                    $cmap_image = &image_put_color($cmap_image, $colors[$j],
                                                                   0, $yp1, $xp, $yp2);
                                }
                            }
                            last if ($yp2 >= $ih-1);
                            last if ($k >= $kb[$seg]);   # ensures once-through, for kt > kb[i]
                        }

#                   Max Interpolation option
                    } elsif ($gr_props{$id}{pc_style} =~ /max interp/i) {
                        if ($gr_props{$id}{ytype} ne "Depth") {
                            $yp2 = ($ih-1)*(1.-($surf_elev-$ymin)/$yrange);
                        }
                        $yp1i = &max(0, &min($ih-1, &round_to_int($yp2)));
                        for ($k=$kt; $k<=$kmx; $k++) {
                            $flows[$k] = 0.0 if (! defined($flows[$k]) || $flows[$k] eq "");
                            $xp    = &round_to_int(($iw-1) *$flows[$k]*$qmult/$xmax);
                            $xp    = &max(0, &min($iw-1, $xp));
                            $yp1   = $yp2;
                            $yp3   = $yp4;
                            $yp3i  = $yp4i;
                            $pval3 = $pval4;
                            $j3    = $j4;
                            last if ($k == $kt && $yp1 >= $ih-1);
                            last if ($k >  $kt && $yp3 >= $ih-1);
                            $kalt  = ($k == $kt && $k > $kb[$seg]) ? $kb[$seg] : $k;
                            if ($gr_props{$id}{ytype} eq "Depth") {
                                $yp2 = ($ih-1)*($surf_elev-$el[$kalt+1][$seg])/$ymax;
                            } else {
                                $yp2 = ($ih-1)*(1.-($el[$kalt+1][$seg]-$ymin)/$yrange);
                            }
                            $i = &max(0, $k -$kt_parm);
                            if (defined($parm_data{$dt_parm}[$i])) {
                                $pval4 = $parm_data{$dt_parm}[$i];
                                $pval4 = $pval4 *1.8 +32 if ($props{$id}{parm}       eq "Temperature" &&
                                                             $props{$id}{parm_units} eq "Fahrenheit");
                                $j4 = &max(0, &min($#colors, int(($#colors+1) *($pval4-$cs_min)/$cs_range)));
                            }
                            $yp4  = 0.5*($yp1+$yp2);
                            $yp4i = &max(0, &min($ih-1, &round_to_int($yp4)));
                            if (&round_to_int($yp4) < 0) {
                                $last_xp = $xp;
                                next;
                            }
                            if ($k==$kt) {
                                if ($xp > 0 && defined($parm_data{$dt_parm}[$i])) {
                                    $cmap_image = &image_put_color($cmap_image, $colors[$j4],
                                                                   0, $yp1i, $xp, $yp4i);
                                }
                                last if ($yp4i >= $ih-1);
                            } else {
                                if (defined($parm_data{$dt_parm}[$i])
                                      && defined($parm_data{$dt_parm}[$i-1])) {
                                    $yp1i = &max(0, &min($ih-1, &round_to_int($yp1)));
                                    if ($j4 == $j3) {
                                        if ($last_xp > 0) {
                                            $cmap_image = &image_put_color($cmap_image, $colors[$j4],
                                                                           0, $yp3i, $last_xp, $yp1i);
                                        }
                                        if ($xp > 0) {
                                            $cmap_image = &image_put_color($cmap_image, $colors[$j4],
                                                                           0, $yp1i, $xp, $yp4i);
                                        }
                                    } else {
                                        $jj = ($j3 < $j4) ? 1 : -1;
                                        for ($j=$j3*$jj; $j<=$j4*$jj; $j++) {
                                            $pval = ($j3 < $j4) ? $scale[$j+1] : $scale[$j*$jj];
                                            $yp   = $yp3 +($yp4-$yp3)*($pval-$pval3)/($pval4-$pval3);
                                            $yp   = &max($yp3, &min($yp4, $yp));
                                            next if (&round_to_int($yp) < 0);
                                            $ypi  = &max(0, &min($ih-1, &round_to_int($yp)));
                                            if ($ypi <= $yp1i) {
                                                if ($last_xp > 0) {
                                                    $cmap_image = &image_put_color($cmap_image,
                                                                                   $colors[$j*$jj],
                                                                                   0, $yp3i, $last_xp, $ypi);
                                                }
                                            } elsif ($yp3i >= $yp1i) {
                                                if ($xp > 0) {
                                                    $cmap_image = &image_put_color($cmap_image,
                                                                                   $colors[$j*$jj],
                                                                                   0, $yp3i, $xp, $ypi);
                                                }
                                            } else {
                                                if ($last_xp > 0) {
                                                    $cmap_image = &image_put_color($cmap_image,
                                                                                   $colors[$j*$jj],
                                                                                   0, $yp3i, $last_xp, $yp1i);
                                                }
                                                if ($xp > 0) {
                                                    $cmap_image = &image_put_color($cmap_image,
                                                                                   $colors[$j*$jj],
                                                                                   0, $yp1i, $xp, $ypi);
                                                }
                                            }
                                            $yp3i = $ypi;
                                            last if ($yp >= $ih-1);
                                        }
                                        $yp4i = $yp3i;
                                    }
                                }
                            }
                            if ($k >= $kb[$seg]) {
                                $yp2 = &round_to_int($yp2);
                                last if ($yp2 < 0);
                                $yp2 = &min($ih-1, $yp2);
                                if ($xp > 0 && defined($parm_data{$dt_parm}[$i])) {
                                    $cmap_image = &image_put_color($cmap_image, $colors[$j4],
                                                                   0, $yp4i, $xp, $yp2);
                                }
                            }
                            last if ($k >= $kb[$seg]);   # ensures once-through, for kt > kb[i]
                            $last_xp = $xp;
                        }

#                   Interpolation option
                    } else {
                        if ($gr_props{$id}{ytype} ne "Depth") {
                            $yp2 = ($ih-1)*(1.-($surf_elev-$ymin)/$yrange);
                        }
                        for ($k=$kt; $k<=$kmx; $k++) {
                            $flows[$k] = 0.0 if (! defined($flows[$k]) || $flows[$k] eq "");
                            $xp   = &round_to_int(($iw-1) *$flows[$k]*$qmult/$xmax);
                            $xp   = &max(0, &min($iw-1, $xp));
                            $yp1  = $yp2;
                            $yp3  = $yp4;
                            $kalt = ($k == $kt && $kt > $kb[$seg]) ? $kb[$seg] : $k;
                            if ($gr_props{$id}{ytype} eq "Depth") {
                                $yp2 = ($ih-1)*($surf_elev-$el[$kalt+1][$seg])/$ymax;
                            } else {
                                $yp2 = ($ih-1)*(1.-($el[$kalt+1][$seg]-$ymin)/$yrange);
                            }
                            $i = &max(0, $k -$kt_parm);
                            if (defined($parm_data{$dt_parm}[$i])) {
                                $pval = $parm_data{$dt_parm}[$i];
                                $pval = $pval *1.8 +32 if ($props{$id}{parm}       eq "Temperature" &&
                                                           $props{$id}{parm_units} eq "Fahrenheit");
                                $j = &max(0, &min($#colors, int(($#colors+1) *($pval-$cs_min)/$cs_range)));
                            }
                            if ($k==$kt) {
                                $yp4 = &round_to_int(0.25*$yp1 +0.75*$yp2);
                                $yp1 = &max(0, &min($ih-1, &round_to_int($yp1)));
                                last if ($yp1 >= $ih-1);
                                if ($yp4 < 0) {
                                    $yp4 = 0;
                                    $last_xp = $xp;
                                    next;
                                }
                                $yp4 = &min($ih-1, $yp4);
                                if ($xp > 0 && defined($parm_data{$dt_parm}[$i])) {
                                    $cmap_image = &image_put_color($cmap_image, $colors[$j],
                                                                   0, $yp1, $xp, $yp4);
                                }
                            } else {
                                $yp4 = &round_to_int(0.75*$yp1 +0.25*$yp2);
                                if ($yp4 < 0) {
                                    $yp4 = 0;
                                    $last_xp = $xp;
                                    next;
                                }
                                $yp4 = &min($ih-1, $yp4);
                                if (defined($parm_data{$dt_parm}[$i])
                                      && defined($parm_data{$dt_parm}[$i-1])) {
                                    $pval = 0.5*($parm_data{$dt_parm}[$i] +$parm_data{$dt_parm}[$i-1]);
                                    $pval = $pval *1.8 +32 if ($props{$id}{parm}       eq "Temperature" &&
                                                               $props{$id}{parm_units} eq "Fahrenheit");
                                    $j2   = &max(0, &min($#colors,
                                                         int(($#colors+1) *($pval-$cs_min)/$cs_range)));
                                    $yp1i = &max(0, &min($ih-1, &round_to_int($yp1)));
                                    if ($last_xp > 0) {
                                        $cmap_image = &image_put_color($cmap_image, $colors[$j2],
                                                                       0, $yp3, $last_xp, $yp1i);
                                    }
                                    if ($xp > 0) {
                                        $cmap_image = &image_put_color($cmap_image, $colors[$j2],
                                                                       0, $yp1i, $xp, $yp4);
                                    }
                                }
                                last if ($yp4 >= $ih-1);
                                $yp3 = $yp4;
                                $yp4 = &round_to_int(0.25*$yp1 +0.75*$yp2);
                                if ($yp4 < 0) {
                                    $yp4 = 0;
                                    $last_xp = $xp;
                                    next;
                                }
                                $yp4 = &min($ih-1, $yp4);
                                if ($xp > 0 && defined($parm_data{$dt_parm}[$i])) {
                                    $cmap_image = &image_put_color($cmap_image, $colors[$j],
                                                                   0, $yp3, $xp, $yp4);
                                }
                            }
                            last if ($yp4 >= $ih-1);
                            if ($k >= $kb[$seg]) {
                                $yp2 = &round_to_int($yp2);
                                last if ($yp2 < 0);
                                $yp2 = &min($ih-1, $yp2);
                                if ($xp > 0 && defined($parm_data{$dt_parm}[$i])) {
                                    $cmap_image = &image_put_color($cmap_image, $colors[$j],
                                                                   0, $yp4, $xp, $yp2);
                                }
                            }
                            last if ($k >= $kb[$seg]);   # ensures once-through, for kt > kb[i]
                            $last_xp = $xp;
                        }
                    }
                    $canvas->create_image($x1, $y1, -anchor => 'nw',
                                                    -image  => $cmap_image,
                                                    -tags   => $gtag . " " . $gtag . "_colorProfile");
                    undef $cmap_image;
                }
            }
            if ($props{$id}{add_parm} && $gr_props{$id}{add_cs}) {
                undef %kt_data;
                undef %parm_data;
            }

#           Plot the water surface and its indicator, if plotting elevations
            if ($gr_props{$id}{ytype} ne "Depth") {
                $yp = $y2 -($y2-$y1)*($surf_elev-$ymin)/$yrange;
                if ($yp >= $y1 && $yp <= $y2) {
                    $canvas->create_line($x1, $yp, $x2, $yp,
                                          -fill  => &get_rgb_code("gray60"),
                                          -width => 1,
                                          -arrow => 'none',
                                          -tags  => $gtag . " " . $gtag . "_profile");
                    $xp = $x1 + 0.9*($x2-$x1);
                    $canvas->create_polygon($xp, $yp, $xp-4, $yp-8, $xp+4, $yp-8,
                                          -outline => &get_rgb_code("gray60"),
                                          -width   => 1,
                                          -fill    => &get_rgb_code("white"),
                                          -tags    => $gtag . " " . $gtag . "_profile");
                }
            }

#           Plot the profile
            if ($np >= 1) {
                $canvas->create_line(@coords, -fill  => &get_rgb_code("black"),
                                              -width => 1,
                                              -arrow => 'none',
                                              -tags  => $gtag . " " . $gtag . "_profile");

#           Plot a no-data message
            } else {
                $canvas->create_text(($x1+$x2)/2., ($y1+$y2)/2.,
                                     -anchor => 'center',
                                     -text   => "No Data",
                                     -fill   => &get_rgb_code("gray60"),
                                     -angle  => 0,
                                     -tags   => $gtag . " " . $gtag . "_profile",
                                     -font   => [-family     => $gr_props{$id}{xfont},
                                                 -size       => $gr_props{$id}{xl_size},
                                                 -weight     => 'normal',
                                                 -slant      => 'roman',
                                                 -underline  => 0,
                                                 -overstrike => 0,
                                                ]);
            }
            undef %qdata;
            undef %vdata;

#       W2 water levels plot
        } elsif ($props{$id}{meta} eq "w2_wlevels") {
            $xmult   = ($gr_props{$id}{xunits} eq "miles") ? 3280.84/5280. : 1.0;
            $xbase   = $gr_props{$id}{xbase} /$xmult;  # km
            $xmin    = $gr_props{$id}{xmin}  /$xmult;  # km
            $xmax    = $gr_props{$id}{xmax}  /$xmult;  # km
            $xrange  = $xmax -$xmin;
            @seglist = @{ $gr_props{$id}{seglist} };
            @xdist   = @{ $gr_props{$id}{xdist}   };  # km
            @us      = @{ $grid{$id}{us}    };
            @ds      = @{ $grid{$id}{ds}    };
            @slope   = @{ $grid{$id}{slope} };
            $nbr     = $grid{$id}{nbr};
            @coords  = ();

#           Loop over the segment list
            $np = 0;
            for ($ns=0; $ns<=$#seglist; $ns++) {
                $i    = $seglist[$ns];
                $wsel = $wl_data{$dt}[$i];
                if ($wsel == -999) {
                    if ($#coords > 2) {
                        if ($gr_props{$id}{xflip}) {   # Flip the x values, if necessary
                            for ($n=0; $n<$#coords; $n+=2) {
                                $coords[$n] = $x2 -($coords[$n] -$x1);
                            }
                        }
                        $canvas->create_line(@coords,
                                             -fill  => &get_rgb_code($gr_props{$id}{wl_color}),
                                             -width => 1,
                                             -arrow => 'none',
                                             -tags  => $gtag . " " . $gtag . "_wlevels");
                    }
                    @coords = ();
                    next;
                }
                $xd1 = ($ns == 0) ? 0 : $xdist[$seglist[$ns-1]];
                $xd2 = $xdist[$i];
                $xp1 = $x1 +($x2-$x1)*($xd1 +$xbase -$xmin)/$xrange;
                $xp2 = $x1 +($x2-$x1)*($xd2 +$xbase -$xmin)/$xrange;
                next if ($xp2 < $x1);
                last if ($xp1 > $x2);

                $add_pt0 = $add_pt3 = 0;
                for ($jb=1; $jb<=$nbr; $jb++) {
                    last if ($i >= $us[$jb] && $i <= $ds[$jb]);
                }
                if ($gr_props{$id}{wl_style} =~ /Interpolate/i) {
#                   When a branch joins mid-segment, need to account for that.
#                   Array seglist is ds to us, so normal progression is to decreasing segment numbers.
                    if ($ns < $#seglist && $i != $us[$jb] && $seglist[$ns+1] != $i-1) {
                        $xp3 = $xp2;
                    } else {
                        $xp3 = 0.5*($xp1+$xp2);
                    }
                    $yp3 = $y2 -($y2-$y1)*($wsel-$ymin)/$yrange;

                    if ($xp3 < $x1) {
                        $last_xp = $xp3;
                        $last_yp = $yp3;
                        next;
                    }
                    if ($#coords == -1) {
                        last if ($xp1 == $x2);
                        $yp3 = $y1 if ($yp3 < $y1);
                        $yp3 = $y2 if ($yp3 > $y2);
                        $last_xp = &max($x1, $xp1);
                        $last_yp = $yp3;
                        push (@coords, $last_xp, $last_yp);
                    }
                    if ($yp3 < $y1 && $last_yp <= $y1) {
                        $yp3 = $y1;
                    } elsif ($yp3 > $y2 && $last_yp >= $y2) {
                        $yp3 = $y2;
                    }
                    if ($xp3 > $x2) {
                        $yp3 = ($yp3-$last_yp)*($x2-$last_xp)/($xp3-$last_xp)+$last_yp;
                        $xp3 = $x2;
                    }
                    if ($yp3 < $y1) {
                        $xp0 = ($xp3-$last_xp)*($y1-$last_yp)/($yp3-$last_yp)+$last_xp;
                        $yp0 = $yp3 = $y1;
                        $add_pt0 = 1;
                    } elsif ($yp3 > $y2) {
                        $xp0 = ($xp3-$last_xp)*($y2-$last_yp)/($yp3-$last_yp)+$last_xp;
                        $yp0 = $yp3 = $y2;
                        $add_pt0 = 1;
                    }
                    push (@coords, $xp0, $yp0) if ($add_pt0);
                    push (@coords, $xp3, $yp3);
                    if ($ns == $#seglist && $xp3 != $x2 && $xp2 > $xp3) {
                        push (@coords, &min($x2, $xp2), $yp3);
                    }
                    $np++;
                    $last_xp = $xp3;
                    $last_yp = $yp3;
                    last if ($xp3 >= $x2);

                } else {
                    if ($slope[$jb] == 0 || $gr_props{$id}{wl_style} =~ /Flat surface/i) {
                        $yp1 = $y2 -($y2-$y1)*($wsel-$ymin)/$yrange;
                        $xp1 = &max($x1, &min($x2, $xp1));
                        $xp2 = &max($x1, &min($x2, $xp2));
                        $yp1 = $yp2 = &max($y1, &min($y2, $yp1));
                    } else {
#                       When a branch joins mid-segment, need to account for that.
#                       Array seglist is ds to us, so normal progression is to decreasing segment numbers.
                        if ($ns < $#seglist && $i != $us[$jb] && $seglist[$ns+1] != $i-1) {
                            $yp1 = $y2 -($y2-$y1)*($wsel-($xd2-$xd1)*1000.*$slope[$jb]-$ymin)/$yrange;
                            $yp2 = $y2 -($y2-$y1)*($wsel-$ymin)/$yrange;
                        } else {
                            $yp1 = $y2 -($y2-$y1)*($wsel-0.5*($xd2-$xd1)*1000.*$slope[$jb]-$ymin)/$yrange;
                            $yp2 = $y2 -($y2-$y1)*($wsel+0.5*($xd2-$xd1)*1000.*$slope[$jb]-$ymin)/$yrange;
                        }
                        if ($xp1 < $x1) {
                            $yp1 = ($yp2-$yp1)*($x1-$xp1)/($xp2-$xp1)+$yp1;
                            $xp1 = $x1;
                        }
                        if ($xp2 > $x2) {
                            $yp2 = ($yp2-$yp1)*($x2-$xp1)/($xp2-$xp1)+$yp1;
                            $xp2 = $x2;
                        }
                        if ($yp1 < $y1 && $yp2 < $y1) {
                            $yp1 = $yp2 = $y1;
                        } elsif ($yp1 > $y2 && $yp2 > $y2) {
                            $yp1 = $yp2 = $y2;
                        }
                        if ($yp1 < $y1) {
                            $xp0 = $xp1;
                            $yp0 = $y1;
                            $xp1 = ($xp2-$xp1)*($y1-$yp1)/($yp2-$yp1)+$xp1;
                            $yp1 = $y1;
                            $add_pt0 = 1;
                        } elsif ($yp1 > $y2) {
                            $xp0 = $xp1;
                            $yp0 = $y2;
                            $xp1 = ($xp2-$xp1)*($y2-$yp1)/($yp2-$yp1)+$xp1;
                            $yp1 = $y2;
                            $add_pt0 = 1;
                        }
                        if ($yp2 < $y1) {
                            $xp3 = $xp1;
                            $yp3 = $y1;
                            $xp2 = ($xp2-$xp1)*($y1-$yp1)/($yp2-$yp1)+$xp1;
                            $yp2 = $y1;
                            $add_pt3 = 1;
                        } elsif ($yp2 > $y2) {
                            $xp3 = $xp1;
                            $yp3 = $y2;
                            $xp2 = ($xp2-$xp1)*($y2-$yp1)/($yp2-$yp1)+$xp1;
                            $yp2 = $y2;
                            $add_pt3 = 1;
                        }
                    }
                    push (@coords, $xp0, $yp0) if ($add_pt0);
                    push (@coords, $xp1, $yp1, $xp2, $yp2);
                    push (@coords, $xp3, $yp3) if ($add_pt3);
                    $np++;
                }
            }
            if ($#coords > 2) {
                if ($gr_props{$id}{xflip}) {   # Flip the x values, if necessary
                    for ($n=0; $n<$#coords; $n+=2) {
                        $coords[$n] = $x2 -($coords[$n] -$x1);
                    }
                }
                $canvas->create_line(@coords, -fill  => &get_rgb_code($gr_props{$id}{wl_color}),
                                              -width => 1,
                                              -arrow => 'none',
                                              -tags  => $gtag . " " . $gtag . "_wlevels");
            } elsif ($np == 0) {
                $canvas->create_text(($x1+$x2)/2., ($y1 +$y2)/2.,
                                     -anchor => 'center',
                                     -text   => "No Data",
                                     -fill   => &get_rgb_code("gray60"),
                                     -angle  => 0,
                                     -tags   => $gtag . " " . $gtag . "_wlevels",
                                     -font   => [-family     => $gr_props{$id}{xfont},
                                                 -size       => $gr_props{$id}{xl_size},
                                                 -weight     => 'normal',
                                                 -slant      => 'roman',
                                                 -underline  => 0,
                                                 -overstrike => 0,
                                                ]);
            }
            undef %wl_data;

#       Vertical profile data plot
        } elsif ($props{$id}{meta} eq "data_profile") {
            @pdata     = @{ $parm_data{$dt} };
            @estimated = @{ $gr_props{$id}{estimated} };
            $xmin      = $gr_props{$id}{xmin};
            $xmax      = $gr_props{$id}{xmax};
            $xrange    = $xmax -$xmin;
            if ($props{$id}{parm_units} eq "Fahrenheit") {
                $diff = ($props{$id}{prof_type} eq "difference") ? 0 : 32;
                for ($i=0; $i<=$lastpt; $i++) {
                    next if ($pdata[$i] eq "na");
                    $pdata[$i] = $pdata[$i] *1.8 +$diff;
                }
            }

#           Populate a data array, and make sure data are available
            @coords   = @valid_pdata = ();
            @pt_color = @valid_elevs = ();
            for ($i=0; $i<=$lastpt; $i++) {
                next if ($pdata[$i] eq "na");
                next if ($pt_elevations[$i] > $surf_elev +0.1/3.28084);
                next if ($gr_props{$id}{ytype} ne "Depth" && $wsurf{$dt} eq "na");
                $xp = $x1 +($x2-$x1)*($pdata[$i]-$xmin)/$xrange;
                if ($gr_props{$id}{ytype} eq "Depth") {
                    $yp = $y1 +($y2-$y1)*($surf_elev-$pt_elevations[$i])/$ymax;
                } else {
                    $yp = $y2 -($y2-$y1)*($pt_elevations[$i]-$ymin)/$yrange;
                }
                push (@coords, $xp, $yp);
                push (@valid_pdata, $pdata[$i]);
                push (@valid_elevs, $pt_elevations[$i]);
                if ($estimated[$i]) {
                    push (@pt_color, "DarkGray");
                } else {
                    push (@pt_color, "black");
                }
            }
            $np = ($#coords +1)/2;

#           Plot optional color profile with depth
            if ($gr_props{$id}{add_cs} && $np > 1) {

#               Create an image to hold the color profile and recognize its methods
                $iw = $x2 -$x1 +1;
                $ih = $y2 -$y1 +1;
                $cmap_image = Tkx::image_create_photo(-width => $iw, -height => $ih);
                $cmap_image = Tkx::widget->new($cmap_image);
                $xp1 = 0;
                $xp2 = $iw -1;

                $old_elev = $surf_elev;
                if ($gr_props{$id}{ytype} eq "Depth") {
                    $yp2 = 0;
                    $el_limit = $surf_elev -$ymax;
                } else {
                    $yp2 = &round_to_int($ih-1 -($ih-1)*($old_elev-$ymin)/$yrange);
                    $yp2 = &max(0, &min($ih-1, $yp2));
                    $el_limit = $ymin;
                }
                $dy = &max(1.0/3.28084, $yrange/($ih-1));
                for ($elev=$surf_elev-$dy; $elev>$el_limit-$dy; $elev-=$dy) {
                    $yp1 = $yp2;
                    if ($gr_props{$id}{ytype} eq "Depth") {
                        $yp2 = &round_to_int(($ih-1)*($surf_elev-$elev)/$ymax);
                    } else {
                        $yp2 = &round_to_int($ih-1 -($ih-1)*($elev-$ymin)/$yrange);
                    }
                    last if ($yp1 >= $ih-1);
                    if ($yp2 < 0) {
                        $old_elev = $elev;
                        $yp2 = 0;
                        next;
                    }
                    $yp2 = &max(0, &min($ih-1, $yp2));

#                   Elevation range of interest is deeper than deepest measurement
                    if ($old_elev <= $valid_elevs[$np-1]) {
                        $pval = $valid_pdata[$np-1];
                    } else {
                        $first = 1;
                        for ($i=0; $i<$np; $i++) {
                            next if ($valid_elevs[$i] > $surf_elev +0.1/3.28084);
                            $el1   = $valid_elevs[$i];
                            $el2   = $valid_elevs[$i+1] if ($i < $np-1);
                            $el3   = $valid_elevs[$i-1] if ($i > 0 && ! $first);
                            $pval1 = $valid_pdata[$i];
                            $pval2 = $valid_pdata[$i+1] if ($i < $np-1);
                            $pval3 = $valid_pdata[$i-1] if ($i > 0 && ! $first);

#                           Elevation is shallower than first measurement
                            if ($first && $el1 <= $elev) {
                                $pval = $pval1;
                                last;

#                           Measurement is in the elevation range of interest
                            } elsif ($el1 < $old_elev && $el1 >= $elev) {

#                               Shallowest measurement in elevation range of interest
                                if ($first) {
                                    $bot  = $pval1 + ($pval2-$pval1)*($el1-$elev)/($el1-$el2);
                                    $pval = ($pval1*($old_elev-$el1)
                                            +(($pval1+$bot)/2.)*($el1-$elev))/($old_elev-$elev);
                                    last;

#                               Deepest measurement in elevation range of interest
                                } elsif ($i == $np-1) {
                                    $top  = $pval3 + ($pval1-$pval3)*($el3-$old_elev)/($el3-$el1);
                                    $pval = ((($top+$pval1)/2.)*($old_elev-$el1)
                                            +$pval1*($el1-$elev))/($old_elev-$elev);
                                    last;

#                               Not shallowest, not deepest, in range of interest
                                } else {
                                    $top  = $pval3 + ($pval1-$pval3)*($el3-$old_elev)/($el3-$el1);
                                    $bot  = $pval1 + ($pval2-$pval1)*($el1-$elev)/($el1-$el2);
                                    $pval = ((($top+$pval1)/2.)*($old_elev-$el1)
                                            +(($pval1+$bot)/2.)*($el1-$elev))/($old_elev-$elev);
                                    last;
                                }

#                           One measurement above and one below the elevation range of interest
                            } elsif ($el1 >= $old_elev && $el2 <= $elev) {
                                $top  = $pval1 + ($pval2-$pval1)*($el1-$old_elev)/($el1-$el2);
                                $bot  = $pval1 + ($pval2-$pval1)*($el1-$elev)/($el1-$el2);
                                $pval = ($top+$bot)/2.;
                                last;
                            }
                            $first = 0;
                        }
                    }
                    $j = int(($#colors+1) *($pval-$cs_min)/$cs_range);
                    $j = &max(0, &min($#colors, $j));
                    $cmap_image->put($colors[$j], -to => $xp1, $yp1, $xp2, $yp2);
                    $old_elev = $elev;
                    last if ($yp2 >= $ih-1);
                }
                $canvas->create_image($x1, $y1, -anchor => 'nw',
                                                -image  => $cmap_image,
                                                -tags   => $gtag . " " . $gtag . "_colorProfile");
                undef $cmap_image;
            }

#           Plot the water surface and its indicator, if plotting elevations
            if ($gr_props{$id}{ytype} ne "Depth" && $wsurf{$dt} ne "na") {
                $yp = $y2 -($y2-$y1)*($surf_elev-$ymin)/$yrange;
                if ($yp >= $y1 && $yp <= $y2) {
                    $canvas->create_line($x1, $yp, $x2, $yp,
                                         -fill  => &get_rgb_code("gray60"),
                                         -width => 1,
                                         -arrow => 'none',
                                         -tags  => $gtag . " " . $gtag . "_profile");
                    $xp = $x1 + 0.9*($x2-$x1);
                    $canvas->create_polygon($xp, $yp, $xp-4, $yp-8, $xp+4, $yp-8,
                                         -outline => &get_rgb_code("gray60"),
                                         -width   => 1,
                                         -fill    => &get_rgb_code("white"),
                                         -tags    => $gtag . " " . $gtag . "_profile");
                }
            }

#           Plot the vertical profile
            if ($np > 1) {
                for ($i=1; $i<$np; $i++) {
                    $xp1 = $coords[2*$i-2];
                    $yp1 = $coords[2*$i-1];
                    $xp2 = $coords[2*$i];
                    $yp2 = $coords[2*$i+1];
                    $pt1_in = ($xp1 >= $x1 && $xp1 <= $x2 &&
                               $yp1 >= $y1 && $yp1 <= $y2) ? 1 : 0;
                    $pt2_in = ($xp2 >= $x1 && $xp2 <= $x2 &&
                               $yp2 >= $y1 && $yp2 <= $y2) ? 1 : 0;
                    next if (! $pt1_in && ! $pt2_in);
                    if (! $pt1_in) {
                        if ($xp1 < $x1) {
                            $yp = $yp1 +($yp2-$yp1) *($x1-$xp1) /($xp2-$xp1);
                            $xp = $x1;
                        } elsif ($xp1 > $x2) {
                            $yp = $yp1 +($yp2-$yp1) *($x2-$xp1) /($xp2-$xp1);
                            $xp = $x2;
                        } else {
                            $xp = $xp1 +($xp2-$xp1) *($y1-$yp1) /($yp2-$yp1);
                            $yp = $y1;
                        }
                        if ($yp < $y1) {
                            $xp = $xp1 +($xp2-$xp1) *($y1-$yp1) /($yp2-$yp1);
                            $yp = $y1;
                        }
                        $xp1 = $xp;
                        $yp1 = $yp;
                    } elsif (! $pt2_in) {
                        if ($xp2 < $x1) {
                            $yp = $yp1 +($yp2-$yp1) *($x1-$xp1) /($xp2-$xp1);
                            $xp = $x1;
                        } elsif ($xp2 > $x2) {
                            $yp = $yp1 +($yp2-$yp1) *($x2-$xp1) /($xp2-$xp1);
                            $xp = $x2;
                        } else {
                            $xp = $xp1 +($xp2-$xp1) *($y2-$yp1) /($yp2-$yp1);
                            $yp = $y2;
                        }
                        if ($yp > $y2) {
                            $xp = $xp1 +($xp2-$xp1) *($y2-$yp1) /($yp2-$yp1);
                            $yp = $y2;
                        }
                        $xp2 = $xp;
                        $yp2 = $yp;
                    }
                    $canvas->create_line($xp1, $yp1, $xp2, $yp2,
                                            -fill  => &get_rgb_code($pt_color[$i]),
                                            -width => 1,
                                            -arrow => 'none',
                                            -tags  => $gtag . " " . $gtag . "_profile");
                }

#           Plot a no-data message
            } else {
                if ($gr_props{$id}{ytype} eq "Depth" || $wsurf{$dt} eq "na") {
                    $yp  = ($y1+$y2)/2;
                    $anc = 'center';
                } else {
                    $yp  = $y2 -($y2-$y1)*($surf_elev-$ymin)/$yrange +5;
                    $anc = 'n';
                    if ($yp < $y1 || $yp > $y2) {
                        $yp  = ($y1+$y2)/2;
                        $anc = 'center';
                    }
                }
                $canvas->create_text(($x1+$x2)/2, $yp,
                                    -anchor => $anc, 
                                    -text   => "No Data",
                                    -fill   => &get_rgb_code("gray60"),
                                    -angle  => 0,
                                    -tags   => $gtag . " " . $gtag . "_profile",
                                    -font   => [-family     => $gr_props{$id}{xfont},
                                                -size       => $gr_props{$id}{xl_size},
                                                -weight     => 'normal',
                                                -slant      => 'roman',
                                                -underline  => 0,
                                                -overstrike => 0,
                                               ]);
            }

#           Plot the measured points
            for ($i=0; $i<$np; $i++) {
                $xp = $coords[2*$i];
                $yp = $coords[2*$i+1];
                if ($xp >= $x1 && $xp <= $x2 && $yp >= $y1 && $yp <= $y2) {
                    if ($gr_props{$id}{add_cs}) {
                        $pval = $valid_pdata[$i];
                        $j    = int(($#colors+1) *($pval-$cs_min)/$cs_range);
                        $j    = &max(0, &min($#colors, $j));
                        $canvas->create_oval($xp-3, $yp-3, $xp+3, $yp+3,
                                            -outline => &get_rgb_code($pt_color[$i]),
                                            -width   => 1,
                                            -fill    => $colors[$j],
                                            -tags    => $gtag . " " . $gtag . "_profile");
                    } else {
                        $canvas->create_oval($xp-3, $yp-3, $xp+3, $yp+3,
                                            -outline => &get_rgb_code($pt_color[$i]),
                                            -width   => 1,
                                            -fill    => &get_rgb_code("white"),
                                            -tags    => $gtag . " " . $gtag . "_profile");
                    }
                }
            }
            undef %parm_data;
            undef %wsurf;

#       Vertical withdrawal zone
        } elsif ($props{$id}{meta} eq "vert_wd_zone") {
            $kbot = $gr_props{$id}{kb};
            @el   = @{ $gr_props{$id}{el} };
            @t    = ();
            $np   = $flow_data = 0;
            @valid_temps = ();
            @valid_elevs = ();
            for ($i=0; $i<=$lastpt; $i++) {
                next if ($temps{$dt}[$i] eq "na");
                next if ($pt_elevations[$i] > $surf_elev +0.1/3.28084);
                next if ($gr_props{$id}{ytype} ne "Depth" && $wsurf{$dt} eq "na");
                push (@valid_temps, $temps{$dt}[$i]);
                push (@valid_elevs, $pt_elevations[$i]);
                $np++;
            }
            undef %temps;

            if ($np > 0) {
                for ($k=1; $k<=$kbot; $k++) {
                    if ($el[$k+1] >= $surf_elev) {
                        $t[$k] = -999.;
                        next;
                    }

#                   Elevation range of interest is deeper than deepest measurement
                    if ($el[$k] <= $valid_elevs[$np-1]) {
                        $t[$k] = $valid_temps[$np-1];

                    } else {
                        if ($el[$k] > $surf_elev) {
                            $height = $surf_elev -$el[$k+1];
                        } else {
                            $height = $el[$k] -$el[$k+1];
                        }
                        $first = 1;
                        for ($i=0; $i<$np; $i++) {
                            next if ($valid_elevs[$i] > $surf_elev +0.1/3.28084);
                            $el1 = $valid_elevs[$i];
                            $el2 = $valid_elevs[$i+1] if ($i < $np-1);
                            $el3 = $valid_elevs[$i-1] if ($i > 0 && ! $first);
                            $wt1 = $valid_temps[$i];
                            $wt2 = $valid_temps[$i+1] if ($i < $np-1);
                            $wt3 = $valid_temps[$i-1] if ($i > 0 && ! $first);

#                           Elevation is shallower than first measurement
                            if ($first && $el1 <= $el[$k+1]) {
                                $t[$k] = $wt1;
                                last;

#                           Measurement is in the elevation range of interest
                            } elsif ($el1 < $el[$k] && $el1 >= $el[$k+1]) {

#                               Shallowest measurement in elevation range of interest
                                if ($first) {
                                    $bot   = $wt1 + ($wt2-$wt1)*($el1-$el[$k+1])/($el1-$el2);
                                    $t[$k] = ($wt1*(&min($el[$k], $surf_elev)-$el1)
                                            +(($wt1+$bot)/2.)*($el1-$el[$k+1]))/$height;
                                    last;

#                               Deepest measurement in elevation range of interest
                                } elsif ($i == $np-1) {
                                    $top   = $wt3 + ($wt1-$wt3)*($el3-$el[$k])/($el3-$el1);
                                    $t[$k] = ((($top+$wt1)/2.)*($el[$k]-$el1)
                                            +$wt1*($el1-$el[$k+1]))/$height;
                                    last;

#                               Not shallowest, not deepest, in range of interest
                                } else {
                                    $top   = $wt3 + ($wt1-$wt3)*($el3-$el[$k])/($el3-$el1);
                                    $bot   = $wt1 + ($wt2-$wt1)*($el1-$el[$k+1])/($el1-$el2);
                                    $t[$k] = ((($top+$wt1)/2.)*($el[$k]-$el1)
                                            +(($wt1+$bot)/2.)*($el1-$el[$k+1]))/$height;
                                    last;
                                }

#                           One measurement above and one below the elevation range of interest
                            } elsif ($el1 >= $el[$k] && $el2 <= $el[$k+1]) {
                                $top   = $wt1 + ($wt2-$wt1)*($el1-$el[$k])  /($el1-$el2);
                                $bot   = $wt1 + ($wt2-$wt1)*($el1-$el[$k+1])/($el1-$el2);
                                $t[$k] = ($top+$bot)/2.;
                                last;
                            }
                            $first = 0;
                        }
                    }
                }

#               Determine whether flow data are available
#               and whether computations have already been completed for this date
                %qdata     = %{ $gr_props{$id}{qdata} };
                $flow_data = (defined($qdata{$dt})) ? 1 : 0;
                $do_calcs  = 0;
                if ($flow_data) {
                    $do_calcs = 1;
                    if (defined($gr_props{$id}{qtot_data})) {
                        %tdata     = %{ $gr_props{$id}{tdata}     };
                        %qtot_data = %{ $gr_props{$id}{qtot_data} };
                        %vtot_data = %{ $gr_props{$id}{vtot_data} };
                        if (defined($qtot_data{$dt})) {
                            $do_calcs = 0;                 # computations already done for this date
                            @qtot = @{ $qtot_data{$dt} };  # layer outflows in cms/m
                            @vtot = @{ $vtot_data{$dt} };  # layer velocities in m/s
                        }
                    } else {
                        %tdata = %qtot_data = %vtot_data = ();
                    }
                }

#               Do the outflow computations if not already completed
                if ($flow_data && $do_calcs) {
                    @qstr = @{ $qdata{$dt} };
                    @tstr = ();

#                   Set parameters for computing vertical withdrawal zone
                    @qtot = @vtot = ();
                    for ($k=1; $k<=$kbot; $k++) {
                        $qtot[$k] = $vtot[$k] = 0;
                    }
                    $qsum   = 0;
                    $tsum   = 0;
                    $nout   = $gr_props{$id}{nout};
                    @sw_alg = @{ $gr_props{$id}{sw_alg} };
                    @names  = @{ $gr_props{$id}{names}  };
                    @estr   = @{ $gr_props{$id}{estr}   };
                    @lw     = @{ $gr_props{$id}{lw}     };
                    @ktsw   = @{ $gr_props{$id}{ktsw}   };
                    @kbsw   = @{ $gr_props{$id}{kbsw}   };
                    @b      = @{ $gr_props{$id}{b}      };

#                   Compute water densities
                    @rho = ();
                    for ($k=1; $k<=$kbot; $k++) {
                        next if ($t[$k] == -999.);
                        $rho[$k] = ((((6.536332E-9*$t[$k]-1.120083E-6)*$t[$k]+1.001685E-4)*$t[$k]
                                      -9.09529E-3)*$t[$k]+6.793952E-2)*$t[$k]+999.842594;
                    }
                    for ($k=$kbot-1; $k>=1; $k--) {   # hopefully not needed
                        if (! defined($rho[$k]) && defined($rho[$k+1])) {
                            $rho[$k] = $rho[$k+1];
                        }
                    }

#                   Collect data needed for selective withdrawal routines
                    $ds_parms{kb}   = $kbot;
                    $ds_parms{kmx}  = $gr_props{$id}{kmx};
                    $ds_parms{wsel} = $surf_elev;       # meters
                    $ds_parms{b}    = [ @b   ];         # meters
                    $ds_parms{el}   = [ @el  ];         # meters
                    $ds_parms{wt}   = [ @t   ];         # deg C
                    $ds_parms{rho}  = [ @rho ];         # kg/cu.m.

                    if ($props{$id}{wd_alg} eq "Libby Dam") {
                        $ds_parms{num_rows}  = $gr_props{$id}{num_rows};
                        $ds_parms{bh_width}  = $gr_props{$id}{bh_width};      # meters
                        $ds_parms{bh_height} = $gr_props{$id}{bh_height};     # meters
                        $ds_parms{base_elev} = $gr_props{$id}{base_elev};     # meters
                        $ds_parms{hlc_base}  = $gr_props{$id}{hlc_base};
                        $ds_parms{hlc_inc}   = $gr_props{$id}{hlc_inc};
                        $ds_parms{bh_miss}   = $gr_props{$id}{bh_miss};
                        @nslots              = @{ $gr_props{$id}{num_slots} };
                        @ww_names            = @{ $gr_props{$id}{ww_names}  };
                        @noutlets            = @{ $gr_props{$id}{num_outs}  };
                    }

#                   Loop over the outlets
                    for ($n=0; $n<$nout; $n++) {
                        if ($qstr[$n] == 0.) {
                            $tstr[$n] = -99.;
                            next;
                        }
                        $ds_parms{qstr} = $qstr[$n];         # cms
                        $ds_parms{ktsw} = $ktsw[$n];
                        $ds_parms{kbsw} = $kbsw[$n];

#                       Compute flows to a discrete outlet using original W2 algorithm
                        if ($sw_alg[$n] eq "W2orig") {
                            $ds_parms{estr} = $estr[$n];     # meters
                            $ds_parms{wstr} = $lw[$n];       # meters
                            ($tout, @qout)  = &downstream_withdrawal(%ds_parms);

#                       Compute flows over/through bulkhead stacks to a wet well
#                       using the new Libby Dam algorithm
                        } elsif ($sw_alg[$n] eq "LibbyDam") {

#                           The wet well number is found by matching outlet names
                            $nww = &list_match($names[$n], @ww_names);
                            if ($nww == -1 || $nww > $gr_props{$id}{num_ww} -1) {
                                return &pop_up_error($main,
                                          "Failed to match the name of the wet well to\n"
                                        . "one of the named outlets in the release rate file:\n"
                                        . "  $props{$id}{lbc_file}\n  $props{$id}{flow_file}");
                            }
                            $ds_parms{nslots}   = $nslots[$nww];
                            $ds_parms{noutlets} = $noutlets[$nww];

                            ($tout, @qout) = &libby_calcs($nww, $dt, %ds_parms);
                        }

                        $qsum += $qstr[$n];          # Note: qstr[] and qout[] in cms
                        $tsum += $qstr[$n] *$tout;   # and tout is in deg Celsius
                        for ($k=1; $k<=$kbot; $k++) {
                            $qtot[$k] += $qout[$k];
                        }
                        $tstr[$n] = $tout;
                    }
                    undef %ds_parms;

                    $tstr[$nout] = ($qsum > 0) ? $tsum /$qsum : -99.;
                    $tdata{$dt}  = [ @tstr ];
                    $gr_props{$id}{tdata} = { %tdata };    # in deg Celsius

#                   Adjust flow per unit height (cms/m) and compute velocity (m/s)
                    for ($k=1; $k<=$kbot; $k++) {
                        next if ($el[$k+1] >= $surf_elev);
                        $height    = &min($surf_elev, $el[$k]) -$el[$k+1];
                        $vtot[$k]  = $qtot[$k] /($height *$b[$k]);
                        $qtot[$k] /= $height;
                    }
                    $qtot_data{$dt} = [ @qtot ];
                    $vtot_data{$dt} = [ @vtot ];
                    $gr_props{$id}{qtot_data} = { %qtot_data };  # layer outflows in cms/m
                    $gr_props{$id}{vtot_data} = { %vtot_data };  # layer velocities in m/s
                }
                undef %qdata;
            }

#           Draw the water-surface indicator
            if ($gr_props{$id}{ytype} ne "Depth" && $wsurf{$dt} ne "na") {
                $yp = $y2 -($y2-$y1)*($surf_elev-$ymin)/$yrange;
                if ($yp >= $y1 && $yp <= $y2) {
                    $canvas->create_line($x1, $yp, $x2, $yp,
                                        -fill  => &get_rgb_code("gray60"),
                                        -width => 1,
                                        -arrow => 'none',
                                        -tags  => $gtag . " " . $gtag . "_profile");
                    $xp = $x1 + 0.9*($x2-$x1);
                    $canvas->create_polygon($xp, $yp, $xp-4, $yp-8, $xp+4, $yp-8,
                                        -outline => &get_rgb_code("gray60"),
                                        -width   => 1,
                                        -fill    => &get_rgb_code("white"),
                                        -tags    => $gtag . " " . $gtag . "_profile");
                }
            }

#           Plot a no-data message
            if ($np == 0 || ! $flow_data) {
                if ($gr_props{$id}{ytype} ne "Depth" && $wsurf{$dt} ne "na") {
                    $yp  = $y2 -($y2-$y1)*($surf_elev-$ymin)/$yrange +5;
                    $anc = 'n';
                    if ($yp < $y1 || $yp > $y2) {
                        $yp  = ($y1 +$y2)/2.;
                        $anc = 'center';
                    }
                } else {
                    $yp  = ($y1 +$y2)/2.;
                    $anc = 'center';
                }
                $msg = ($np == 0) ? "No Data" : "No Outlet Flow Data";
                $canvas->create_text(($x1+$x2)/2, $yp,
                                -anchor => $anc, 
                                -text   => $msg,
                                -fill   => &get_rgb_code("gray60"),
                                -angle  => 0,
                                -tags   => $gtag . " " . $gtag . "_profile",
                                -font   => [-family     => $gr_props{$id}{xfont},
                                            -size       => $gr_props{$id}{xl_size},
                                            -weight     => 'normal',
                                            -slant      => 'roman',
                                            -underline  => 0,
                                            -overstrike => 0,
                                           ]);
            }
            undef %wsurf;

#           Draw the layer-specific flow graph
            if ($np > 0 && $flow_data) {

#               Create an image to hold the color profile and recognize its methods
                if ($gr_props{$id}{add_cs}) {
                    $iw = $x2 -$x1 +1;
                    $ih = $y2 -$y1 +1;
                    $cmap_image = Tkx::image_create_photo(-width => $iw, -height => $ih);
                    $cmap_image = Tkx::widget->new($cmap_image);
                }

                if ($gr_props{$id}{qunits} eq "cfs/ft") {      # outflow per unit height
                    $qmult = 10.763911;
                } elsif ($gr_props{$id}{qunits} eq "cms/m") {  # outflow per unit height
                    $qmult = 1.0;
                } else {                                 # swap for velocity data
                    @qtot  = @vtot;
                    $qmult = ($gr_props{$id}{qunits} eq "ft/s") ? 3.28084 : 1.0;
                }
                @coords  = ();
                $last_xp = $x1;
                for ($k=1; $k<=$kbot; $k++) {
                    next if ($el[$k+1] >= $surf_elev);
                    if ($gr_props{$id}{ytype} eq "Depth") {
                        last if ($surf_elev -$el[$k] > $ymax);
                    } else {
                        next if ($el[$k+1] > $ymax);
                        last if ($el[$k]   < $ymin);
                    }
                    if ($gr_props{$id}{add_cs}) {
                        $xp = &round_to_int(&min($iw-1, ($iw-1)*$qtot[$k]*$qmult/$gr_props{$id}{xmax}));
                        if ($xp > 0) {
                            if ($gr_props{$id}{ytype} eq "Depth") {
                                $yp1 = &round_to_int(($ih-1)*(&max(0.0, $surf_elev-$el[$k]))/$ymax);
                                $yp2 = &round_to_int(($ih-1)*($surf_elev-$el[$k+1])/$ymax);
                            } else {
                                $yp1 = &round_to_int($ih-1 -($ih-1)*(&min($surf_elev,$el[$k])-$ymin)/$yrange);
                                $yp2 = &round_to_int($ih-1 -($ih-1)*($el[$k+1]-$ymin)/$yrange);
                            }
                            $yp1 = &max(0, &min($ih-1, $yp1));
                            $yp2 = &max(0, &min($ih-1, $yp2));
                            if ($props{$id}{wt_units} eq "Fahrenheit") {
                                $j = int(($#colors+1) *(($t[$k] *1.8 +32)-$cs_min)/$cs_range);
                            } else {
                                $j = int(($#colors+1) *($t[$k]-$cs_min)/$cs_range);
                            }
                            $j = &max(0, &min($#colors, $j));
                            $cmap_image->put($colors[$j], -to => 0, $yp1, $xp, $yp2);
                        }
                    }
                    $xp = &min($x2, $x1 +($x2-$x1)*$qtot[$k]*$qmult/$gr_props{$id}{xmax});
                    if ($gr_props{$id}{ytype} eq "Depth") {
                        $yp1 = $y1 +($y2-$y1)*(&max(0.0, $surf_elev-$el[$k]))/$ymax;
                        $yp2 = $y1 +($y2-$y1)*($surf_elev-$el[$k+1])/$ymax;
                    } else {
                        $yp1 = $y2 -($y2-$y1)*(&min($surf_elev, $el[$k])-$ymin)/$yrange;
                        $yp2 = $y2 -($y2-$y1)*($el[$k+1]-$ymin)/$yrange;
                    }
                    $yp1 = &max($y1, &min($y2, $yp1));
                    $yp2 = &max($y1, &min($y2, $yp2));
                    if ($xp == $last_xp) {
                        push (@coords, $xp, $yp1) if ($#coords < 0);
                        push (@coords, $xp, $yp2);
                    } else {
                        push (@coords, $last_xp, $yp1, $xp, $yp1, $xp, $yp2);
                    }
                    if ($k == $kbot && $xp != $x1) {
                        push (@coords, $x1, $yp2);
                    }
                    $last_xp = $xp;
                    last if ($yp2 == $y2);
                }
                if ($gr_props{$id}{add_cs}) {
                    $canvas->create_image($x1, $y1,
                                          -anchor => 'nw',
                                          -image  => $cmap_image,
                                          -tags   => $gtag . " " . $gtag . "_colorProfile");
                    undef $cmap_image;
                }

#               Plot the flow graph
                if ($#coords >= 3) {
                    $canvas->create_line(@coords,
                                         -fill  => &get_rgb_code("black"),
                                         -width => 1,
                                         -arrow => 'none',
                                         -tags  => $gtag . " " . $gtag . "_profile");
                }
            }
        }

#       Update any links
        if ($props{$id}{meta} =~ /^(data_profile|vert_wd_zone|w2_profile|w2_outflow)$/) {
            &update_links($canvas, $id, $dt);
        }

#       Place the graphic items in the proper order
        if ($props{$id}{meta} eq "w2_profile") {
            $canvas->lower($gtag . "_colorProfile", $gtag . "_date") if (defined($gr_props{$id}{add_cs})
                                                                         && $gr_props{$id}{add_cs});
            $canvas->lower($gtag . "_profile",      $gtag . "_date");
            $canvas->lower($gtag . "_refData",      $gtag . "_date")
        } else {
            $canvas->lower($gtag . "_colorProfile", $gtag . "_xaxis") if (defined($gr_props{$id}{add_cs})
                                                                          && $gr_props{$id}{add_cs});
            $canvas->lower($gtag . "_profile", $gtag . "_xaxis");
        }
        $canvas->lower($gtag . "_wlevels", $gtag . "_xaxis") if ($props{$id}{meta} eq "w2_wlevels");
        if ($props{$id}{meta} eq "vert_wd_zone") {
            if ($props{$id}{wd_alg} eq "Libby Dam" && $gr_props{$id}{bh_show}) {
                $canvas->lower($gtag . "_openBH", $id);
            }
        }
        if ($group_tags) {
            foreach $tag (@grp_tags) {
                $canvas->addtag($tag, withtag => $gtag);
            }
        }
    }

#   Update any independent time-series links
    &update_ind_links($canvas);

    Tkx::update_idletasks();
}


################################################################################
#
# Zoom tools
#
################################################################################

sub zoom_toolbar {
    my ($X, $Y) = @_;
    my (
        $fr_btns, $fr_msgs, $frame, $geom, $gkid, $ggkid, $i, $indx, $kid,

        @grandkids, @greatgrandkids, @kids, @zoom_btn, @zoom_btn_img,
        @zoom_btn_img2,
       );

    $zoom_tip = "";

#   Normal zoom toolbar images
    $zoom_btn_img[0] = Tkx::image_create_photo(-file => "${prog_path}images/zoom_in.png");
    $zoom_btn_img[1] = Tkx::image_create_photo(-file => "${prog_path}images/zoom_inX.png");
    $zoom_btn_img[2] = Tkx::image_create_photo(-file => "${prog_path}images/zoom_inY.png");
    $zoom_btn_img[3] = Tkx::image_create_photo(-file => "${prog_path}images/zoom_out.png");
    $zoom_btn_img[4] = Tkx::image_create_photo(-file => "${prog_path}images/zoom_outX.png");
    $zoom_btn_img[5] = Tkx::image_create_photo(-file => "${prog_path}images/zoom_outY.png");
    $zoom_btn_img[6] = Tkx::image_create_photo(-file => "${prog_path}images/zoom_full.png");
    $zoom_btn_img[7] = Tkx::image_create_photo(-file => "${prog_path}images/zoom_fullX.png");
    $zoom_btn_img[8] = Tkx::image_create_photo(-file => "${prog_path}images/zoom_fullY.png");

    if (defined($zoom_tb) && Tkx::winfo_exists($zoom_tb)) {
        if ($zoom_tb->g_wm_title() eq "Zoom toolbar") {
            $zoom_tb->configure(-cursor => $cursor_norm);
            $indx = 0;
            @kids = Tkx::SplitList(Tkx::winfo_children($zoom_tb));
            foreach $kid (@kids) {
                @grandkids = Tkx::SplitList(Tkx::winfo_children($kid));
                foreach $gkid (@grandkids) {
                    @greatgrandkids = Tkx::SplitList(Tkx::winfo_children($gkid));
                    foreach $ggkid (@greatgrandkids) {
                        if (Tkx::winfo_class($ggkid) eq "Button") {
                            $ggkid = Tkx::widget->new($ggkid);
                            $ggkid->configure(-image => $zoom_btn_img[$indx]);
                            $indx++;
                            return if ($indx > 8);
                        }
                    }
                }
            }
            return;
        }
    }

    $geom = sprintf("+%d+%d", $X, $Y);
    $zoom_tb = $main->new_toplevel();
    $zoom_tb->g_wm_transient($main);
    $zoom_tb->g_wm_title("Zoom toolbar");
    $zoom_tb->configure(-cursor => $cursor_norm);
    $zoom_tb->g_wm_geometry($geom);

#   Active zoom toolbar images
    $zoom_btn_img2[0] = Tkx::image_create_photo(-file => "${prog_path}images/zoom_in2.png");
    $zoom_btn_img2[1] = Tkx::image_create_photo(-file => "${prog_path}images/zoom_inX2.png");
    $zoom_btn_img2[2] = Tkx::image_create_photo(-file => "${prog_path}images/zoom_inY2.png");
    $zoom_btn_img2[3] = Tkx::image_create_photo(-file => "${prog_path}images/zoom_out2.png");
    $zoom_btn_img2[4] = Tkx::image_create_photo(-file => "${prog_path}images/zoom_outX2.png");
    $zoom_btn_img2[5] = Tkx::image_create_photo(-file => "${prog_path}images/zoom_outY2.png");
    $zoom_btn_img2[6] = Tkx::image_create_photo(-file => "${prog_path}images/zoom_full2.png");
    $zoom_btn_img2[7] = Tkx::image_create_photo(-file => "${prog_path}images/zoom_fullX2.png");
    $zoom_btn_img2[8] = Tkx::image_create_photo(-file => "${prog_path}images/zoom_fullY2.png");

    $frame = $zoom_tb->new_frame(
                -borderwidth => 2,
                -relief      => 'groove');
    $frame->g_pack(-anchor => 'nw', -expand => 1, -fill => 'x');
    $fr_btns = $frame->new_frame();
    $fr_btns->g_grid(-row => 0, -column => 0, -sticky => 'nw', -padx => 0, -pady => 0);
    ($zoom_btn[0] = $fr_btns->new_button(
                -repeatdelay    => 100000,
                -repeatinterval => 100000,
                -image          => $zoom_btn_img[0],
                -command        => sub { &forget_drawing('') if ($zoom_tip =~ /Select|Draw/);
                                         $zoom_tip = "Draw a zoom box on a TS graph...";
                                         $zoom_tb->configure(-cursor => $cursor_draw);
                                         $zoom_btn[0]->configure(-image => $zoom_btn_img2[0]);
                                         &prepare_to("zoom_in");
                                       },
                ))->g_pack(-side => 'left', -padx => 0, -pady => 1);
    ($zoom_btn[1] = $fr_btns->new_button(
                -repeatdelay    => 100000,
                -repeatinterval => 100000,
                -image          => $zoom_btn_img[1],
                -command        => sub { &forget_drawing('') if ($zoom_tip =~ /Select|Draw/);
                                         $zoom_tip = "Draw an X zoom bar on a TS graph...";
                                         $zoom_tb->configure(-cursor => $cursor_draw);
                                         $zoom_btn[1]->configure(-image => $zoom_btn_img2[1]);
                                         &prepare_to("zoom_in_X");
                                       },
                ))->g_pack(-side => 'left', -padx => 0, -pady => 1);
    ($zoom_btn[2] = $fr_btns->new_button(
                -repeatdelay    => 100000,
                -repeatinterval => 100000,
                -image          => $zoom_btn_img[2],
                -command        => sub { &forget_drawing('') if ($zoom_tip =~ /Select|Draw/);
                                         $zoom_tip = "Draw a Y zoom bar on a TS graph...";
                                         $zoom_tb->configure(-cursor => $cursor_draw);
                                         $zoom_btn[2]->configure(-image => $zoom_btn_img2[2]);
                                         &prepare_to("zoom_in_Y");
                                       },
                ))->g_pack(-side => 'left', -padx => 0, -pady => 1);
    ($zoom_btn[3] = $fr_btns->new_button(
                -repeatdelay    => 100000,
                -repeatinterval => 100000,
                -image          => $zoom_btn_img[3],
                -command        => sub { &forget_drawing('') if ($zoom_tip =~ /Select|Draw/);
                                         $zoom_tip = "Select a TS graph... (Zoom Out)";
                                         $zoom_tb->configure(-cursor => $cursor_hand);
                                         $zoom_btn[3]->configure(-image => $zoom_btn_img2[3]);
                                         &prepare_to("zoom_out");
                                       },
                ))->g_pack(-side => 'left', -padx => 0, -pady => 1);
    ($zoom_btn[4] = $fr_btns->new_button(
                -repeatdelay    => 100000,
                -repeatinterval => 100000,
                -image          => $zoom_btn_img[4],
                -command        => sub { &forget_drawing('') if ($zoom_tip =~ /Select|Draw/);
                                         $zoom_tip = "Select a TS graph... (Zoom Out X)";
                                         $zoom_tb->configure(-cursor => $cursor_hand);
                                         $zoom_btn[4]->configure(-image => $zoom_btn_img2[4]);
                                         &prepare_to("zoom_out_X");
                                       },
                ))->g_pack(-side => 'left', -padx => 0, -pady => 1);
    ($zoom_btn[5] = $fr_btns->new_button(
                -repeatdelay    => 100000,
                -repeatinterval => 100000,
                -image          => $zoom_btn_img[5],
                -command        => sub { &forget_drawing('') if ($zoom_tip =~ /Select|Draw/);
                                         $zoom_tip = "Select a TS graph... (Zoom Out Y)";
                                         $zoom_tb->configure(-cursor => $cursor_hand);
                                         $zoom_btn[5]->configure(-image => $zoom_btn_img2[5]);
                                         &prepare_to("zoom_out_Y");
                                       },
                ))->g_pack(-side => 'left', -padx => 0, -pady => 1);
    ($zoom_btn[6] = $fr_btns->new_button(
                -repeatdelay    => 100000,
                -repeatinterval => 100000,
                -image          => $zoom_btn_img[6],
                -command        => sub { &forget_drawing('') if ($zoom_tip =~ /Select|Draw/);
                                         $zoom_tip = "Select a TS graph... (Zoom Full Extent)";
                                         $zoom_tb->configure(-cursor => $cursor_hand);
                                         $zoom_btn[6]->configure(-image => $zoom_btn_img2[6]);
                                         &prepare_to("zoom_full");
                                       },
                ))->g_pack(-side => 'left', -padx => 0, -pady => 1);
    ($zoom_btn[7] = $fr_btns->new_button(
                -repeatdelay    => 100000,
                -repeatinterval => 100000,
                -image          => $zoom_btn_img[7],
                -command        => sub { &forget_drawing('') if ($zoom_tip =~ /Select|Draw/);
                                         $zoom_tip = "Select a TS graph... (Zoom X Full Extent)";
                                         $zoom_tb->configure(-cursor => $cursor_hand);
                                         $zoom_btn[7]->configure(-image => $zoom_btn_img2[7]);
                                         &prepare_to("zoom_full_X");
                                       },
                ))->g_pack(-side => 'left', -padx => 0, -pady => 1);
    ($zoom_btn[8] = $fr_btns->new_button(
                -repeatdelay    => 100000,
                -repeatinterval => 100000,
                -image          => $zoom_btn_img[8],
                -command        => sub { &forget_drawing('') if ($zoom_tip =~ /Select|Draw/);
                                         $zoom_tip = "Select a TS graph... (Zoom Y Full Extent)";
                                         $zoom_tb->configure(-cursor => $cursor_hand);
                                         $zoom_btn[8]->configure(-image => $zoom_btn_img2[8]);
                                         &prepare_to("zoom_full_Y");
                                       },
                ))->g_pack(-side => 'left', -padx => 0, -pady => 1);

    $fr_msgs = $frame->new_frame();
    $fr_msgs->g_grid(-row => 1, -column => 0, -sticky => 'nsew', -padx => 0, -pady => 0);
    $fr_msgs->new_label(
                -textvariable => \$zoom_tip,
                -justify      => 'left',
                -font         => 'default',
                )->g_pack(-side => 'left', -padx => 1, -pady => 1);

#   Bindings for mouse focus
    $zoom_btn[0]->g_bind("<Enter>", sub { $zoom_tip = "Zoom In"
                                                      if ($zoom_tip !~ /(Select|Draw)/); });
    $zoom_btn[1]->g_bind("<Enter>", sub { $zoom_tip = "Zoom In, X only"
                                                      if ($zoom_tip !~ /(Select|Draw)/); });
    $zoom_btn[2]->g_bind("<Enter>", sub { $zoom_tip = "Zoom In, Y only"
                                                      if ($zoom_tip !~ /(Select|Draw)/); });
    $zoom_btn[3]->g_bind("<Enter>", sub { $zoom_tip = "Zoom Out"
                                                      if ($zoom_tip !~ /(Select|Draw)/); });
    $zoom_btn[4]->g_bind("<Enter>", sub { $zoom_tip = "Zoom Out, X only"
                                                      if ($zoom_tip !~ /(Select|Draw)/); });
    $zoom_btn[5]->g_bind("<Enter>", sub { $zoom_tip = "Zoom Out, Y only"
                                                      if ($zoom_tip !~ /(Select|Draw)/); });
    $zoom_btn[6]->g_bind("<Enter>", sub { $zoom_tip = "Zoom to Full Extent"
                                                      if ($zoom_tip !~ /(Select|Draw)/); });
    $zoom_btn[7]->g_bind("<Enter>", sub { $zoom_tip = "Zoom to X Full Extent"
                                                      if ($zoom_tip !~ /(Select|Draw)/); });
    $zoom_btn[8]->g_bind("<Enter>", sub { $zoom_tip = "Zoom to Y Full Extent"
                                                      if ($zoom_tip !~ /(Select|Draw)/); });
    for ($i=0; $i<=8; $i++) {
        $zoom_btn[$i]->g_bind("<Leave>", sub { $zoom_tip = "" if ($zoom_tip =~ /^Zoom/); });
    }

#   Bindings for keyboard focus
    $zoom_btn[0]->g_bind("<FocusIn>", sub { $zoom_btn[0]->configure(-default => 'active');
                                            $zoom_tip = "Zoom In"
                                                        if ($zoom_tip !~ /(Select|Draw)/); });
    $zoom_btn[1]->g_bind("<FocusIn>", sub { $zoom_btn[1]->configure(-default => 'active');
                                            $zoom_tip = "Zoom In, X only"
                                                        if ($zoom_tip !~ /(Select|Draw)/); });
    $zoom_btn[2]->g_bind("<FocusIn>", sub { $zoom_btn[2]->configure(-default => 'active');
                                            $zoom_tip = "Zoom In, Y only"
                                                        if ($zoom_tip !~ /(Select|Draw)/); });
    $zoom_btn[3]->g_bind("<FocusIn>", sub { $zoom_btn[3]->configure(-default => 'active');
                                            $zoom_tip = "Zoom Out"
                                                        if ($zoom_tip !~ /(Select|Draw)/); });
    $zoom_btn[4]->g_bind("<FocusIn>", sub { $zoom_btn[4]->configure(-default => 'active');
                                            $zoom_tip = "Zoom Out, X only"
                                                        if ($zoom_tip !~ /(Select|Draw)/); });
    $zoom_btn[5]->g_bind("<FocusIn>", sub { $zoom_btn[5]->configure(-default => 'active');
                                            $zoom_tip = "Zoom Out, Y only"
                                                        if ($zoom_tip !~ /(Selec|Drawt)/); });
    $zoom_btn[6]->g_bind("<FocusIn>", sub { $zoom_btn[6]->configure(-default => 'active');
                                            $zoom_tip = "Zoom to Full Extent"
                                                        if ($zoom_tip !~ /(Sele|Drawct)/); });
    $zoom_btn[7]->g_bind("<FocusIn>", sub { $zoom_btn[7]->configure(-default => 'active');
                                            $zoom_tip = "Zoom to X Full Extent"
                                                        if ($zoom_tip !~ /(Sele|Drawct)/); });
    $zoom_btn[8]->g_bind("<FocusIn>", sub { $zoom_btn[8]->configure(-default => 'active');
                                            $zoom_tip = "Zoom to Y Full Extent"
                                                        if ($zoom_tip !~ /(Sele|Drawct)/); });
    for ($i=0; $i<=8; $i++) {
        $zoom_btn[$i]->g_bind("<FocusOut>", sub { $zoom_btn[$i]->configure(-default => 'normal'); });
    }

#   Bindings to restore button shape after keyboard input is sustained
    for ($i=0; $i<=8; $i++) {
        $zoom_btn[$i]->g_bind("<KeyPress>", [\&restore_btn, Tkx::Ev("%k"), $zoom_btn[$i] ]);
    }

    Tkx::wm_resizable($zoom_tb,0,0);
    &adjust_window_position($zoom_tb);
    $zoom_tb->g_focus;
}


sub begin_zoom_box {
    my ($x, $y, $canv, $id, $action) = @_;
    my (
        $x1, $x2, $y1, $y2, $zbox, $zxbar, $zybar,
       );

    $canv->delete("zoom_box");
    $canv->delete("zoom_bar");

    $zbox = $zxbar = $zybar = "";

    ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
    ($x, $y) = &get_xy($canv, $x, $y, 0);
    $x = $x1 if ($x < $x1);
    $x = $x2 if ($x > $x2);
    $y = $y1 if ($y < $y1);
    $y = $y2 if ($y > $y2);
    if ($action eq "zoom_in") {
        $zbox = $canv->create_rectangle($x, $y, $x, $y,
                       -outline => &get_rgb_code("blue"),
                       -width   => 1,
                       -fill    => "",
                       -tags    => "zoom_box");
    }
    if ($action =~ /^(zoom_in|zoom_in_X)$/) {
        $zxbar = $canv->create_rectangle($x, $y2, $x, $y2+4,
                        -outline => "",
                        -width   => 0,
                        -fill    => &get_rgb_code("blue"),
                        -tags    => "zoom_bar");
    }
    if ($action =~ /^(zoom_in|zoom_in_Y)$/) {
        $zybar = $canv->create_rectangle($x1-4, $y, $x1, $y,
                        -outline => "",
                        -width   => 0,
                        -fill    => &get_rgb_code("blue"),
                        -tags    => "zoom_bar");
    }
    $canv->g_bind("<Motion>",          [ \&draw_zoom_box, Tkx::Ev("%x","%y"), $canv, $id, $action,
                                                          $zbox, $zxbar, $zybar, $x, $y ]);
    $canv->g_bind("<ButtonRelease-1>", [ \&end_zoom_box,  Tkx::Ev("%x","%y"), $canv, $id, $action, $x, $y ]);
}


sub draw_zoom_box {
    my ($x, $y, $canv, $id, $action, $zbox, $zxbar, $zybar, $xo, $yo) = @_;
    my (
        $x1, $x2, $xloc1, $xloc2, $xmax, $xmin, $xtype, $y1, $y2, $yloc1,
        $yloc2, $ymax, $ymin,
       );

    ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
    $xmin  = $gr_props{$id}{xmin};
    $xmax  = $gr_props{$id}{xmax};
    $ymin  = $gr_props{$id}{ymin};
    $ymax  = $gr_props{$id}{ymax};
    $xtype = $gr_props{$id}{xtype};

    ($x, $y) = &get_xy($canv, $x, $y, 0);
    $x = $x1 if ($x < $x1);
    $x = $x2 if ($x > $x2);
    $y = $y1 if ($y < $y1);
    $y = $y2 if ($y > $y2);

    if ($action eq "zoom_in") {
        $canv->coords($zbox, $xo, $yo, $x, $y);
    }
    if ($action =~ /^(zoom_in|zoom_in_X)$/) {
        $canv->coords($zxbar, $xo, $y2, $x, $y2+4);
        if ($xtype eq "Date/Time") {
            $xmin  = &datelabel2jdate($xmin);
            $xmax  = &datelabel2jdate($xmax);
            $xloc1 = $xmin + ($xmax -$xmin) *(&min($xo, $x) -$x1) /($x2 -$x1);
            $xloc2 = $xmin + ($xmax -$xmin) *(&max($xo, $x) -$x1) /($x2 -$x1);
            $xloc1 = &jdate2datelabel($xloc1, "Mon-DD-YYYY");
            $xloc2 = &jdate2datelabel($xloc2, "Mon-DD-YYYY");
        } else {
            $xloc1 = $xmin + ($xmax -$xmin) *(&min($xo, $x) -$x1) /($x2 -$x1);
            $xloc2 = $xmin + ($xmax -$xmin) *(&max($xo, $x) -$x1) /($x2 -$x1);
        }
    }
    if ($action =~ /^(zoom_in|zoom_in_Y)$/) {
        $canv->coords($zybar, $x1-4, $yo, $x1, $y);
        $yloc1 = $ymin + ($ymax -$ymin) *($y2 - &max($yo, $y)) /($y2 -$y1);
        $yloc2 = $ymin + ($ymax -$ymin) *($y2 - &min($yo, $y)) /($y2 -$y1);
    }
    if ($action eq "zoom_in_X") {
        if ($xtype eq "Date/Time") {
            $status_line = sprintf("Zoom X: %s to %s", $xloc1, $xloc2);
        } else {
            $status_line = sprintf("Zoom X: %.2f to %.2f", $xloc1, $xloc2);
        }
    } elsif ($action eq "zoom_in_Y") {
        $status_line = sprintf("Zoom Y: %.2f to %.2f", $yloc1, $yloc2);
    } else {
        if ($xtype eq "Date/Time") {
            $status_line = sprintf("Zoom X,Y: %s to %s, %.2f to %.2f", $xloc1, $xloc2, $yloc1, $yloc2);
        } else {
            $status_line = sprintf("Zoom X,Y: %.2f to %.2f, %.2f to %.2f", $xloc1, $xloc2, $yloc1, $yloc2);
        }
    }
}


sub end_zoom_box {
    my ($x, $y, $canv, $id, $action, $xo, $yo) = @_;
    my (
        $x1, $x2, $xloc1, $xloc2, $xmax, $xmin, $xtype, $y1, $y2, $yloc1,
        $yloc2, $ymax, $ymin,
       );

    ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
    $xmin  = $gr_props{$id}{xmin};
    $xmax  = $gr_props{$id}{xmax};
    $ymin  = $gr_props{$id}{ymin};
    $ymax  = $gr_props{$id}{ymax};
    $xtype = $gr_props{$id}{xtype};

    ($x, $y) = &get_xy($canv, $x, $y, 0);
    $x = $x1 if ($x < $x1);
    $x = $x2 if ($x > $x2);
    $y = $y1 if ($y < $y1);
    $y = $y2 if ($y > $y2);

    if ($action eq "zoom_in" && ($x == $xo || $y == $yo)) {
        $canv->delete("zoom_box");
        &prepare_to("zoom_in");
        return;
    } elsif ($action eq "zoom_in_X" && $x == $xo) {
        &prepare_to("zoom_in_X");
        return;
    } elsif ($action eq "zoom_in_Y" && $y == $yo) {
        &prepare_to("zoom_in_Y");
        return;
    }
    if ($action =~ /^(zoom_in|zoom_in_X)$/) {
        if ($xtype eq "Date/Time") {
            $xmin  = &datelabel2jdate($xmin);
            $xmax  = &datelabel2jdate($xmax);
            $xloc1 = $xmin + ($xmax -$xmin) *(&min($xo, $x) -$x1) /($x2 -$x1);
            $xloc2 = $xmin + ($xmax -$xmin) *(&max($xo, $x) -$x1) /($x2 -$x1);
            $xloc1 = &jdate2datelabel($xloc1, "Mon-DD-YYYY");
            $xloc2 = &jdate2datelabel($xloc2, "Mon-DD-YYYY");
        } else {
            $xloc1 = $xmin + ($xmax -$xmin) *(&min($xo, $x) -$x1) /($x2 -$x1);
            $xloc2 = $xmin + ($xmax -$xmin) *(&max($xo, $x) -$x1) /($x2 -$x1);
        }
    }
    if ($action =~ /^(zoom_in|zoom_in_Y)$/) {
        $yloc1 = $ymin + ($ymax -$ymin) *($y2 - &max($yo, $y)) /($y2 -$y1);
        $yloc2 = $ymin + ($ymax -$ymin) *($y2 - &min($yo, $y)) /($y2 -$y1);
    }

    $canv->delete("zoom_box");
    $canv->delete("zoom_bar");

    if ($action eq "zoom_in") {
        &zoom_in($canv, $id, $xloc1, $xloc2, $yloc1, $yloc2);
    } elsif ($action eq "zoom_in_X") {
        &zoom_in_X($canv, $id, $xloc1, $xloc2);
    } elsif ($action eq "zoom_in_Y") {
        &zoom_in_Y($canv, $id, $yloc1, $yloc2);
    }
}


sub zoom_in {
    my ($canv, $id, $xmin, $xmax, $ymin, $ymax) = @_;
    my (
        $base_jd, $geom, $jd1, $jd2, $tabid, $X, $Y, $ymajor,
       );

    &end_select($canv, $id, 1);
    &reset_bindings;

#   Set the X axis limits and adjust the axis format or major tick spacing, if needed
    $gr_props{$id}{xmin} = $xmin;
    $gr_props{$id}{xmax} = $xmax;
    if ($gr_props{$id}{xtype} eq "Date/Time") {
        $jd1 = &datelabel2jdate($xmin);
        $jd2 = &datelabel2jdate($xmax);
        if ($xmin eq $xmax) {
            $jd2++;
            $gr_props{$id}{xmax} = &jdate2datelabel($jd2, "Mon-DD-YYYY");
        }
        if ($gr_props{$id}{datefmt} eq "Year" && $jd2 -$jd1 <= 365 *2) {
            $gr_props{$id}{datefmt} = "Month";
        } elsif ($gr_props{$id}{datefmt} eq "Month" && $jd2 -$jd1 >= 365 *5) {
            $gr_props{$id}{datefmt} = "Year";
        } elsif ($gr_props{$id}{datefmt} =~ /Mon-DD/) {
            if ($gr_props{$id}{xmajor} ne "auto" && ($jd2 -$jd1) /$gr_props{$id}{xmajor} < 5) {
                $gr_props{$id}{xmajor} = &max(1, int((($jd2 -$jd1) /30. +2.51)/5.) *5.);
                if (($jd2 -$jd1) /$gr_props{$id}{xmajor} < 5 && $gr_props{$id}{xmajor} != 1) {
                    $gr_props{$id}{xmajor} = &max(1, int((($jd2 -$jd1) /30. +2.51)/5.));
                }
            }
        }
    } else {
        if ($xmin == $xmax) {
            $xmin = $gr_props{$id}{xmin} = $xmin -0.5;
            $xmax = $gr_props{$id}{xmax} = $xmax +0.5;
        }
        $base_jd = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
        $jd1     = $xmin +$base_jd -1;
        $jd2     = $xmax +$base_jd -1;
        if ($gr_props{$id}{xmajor} ne "auto" && ($jd2 -$jd1) /$gr_props{$id}{xmajor} < 5) {
            $gr_props{$id}{xmajor} = &max(1, int((($jd2 -$jd1) /30. +2.51)/5.) *5.);
            if (($jd2 -$jd1) /$gr_props{$id}{xmajor} < 5 && $gr_props{$id}{xmajor} != 1) {
                $gr_props{$id}{xmajor} = &max(1, int((($jd2 -$jd1) /30. +2.51)/5.));
            }
        }
    }

#   Set the Y axis limits and major spacing
    ($ymin, $ymax, $ymajor) = &find_axis_limits($ymin, $ymax);
    $gr_props{$id}{ymin}    = $ymin;
    $gr_props{$id}{ymax}    = $ymax;
    $gr_props{$id}{ymajor}  = $ymajor;

#   Redraw the graph
    $gr_props{$id}{redraw} = 1;
    &make_ts_graph($canv, $id, 1);

#   Refresh the Graph Properties menu, if present
    if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
        if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
            $tabid = $grprops_notebook->index('current');
            $geom  = $graph_props_menu->g_wm_geometry();
            (undef, $X, $Y) = split(/\+/, $geom);
            &edit_graph_props($id, $X, $Y, $tabid);
        }
    }
}


sub zoom_in_X {
    my ($canv, $id, $xmin, $xmax) = @_;
    my (
        $base_jd, $geom, $jd1, $jd2, $tabid, $X, $Y,
       );

    &end_select($canv, $id, 1);
    &reset_bindings;

#   Set the X axis limits and adjust the axis format or major tick spacing, if needed
    $gr_props{$id}{xmin} = $xmin;
    $gr_props{$id}{xmax} = $xmax;
    if ($gr_props{$id}{xtype} eq "Date/Time") {
        $jd1 = &datelabel2jdate($xmin);
        $jd2 = &datelabel2jdate($xmax);
        if ($xmin eq $xmax) {
            $jd2++;
            $gr_props{$id}{xmax} = &jdate2datelabel($jd2, "Mon-DD-YYYY");
        }
        if ($gr_props{$id}{datefmt} eq "Year" && $jd2 -$jd1 <= 365 *2) {
            $gr_props{$id}{datefmt} = "Month";
        } elsif ($gr_props{$id}{datefmt} eq "Month" && $jd2 -$jd1 >= 365 *5) {
            $gr_props{$id}{datefmt} = "Year";
        } elsif ($gr_props{$id}{datefmt} =~ /Mon-DD/) {
            if ($gr_props{$id}{xmajor} ne "auto" && ($jd2 -$jd1) /$gr_props{$id}{xmajor} < 5) {
                $gr_props{$id}{xmajor} = &max(1, int((($jd2 -$jd1) /30. +2.51)/5.) *5.);
                if (($jd2 -$jd1) /$gr_props{$id}{xmajor} < 5 && $gr_props{$id}{xmajor} != 1) {
                    $gr_props{$id}{xmajor} = &max(1, int((($jd2 -$jd1) /30. +2.51)/5.));
                }
            }
        }
    } else {
        if ($xmin == $xmax) {
            $xmin = $gr_props{$id}{xmin} = $xmin -0.5;
            $xmax = $gr_props{$id}{xmax} = $xmax +0.5;
        }
        $base_jd = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
        $jd1     = $xmin +$base_jd -1;
        $jd2     = $xmax +$base_jd -1;
        if ($gr_props{$id}{xmajor} ne "auto" && ($jd2 -$jd1) /$gr_props{$id}{xmajor} < 5) {
            $gr_props{$id}{xmajor} = &max(1, int((($jd2 -$jd1) /30. +2.51)/5.) *5.);
            if (($jd2 -$jd1) /$gr_props{$id}{xmajor} < 5 && $gr_props{$id}{xmajor} != 1) {
                $gr_props{$id}{xmajor} = &max(1, int((($jd2 -$jd1) /30. +2.51)/5.));
            }
        }
    }

#   Redraw the graph
    $gr_props{$id}{redraw} = 1;
    &make_ts_graph($canv, $id, 1);

#   Refresh the Graph Properties menu, if present
    if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
        if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
            $tabid = $grprops_notebook->index('current');
            $geom  = $graph_props_menu->g_wm_geometry();
            (undef, $X, $Y) = split(/\+/, $geom);
            &edit_graph_props($id, $X, $Y, $tabid);
        }
    }
}


sub zoom_in_Y {
    my ($canv, $id, $ymin, $ymax) = @_;
    my (
        $geom, $tabid, $X, $Y, $ymajor,
       );

    &end_select($canv, $id, 1);
    &reset_bindings;

#   Set the Y axis limits and major spacing, and redraw the graph
    ($ymin, $ymax, $ymajor) = &find_axis_limits($ymin, $ymax);
    $gr_props{$id}{ymin}    = $ymin;
    $gr_props{$id}{ymax}    = $ymax;
    $gr_props{$id}{ymajor}  = $ymajor;
    $gr_props{$id}{redraw}  = 1;
    &make_ts_graph($canv, $id, 1);

#   Refresh the Graph Properties menu, if present
    if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
        if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
            $tabid = $grprops_notebook->index('current');
            $geom  = $graph_props_menu->g_wm_geometry();
            (undef, $X, $Y) = split(/\+/, $geom);
            &edit_graph_props($id, $X, $Y, $tabid);
        }
    }
}


sub zoom_out {
    my ($canv, $id) = @_;
    my (
        $base_jd, $datemax, $datemin, $dtmax, $dtmin, $geom, $jd_expand,
        $jd1, $jd2, $jdmax, $jdmin, $tabid, $target_range, $X, $Y, $ymajor,
        $ymax, $ymin,
       );

    &end_select($canv, $id, 1);
    &reset_bindings;

#   Get date limits for visible datasets
    ($dtmin, $dtmax, undef, undef) = &find_ts_limits($id, 1);
    return if ($dtmin == -999);
    $dtmax = &adjust_dt_by_day($dtmax, 1);

#   Expand date range by 50 percent, ideally 25 percent on each side
    if ($gr_props{$id}{xtype} eq "Date/Time") {
        $datemin = &datelabel2date($gr_props{$id}{xmin});
        $datemax = &datelabel2date($gr_props{$id}{xmax});
    } else {
        $base_jd = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
        $datemin = substr(&jdate2date($gr_props{$id}{xmin} +$base_jd -1), 0,8);
        $datemax = substr(&jdate2date($gr_props{$id}{xmax} +$base_jd -1), 0,8);
    }
    ($jdmin, $jdmax, $jd1, $jd2) = &dates2jdates($dtmin, $dtmax, $datemin, $datemax);
    $jd_expand    = &max(1, &round_to_int(($jd2 -$jd1) *0.25));
    $target_range = ($jd2 -$jd1) +$jd_expand *2;
    $jd1 = &max($jdmin, $jd1 -$jd_expand);
    $jd2 = &min($jdmax, $jd2 +$jd_expand);
    if ($jd1 == $jdmin) {
        $jd2 = &min($jdmax, $jd1 +$target_range);
    } elsif ($jd2 == $jdmax) {
        $jd1 = &max($jdmin, $jd2 -$target_range);
    }
    if ($gr_props{$id}{xtype} eq "Date/Time") {
        $gr_props{$id}{xmin} = &jdate2datelabel($jd1, "Mon-DD-YYYY");
        $gr_props{$id}{xmax} = &jdate2datelabel($jd2, "Mon-DD-YYYY");
        if ($gr_props{$id}{datefmt} eq "Year" && $jd2 -$jd1 <= 365 *2) {
            $gr_props{$id}{datefmt} = "Month";
        } elsif ($gr_props{$id}{datefmt} eq "Month" && $jd2 -$jd1 >= 365 *5) {
            $gr_props{$id}{datefmt} = "Year";
        } elsif ($gr_props{$id}{datefmt} =~ /Mon-DD/) {
            if ($gr_props{$id}{xmajor} ne "auto" && ($jd2 -$jd1) /$gr_props{$id}{xmajor} > 30) {
                $gr_props{$id}{xmajor} = &max(1, int((($jd2 -$jd1) /30. +2.51)/5.) *5.);
            }
        }
    } else {
        $gr_props{$id}{xmin} = $jd1 -$base_jd +1;
        $gr_props{$id}{xmax} = $jd2 -$base_jd +1;
        if ($gr_props{$id}{xmajor} ne "auto" && ($jd2 -$jd1) /$gr_props{$id}{xmajor} > 30) {
            $gr_props{$id}{xmajor} = &max(1, int((($jd2 -$jd1) /30. +2.51)/5.) *5.);
        }
    }

#   Expand the Y axis range by roughly 1 major tick division in both directions
    $ymin   = $gr_props{$id}{ymin};
    $ymax   = $gr_props{$id}{ymax};
    $ymajor = $gr_props{$id}{ymajor};
    if ($ymajor eq "auto") {
        ($ymin, $ymax, $ymajor) = &find_axis_limits($ymin, $ymax);
    }
    if ($ymin > 0) {
        $ymin = &max(0, $ymin -$ymajor);
    } elsif ($ymin < 0) {
        $ymin -= $ymajor;
    } else {
        $ymax += $ymajor;
    }
    $ymax += $ymajor *0.9;
    ($ymin, $ymax, $ymajor) = &find_axis_limits($ymin, $ymax);
    $gr_props{$id}{ymin}   = $ymin;
    $gr_props{$id}{ymax}   = $ymax;
    $gr_props{$id}{ymajor} = $ymajor;

#   Redraw the graph
    $gr_props{$id}{redraw} = 1;
    &make_ts_graph($canv, $id, 1);

#   Refresh the Graph Properties menu, if present
    if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
        if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
            $tabid = $grprops_notebook->index('current');
            $geom  = $graph_props_menu->g_wm_geometry();
            (undef, $X, $Y) = split(/\+/, $geom);
            &edit_graph_props($id, $X, $Y, $tabid);
        }
    }
}


sub zoom_out_X {
    my ($canv, $id) = @_;
    my (
        $base_jd, $datemax, $datemin, $dtmax, $dtmin, $geom, $jd_expand,
        $jd1, $jd2, $jdmax, $jdmin, $tabid, $target_range, $X, $Y,
       );

    &end_select($canv, $id, 1);
    &reset_bindings;

#   Get date limits for visible datasets
    ($dtmin, $dtmax, undef, undef) = &find_ts_limits($id, 1);
    return if ($dtmin == -999);
    $dtmax = &adjust_dt_by_day($dtmax, 1);

#   Expand date range by 50 percent, ideally 25 percent on each side
    if ($gr_props{$id}{xtype} eq "Date/Time") {
        $datemin = &datelabel2date($gr_props{$id}{xmin});
        $datemax = &datelabel2date($gr_props{$id}{xmax});
    } else {
        $base_jd = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
        $datemin = substr(&jdate2date($gr_props{$id}{xmin} +$base_jd -1), 0,8);
        $datemax = substr(&jdate2date($gr_props{$id}{xmax} +$base_jd -1), 0,8);
    }
    return if ($dtmin == $datemin && $dtmax == $datemax);
    ($jdmin, $jdmax, $jd1, $jd2) = &dates2jdates($dtmin, $dtmax, $datemin, $datemax);
    $jd_expand    = &max(1, &round_to_int(($jd2 -$jd1) *0.25));
    $target_range = ($jd2 -$jd1) +$jd_expand *2;
    $jd1 = &max($jdmin, $jd1 -$jd_expand);
    $jd2 = &min($jdmax, $jd2 +$jd_expand);
    if ($jd1 == $jdmin) {
        $jd2 = &min($jdmax, $jd1 +$target_range);
    } elsif ($jd2 == $jdmax) {
        $jd1 = &max($jdmin, $jd2 -$target_range);
    }
    if ($gr_props{$id}{xtype} eq "Date/Time") {
        $gr_props{$id}{xmin} = &jdate2datelabel($jd1, "Mon-DD-YYYY");
        $gr_props{$id}{xmax} = &jdate2datelabel($jd2, "Mon-DD-YYYY");
        if ($gr_props{$id}{datefmt} eq "Year" && $jd2 -$jd1 <= 365 *2) {
            $gr_props{$id}{datefmt} = "Month";
        } elsif ($gr_props{$id}{datefmt} eq "Month" && $jd2 -$jd1 >= 365 *5) {
            $gr_props{$id}{datefmt} = "Year";
        } elsif ($gr_props{$id}{datefmt} =~ /Mon-DD/) {
            if ($gr_props{$id}{xmajor} ne "auto" && ($jd2 -$jd1) /$gr_props{$id}{xmajor} > 30) {
                $gr_props{$id}{xmajor} = &max(1, int((($jd2 -$jd1) /30. +2.51)/5.) *5.);
            }
        }
    } else {
        $gr_props{$id}{xmin} = $jd1 -$base_jd +1;
        $gr_props{$id}{xmax} = $jd2 -$base_jd +1;
        if ($gr_props{$id}{xmajor} ne "auto" && ($jd2 -$jd1) /$gr_props{$id}{xmajor} > 30) {
            $gr_props{$id}{xmajor} = &max(1, int((($jd2 -$jd1) /30. +2.51)/5.) *5.);
        }
    }
    $gr_props{$id}{redraw} = 1;
    &make_ts_graph($canv, $id, 1);

#   Refresh the Graph Properties menu, if present
    if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
        if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
            $tabid = $grprops_notebook->index('current');
            $geom  = $graph_props_menu->g_wm_geometry();
            (undef, $X, $Y) = split(/\+/, $geom);
            &edit_graph_props($id, $X, $Y, $tabid);
        }
    }
}


sub zoom_out_Y {
    my ($canv, $id) = @_;
    my (
        $geom, $tabid, $X, $Y, $ymajor, $ymax, $ymin,
       );

    &end_select($canv, $id, 1);
    &reset_bindings;

#   Expand the Y axis range by roughly 1 major tick division in both directions
    $ymin   = $gr_props{$id}{ymin};
    $ymax   = $gr_props{$id}{ymax};
    $ymajor = $gr_props{$id}{ymajor};
    if ($ymajor eq "auto") {
        ($ymin, $ymax, $ymajor) = &find_axis_limits($ymin, $ymax);
    }
    if ($ymin > 0) {
        $ymin = &max(0, $ymin -$ymajor);
    } elsif ($ymin < 0) {
        $ymin -= $ymajor;
    } else {
        $ymax += $ymajor;
    }
    $ymax += $ymajor *0.9;
    ($ymin, $ymax, $ymajor) = &find_axis_limits($ymin, $ymax);

    $gr_props{$id}{ymin}   = $ymin;
    $gr_props{$id}{ymax}   = $ymax;
    $gr_props{$id}{ymajor} = $ymajor;
    $gr_props{$id}{redraw} = 1;
    &make_ts_graph($canv, $id, 1);

#   Refresh the Graph Properties menu, if present
    if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
        if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
            $tabid = $grprops_notebook->index('current');
            $geom  = $graph_props_menu->g_wm_geometry();
            (undef, $X, $Y) = split(/\+/, $geom);
            &edit_graph_props($id, $X, $Y, $tabid);
        }
    }
}


sub zoom_full {
    my ($canv, $id) = @_;
    my (
        $base_jd, $datemax, $datemin, $dtmax, $dtmin, $geom, $jd1, $jd2,
        $pmax, $pmin, $tabid, $X, $Y, $ymajor, $ymax, $ymin,
       );

    &end_select($canv, $id, 1);
    &reset_bindings;

    ($dtmin, $dtmax, $pmin, $pmax) = &find_ts_limits($id, 1);
    return if ($dtmin == -999);
    $dtmax = &adjust_dt_by_day($dtmax, 1);
    if ($gr_props{$id}{xtype} eq "Date/Time") {
        $datemin = &datelabel2date($gr_props{$id}{xmin});
        $datemax = &datelabel2date($gr_props{$id}{xmax});
    } else {
        $base_jd = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
        $datemin = substr(&jdate2date($gr_props{$id}{xmin} +$base_jd -1), 0,8);
        $datemax = substr(&jdate2date($gr_props{$id}{xmax} +$base_jd -1), 0,8);
    }

    $ymin   = $gr_props{$id}{ymin};
    $ymax   = $gr_props{$id}{ymax};
    $ymajor = $gr_props{$id}{ymajor};
    if ($ymin > $pmin || $ymax < $pmax || $ymax -$ymin > ($pmax -$pmin) *1.15) {
        ($ymin, $ymax, $ymajor) = &find_axis_limits($pmin, $pmax);
    }
    return if ($dtmin == $datemin && $dtmax == $datemax
               && $ymin == $gr_props{$id}{ymin} && $ymax == $gr_props{$id}{ymax});

    if ($gr_props{$id}{xtype} eq "Date/Time") {
        $gr_props{$id}{xmin} = &date2datelabel($dtmin, "Mon-DD-YYYY");
        $gr_props{$id}{xmax} = &date2datelabel($dtmax, "Mon-DD-YYYY");
        ($jd1, $jd2) = &dates2jdates($dtmin, $dtmax);
        if ($gr_props{$id}{datefmt} eq "Year" && $jd2 -$jd1 <= 365 *2) {
            $gr_props{$id}{datefmt} = "Month";
        } elsif ($gr_props{$id}{datefmt} eq "Month" && $jd2 -$jd1 >= 365 *5) {
            $gr_props{$id}{datefmt} = "Year";
        } elsif ($gr_props{$id}{datefmt} =~ /Mon-DD/) {
            if ($gr_props{$id}{xmajor} ne "auto" && ($jd2 -$jd1) /$gr_props{$id}{xmajor} > 30) {
                $gr_props{$id}{xmajor} = &max(1, int((($jd2 -$jd1) /30. +2.51)/5.) *5.);
            }
        }
    } else {
        ($jd1, $jd2) = &dates2jdates($dtmin, $dtmax);
        $gr_props{$id}{xmin} = $jd1 -$base_jd +1;
        $gr_props{$id}{xmax} = $jd2 -$base_jd +1;
        if ($gr_props{$id}{xmajor} ne "auto" && ($jd2 -$jd1) /$gr_props{$id}{xmajor} > 30) {
            $gr_props{$id}{xmajor} = &max(1, int((($jd2 -$jd1) /30. +2.51)/5.) *5.);
        }
    }
    $gr_props{$id}{ymin}   = $ymin;
    $gr_props{$id}{ymax}   = $ymax;
    $gr_props{$id}{ymajor} = $ymajor;
    $gr_props{$id}{redraw} = 1;
    &make_ts_graph($canv, $id, 1);

#   Refresh the Graph Properties menu, if present
    if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
        if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
            $tabid = $grprops_notebook->index('current');
            $geom  = $graph_props_menu->g_wm_geometry();
            (undef, $X, $Y) = split(/\+/, $geom);
            &edit_graph_props($id, $X, $Y, $tabid);
        }
    }
}


sub zoom_full_X {
    my ($canv, $id) = @_;
    my (
        $base_jd, $datemax, $datemin, $dtmax, $dtmin, $geom, $jd1, $jd2,
        $tabid, $X, $Y,
       );

    &end_select($canv, $id, 1);
    &reset_bindings;

    ($dtmin, $dtmax, undef, undef) = &find_ts_limits($id, 1);
    return if ($dtmin == -999);
    $dtmax = &adjust_dt_by_day($dtmax, 1);
    if ($gr_props{$id}{xtype} eq "Date/Time") {
        $datemin = &datelabel2date($gr_props{$id}{xmin});
        $datemax = &datelabel2date($gr_props{$id}{xmax});
    } else {
        $base_jd = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
        $datemin = substr(&jdate2date($gr_props{$id}{xmin} +$base_jd -1), 0,8);
        $datemax = substr(&jdate2date($gr_props{$id}{xmax} +$base_jd -1), 0,8);
    }
    return if ($dtmin == $datemin && $dtmax == $datemax);

    if ($gr_props{$id}{xtype} eq "Date/Time") {
        $gr_props{$id}{xmin} = &date2datelabel($dtmin, "Mon-DD-YYYY");
        $gr_props{$id}{xmax} = &date2datelabel($dtmax, "Mon-DD-YYYY");
        ($jd1, $jd2) = &dates2jdates($dtmin, $dtmax);
        if ($gr_props{$id}{datefmt} eq "Year" && $jd2 -$jd1 <= 365 *2) {
            $gr_props{$id}{datefmt} = "Month";
        } elsif ($gr_props{$id}{datefmt} eq "Month" && $jd2 -$jd1 >= 365 *5) {
            $gr_props{$id}{datefmt} = "Year";
        } elsif ($gr_props{$id}{datefmt} =~ /Mon-DD/) {
            if ($gr_props{$id}{xmajor} ne "auto" && ($jd2 -$jd1) /$gr_props{$id}{xmajor} > 30) {
                $gr_props{$id}{xmajor} = &max(1, int((($jd2 -$jd1) /30. +2.51)/5.) *5.);
            }
        }
    } else {
        ($jd1, $jd2) = &dates2jdates($dtmin, $dtmax);
        $gr_props{$id}{xmin} = $jd1 -$base_jd +1;
        $gr_props{$id}{xmax} = $jd2 -$base_jd +1;
        if ($gr_props{$id}{xmajor} ne "auto" && ($jd2 -$jd1) /$gr_props{$id}{xmajor} > 30) {
            $gr_props{$id}{xmajor} = &max(1, int((($jd2 -$jd1) /30. +2.51)/5.) *5.);
        }
    }
    $gr_props{$id}{redraw} = 1;
    &make_ts_graph($canv, $id, 1);

#   Refresh the Graph Properties menu, if present
    if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
        if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
            $tabid = $grprops_notebook->index('current');
            $geom  = $graph_props_menu->g_wm_geometry();
            (undef, $X, $Y) = split(/\+/, $geom);
            &edit_graph_props($id, $X, $Y, $tabid);
        }
    }
}


sub zoom_full_Y {
    my ($canv, $id) = @_;
    my (
        $base_jd, $dtmax, $dtmin, $geom, $pmax, $pmin, $tabid, $X, $Y,
        $ymajor, $ymax, $ymin,
       );

    &end_select($canv, $id, 1);
    &reset_bindings;

#   Restrict the search to the dates included in the visible graph
#   dtmin and dtmax will be in YYYYMMDDHHmm format
    if ($gr_props{$id}{xtype} eq "Date/Time") {
        $dtmin = &datelabel2date($gr_props{$id}{xmin}) *10000;
        $dtmax = &datelabel2date($gr_props{$id}{xmax}) *10000;
    } else {
        $base_jd = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
        $dtmin   = &jdate2date($gr_props{$id}{xmin} +$base_jd -1);
        $dtmax   = &jdate2date($gr_props{$id}{xmax} +$base_jd -1);
    }
    ($dtmin, $dtmax, $pmin, $pmax) = &find_ts_limits($id, 1, $dtmin, $dtmax);
    return if ($dtmin == -999);

    $ymin   = $gr_props{$id}{ymin};
    $ymax   = $gr_props{$id}{ymax};
    $ymajor = $gr_props{$id}{ymajor};
    if ($ymin > $pmin || $ymax < $pmax || $ymax -$ymin > ($pmax -$pmin) *1.15) {
        ($ymin, $ymax, $ymajor) = &find_axis_limits($pmin, $pmax);
    }
    return if ($ymin == $gr_props{$id}{ymin} && $ymax == $gr_props{$id}{ymax});

    $gr_props{$id}{ymin}   = $ymin;
    $gr_props{$id}{ymax}   = $ymax;
    $gr_props{$id}{ymajor} = $ymajor;
    $gr_props{$id}{redraw} = 1;
    &make_ts_graph($canv, $id, 1);

#   Refresh the Graph Properties menu, if present
    if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
        if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
            $tabid = $grprops_notebook->index('current');
            $geom  = $graph_props_menu->g_wm_geometry();
            (undef, $X, $Y) = split(/\+/, $geom);
            &edit_graph_props($id, $X, $Y, $tabid);
        }
    }
}


################################################################################
#
# Open or save project files
#
################################################################################

sub open_file {
    my ($file, $revert) = @_;
    my (

        $add_cs, $add_parm, $ahd1, $ahd2, $ahd3, $anchor, $angle, $answer,
        $arrow, $b_ref, $base_yr, $bgrid, $bgrid_col, $bh_bcellh, $bh_bcellw,
        $bh_bcolor, $bh_bwidth, $bh_docked, $bh_font, $bh_show, $bh_size,
        $bh_tcolor, $bh_weight, $bh_xpos, $bh_ypos, $blanks, $br_list,
        $br_list2, $bth_file, $byear, $case_tol, $clines, $color, $con_file,
        $confirm_type, $coordlist, $cs_height, $cs_hide, $cs_link, $cs_major,
        $cs_max, $cs_min, $cs_rev, $cs_width, $cscheme1, $cscheme2, $ctype,
        $ctype2, $data_type, $datafile, $date_axis, $datefmt, $dateline,
        $datelinec, $day, $dbase, $dfirst, $dflip, $dfont, $different,
        $dir, $dl_size, $dl_weight, $dmajor, $dmax, $dmax_auto, $dmin,
        $dop_tics, $dpr_tics, $dref_byear, $dref_ctype, $dref_file,
        $dref_ftype, $dref_lines, $dref_parm, $dref_tol, $dref_type,
        $dref_tzoff, $dref_val, $dsum, $dt, $dt_adj, $dt_begin, $dt_end,
        $dt_limits, $dt_size, $dt_weight, $dt2, $dtitle, $dunits, $elbot,
        $elev_ref, $extra_chk, $family, $fh, $fill, $fillcolor, $flip,
        $flow_file, $fname, $gap_tol, $gnum, $got_anchor, $got_bth_file,
        $got_con_file, $got_coordlist, $got_cpl_file, $got_cpl_file2,
        $got_cpl_info, $got_cpl_info2, $got_file, $got_hh, $got_hw,
        $got_lbc_file, $got_link, $got_links, $got_qla_file, $got_qla_lines,
        $got_text, $got_flow_file, $got_meta, $got_ref, $got_riv_file,
        $got_riv_file2, $got_riv_info, $got_riv_info2, $got_src_file,
        $got_src_file2, $got_src_lines, $got_w2l_file, $got_w2l_file2,
        $got_wl_file, $got_wl_lines, $got_wt_file, $got_x, $got_xc, $got_y,
        $got_yc, $gridcolor, $gridwidth, $gridx, $gridy, $gs_color,
        $gs_edge, $gs_edgec, $gs_fill, $gs_fillc, $gs_fmt, $gs_pos,
        $gs_size, $gs_weight, $gstitle, $gt_size, $gt_weight, $gtfont,
        $gtitle, $h_ref, $hh, $hide_daxis, $hide_taxis, $hide_title, $hw,
        $i, $id, $ihc, $iho, $image, $img, $img_data, $input_section,
        $iwc, $iwo, $j, $jb, $jd_skip, $jw, $k, $kb_seg, $key, $keyfont,
        $keytitle, $kmx, $kn_digits, $kn_size, $kn_weight, $kt, $kt_ref,
        $kt_size, $kt_weight, $lbc_file, $le_edge, $le_edgec, $le_fill,
        $le_fillc, $le_size, $le_weight, $legfont, $legtitle, $line,
        $link_id, $ln_digits, $ln_form, $ln_gnum, $ln_interp, $ln_outlet,
        $ln_tol, $ln_type, $ln_units, $lt_size, $lt_weight, $map_type,
        $match_tol, $matrix, $meta, $mi, $mon, $ms_color, $ms_digits,
        $ms_edge, $ms_edgec, $ms_fill, $ms_fillc, $ms_font, $ms_interp,
        $ms_pos, $ms_size, $ms_slant, $ms_stats, $ms_types, $ms_weight, $n,
        $ncolors, $nd, $nwb, $nww, $parm, $parm_div, $parm_ref, $parm_skip,
        $parm_units, $parm2, $parm2_div, $pbar, $pbar_window, $pc_style,
        $pdates, $pos, $pr_gnum, $pr_linec, $pr_linew, $pr_style, $prof_stat,
        $prof_type, $project_path, $q_ref, $qla_file, $qla_lines, $qunits,
        $r, $ref_color, $ref_ctype, $ref_file, $ref_hide, $ref_linew,
        $ref_size, $ref_tol, $rlines, $scale, $seg, $seg_list, $set, $sfont,
        $sgrid, $sgrid_col, $size, $sl_size, $sl_weight, $slant, $smajor,
        $smooth, $sop_tics, $spr_tics, $src_file, $src_file2, $src_lines,
        $src_lines2, $src_type, $src_type2, $st_size, $st_weight, $stic_loc,
        $stitle, $stype, $swap_order, $tags, $tecplot, $text, $tflip,
        $tfont, $tl_size, $tl_weight, $tmajor, $tmax, $tmin, $tmp_file,
        $top_tics, $tplot, $tpr_tics, $ts_gnum, $ts_id, $ts_type, $ts_units,
        $tt_size, $tt_weight, $ttitle, $ttype, $txt, $type, $tz_offset,
        $underline, $v_ref, $val, $vol, $w2l_file, $w2l_file2, $wb_list,
        $wd_alg, $weight, $width, $wl_color, $wl_grid, $wl_gridc, $wl_file,
        $wl_lines, $wl_style, $wt_file, $wt_units, $x, $xbase, $xc, $xfirst,
        $xflip, $xfont, $xl_size, $xl_weight, $xleg_off, $xmajor, $xmax,
        $xmax_auto, $xmin, $xop_tics, $xpr_tics, $xt_size, $xt_weight,
        $xtitle, $xunits, $xtype, $y, $yc, $yfont, $yl_size, $yl_weight,
        $yleg_off, $ymajor, $ymax, $ymin, $yop_tics, $ypr_tics, $yr,
        $yt_size, $yt_weight, $ytitle, $ytype, $yunits,

        @add_ts_byear, @add_ts_color, @add_ts_ctype, @add_ts_file,
        @add_ts_ftype, @add_ts_lines, @add_ts_param, @add_ts_seg,
        @add_ts_setnum, @add_ts_show, @add_ts_text, @add_ts_tzoff,
        @add_ts_width, @b, @be, @brs, @bs, @bth_files, @coords, @cpl_files,
        @cpl_files2, @cpl_lines, @cpl_lines2, @crop, @cus, @ds, @el,
        @elws, @graph_ids, @graph_nums, @h, @id_list, @kb, @kbsw, @ktsw,
        @mydates, @pdata, @riv_files, @riv_files2, @riv_lines, @riv_lines2,
        @slice_data, @sw_alg, @tecplot, @tecplot2, @tmp_list, @ts_color,
        @ts_show, @ts_width, @tslink_ids, @us, @wbs,

        %add_ts_parms, %bh_config, %data, %elev_data, %kt_data, %limits,
        %matrix_gnums, %parm_data, %parms, %profile, %qdata, %ref_data,
        %ref_profile, %rel_data, %sdata, %td_data, %tmp_data, %vdata,
        %wl_data,
       );

#   Determine whether the operating system tolerates case differences
    $case_tol = File::Spec->case_tolerant();

#   Before opening a file, check to see if any objects on the canvas labeled "keep".
#   Does the user wish to save them before opening a new project?
    @id_list  = Tkx::SplitList($canvas->find_withtag("keep"));
    @tmp_list = @id_list;
    for ($i=0; $i<=$#tmp_list; $i++) {
        $id = $tmp_list[$i];
        if ($props{$id}{type} eq "graph") {
            if (! defined($props{$id}{gnum})) {        # Graph not fully created yet
                $n = &list_match($id, @id_list);
                splice(@id_list, $n, 1) if ($n >= 0);  # Remove from list
            }
        }
    }
    if ($#id_list >= 0) {
        ($tmp_file = $autosave_file) =~ s/\.w2a$/tmp\.w2a/;
        &save_file($tmp_file, 1);

      # If an autosave file already exists, push it to autosave_file2 if different.
      # Don't take this step if loading an autosaved file from this instance of W2Anim.
        if (! defined($file)
              || (  $case_tol && lc($file) ne lc($autosave_file) && lc($file) ne lc($autosave_file2))
              || (! $case_tol &&    $file  ne    $autosave_file  &&    $file  ne    $autosave_file2)) {
            if (-e $autosave_file) {
                $different = &compare_saved($autosave_file, $tmp_file);
                if ($different) {
                    unlink $autosave_file2 if (-e $autosave_file2);
                    move($autosave_file, $autosave_file2);
                    $autosave_menu->entryconfigure('end', -state => 'normal');
                }
            }
            copy($tmp_file, $autosave_file);
            $autosave_menu->entryconfigure(8, -state => 'normal');  # entry 8 is "Revert, recent"
        }

      # Compare current project file to saved file
        if ($savefile ne "" && -e $savefile) {
            $different = &compare_saved($tmp_file, $savefile);
            unlink $tmp_file;
            if ($different) {
                $answer = &pop_up_question($main,
                               "Current project is different than saved\n"
                             . "project file. Do you want to save the\n"
                             . "current project before opening a new one?");
                return &save_file if (lc($answer) eq "yes");
            }
        } else {
            unlink $tmp_file;
            $answer = &pop_up_question($main,
                           "Current project has not been saved. Do you\n"
                         . "want to save it before opening a new one?");
            return &save_file if (lc($answer) eq "yes");
        }
    }

#   Get or process the file name
    if (! defined($file)) {
        $file = Tkx::tk___getOpenFile(
            -parent           => $main,
            -title            => "Open Project File",
            -initialdir       => abs_path(),
            -defaultextension => ".w2a",
            -filetypes => [ ['W2 Animator Files', '.w2a'],
                            ['All Files',  '*'],
                          ],
            );
    }
    return if (! defined($file) || $file eq "");
    if (! -e $file) {
        return &pop_up_error($main, "File not found\nor does not exist");
    }
    $file = File::Spec->rel2abs($file);
    open ($fh, "<", $file) || return &pop_up_error($main, "Unable to open\n$file");

#   Get project path
    ($vol, $dir, $fname) = File::Spec->splitpath($file);
    $project_path = $vol . $dir;
    $revert = 1 if ((  $case_tol && (lc($file) eq lc($autosave_file) || lc($file) eq lc($autosave_file2)))
                 || (! $case_tol && (   $file  eq    $autosave_file  ||    $file  eq    $autosave_file2))
                 || $file =~ /_autosave\d+\.w2a$/ || $file =~ /_autosave\d+_2\.w2a$/);

#   Delete existing stuff on the canvas and reset variables
    @id_list = Tkx::SplitList($canvas->find_all());
    for ($i=0; $i<=$#id_list; $i++) {
        $canvas->delete($id_list[$i]);
    }
    undef $ts_datemin;
    undef $ts_datemax;
    undef $cmap_datemin;
    undef $cmap_datemax;
    undef @dates;
    undef @id_list;
    undef %grid;
    undef %props;
    undef %gr_props;
    undef %link_props;
    undef $old_id if (defined($old_id));
    @animate_ids      = ();
    @ind_link_ids     = ();
    @graph_nums       = ();
    @graph_ids        = ();
    @tslink_ids       = ();
    @dtis_with_pdata  = ();
    %matrix_gnums     = ();
    $w2profile_data   =  0;
    $graph_num        = -1;
    $got_links        =  0;
    $savefile         = "";
    $global_dt_limits =  0;
    $global_dt_begin  = $global_dt_end = "na";
    $anim_tb_status   = "stopped";
    $delay_autosave   =  1;
    $delta_dti        =  1;
    $export_menu->entryconfigure(3, -state => 'disabled');
    $pref_menu->entryconfigure(0,   -state => 'disabled');

#   Kill any open pop-up menus that might be tied to old objects
#   Reset the general and canvas defaults
    &remove_and_restore_menus();

#   Read and parse the file
    while (defined( $line = <$fh> )) {
        $line =~ s/^\s+//;
        $line =~ s/\s+$//;
        next if ($line =~ /^#/ || $line eq "");

        if ($line =~ /==== CANVAS ====/) {
            $input_section = "canvas";
            next;
        } elsif ($line =~ /==== END CANVAS ====/) {
            $canvas_width      = $min_canvas_width  if ($canvas_width  < $min_canvas_width);
            $canvas_height     = $min_canvas_height if ($canvas_height < $min_canvas_height);
            $canvas_width      = 20000              if ($canvas_width  > 20000);
            $canvas_height     = 20000              if ($canvas_height > 20000);
            $max_canvas_width  = $canvas_width      if ($canvas_width  > $max_canvas_width);
            $max_canvas_height = $canvas_height     if ($canvas_height > $max_canvas_height);

            &initialize_canvas_scrollbars();
            $canvas->configure(-background   => &get_rgb_code($canvas_color),
                               -width        => $canvas_width,
                               -height       => $canvas_height,
                               -scrollregion => [0, 0, $canvas_width, $canvas_height],
                              );
            &adjust_main_position();
            $input_section = "none";
            next;
        } elsif ($line =~ /==== DATE LIMITS ====/) {
            $input_section = "date limits";
            next;
        } elsif ($line =~ /==== END DATE LIMITS ====/) {
            $global_dt_limits = 1 if ($global_dt_begin =~ /^[12][0-9][0-9][0-9][01][0-9][0-3][0-9]0000$/ &&
                                      $global_dt_end   =~ /^[12][0-9][0-9][0-9][01][0-9][0-3][0-9]0000$/);
            $input_section = "none";
            next;
        } elsif ($line =~ /==== OBJECTS ====/) {
            $input_section = "objects";
            next;
        } elsif ($line =~ /==== END OBJECTS ====/) {
            $input_section = "none";
            next;
        }
        if ($input_section eq "canvas") {
            if ($line =~ /[a-zA-Z_]+: /) {
                $pos = index($line, ":");
                $key = substr($line, 0, $pos);
                $val = substr($line, $pos + 1);
                $val =~ s/^\s+//;
                $canvas_width      = $val if ($key eq "width");
                $canvas_height     = $val if ($key eq "height");
                $canvas_color      = $val if ($key eq "color");
                $snap2grid         = $val if ($key eq "snap2grid");
                $grid_spacing      = $val if ($key eq "grid_spac");
                $text_select_color = $val if ($key eq "text_slct");
            }
        }
        if ($input_section eq "date limits") {
            if ($line =~ /[a-zA-Z_]+: /) {
                $pos = index($line, ":");
                $key = substr($line, 0, $pos);
                $val = substr($line, $pos + 1);
                $val =~ s/^\s+//;
                if ($key eq "gdt_begin") {
                    if ($val =~ /^[a-z][a-z][a-z]-[0-3]?[0-9]-[12][0-9][0-9][0-9]$/i) {
                        ($mon, $day, $yr) = &parse_date($val, 1);
                        $global_dt_begin = sprintf("%04d%02d%02d0000", $yr, $mon, $day);
                    }
                }
                if ($key eq "gdt_end") {
                    if ($val =~ /^[a-z][a-z][a-z]-[0-3]?[0-9]-[12][0-9][0-9][0-9]$/i) {
                        ($mon, $day, $yr) = &parse_date($val, 1);
                        $global_dt_end = sprintf("%04d%02d%02d0000", $yr, $mon, $day);
                    }
                }
            }
        }
        if ($input_section eq "objects") {
            $got_x = $got_y = $got_xc = $got_yc = $got_hw = $got_hh = 0;
            $got_anchor  = $got_coordlist = $got_text = $got_meta = $got_file = 0;
            $got_wt_file = $got_flow_file = $got_bth_file = $got_lbc_file = 0;
            $got_src_file  = $got_src_lines = $got_link = $got_ref = 0;
            $got_con_file  = $got_cpl_info  = $got_cpl_file  = $got_wl_lines  = 0;
            $got_qla_file  = $got_qla_lines = $got_w2l_file  = $got_wl_file   = 0;
            $got_cpl_info2 = $got_cpl_file2 = $got_w2l_file2 = $got_src_file2 = 0;
            $got_riv_info  = $got_riv_file  = $got_riv_info2 = $got_riv_file2 = 0;

            $tags      = "keep";
            $color     = $default_color;
            $width     = $default_width;
            $fill      = $default_fill;
            $fillcolor = $default_fillcolor;
            $angle     = $default_angle;
            $arrow     = $default_arrow;
            $ahd1      = $default_ahd1;
            $ahd2      = $default_ahd2;
            $ahd3      = $default_ahd3;
            $smooth    = $default_smooth;
            $family    = $default_family;
            $size      = $default_size;
            $weight    = $default_weight;
            $slant     = $default_slant;
            $underline = $default_underline;

            $xleg_off  = 40;
            $yleg_off  =  0;
            $kn_digits =  1;
            $cs_hide   =  0;
            $cs_link   =  0;
            $cs_width  = 24;
            $cs_height = 18;
            $cs_major  = -999;
            $xfont     = $yfont     = $gtfont    = $keyfont   = $tfont   = $dfont   = $default_family;
            $xt_size   = $yt_size   = $gt_size   = $kt_size   = $tt_size = $dt_size = 13;
            $xl_size   = $yl_size   =              $kn_size   = $tl_size = $dl_size = 11;
            $xt_weight = $xl_weight = $tt_weight = $tl_weight = 'normal';
            $yt_weight = $yl_weight = $dt_weight = $dl_weight = 'normal';
            $kt_weight = $kn_weight = 'normal';
            $gt_weight = $gs_weight = 'bold';
            $gs_size   = 12;
            $gs_pos    = "Top Left";
            $gs_fmt    = "DD-Mon-YYYY HH:mm";
            $gs_edge   = 0;
            $gs_edgec  = $gs_color = "black";
            $gs_fill   = 1;
            $gs_fillc  = "white";
            $datefmt   = "Month";
            $dateline  = -1;
            $datelinec = "black";
            $date_axis = "X";
            $wd_alg    = "W2 original";
            $seg       = 0;
            $elbot     = 0;
            $xtitle    = $ytitle    = $gtitle   = $gstitle  = $keytitle = $ttitle = $dtitle = "";
            $wt_file   = $flow_file = $bth_file = $lbc_file = $w2l_file = $w2l_file2 = $wl_file = "";
            $src_file  = $src_type  = $con_file = $ref_file = $qla_file = $src_type2 = $src_file2 = "";
            $src_lines = $qla_lines = $wl_lines = $src_lines2 = $tplot = 0;
            $ln_gnum   = $gnum = 0;
            $ln_type   = "Water Surface Elevation";
            $ln_outlet = "All Outlets";
            $ln_form   = "Text";
            $ln_units  = "";
            $ln_digits = 0;
            $ln_interp = 0;
            $ln_tol    = 10;
            $data_type = "Other";
            $gridx     = $gridy = 0;
            $gridwidth = 1;
            $gridcolor = '#C0C0C0';
            $scale     = 1;
            $flip      = "none";
            @crop      = (0.0, 0.0, 0.0, 0.0);
            $dfirst    = $xfirst = "";
            $dpr_tics  = $tpr_tics = $xpr_tics = $ypr_tics = $spr_tics = "outside";
            $dop_tics  = $top_tics = $xop_tics = $yop_tics = $sop_tics = "none";
            $hide_title = $hide_taxis = $hide_daxis = 0;

            $pr_style  = "Stairstep";
            $pr_linec  = "black";
            $pr_linew  = 1;
            $pc_style  = "By Layer";
            $matrix    = $pdates = $blanks = "";
            $pr_gnum   = -99;

            $ms_stats  = -1;
            $ms_types  = "N ME MAE RMSE";
            $ms_digits = 2;
            $ms_interp = 1;
            $ms_font   = $default_family;
            $ms_size   = $default_size -2;
            $ms_weight = $default_weight;
            $ms_slant  = $default_slant;
            $ms_color  = $default_color;
            $ms_edge   = 0;
            $ms_edgec  = "black";
            $ms_fill   = 0;
            $ms_fillc  = "white";
            $ms_pos    = "Bottom Right";

            $bh_show   = 0;
            $bh_docked = 1;
            $bh_xpos   = -99;
            $bh_ypos   = -99;
            $bh_bcellh = -99;
            $bh_font   = $yfont;
            $bh_size   = $yl_size;
            $bh_weight = $yl_weight;
            $bh_tcolor = $bh_bcolor = "black";
            $bh_bwidth = 1;
            $bh_bcellw = 18;

            $parm      = $parm2     = $parm_units = "";
            $parm_div  = $parm2_div = "None";
            $byear     = "";
            $base_yr   = "";
            $ctype     = $ctype2 = "None";
            $ytype     = "Elevation";
            $yunits    = "feet";
            $qunits    = "cfs";
            $wt_units  = "Celsius";
            $xunits    = $dunits = "miles";
            $xtype     = $ttype  = "Date/Time";
            $xflip     = $tflip  = $dflip = $dmax_auto = $xmax_auto = 0;
            $jd_skip   = 0;
            $extra_chk = 1;
            $seg_list  = $wb_list = $br_list = $br_list2 = $xbase = $dbase = "";
            $map_type  = "standard";
            $tz_offset = "+00:00";
            $dt_limits = 0;
            $dt_begin  = $dt_end = -999;

            $stype     = "none";
            $sfont     = $default_family;
            $st_size   = 13;
            $sl_size   = 11;
            $st_weight = $sl_weight = 'normal';
            $smajor    = "auto";
            $stic_loc  = "upstream edge";
            $sgrid     = $bgrid = 0;
            $sgrid_col = '#C0C0C0';
            $bgrid_col = '#FF8040';
            $stitle    = "Segment Number";

            $add_parm  = 0;
            $parm_skip = 0;
            $match_tol = 10;
            $swap_order= 0;

            $prof_stat = "";
            $prof_type = "standard";
            $dref_type = "Constant";
            $dref_val  = $dref_lines = $dref_byear = $dref_tol = 0;
            $dref_file = $dref_ftype = $dref_parm  = "";
            $dref_ctype = "None";
            $dref_tzoff = "+00:00";

            $ref_ctype = "None";
            $ref_tol   = 10;
            $ref_color = "black";
            $ref_size  = "Medium";
            $ref_linew = 1;
            $ref_hide  = 0;

            @ts_color  = @ts_show = @ts_width = ();
            $ts_gnum   = 0;
            $ts_type   = "Release Rate";
            $ts_units  = "cfs";
            $legtitle  = "";
            $legfont   = $default_family;
            $lt_size   = 13;
            $le_size   = 11;
            $lt_weight = $le_weight = 'normal';
            $le_edge   = $le_fill = 0;
            $le_edgec  = "black";
            $le_fillc  = "white";
            $gap_tol   = 2;
            $wl_color  = "black";
            $wl_style  = "Flat surface";
            $wl_grid   = 0;
            $wl_gridc  = "#D0D0D0";

            @add_ts_setnum = @add_ts_file  = @add_ts_show  = @add_ts_lines = ();
            @add_ts_width  = @add_ts_color = @add_ts_text  = @add_ts_ctype = ();
            @add_ts_ftype  = @add_ts_param = @add_ts_byear = @add_ts_tzoff = @add_ts_seg = ();
            @cpl_files  = @tecplot  = @cpl_lines  = @bth_files = @wbs = ();
            @cpl_files2 = @tecplot2 = @cpl_lines2 = ();
            @riv_files = @riv_lines = @riv_files2 = @riv_lines2 = ();

            if (&list_match($line, @object_types) > -1) {
                $type = $line;
            } else {
                next;
            }
            while (defined( $line = <$fh> ) && $line !~ /end $type/) {
                $line =~ s/^\s+//;
                $line =~ s/\s+$//;
                $pos  = index($line, ":");
                $key  = substr($line, 0, $pos);
                $val  = substr($line, $pos +1);
                $val  =~ s/^\s+//;
                if ($key eq "x") {
                    $x     = $val +3;
                    $got_x = 1;
                } elsif ($key eq "y") {
                    $y     = $val +3;
                    $got_y = 1;
                } elsif ($key eq "xc") {
                    $xc     = $val +3;
                    $got_xc = 1;
                } elsif ($key eq "yc") {
                    $yc     = $val +3;
                    $got_yc = 1;
                } elsif ($key eq "hw") {
                    $hw     = $val;
                    $got_hw = 1;
                } elsif ($key eq "hh") {
                    $hh     = $val;
                    $got_hh = 1;
                } elsif ($key eq "anchor") {
                    $anchor     = $val;
                    $got_anchor = 1;
                } elsif ($key eq "coordlist") {
                    ($coordlist = $val) =~ s/\s+//g;
                    @coords     = split(/,/, $coordlist);
                    for ($i=0; $i<=$#coords; $i++) {
                        $coords[$i] += 3;
                    }
                    $got_coordlist = 1;
                } elsif ($key eq "text") {
                    $text     = $val;
                    $got_text = 1;
                } elsif ($key eq "file") {
                    $datafile = File::Spec->rel2abs($val, $project_path);
                    $got_file = 1;
                } elsif ($key eq "wt_file") {
                    $wt_file = File::Spec->rel2abs($val, $project_path);
                    $got_wt_file = 1;
                } elsif ($key eq "flow_file") {
                    $flow_file = File::Spec->rel2abs($val, $project_path);
                    $got_flow_file = 1;
                } elsif ($key eq "bth_file") {
                    $bth_file = File::Spec->rel2abs($val, $project_path);
                    $got_bth_file = 1;
                } elsif ($key eq "lbc_file") {
                    $lbc_file = File::Spec->rel2abs($val, $project_path);
                    $got_lbc_file = 1;
                } elsif ($key eq "src_file") {
                    $src_file = File::Spec->rel2abs($val, $project_path);
                    $got_src_file = 1;
                } elsif ($key eq "src_file2") {
                    $src_file2 = File::Spec->rel2abs($val, $project_path);
                    $got_src_file2 = 1;
                } elsif ($key eq "src_lines") {
                    $src_lines     = $val;
                    $got_src_lines = 1;
                } elsif ($key eq "src_line2") {
                    $src_lines2 = $val;
                } elsif ($key eq "con_file") {
                    $con_file = File::Spec->rel2abs($val, $project_path);
                    $got_con_file = 1;
                } elsif ($key eq "qla_file") {
                    $qla_file = File::Spec->rel2abs($val, $project_path);
                    $got_qla_file = 1;
                } elsif ($key eq "qla_lines") {
                    $qla_lines     = $val;
                    $got_qla_lines = 1;
                } elsif ($key eq "cpl_info") {
                    ($n, $tecplot, $clines) = split(/,/, $val);
                    $tecplot[$n]   = $tecplot +0;
                    $cpl_lines[$n] = $clines  +0;
                    $got_cpl_info  = 1;
                } elsif ($key eq "cpl_info2") {
                    ($n, $tecplot, $clines) = split(/,/, $val);
                    $tecplot2[$n]   = $tecplot +0;
                    $cpl_lines2[$n] = $clines  +0;
                    $got_cpl_info2  = 1;
                } elsif ($key eq "cpl_files") {
                    ($n, $tmp_file) = split(/,/, $val);
                    $tmp_file =~ s/^\s+//;
                    $cpl_files[$n] = File::Spec->rel2abs($tmp_file, $project_path);
                    $got_cpl_file  = 1;
                } elsif ($key eq "cpl_file2") {
                    ($n, $tmp_file) = split(/,/, $val);
                    $tmp_file =~ s/^\s+//;
                    $cpl_files2[$n] = File::Spec->rel2abs($tmp_file, $project_path);
                    $got_cpl_file2  = 1;
                } elsif ($key eq "riv_info") {
                    ($n, $jb, $rlines) = split(/,/, $val);
                    $br_list      .= ($jb+0) . ",";
                    $riv_lines[$n] = $rlines +0;
                    $got_riv_info  = 1;
                } elsif ($key eq "riv_info2") {
                    ($n, $jb, $rlines) = split(/,/, $val);
                    $br_list2      .= ($jb+0) . ",";
                    $riv_lines2[$n] = $rlines +0;
                    $got_riv_info2  = 1;
                } elsif ($key eq "riv_files") {
                    ($n, $tmp_file) = split(/,/, $val);
                    $tmp_file =~ s/^\s+//;
                    $riv_files[$n] = File::Spec->rel2abs($tmp_file, $project_path);
                    $got_riv_file  = 1;
                } elsif ($key eq "riv_file2") {
                    ($n, $tmp_file) = split(/,/, $val);
                    $tmp_file =~ s/^\s+//;
                    $riv_files2[$n] = File::Spec->rel2abs($tmp_file, $project_path);
                    $got_riv_file2  = 1;
                } elsif ($key eq "bth_files") {
                    ($n, $tmp_file) = split(/,/, $val);
                    $tmp_file =~ s/^\s+//;
                    $bth_files[$n] = File::Spec->rel2abs($tmp_file, $project_path);
                    $got_bth_file  = 1;
                } elsif ($key eq "w2l_file") {
                    $w2l_file = File::Spec->rel2abs($val, $project_path);
                    $got_w2l_file = 1;
                } elsif ($key eq "w2l_file2") {
                    $w2l_file2 = File::Spec->rel2abs($val, $project_path);
                    $got_w2l_file2 = 1;
                } elsif ($key eq "wl_file") {
                    $wl_file = File::Spec->rel2abs($val, $project_path);
                    $got_wl_file = 1;
                } elsif ($key eq "wl_lines") {
                    $wl_lines     = $val;
                    $got_wl_lines = 1;
                } elsif ($key eq "ref_file") {
                    $ref_file = File::Spec->rel2abs($val, $project_path);
                    $got_ref  = 1;
                } elsif ($key eq "meta") {
                    $meta     = $val;
                    $got_meta = 1;
                } elsif ($key eq "ln_gnum") {
                    $ln_gnum  = $val;
                    $got_link = $got_links = 1;
                } elsif ($key eq "crop") {
                    $val =~ s/\s+//g;
                    @crop = split(/,/, $val);  # left, right, top, bottom
                    for ($i=0; $i<4; $i++) {
                        $crop[$i] = &max(0., &min(1., $crop[$i]));
                    }
                    if ($crop[0] +$crop[1] >= 1.0) {
                        $crop[0] = $crop[1] = 0.;
                    }
                    if ($crop[2] +$crop[3] >= 1.0) {
                        $crop[2] = $crop[3] = 0.;
                    }
                }
                $tags     .= " " . $val if ($key eq "grouptags");
                $color     = $val if ($key eq "color");
                $width     = $val if ($key eq "width");
                $fill      = $val if ($key eq "fill");
                $fillcolor = $val if ($key eq "fillcolor");
                $angle     = $val if ($key eq "angle");
                $arrow     = $val if ($key eq "arrow");
                $ahd1      = $val if ($key eq "ahd1");
                $ahd2      = $val if ($key eq "ahd2");
                $ahd3      = $val if ($key eq "ahd3");
                $smooth    = $val if ($key eq "smooth");
                $family    = $val if ($key eq "family");
                $size      = $val if ($key eq "size");
                $weight    = $val if ($key eq "weight");
                $slant     = $val if ($key eq "slant");
                $underline = $val if ($key eq "underline");

                $add_cs    = $val if ($key eq "add_cs");
                $cs_hide   = $val if ($key eq "cs_hide");
                $cs_link   = $val if ($key eq "cs_link");
                $cscheme1  = $val if ($key eq "cscheme1");
                $cscheme2  = $val if ($key eq "cscheme2");
                $ncolors   = $val if ($key eq "ncolors");
                $cs_rev    = $val if ($key eq "cs_rev");
                $cs_min    = $val if ($key eq "cs_min");
                $cs_max    = $val if ($key eq "cs_max");
                $cs_major  = $val if ($key eq "cs_major");
                $cs_width  = $val if ($key eq "cs_width");
                $cs_height = $val if ($key eq "cs_height");
                $xleg_off  = $val if ($key eq "xleg_off");
                $yleg_off  = $val if ($key eq "yleg_off");
                $keyfont   = $val if ($key eq "keyfont");
                $keytitle  = $val if ($key eq "keytitle");
                $kt_size   = $val if ($key eq "kt_size");
                $kt_weight = $val if ($key eq "kt_weight");
                $kn_size   = $val if ($key eq "kn_size");
                $kn_weight = $val if ($key eq "kn_weight");
                $kn_digits = $val if ($key eq "kn_digits");
                $pr_style  = $val if ($key eq "pr_style");
                $pr_linec  = $val if ($key eq "pr_linec");
                $pr_linew  = $val if ($key eq "pr_linew");
                $pc_style  = $val if ($key eq "pc_style");
                $matrix    = $val if ($key eq "matrix");
                $pr_gnum   = $val if ($key eq "pr_gnum");
                $pdates    = $val if ($key eq "pr_dates");
                $blanks    = $val if ($key eq "blanks");
                $xtitle    = $val if ($key eq "xtitle");
                $xfont     = $val if ($key eq "xfont");
                $xt_size   = $val if ($key eq "xt_size");
                $xt_weight = $val if ($key eq "xt_weight");
                $xl_size   = $val if ($key eq "xl_size");
                $xl_weight = $val if ($key eq "xl_weight");
                $xbase     = $val if ($key eq "xbase");
                $xmin      = $val if ($key eq "xmin");
                $xmax      = $val if ($key eq "xmax");
                $xmax_auto = $val if ($key eq "xmax_auto");
                $xfirst    = $val if ($key eq "xfirst");
                $xmajor    = $val if ($key eq "xmajor");
                $xunits    = $val if ($key eq "xunits");
                $xflip     = $val if ($key eq "xflip");
                $xtype     = $val if ($key eq "xtype");
                $base_yr   = $val if ($key eq "base_yr");
                $datefmt   = $val if ($key eq "datefmt");
                $dateline  = $val if ($key eq "dateline");
                $datelinec = $val if ($key eq "datelinec");
                $ytitle    = $val if ($key eq "ytitle");
                $yfont     = $val if ($key eq "yfont");
                $yt_size   = $val if ($key eq "yt_size");
                $yt_weight = $val if ($key eq "yt_weight");
                $yl_size   = $val if ($key eq "yl_size");
                $yl_weight = $val if ($key eq "yl_weight");
                $ymin      = $val if ($key eq "ymin");
                $ymax      = $val if ($key eq "ymax");
                $ymajor    = $val if ($key eq "ymajor");
                $ytype     = $val if ($key eq "ytype");
                $yunits    = $val if ($key eq "yunits");
                $date_axis = $val if ($key eq "date_axis");
                $ttitle    = $val if ($key eq "ttitle");
                $tfont     = $val if ($key eq "tfont");
                $tt_size   = $val if ($key eq "tt_size");
                $tt_weight = $val if ($key eq "tt_weight");
                $tl_size   = $val if ($key eq "tl_size");
                $tl_weight = $val if ($key eq "tl_weight");
                $tmin      = $val if ($key eq "tmin");
                $tmax      = $val if ($key eq "tmax");
                $tmajor    = $val if ($key eq "tmajor");
                $tflip     = $val if ($key eq "tflip");
                $ttype     = $val if ($key eq "ttype");
                $dtitle    = $val if ($key eq "dtitle");
                $dfont     = $val if ($key eq "dfont");
                $dt_size   = $val if ($key eq "dt_size");
                $dt_weight = $val if ($key eq "dt_weight");
                $dl_size   = $val if ($key eq "dl_size");
                $dl_weight = $val if ($key eq "dl_weight");
                $dbase     = $val if ($key eq "dbase");
                $dmin      = $val if ($key eq "dmin");
                $dmax      = $val if ($key eq "dmax");
                $dmax_auto = $val if ($key eq "dmax_auto");
                $dfirst    = $val if ($key eq "dfirst");
                $dmajor    = $val if ($key eq "dmajor");
                $dflip     = $val if ($key eq "dflip");
                $dunits    = $val if ($key eq "dunits");
                $prof_stat = $val if ($key eq "prof_stat");
                $gtfont    = $val if ($key eq "gtfont");
                $gt_size   = $val if ($key eq "gt_size");
                $gt_weight = $val if ($key eq "gt_weight");
                $gtitle    = $val if ($key eq "gtitle");
                $gstitle   = $val if ($key eq "gstitle");
                $gs_size   = $val if ($key eq "gs_size");
                $gs_weight = $val if ($key eq "gs_weight");
                $gs_pos    = $val if ($key eq "gs_pos");
                $gs_fmt    = $val if ($key eq "gs_fmt");
                $gs_color  = $val if ($key eq "gs_color");
                $gs_edge   = $val if ($key eq "gs_edge");
                $gs_edgec  = $val if ($key eq "gs_edgec");
                $gs_fill   = $val if ($key eq "gs_fill");
                $gs_fillc  = $val if ($key eq "gs_fillc");
                $wd_alg    = $val if ($key eq "wd_alg");
                $seg       = $val if ($key eq "seg");
                $elbot     = $val if ($key eq "elbot");
                $gnum      = $val if ($key eq "gnum");
                $ln_type   = $val if ($key eq "ln_type");
                $ln_outlet = $val if ($key eq "ln_outlet");
                $ln_form   = $val if ($key eq "ln_form");
                $ln_units  = $val if ($key eq "ln_units");
                $ln_digits = $val if ($key eq "ln_digits");
                $ln_interp = $val if ($key eq "ln_interp");
                $ln_tol    = $val if ($key eq "ln_tol");
                $data_type = $val if ($key eq "data_type");
                $gridx     = $val if ($key eq "gridx");
                $gridy     = $val if ($key eq "gridy");
                $gridwidth = $val if ($key eq "gridwidth");
                $gridcolor = $val if ($key eq "gridcolor");
                $scale     = $val if ($key eq "scale");
                $flip      = $val if ($key eq "flip");
                $wl_color  = $val if ($key eq "wl_color");
                $wl_style  = $val if ($key eq "wl_style");
                $wl_grid   = $val if ($key eq "wl_grid");
                $wl_gridc  = $val if ($key eq "wl_gridc");

                $dpr_tics  = $val if ($key eq "dpr_tics");
                $dop_tics  = $val if ($key eq "dop_tics");
                $tpr_tics  = $val if ($key eq "tpr_tics");
                $top_tics  = $val if ($key eq "top_tics");
                $xpr_tics  = $val if ($key eq "xpr_tics");
                $xop_tics  = $val if ($key eq "xop_tics");
                $ypr_tics  = $val if ($key eq "ypr_tics");
                $yop_tics  = $val if ($key eq "yop_tics");
                $spr_tics  = $val if ($key eq "spr_tics");
                $sop_tics  = $val if ($key eq "sop_tics");

                $stype     = $val if ($key eq "stype");
                $sfont     = $val if ($key eq "sfont");
                $st_size   = $val if ($key eq "st_size");
                $st_weight = $val if ($key eq "st_weight");
                $sl_size   = $val if ($key eq "sl_size");
                $sl_weight = $val if ($key eq "sl_weight");
                $smajor    = $val if ($key eq "smajor");
                $stic_loc  = $val if ($key eq "stic_loc");
                $sgrid     = $val if ($key eq "sgrid");
                $sgrid_col = $val if ($key eq "sgrid_col");
                $bgrid     = $val if ($key eq "bgrid");
                $bgrid_col = $val if ($key eq "bgrid_col");
                $stitle    = $val if ($key eq "stitle");

                $hide_title = $val if ($key eq "hidetitle");
                $hide_taxis = $val if ($key eq "hidetaxis");
                $hide_daxis = $val if ($key eq "hidedaxis");
                $map_type   = $val if ($key eq "map_type");

                $ms_stats   = $val if ($key eq "ms_stats");
                $ms_types   = $val if ($key eq "ms_types");
                $ms_digits  = $val if ($key eq "ms_digits");
                $ms_interp  = $val if ($key eq "ms_interp");
                $ms_font    = $val if ($key eq "ms_font");
                $ms_size    = $val if ($key eq "ms_size");
                $ms_weight  = $val if ($key eq "ms_weight");
                $ms_slant   = $val if ($key eq "ms_slant");
                $ms_color   = $val if ($key eq "ms_color");
                $ms_edge    = $val if ($key eq "ms_edge");
                $ms_edgec   = $val if ($key eq "ms_edgec");
                $ms_fill    = $val if ($key eq "ms_fill");
                $ms_fillc   = $val if ($key eq "ms_fillc");
                $ms_pos     = $val if ($key eq "ms_pos");

                $bh_show   = $val if ($key eq "bh_show");
                $bh_docked = $val if ($key eq "bh_docked");
                $bh_xpos   = $val if ($key eq "bh_xpos");
                $bh_ypos   = $val if ($key eq "bh_ypos");
                $bh_font   = $val if ($key eq "bh_font");
                $bh_size   = $val if ($key eq "bh_size");
                $bh_weight = $val if ($key eq "bh_weight");
                $bh_tcolor = $val if ($key eq "bh_tcolor");
                $bh_bwidth = $val if ($key eq "bh_bwidth");
                $bh_bcolor = $val if ($key eq "bh_bcolor");
                $bh_bcellw = $val if ($key eq "bh_bcellw");
                $bh_bcellh = $val if ($key eq "bh_bcellh");

                $parm      = $val if ($key eq "parm");
                $parm_div  = $val if ($key eq "parm_div");
                $parm2     = $val if ($key eq "parm2");
                $parm2_div = $val if ($key eq "parm2_div");
                $parm_units= $val if ($key eq "parmunits");
                $byear     = $val if ($key eq "byear");
                $tz_offset = $val if ($key eq "tz_offset");
                $ctype     = $val if ($key eq "ctype");
                $ctype2    = $val if ($key eq "ctype2");
                $wt_units  = $val if ($key eq "wt_units");
                $qunits    = $val if ($key eq "qunits");
                $seg_list  = $val if ($key eq "seg_list");
                $wb_list   = $val if ($key eq "wb_list");
                $jd_skip   = $val if ($key eq "jd_skip");
                $extra_chk = $val if ($key eq "extra_chk");
                $src_type  = $val if ($key eq "src_type");
                $src_type2 = $val if ($key eq "src_type2");
                $tplot     = $val if ($key eq "tplot");
                $add_parm  = $val if ($key eq "qla_parm");
                $parm_skip = $val if ($key eq "parm_skip");
                $match_tol = $val if ($key eq "match_tol");
                $swap_order= $val if ($key eq "diff_swap");

                $dt_limits = $val if ($key eq "dt_limits");
                $dt_begin  = $val if ($key eq "dt_begin");
                $dt_end    = $val if ($key eq "dt_end");

                $prof_type  = $val if ($key eq "prof_type");
                $dref_type  = $val if ($key eq "dref_type");
                $dref_val   = $val if ($key eq "dref_val");
                $dref_file  = $val if ($key eq "dref_file");
                $dref_ftype = $val if ($key eq "dref_ftyp");
                $dref_lines = $val if ($key eq "dref_line");
                $dref_parm  = $val if ($key eq "dref_parm");
                $dref_ctype = $val if ($key eq "dref_ctyp");
                $dref_tol   = $val if ($key eq "dref_tol");
                $dref_byear = $val if ($key eq "dref_byr");
                $dref_tzoff = $val if ($key eq "dref_tzof");

                $ref_ctype = $val if ($key eq "ref_ctype");
                $ref_tol   = $val if ($key eq "ref_tol");
                $ref_color = $val if ($key eq "ref_color");
                $ref_size  = $val if ($key eq "ref_size");
                $ref_linew = $val if ($key eq "ref_linew");
                $ref_hide  = $val if ($key eq "ref_hide");

                $legtitle  = $val if ($key eq "legtitle");
                $legfont   = $val if ($key eq "legfont");
                $lt_size   = $val if ($key eq "lt_size");
                $lt_weight = $val if ($key eq "lt_weight");
                $le_size   = $val if ($key eq "le_size");
                $le_weight = $val if ($key eq "le_weight");
                $le_edge   = $val if ($key eq "le_edge");
                $le_edgec  = $val if ($key eq "le_edgec");
                $le_fill   = $val if ($key eq "le_fill");
                $le_fillc  = $val if ($key eq "le_fillc");
                $ts_gnum   = $val if ($key eq "ts_gnum");
                $ts_type   = $val if ($key eq "ts_type");
                $ts_units  = $val if ($key eq "ts_units");
                $gap_tol   = $val if ($key eq "gap_tol");
                if ($key eq "ts_show") {
                    $val =~ s/\s+//g;
                    @ts_show = split(/,/, $val);
                    for ($i=0; $i<=$#ts_show; $i++) {
                        $ts_show[$i] = 0 if ($ts_show[$i] != 1);
                    }
                } elsif ($key eq "ts_width") {
                    $val =~ s/\s+//g;
                    @ts_width = split(/,/, $val);
                    for ($i=0; $i<=$#ts_width; $i++) {
                        $ts_width[$i] = &max(1, &min(10, $ts_width[$i]));
                    }
                } elsif ($key eq "ts_color") {
                    $val =~ s/\s+//g;
                    @ts_color = split(/,/, $val);

                } elsif ($key eq "add_data") {
                    $pos = index($val, ",");
                    $set = substr($val, 0, $pos);
                    $val = substr($val, $pos +1);
                    $val =~ s/^\s+//;
                    push (@add_ts_setnum, $set);
                    push (@add_ts_file, File::Spec->rel2abs($val, $project_path));
                } elsif ($key eq "add_ftype") {
                    $pos = index($val, ",");
                    $i   = &list_match(substr($val, 0, $pos), @add_ts_setnum);
                    $val = substr($val, $pos +1);
                    $val =~ s/^\s+//;
                    $add_ts_ftype[$i] = $val if ($i >= 0);
                } elsif ($key eq "add_show") {
                    $pos = index($val, ",");
                    $i   = &list_match(substr($val, 0, $pos), @add_ts_setnum);
                    $val = substr($val, $pos +1);
                    $val =~ s/^\s+//;
                    $add_ts_show[$i] = $val if ($i >= 0);
                } elsif ($key eq "add_width") {
                    $pos = index($val, ",");
                    $i   = &list_match(substr($val, 0, $pos), @add_ts_setnum);
                    $val = substr($val, $pos +1);
                    $val =~ s/^\s+//;
                    $add_ts_width[$i] = $val if ($i >= 0);
                } elsif ($key eq "add_color") {
                    $pos = index($val, ",");
                    $i   = &list_match(substr($val, 0, $pos), @add_ts_setnum);
                    $val = substr($val, $pos +1);
                    $val =~ s/^\s+//;
                    $add_ts_color[$i] = $val if ($i >= 0);
                } elsif ($key eq "add_text") {
                    $pos = index($val, ",");
                    $i   = &list_match(substr($val, 0, $pos), @add_ts_setnum);
                    $val = substr($val, $pos +1);
                    $val =~ s/^\s+//;
                    $add_ts_text[$i] = $val if ($i >= 0);
                } elsif ($key eq "add_parm") {
                    $pos = index($val, ",");
                    $i   = &list_match(substr($val, 0, $pos), @add_ts_setnum);
                    $val = substr($val, $pos +1);
                    $val =~ s/^\s+//;
                    $add_ts_param[$i] = $val if ($i >= 0);
                } elsif ($key eq "add_byear") {
                    $pos = index($val, ",");
                    $i   = &list_match(substr($val, 0, $pos), @add_ts_setnum);
                    $val = substr($val, $pos +1);
                    $val =~ s/^\s+//;
                    $val = "n/a" if ($val eq "");
                    $add_ts_byear[$i] = $val if ($i >= 0);
                } elsif ($key eq "add_tzoff") {
                    $pos = index($val, ",");
                    $i   = &list_match(substr($val, 0, $pos), @add_ts_setnum);
                    $val = substr($val, $pos +1);
                    $val =~ s/^\s+//;
                    $val = "n/a" if ($val eq "");
                    $add_ts_tzoff[$i] = $val if ($i >= 0);
                } elsif ($key eq "add_seg") {
                    $pos = index($val, ",");
                    $i   = &list_match(substr($val, 0, $pos), @add_ts_setnum);
                    $val = substr($val, $pos +1);
                    $val =~ s/^\s+//;
                    $val = "n/a" if ($val eq "");
                    $add_ts_seg[$i] = $val if ($i >= 0);
                } elsif ($key eq "add_ctype") {
                    $pos = index($val, ",");
                    $i   = &list_match(substr($val, 0, $pos), @add_ts_setnum);
                    $val = substr($val, $pos +1);
                    $val =~ s/^\s+//;
                    $add_ts_ctype[$i] = $val if ($i >= 0);
                }
            }
            if ($type =~ /^(line|polyline)$/) {
                if ($got_x && $got_y && $got_xc && $got_yc && $got_anchor && $got_coordlist) {
                    $id = $canvas->create_line(@coords,
                             -fill       => &get_rgb_code($color),
                             -width      => $width,
                             -arrow      => $arrow_type[$arrow],
                             -arrowshape => [ $ahd1, $ahd2, $ahd3 ],
                             -tags       => $tags);
                    $props{$id}{type}      = $type;
                    $props{$id}{x}         = $x;
                    $props{$id}{y}         = $y;
                    $props{$id}{xc}        = $xc;
                    $props{$id}{yc}        = $yc;
                    $props{$id}{anchor}    = $anchor;
                    $props{$id}{coordlist} = [ @coords ];
                    $props{$id}{color}     = $color;
                    $props{$id}{width}     = $width;
                    $props{$id}{arrow}     = $arrow;
                    $props{$id}{ahd1}      = $ahd1;
                    $props{$id}{ahd2}      = $ahd2;
                    $props{$id}{ahd3}      = $ahd3;
                    if ($type eq "polyline") {
                        ($xc, $yc, $r) = &smallest_circle(@coords);
                        $props{$id}{xc_rot}    = $xc;
                        $props{$id}{yc_rot}    = $yc;
                        $props{$id}{angle}     = $angle;
                        $props{$id}{angle_tmp} = $angle;
                    }
                }
            } elsif ($type eq "circle") {
                if ($got_x && $got_y && $got_xc && $got_yc && $got_anchor && $got_coordlist) {
                    $id = $canvas->create_oval(@coords,
                             -outline => &get_rgb_code($color),
                             -width   => $width,
                             -tags    => $tags);
                    if ($fill && $fillcolor ne "") {
                        $canvas->itemconfigure($id, -fill => &get_rgb_code($fillcolor));
                    } else {
                        $canvas->itemconfigure($id, -fill => "");
                    }
                    if ($width == 0) {
                        $canvas->itemconfigure($id, -outline => "");
                    }
                    $props{$id}{type}      = $type;
                    $props{$id}{x}         = $x;
                    $props{$id}{y}         = $y;
                    $props{$id}{xc}        = $xc;
                    $props{$id}{yc}        = $yc;
                    $props{$id}{anchor}    = $anchor;
                    $props{$id}{coordlist} = [ @coords ];
                    $props{$id}{color}     = $color;
                    $props{$id}{width}     = $width;
                    $props{$id}{fill}      = $fill;
                    $props{$id}{fillcolor} = $fillcolor;
                }
            } elsif ($type eq "ellipse") {
                if ($got_x && $got_y && $got_xc && $got_yc && $got_hw && $got_hh && $got_anchor) {
                    @coords = &make_shape_coords($type, $xc, $yc, $hw, $hh, $angle);
                    $id = $canvas->create_polygon(@coords,
                             -outline => &get_rgb_code($color),
                             -width   => $width,
                             -smooth  => 'false',
                             -tags    => $tags);
                    if ($fill && $fillcolor ne "") {
                        $canvas->itemconfigure($id, -fill => &get_rgb_code($fillcolor));
                    } else {
                        $canvas->itemconfigure($id, -fill => "");
                    }
                    if ($width == 0) {
                        $canvas->itemconfigure($id, -outline => "");
                    }
                    $props{$id}{type}      = $type;
                    $props{$id}{x}         = $x;
                    $props{$id}{y}         = $y;
                    $props{$id}{xc}        = $xc;
                    $props{$id}{yc}        = $yc;
                    $props{$id}{hw}        = $hw;
                    $props{$id}{hh}        = $hh;
                    $props{$id}{anchor}    = $anchor;
                    $props{$id}{coordlist} = [ @coords ];
                    $props{$id}{color}     = $color;
                    $props{$id}{width}     = $width;
                    $props{$id}{fill}      = $fill;
                    $props{$id}{fillcolor} = $fillcolor;
                    $props{$id}{angle}     = $angle;
                    $props{$id}{angle_tmp} = $angle;
                    $props{$id}{smooth}    = 0;
                }
            } elsif ($type =~ /^(rectangle|diamond)$/) {
                if ($got_x && $got_y && $got_xc && $got_yc && $got_coordlist && $got_anchor) {
                    $id = $canvas->create_polygon(@coords,
                             -outline => &get_rgb_code($color),
                             -width   => $width,
                             -smooth  => $smooth_type[$smooth],
                             -tags    => $tags);
                    if ($fill && $fillcolor ne "") {
                        $canvas->itemconfigure($id, -fill => &get_rgb_code($fillcolor));
                    } else {
                        $canvas->itemconfigure($id, -fill => "");
                    }
                    if ($width == 0) {
                        $canvas->itemconfigure($id, -outline => "");
                    }
                    $props{$id}{type}      = $type;
                    $props{$id}{x}         = $x;
                    $props{$id}{y}         = $y;
                    $props{$id}{xc}        = $xc;
                    $props{$id}{yc}        = $yc;
                    $props{$id}{anchor}    = $anchor;
                    $props{$id}{coordlist} = [ @coords ];
                    $props{$id}{color}     = $color;
                    $props{$id}{width}     = $width;
                    $props{$id}{fill}      = $fill;
                    $props{$id}{fillcolor} = $fillcolor;
                    $props{$id}{angle}     = $angle;
                    $props{$id}{angle_tmp} = $angle;
                    $props{$id}{smooth}    = $smooth;
                }
            } elsif ($type eq "polygon") {
                if ($got_x && $got_y && $got_xc && $got_yc && $got_coordlist && $got_anchor) {
                    $id = $canvas->create_polygon(@coords,
                             -outline => &get_rgb_code($color),
                             -width   => $width,
                             -tags    => $tags);
                    if ($fill && $fillcolor ne "") {
                        $canvas->itemconfigure($id, -fill => &get_rgb_code($fillcolor));
                    } else {
                        $canvas->itemconfigure($id, -fill => "");
                    }
                    if ($width == 0) {
                        $canvas->itemconfigure($id, -outline => "");
                    }
                    $props{$id}{type}      = $type;
                    $props{$id}{x}         = $x;
                    $props{$id}{y}         = $y;
                    $props{$id}{xc}        = $xc;
                    $props{$id}{yc}        = $yc;
                    $props{$id}{anchor}    = $anchor;
                    $props{$id}{coordlist} = [ @coords ];
                    $props{$id}{color}     = $color;
                    $props{$id}{width}     = $width;
                    $props{$id}{fill}      = $fill;
                    $props{$id}{fillcolor} = $fillcolor;
                    $props{$id}{angle}     = $angle;
                    $props{$id}{angle_tmp} = $angle;

                    ($xc, $yc, $r) = &smallest_circle(@coords);
                    $props{$id}{xc_rot}    = $xc;
                    $props{$id}{yc_rot}    = $yc;
                }
            } elsif ($type eq "text") {
                if ($got_x && $got_y && $got_anchor && $got_text) {
                    $id = $canvas->create_text($x, $y,
                             -anchor => $anchor,
                             -text   => $text,
                             -fill   => &get_rgb_code($color),
                             -angle  => $angle,
                             -tags   => $tags,
                             -font   => [-family     => $family,
                                         -size       => $size,
                                         -weight     => $weight,
                                         -slant      => $slant_type[$slant],
                                         -underline  => $underline,
                                         -overstrike => 0,
                                        ]);
                    $props{$id}{type}      = $type;
                    $props{$id}{text}      = $text;
                    $props{$id}{x}         = $x;
                    $props{$id}{y}         = $y;
                    $props{$id}{anchor}    = $anchor;
                    $props{$id}{coordlist} = [$x, $y];
                    $props{$id}{color}     = $color;
                    $props{$id}{family}    = $family;
                    $props{$id}{size}      = $size;
                    $props{$id}{weight}    = $weight;
                    $props{$id}{slant}     = $slant;
                    $props{$id}{underline} = $underline;
                    $props{$id}{angle}     = $angle;
                    &find_rect_from_text_or_image($canvas, $id);

                    if ($src_file ne "" && $src_type ne "" && $src_lines != 0) {
                        push (@ind_link_ids, $id);
                        $props{$id}{src_file}  = $src_file;
                        $props{$id}{src_type}  = $src_type;
                        $props{$id}{src_lines} = $src_lines;
                        $props{$id}{ctype}     = $ctype;
                        $props{$id}{parm}      = $parm;
                        if ($src_type =~ /^W2 /) {
                            $props{$id}{byear}     = $byear;
                            $props{$id}{tz_offset} = $tz_offset;
                            $props{$id}{seg}       = $seg;
                        }
                        $props{$id}{data_type} = $data_type;
                        $props{$id}{units}     = $ln_units;
                        $props{$id}{digits}    = $ln_digits;
                        $props{$id}{link_tol}  = $ln_tol;
                    }
                }
            } elsif ($type eq "image") {
                if ($got_x && $got_y && $got_anchor && $got_file) {
                    if (! -e $datafile || -s $datafile == 0) {
                        return &pop_up_error2($main, "Image file empty or does not exist\n  $datafile");
                    }
                    $img = Imager->new;
                    $img->read(file => $datafile) or
                            return &pop_up_error2($main, "Failed to load $datafile\n $img->errstr");
                    $img = $img->convert(preset => 'addalpha');
                    $iwo = $img->getwidth();
                    $iho = $img->getheight();
                    if ($crop[0] > 0. || $crop[1] > 0. || $crop[2] > 0. || $crop[3] > 0.) {
                        $img = $img->crop(left   => &round_to_int($iwo *$crop[0]),
                                          right  => &round_to_int($iwo *(1.0 -$crop[1])),
                                          top    => &round_to_int($iho *$crop[2]),
                                          bottom => &round_to_int($iho *(1.0 -$crop[3])));
                    }
                    $iwc = $img->getwidth();
                    $ihc = $img->getheight();
                    if (defined($scale) && $scale != 1.0) {
                        $img = $img->scale(xpixels => &round_to_int($iwc *$scale));
                    }
                    if ($flip ne "none") {
                        $img->flip(dir => $flip);
                    }
                    $img->write(data => \$img_data, type => 'png');
                    $image = Tkx::image_create_photo(-data => $img_data);
                    $id = $canvas->create_image($x, $y,
                                                -anchor => 'center',
                                                -image  => $image,
                                                -tags   => $tags,
                                                -state  => 'hidden');
                    $props{$id}{type}   = $type;
                    $props{$id}{x}      = $x;
                    $props{$id}{y}      = $y;
                    $props{$id}{anchor} = $anchor;
                    $props{$id}{iw}     = Tkx::image_width($image);
                    $props{$id}{ih}     = Tkx::image_height($image);
                    $props{$id}{iwo}    = $iwo;
                    $props{$id}{iho}    = $iho;
                    $props{$id}{iwc}    = $iwc;
                    $props{$id}{ihc}    = $ihc;
                    $props{$id}{crop}   = [ @crop ];
                    $props{$id}{file}   = $datafile;
                    $props{$id}{image}  = $image;
                    $props{$id}{idata}  = $img_data;
                    $props{$id}{angle}  = $angle;
                    $props{$id}{flip}   = $flip;

                    &find_rect_from_text_or_image($canvas, $id);  # set xc, yc
                    $props{$id}{coordlist} = [$props{$id}{xc}, $props{$id}{yc}];

                    if ($angle != 0) {
                        $img = $img->rotate(degrees => -1 *$angle);
                        $img->write(data => \$img_data, type => 'png');
                        $image = Tkx::image_create_photo(-data => $img_data);
                        $canvas->itemconfigure($id, -image => $image);
                    }
                    $canvas->coords($id, $props{$id}{xc}, $props{$id}{yc});
                    $canvas->itemconfigure($id, -state => 'normal');
                }
            } elsif ($type eq "graph") {
                if ($meta =~ /w2_profile|w2_slice|w2_wlevels|w2_tdmap/ && ! $got_bth_file) {
                    return &pop_up_error2($main, "Graph type $meta requires a bathymetry file.\n"
                                               . "Please edit the project file or recreate it.");
                }
                if ($got_x && $got_y && $got_anchor && $got_coordlist && $got_meta
                    && ($meta =~ /time_series/
                       || ($meta =~ /data_profile/ && $got_src_file)
                       || ($meta eq "vert_wd_zone" && $got_wt_file && $got_flow_file && $got_bth_file
                           && ($wd_alg ne "Libby Dam" || $got_lbc_file))
                       || ($meta =~ /w2_profile/ && $got_con_file && $got_src_file && $got_bth_file
                                                 && ($src_type =~ /Vector/i 
                                                      || ($src_type =~ /Spreadsheet|Contour|LakeCon/i
                                                            && $got_src_lines)))
                       || ($meta =~ /w2_outflow/ && $got_con_file && $got_bth_file
                                                 && $got_qla_file && $got_qla_lines)
                       || ($meta =~ /w2_slice/ && $got_con_file && $got_bth_file && ($got_w2l_file
                                                  || ($got_cpl_info && $got_cpl_file)))
                       || ($meta =~ /w2_wlevels/ && $got_con_file && $got_bth_file && ($got_w2l_file
                                                  || ($got_wl_file  && $got_wl_lines)
                                                  || ($got_cpl_info && $got_cpl_file)))
                       || ($meta =~ /w2_tdmap/ && $got_con_file && $got_bth_file
                                               && ($got_w2l_file
                                                  || ($got_cpl_info && $got_cpl_file)
                                                  || ($got_riv_info && $got_riv_file)
                                                  || $got_src_file)))) {

                    $status_line = "Reading input files.  Please wait...";
                    $canvas->configure(-cursor => $cursor_wait);
                    Tkx::update();

                    if ($meta =~ /data_profile/ && (! -e $src_file || -s $src_file == 0)) {
                        return &pop_up_error2($main,
                                          "Data file empty or does not exist\n  $src_file");
                    }
                    if ($meta eq "vert_wd_zone") {
                        if (! -e $wt_file || -s $wt_file == 0) {
                            return &pop_up_error2($main,
                                          "Temperature file empty or does not exist\n  $wt_file");
                        }
                        if (! -e $flow_file || -s $flow_file == 0) {
                            return &pop_up_error2($main,
                                          "Outlet flow file empty or does not exist\n  $flow_file");
                        }
                        if (! -e $bth_file || -s $bth_file == 0) {
                            return &pop_up_error2($main,
                                          "Bathymetry file empty or does not exist\n  $bth_file");
                        }
                        if ($wd_alg eq "Libby Dam") {
                            if (! -e $lbc_file || -s $lbc_file == 0) {
                                return &pop_up_error2($main,
                                "Libby bulkhead configuration file empty or does not exist\n  $lbc_file");
                            }
                        }
                    } elsif ($meta =~ /w2_profile/) {
                        if (! -e $con_file || -s $con_file == 0) {
                            return &pop_up_error2($main,
                                          "W2 control file empty or does not exist\n  $con_file");
                        }
                        if (! -e $bth_file || -s $bth_file == 0) {
                            return &pop_up_error2($main,
                                          "Bathymetry file empty or does not exist\n  $bth_file");
                        }
                        if (! -e $src_file || -s $src_file == 0) {
                            if ($src_type =~ /Spreadsheet/i) {
                                return &pop_up_error2($main,
                                          "W2 spreadsheet file empty or does not exist\n  $src_file");
                            } elsif ($src_type =~ /Contour/i) {
                                return &pop_up_error2($main,
                                          "W2 contour file empty or does not exist\n  $src_file");
                            } elsif ($src_type =~ /LakeCon/i) {
                                return &pop_up_error2($main,
                                          "W2 Lake Contour file empty or does not exist\n  $src_file");
                            } else {
                                return &pop_up_error2($main,
                                          "W2 vector file empty or does not exist\n  $src_file");
                            }
                        }
                        if ($got_ref) {
                            if (! -e $ref_file || -s $ref_file == 0) {
                                return &pop_up_error2($main,
                                          "Reference profile file empty or does not exist\n  $ref_file");
                            }
                        }
                    } elsif ($meta =~ /w2_outflow/) {
                        if (! -e $con_file || -s $con_file == 0) {
                            return &pop_up_error2($main,
                                          "W2 control file empty or does not exist\n  $con_file");
                        }
                        if (! -e $bth_file || -s $bth_file == 0) {
                            return &pop_up_error2($main,
                                          "Bathymetry file empty or does not exist\n  $bth_file");
                        }
                        if (! -e $qla_file || -s $qla_file == 0) {
                            return &pop_up_error2($main,
                                          "Layer outflow file empty or does not exist\n  $qla_file");
                        }
                        if ($add_parm) {
                            if (! -e $src_file || -s $src_file == 0) {
                                if ($src_type =~ /Spreadsheet/i) {
                                    return &pop_up_error2($main,
                                              "W2 spreadsheet file empty or does not exist\n  $src_file");
                                } elsif ($src_type =~ /Contour/i) {
                                    return &pop_up_error2($main,
                                              "W2 contour file empty or does not exist\n  $src_file");
                                } elsif ($src_type =~ /Vector/i) {
                                    return &pop_up_error2($main,
                                              "W2 vector file empty or does not exist\n  $src_file");
                                } elsif ($src_type =~ /LakeCon/i) {
                                    return &pop_up_error2($main,
                                              "W2 Lake Contour file empty or does not exist\n  $src_file");
                                }
                            }
                        }
                    } elsif ($meta =~ /w2_slice|w2_wlevels/) {
                        if (! -e $con_file || -s $con_file == 0) {
                            return &pop_up_error2($main,
                                          "W2 control file empty or does not exist\n  $con_file");
                        }
                        if ($meta eq "w2_slice") {
                            if ($src_type eq "" || $src_type !~ /^(W2 Contour File|W2 Vector File)$/) {
                                if ($got_cpl_info && $got_cpl_file) {
                                    $src_type = "W2 Contour File";
                                } elsif ($got_w2l_file) {
                                    $src_type = "W2 Vector File";
                                }
                            }
                        } elsif ($meta eq "w2_wlevels") {
                            if ($src_type eq ""
                                 || $src_type !~ /^(W2 Contour File|W2 Vector File|W2 Water Level File)$/) {
                                if ($got_cpl_info && $got_cpl_file) {
                                    $src_type = "W2 Contour File";
                                } elsif ($got_w2l_file) {
                                    $src_type = "W2 Vector File";
                                } elsif ($got_wl_file && $got_wl_lines) {
                                    $src_type = "W2 Water Level File";
                                }
                            }
                        }
                        $txt = ($meta eq "w2_slice") ? "slice" : "water level";
                        if ($src_type =~ /Contour/i) {
                            if (! $got_bth_file || ! $got_cpl_info || ! $got_cpl_file) {
                                return &pop_up_error2($main,
                                       "W2 $txt object has insufficient data on W2 contour files");
                            }
                            @wbs = split(/,/, $wb_list);
                            for ($j=0; $j<=$#wbs; $j++) {
                                if (! -e $cpl_files[$j] || -s $cpl_files[$j] == 0) {
                                    return &pop_up_error2($main,
                                           "W2 contour file empty or does not exist\n  $cpl_files[$j]");
                                }
                                if (! -e $bth_files[$j] || -s $bth_files[$j] == 0) {
                                    return &pop_up_error2($main,
                                           "W2 bathymetry file empty or does not exist\n  $bth_files[$j]");
                                }
                            }
                        } elsif ($src_type =~ /Vector/i) {
                            if (! $got_w2l_file) {
                                return &pop_up_error2($main,
                                       "W2 $txt object failed to specify the W2 vector file name");
                            }
                            if (! -e $w2l_file || -s $w2l_file == 0) {
                                return &pop_up_error2($main,
                                       "W2 vector file empty or does not exist\n  $w2l_file");
                            }
                            @wbs = split(/,/, $wb_list);
                            for ($j=0; $j<=$#wbs; $j++) {
                                if (! -e $bth_files[$j] || -s $bth_files[$j] == 0) {
                                    return &pop_up_error2($main,
                                           "W2 bathymetry file empty or does not exist\n  $bth_files[$j]");
                                }
                            }
                        } elsif ($src_type =~ /Water Level/i) {
                            if (! $got_wl_file || ! $got_wl_lines) {
                                return &pop_up_error2($main,
                                       "W2 $txt object has insufficient data on the W2 water level file");
                            }
                            if (! -e $wl_file || -s $wl_file == 0) {
                                return &pop_up_error2($main,
                                       "W2 water level file empty or does not exist\n  $wl_file");
                            }
                            @wbs = split(/,/, $wb_list);
                            for ($j=0; $j<=$#wbs; $j++) {
                                if (! -e $bth_files[$j] || -s $bth_files[$j] == 0) {
                                    return &pop_up_error2($main,
                                           "W2 bathymetry file empty or does not exist\n  $bth_files[$j]");
                                }
                            }
                        }
                    } elsif ($meta =~ /w2_tdmap/) {
                        if (! -e $con_file || -s $con_file == 0) {
                            return &pop_up_error2($main,
                                          "W2 control file empty or does not exist\n  $con_file");
                        }
                        if ($src_type eq ""
                               || $src_type !~ /^(W2 Contour File|W2 Vector File|W2 RiverCon File)$/
                               || $src_type !~ /^(W2 SurfTemp File|W2 VolTemp File|W2 FlowTemp File)$/) {
                            if ($got_cpl_info && $got_cpl_file) {
                                $src_type = "W2 Contour File";
                            } elsif ($got_w2l_file) {
                                $src_type = "W2 Vector File";
                            } elsif ($got_riv_info && $got_riv_file) {
                                $src_type  = "W2 RiverCon File";
                                $prof_stat = "Surface value";
                            } elsif ($got_src_file) {
                                ($src_type, undef, undef) = &determine_ts_type($main, $src_file, 1);
                                if ($src_type =~ /SurfTemp/i) {
                                    $src_type  = "W2 SurfTemp File";
                                    $prof_stat = "Surface value";
                                } elsif ($src_type =~ /VolTemp/i) {
                                    $src_type  = "W2 VolTemp File";
                                    $prof_stat = "Volume-weighted";
                                } elsif ($src_type =~ /FlowTemp/i) {
                                    $src_type  = "W2 FlowTemp File";
                                    $prof_stat = "Flow-weighted";
                                }
                            }
                        }
                        if ($src_type =~ /Contour/i) {
                            if (! $got_bth_file || ! $got_cpl_info || ! $got_cpl_file) {
                                return &pop_up_error2($main,
                                       "W2 time/distance object has insufficient data on W2 contour files");
                            }
                            @wbs = split(/,/, $wb_list);
                            for ($j=0; $j<=$#wbs; $j++) {
                                if (! -e $cpl_files[$j] || -s $cpl_files[$j] == 0) {
                                    return &pop_up_error2($main,
                                           "W2 contour file empty or does not exist\n  $cpl_files[$j]");
                                }
                                if (! -e $bth_files[$j] || -s $bth_files[$j] == 0) {
                                    return &pop_up_error2($main,
                                           "W2 bathymetry file empty or does not exist\n  $bth_files[$j]");
                                }
                            }
                            if ($prof_stat eq "Flow-weighted") {
                                return &pop_up_error2($main,
                                       "Profile stat ($prof_stat) for Time/Distance Diff Map\n"
                                     . "inconsistent with use of W2 contour output file");
                            }
                        } elsif ($src_type =~ /Vector/i) {
                            if (! $got_w2l_file) {
                                return &pop_up_error2($main,
                                       "W2 time/distance object failed to specify the W2 vector file name");
                            }
                            if (! -e $w2l_file || -s $w2l_file == 0) {
                                return &pop_up_error2($main,
                                       "W2 vector file empty or does not exist\n  $w2l_file");
                            }
                            @wbs = split(/,/, $wb_list);
                            for ($j=0; $j<=$#wbs; $j++) {
                                if (! -e $bth_files[$j] || -s $bth_files[$j] == 0) {
                                    return &pop_up_error2($main,
                                           "W2 bathymetry file empty or does not exist\n  $bth_files[$j]");
                                }
                            }
                            if ($prof_stat eq "Flow-weighted") {
                                return &pop_up_error2($main,
                                       "Profile stat ($prof_stat) for Time/Distance Diff Map\n"
                                     . "inconsistent with use of W2 vector output file");
                            }
                        } elsif ($src_type =~ /RiverCon/i) {
                            if (! $got_bth_file || ! $got_riv_info || ! $got_riv_file) {
                                return &pop_up_error2($main,
                                       "W2 time/distance object has insufficient data on W2 RiverCon files");
                            }
                            for ($j=0; $j<=$#riv_files; $j++) {
                                if (! -e $riv_files[$j] || -s $riv_files[$j] == 0) {
                                    return &pop_up_error2($main,
                                           "W2 RiverCon file empty or does not exist\n  $riv_files[$j]");
                                }
                            }
                            @wbs = split(/,/, $wb_list);
                            for ($j=0; $j<=$#wbs; $j++) {
                                if (! -e $bth_files[$j] || -s $bth_files[$j] == 0) {
                                    return &pop_up_error2($main,
                                           "W2 bathymetry file empty or does not exist\n  $bth_files[$j]");
                                }
                            }
                            if ($prof_stat eq "Flow-weighted" || $prof_stat eq "Volume-weighted") {
                                return &pop_up_error2($main,
                                       "Profile stat ($prof_stat) for Time/Distance Diff Map\n"
                                     . "inconsistent with use of W2 RiverCon output file");
                            }
                        } elsif ($src_type =~ /SurfTemp|VolTemp|FlowTemp/i) {
                            if (! $got_src_file) {
                                return &pop_up_error2($main, "W2 time/distance object failed to specify the "
                                                            . $src_type . " name");
                            }
                            if (! -e $src_file || -s $src_file == 0) {
                                return &pop_up_error2($main,
                                                      $src_type . " empty or does not exist\n  $src_file");
                            }
                            @wbs = split(/,/, $wb_list);
                            for ($j=0; $j<=$#wbs; $j++) {
                                if (! -e $bth_files[$j] || -s $bth_files[$j] == 0) {
                                    return &pop_up_error2($main,
                                           "W2 bathymetry file empty or does not exist\n  $bth_files[$j]");
                                }
                            }
                            if ($src_type =~ /SurfTemp/i) {
                                if ($prof_stat ne "Surface value") {
                                    return &pop_up_error2($main,
                                           "Profile stat ($prof_stat) for Time/Distance Diff Map\n"
                                         . "inconsistent with use of W2 SurfTemp output file");
                                }
                            } elsif ($src_type =~ /VolTemp/i) {
                                if ($prof_stat ne "Volume-weighted") {
                                    return &pop_up_error2($main,
                                           "Profile stat ($prof_stat) for Time/Distance Diff Map\n"
                                         . "inconsistent with use of W2 VolTemp output file");
                                }
                            } elsif ($src_type =~ /FlowTemp/i) {
                                if ($prof_stat ne "Flow-weighted") {
                                    return &pop_up_error2($main,
                                           "Profile stat ($prof_stat) for Time/Distance Diff Map\n"
                                         . "inconsistent with use of W2 FlowTemp output file");
                                }
                            }
                        }
                        if ($map_type eq "filediff") {
                            if ($src_type2 eq ""
                                   || $src_type2 !~ /^(W2 Contour File|W2 Vector File|W2 RiverCon File)$/
                                   || $src_type2 !~ /^(W2 SurfTemp File|W2 VolTemp File|W2 FlowTemp File)$/) {
                                if ($got_cpl_info2 && $got_cpl_file2) {
                                    $src_type2 = "W2 Contour File";
                                    if ($prof_stat eq "Flow-weighted") {
                                        return &pop_up_error2($main,
                                               "Profile stat ($prof_stat) for Time/Distance Diff Map\n"
                                             . "inconsistent with use of W2 contour output file");
                                    }
                                } elsif ($got_w2l_file2) {
                                    $src_type2 = "W2 Vector File";
                                    if ($prof_stat eq "Flow-weighted") {
                                        return &pop_up_error2($main,
                                               "Profile stat ($prof_stat) for Time/Distance Diff Map\n"
                                             . "inconsistent with use of W2 vector output file");
                                    }
                                } elsif ($got_riv_info2 && $got_riv_file2) {
                                    $src_type2 = "W2 RiverCon File";
                                    if ($prof_stat eq "Flow-weighted" || $prof_stat eq "Volume-weighted") {
                                        return &pop_up_error2($main,
                                               "Profile stat ($prof_stat) for Time/Distance Diff Map\n"
                                             . "inconsistent with use of W2 RiverCon output file");
                                    }
                                } elsif ($got_src_file2) {
                                    ($src_type2, undef, undef) = &determine_ts_type($main, $src_file2, 1);
                                    if ($src_type2 =~ /SurfTemp/i) {
                                        $src_type2 = "W2 SurfTemp File";
                                        if ($prof_stat ne "Surface value") {
                                            return &pop_up_error2($main,
                                                   "Profile stat ($prof_stat) for Time/Distance Diff Map\n"
                                                 . "inconsistent with use of W2 SurfTemp output file");
                                        }
                                    } elsif ($src_type2 =~ /VolTemp/i) {
                                        $src_type2 = "W2 VolTemp File";
                                        if ($prof_stat ne "Volume-weighted") {
                                            return &pop_up_error2($main,
                                                   "Profile stat ($prof_stat) for Time/Distance Diff Map\n"
                                                 . "inconsistent with use of W2 VolTemp output file");
                                        }
                                    } elsif ($src_type =~ /FlowTemp/i) {
                                        $src_type2 = "W2 FlowTemp File";
                                        if ($prof_stat ne "Flow-weighted") {
                                            return &pop_up_error2($main,
                                                   "Profile stat ($prof_stat) for Time/Distance Diff Map\n"
                                                 . "inconsistent with use of W2 FlowTemp output file");
                                        }
                                    }
                                }
                            }
                            if ($src_type2 =~ /Contour/i) {
                                if (! $got_cpl_info2 || ! $got_cpl_file2) {
                                    return &pop_up_error2($main,
                                         "W2 time/distance object has insufficient data on W2 contour files");
                                }
                                @wbs = split(/,/, $wb_list);
                                for ($j=0; $j<=$#wbs; $j++) {
                                    if (! -e $cpl_files2[$j] || -s $cpl_files2[$j] == 0) {
                                        return &pop_up_error2($main,
                                               "W2 contour file empty or does not exist\n  $cpl_files2[$j]");
                                    }
                                }
                                if ($prof_stat eq "Flow-weighted") {
                                    return &pop_up_error2($main,
                                           "Profile stat ($prof_stat) for Time/Distance Diff Map\n"
                                         . "inconsistent with use of W2 contour output file");
                                }
                            } elsif ($src_type2 =~ /Vector/i) {
                                if (! $got_w2l_file2) {
                                    return &pop_up_error2($main,
                                         "W2 time/distance object failed to specify the W2 vector file name");
                                }
                                if (! -e $w2l_file2 || -s $w2l_file2 == 0) {
                                    return &pop_up_error2($main,
                                           "W2 vector file empty or does not exist\n  $w2l_file2");
                                }
                                if ($prof_stat eq "Flow-weighted") {
                                    return &pop_up_error2($main,
                                           "Profile stat ($prof_stat) for Time/Distance Diff Map\n"
                                         . "inconsistent with use of W2 contour output file");
                                }
                            } elsif ($src_type2 =~ /RiverCon/i) {
                                if (! $got_riv_info2 || ! $got_riv_file2) {
                                    return &pop_up_error2($main,
                                        "W2 time/distance object has insufficient data on W2 RiverCon files");
                                }
                                for ($j=0; $j<=$#riv_files2; $j++) {
                                    if (! -e $riv_files2[$j] || -s $riv_files2[$j] == 0) {
                                        return &pop_up_error2($main,
                                               "W2 RiverCon file empty or does not exist\n  $riv_files2[$j]");
                                    }
                                }
                                if ($prof_stat eq "Flow-weighted" || $prof_stat eq "Volume-weighted") {
                                    return &pop_up_error2($main,
                                           "Profile stat ($prof_stat) for Time/Distance Diff Map\n"
                                         . "inconsistent with use of W2 RiverCon output file");
                                }
                            } elsif ($src_type2 =~ /SurfTemp|VolTemp|FlowTemp/i) {
                                if (! $got_src_file2) {
                                    return &pop_up_error2($main,
                                                          "W2 time/distance object failed to specify the "
                                                        . $src_type2 . " name");
                                }
                                if (! -e $src_file2 || -s $src_file2 == 0) {
                                    return &pop_up_error2($main, $src_type2
                                                               . " empty or does not exist\n  $src_file2");
                                }
                                if ($src_type2 =~ /SurfTemp/i) {
                                    if ($prof_stat ne "Surface value") {
                                        return &pop_up_error2($main,
                                               "Profile stat ($prof_stat) for Time/Distance Diff Map\n"
                                             . "inconsistent with use of W2 SurfTemp output file");
                                    }
                                } elsif ($src_type2 =~ /VolTemp/i) {
                                    if ($prof_stat ne "Volume-weighted") {
                                        return &pop_up_error2($main,
                                               "Profile stat ($prof_stat) for Time/Distance Diff Map\n"
                                             . "inconsistent with use of W2 VolTemp output file");
                                    }
                                } elsif ($src_type2 =~ /FlowTemp/i) {
                                    if ($prof_stat ne "Flow-weighted") {
                                        return &pop_up_error2($main,
                                               "Profile stat ($prof_stat) for Time/Distance Diff Map\n"
                                             . "inconsistent with use of W2 FlowTemp output file");
                                    }
                                }
                            }
                        }
                    }
                    $id = $canvas->create_rectangle(@coords,
                             -outline => &get_rgb_code($color),
                             -width   => $width,
                             -fill    => "",
                             -tags    => $tags);
                    $props{$id}{type}      = $type;
                    $props{$id}{meta}      = $meta;
                    $props{$id}{gnum}      = $gnum;
                    $props{$id}{x}         = $x;
                    $props{$id}{y}         = $y;
                    $props{$id}{xc}        = $xc;
                    $props{$id}{yc}        = $yc;
                    $props{$id}{anchor}    = $anchor;
                    $props{$id}{coordlist} = [ @coords ];
                    $props{$id}{oldcoords} = [ @coords ];
                    $props{$id}{color}     = $color;
                    $props{$id}{width}     = $width;
                    $props{$id}{fill}      = $fill;
                    $canvas->addtag("graph" . $id, withtag => $id);

                    if ($meta =~ /time_series/) {
                        %profile = ();

                    } elsif ($meta =~ /w2_profile/) {
                        %profile = ();
                        $props{$id}{files}      = 1;
                        $props{$id}{con_file}   = $con_file;
                        $props{$id}{bth_file}   = $bth_file;
                        $props{$id}{src_type}   = $src_type;
                        $props{$id}{src_file}   = $src_file;
                        $props{$id}{src_lines}  = $src_lines;
                        $props{$id}{tplot}      = $tplot;
                        $props{$id}{parm}       = $parm;
                        $props{$id}{parm_div}   = $parm_div;
                        $props{$id}{parm_units} = $parm_units;
                        $props{$id}{ctype}      = $ctype;
                        $props{$id}{seg}        = $seg;
                        $props{$id}{byear}      = $byear;
                        $props{$id}{tz_offset}  = $tz_offset;
                        $props{$id}{jd_skip}    = $jd_skip;

                        $confirm_type = &confirm_w2_ftype($main, $src_file);
                        if ($src_type =~ /Spreadsheet/i && $confirm_type ne "spr") {
                            return &pop_up_error2($main,
                                    "The W2 source file is not a W2 Spreadsheet file:\n$src_file");
                        } elsif ($src_type =~ /Contour/i && $confirm_type ne "cpl") {
                            return &pop_up_error2($main,
                                    "The W2 source file is not a W2 Contour file:\n$src_file");
                        } elsif ($src_type =~ /Vector/i && $confirm_type ne "w2l") {
                            return &pop_up_error2($main,
                                    "The W2 source file is not a W2 Vector (w2l) file:\n$src_file");
                        } elsif ($src_type =~ /LakeCon/i && $confirm_type ne "lcon1") {
                            return &pop_up_error2($main,
                                    "The W2 source file is not an acceptable\n"
                                  . "W2 Lake Contour (format 1) file:\n$src_file");
                        }

                        &read_con($main, $id, $con_file);
                        $nwb = $grid{$id}{nwb};
                        @bs  = @{ $grid{$id}{bs} };
                        @be  = @{ $grid{$id}{be} };
                        @us  = @{ $grid{$id}{us} };
                        @ds  = @{ $grid{$id}{ds} };
                        for ($jw=1; $jw<=$nwb; $jw++) {
                            last if ($seg >= $us[$bs[$jw]] && $seg <= $ds[$be[$jw]]);
                        }
                        &read_bth($main, $id, $jw, $bth_file);

                        if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
                            $canvas->g_bind("<Motion>", "");
                            Tkx::event_generate($main, "<Motion>", -warp => 1,
                                                                   -x => ($coords[0]+$coords[2])/2,
                                                                   -y => ($coords[1]+$coords[3])/2);
                            $canvas->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"),
                                                                           $canvas, "menu" ]);
                            $main->g_focus;
                        }

                        if ($src_type =~ /Spreadsheet/i) {
                            &get_grid_elevations($main, $id, $jw);
                            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $src_lines,
                                                                "Reading W2 spreadsheet file...");
                            ($kt_ref, $elev_ref, $parm_ref)
                                            = &read_w2_spr_file($main, $id, $src_file, $parm, $parm_div,
                                                                $byear, $seg, $tz_offset, $jd_skip, $pbar);
                            &destroy_progress_bar($main, $pbar_window);

                            %kt_data   = %{ $kt_ref   };
                            %elev_data = %{ $elev_ref };
                            %parm_data = %{ $parm_ref };

                        } elsif ($src_type =~ /Contour/i) {
                            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $src_lines,
                                                                "Reading W2 contour file...");
                            %data = &read_w2_cpl_file($main, $id, $jw, $src_file, $tplot, $seg, $parm,
                                                      $parm_div, $byear, $tz_offset, $jd_skip, $pbar);
                            &destroy_progress_bar($main, $pbar_window);

                            %kt_data   = ();
                            %elev_data = ();
                            %parm_data = ();
                            @mydates = keys %data;
                            for ($j=0; $j<=$#mydates; $j++) {
                                $dt    = $mydates[$j];
                                $kt    = $data{$dt}{kt};
                                @elws  = @{ $data{$dt}{elws}      };
                                @pdata = @{ $data{$dt}{parm_data} };
                                if (defined($elws[$seg])) {
                                    $elev_data{$dt} = $elws[$seg];
                                    for ($k=$kt; $k<=$#pdata; $k++) {
                                        $parm_data{$dt}[$k-$kt] = $pdata[$k][$seg];
                                    }
                                }
                                $kt_data{$dt} = $kt;
                            }
                            undef %data;

                        } elsif ($props{$id}{src_type} =~ /Vector/i) {
                            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, -s $src_file,
                                                                         "Reading W2 vector file...");
                            $status_line = "Reading W2 vector file... Date = 1";
                            %data = &read_w2_vector_file($main, $id, $src_file, $seg, $parm, $parm_div,
                                                         $byear, $tz_offset, $jd_skip, $pbar);
                            &destroy_progress_bar($main, $pbar_window);

                            %kt_data   = ();
                            %elev_data = ();
                            %parm_data = ();
                            @kb        = @{ $grid{$id}{kb} };
                            @mydates   = keys %data;
                            for ($j=0; $j<=$#mydates; $j++) {
                                $dt    = $mydates[$j];
                                $kt    = $data{$dt}{kt};
                                @pdata = @{ $data{$dt}{parm_data} };
                                if (defined($data{$dt}{elws}) && $data{$dt}{elws} != -99) {
                                    $elev_data{$dt} = $data{$dt}{elws};
                                    for ($k=$kt; $k<=$#pdata; $k++) {
                                        $parm_data{$dt}[$k-$kt] = $pdata[$k];
                                        last if ($k >= $kb[$seg]);
                                    }
                                }
                                $kt_data{$dt} = $kt;
                            }
                            undef %data;

                        } elsif ($props{$id}{src_type} =~ /LakeCon/i) {
                            &get_grid_elevations($main, $id, $jw);
                            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $src_lines,
                                                                         "Reading W2 Lake Contour file...");
                            ($kt_ref, $elev_ref, $parm_ref)
                                            = &read_w2_lakecon_file($main, $id, $src_file, $seg, $parm,
                                                                    $byear, $tz_offset, $jd_skip, $pbar);
                            &destroy_progress_bar($main, $pbar_window);

                            %kt_data   = %{ $kt_ref   };
                            %elev_data = %{ $elev_ref };
                            %parm_data = %{ $parm_ref };
                        }

                        if (&list_match($ctype, @conv_types) > 0 || $ctype =~ /^Custom,/) {
                            $status_line = "Converting units...";
                            Tkx::update_idletasks();
                            %parm_data = &convert_timeseries($main, $ctype, 1, %parm_data);
                            $status_line = "";
                            Tkx::update_idletasks();
                        }

                        %limits = &find_w2_profile_limits($id, $seg, \%elev_data, \%parm_data);
                        $profile{date_min}  = $limits{date_min};
                        $profile{date_max}  = $limits{date_max};
                        $profile{dpth_min}  = $limits{dpth_min};
                        $profile{dpth_max}  = $limits{dpth_max};
                        $profile{elev_min}  = $limits{elev_min};
                        $profile{elev_max}  = $limits{elev_max};
                        $profile{parm_min}  = $limits{parm_min};
                        $profile{parm_max}  = $limits{parm_max};
                        undef %limits;

                        $profile{kt_data}   = { %kt_data   };
                        $profile{elev_data} = { %elev_data };
                        $profile{parm_data} = { %parm_data };
                        $profile{ytype}     = $ytype;
                        $profile{yunits}    = $yunits;

                        if ($got_ref) {
                            $props{$id}{ref_file}  = $ref_file;
                            $props{$id}{ref_ctype} = $ref_ctype;
                            $props{$id}{ref_tol}   = $ref_tol;
                            $props{$id}{ref_color} = $ref_color;
                            $props{$id}{ref_size}  = $ref_size;
                            $props{$id}{ref_linew} = $ref_linew;
                            $props{$id}{ref_hide}  = $ref_hide;

                            %ref_profile = &read_profile($main, $ref_file);
                            if (&list_match($ref_ctype, @conv_types) > 0 || $ref_ctype =~ /^Custom,/) {
                                %ref_data = %{ $ref_profile{pdata} };
                                %ref_data = &convert_timeseries($main, $ref_ctype, 1, %ref_data);
                                $ref_profile{pdata} = { %ref_data };
                            }
                            $profile{ref_data} = { %ref_profile };
                        }

                    } elsif ($meta =~ /w2_outflow/) {
                        %profile = ();
                        $props{$id}{files}      = 1;
                        $props{$id}{con_file}   = $con_file;
                        $props{$id}{bth_file}   = $bth_file;
                        $props{$id}{qla_file}   = $qla_file;
                        $props{$id}{qla_lines}  = $qla_lines;
                        $props{$id}{seg}        = $seg;
                        $props{$id}{byear}      = $byear;
                        $props{$id}{tz_offset}  = $tz_offset;
                        $props{$id}{jd_skip}    = $jd_skip;
                        $props{$id}{add_parm}   = $add_parm;
                        if ($add_parm) {
                            $props{$id}{src_type}   = $src_type;
                            $props{$id}{src_file}   = $src_file;
                            $props{$id}{src_lines}  = $src_lines;
                            $props{$id}{tplot}      = $tplot;
                            $props{$id}{parm}       = $parm;
                            $props{$id}{parm_div}   = $parm_div;
                            $props{$id}{parm_units} = $parm_units;
                            $props{$id}{parm_ctype} = $ctype;
                            $props{$id}{parm_skip}  = $parm_skip;
                            $props{$id}{match_tol}  = $match_tol;
                        }

                        &read_con($main, $id, $con_file);
                        $nwb = $grid{$id}{nwb};
                        @bs  = @{ $grid{$id}{bs} };
                        @be  = @{ $grid{$id}{be} };
                        @us  = @{ $grid{$id}{us} };
                        @ds  = @{ $grid{$id}{ds} };
                        for ($jw=1; $jw<=$nwb; $jw++) {
                            last if ($seg >= $us[$bs[$jw]] && $seg <= $ds[$be[$jw]]);
                        }
                        &read_bth($main, $id, $jw, $bth_file);
                        &get_grid_elevations($main, $id, $jw);

                        if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
                            $canvas->g_bind("<Motion>", "");
                            Tkx::event_generate($main, "<Motion>", -warp => 1,
                                                                   -x => ($coords[0]+$coords[2])/2,
                                                                   -y => ($coords[1]+$coords[3])/2);
                            $canvas->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"),
                                                                           $canvas, "menu" ]);
                            $main->g_focus;
                        }
                        ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $qla_lines,
                                                             "Reading W2 Layer Outflow file...");
                        ($q_ref, $v_ref) = &read_w2_layer_outflow($main, $id, $qla_file, $seg,
                                                                  $byear, $tz_offset, $jd_skip, $pbar);
                        &destroy_progress_bar($main, $pbar_window);

                        %qdata           = %{ $q_ref };
                        %vdata           = %{ $v_ref };
                        $profile{qdata}  = { %qdata };
                        $profile{vdata}  = { %vdata };
                        $profile{ytype}  = $ytype;
                        $profile{yunits} = $yunits;
                        $profile{qunits} = $qunits;

                        %limits = &find_w2_outflow_limits($id, $seg, \%qdata, \%vdata);
                        $profile{date_min} = $limits{date_min};
                        $profile{date_max} = $limits{date_max};
                        $profile{dpth_min} = $limits{dpth_min};
                        $profile{dpth_max} = $limits{dpth_max};
                        $profile{elev_min} = $limits{elev_min};
                        $profile{elev_max} = $limits{elev_max};
                        $profile{flow_min} = $limits{flow_min};
                        $profile{flow_max} = $limits{flow_max};
                        $profile{vel_min}  = $limits{vel_min};
                        $profile{vel_max}  = $limits{vel_max};
                        undef %limits;

                        if ($add_parm) {
                            $confirm_type = &confirm_w2_ftype($main, $src_file);
                            if ($src_type =~ /Spreadsheet/i && $confirm_type ne "spr") {
                                return &pop_up_error2($main,
                                        "The W2 source file is not a W2 Spreadsheet file:\n$src_file");
                            } elsif ($src_type =~ /Contour/i && $confirm_type ne "cpl") {
                                return &pop_up_error2($main,
                                        "The W2 source file is not a W2 Contour file:\n$src_file");
                            } elsif ($src_type =~ /Vector/i && $confirm_type ne "w2l") {
                                return &pop_up_error2($main,
                                        "The W2 source file is not a W2 Vector (w2l) file:\n$src_file");
                            } elsif ($src_type =~ /LakeCon/i && $confirm_type ne "lcon1") {
                                return &pop_up_error2($main,
                                        "The W2 source file is not an acceptable\n"
                                      . "W2 Lake Contour (format 1) file:\n$src_file");
                            }
                            if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
                                $canvas->g_bind("<Motion>", "");
                                Tkx::event_generate($main, "<Motion>", -warp => 1,
                                                                       -x => ($coords[0]+$coords[2])/2,
                                                                       -y => ($coords[1]+$coords[3])/2);
                                $canvas->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"),
                                                                               $canvas, "menu" ]);
                                $main->g_focus;
                            }

                            if ($props{$id}{src_type} =~ /Spreadsheet/i) {
                                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $src_lines,
                                                                 "Reading W2 spreadsheet file...");
                                ($kt_ref, $elev_ref, $parm_ref)
                                        = &read_w2_spr_file($main, $id, $src_file, $parm, $parm_div,
                                                            $byear, $seg, $tz_offset, $parm_skip, $pbar);
                                &destroy_progress_bar($main, $pbar_window);

                                %kt_data   = %{ $kt_ref   };
                                %elev_data = %{ $elev_ref };
                                %parm_data = %{ $parm_ref };

                            } elsif ($props{$id}{src_type} =~ /Contour/i) {
                                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $src_lines,
                                                                 "Reading W2 contour file...");
                                %data = &read_w2_cpl_file($main, $id, $jw, $src_file, $tplot, $seg, $parm,
                                                          $parm_div, $byear, $tz_offset, $parm_skip, $pbar);
                                &destroy_progress_bar($main, $pbar_window);

                                %kt_data   = ();
                                %elev_data = ();
                                %parm_data = ();
                                @mydates = keys %data;
                                for ($j=0; $j<=$#mydates; $j++) {
                                    $dt    = $mydates[$j];
                                    $kt    = $data{$dt}{kt};
                                    @elws  = @{ $data{$dt}{elws}      };
                                    @pdata = @{ $data{$dt}{parm_data} };
                                    if (defined($elws[$seg])) {
                                        $elev_data{$dt} = $elws[$seg];
                                        for ($k=$kt; $k<=$#pdata; $k++) {
                                            $parm_data{$dt}[$k-$kt] = $pdata[$k][$seg];
                                        }
                                    }
                                    $kt_data{$dt} = $kt;
                                }
                                undef %data;

                            } elsif ($props{$id}{src_type} =~ /Vector/i) {
                                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, -s $src_file,
                                                                             "Reading W2 vector file...");
                                $status_line = "Reading W2 vector file... Date = 1";
                                %data = &read_w2_vector_file($main, $id, $src_file, $seg, $parm, $parm_div,
                                                             $byear, $tz_offset, $parm_skip, $pbar);
                                &destroy_progress_bar($main, $pbar_window);

                                %kt_data   = ();
                                %elev_data = ();
                                %parm_data = ();
                                @kb        = @{ $grid{$id}{kb} };
                                @mydates   = keys %data;
                                for ($j=0; $j<=$#mydates; $j++) {
                                    $dt    = $mydates[$j];
                                    $kt    = $data{$dt}{kt};
                                    @pdata = @{ $data{$dt}{parm_data} };
                                    if (defined($data{$dt}{elws}) && $data{$dt}{elws} != -99) {
                                        $elev_data{$dt} = $data{$dt}{elws};
                                        for ($k=$kt; $k<=$#pdata; $k++) {
                                            $parm_data{$dt}[$k-$kt] = $pdata[$k];
                                            last if ($k >= $kb[$seg]);
                                        }
                                    }
                                    $kt_data{$dt} = $kt;
                                }
                                undef %data;

                            } elsif ($props{$id}{src_type} =~ /LakeCon/i) {
                                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $src_lines,
                                                                 "Reading W2 Lake Contour file...");
                                ($kt_ref, $elev_ref, $parm_ref)
                                        = &read_w2_lakecon_file($main, $id, $src_file, $seg, $parm,
                                                                $byear, $tz_offset, $parm_skip, $pbar);
                                &destroy_progress_bar($main, $pbar_window);

                                %kt_data   = %{ $kt_ref   };
                                %elev_data = %{ $elev_ref };
                                %parm_data = %{ $parm_ref };
                            }

                            if (&list_match($ctype, @conv_types) > 0 || $ctype =~ /^Custom,/) {
                                $status_line = "Converting units...";
                                Tkx::update_idletasks();
                                %parm_data = &convert_timeseries($main, $ctype, 1, %parm_data);
                                $status_line = "";
                                Tkx::update_idletasks();
                            }
                            %limits = &find_w2_profile_limits($id, $seg, \%elev_data, \%parm_data);
                            $profile{parm_min}  = $limits{parm_min};
                            $profile{parm_max}  = $limits{parm_max};
                            undef %limits;

                            $profile{kt_data}   = { %kt_data   };
                            $profile{elev_data} = { %elev_data };
                            $profile{parm_data} = { %parm_data };
                        }

                    } elsif ($meta =~ /w2_slice/) {
                        %profile = ();
                        $props{$id}{files}      = 1;
                        $props{$id}{con_file}   = $con_file;
                        $props{$id}{src_type}   = $src_type;
                        $props{$id}{seg_list}   = $seg_list;
                        $props{$id}{wb_list}    = $wb_list;
                        $props{$id}{parm}       = $parm;
                        $props{$id}{parm_div}   = $parm_div;
                        $props{$id}{parm_units} = $parm_units;
                        $props{$id}{ctype}      = $ctype;
                        $props{$id}{byear}      = $byear;
                        $props{$id}{tz_offset}  = $tz_offset;
                        $props{$id}{jd_skip}    = $jd_skip;
                        $props{$id}{dt_limits}  = $dt_limits;
                        if ($src_type =~ /Contour/i) {
                            $props{$id}{tecplot}   = [ @tecplot   ];
                            $props{$id}{cpl_lines} = [ @cpl_lines ];
                            $props{$id}{cpl_files} = [ @cpl_files ];
                            $props{$id}{bth_files} = [ @bth_files ];
                        } elsif ($src_type =~ /Vector/i) {
                            $props{$id}{w2l_file}  = $w2l_file;
                            $props{$id}{bth_files} = [ @bth_files ];
                        }

                        if ($dt_limits) {
                            $props{$id}{dt_begin} = $dt_begin;
                            $props{$id}{dt_end}   = $dt_end;
                            if ($dt_begin =~ /[a-z][a-z][a-z]-[0-3]?[0-9]-[12][0-9][0-9][0-9]/i) {
                                ($mon, $day, $yr) = &parse_date($dt_begin, 1);
                                $dt_begin = sprintf("%04d%02d%02d0000", $yr, $mon, $day);
                            } else {
                                $dt_begin = -999;
                            }
                            if ($dt_end =~ /[a-z][a-z][a-z]-[0-3]?[0-9]-[12][0-9][0-9][0-9]/i) {
                                ($mon, $day, $yr) = &parse_date($dt_end, 1);
                                $dt_end = sprintf("%04d%02d%02d0000", $yr, $mon, $day);
                            } else {
                                $dt_end = -999;
                            }
                            $props{$id}{dt_limits} = 0 if ($dt_begin == -999 || $dt_end == -999);
                        } else {
                            $dt_begin = $dt_end = -999;
                        }

                        &read_con($main, $id, $con_file);
                        $status_line = "Reading bathymetry files...";
                        Tkx::update_idletasks();
                        for ($n=0; $n<=$#wbs; $n++) {
                            &read_bth($main, $id, $wbs[$n], $bth_files[$n]);
                        }
                        $status_line = "";
                        Tkx::update_idletasks();

                        if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
                            $canvas->g_bind("<Motion>", "");
                            Tkx::event_generate($main, "<Motion>", -warp => 1,
                                                                   -x => ($coords[0]+$coords[2])/2,
                                                                   -y => ($coords[1]+$coords[3])/2);
                            $canvas->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"),
                                                                           $canvas, "menu" ]);
                            $main->g_focus;
                        }

                        if ($src_type =~ /Contour/i) {
                            for ($n=0; $n<=$#wbs; $n++) {
                                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $cpl_lines[$n],
                                                             "Reading W2 contour file...");
                                %sdata = &read_w2_cpl_file($main, $id, $wbs[$n], $cpl_files[$n],
                                                           $tecplot[$n], 0, $parm, $parm_div, $byear,
                                                           $tz_offset, $jd_skip, $pbar, $dt_begin, $dt_end);
                                &destroy_progress_bar($main, $pbar_window);

                                if (&list_match($ctype, @conv_types) > 0 || $ctype =~ /^Custom,/) {
                                    $status_line = "Converting units...";
                                    Tkx::update_idletasks();
                                    %sdata = &convert_slice_data($main, $ctype, $id, $wbs[$n], %sdata);
                                    $status_line = "";
                                    Tkx::update_idletasks();
                                }
                                $slice_data[$n] = { %sdata };
                            }
                        } elsif ($src_type =~ /Vector/i) {
                            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, -s $w2l_file,
                                                         "Reading W2 vector file...");
                            $status_line = "Reading W2 vector file... Date = 1";
                            %sdata = &read_w2_vector_file($main, $id, $w2l_file, 0, $parm, $parm_div,
                                                          $byear, $tz_offset, $jd_skip, $pbar,
                                                          $dt_begin, $dt_end);
                            &destroy_progress_bar($main, $pbar_window);

                            if (&list_match($ctype, @conv_types) > 0 || $ctype =~ /^Custom,/) {
                                $status_line = "Converting units...";
                                Tkx::update_idletasks();
                                %sdata = &convert_slice_data($main, $ctype, $id, 'all', %sdata);
                                $status_line = "";
                                Tkx::update_idletasks();
                            }
                            $slice_data[0] = { %sdata };
                        }
                        $profile{slice_data} = [ @slice_data ];
                        undef %sdata;

                        %limits = &find_w2_slice_limits($id, %profile);
                        $profile{date_min}  = $limits{date_min};
                        $profile{date_max}  = $limits{date_max};
                        $profile{dpth_min}  = $limits{dpth_min};
                        $profile{dpth_max}  = $limits{dpth_max};
                        $profile{elev_min}  = $limits{elev_min};
                        $profile{elev_max}  = $limits{elev_max};
                        $profile{parm_min}  = $limits{parm_min};
                        $profile{parm_max}  = $limits{parm_max};
                        undef %limits;

                        $profile{ytype}     = $ytype;
                        $profile{yunits}    = $yunits;
                        $profile{xflip}     = $xflip;
                        $profile{xunits}    = $xunits;
                        $profile{xflip_img} = 0;
                        $profile{xmax_auto} = $xmax_auto;

                    } elsif ($meta =~ /w2_tdmap/) {
                        %profile = ();
                        $props{$id}{files}      = 1;
                        $props{$id}{map_type}   = $map_type;
                        $props{$id}{con_file}   = $con_file;
                        $props{$id}{src_type}   = $src_type;
                        $props{$id}{seg_list}   = $seg_list;
                        $props{$id}{wb_list}    = $wb_list;
                        $props{$id}{parm}       = $parm;
                        $props{$id}{parm_sav}   = $parm;
                        $props{$id}{parm_div}   = $parm_div;
                        $props{$id}{pdiv_sav}   = $parm_div;
                        $props{$id}{parm_units} = $parm_units;
                        $props{$id}{prof_stat}  = $prof_stat;
                        $props{$id}{ctype}      = $ctype;
                        $props{$id}{byear}      = $byear;
                        $props{$id}{tz_offset}  = $tz_offset;
                        $props{$id}{jd_skip}    = $jd_skip;

                        if ($src_type =~ /Contour/i) {
                            $props{$id}{tecplot}   = [ @tecplot   ];
                            $props{$id}{cpl_lines} = [ @cpl_lines ];
                            $props{$id}{cpl_files} = [ @cpl_files ];
                            $props{$id}{bth_files} = [ @bth_files ];
                        } elsif ($src_type =~ /Vector/i) {
                            $props{$id}{w2l_file}  = $w2l_file;
                            $props{$id}{bth_files} = [ @bth_files ];
                        } elsif ($src_type =~ /RiverCon/i) {
                            $br_list =~ s/,$//;
                            $props{$id}{br_list}   = $br_list;
                            $props{$id}{riv_lines} = [ @riv_lines ];
                            $props{$id}{riv_files} = [ @riv_files ];
                            $props{$id}{bth_files} = [ @bth_files ];
                        } elsif ($src_type =~ /SurfTemp|VolTemp|FlowTemp/i) {
                            $props{$id}{src_file}  = $src_file;
                            $props{$id}{src_lines} = $src_lines;
                            $props{$id}{bth_files} = [ @bth_files ];
                        }
                        if ($map_type eq "parmdiff") {
                            $props{$id}{src_type2}  = $src_type2 = $src_type;
                            $props{$id}{parm2}      = $parm2;
                            $props{$id}{parm2_sav}  = $parm2;
                            $props{$id}{parm2_div}  = $parm2_div;
                            $props{$id}{pdiv2_sav}  = $parm2_div;
                            $props{$id}{ctype2}     = $ctype2;
                            $props{$id}{swap_order} = $swap_order;
                            if ($src_type2 =~ /Contour/i) {
                                @tecplot2   = @tecplot;
                                @cpl_lines2 = @cpl_lines;
                                @cpl_files2 = @cpl_files;
                                $props{$id}{tecplot2}   = [ @tecplot2   ];
                                $props{$id}{cpl_lines2} = [ @cpl_lines2 ];
                                $props{$id}{cpl_files2} = [ @cpl_files2 ];
                            } elsif ($src_type2 =~ /Vector/i) {
                                $props{$id}{w2l_file2}  = $w2l_file2  = $w2l_file;
                            } elsif ($src_type2 =~ /RiverCon/i) {
                                $br_list2   = $br_list;
                                @riv_lines2 = @riv_lines;
                                @riv_files2 = @riv_files;
                                $props{$id}{br_list2}   = $br_list2;
                                $props{$id}{riv_lines2} = [ @riv_lines2 ];
                                $props{$id}{riv_files2} = [ @riv_files2 ];
                            } elsif ($src_type2 =~ /SurfTemp|VolTemp|FlowTemp/i) {
                                $props{$id}{src_file2}  = $src_file2  = $src_file;
                                $props{$id}{src_lines2} = $src_lines2 = $src_lines;
                            }
                        } elsif ($map_type eq "filediff") {
                            $props{$id}{src_type2}  = $src_type2;
                            $props{$id}{parm2}      = $parm2     = $parm;
                            $props{$id}{parm2_sav}  = $parm2     = $parm;
                            $props{$id}{parm2_div}  = $parm2_div = $parm_div;
                            $props{$id}{pdiv2_sav}  = $parm2_div = $parm_div;
                            $props{$id}{ctype2}     = $ctype2    = $ctype;
                            $props{$id}{match_tol}  = $match_tol;
                            $props{$id}{swap_order} = $swap_order;
                            if ($src_type2 =~ /Contour/i) {
                                $props{$id}{tecplot2}   = [ @tecplot2   ];
                                $props{$id}{cpl_lines2} = [ @cpl_lines2 ];
                                $props{$id}{cpl_files2} = [ @cpl_files2 ];
                            } elsif ($src_type2 =~ /Vector/i) {
                                $props{$id}{w2l_file2}  = $w2l_file2;
                            } elsif ($src_type2 =~ /RiverCon/i) {
                                $br_list2 =~ s/,$//;
                                $props{$id}{br_list2}   = $br_list2;
                                $props{$id}{riv_lines2} = [ @riv_lines2 ];
                                $props{$id}{riv_files2} = [ @riv_files2 ];
                            } elsif ($src_type2 =~ /SurfTemp|VolTemp|FlowTemp/i) {
                                $props{$id}{src_file2}  = $src_file2;
                                $props{$id}{src_lines2} = $src_lines2;
                            }
                        }

                        &read_con($main, $id, $con_file);
                        $status_line = "Reading bathymetry files...";
                        Tkx::update_idletasks();
                        for ($n=0; $n<=$#wbs; $n++) {
                            &read_bth($main, $id, $wbs[$n], $bth_files[$n]);
                        }
                        $status_line = "";
                        Tkx::update_idletasks();

                        if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
                            $canvas->g_bind("<Motion>", "");
                            Tkx::event_generate($main, "<Motion>", -warp => 1,
                                                                   -x => ($coords[0]+$coords[2])/2,
                                                                   -y => ($coords[1]+$coords[3])/2);
                            $canvas->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"),
                                                                           $canvas, "menu" ]);
                            $main->g_focus;
                        }

                        if ($src_type =~ /Contour/i) {
                            for ($n=0; $n<=$#wbs; $n++) {
                                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $cpl_lines[$n],
                                                             "Reading W2 contour file...");
                                %sdata = &read_w2_cpl_file($main, $id, $wbs[$n], $cpl_files[$n],
                                                           $tecplot[$n], 0, $parm, $parm_div, $byear,
                                                           $tz_offset, $jd_skip, $pbar);
                                &destroy_progress_bar($main, $pbar_window);

                                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, 10,
                                                             "Computing profile stats...");
                                %tmp_data = &compute_pstat_from_slice($main, $id, $prof_stat,
                                                                      $wbs[$n], $pbar, %sdata);
                                &destroy_progress_bar($main, $pbar_window);

                                if ($#wbs == 0 || $n == 0) {
                                    %td_data = %tmp_data;
                                    @mydates = keys %td_data;
                                    $dsum    = &sum(@mydates);
                                } else {
                                    @mydates = keys %tmp_data;
                                    if ($dsum != &sum(@mydates)) {
                                        &pop_up_info($main,
                                                     "Contour file dates for waterbody " . $wbs[$n] . "\n"
                                                   . "do not match those for waterbody " . $wbs[0] . "\n"
                                                   . "This could lead to visualization problems.");
                                    }
                                    foreach $dt (@mydates) {                             # each date/time
                                        foreach $seg (keys %{ $tmp_data{$dt} }) {        # each segment
                                            $td_data{$dt}{$seg} = $tmp_data{$dt}{$seg};
                                        }
                                    }
                                }
                                undef %sdata;
                                undef %tmp_data;
                            }
                        } elsif ($src_type =~ /Vector/i) {
                            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, -s $w2l_file,
                                                         "Reading W2 vector file...");
                            $status_line = "Reading W2 vector file... Date = 1";
                            %sdata = &read_w2_vector_file($main, $id, $w2l_file, 0, $parm, $parm_div,
                                                          $byear, $tz_offset, $jd_skip, $pbar);
                            &destroy_progress_bar($main, $pbar_window);

                            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, 10,
                                                         "Computing profile stats...");
                            %td_data = &compute_pstat_from_slice($main, $id, $prof_stat,
                                                                 "all", $pbar, %sdata);
                            &destroy_progress_bar($main, $pbar_window);
                            undef %sdata;

                        } elsif ($src_type =~ /RiverCon/i) {
                            @brs = split(/,/, $br_list);
                            for ($n=0; $n<=$#brs; $n++) {
                                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $riv_lines[$n],
                                                                             "Reading W2 RiverCon file...");
                                %tmp_data = &read_w2_rivcon_file($main, $id, $riv_files[$n], $parm, $brs[$n],
                                                                 $byear, $tz_offset, $jd_skip, $pbar);
                                &destroy_progress_bar($main, $pbar_window);

                                if ($#brs == 0 || $n == 0) {
                                    %td_data = %tmp_data;
                                    @mydates = keys %td_data;
                                    $dsum    = &sum(@mydates);
                                } else {
                                    @mydates = keys %tmp_data;
                                    if ($dsum != &sum(@mydates)) {
                                        &pop_up_info($main,
                                                     "RiverCon file dates for branch " . $brs[$n] . "\n"
                                                   . "do not match those for branch " . $brs[0] . "\n"
                                                   . "This could lead to visualization problems.");
                                    }
                                    foreach $dt (@mydates) {                             # each date/time
                                        foreach $seg (keys %{ $tmp_data{$dt} }) {        # each segment
                                            $td_data{$dt}{$seg} = $tmp_data{$dt}{$seg};
                                        }
                                    }
                                }
                                undef %tmp_data;
                            }

                        } elsif ($src_type =~ /SurfTemp|VolTemp|FlowTemp/i) {
                            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $src_lines,
                                                         "Reading " . $src_type . "...");
                            %td_data = &read_w2_flowtemp_alt($main, $src_file, $parm, $parm_div,
                                                             $byear, $tz_offset, $jd_skip, $pbar);
                            &destroy_progress_bar($main, $pbar_window);
                        }

                        if (&list_match($ctype, @conv_types) > 0 || $ctype =~ /^Custom,/) {
                            $status_line = "Converting units...";
                            Tkx::update_idletasks();
                            %td_data = &convert_tdmap_data($main, $ctype, %td_data);
                            $status_line = "";
                            Tkx::update_idletasks();
                        }
                        $profile{td_data} = { %td_data };

                        if ($props{$id}{map_type} =~ /^(parmdiff|filediff)$/) {
                            if ($src_type2 =~ /Contour/i) {
                                for ($n=0; $n<=$#wbs; $n++) {
                                    ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300,
                                                              $cpl_lines2[$n], "Reading W2 contour file...");
                                    %sdata = &read_w2_cpl_file($main, $id, $wbs[$n], $cpl_files2[$n],
                                                               $tecplot2[$n], 0, $parm2, $parm2_div,
                                                               $byear, $tz_offset, $jd_skip, $pbar);
                                    &destroy_progress_bar($main, $pbar_window);

                                    ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, 10,
                                                                             "Computing profile stats...");
                                    %tmp_data = &compute_pstat_from_slice($main, $id, $props{$id}{prof_stat},
                                                                          $wbs[$n], $pbar, %sdata);
                                    &destroy_progress_bar($main, $pbar_window);

                                    if ($#wbs == 0 || $n == 0) {
                                        %td_data = %tmp_data;
                                        @mydates = keys %td_data;
                                        $dsum    = &sum(@mydates);
                                    } else {
                                        @mydates = keys %tmp_data;
                                        if ($dsum != &sum(@mydates)) {
                                            &pop_up_info($main,
                                                         "Contour file dates for waterbody " . $wbs[$n] . "\n"
                                                       . "do not match those for waterbody " . $wbs[0] . "\n"
                                                       . "This could lead to visualization problems.");
                                        }
                                        foreach $dt (@mydates) {                           # each date/time
                                            foreach $seg (keys %{ $tmp_data{$dt} }) {      # each segment
                                                $td_data{$dt}{$seg} = $tmp_data{$dt}{$seg};
                                            }
                                        }
                                    }
                                    undef %sdata;
                                    undef %tmp_data;
                                }

                            } elsif ($src_type2 =~ /Vector/i) {
                                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, -s $w2l_file2,
                                                                             "Reading W2 vector file...");
                                $status_line = "Reading W2 vector file... Date = 1";
                                %sdata = &read_w2_vector_file($main, $id, $w2l_file2, 0, $parm2, $parm2_div,
                                                              $byear, $tz_offset, $jd_skip, $pbar);
                                &destroy_progress_bar($main, $pbar_window);

                                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, 10,
                                                                             "Computing profile stats...");
                                %td_data = &compute_pstat_from_slice($main, $id, $prof_stat,
                                                                     "all", $pbar, %sdata);
                                &destroy_progress_bar($main, $pbar_window);
                                undef %sdata;

                            } elsif ($src_type2 =~ /RiverCon/i) {
                                @brs = split(/,/, $br_list2);
                                for ($n=0; $n<=$#brs; $n++) {
                                    ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300,
                                                              $riv_lines2[$n], "Reading W2 RiverCon file...");
                                    %tmp_data = &read_w2_rivcon_file($main, $id, $riv_files2[$n], $parm2,
                                                                     $brs[$n], $byear, $tz_offset,
                                                                     $jd_skip, $pbar);
                                    &destroy_progress_bar($main, $pbar_window);

                                    if ($#brs == 0 || $n == 0) {
                                        %td_data = %tmp_data;
                                        @mydates = keys %td_data;
                                        $dsum    = &sum(@mydates);
                                    } else {
                                        @mydates = keys %tmp_data;
                                        if ($dsum != &sum(@mydates)) {
                                            &pop_up_info($main,
                                                         "RiverCon file dates for branch " . $brs[$n] . "\n"
                                                       . "do not match those for branch " . $brs[0] . "\n"
                                                       . "This could lead to visualization problems.");
                                        }
                                        foreach $dt (@mydates) {                           # each date/time
                                            foreach $seg (keys %{ $tmp_data{$dt} }) {      # each segment
                                                $td_data{$dt}{$seg} = $tmp_data{$dt}{$seg};
                                            }
                                        }
                                    }
                                    undef %tmp_data;
                                }

                            } elsif ($src_type2 =~ /SurfTemp|VolTemp|FlowTemp/i) {
                                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $src_lines2,
                                                                             "Reading " . $src_type2 . "...");
                                %td_data = &read_w2_flowtemp_alt($main, $src_file2, $parm2, $parm2_div,
                                                                 $byear, $tz_offset, $jd_skip, $pbar);
                                &destroy_progress_bar($main, $pbar_window);
                            }

                            if (&list_match($ctype2, @conv_types) > 0 || $ctype2 =~ /^Custom,/) {
                                $status_line = "Converting units...";
                                Tkx::update_idletasks();
                                %td_data = &convert_tdmap_data($main, $ctype2, %td_data);
                                $status_line = "";
                                Tkx::update_idletasks();
                            }

#                           Compute differences
                            %tmp_data = %{ $profile{td_data} };                 # data for parameter 1
                            if ($props{$id}{map_type} eq "parmdiff") {
                                foreach $dt (keys %tmp_data) {                  # each date/time
                                    foreach $seg (keys %{ $tmp_data{$dt} }) {   # each segment
                                        if (! defined($td_data{$dt}{$seg}) || $td_data{$dt}{$seg}  == -99
                                                                           || $tmp_data{$dt}{$seg} == -99) {
                                            $tmp_data{$dt}{$seg} = -99;
                                        } else {
                                            $tmp_data{$dt}{$seg} -= $td_data{$dt}{$seg};
                                        }
                                    }
                                }
                            } elsif ($props{$id}{map_type} eq "filediff") {
                                foreach $dt (keys %tmp_data) {                  # each date/time
                                    $dt2 = $dt;
                                    if (! defined($td_data{$dt2}) && $props{$id}{match_tol} > 0) {
                                        for ($mi=1; $mi<=$props{$id}{match_tol}; $mi++) {
                                            $dt_adj = &adjust_dt($dt2, $mi);
                                            if (defined($td_data{$dt_adj})) {
                                                $dt2 = $dt_adj;
                                                last;
                                            }
                                            $dt_adj = &adjust_dt($dt2, -1 *$mi);
                                            if (defined($td_data{$dt_adj})) {
                                                $dt2 = $dt_adj;
                                                last;
                                            }
                                        }
                                    }
                                    foreach $seg (keys %{ $tmp_data{$dt} }) {   # each segment
                                        if (! defined($td_data{$dt2}{$seg}) || $td_data{$dt2}{$seg} == -99
                                                                            || $tmp_data{$dt}{$seg} == -99) {
                                            $tmp_data{$dt}{$seg} = -99;
                                        } else {
                                            $tmp_data{$dt}{$seg} -= $td_data{$dt2}{$seg};
                                        }
                                    }
                                }
                            }
                            if ($swap_order) {                                  # swap order of difference
                                foreach $dt (keys %tmp_data) {                  # each date/time
                                    foreach $seg (keys %{ $tmp_data{$dt} }) {   # each segment
                                        if ($tmp_data{$dt}{$seg} != -99) {
                                            $tmp_data{$dt}{$seg} *= -1.0;
                                        }
                                    }
                                }
                            }
                            %td_data           = %tmp_data;
                            $profile{td_data}  = { %td_data };
                            $props{$id}{data2} = 1;
                            undef %tmp_data;
                        }

                        %limits = &find_w2_tdmap_limits($id, %td_data);
                        $profile{date_min} = $limits{date_min};
                        $profile{date_max} = $limits{date_max};
                        $profile{parm_min} = $limits{parm_min};
                        $profile{parm_max} = $limits{parm_max};
                        undef %limits;

                        if ($props{$id}{parm} =~ /^(Temperature|TEMP|Tmin|Tmean|Tmax)$/) {
                            $props{$id}{parm} = "Temperature";
                        }
                        if ($props{$id}{parm_div} =~ /^(Temperature|TEMP|Tmin|Tmean|Tmax)$/) {
                            $props{$id}{parm_div} = "Temperature";
                        }
                        if ($props{$id}{map_type} =~ /^(parmdiff|filediff)$/) {
                            if ($props{$id}{parm2} =~ /^(Temperature|TEMP|Tmin|Tmean|Tmax)$/) {
                                $props{$id}{parm2} = "Temperature";
                            }
                            if ($props{$id}{parm2_div} =~ /^(Temperature|TEMP|Tmin|Tmean|Tmax)$/) {
                                $props{$id}{parm2_div} = "Temperature";
                            }
                        }

                    } elsif ($meta =~ /w2_wlevels/) {
                        %profile = ();
                        $props{$id}{files}     = 1;
                        $props{$id}{con_file}  = $con_file;
                        $props{$id}{src_type}  = $src_type;
                        $props{$id}{seg_list}  = $seg_list;
                        $props{$id}{wb_list}   = $wb_list;
                        $props{$id}{byear}     = $byear;
                        $props{$id}{tz_offset} = $tz_offset;
                        $props{$id}{jd_skip}   = $jd_skip;
                        if ($src_type =~ /Contour/i) {
                            $props{$id}{extra_chk} = 0;
                            $props{$id}{tecplot}   = [ @tecplot   ];
                            $props{$id}{cpl_lines} = [ @cpl_lines ];
                            $props{$id}{cpl_files} = [ @cpl_files ];
                            $props{$id}{bth_files} = [ @bth_files ];
                        } elsif ($src_type =~ /Vector/i) {
                            $props{$id}{extra_chk} = 0;
                            $props{$id}{w2l_file}  = $w2l_file;
                            $props{$id}{bth_files} = [ @bth_files ];
                        } elsif ($src_type =~ /Water Level/i) {
                            $props{$id}{extra_chk} = $extra_chk;
                            $props{$id}{wl_file}   = $wl_file;
                            $props{$id}{wl_lines}  = $wl_lines;
                            $props{$id}{bth_files} = [ @bth_files ];
                        }

                        &read_con($main, $id, $con_file);
                        $status_line = "Reading bathymetry files...";
                        Tkx::update_idletasks();
                        for ($n=0; $n<=$#wbs; $n++) {
                            &read_bth($main, $id, $wbs[$n], $bth_files[$n]);
                            &get_grid_elevations($main, $id, $wbs[$n]);
                        }
                        $status_line = "";
                        Tkx::update_idletasks();

                        if ($src_type =~ /Contour|Vector/i) {
                            @bs = @{ $grid{$id}{bs} };
                            @be = @{ $grid{$id}{be} };
                            @us = @{ $grid{$id}{us} };
                            @ds = @{ $grid{$id}{ds} };
                        }

                        if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
                            $canvas->g_bind("<Motion>", "");
                            Tkx::event_generate($main, "<Motion>", -warp => 1,
                                                                   -x => ($coords[0]+$coords[2])/2,
                                                                   -y => ($coords[1]+$coords[3])/2);
                            $canvas->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"),
                                                                           $canvas, "menu" ]);
                            $main->g_focus;
                        }

                        if ($src_type =~ /Contour/i) {
                            for ($n=0; $n<=$#wbs; $n++) {
                                $jw = $wbs[$n];
                                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $cpl_lines[$n],
                                                             "Reading W2 contour file...");
                                %sdata = &read_w2_cpl_file($main, $id, $jw, $cpl_files[$n],
                                                           $tecplot[$n], 0, "Temperature", "None",
                                                           $byear, $tz_offset, $jd_skip, $pbar);
                                $nd      = 0;
                                @mydates = sort keys %sdata;
                                $pbar_window->g_wm_title("Processing data...");
                                $status_line = "";
                                Tkx::update_idletasks();
                                &reset_progress_bar($pbar, $#mydates +1, "Processing data... Date = 1");

#                               Consolidate data from different waterbodies
                                if ($#wbs == 0 || $n == 0) {
                                    $dsum    = &sum(@mydates);
                                    %wl_data = ();
                                    foreach $dt (@mydates) {
                                        &update_progress_bar($pbar, ++$nd, $dt);
                                        @cus  = @{ $sdata{$dt}{cus}  };
                                        @elws = @{ $sdata{$dt}{elws} };
                                        for ($jb=$bs[$jw]; $jb<=$be[$jw]; $jb++) {
                                            for ($i=$us[$jb]; $i<=$ds[$jb]; $i++) {
                                                if (! defined($cus[$jb]) || ! defined($elws[$i])
                                                                         || $i < $cus[$jb]) {
                                                    $wl_data{$dt}[$i] = -999;
                                                } else {
                                                    $wl_data{$dt}[$i] = $elws[$i];
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if ($dsum != &sum(@mydates)) {
                                        &pop_up_info($main,
                                                     "Contour file dates for waterbody " . $wbs[$n] . "\n"
                                                   . "do not match those for waterbody " . $wbs[0] . "\n"
                                                   . "This could lead to visualization problems.");
                                    }
                                    foreach $dt (@mydates) {
                                        &update_progress_bar($pbar, ++$nd, $dt);
                                        @cus  = @{ $sdata{$dt}{cus}  };
                                        @elws = @{ $sdata{$dt}{elws} };
                                        for ($jb=$bs[$jw]; $jb<=$be[$jw]; $jb++) {
                                            for ($i=$us[$jb]; $i<=$ds[$jb]; $i++) {
                                                if (! defined($cus[$jb]) || ! defined($elws[$i])
                                                                         || $i < $cus[$jb]) {
                                                    $wl_data{$dt}[$i] = -999;
                                                } else {
                                                    $wl_data{$dt}[$i] = $elws[$i];
                                                }
                                            }
                                        }
                                    }
                                }
                                &destroy_progress_bar($main, $pbar_window);
                                $status_line = "Cleaning up...                           ";
                                Tkx::update_idletasks();
                                undef %sdata;
                                undef @cus;
                                undef @elws;
                            }

                        } elsif ($src_type =~ /Vector/i) {
                            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, -s $w2l_file,
                                                         "Reading W2 vector file...");
                            $status_line = "Reading W2 vector file... Date = 1";
                            %sdata = &read_w2_vector_file($main, $id, $w2l_file, 0, "Temperature", "None",
                                                          $byear, $tz_offset, $jd_skip, $pbar);
                            @mydates = sort keys %sdata;
                            $pbar_window->g_wm_title("Processing data...");
                            $status_line = "";
                            Tkx::update_idletasks();
                            &reset_progress_bar($pbar, $#mydates +1, "Processing data... Date = 1");

                            $nd      = 0;
                            %wl_data = ();
                            foreach $dt (@mydates) {
                                &update_progress_bar($pbar, ++$nd, $dt);
                                @cus  = @{ $sdata{$dt}{cus}  };
                                @elws = @{ $sdata{$dt}{elws} };
                                for ($jb=1; $jb<=$grid{$id}{nbr}; $jb++) {
                                    for ($i=$us[$jb]; $i<=$ds[$jb]; $i++) {
                                        if (! defined($cus[$jb]) || ! defined($elws[$i])
                                                                 || $i < $cus[$jb]) {
                                            $wl_data{$dt}[$i] = -999;
                                        } else {
                                            $wl_data{$dt}[$i] = $elws[$i];
                                        }
                                    }
                                }
                            }
                            &destroy_progress_bar($main, $pbar_window);
                            $status_line = "Cleaning up...                           ";
                            Tkx::update_idletasks();
                            undef %sdata;
                            undef @cus;
                            undef @elws;

                        } elsif ($src_type =~ /Water Level/i) {
                            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $wl_lines,
                                                                 "Reading W2 water levels file...");
                            %wl_data = &read_w2_wlevel($main, $id, $wl_file, $byear, $tz_offset,
                                                       "all", $jd_skip, $extra_chk, $pbar);
                            &destroy_progress_bar($main, $pbar_window);
                        }
                        $profile{wl_data} = { %wl_data };

                        %limits = &find_w2_wlevel_limits($id, %wl_data);
                        $profile{date_min} = $limits{date_min};
                        $profile{date_max} = $limits{date_max};
                        $profile{elev_min} = $limits{elev_min};
                        $profile{elev_max} = $limits{elev_max};
                        undef %limits;

                        $profile{yunits}    = $yunits;
                        $profile{xflip}     = $xflip;
                        $profile{xunits}    = $xunits;
                        $profile{xmax_auto} = $xmax_auto;

                    } elsif ($meta =~ /data_profile/) {
                        $props{$id}{files}      = 1;
                        $props{$id}{src_file}   = $src_file;
                        $props{$id}{parm}       = $parm;
                        $props{$id}{parm_units} = $parm_units;
                        %profile                = &read_profile($main, $src_file);

                        %limits            = &find_data_limits($id, %profile);
                        $profile{date_min} = $limits{date_min};
                        $profile{date_max} = $limits{date_max};
                        $profile{dpth_min} = $limits{dpth_min};
                        $profile{dpth_max} = $limits{dpth_max};
                        $profile{elev_min} = $limits{elev_min};
                        $profile{elev_max} = $limits{elev_max};
                        $profile{parm_min} = $limits{parm_min};
                        $profile{parm_max} = $limits{parm_max};
                        undef %limits;

                        $props{$id}{prof_type}  = $prof_type;
                        if ($prof_type =~ /difference/i) {
                            $props{$id}{dref_type} = $dref_type;
                            if ($dref_type =~ /Constant/i) {
                                $props{$id}{dref_val} = $dref_val;
                            } else {
                                $props{$id}{dref_file}  = $dref_file;
                                $props{$id}{dref_ftype} = $dref_ftype;
                                $props{$id}{dref_lines} = $dref_lines;
                                $props{$id}{dref_parm}  = $dref_parm;
                                $props{$id}{dref_ctype} = $dref_ctype;
                                $props{$id}{dref_tol}   = $dref_tol;
                                if ($props{$id}{dref_ftype} =~ /^W2 /) {
                                    $props{$id}{dref_byear} = $dref_byear;
                                    $props{$id}{dref_tzoff} = $dref_tzoff;
                                }
                            }
                        }
                        $profile{ytype}  = $ytype;
                        $profile{yunits} = $yunits;

                    } elsif ($meta eq "vert_wd_zone") {
                        $props{$id}{files}     = 1;
                        $props{$id}{wt_file}   = $wt_file;
                        $props{$id}{wt_units}  = $wt_units;
                        %profile               = &read_profile($main, $wt_file);

                        $props{$id}{flow_file} = $flow_file;
                        $props{$id}{bth_file}  = $bth_file;
                        $props{$id}{seg}       = $seg;
                        $props{$id}{elbot}     = $elbot;
                        $props{$id}{wd_alg}    = $wd_alg;

                        %rel_data = &read_release_rates($main, $flow_file);
                        if ($profile{daily} != $rel_data{daily}) {
                            return &pop_up_error2($main, "The input temperature and release-rate data\n"
                                                       . "are not on the same time scale.  One is daily\n"
                                                       . "and the other is subdaily.  Please start over.");
                        }
                        ($kmx, $kb_seg, $h_ref, $b_ref) = &read_bth_slice($main, $seg, $bth_file);
                        @h  = @{ $h_ref };
                        @b  = @{ $b_ref };
                        @el = ();
                        $el[$kmx] = $elbot;
                        for ($k=$kmx-1; $k>=1; $k--) {
                            $el[$k] = $el[$k+1] +$h[$k];
                        }
                        $profile{kmx} = $kmx;
                        $profile{kb}  = $kb_seg;
                        $profile{b}   = [ @b  ];
                        $profile{el}  = [ @el ];

                        @ktsw = @{ $rel_data{ktsw} };
                        @kbsw = @{ $rel_data{kbsw} };
                        for ($n=0; $n<$rel_data{nout}; $n++) {
                            $ktsw[$n] = $kb_seg   if ($ktsw[$n] > $kb_seg);                   # already >= 2
                            $kbsw[$n] = $kb_seg   if ($kbsw[$n] > $kb_seg || $kbsw[$n] == 0); # 0 if bad input
                            $kbsw[$n] = $ktsw[$n] if ($kbsw[$n] < $ktsw[$n]);
                        }
                        $profile{ktsw}   = [ @ktsw ];
                        $profile{kbsw}   = [ @kbsw ];
                        $profile{nout}   = $rel_data{nout};
                        $profile{sw_alg} = $rel_data{sw_alg};
                        $profile{names}  = $rel_data{names};
                        $profile{estr}   = $rel_data{estr};
                        $profile{lw}     = $rel_data{lw};
                        $profile{qdata}  = $rel_data{qdata};
                        $profile{qunits} = $qunits;
                        $profile{ytype}  = $ytype;
                        $profile{yunits} = $yunits;

                        %limits            = &find_data_limits($id, %profile);
                        $profile{date_min} = $limits{date_min};
                        $profile{date_max} = $limits{date_max};
                        $profile{dpth_min} = $limits{dpth_min};
                        $profile{dpth_max} = $limits{dpth_max};
                        $profile{elev_min} = $limits{elev_min};
                        $profile{elev_max} = $limits{elev_max};
                        $profile{parm_min} = $limits{parm_min};
                        $profile{parm_max} = $limits{parm_max};
                        $profile{flow_min} = $limits{flow_min};
                        $profile{flow_max} = $limits{flow_max};
                        undef %limits;

                        if ($wd_alg eq "Libby Dam") {
                            $props{$id}{lbc_file} = $lbc_file;
                            %bh_config = &read_libby_config($main, $lbc_file);
                            $profile{num_ww}    = $bh_config{num_ww};
                            $profile{ww_names}  = $bh_config{ww_names};
                            $profile{num_outs}  = $bh_config{num_outs};
                            $profile{num_slots} = $bh_config{num_slots};
                            $profile{num_rows}  = $bh_config{num_rows};
                            $profile{bh_width}  = $bh_config{bh_width};
                            $profile{bh_height} = $bh_config{bh_height};
                            $profile{base_elev} = $bh_config{base_elev};
                            $profile{hlc_base}  = $bh_config{hlc_base};
                            $profile{hlc_inc}   = $bh_config{hlc_inc};
                            $profile{bh_miss}   = $bh_config{bh_miss};

                            @sw_alg = @{ $rel_data{sw_alg} };
                            $nww = -1;
                            for ($n=0; $n<=$#sw_alg; $n++) {
                                $nww++ if ($sw_alg[$n] eq "LibbyDam");
                            }
                            if ($nww +1 != $bh_config{num_ww}) {
                                return &pop_up_error2($main,
                                          "Libby bulkhead configuration file is inconsistent with\n"
                                        . "outflow release file in terms of the number of outlets\n"
                                        . "using Libby-Dam-like wet-well selective withdrawal:\n"
                                        . "  $lbc_file\n  $flow_file");
                            }
                            undef %bh_config;

                            $profile{bh_show}   = $bh_show;
                            $profile{bh_docked} = $bh_docked;
                            $profile{bh_xpos}   = $bh_xpos;
                            $profile{bh_ypos}   = $bh_ypos;
                            $profile{bh_font}   = $bh_font;
                            $profile{bh_size}   = $bh_size;
                            $profile{bh_weight} = $bh_weight;
                            $profile{bh_tcolor} = $bh_tcolor;
                            $profile{bh_bwidth} = $bh_bwidth;
                            $profile{bh_bcolor} = $bh_bcolor;
                            $profile{bh_bcellw} = $bh_bcellw;
                            $profile{bh_bcellh} = $bh_bcellh;
                        }
                    }
                    $profile{redraw}  = 1;
                    $gr_props{$id}    = { %profile };
                    $props{$id}{data} = 1;
                    undef %profile;

                    if ($meta =~ /^(data_profile|w2_profile|w2_profile_matrix|w2_outflow|vert_wd_zone)$/) {
                        $gr_props{$id}{add_cs}    = $add_cs;
                        $gr_props{$id}{gs_size}   = $gs_size;
                        $gr_props{$id}{gs_weight} = $gs_weight;
                    } elsif ($meta =~ /w2_slice|w2_wlevels/) {
                        $gr_props{$id}{add_cs}    = 1 if ($meta eq "w2_slice");
                        $gr_props{$id}{xbase}     = ($xbase ne "") ? $xbase : $xmin;
                        $gr_props{$id}{xfirst}    = $xfirst;
                        $gr_props{$id}{gs_size}   = $gs_size;
                        $gr_props{$id}{gs_weight} = $gs_weight;
                        $gr_props{$id}{stype}     = $stype;
                        $gr_props{$id}{sfont}     = $sfont;
                        $gr_props{$id}{st_size}   = $st_size;
                        $gr_props{$id}{st_weight} = $st_weight;
                        $gr_props{$id}{sl_size}   = $sl_size;
                        $gr_props{$id}{sl_weight} = $sl_weight;
                        $gr_props{$id}{smajor}    = $smajor;
                        $gr_props{$id}{spr_tics}  = $spr_tics;
                        $gr_props{$id}{sop_tics}  = $sop_tics;
                        $gr_props{$id}{stic_loc}  = $stic_loc;
                        $gr_props{$id}{sgrid}     = $sgrid;
                        $gr_props{$id}{sgrid_col} = $sgrid_col;
                        $gr_props{$id}{bgrid}     = $bgrid;
                        $gr_props{$id}{bgrid_col} = $bgrid_col;
                        $gr_props{$id}{stitle}    = $stitle;
                        if ($meta eq "w2_wlevels") {
                            $gr_props{$id}{wl_color} = $wl_color;
                            $gr_props{$id}{wl_style} = $wl_style;
                            $gr_props{$id}{wl_grid}  = $wl_grid;
                            $gr_props{$id}{wl_gridc} = $wl_gridc;
                        }
                    } elsif ($meta eq "w2_tdmap") {
                        $gr_props{$id}{add_cs}     = 1;
                        $gr_props{$id}{datefmt}    = $datefmt;
                        $gr_props{$id}{base_yr}    = $base_yr;
                        $gr_props{$id}{gstitle}    = $gstitle;
                        $gr_props{$id}{gs_size}    = $gs_size;
                        $gr_props{$id}{gs_weight}  = $gs_weight;
                        $gr_props{$id}{hide_title} = $hide_title;
                        $gr_props{$id}{hide_taxis} = $hide_taxis;
                        $gr_props{$id}{hide_daxis} = $hide_daxis;
                    } elsif ($meta =~ /(data_profile_cmap|w2_profile_cmap|time_series)/) {
                        $gr_props{$id}{datefmt}   = $datefmt;
                        $gr_props{$id}{add_cs}    = 1 if ($meta =~ /profile_cmap/);
                        $gr_props{$id}{xtype}     = $xtype;
                        $gr_props{$id}{base_yr}   = $base_yr;
                        $gr_props{$id}{datelinec} = $datelinec;
                        if ($meta =~ /data_profile_cmap|w2_profile_cmap/) {
                            $gr_props{$id}{dateline} = ($dateline < 0) ? 1 : $dateline;
                        } else {
                            $gr_props{$id}{dateline} = ($dateline < 0) ? 0 : $dateline;
                        }
                    }
                    if ($meta !~ /time_series|w2_wlevels/) {
                        $gr_props{$id}{cs_hide}   = $cs_hide;
                        $gr_props{$id}{cs_link}   = $cs_link;
                        $gr_props{$id}{cscheme1}  = $cscheme1;
                        $gr_props{$id}{cscheme2}  = $cscheme2;
                        $gr_props{$id}{ncolors}   = $ncolors;
                        $gr_props{$id}{cs_rev}    = $cs_rev;
                        $gr_props{$id}{cs_min}    = $cs_min;
                        $gr_props{$id}{cs_max}    = $cs_max;
                        $gr_props{$id}{cs_width}  = $cs_width;
                        $gr_props{$id}{cs_height} = $cs_height;
                        $gr_props{$id}{xleg_off}  = $xleg_off;
                        $gr_props{$id}{yleg_off}  = $yleg_off;
                        $gr_props{$id}{keyfont}   = $keyfont;
                        $gr_props{$id}{keytitle}  = $keytitle;
                        $gr_props{$id}{kt_size}   = $kt_size;
                        $gr_props{$id}{kt_weight} = $kt_weight;
                        $gr_props{$id}{kn_size}   = $kn_size;
                        $gr_props{$id}{kn_weight} = $kn_weight;
                        $gr_props{$id}{kn_digits} = $kn_digits;
                        if ($cs_major eq "auto") {
                            $gr_props{$id}{cs_major} = "auto";
                        } elsif ($cs_major <= 0) {
                            $gr_props{$id}{cs_major} = "auto";
                        } elsif ($cs_major > abs($cs_max -$cs_min)) {
                            $gr_props{$id}{cs_major} = abs($cs_max -$cs_min);
                        } else {
                            $gr_props{$id}{cs_major} = $cs_major;
                        }
                        if ($meta =~ /w2_profile|w2_slice|w2_outflow/) {
                            if ($meta =~ /^(w2_profile|w2_profile_matrix)$/) {
                                $gr_props{$id}{pr_style} = $pr_style;
                                $gr_props{$id}{pr_linec} = $pr_linec;
                                $gr_props{$id}{pr_linew} = $pr_linew;
                            }
                            $gr_props{$id}{pc_style} = $pc_style;
                            if ($meta eq "w2_profile_matrix") {
                                $props{$id}{link_id}     = "";
                                $gr_props{$id}{matrix}   = $matrix;
                                @tmp_list = split(" ", $pdates);
                                $gr_props{$id}{pdates}   = [ @tmp_list ];
                                @tmp_list = split(" ", $blanks);
                                $gr_props{$id}{blanks}   = [ @tmp_list ];
                                $gr_props{$id}{gs_pos}   = $gs_pos;
                                $gr_props{$id}{gs_fmt}   = $gs_fmt;
                                $gr_props{$id}{gs_color} = $gs_color;
                                $gr_props{$id}{gs_edge}  = $gs_edge;
                                $gr_props{$id}{gs_edgec} = $gs_edgec;
                                $gr_props{$id}{gs_fill}  = $gs_fill;
                                $gr_props{$id}{gs_fillc} = $gs_fillc;
                                $matrix_gnums{$id}       = $pr_gnum;
                                if ($ms_stats == 0 || $ms_stats == 1) {
                                    $gr_props{$id}{ms_stats}  = $ms_stats;
                                    $gr_props{$id}{ms_types}  = $ms_types;
                                    $gr_props{$id}{ms_digits} = $ms_digits;
                                    $gr_props{$id}{ms_interp} = $ms_interp;
                                    $gr_props{$id}{ms_font}   = $ms_font;
                                    $gr_props{$id}{ms_size}   = $ms_size;
                                    $gr_props{$id}{ms_weight} = $ms_weight;
                                    $gr_props{$id}{ms_slant}  = $ms_slant;
                                    $gr_props{$id}{ms_color}  = $ms_color;
                                    $gr_props{$id}{ms_edge}   = $ms_edge;
                                    $gr_props{$id}{ms_edgec}  = $ms_edgec;
                                    $gr_props{$id}{ms_fill}   = $ms_fill;
                                    $gr_props{$id}{ms_fillc}  = $ms_fillc;
                                    $gr_props{$id}{ms_pos}    = $ms_pos;
                                }
                            }
                        }
                    }

                    if ($meta eq "w2_tdmap") {
                        $gr_props{$id}{date_axis} = uc($date_axis);
                        $gr_props{$id}{ttitle}    = $ttitle;
                        $gr_props{$id}{tfont}     = $tfont;
                        $gr_props{$id}{tt_size}   = $tt_size;
                        $gr_props{$id}{tt_weight} = $tt_weight;
                        $gr_props{$id}{tl_size}   = $tl_size;
                        $gr_props{$id}{tl_weight} = $tl_weight;
                        $gr_props{$id}{tmin}      = $tmin;
                        $gr_props{$id}{tmax}      = $tmax;
                        $gr_props{$id}{tmajor}    = $tmajor;
                        $gr_props{$id}{tpr_tics}  = $tpr_tics;
                        $gr_props{$id}{top_tics}  = $top_tics;
                        $gr_props{$id}{ttype}     = $ttype;
                        $gr_props{$id}{tflip}     = $tflip;
                        $gr_props{$id}{tflip_img} = 0;
                        $gr_props{$id}{dtitle}    = $dtitle;
                        $gr_props{$id}{dfont}     = $dfont;
                        $gr_props{$id}{dt_size}   = $dt_size;
                        $gr_props{$id}{dt_weight} = $dt_weight;
                        $gr_props{$id}{dl_size}   = $dl_size;
                        $gr_props{$id}{dl_weight} = $dl_weight;
                        $gr_props{$id}{dbase}     = ($dbase ne "") ? $dbase : $dmin;
                        $gr_props{$id}{dmin}      = $dmin;
                        $gr_props{$id}{dmax}      = $dmax;
                        $gr_props{$id}{dmax_auto} = $dmax_auto;
                        $gr_props{$id}{dfirst}    = $dfirst;
                        $gr_props{$id}{dmajor}    = $dmajor;
                        $gr_props{$id}{dpr_tics}  = $dpr_tics;
                        $gr_props{$id}{dop_tics}  = $dop_tics;
                        $gr_props{$id}{dflip}     = $dflip;
                        $gr_props{$id}{dflip_img} = 0;
                        $gr_props{$id}{dunits}    = $dunits;
                        if ($gr_props{$id}{dunits} eq "miles") {
                            $gr_props{$id}{d_km} = ($dmax -$dmin) /(3280.84/5280.);
                        } else {
                            $gr_props{$id}{d_km} = ($dmax -$dmin);
                        }
                    } else {
                        $gr_props{$id}{xfont}     = $xfont;
                        $gr_props{$id}{xt_size}   = $xt_size;
                        $gr_props{$id}{xt_weight} = $xt_weight;
                        $gr_props{$id}{xl_size}   = $xl_size;
                        $gr_props{$id}{xl_weight} = $xl_weight;
                        $gr_props{$id}{xmin}      = $xmin;
                        $gr_props{$id}{xmax}      = $xmax;
                        $gr_props{$id}{xmajor}    = $xmajor;
                        $gr_props{$id}{xpr_tics}  = $xpr_tics;
                        $gr_props{$id}{xop_tics}  = $xop_tics;
                        $gr_props{$id}{xtitle}    = $xtitle;
                        $gr_props{$id}{yfont}     = $yfont;
                        $gr_props{$id}{yt_size}   = $yt_size;
                        $gr_props{$id}{yt_weight} = $yt_weight;
                        $gr_props{$id}{yl_size}   = $yl_size;
                        $gr_props{$id}{yl_weight} = $yl_weight;
                        $gr_props{$id}{ymin}      = $ymin;
                        $gr_props{$id}{ymax}      = $ymax;
                        $gr_props{$id}{ymajor}    = $ymajor;
                        $gr_props{$id}{ypr_tics}  = $ypr_tics;
                        $gr_props{$id}{yop_tics}  = $yop_tics;
                        $gr_props{$id}{ytitle}    = $ytitle;
                    }
                    $gr_props{$id}{gtfont}    = $gtfont;
                    $gr_props{$id}{gt_size}   = $gt_size;
                    $gr_props{$id}{gt_weight} = $gt_weight;
                    $gr_props{$id}{gtitle}    = $gtitle;

                    if ($meta =~ /time_series/) {
                        $gr_props{$id}{legtitle}  = $legtitle;
                        $gr_props{$id}{legfont}   = $legfont;
                        $gr_props{$id}{lt_size}   = $lt_size;
                        $gr_props{$id}{lt_weight} = $lt_weight;
                        $gr_props{$id}{le_size}   = $le_size;
                        $gr_props{$id}{le_weight} = $le_weight;
                        $gr_props{$id}{le_edge}   = $le_edge;
                        $gr_props{$id}{le_edgec}  = $le_edgec;
                        $gr_props{$id}{le_fill}   = $le_fill;
                        $gr_props{$id}{le_fillc}  = $le_fillc;
                        $gr_props{$id}{xleg_off}  = $xleg_off;
                        $gr_props{$id}{yleg_off}  = $yleg_off;
                        $gr_props{$id}{gap_tol}   = $gap_tol;
                        $gr_props{$id}{gridx}     = $gridx;
                        $gr_props{$id}{gridy}     = $gridy;
                        $gr_props{$id}{gridwidth} = $gridwidth;
                        $gr_props{$id}{gridcolor} = $gridcolor;
                        $props{$id}{ts_gnum}      = $ts_gnum;

                        %parms          = ();
                        $ts_type        = "Release Rate" if ($ts_type eq "Flow" &&
                                                             $meta eq "linked_time_series");
                        $parms{ts_type} = $ts_type;
                        $parms{units}   = $ts_units;
                        if ($meta eq "linked_time_series") {
                            $parms{show}  = [ @ts_show  ];
                            $parms{width} = [ @ts_width ];
                            $parms{color} = [ @ts_color ];
                        }
                        $props{$id}{ts_parms} = { %parms };

                        if ($#add_ts_setnum >= 0) {
                            @add_ts_lines = (0) x @add_ts_setnum;
                            %add_ts_parms             = ();
                            $add_ts_parms{ts_setnum}  = [ @add_ts_setnum ];
                            $add_ts_parms{ts_file}    = [ @add_ts_file   ];
                            $add_ts_parms{ts_show}    = [ @add_ts_show   ];
                            $add_ts_parms{ts_width}   = [ @add_ts_width  ];
                            $add_ts_parms{ts_color}   = [ @add_ts_color  ];
                            $add_ts_parms{ts_text}    = [ @add_ts_text   ];
                            $add_ts_parms{ts_ftype}   = [ @add_ts_ftype  ];
                            $add_ts_parms{ts_lines}   = [ @add_ts_lines  ];
                            $add_ts_parms{ts_param}   = [ @add_ts_param  ];
                            $add_ts_parms{ts_byear}   = [ @add_ts_byear  ];
                            $add_ts_parms{ts_tzoff}   = [ @add_ts_tzoff  ];
                            $add_ts_parms{ts_seg}     = [ @add_ts_seg    ];
                            $add_ts_parms{ts_ctype}   = [ @add_ts_ctype  ];
                            $add_ts_parms{ts_limits}  = [ ( )            ];
                            $add_ts_parms{ts_data}    = [ ( )            ];
                            $props{$id}{add_ts_parms} = { %add_ts_parms  };
                        }
                    }
                    push (@graph_nums, $gnum);
                    push (@graph_ids,  $id);

                    $status_line = "";
                    $canvas->configure(-cursor => $cursor_norm);
                    Tkx::update();
                    if ($meta eq "data_profile" || $meta eq "data_profile_cmap") {
                        if ($prof_type =~ /difference/i) {
                            &calculate_diffs($id);
                        }
                        &make_data_profile($canvas, $id, 1);

                    } elsif ($meta eq "vert_wd_zone") {
                        &make_wd_zone($canvas, $id, 1);

                    } elsif ($meta =~ /^(w2_profile|w2_profile_matrix|w2_profile_cmap)$/) {
                        undef %kt_data;
                        undef %elev_data;
                        undef %parm_data;
                        &make_w2_profile($canvas, $id, 1);

                    } elsif ($meta eq "w2_outflow") {
                        undef %qdata;
                        undef %vdata;
                        if ($add_parm) {
                            undef %kt_data;
                            undef %elev_data;
                            undef %parm_data;
                        }
                        &make_w2_outflow($canvas, $id, 1);

                    } elsif ($meta eq "w2_slice") {
                        undef @slice_data;
                        &make_w2_slice($canvas, $id, 1);

                    } elsif ($meta eq "w2_tdmap") {
                        undef %td_data;
                        &make_w2_tdmap($canvas, $id, 1);

                    } elsif ($meta eq "w2_wlevels") {
                        &make_w2_wlevels($canvas, $id, 1);

                    } elsif ($meta eq "linked_time_series") {
                        $i = &list_match($ts_gnum, @graph_nums);
                        if ($i > -1) {
                            $props{$id}{link_id} = $graph_ids[$i];
                            &make_ts_graph($canvas, $id, 1);
                        } else {
                            push (@tslink_ids, $id);
                        }

                    } elsif ($meta eq "time_series") {
                        &make_ts_graph($canvas, $id, 1);
                    }
                    if ($meta =~ /^(data_profile|vert_wd_zone)$/) {
                        foreach $ts_id (@tslink_ids) {
                            if ($props{$ts_id}{ts_gnum} == $gnum) {
                                $props{$ts_id}{link_id} = $id;
                                &make_ts_graph($canvas, $ts_id, 1);
                            }
                        }
                    }
                    $graph_num = &max($gnum, $graph_num);
                }
            }

#           Add link info, if object is a link
            if ($got_link) {
                $ln_type = "Release Rate" if ($ln_type eq "Flow");
                $link_props{$id}{gnum}   = $ln_gnum;
                $link_props{$id}{type}   = $ln_type;
                $link_props{$id}{form}   = $ln_form;
                $link_props{$id}{digits} = $ln_digits;
                if ($ln_form eq "stat") {
                    $link_props{$id}{tol}    = $ln_tol;
                    $link_props{$id}{interp} = $ln_interp;
                } else {
                    $link_props{$id}{outlet} = $ln_outlet;
                    $link_props{$id}{units}  = $ln_units;
                }
            }
            Tkx::update_idletasks();
        }
    }

    $savefile = $file if (! $revert);
    close ($fh);

#   Final details for any linked objects
    if (@animate_ids && $#animate_ids >= 0 && $got_links) {
        foreach $link_id (keys %link_props) {
            foreach $id (@animate_ids) {
                if ($link_props{$link_id}{gnum} == $props{$id}{gnum}) {
                    $link_props{$link_id}{id} = $id;
                    $canvas->addtag("link_gr" . $id, withtag => $link_id);
                    last;
                }
            }
        }
        foreach $id (@animate_ids) {
            if ($props{$id}{meta} =~ /^(data_profile|vert_wd_zone|w2_profile|w2_outflow)$/) {
                &update_links($canvas, $id, $dates[$dti-1]);
            }
        }
    }

#   Add link_id for any W2 profile matrix plots
    foreach $id (keys %matrix_gnums) {
        $gnum = $matrix_gnums{$id};
        $i    = &list_match($gnum, @graph_nums);
        if ($i > -1 && $props{$graph_ids[$i]}{meta} eq "w2_profile") {
            $props{$id}{link_id} = $graph_ids[$i];
        } else {
            $props{$id}{link_id} = "";
        }
    }

#   Set up any independent time-series text links
    &update_ind_links($canvas);

#   Ensure that global date limits are active only when appropriate
    if ($global_dt_limits) {
        $global_dt_limits = 0;
        if (@animate_ids && $#animate_ids >= 0) {
            foreach $id (@animate_ids) {
                if ($props{$id}{meta}
                        =~ /^(data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)$/) {
                    $global_dt_limits = 1;
                    last;
                }
            }
        }
        if ($global_dt_limits) {
            $pref_menu->entryconfigure(0, -state => 'normal');
        } else {
            $global_dt_begin = $global_dt_end = "na";
        }
    }
    $delay_autosave = 0;

#   Build the profile dates array for W2 profile plots with reference data.
#   Sets the w2profile_data variable and the dtis_with_pdata array.
    if (@animate_ids && $#animate_ids >= 0) {
        &build_profile_match_list();
    }

#   Put file name in title bar
    if ($revert) {
        $main->g_wm_title("W2 Animator");
        &pop_up_info($main, "Autosave file loaded. Please consider\n"
                          . "saving this project under a new name.", "Save File Notice");
    } else {
        $main->g_wm_title("W2 Animator  --  $file");
        &add_to_recent($file);
    }
}


sub pop_up_error2 {            # Needed to reset delay_autosave in open_file subroutine
    my ($parent, $msg) = @_;
    $delay_autosave = 0;
    &pop_up_error($parent, $msg);
}


sub add_to_recent {
    my ($file) = @_;
    my ($entry, $fh, $line, $n, $recent_file, $success,
        @entries,
       );

    $recent_file = "${prog_path}w2anim_recent.txt";
    @entries     = ();
    push (@entries, $file);   # Add current file to top of list

#   Delete any entries in the File/Recent menu
    $recent_menu->delete(0, 'end');

#   Check validity of recent file list, obtain the current list, then delete the file
    if (-e $recent_file) {
        $success = open ($fh, "<", $recent_file);
        if (defined($success)) {
            $line = <$fh>;
            if ($line =~ /^\# W2 Animator recent files list/) {
                while (defined( $entry = <$fh> )) {
                    $entry =~ s/^\s+//;
                    $entry =~ s/\s+$//;
                    next if ($entry =~ /^#/ || $entry eq "");
                    next if ($entry !~ /\.w2a$/ || ! -e $entry || -d $entry || -s $entry == 0);
                    $entry = File::Spec->rel2abs($entry);
                    if (File::Spec->case_tolerant()) {
                        next if (lc($entry) eq lc($file));
                    } else {
                        next if ($entry eq $file);
                    }
                    push (@entries, $entry);
                }
            }
            close ($fh);
        }
        unlink $recent_file;
    }

#   Write out the recent file list, with a maximum of 15 entries
    $success = open ($fh, ">", $recent_file);
    if (defined($success)) {
        print $fh "\# W2 Animator recent files list\n";
        for ($n=0; $n<=$#entries; $n++) {
            print $fh $entries[$n], "\n";
            $recent_menu->add_command(
                        -label   => $entries[$n],
                        -state   => 'normal',
                        -command => [ \&open_file, $entries[$n], 0 ],
                        );
            last if ($n == 14);
        }
        close ($fh);
        $recent_menu->add_command(
                    -label     => "Clear recent list",
                    -underline => 0,
                    -state     => 'normal',
                    -command   => \&clear_recent,
                    );
    } else {
        $recent_menu->add_command(
                    -label     => "None",
                    -underline => 0,
                    -state     => 'disabled',
                    );
    }
}


sub clear_recent {
    my ($fh, $recent_file, $success);

    $recent_file = "${prog_path}w2anim_recent.txt";

#   Delete any entries in the File/Recent menu and add None
    $recent_menu->delete(0, 'end');
    $recent_menu->add_command(
                -label     => "None",
                -underline => 0,
                -state     => 'disabled',
                );

#   Rewrite the recent files list
    $success = open ($fh, ">", $recent_file);
    if (defined($success)) {
        print $fh "\# W2 Animator recent files list\n";
        close ($fh);
    } else {
        unlink $recent_file if (-e $recent_file);
    }
}


sub autosave {
    my ($different, $i, $id, $interval, $n, $tmp_file, @id_list, @tmp_list);

#   Remove any previously scheduled autosave jobs. Probably aren't any.
    if ($autosave_id1 ne "" && $autosave_id2 ne "") {
        foreach $id (Tkx::SplitList(Tkx::after_info())) {
            Tkx::after_cancel($id) if ($id eq $autosave_id1 ||
                                       $id eq $autosave_id2);
        }
    }

#   Delay the autosave by 1 minute if an animation is in progress or if exporting output
    if ($anim_tb_status ne "stopped" || $delay_autosave) {
        $interval = 60000;
        $autosave_id2 = Tkx::after_idle(sub {$autosave_id1 = Tkx::after($interval, [\&autosave]);});
        return;
    }

#   Proceed with the autosave, but only if objects are present that are worth saving
    @id_list  = Tkx::SplitList($canvas->find_withtag("keep"));
    @tmp_list = @id_list;
    for ($i=0; $i<=$#tmp_list; $i++) {
        $id = $tmp_list[$i];
        if ($props{$id}{type} eq "graph") {
            if (! defined($props{$id}{gnum})) {        # Graph not fully created yet
                $n = &list_match($id, @id_list);
                splice(@id_list, $n, 1) if ($n >= 0);  # Remove from list
            }
        }
    }
    if ($#id_list >= 0) {
        $status_line = "Autosaving...";
        Tkx::update_idletasks();
        $tmp_file = "";
        if (-e $autosave_file) {
            ($tmp_file = $autosave_file) =~ s/\.w2a$/tmp\.w2a/;
            copy($autosave_file, $tmp_file);
        }
        &save_file($autosave_file, 1);
        if ($tmp_file ne "") {
            $different = &compare_saved($autosave_file, $tmp_file);
            if ($different) {
                unlink $autosave_file2 if (-e $autosave_file2);
                move($tmp_file, $autosave_file2);
                $autosave_menu->entryconfigure('end', -state => 'normal');
            } else {
                unlink $tmp_file;
            }
        }
        $autosave_menu->entryconfigure(8, -state => 'normal');  # entry 8 is "Revert, recent"
        $status_line = "Autosaving... done";
    }

#   The After interval is expressed in milliseconds.
#   One minute = 60,000 ms. Five minutes = 300,000 ms.
    $interval = 60000 *$autosave_interval;
    $autosave_id2 = Tkx::after_idle(sub {$autosave_id1 = Tkx::after($interval, [\&autosave]);});
}


sub reassign_autosave_files {
    my ($new_dir) = @_;
    my (
        $fh1, $fh2, $key, $line, $n, $new_autosave_file, $new_autosave_file2,
        $newfile, $oldfile, $pos, $random, $success1, $success2, $tmp_file,
        $val,
       );

    return if ($new_dir eq $temp_dir);
    $delay_autosave = 1;

    ($random = $autosave_file) =~ s/.*_autosave(\d+)\.w2a/$1/;
    $new_autosave_file  = "_autosave" . $random . ".w2a";
    $new_autosave_file2 = "_autosave" . $random . "_2.w2a";
    $new_autosave_file  = File::Spec->rel2abs($new_autosave_file,  $new_dir);
    $new_autosave_file2 = File::Spec->rel2abs($new_autosave_file2, $new_dir);

    for ($n=1; $n<=2; $n++) {
        if ($n==1) {
            $oldfile = $autosave_file;
            $newfile = $new_autosave_file;
        } else {
            $oldfile = $autosave_file2;
            $newfile = $new_autosave_file2;
        }
        if (-e $oldfile) {
            $success1 = open ($fh1, "<", $oldfile);
            $success2 = open ($fh2, ">", $newfile);
            if (defined($success1) && defined($success2)) {
                while (defined($line = <$fh1>)) {
                    if ($line =~ /_file: |_files: |_file2: | file: | add_data: /) {
                        $line =~ s/\s+$//;
                        $pos  = index($line, ":");
                        $key  = substr($line, 0, $pos);
                        $val  = substr($line, $pos +1);
                        $key  =~ s/^\s+//;
                        $val  =~ s/^\s+//;

                        if ($key =~ /cpl_files|cpl_file2|riv_files|riv_file2|bth_files|add_data/) {
                            (undef, $tmp_file) = split(/,/, $val);
                            $tmp_file =~ s/^\s+//;
                            $pos      = index($line, $tmp_file);
                            $tmp_file = File::Spec->rel2abs($tmp_file, $temp_dir);
                        } else {
                            $pos      = index($line, $val);
                            $tmp_file = File::Spec->rel2abs($val, $temp_dir);
                        }
                        $tmp_file = File::Spec->abs2rel($tmp_file, $new_dir);
                        $line = substr($line, 0, $pos) . $tmp_file . "\n";
                    }
                    print $fh2 $line;
                }
                close ($fh1);
                close ($fh2);
            }
            unlink $oldfile;
        }
    }
    $autosave_file  = $new_autosave_file;
    $autosave_file2 = $new_autosave_file2;
    $delay_autosave = 0;
}


sub compare_saved {
    my ($file1, $file2) = @_;
    my (
        $case_tol, $content1, $content2, $dir1, $dir2, $fh1, $fh2, $i,
        $key1, $key2, $line1, $line2, $n1, $n2, $pos, $success1, $success2,
        $tmp_file1, $tmp_file2, $val1, $val2, $vol1, $vol2,

        @lines1, @lines2,
       );

#   Files must exist and be readable
    return 0 if (! -e $file1 || ! -e $file2 || ! -r $file1 || ! -r $file2);

#   Must be able to open the files for reading
    $success1 = open ($fh1, "<", $file1);
    $success2 = open ($fh2, "<", $file2);
    return 0 if (! defined($success1) || ! defined($success2));

#   Simple tests to determine that these are W2Anim project files
    $line1 = <$fh1>;
    $line2 = <$fh2>;
    if ($line1 !~ /^\# W2 Animator data file, version/ || $line2 !~ /^\# W2 Animator data file, version/) {
        close ($fh1);
        close ($fh2);
        return 0;
    }
    $line1 = <$fh1>;
    $line2 = <$fh2>;
    if ($line1 !~ /^\# File created: / || $line2 !~ /^\# File created: /) {
        close ($fh1);
        close ($fh2);
        return 0;
    }

#   Slurp the rest of the files
    {
        local $/;    # Enable local slurp mode
        $content1 = <$fh1>;
        $content2 = <$fh2>;
    }
    close ($fh1);
    close ($fh2);

    @lines1 = split(/\n/, $content1);
    @lines2 = split(/\n/, $content2);
    return 1 if ($#lines1 != $#lines2);       # different number of lines

#   Get paths to files, as file names in project files have relative paths
    $case_tol = File::Spec->case_tolerant();
    ($vol1, $dir1, undef) = File::Spec->splitpath($file1);
    ($vol2, $dir2, undef) = File::Spec->splitpath($file2);
    for ($i=0; $i<=$#lines1; $i++) {
        if ($lines1[$i] =~ /_file: |_files: |_file2: | file: | add_data: /) {
            return 1 if ($lines2[$i] !~ /_file: |_files: |_file2: | file: | add_data: /);

            $lines1[$i] =~ s/^\s+//;
            $lines1[$i] =~ s/\s+$//;
            $pos  = index($lines1[$i], ":");
            $key1 = substr($lines1[$i], 0, $pos);
            $val1 = substr($lines1[$i], $pos +1);
            $val1 =~ s/^\s+//;

            $lines2[$i] =~ s/^\s+//;
            $lines2[$i] =~ s/\s+$//;
            $pos  = index($lines2[$i], ":");
            $key2 = substr($lines2[$i], 0, $pos);
            $val2 = substr($lines2[$i], $pos +1);
            $val2 =~ s/^\s+//;
            return 1 if ($key1 ne $key2);

            if ($key1 =~ /cpl_files|cpl_file2|riv_files|riv_file2|bth_files|add_data/) {
                ($n1, $tmp_file1) = split(/,/, $val1);
                ($n2, $tmp_file2) = split(/,/, $val2);
                $tmp_file1 =~ s/^\s+//;
                $tmp_file2 =~ s/^\s+//;
                $tmp_file1 = File::Spec->rel2abs($tmp_file1, $vol1 . $dir1);
                $tmp_file2 = File::Spec->rel2abs($tmp_file2, $vol2 . $dir2);
                return 1 if ($n1 ne $n2);
            } else {
                $tmp_file1 = File::Spec->rel2abs($val1, $vol1 . $dir1);
                $tmp_file2 = File::Spec->rel2abs($val2, $vol2 . $dir2);
            }
            if ($case_tol) {                # for case-tolerant systems like Windows
                $tmp_file1 = lc($tmp_file1);
                $tmp_file2 = lc($tmp_file2);
            }
            return 1 if ($tmp_file1 ne $tmp_file2);
        } else {
            return 1 if ($lines1[$i] ne $lines2[$i]);
        }
    }
    return 0;   # no differences found
}


sub save_file {
    my ($file, $silent) = @_;
    my (
        $blank, $bth_file, $colors, $con_file, $coordlist, $croplist,
        $date1, $date2, $dir, $fill, $fillcolor, $flow_file, $fname,
        $gnum, $group_tags, $i, $id, $img_file, $j, $lbc_file, $n, $pdates,
        $qla_file, $ref_file, $scale, $show_sets, $src_file, $tag, $type,
        $txt, $vol, $w2l_file, $wl_file, $widths, $wt_file, $xct, $xt,
        $yct, $yt,

        @bfiles, @blanks, @brs, @byear, @cfiles, @chosen_dates, @clines,
        @color, @coords, @crop, @ctype, @ftype, @id_list, @param, @rfiles,
        @rlines, @seg, @setnum, @show, @tags, @text, @tecplot, @tmp_list,
        @tsfile, @tzoff, @width,

        %parms,
       );

#   When autosaving, operate silently and do not check or save the file name
    $silent = 0 if (! defined($silent) || $silent != 1);

    if (defined($file) && ! $silent) {
        if (! -e $file) {
            undef $file;
        } else {
            return if ( lc(&pop_up_question($main, "Overwrite $file?")) eq "no" );
        }
    }
    if (! defined($file)) {
        $file = Tkx::tk___getSaveFile(
            -parent           => $main,
            -title            => "Save Project File",
            -initialdir       => abs_path(),
            -defaultextension => ".w2a",
            -filetypes => [ ['W2 Animator Files', '.w2a'],
                            ['All Files',  '*'],
                          ],
            );
    }
    return if (! defined($file) || $file eq "");
    $file = File::Spec->rel2abs($file);

    open (OUT, ">", $file) || return &pop_up_error($main, "Unable to save\n$file");
    if (! $silent) {
        $savefile = $file;
        &add_to_recent($file);
    }
    ($vol, $dir, $fname) = File::Spec->splitpath($file);
    $delay_autosave = 1;

#   Print header and canvas properties
    print OUT "# W2 Animator data file, version $version\n";
    print OUT "# File created: ", &get_datetime, "\n";
    print OUT "#\n";

    print OUT << "end_of_input";

==== CANVAS ====
  width:     $canvas_width
  height:    $canvas_height
  color:     $canvas_color
  text_slct: $text_select_color
  snap2grid: $snap2grid
  grid_spac: $grid_spacing
==== END CANVAS ====
end_of_input

#   Include global date limits, if present
    if ($global_dt_limits) {
        $date1 = $date2 = "na";
        if ($global_dt_begin =~ /^[12][0-9][0-9][0-9][01][0-9][0-3][0-9]0000$/) {
            $date1 = &date2datelabel($global_dt_begin, "Mon-DD-YYYY");
        }
        if ($global_dt_end =~ /^[12][0-9][0-9][0-9][01][0-9][0-3][0-9]0000$/) {
            $date2 = &date2datelabel($global_dt_end, "Mon-DD-YYYY");
        }
        if ($date1 ne "na" && $date2 ne "na") {
            print OUT << "end_of_input";

==== DATE LIMITS ====
  gdt_begin: $date1
  gdt_end:   $date2
==== END DATE LIMITS ====
end_of_input
        }
    }

#   Items from find command are returned in stacking order, w/ lowest first
    @id_list  = Tkx::SplitList($canvas->find_withtag("keep"));
    @tmp_list = @id_list;
    for ($i=0; $i<=$#tmp_list; $i++) {
        $id = $tmp_list[$i];
        if ($props{$id}{type} eq "graph") {
            if (! defined($props{$id}{gnum})) {        # Graph not fully created yet
                $n = &list_match($id, @id_list);
                splice(@id_list, $n, 1) if ($n >= 0);  # Remove from list
            }
        }
    }
    print OUT "\n==== OBJECTS ====  From lowest to highest\n";

    for ($i=0; $i<=$#id_list; $i++) {
        $id   = $id_list[$i];
        $type = $props{$id}{type};
        $xt   = $props{$id}{x} -3;
        $yt   = $props{$id}{y} -3;
        @tags = Tkx::SplitList($canvas->itemcget($id, -tags));
        $group_tags = "";
        if (&list_search("group_", @tags) > -1) {
            foreach $tag (@tags) {
                $group_tags .= $tag . " " if ($tag =~ /^group_/);
            }
            $group_tags =~ s/\s+$//;
        }

        if ($type eq "graph") {
            $xct    = $props{$id}{xc} -3;
            $yct    = $props{$id}{yc} -3;
            @coords = @{ $props{$id}{coordlist} };
            $coordlist = sprintf("%.5f", $coords[0]-3);
            for ($j=1; $j<=$#coords; $j++) {
                $coordlist .= ', ' . sprintf("%.5f", $coords[$j]-3);
            }
            print OUT << "end_of_input";
$type
  meta:      $props{$id}{meta}
  gnum:      $props{$id}{gnum}
  x:         $xt
  y:         $yt
  xc:        $xct
  yc:        $yct
  anchor:    $props{$id}{anchor}
  color:     $props{$id}{color}
  width:     $props{$id}{width}
  fill:      $props{$id}{fill}
  coordlist: $coordlist
end_of_input
            if ($props{$id}{meta} =~ /data_profile/) {
                $src_file = File::Spec->abs2rel($props{$id}{src_file}, $vol . $dir);
                print OUT << "end_of_input";
  src_file:  $src_file
  parm:      $props{$id}{parm}
  parmunits: $props{$id}{parm_units}
  prof_type: $props{$id}{prof_type}
end_of_input
                if ($props{$id}{prof_type} =~ /difference/i) {
                    print OUT << "end_of_input";
  dref_type: $props{$id}{dref_type}
end_of_input
                    if ($props{$id}{dref_type} =~ /Constant/i) {
                        print OUT << "end_of_input";
  dref_val:  $props{$id}{dref_val}
end_of_input
                    } else {
                        $ref_file = File::Spec->abs2rel($props{$id}{dref_file}, $vol . $dir);
                        print OUT << "end_of_input";
  dref_file: $ref_file
  dref_ftyp: $props{$id}{dref_ftype}
  dref_line: $props{$id}{dref_lines}
  dref_parm: $props{$id}{dref_parm}
  dref_ctyp: $props{$id}{dref_ctype}
  dref_tol:  $props{$id}{dref_tol}
end_of_input
                        if ($props{$id}{dref_ftype} =~ /^W2 /) {
                            print OUT << "end_of_input";
  dref_byr:  $props{$id}{dref_byear}
  dref_tzof: $props{$id}{dref_tzoff}
end_of_input
                        }
                    }
                }
            } elsif ($props{$id}{meta} =~ /w2_profile/) {
                $con_file = File::Spec->abs2rel($props{$id}{con_file}, $vol . $dir);
                $src_file = File::Spec->abs2rel($props{$id}{src_file}, $vol . $dir);
                $bth_file = File::Spec->abs2rel($props{$id}{bth_file}, $vol . $dir);
                if ($props{$id}{src_type} =~ /Spreadsheet|Contour|LakeCon/i) {
                    print OUT << "end_of_input";
  con_file:  $con_file
  bth_file:  $bth_file
  src_type:  $props{$id}{src_type}
  src_file:  $src_file
  src_lines: $props{$id}{src_lines}
end_of_input
                    if ($props{$id}{src_type} =~ /Contour/i) {
                        print OUT << "end_of_input";
  tplot:     $props{$id}{tplot}
end_of_input
                    }
                } elsif ($props{$id}{src_type} =~ /Vector/i) {
                    print OUT << "end_of_input";
  con_file:  $con_file
  bth_file:  $bth_file
  src_type:  $props{$id}{src_type}
  src_file:  $src_file
end_of_input
                }
                print OUT << "end_of_input";
  parm:      $props{$id}{parm}
  parm_div:  $props{$id}{parm_div}
  parmunits: $props{$id}{parm_units}
  ctype:     $props{$id}{ctype}
  seg:       $props{$id}{seg}
  byear:     $props{$id}{byear}
  tz_offset: $props{$id}{tz_offset}
  jd_skip:   $props{$id}{jd_skip}
end_of_input
                if ($props{$id}{meta} eq "w2_profile_matrix") {
                    @chosen_dates = @{ $gr_props{$id}{pdates} };
                    @blanks       = @{ $gr_props{$id}{blanks} };
                    $pdates = $blank = "";
                    for ($j=0; $j<=$#chosen_dates; $j++) {
                        $pdates .= $chosen_dates[$j];
                        $pdates .= " " if ($j < $#chosen_dates);
                    }
                    for ($j=0; $j<=$#blanks; $j++) {
                        $blank .= $blanks[$j];
                        $blank  .= " " if ($j < $#blanks);
                    }
                    if ($props{$id}{link_id} ne "" && defined($props{$props{$id}{link_id}}{gnum})) {
                        $gnum = $props{$props{$id}{link_id}}{gnum};
                    } else {
                        $gnum = -1;
                    }
                    print OUT << "end_of_input";
  matrix:    $gr_props{$id}{matrix}
  pr_gnum:   $gnum
  pr_dates:  $pdates
  blanks:    $blank
end_of_input
                }
            } elsif ($props{$id}{meta} =~ /w2_slice/) {
                $con_file = File::Spec->abs2rel($props{$id}{con_file}, $vol . $dir);
                print OUT << "end_of_input";
  con_file:  $con_file
  src_type:  $props{$id}{src_type}
end_of_input
                if ($props{$id}{src_type} =~ /Contour/i) {
                    @tecplot = @{ $props{$id}{tecplot}   };
                    @clines  = @{ $props{$id}{cpl_lines} };
                    @cfiles  = @{ $props{$id}{cpl_files} };
                    @bfiles  = @{ $props{$id}{bth_files} };
                    for ($j=0; $j<=$#cfiles; $j++) {
                        $cfiles[$j] = File::Spec->abs2rel($cfiles[$j], $vol . $dir);
                        $bfiles[$j] = File::Spec->abs2rel($bfiles[$j], $vol . $dir);
                        print OUT << "end_of_input";
  cpl_info:  $j, $tecplot[$j], $clines[$j]
  cpl_files: $j, $cfiles[$j]
  bth_files: $j, $bfiles[$j]
end_of_input
                    }
                } elsif ($props{$id}{src_type} =~ /Vector/i) {
                    $w2l_file = File::Spec->abs2rel($props{$id}{w2l_file}, $vol . $dir);
                    print OUT << "end_of_input";
  w2l_file:  $w2l_file
end_of_input
                    @bfiles = @{ $props{$id}{bth_files} };
                    for ($j=0; $j<=$#bfiles; $j++) {
                        $bfiles[$j] = File::Spec->abs2rel($bfiles[$j], $vol . $dir);
                        print OUT << "end_of_input";
  bth_files: $j, $bfiles[$j]
end_of_input
                    }
                }
                print OUT << "end_of_input";
  seg_list:  $props{$id}{seg_list}
  wb_list:   $props{$id}{wb_list}
  parm:      $props{$id}{parm}
  parm_div:  $props{$id}{parm_div}
  parmunits: $props{$id}{parm_units}
  ctype:     $props{$id}{ctype}
  byear:     $props{$id}{byear}
  tz_offset: $props{$id}{tz_offset}
  jd_skip:   $props{$id}{jd_skip}
  dt_limits: $props{$id}{dt_limits}
end_of_input
                if ($props{$id}{dt_limits}) {
                    print OUT << "end_of_input";
  dt_begin:  $props{$id}{dt_begin}
  dt_end:    $props{$id}{dt_end}
end_of_input
                }
            } elsif ($props{$id}{meta} =~ /w2_wlevels/) {
                $con_file = File::Spec->abs2rel($props{$id}{con_file}, $vol . $dir);
                print OUT << "end_of_input";
  con_file:  $con_file
  src_type:  $props{$id}{src_type}
end_of_input
                if ($props{$id}{src_type} =~ /Contour/i) {
                    @tecplot = @{ $props{$id}{tecplot}   };
                    @clines  = @{ $props{$id}{cpl_lines} };
                    @cfiles  = @{ $props{$id}{cpl_files} };
                    @bfiles  = @{ $props{$id}{bth_files} };
                    for ($j=0; $j<=$#cfiles; $j++) {
                        $cfiles[$j] = File::Spec->abs2rel($cfiles[$j], $vol . $dir);
                        $bfiles[$j] = File::Spec->abs2rel($bfiles[$j], $vol . $dir);
                        print OUT << "end_of_input";
  cpl_info:  $j, $tecplot[$j], $clines[$j]
  cpl_files: $j, $cfiles[$j]
  bth_files: $j, $bfiles[$j]
end_of_input
                    }
                } elsif ($props{$id}{src_type} =~ /Vector/i) {
                    $w2l_file = File::Spec->abs2rel($props{$id}{w2l_file}, $vol . $dir);
                    print OUT << "end_of_input";
  w2l_file:  $w2l_file
end_of_input
                    @bfiles = @{ $props{$id}{bth_files} };
                    for ($j=0; $j<=$#bfiles; $j++) {
                        $bfiles[$j] = File::Spec->abs2rel($bfiles[$j], $vol . $dir);
                        print OUT << "end_of_input";
  bth_files: $j, $bfiles[$j]
end_of_input
                    }
                } elsif ($props{$id}{src_type} =~ /Water Level/i) {
                    $wl_file = File::Spec->abs2rel($props{$id}{wl_file}, $vol . $dir);
                    print OUT << "end_of_input";
  wl_file:   $wl_file
  wl_lines:  $props{$id}{wl_lines}
end_of_input
                    @bfiles = @{ $props{$id}{bth_files} };
                    for ($j=0; $j<=$#bfiles; $j++) {
                        $bfiles[$j] = File::Spec->abs2rel($bfiles[$j], $vol . $dir);
                        print OUT << "end_of_input";
  bth_files: $j, $bfiles[$j]
end_of_input
                    }
                }
                print OUT << "end_of_input";
  seg_list:  $props{$id}{seg_list}
  wb_list:   $props{$id}{wb_list}
  byear:     $props{$id}{byear}
  tz_offset: $props{$id}{tz_offset}
  jd_skip:   $props{$id}{jd_skip}
  extra_chk: $props{$id}{extra_chk}
end_of_input
            } elsif ($props{$id}{meta} =~ /w2_tdmap/) {
                $con_file = File::Spec->abs2rel($props{$id}{con_file}, $vol . $dir);
                print OUT << "end_of_input";
  map_type:  $props{$id}{map_type}
  con_file:  $con_file
  src_type:  $props{$id}{src_type}
end_of_input
                if ($props{$id}{src_type} =~ /Contour/i) {
                    @tecplot = @{ $props{$id}{tecplot}   };
                    @clines  = @{ $props{$id}{cpl_lines} };
                    @cfiles  = @{ $props{$id}{cpl_files} };
                    @bfiles  = @{ $props{$id}{bth_files} };
                    for ($j=0; $j<=$#cfiles; $j++) {
                        $cfiles[$j] = File::Spec->abs2rel($cfiles[$j], $vol . $dir);
                        $bfiles[$j] = File::Spec->abs2rel($bfiles[$j], $vol . $dir);
                        print OUT << "end_of_input";
  cpl_info:  $j, $tecplot[$j], $clines[$j]
  cpl_files: $j, $cfiles[$j]
  bth_files: $j, $bfiles[$j]
end_of_input
                    }
                } elsif ($props{$id}{src_type} =~ /Vector/i) {
                    $w2l_file = File::Spec->abs2rel($props{$id}{w2l_file}, $vol . $dir);
                    print OUT << "end_of_input";
  w2l_file:  $w2l_file
end_of_input
                    @bfiles = @{ $props{$id}{bth_files} };
                    for ($j=0; $j<=$#bfiles; $j++) {
                        $bfiles[$j] = File::Spec->abs2rel($bfiles[$j], $vol . $dir);
                        print OUT << "end_of_input";
  bth_files: $j, $bfiles[$j]
end_of_input
                    }
                } elsif ($props{$id}{src_type} =~ /RiverCon/i) {
                    @brs    = split(/,/, $props{$id}{br_list});
                    @rlines = @{ $props{$id}{riv_lines} };
                    @rfiles = @{ $props{$id}{riv_files} };
                    @bfiles = @{ $props{$id}{bth_files} };
                    for ($j=0; $j<=$#rfiles; $j++) {
                        $rfiles[$j] = File::Spec->abs2rel($rfiles[$j], $vol . $dir);
                        print OUT << "end_of_input";
  riv_info:  $j, $brs[$j], $rlines[$j]
  riv_files: $j, $rfiles[$j]
end_of_input
                    }
                    for ($j=0; $j<=$#bfiles; $j++) {
                        $bfiles[$j] = File::Spec->abs2rel($bfiles[$j], $vol . $dir);
                        print OUT << "end_of_input";
  bth_files: $j, $bfiles[$j]
end_of_input
                    }
                } elsif ($props{$id}{src_type} =~ /SurfTemp|VolTemp|FlowTemp/i) {
                    $src_file = File::Spec->abs2rel($props{$id}{src_file}, $vol . $dir);
                    print OUT << "end_of_input";
  src_file:  $src_file
  src_lines: $props{$id}{src_lines}
end_of_input
                    @bfiles = @{ $props{$id}{bth_files} };
                    for ($j=0; $j<=$#bfiles; $j++) {
                        $bfiles[$j] = File::Spec->abs2rel($bfiles[$j], $vol . $dir);
                        print OUT << "end_of_input";
  bth_files: $j, $bfiles[$j]
end_of_input
                    }
                }
                if ($props{$id}{map_type} eq "filediff") {
                    print OUT << "end_of_input";
  src_type2: $props{$id}{src_type2}
  match_tol: $props{$id}{match_tol}
end_of_input
                    if ($props{$id}{src_type2} =~ /Contour/i) {
                        @tecplot = @{ $props{$id}{tecplot2}   };
                        @clines  = @{ $props{$id}{cpl_lines2} };
                        @cfiles  = @{ $props{$id}{cpl_files2} };
                        for ($j=0; $j<=$#cfiles; $j++) {
                            $cfiles[$j] = File::Spec->abs2rel($cfiles[$j], $vol . $dir);
                            print OUT << "end_of_input";
  cpl_info2: $j, $tecplot[$j], $clines[$j]
  cpl_file2: $j, $cfiles[$j]
end_of_input
                        }
                    } elsif ($props{$id}{src_type2} =~ /Vector/i) {
                        $w2l_file = File::Spec->abs2rel($props{$id}{w2l_file2}, $vol . $dir);
                        print OUT << "end_of_input";
  w2l_file2: $w2l_file
end_of_input
                    } elsif ($props{$id}{src_type2} =~ /RiverCon/i) {
                        @brs    = split(/,/, $props{$id}{br_list2});
                        @rlines = @{ $props{$id}{riv_lines2} };
                        @rfiles = @{ $props{$id}{riv_files2} };
                        for ($j=0; $j<=$#rfiles; $j++) {
                            $rfiles[$j] = File::Spec->abs2rel($rfiles[$j], $vol . $dir);
                            print OUT << "end_of_input";
  riv_info2: $j, $brs[$j], $rlines[$j]
  riv_file2: $j, $rfiles[$j]
end_of_input
                        }
                    } elsif ($props{$id}{src_type2} =~ /SurfTemp|VolTemp|FlowTemp/i) {
                        $src_file = File::Spec->abs2rel($props{$id}{src_file2}, $vol . $dir);
                        print OUT << "end_of_input";
  src_file2: $src_file
  src_line2: $props{$id}{src_lines2}
end_of_input
                    }
                }
                print OUT << "end_of_input";
  seg_list:  $props{$id}{seg_list}
  wb_list:   $props{$id}{wb_list}
  parm:      $props{$id}{parm_sav}
  parm_div:  $props{$id}{pdiv_sav}
  ctype:     $props{$id}{ctype}
end_of_input
                if ($props{$id}{map_type} eq "parmdiff") {
                    print OUT << "end_of_input";
  parm2:     $props{$id}{parm2_sav}
  parm2_div: $props{$id}{pdiv2_sav}
  ctype2:    $props{$id}{ctype2}
end_of_input
                }
                if ($props{$id}{map_type} =~ /^(parmdiff|filediff)$/) {
                    print OUT << "end_of_input";
  diff_swap: $props{$id}{swap_order}
end_of_input
                }
                print OUT << "end_of_input";
  parmunits: $props{$id}{parm_units}
  prof_stat: $props{$id}{prof_stat}
  byear:     $props{$id}{byear}
  tz_offset: $props{$id}{tz_offset}
  jd_skip:   $props{$id}{jd_skip}
end_of_input
            } elsif ($props{$id}{meta} =~ /w2_outflow/) {
                $con_file = File::Spec->abs2rel($props{$id}{con_file}, $vol . $dir);
                $bth_file = File::Spec->abs2rel($props{$id}{bth_file}, $vol . $dir);
                $qla_file = File::Spec->abs2rel($props{$id}{qla_file}, $vol . $dir);
                print OUT << "end_of_input";
  con_file:  $con_file
  bth_file:  $bth_file
  qla_file:  $qla_file
  qla_lines: $props{$id}{qla_lines}
  seg:       $props{$id}{seg}
  byear:     $props{$id}{byear}
  tz_offset: $props{$id}{tz_offset}
  jd_skip:   $props{$id}{jd_skip}
  qla_parm:  $props{$id}{add_parm}
end_of_input
                if ($props{$id}{add_parm}) {
                    $src_file = File::Spec->abs2rel($props{$id}{src_file}, $vol . $dir);
                    print OUT << "end_of_input";
  src_type:  $props{$id}{src_type}
  src_file:  $src_file
end_of_input
                    if ($props{$id}{src_type} =~ /Spreadsheet|LakeCon/i) {
                        print OUT << "end_of_input";
  src_lines: $props{$id}{src_lines}
end_of_input
                    } elsif ($props{$id}{src_type} =~ /Contour/i) {
                        print OUT << "end_of_input";
  src_lines: $props{$id}{src_lines}
  tplot:     $props{$id}{tplot}
end_of_input
                    }
                    print OUT << "end_of_input";
  parm:      $props{$id}{parm}
  parm_div:  $props{$id}{parm_div}
  parmunits: $props{$id}{parm_units}
  ctype:     $props{$id}{parm_ctype}
  parm_skip: $props{$id}{parm_skip}
  match_tol: $props{$id}{match_tol}
  add_cs:    $gr_props{$id}{add_cs}
end_of_input
                }
            } elsif ($props{$id}{meta} eq "vert_wd_zone") {
                $wt_file   = File::Spec->abs2rel($props{$id}{wt_file}, $vol . $dir);
                $flow_file = File::Spec->abs2rel($props{$id}{flow_file}, $vol . $dir);
                $bth_file  = File::Spec->abs2rel($props{$id}{bth_file},  $vol . $dir);
                print OUT << "end_of_input";
  wt_file:   $wt_file
  flow_file: $flow_file
  bth_file:  $bth_file
end_of_input
                if ($props{$id}{wd_alg} eq "Libby Dam") {
                    $lbc_file = File::Spec->abs2rel($props{$id}{lbc_file}, $vol . $dir);
                    print OUT << "end_of_input";
  lbc_file:  $lbc_file
  bh_show:   $gr_props{$id}{bh_show}
  bh_docked: $gr_props{$id}{bh_docked}
  bh_xpos:   $gr_props{$id}{bh_xpos}
  bh_ypos:   $gr_props{$id}{bh_ypos}
  bh_font:   $gr_props{$id}{bh_font}
  bh_size:   $gr_props{$id}{bh_size}
  bh_weight: $gr_props{$id}{bh_weight}
  bh_tcolor: $gr_props{$id}{bh_tcolor}
  bh_bwidth: $gr_props{$id}{bh_bwidth}
  bh_bcolor: $gr_props{$id}{bh_bcolor}
  bh_bcellw: $gr_props{$id}{bh_bcellw}
  bh_bcellh: $gr_props{$id}{bh_bcellh}
end_of_input
                }
                print OUT << "end_of_input";
  wd_alg:    $props{$id}{wd_alg}
  seg:       $props{$id}{seg}
  elbot:     $props{$id}{elbot}
  add_cs:    $gr_props{$id}{add_cs}
end_of_input
            }
            if ($props{$id}{meta} =~ /^(data_profile|w2_profile|w2_profile_matrix)$/) {
                print OUT << "end_of_input";
  add_cs:    $gr_props{$id}{add_cs}
end_of_input
            }
            if ($props{$id}{meta} !~ /time_series/ && defined($gr_props{$id}{add_cs})) {
                print OUT << "end_of_input";
  cs_hide:   $gr_props{$id}{cs_hide}
  cs_link:   $gr_props{$id}{cs_link}
  cscheme1:  $gr_props{$id}{cscheme1}
  cscheme2:  $gr_props{$id}{cscheme2}
  ncolors:   $gr_props{$id}{ncolors}
  cs_rev:    $gr_props{$id}{cs_rev}
  cs_min:    $gr_props{$id}{cs_min}
  cs_max:    $gr_props{$id}{cs_max}
  cs_major:  $gr_props{$id}{cs_major}
  cs_width:  $gr_props{$id}{cs_width}
  cs_height: $gr_props{$id}{cs_height}
  xleg_off:  $gr_props{$id}{xleg_off}
  yleg_off:  $gr_props{$id}{yleg_off}
  keyfont:   $gr_props{$id}{keyfont}
  keytitle:  $gr_props{$id}{keytitle}
  kt_size:   $gr_props{$id}{kt_size}
  kt_weight: $gr_props{$id}{kt_weight}
  kn_size:   $gr_props{$id}{kn_size}
  kn_weight: $gr_props{$id}{kn_weight}
  kn_digits: $gr_props{$id}{kn_digits}
end_of_input
            }
            if ($props{$id}{meta} =~ /^(w2_profile|w2_profile_matrix)$/) {
                print OUT << "end_of_input";
  pr_style:  $gr_props{$id}{pr_style}
  pr_linec:  $gr_props{$id}{pr_linec}
  pr_linew:  $gr_props{$id}{pr_linew}
  pc_style:  $gr_props{$id}{pc_style}
end_of_input
            }
            if ($props{$id}{meta} =~ /w2_profile_cmap|w2_slice|w2_outflow/) {
                print OUT << "end_of_input";
  pc_style:  $gr_props{$id}{pc_style}
end_of_input
            }
            if ($props{$id}{meta} eq "w2_tdmap") {
                print OUT << "end_of_input";
  date_axis: $gr_props{$id}{date_axis}
  ttitle:    $gr_props{$id}{ttitle}
  tfont:     $gr_props{$id}{tfont}
  tt_size:   $gr_props{$id}{tt_size}
  tt_weight: $gr_props{$id}{tt_weight}
  tl_size:   $gr_props{$id}{tl_size}
  tl_weight: $gr_props{$id}{tl_weight}
  tmin:      $gr_props{$id}{tmin}
  tmax:      $gr_props{$id}{tmax}
  tmajor:    $gr_props{$id}{tmajor}
  tpr_tics:  $gr_props{$id}{tpr_tics}
  top_tics:  $gr_props{$id}{top_tics}
  ttype:     $gr_props{$id}{ttype}
  tflip:     $gr_props{$id}{tflip}
  base_yr:   $gr_props{$id}{base_yr}
  datefmt:   $gr_props{$id}{datefmt}
  dtitle:    $gr_props{$id}{dtitle}
  dfont:     $gr_props{$id}{dfont}
  dt_size:   $gr_props{$id}{dt_size}
  dt_weight: $gr_props{$id}{dt_weight}
  dl_size:   $gr_props{$id}{dl_size}
  dl_weight: $gr_props{$id}{dl_weight}
  dbase:     $gr_props{$id}{dbase}
  dmin:      $gr_props{$id}{dmin}
  dmax:      $gr_props{$id}{dmax}
  dmax_auto: $gr_props{$id}{dmax_auto}
  dfirst:    $gr_props{$id}{dfirst}
  dmajor:    $gr_props{$id}{dmajor}
  dpr_tics:  $gr_props{$id}{dpr_tics}
  dop_tics:  $gr_props{$id}{dop_tics}
  dflip:     $gr_props{$id}{dflip}
  dunits:    $gr_props{$id}{dunits}
end_of_input
            } else {
                print OUT << "end_of_input";
  xtitle:    $gr_props{$id}{xtitle}
  xfont:     $gr_props{$id}{xfont}
  xt_size:   $gr_props{$id}{xt_size}
  xt_weight: $gr_props{$id}{xt_weight}
  xl_size:   $gr_props{$id}{xl_size}
  xl_weight: $gr_props{$id}{xl_weight}
  xmin:      $gr_props{$id}{xmin}
  xmax:      $gr_props{$id}{xmax}
  xmajor:    $gr_props{$id}{xmajor}
  xpr_tics:  $gr_props{$id}{xpr_tics}
  xop_tics:  $gr_props{$id}{xop_tics}
end_of_input
            }
            if ($props{$id}{meta} =~ /w2_slice|w2_wlevels/) {
                print OUT << "end_of_input";
  xmax_auto: $gr_props{$id}{xmax_auto}
  xbase:     $gr_props{$id}{xbase}
  xfirst:    $gr_props{$id}{xfirst}
  xflip:     $gr_props{$id}{xflip}
  xunits:    $gr_props{$id}{xunits}
end_of_input
            }
            if ($props{$id}{meta} =~ /(data_profile_cmap|w2_profile_cmap|time_series)/) {
                if (! defined($gr_props{$id}{base_yr}) || $gr_props{$id}{base_yr} eq "") {
                    $gr_props{$id}{base_yr} = (localtime(time))[5] +1900;
                }
                print OUT << "end_of_input";
  xtype:     $gr_props{$id}{xtype}
  base_yr:   $gr_props{$id}{base_yr}
  datefmt:   $gr_props{$id}{datefmt}
  dateline:  $gr_props{$id}{dateline}
  datelinec: $gr_props{$id}{datelinec}
end_of_input
            }
            if ($props{$id}{meta} =~ /w2_outflow|vert_wd_zone/) {
                print OUT << "end_of_input";
  qunits:    $gr_props{$id}{qunits}
end_of_input
                if ($props{$id}{meta} eq "vert_wd_zone") {
                    print OUT << "end_of_input";
  wt_units:  $props{$id}{wt_units}
end_of_input
                }
            }
            if ($props{$id}{meta} =~ /(data_profile|w2_profile|w2_slice|w2_outflow|vert_wd_zone)/) {
                print OUT << "end_of_input";
  ytype:     $gr_props{$id}{ytype}
  yunits:    $gr_props{$id}{yunits}
end_of_input
            } elsif ($props{$id}{meta} eq "w2_wlevels") {
                print OUT << "end_of_input";
  yunits:    $gr_props{$id}{yunits}
end_of_input
            }
            if ($props{$id}{meta} ne "w2_tdmap") {
                print OUT << "end_of_input";
  ytitle:    $gr_props{$id}{ytitle}
  yfont:     $gr_props{$id}{yfont}
  yt_size:   $gr_props{$id}{yt_size}
  yt_weight: $gr_props{$id}{yt_weight}
  yl_size:   $gr_props{$id}{yl_size}
  yl_weight: $gr_props{$id}{yl_weight}
  ymin:      $gr_props{$id}{ymin}
  ymax:      $gr_props{$id}{ymax}
  ymajor:    $gr_props{$id}{ymajor}
  ypr_tics:  $gr_props{$id}{ypr_tics}
  yop_tics:  $gr_props{$id}{yop_tics}
end_of_input
            }
            if ($props{$id}{meta} =~ /w2_slice|w2_wlevels/) {
                print OUT << "end_of_input";
  stype:     $gr_props{$id}{stype}
  sfont:     $gr_props{$id}{sfont}
  st_size:   $gr_props{$id}{st_size}
  st_weight: $gr_props{$id}{st_weight}
  sl_size:   $gr_props{$id}{sl_size}
  sl_weight: $gr_props{$id}{sl_weight}
  stic_loc:  $gr_props{$id}{stic_loc}
  smajor:    $gr_props{$id}{smajor}
  spr_tics:  $gr_props{$id}{spr_tics}
  sop_tics:  $gr_props{$id}{sop_tics}
  sgrid:     $gr_props{$id}{sgrid}
  sgrid_col: $gr_props{$id}{sgrid_col}
  bgrid:     $gr_props{$id}{bgrid}
  bgrid_col: $gr_props{$id}{bgrid_col}
  stitle:    $gr_props{$id}{stitle}
end_of_input
            }
            print OUT << "end_of_input";
  gtitle:    $gr_props{$id}{gtitle}
end_of_input
            if ($props{$id}{meta} eq "w2_tdmap") {
                print OUT << "end_of_input";
  gstitle:   $gr_props{$id}{gstitle}
end_of_input
            }
            print OUT << "end_of_input";
  gtfont:    $gr_props{$id}{gtfont}
  gt_size:   $gr_props{$id}{gt_size}
  gt_weight: $gr_props{$id}{gt_weight}
end_of_input
            if ($props{$id}{meta} =~
                    /^(data_profile|w2_profile|w2_profile_matrix|w2_slice|w2_outflow|vert_wd_zone)$/) {
                print OUT << "end_of_input";
  gs_size:   $gr_props{$id}{gs_size}
  gs_weight: $gr_props{$id}{gs_weight}
end_of_input
                if ($props{$id}{meta} eq "w2_profile_matrix") {
                    print OUT << "end_of_input";
  gs_pos:    $gr_props{$id}{gs_pos}
  gs_fmt:    $gr_props{$id}{gs_fmt}
  gs_color:  $gr_props{$id}{gs_color}
  gs_edge:   $gr_props{$id}{gs_edge}
  gs_edgec:  $gr_props{$id}{gs_edgec}
  gs_fill:   $gr_props{$id}{gs_fill}
  gs_fillc:  $gr_props{$id}{gs_fillc}
end_of_input
                }
            } elsif ($props{$id}{meta} eq "w2_wlevels") {
                print OUT << "end_of_input";
  gs_size:   $gr_props{$id}{gs_size}
  gs_weight: $gr_props{$id}{gs_weight}
  wl_color:  $gr_props{$id}{wl_color}
  wl_style:  $gr_props{$id}{wl_style}
  wl_grid:   $gr_props{$id}{wl_grid}
  wl_gridc:  $gr_props{$id}{wl_gridc}
end_of_input
            } elsif ($props{$id}{meta} eq "w2_tdmap") {
                print OUT << "end_of_input";
  gs_size:   $gr_props{$id}{gs_size}
  gs_weight: $gr_props{$id}{gs_weight}
  hidetitle: $gr_props{$id}{hide_title}
  hidetaxis: $gr_props{$id}{hide_taxis}
  hidedaxis: $gr_props{$id}{hide_daxis}
end_of_input
            }
            if ($props{$id}{meta} =~ /^(w2_profile|w2_profile_matrix)$/ && defined($props{$id}{ref_file})) {
                $ref_file = File::Spec->abs2rel($props{$id}{ref_file}, $vol . $dir);
                print OUT << "end_of_input";
  ref_file:  $ref_file
  ref_ctype: $props{$id}{ref_ctype}
  ref_tol:   $props{$id}{ref_tol}
  ref_color: $props{$id}{ref_color}
  ref_size:  $props{$id}{ref_size}
  ref_linew: $props{$id}{ref_linew}
  ref_hide:  $props{$id}{ref_hide}
end_of_input
                if ($props{$id}{meta} eq "w2_profile_matrix") {
                    if (defined($gr_props{$id}{ms_stats})) {
                        print OUT << "end_of_input";
  ms_stats:  $gr_props{$id}{ms_stats}
  ms_types:  $gr_props{$id}{ms_types}
  ms_digits: $gr_props{$id}{ms_digits}
  ms_interp: $gr_props{$id}{ms_interp}
  ms_font:   $gr_props{$id}{ms_font}
  ms_size:   $gr_props{$id}{ms_size}
  ms_weight: $gr_props{$id}{ms_weight}
  ms_slant:  $gr_props{$id}{ms_slant}
  ms_color:  $gr_props{$id}{ms_color}
  ms_edge:   $gr_props{$id}{ms_edge}
  ms_edgec:  $gr_props{$id}{ms_edgec}
  ms_fill:   $gr_props{$id}{ms_fill}
  ms_fillc:  $gr_props{$id}{ms_fillc}
  ms_pos:    $gr_props{$id}{ms_pos}
end_of_input
                    }
                }
            }
            if ($props{$id}{meta} =~ /time_series/) {
                print OUT << "end_of_input";
  gridx:     $gr_props{$id}{gridx}
  gridy:     $gr_props{$id}{gridy}
  gridwidth: $gr_props{$id}{gridwidth}
  gridcolor: $gr_props{$id}{gridcolor}
  legtitle:  $gr_props{$id}{legtitle}
  legfont:   $gr_props{$id}{legfont}
  lt_size:   $gr_props{$id}{lt_size}
  lt_weight: $gr_props{$id}{lt_weight}
  le_size:   $gr_props{$id}{le_size}
  le_weight: $gr_props{$id}{le_weight}
  le_edge:   $gr_props{$id}{le_edge}
  le_edgec:  $gr_props{$id}{le_edgec}
  le_fill:   $gr_props{$id}{le_fill}
  le_fillc:  $gr_props{$id}{le_fillc}
  xleg_off:  $gr_props{$id}{xleg_off}
  yleg_off:  $gr_props{$id}{yleg_off}
  gap_tol:   $gr_props{$id}{gap_tol}
end_of_input
                if ($props{$id}{meta} eq "linked_time_series") {
                    $gnum = $props{$props{$id}{link_id}}{gnum};
                    print OUT << "end_of_input";
  ts_gnum:   $gnum
end_of_input
                }
                %parms = %{ $props{$id}{ts_parms} };
                print OUT << "end_of_input";
  ts_type:   $parms{ts_type}
  ts_units:  $parms{units}
end_of_input
                if ($props{$id}{meta} eq "linked_time_series") {
                    @show      = @{ $parms{show}  };
                    @width     = @{ $parms{width} };
                    @color     = @{ $parms{color} };
                    $show_sets = $show[0];
                    $widths    = $width[0];
                    $colors    = $color[0];
                    for ($j=1; $j<=$#show; $j++) {
                        $show_sets .= ', ' . $show[$j];
                        $widths    .= ', ' . $width[$j];
                        $colors    .= ', ' . $color[$j];
                    }
                    print OUT << "end_of_input";
  ts_show:   $show_sets
  ts_width:  $widths
  ts_color:  $colors
end_of_input
                }
                if (defined($props{$id}{add_ts_parms})) {
                    %parms  = %{ $props{$id}{add_ts_parms} };
                    @setnum = @{ $parms{ts_setnum} };
                    @tsfile = @{ $parms{ts_file}   };
                    @ftype  = @{ $parms{ts_ftype}  };
                    @show   = @{ $parms{ts_show}   };
                    @width  = @{ $parms{ts_width}  };
                    @color  = @{ $parms{ts_color}  };
                    @text   = @{ $parms{ts_text}   };
                    @param  = @{ $parms{ts_param}  };
                    @byear  = @{ $parms{ts_byear}  };
                    @tzoff  = @{ $parms{ts_tzoff}  };
                    @seg    = @{ $parms{ts_seg}    };
                    @ctype  = @{ $parms{ts_ctype}  };
                    for ($j=0; $j<=$#setnum; $j++) {
                        $tsfile[$j] = File::Spec->abs2rel($tsfile[$j], $vol . $dir);
                        print OUT << "end_of_input";
  add_data:  $setnum[$j], $tsfile[$j]
  add_ftype: $setnum[$j], $ftype[$j]
  add_ctype: $setnum[$j], $ctype[$j]
  add_parm:  $setnum[$j], $param[$j]
  add_show:  $setnum[$j], $show[$j]
  add_width: $setnum[$j], $width[$j]
  add_color: $setnum[$j], $color[$j]
  add_text:  $setnum[$j], $text[$j]
end_of_input
                        if ($ftype[$j] =~ /^W2 /) {
                            print OUT << "end_of_input";
  add_byear: $setnum[$j], $byear[$j]
  add_tzoff: $setnum[$j], $tzoff[$j]
  add_seg:   $setnum[$j], $seg[$j]
end_of_input
                        }
                    }
                }
            }

        } elsif ($type eq "text") {
            if (defined($link_props{$id}{id})) {        # saved link text should be generic
                if ($link_props{$id}{form} eq "stat") {
                    ($txt = $props{$id}{text}) =~ s/([a-zA-Z]): .*$/$1: link/;
                } else {
                    $txt = "link";
                }
            } elsif (&list_match($id, @ind_link_ids) >= 0) {
                $txt = "text link";
            } else {
                $txt = $props{$id}{text};
            }
            print OUT << "end_of_input";
$type
  text:      $txt
  x:         $xt
  y:         $yt
  anchor:    $props{$id}{anchor}
  color:     $props{$id}{color}
  family:    $props{$id}{family}
  size:      $props{$id}{size}
  weight:    $props{$id}{weight}
  slant:     $props{$id}{slant}
  underline: $props{$id}{underline}
  angle:     $props{$id}{angle}
end_of_input
            if (&list_match($id, @ind_link_ids) >= 0) {
                $src_file = File::Spec->abs2rel($props{$id}{src_file}, $vol . $dir);
                print OUT << "end_of_input";
  src_file:  $src_file
  src_type:  $props{$id}{src_type}
  src_lines: $props{$id}{src_lines}
  ctype:     $props{$id}{ctype}
  parm:      $props{$id}{parm}
end_of_input
                if ($props{$id}{src_type} =~ /^W2 /) {
                    print OUT << "end_of_input";
  byear:     $props{$id}{byear}
  tz_offset: $props{$id}{tz_offset}
  seg:       $props{$id}{seg}
end_of_input
                }
                print OUT << "end_of_input";
  data_type: $props{$id}{data_type}
  ln_units:  $props{$id}{units}
  ln_digits: $props{$id}{digits}
  ln_tol:    $props{$id}{link_tol}
end_of_input
            }
        } elsif ($type eq "image") {
            $scale = sprintf("%.5f", $props{$id}{iw} /$props{$id}{iwc});
            @crop  = @{ $props{$id}{crop} };
            $croplist = sprintf("%.5f", $crop[0]);
            for ($j=1; $j<=3; $j++) {
                $croplist .= ', ' . sprintf("%.5f", $crop[$j]);
            }
            $img_file = File::Spec->abs2rel($props{$id}{file}, $vol . $dir);
            print OUT << "end_of_input";
$type
  x:         $xt
  y:         $yt
  anchor:    $props{$id}{anchor}
  angle:     $props{$id}{angle}
  crop:      $croplist
  scale:     $scale
  flip:      $props{$id}{flip}
  file:      $img_file
end_of_input
        } else {
            $xct = $props{$id}{xc} -3;
            $yct = $props{$id}{yc} -3;
            print OUT << "end_of_input";
$type
  x:         $xt
  y:         $yt
  xc:        $xct
  yc:        $yct
  anchor:    $props{$id}{anchor}
  color:     $props{$id}{color}
  width:     $props{$id}{width}
end_of_input
            if ($type =~ /rectangle|diamond|polygon|circle|ellipse/i) {
                if (defined($link_props{$id}{id})) {
                    $fill      = 1;
                    $fillcolor = ""
                } else {
                    $fill      = $props{$id}{fill};
                    $fillcolor = $props{$id}{fillcolor};
                }
            }
            if ($type eq "ellipse") {
                print OUT << "end_of_input";
  fill:      $fill
  fillcolor: $fillcolor
  angle:     $props{$id}{angle}
  hw:        $props{$id}{hw}
  hh:        $props{$id}{hh}
end_of_input
            } else {
                @coords = @{ $props{$id}{coordlist} };
                $coordlist = sprintf("%.5f", $coords[0]-3);
                for ($j=1; $j<=$#coords; $j++) {
                    $coordlist .= ', ' . sprintf("%.5f", $coords[$j]-3);
                }
                
                if ($type =~ /^(rectangle|diamond)$/) {
                    print OUT << "end_of_input";
  fill:      $fill
  fillcolor: $fillcolor
  angle:     $props{$id}{angle}
  smooth:    $props{$id}{smooth}
  coordlist: $coordlist
end_of_input
                } elsif ($type eq "polygon") {
                    print OUT << "end_of_input";
  fill:      $fill
  fillcolor: $fillcolor
  angle:     $props{$id}{angle}
  coordlist: $coordlist
end_of_input
                } elsif ($type eq "polyline") {
                    print OUT << "end_of_input";
  angle:     $props{$id}{angle}
end_of_input
                } elsif ($type eq "circle") {
                    print OUT << "end_of_input";
  fill:      $fill
  fillcolor: $fillcolor
  coordlist: $coordlist
end_of_input
                }
                if ($type =~ /^(line|polyline)$/) {
                    print OUT << "end_of_input";
  arrow:     $props{$id}{arrow}
  ahd1:      $props{$id}{ahd1}
  ahd2:      $props{$id}{ahd2}
  ahd3:      $props{$id}{ahd3}
  coordlist: $coordlist
end_of_input
                }
            }
        }
        if (defined($link_props{$id}{id})) {
            if ($link_props{$id}{form} eq "stat") {
                print OUT << "end_of_input";
  ln_gnum:   $link_props{$id}{gnum}
  ln_form:   $link_props{$id}{form}
  ln_type:   $link_props{$id}{type}
  ln_tol:    $link_props{$id}{tol}
  ln_interp: $link_props{$id}{interp}
  ln_digits: $link_props{$id}{digits}
end_of_input
            } else {
                print OUT << "end_of_input";
  ln_gnum:   $link_props{$id}{gnum}
  ln_type:   $link_props{$id}{type}
  ln_outlet: $link_props{$id}{outlet}
  ln_form:   $link_props{$id}{form}
  ln_units:  $link_props{$id}{units}
  ln_digits: $link_props{$id}{digits}
end_of_input
            }
        }
        if ($group_tags ne "") {
            print OUT "  grouptags: $group_tags\n";
        }
        print OUT "end $type\n";
    }
    print OUT "==== END OBJECTS ====\n";
    $delay_autosave = 0;
    if (! $silent) {
        close (OUT) || return &pop_up_error($main, "Trouble closing\n$file");
        $main->g_wm_title("W2 Animator  --  $file");
    } else {
        close (OUT);
    }
}


sub print_canvas {
    my ($fmt, $scalefac, $print_file) = @_;
    my (
        $b, $code, $eps_file, $fh, $g, $img, $png_file, $png_height,
        $png_width, $ps_add, $psdata, $r, $replace_str, $rnum, $search_str,
        @cmd_args,
       );

#   Get output file name.
    if ($fmt eq "PostScript") {
        $print_file = Tkx::tk___getSaveFile(
            -parent           => $main,
            -title            => 'Save as Encapsulated PostScript',
            -initialdir       => abs_path(),
            -defaultextension => ".eps",
            -filetypes => [ ['Encapsulated PostScript Files', '.eps'],
                            ['All Files', '*'],
                          ],
            );
    } elsif ($fmt eq "PDF") {
        $print_file = Tkx::tk___getSaveFile(
            -parent           => $main,
            -title            => 'Save as PDF',
            -initialdir       => abs_path(),
            -defaultextension => ".pdf",
            -filetypes => [ ['Portable Document Format', '.pdf'],
                            ['All Files', '*'],
                          ],
            );
    }
    if (! defined($print_file) || $print_file eq "") {
        return &pop_up_error($main, "Output file not specified.\nAborting...");
    }
    if ($fmt eq "Raster") {
        if ($print_file !~ /(\.bmp|\.gif|\.jpg|\.jpeg|\.png|\.ppm|\.tga|\.tif|\.tiff)$/i) {
            return &pop_up_error($main, "Output file format not recognized from file name.\n"
                                      . "Please use a file name extension that is one of:\n"
                                      . ".bmp, .gif, .jpg, .jpeg, .png, .ppm, .tga, .tif, or .tiff\n"
                                      . "Aborting...");
        }
        ($fmt = lc($print_file)) =~ s/.*(bmp|gif|jpg|jpeg|png|ppm|tga|tif|tiff)$/$1/i;
        $fmt = "jpeg" if ($fmt eq "jpg");
    }

#   End any current selection.
    &end_select($canvas, $old_id) if (defined($old_id));

#   Set the application to a busy state.
    Tkx::tk_busy_hold($main, -cursor => $cursor_wait);
    $status_line = "Working on print file $print_file.  Please wait...";
    Tkx::update();

#   Generate PS code to fill the background with the canvas color.
    $code    = &get_rgb_code($canvas_color);
    $r       = &hex2decimal(substr($code,1,2)) /255.;   # as a fraction between 0 and 1
    $g       = &hex2decimal(substr($code,3,2)) /255.;
    $b       = &hex2decimal(substr($code,5,2)) /255.;
    $ps_add  = "3 1 moveto\n";
    $ps_add .= sprintf("%d 1 lineto\n", $canvas_width +2);
    $ps_add .= sprintf("%d %d lineto\n", $canvas_width +2, $canvas_height);
    $ps_add .= sprintf("3 %d lineto\n", $canvas_height);
    $ps_add .= "3 1 lineto\n";
    $ps_add .= sprintf("%5.3f %5.3f %5.3f setrgbcolor AdjustColor\n", $r, $g, $b);
    $ps_add .= "fill\ngrestore\ngsave\n";

#   PostScript option
    if ($fmt =~ /^(PostScript|PDF)$/) {
        $psdata = $canvas->postscript(-x => 3, -y => 3,
                                      -width      => $canvas_width,  -pagex => 0,
                                      -height     => $canvas_height, -pagey => 0,
                                      -pageanchor => 'sw',
                                      -pagewidth  => $canvas_width /$pixels_per_pt);

#       Swap "fill" for "eofill" commands
#       $psdata =~ s/eofill/fill/g;

#       Because of a bug in the canvas postscript method, need to redefine the scalefont function
#       Otherwise, all of the text will be too small
        $psdata =~ s/\%\%EndProlog/\/scalefont \{$pixels_per_pt mul scalefont\} bind def\n\%\%EndProlog/;

#       Fill the background with the canvas color.  Add code after "closepath clip newpath\ngsave"
        $psdata =~ s/closepath clip newpath\ngsave\n/closepath clip newpath\ngsave\n$ps_add/;

#       Tweak the bounding box in the EPS file slightly
        $search_str  = sprintf("%d %d", int(($canvas_width+1)  /$pixels_per_pt +0.5),
                                        int(($canvas_height+1) /$pixels_per_pt +0.5));
        $replace_str = sprintf("%d %d", int($canvas_width  /$pixels_per_pt +0.5),
                                        int($canvas_height /$pixels_per_pt +0.5));
        $psdata =~ s/\%\%BoundingBox: 0 0 $search_str/\%\%BoundingBox: 0 0 $replace_str/;

#       Write output
        if ($fmt eq "PostScript") {
            open ($fh, ">", $print_file)
                        || do { Tkx::tk_busy_forget($main);
                                $status_line = "Printing failed.";
                                return &pop_up_error($main, "Unable to open\n$print_file");
                              };
            print $fh $psdata;
            close ($fh) || do { Tkx::tk_busy_forget($main);
                                $status_line = "Printing failed.";
                                return &pop_up_error($main, "Trouble closing\n$print_file");
                              };
        } else {
            $rnum     = &get_random_number();
            $eps_file = "tmp_" . $rnum . ".eps";
            if ($use_temp) {
                $eps_file = $temp_dir . '/' . $eps_file;
            }
            open ($fh, ">", $eps_file)
                        || do { Tkx::tk_busy_forget($main);
                                $status_line = "Printing failed.";
                                return &pop_up_error($main, "Unable to open\n$eps_file");
                              };
            print $fh $psdata;
            close ($fh) || do { Tkx::tk_busy_forget($main);
                                $status_line = "Printing failed.";
                                return &pop_up_error($main, "Trouble closing\n$eps_file");
                              };

#           Break out each term of the command line to avoid problems with spaces in PATHs
            @cmd_args = ($GS_PROG, "-dSAFER", "-dBATCH", "-dNOPAUSE", "-dQUIET", "-sDEVICE=pdfimage24",
                         "-sFONTPATH=C:\\Windows\\Fonts", "-dEPSCrop", "-o", $print_file, $eps_file);
            system(@cmd_args);
            unlink $eps_file;
        }

    } else {
        $rnum     = &get_random_number();
        $eps_file = "tmp_" . $rnum . ".eps";
        if ($use_temp) {
            $eps_file = $temp_dir . '/' . $eps_file;
        }
        if ($fmt eq "png") {
            $png_file = $print_file;
        } else {
            $png_file = "tmp_" . $rnum . ".png";
            if ($use_temp) {
                $png_file = $temp_dir . '/' . $png_file;
            }
        }
        $png_width  = &round_to_int($canvas_width  *$scalefac /100);
        $png_height = &round_to_int($canvas_height *$scalefac /100);
        $psdata = $canvas->postscript(-x => 3, -y => 3,
                                      -width      => $canvas_width,  -pagex => 0,
                                      -height     => $canvas_height, -pagey => 0,
                                      -pageanchor => 'sw',
                                      -pagewidth  => $png_width);

#       Swap "fill" for "eofill" commands
#       $psdata =~ s/eofill/fill/g;

#       Because of a bug in the canvas postscript method, need to redefine the scalefont function
#       Otherwise, all of the text will be too small
        $psdata =~ s/\%\%EndProlog/\/scalefont \{$pixels_per_pt mul scalefont\} bind def\n\%\%EndProlog/;

#       Fill the background with the canvas color.  Add code after "closepath clip newpath\ngsave"
        $psdata =~ s/closepath clip newpath\ngsave\n/closepath clip newpath\ngsave\n$ps_add/;

        open ($fh, ">", $eps_file)
                    || do { Tkx::tk_busy_forget($main);
                            $status_line = "Printing failed.";
                            return &pop_up_error($main, "Unable to open temporary file\n$eps_file");
                          };
        print $fh $psdata;
        close ($fh) || do { Tkx::tk_busy_forget($main);
                            $status_line = "Printing failed.";
                            return &pop_up_error($main, "Trouble closing\n$eps_file");
                          };

#       Break out each term of the command line to avoid problems with spaces in PATHs
        @cmd_args = ($GS_PROG, "-dSAFER", "-dQUIET", "-sDEVICE=png16m", "-dGraphicsAlphaBits=2",
                     "-dTextAlphaBits=4", "-sFONTPATH=C:\\Windows\\Fonts",
                     "-g${png_width}x${png_height}", "-o", $png_file, $eps_file);
        system(@cmd_args);
        unlink $eps_file;
        if ($fmt ne "png") {
            $img = Imager->new;
            $img->read(file => $png_file)
                    || do { Tkx::tk_busy_forget($main);
                            $status_line = "Printing failed.";
                            return &pop_up_error($main,
                                                 "Problem loading temporary image file\n $img->errstr");
                          };
            if ($fmt eq "gif") {
                $img->write(file => $print_file, type => $fmt, translate => 'giflib', max_colors => 256)
                    || do { Tkx::tk_busy_forget($main);
                            $status_line = "Printing failed.";
                            return &pop_up_error($main, "Problem creating image file\n $img->errstr");
                          };
            } elsif ($fmt eq "jpeg") {
                $img->write(file => $print_file, type => $fmt, jpegquality => 100)
                    || do { Tkx::tk_busy_forget($main);
                            $status_line = "Printing failed.";
                            return &pop_up_error($main, "Problem creating image file\n $img->errstr");
                          };
            } else {
                $img->write(file => $print_file, type => $fmt)
                    || do { Tkx::tk_busy_forget($main);
                            $status_line = "Printing failed.";
                            return &pop_up_error($main, "Problem creating image file\n $img->errstr");
                          };
            }
            unlink $png_file;
        }
    }

#   Unset the busy status.
    Tkx::tk_busy_forget($main);

    $status_line = "Printing completed.";
}


sub scale_output {
    my ($fmt, $revisit) = @_;
    my (
        $bdate_label, $del_frames_tmp, $edate_label, $ext, $f, $fmt_chars,
        $fmt_choice, $format, $format_cb, $frame_rate_scale, $frame,
        $frame_end_scale, $frame_end_tmp, $frame_rate_max, $frame_rate_tmp,
        $frame_start_scale, $frame_start_tmp, $geom, $i, $ok_btn, $outfile,
        $row, $scalemin, $scalemax, $sfac_scale, $sfac_tmp, $X, $Y,

        @extension, @filetypes, @fmt_types, @type_text,
       );

    $revisit = 0 if (! defined($revisit));

    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $geom = sprintf("+%d+%d", $X+70, $Y+60);

    if (defined($scale_output_menu) && Tkx::winfo_exists($scale_output_menu)) {
        if ($scale_output_menu->g_wm_title() eq "Select and Scale Output") {
            $scale_output_menu->g_destroy();
            undef $scale_output_menu;
        }
    }
    $scale_output_menu = $main->new_toplevel();
    $scale_output_menu->g_wm_transient($main);
    $scale_output_menu->g_wm_title("Select and Scale Output");
    $scale_output_menu->configure(-cursor => $cursor_norm);
    $scale_output_menu->g_wm_geometry($geom);

    $outfile  =  "";
    $sfac_tmp = $scalefac;
    $scalemin =  50;
    $scalemax = 400;
    if ($fmt eq "Raster") {
        @filetypes = ( ['Portable Network Graphics files', '.png'],
                       ['Graphics Interchange Format files', '.gif'],
                       ['Joint Photographic Experts Group files', ['.jpg','.jpeg']],
                       ['Win32 bitmaps', '.bmp'],
                       ['Unix portable pixmaps', '.ppm'],
                       ['Targa images', '.tga'],
                       ['Tagged Image Format files', ['.tif','.tiff']],
                       ['All image formats',
                           ['.bmp','.gif','.jpg','.jpeg','.png',
                            '.ppm','.tga','.tif','.tiff']],
                     );
        @type_text = ( 'Portable Network Graphics (PNG)',
                       'Graphics Interchange Format (GIF)',
                       'Joint Photographic Experts Group (JPEG)',
                       'Win32 bitmap (BMP)',
                       'Unix portable pixmap (PPM)',
                       'Targa image (TGA)',
                       'Tagged Image Format (TIFF)',
                     );
        @extension = ( '.png',
                       '.gif',
                       '.jpg',
                       '.bmp',
                       '.ppm',
                       '.tga',
                       '.tiff',
                     );

    } elsif ($fmt eq "Animation") {
        if ($use_FFmpeg) {
            @filetypes = ( ['Audio Video Interleave files', '.avi'],
                           ['Flash Video files', '.flv'],
                           ['Graphics Interchange Format files', '.gif'],
                           ['QuickTime Movie files', '.mov'],
                           ['MPEG-4 files', '.mp4'],
                           ['All video formats', ['.avi','.flv','.gif','.mov','.mp4']],
                         );
            @type_text = ( 'Audio Video Interleave (AVI)',
                           'Flash Video (FLV)',
                           'Graphics Interchange Format (GIF)',
                           'QuickTime Movie (MOV)',
                           'MPEG-4 (MP4)',
                         );
            @extension = ( '.avi',
                           '.flv',
                           '.gif',
                           '.mov',
                           '.mp4',
                         );
        } else {
            @filetypes = ( ['Graphics Interchange Format files', '.gif'],
                           ['All video formats', ['.gif']],
                         );
            @type_text = ( 'Graphics Interchange Format (GIF)',
                         );
            @extension = ( '.gif',
                         );
        }
        $frame_end       = $dti_max if (! defined($frame_end)   || $frame_end   > $dti_max);
        $frame_start     = 1        if (! defined($frame_start) || $frame_start > $frame_end);
        $frame_start_tmp = $frame_start;
        $frame_end_tmp   = $frame_end;
        ($bdate_label    = &get_formatted_date($dates[$frame_start-1])) =~ s/^\s+//;
        ($edate_label    = &get_formatted_date($dates[$frame_end  -1])) =~ s/^\s+//;
        $frame_rate_max  = 60;
        $frame_rate      = 5 if (! defined($frame_rate));
        $frame_rate_tmp  = &max(1, &min($frame_rate, $frame_rate_max));
        $delete_frames   = 1 if (! defined($delete_frames));
        $del_frames_tmp  = $delete_frames;
    }
    $fmt_choice = 0;
    $format     = $type_text[$fmt_choice];
    $ext        = $extension[$fmt_choice];
    @fmt_types  = ( $filetypes[$fmt_choice], $filetypes[$#filetypes] );
    $fmt_chars  = length($type_text[0]);
    for ($i=1; $i<=$#type_text; $i++) {
        $fmt_chars = length($type_text[$i]) if (length($type_text[$i]) > $fmt_chars);
    }

    $frame = $scale_output_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -state   => 'disabled',
            -command => sub { my ($file_ext);
                              if (! defined($outfile) || $outfile eq "") {
                                  return &pop_up_error($scale_output_menu,
                                      "Output file not set. Please try again.");
                              }
                              if (! defined($sfac_tmp) || $sfac_tmp < $scalemin || $sfac_tmp > $scalemax) {
                                  return &pop_up_error($scale_output_menu,
                                      "Output scale factor not defined or outside of limits.");
                              }
                              if ($fmt eq "Animation") {
                                  $frame_start_tmp = 1        if ($frame_start_tmp < 1);
                                  $frame_end_tmp   = $dti_max if ($frame_end_tmp   > $dti_max);
                                  if ($frame_start_tmp > $frame_end_tmp) {
                                      return &pop_up_error($scale_output_menu,
                                          "Frame start index is greater than frame end index.");
                                  }
                                  $frame_rate_tmp = 1               if ($frame_rate_tmp < 1);
                                  $frame_rate_tmp = $frame_rate_max if ($frame_rate_tmp > $frame_rate_max);
                              }
                              ($file_ext = $outfile) =~ s/.*(\..*)$/$1/;
                              if (&list_match($file_ext, @extension) < 0) {
                                  return &pop_up_error($scale_output_menu,
                                      "File extension not consistent with chosen output format.");
                              }
                              $scalefac = $sfac_tmp;
                              $scale_output_menu->g_destroy();
                              undef $scale_output_menu;
                              if ($fmt eq "Raster") {
                                  &print_canvas($fmt, $scalefac, $outfile);
                              } else {
                                  $frame_start   = $frame_start_tmp;
                                  $frame_end     = $frame_end_tmp;
                                  $frame_rate    = $frame_rate_tmp;
                                  $delete_frames = $del_frames_tmp;
                                  if ($revisit) {
                                      return &make_animation($revisit, $outfile, $frame_end -$frame_start +1,
                                                             $frame_rate, $delete_frames);
                                  } else {
                                      return &make_anim_frames($scalefac, $outfile, $frame_start,
                                                               $frame_end, $frame_rate, $delete_frames);
                                  }
                              }
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $scale_output_menu->g_destroy();
                              undef $scale_output_menu;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

    $f = $scale_output_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "Output Format: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($format_cb = $f->new_ttk__combobox(
            -textvariable => \$format,
            -values       => [ @type_text ],
            -state        => 'readonly',
            -width        => $fmt_chars,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $format_cb->g_bind("<<ComboboxSelected>>",
                    sub { my ($n);
                          $n = &list_match($format, @type_text);
                          if ($n >= 0) {
                              $fmt_choice = $n;
                              $ext        = $extension[$fmt_choice];
                              @fmt_types  = ( $filetypes[$fmt_choice], $filetypes[$#filetypes] );
                              if (defined($outfile) && $outfile ne "" && $outfile !~ /$ext$/) {
                                  $outfile =~ s/(.*)\..*/$1$ext/;
                              }
                              if ($fmt eq "Animation") {
                                  $frame_rate_max = ($ext eq '.gif') ? 10 : 60;
                                  $frame_rate_tmp = &min($frame_rate_tmp, $frame_rate_max);
                                  $frame_rate_scale->configure(-to => $frame_rate_max);
                              }
                          }
                        }
                    );

    $row++;
    $f->new_label(
            -text => "Output File: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $f->new_label(
            -textvariable => \$outfile,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew');
    $f->new_button(
            -text    => "Browse",
            -command => sub { my ($file);
                              $file = Tkx::tk___getSaveFile(
                                      -parent           => $scale_output_menu,
                                      -title            => "Select Output File",
                                      -defaultextension => $ext,
                                      -initialdir       => abs_path(),
                                      -filetypes        => [ @fmt_types ],
                                      );
                              if ( $^O =~ /MSWin32/i ) {
                                  if (defined($file) && $file ne "") {
                                      $file =~ s/\//\\/g;
                                  }
                              }
                              if (defined($file) && $file ne "") {
                                  $outfile = $file;
                                  $ok_btn->configure(-state => 'normal');
                              } else {
                                  $ok_btn->configure(-state => 'disabled');
                              }
                            },
            )->g_grid(-row => $row, -column => 4, -sticky => 'ew', -padx => 2);

    $row++;
    $f->new_label(
            -text => "Scale Factor: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'se');
    ($sfac_scale = $f->new_scale(
            -orient       => 'horizontal',
            -from         => $scalemin,
            -to           => $scalemax,
            -variable     => \$sfac_tmp,
            -resolution   => 5,
            -length       => 150,
            -width        => 10,
            -sliderlength => 20,
            -takefocus    => 1,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w');
    $f->new_label(
            -text => "percent",
            -font => 'default',
            )->g_grid(-row => $row, -column => 2, -sticky => 'sw', -padx => 2);
    $f->new_label(
            -text  => "",
            -font  => 'default',
            -width => 15,
            )->g_grid(-row => $row, -column => 3, -columnspan => 2, -sticky => 'sw', -padx => 2);

    if ($fmt eq "Animation") {
        $row++;
        $f->new_label(
                -text => "Start Frame: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'se');
        ($frame_start_scale = $f->new_scale(
                -orient       => 'horizontal',
                -from         => 1,
                -to           => $dti_max,
                -variable     => \$frame_start_tmp,
                -resolution   => 1,
                -length       => 150,
                -width        => 10,
                -sliderlength => 20,
                -takefocus    => 1,
                -command => sub { $frame_start_tmp = $frame_end_tmp if ($frame_start_tmp > $frame_end_tmp);
                                  $bdate_label = &get_formatted_date($dates[$frame_start_tmp-1]);
                                  $bdate_label =~ s/^\s+//;
                                },
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w');
        $f->new_label(
                -textvariable => \$bdate_label,
                -anchor       => 'w',
                -font         => 'default',
                )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'sw');

        $row++;
        $f->new_label(
                -text => "End Frame: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'se');
        ($frame_end_scale = $f->new_scale(
                -orient       => 'horizontal',
                -from         => 1,
                -to           => $dti_max,
                -variable     => \$frame_end_tmp,
                -resolution   => 1,
                -length       => 150,
                -width        => 10,
                -sliderlength => 20,
                -takefocus    => 1,
                -command => sub { $frame_end_tmp = $frame_start_tmp if ($frame_end_tmp < $frame_start_tmp);
                                  $edate_label = &get_formatted_date($dates[$frame_end_tmp-1]);
                                  $edate_label =~ s/^\s+//;
                                },
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w');
        $f->new_label(
                -textvariable => \$edate_label,
                -anchor       => 'w',
                -font         => 'default',
                )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'sw');

        $row++;
        $f->new_label(
                -text => "Frame Rate: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'se');
        ($frame_rate_scale = $f->new_scale(
                -orient       => 'horizontal',
                -from         => 1,
                -to           => $frame_rate_max,
                -variable     => \$frame_rate_tmp,
                -resolution   => 1,
                -length       => 150,
                -width        => 10,
                -sliderlength => 20,
                -takefocus    => 1,
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w');
        $f->new_label(
                -text   => "frames/sec",
                -anchor => 'w',
                -font   => 'default',
                )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'sw');

        $frame_rate_max = ($ext eq '.gif') ? 10 : 60;
        $frame_rate_tmp = &max(1, &min($frame_rate_tmp, $frame_rate_max));
        $frame_rate_scale->configure(-to => $frame_rate_max);

        $row++;
        $f->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "",
                -font     => 'default',
                -variable => \$del_frames_tmp,
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text   => "Delete frame images after creating video",
                -anchor => 'w',
                -font   => 'default',
                )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

        if ($revisit) {
            $sfac_scale->configure(-state => 'disabled');
            $frame_start_scale->configure(-state => 'disabled');
            $frame_end_scale->configure(-state => 'disabled');
        }
    }

    $f->g_grid_columnconfigure(2, -weight => 3);
    $f->g_grid_columnconfigure(3, -weight => 2);

    Tkx::wm_resizable($scale_output_menu,0,0);
    &adjust_window_position($scale_output_menu);
    $scale_output_menu->g_focus;
}


sub make_anim_frames {
    my ($scalefac, $anim_file, $frame_start, $frame_end, $frame_rate, $delete_frames) = @_;
    my (
        $answer, $b, $base_file, $code, $date_label, $eps_file, $fh, $fmt,
        $fr, $frame_delay, $g, $gif_frames, $geom, $gif_delay, $id, $n, $nf,
        $pbar, $pbar_frame, $pbar_img, $pbar_window, $png_file, $png_height,
        $png_width, $ps_add, $psdata, $r, $rnum, $stop_processing, $w,
        $X, $Y,

        @cmd_args, @imgs,
       );

#   Determine the format of the animation file.
    ($fmt = lc($anim_file)) =~ s/.*\.(.*)$/$1/;

#   Apply scale factor to the frame size and set up the Ghostscript command.
    $png_width  = &round_to_int($canvas_width  *$scalefac /100);
    $png_height = &round_to_int($canvas_height *$scalefac /100);
    @cmd_args = ($GS_PROG, "-dSAFER", "-dQUIET", "-sDEVICE=png16m", "-dGraphicsAlphaBits=2",
                 "-dTextAlphaBits=4", "-g${png_width}x${png_height}");
    if ( $^O =~ /MSWin32/i ) {
        push (@cmd_args, "-sFONTPATH=C:\\Windows\\Fonts");
    }

#   Set a base file name.
    $rnum      = &get_random_number();
    $base_file = "tmp_" . $rnum . "_";
    if ($use_temp) {
        $base_file = $temp_dir . '/' . $base_file;
        if ( $^O =~ /MSWin32/i ) { $base_file =~ s/\//\\/; }
    }
    $w = int(log10($frame_end)) +1;

#   Generate PS code to fill the background with the canvas color.
    $code    = &get_rgb_code($canvas_color);
    $r       = &hex2decimal(substr($code,1,2)) /255.;   # as a fraction between 0 and 1
    $g       = &hex2decimal(substr($code,3,2)) /255.;
    $b       = &hex2decimal(substr($code,5,2)) /255.;
    $ps_add  = "3 1 moveto\n";
    $ps_add .= sprintf("%d 1 lineto\n", $canvas_width +2);
    $ps_add .= sprintf("%d %d lineto\n", $canvas_width +2, $canvas_height);
    $ps_add .= sprintf("3 %d lineto\n", $canvas_height);
    $ps_add .= "3 1 lineto\n";
    $ps_add .= sprintf("%5.3f %5.3f %5.3f setrgbcolor AdjustColor\n", $r, $g, $b);
    $ps_add .= "fill\ngrestore\ngsave\n";

#   Create a progress bar with a cancel button.
    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $geom = sprintf("+%d+%d", $X+$canvas_width/2-200, $Y+$canvas_height/2);

    $pbar_window = $main->new_toplevel();
    $pbar_window->g_wm_transient($main);
    $pbar_window->g_wm_title("Making animation frames...");
    $pbar_window->g_wm_geometry($geom);
    $pbar_window->configure(-cursor => $cursor_wait);
    $pbar_window->g_focus;
    $pbar_window->g_bind('<Destroy>' => sub { $stop_processing = 1;
                                              $status_line = "Processing stopped.";
                                              $pbar_window->g_grab_release();
                                              $pbar_window->g_bind('<Destroy>' => "");
                                              Tkx::update_idletasks();
                                            });
    $pbar_frame = $pbar_window->new_frame(
                    -borderwidth => 2,
                    -relief      => 'groove');
    $pbar_frame->g_pack(-anchor => 'nw', -expand => 1, -fill => 'x');
    ($pbar = $pbar_frame->new_ttk__progressbar(
                    -orient  => 'horizontal',
                    -length  => 350,
                    -mode    => 'determinate',
                    -value   => 0,
                    -maximum => $frame_end -$frame_start +1,
                    ))->g_pack(-side => 'left');
    $pbar_frame->new_button(
                    -text    => "Cancel",
                    -font    => 'default',
                    -cursor  => $cursor_select,
                    -command => sub { $stop_processing = 1;
                                      $status_line = "Processing stopped.";
                                      Tkx::update_idletasks();
                                    },
                    )->g_pack(-side => 'right');

#   End any current selection.
    &end_select($canvas, $old_id) if (defined($old_id));

#   Prepare the application to appear busy.
    $status_line = "Creating frames for animation export.  Please wait...";
    $canvas->configure(-cursor => $cursor_wait);
    $main->configure(-cursor => $cursor_wait);
    $pbar_window->g_focus;
    $pbar_window->g_grab_set();
    Tkx::update();
    Tkx::wm_resizable($pbar_window,0,0);

#   Loop over the frames of the animation.
    $stop_processing = 0;
    $delay_autosave  = 1;
    for ($fr=$frame_start; $fr<=$frame_end; $fr++) {
        last if ($stop_processing);
        $dti = $fr;
        $date_label = &get_formatted_date($dates[$dti-1]);
        &update_animate($date_label);
        $dti_old = $fr;

        $png_file = $base_file . sprintf("%0${w}d", $fr -$frame_start +1) . ".png";
        $eps_file = $base_file . sprintf("%0${w}d", $fr -$frame_start +1) . ".eps";

        $psdata = $canvas->postscript(-x => 3, -y => 3,
                                      -width      => $canvas_width,  -pagex => 0,
                                      -height     => $canvas_height, -pagey => 0,
                                      -pageanchor => 'sw',
                                      -pagewidth  => $png_width);

#       Swap "fill" for "eofill" commands
#       $psdata =~ s/eofill/fill/g;

#       Because of a bug in the canvas postscript method, need to redefine the scalefont function
#       Otherwise, all of the text will be too small
        $psdata =~ s/\%\%EndProlog/\/scalefont \{$pixels_per_pt mul scalefont\} bind def\n\%\%EndProlog/;

#       Fill the background with the canvas color.  Add code after "closepath clip newpath\ngsave"
        $psdata =~ s/closepath clip newpath\ngsave\n/closepath clip newpath\ngsave\n$ps_add/;

        open ($fh, ">", $eps_file)
                    || return &stop_and_reset(1, $pbar_window, $delete_frames, $base_file,
                                              "Unable to open temporary file:\n $eps_file");
        print $fh $psdata;
        close ($fh) || return &stop_and_reset(1, $pbar_window, $delete_frames, $base_file,
                                              "Trouble closing EPS file:\n $eps_file");

#       Break out each term of the command line to avoid problems with spaces in PATHs
        system(@cmd_args, "-o", $png_file, $eps_file);
        unlink $eps_file;

#       Update the progress bar
        $pbar_window->g_wm_title(sprintf("Making animation frames... %d of %d",
                                         $fr -$frame_start +1, $frame_end -$frame_start +1));
        $pbar->configure(-value => $fr -$frame_start +1);
        Tkx::update();
    }

#   Make the video file
    if (! $stop_processing) {
        if ($fmt eq "gif") {
            $status_line = "Reading frames of animation.  Please wait...";
            $pbar_window->g_wm_title("Reading image frames...");
            $pbar->configure(-value => 0);
            Tkx::update_idletasks();

            @imgs = ();
            $n = 0;
            foreach $png_file (glob "${base_file}*.png") {
                $imgs[$n] = Imager->new;
                $imgs[$n]->read(file => $png_file)
                           or return &stop_and_reset(1, $pbar_window, $delete_frames, $base_file,
                                                     "Problem reading temporary image file\n"
                                                     . " $imgs[$n]->errstr");
                $n++;
                $pbar->configure(-value => $n);
                Tkx::update();
            }
            $pbar_window->g_wm_title("Exporting video file...");
            $status_line = "Exporting video file $anim_file.  Please wait...";
            Tkx::update_idletasks();
            $gif_delay = &round_to_int(100.0 /$frame_rate);
            Imager->write_multi({ file          => $anim_file,
                                  type          => $fmt,
                                  translate     => 'giflib',
                                  max_colors    => 256,
                                  gif_local_map => 1,
                                  gif_delay     => $gif_delay,
                                }, @imgs)
                           or return &stop_and_reset(1, $pbar_window, $delete_frames, $base_file,
                                                     "Problem writing GIF file");
        } else {
#           Modify the progress bar
            $nf          =  0;
            $gif_frames  = 80;
            $frame_delay = 20;
            $pbar_img = Tkx::image_create_photo(-file   => "${prog_path}images/pbar.gif",
                                                -format => "gif -index $nf");
            $pbar_img = Tkx::widget->new($pbar_img);
            $pbar->g_pack_forget();
            ($pbar = $pbar_frame->new_label(-image => $pbar_img,
                                           ))->g_pack(-side => 'left');
            undef $bg_proc if (defined($bg_proc));
            $delay_frame_id = Tkx::after($frame_delay,
                                         [\&next_gif_frame, $pbar_img, $nf, $gif_frames, $frame_delay]);

            $status_line = "Exporting video file $anim_file.  Please wait...";
            $pbar_window->g_wm_title("Exporting video file...");
            Tkx::update();

#           FFmpeg options:
#             -hide_banner      Do not print banner message
#             -y                Overwrite output files without asking
#             -loglevel quiet   Do not print log messages
#             -framerate X      Specify frame rate of X frames per second
#             -i file_%03d.png  Input files of the form "file_000.png"
#             -c:v codelib      Use the "codelib" encoder library (e.g., mpeg4, flv1, libx265)
#
#             -force_key_frames expr:gte(t,n_forced*5)  will force a key frame every 5 seconds

            @cmd_args = ($FFmpeg_PROG, "-hide_banner", "-y", "-loglevel", "quiet",
                         "-framerate", $frame_rate, "-i", "${base_file}\%0${w}d\.png");
            if ($fmt eq "avi") {
                push (@cmd_args, "-c:v", "mpeg4", "-qscale:v", "5", "-vtag", "xvid", $anim_file);

            } elsif ($fmt eq "flv") {
                push (@cmd_args, "-c:v", "flv1", "-qscale:v", "5", $anim_file);

            } elsif ($fmt eq "mov") {
                push (@cmd_args, "-c:v", "libx265", "-x265-params", "log-level=quiet",
                                                    "-crf", "28", $anim_file);

            } elsif ($fmt eq "mp4") {
                push (@cmd_args, "-c:v", "libx265", "-x265-params", "log-level=quiet",
                                                    "-crf", "28", "-tag:v", "hvc1", $anim_file);
            }

#           Run the process in the background
            $bg_proc = Proc::Background->new({ autodie => 1,
                                               command => \@cmd_args,
                                             });

#           Update the screen while the process runs
            while ($bg_proc->alive) {
                Tkx::update();
            }
            foreach $id (Tkx::SplitList(Tkx::after_info())) {
                Tkx::after_cancel($id) if ($id eq $delay_frame_id);
            }
        }
    }
    $delay_autosave = 0;

#   Remove progress bar and unset the busy status.
    if (defined($pbar_window) && Tkx::winfo_exists($pbar_window)) {
        $pbar_window->g_grab_release();
        $pbar_window->g_bind('<Destroy>' => "");
        $pbar_window->g_destroy();
    }
    $canvas->configure(-cursor => $cursor_norm);
    $main->configure(-cursor => $cursor_norm);
    if ($stop_processing) {
        if (defined($bg_proc) && $bg_proc->alive) {
            $bg_proc->terminate;
        }
        undef $bg_proc if (defined($bg_proc));
    } else {
        $status_line = "Export completed.";
    }

#   Remove image files, if requested.
    if ($delete_frames) {
        unlink glob "${base_file}*.png" || return &pop_up_error($main,
                                                                "Unable to remove image files:\n $!");
    } else {
        $answer = &pop_up_question($main, "Do you want to make another video file\n"
                                        . "using the same series of images, but\n"
                                        . "with a different format or frame rate?");
        if (lc($answer) eq "yes") {
            return &scale_output("Animation", $rnum);
        }
    }
}


sub make_animation {
    my ($rnum, $anim_file, $nframes, $frame_rate, $delete_frames) = @_;
    my (
        $answer, $base_file, $fmt, $frame_delay, $geom, $gif_delay,
        $gif_frames, $id, $n, $nf, $pbar, $pbar_frame, $pbar_img,
        $pbar_window, $png_file, $w, $X, $Y,

        @cmd_args, @imgs,
       );

#   Determine the format of the animation file.
    ($fmt = lc($anim_file)) =~ s/.*\.(.*)$/$1/;

#   Set parameters to identify frame files.
    $base_file = "tmp_" . $rnum . "_";
    if ($use_temp) {
        $base_file = $temp_dir . '/' . $base_file;
        if ( $^O =~ /MSWin32/i ) { $base_file =~ s/\//\\/; }
    }
    $w = int(log10($nframes)) +1;

#   Set up an indeterminate progress bar.
    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $geom = sprintf("+%d+%d", $X+$canvas_width/2-200, $Y+$canvas_height/2);

    $pbar_window = $main->new_toplevel();
    $pbar_window->g_wm_transient($main);
    $pbar_window->g_wm_geometry($geom);
    $pbar_window->configure(-cursor => $cursor_wait);

    $pbar_frame = $pbar_window->new_frame(
                    -borderwidth => 2,
                    -relief      => 'groove');
    $pbar_frame->g_pack(-anchor => 'nw', -expand => 1, -fill => 'x');

#   Make the video file.
    $delay_autosave = 1;
    if ($fmt eq "gif") {
        ($pbar = $pbar_frame->new_ttk__progressbar(
                        -orient  => 'horizontal',
                        -length  => 350,
                        -mode    => 'determinate',
                        -value   => 0,
                        -maximum => $nframes,
                        ))->g_pack(-side => 'left');

#       Give the program a busy status.
        $status_line = "Reading frames of animation.  Please wait...";
        $pbar_window->g_wm_title("Reading image frames...");
        $pbar_window->g_focus;
        Tkx::tk_busy_hold($main, -cursor => $cursor_wait);
        Tkx::update();
        Tkx::wm_resizable($pbar_window,0,0);

        @imgs = ();
        $n = 0;
        foreach $png_file (glob "${base_file}*.png") {
            $imgs[$n] = Imager->new;
            $imgs[$n]->read(file => $png_file)
                       or return &stop_and_reset(0, "", $delete_frames, $base_file,
                                                 "Problem reading temporary image file\n"
                                                 . " $imgs[$n]->errstr");
            $n++;
            $pbar->configure(-value => $n);
            Tkx::update_idletasks();
        }
        $pbar_window->g_wm_title("Exporting video file...");
        $status_line = "Exporting video file $anim_file.  Please wait...";
        Tkx::update_idletasks();
        $gif_delay = &round_to_int(100.0 /$frame_rate);
        Imager->write_multi({ file          => $anim_file,
                              type          => $fmt,
                              translate     => 'giflib',
                              max_colors    => 256,
                              gif_local_map => 1,
                              gif_delay     => $gif_delay,
                            }, @imgs)
                       or return &stop_and_reset(0, "", $delete_frames, $base_file,
                                                 "Problem writing GIF file");
    } else {
        $nf          =  0;
        $gif_frames  = 80;
        $frame_delay = 20;
        $pbar_img = Tkx::image_create_photo(-file   => "${prog_path}images/pbar.gif",
                                            -format => "gif -index $nf");
        $pbar_img = Tkx::widget->new($pbar_img);
        ($pbar = $pbar_frame->new_label(-image => $pbar_img,
                                       ))->g_pack(-side => 'left');
        undef $bg_proc if (defined($bg_proc));
        $delay_frame_id = Tkx::after($frame_delay,
                                     [\&next_gif_frame, $pbar_img, $nf, $gif_frames, $frame_delay]);

#       Give the program a busy status.
        $status_line = "Exporting video file $anim_file.  Please wait...";
        $pbar_window->g_wm_title("Exporting video file...");
        $pbar_window->g_focus;
        Tkx::tk_busy_hold($main, -cursor => $cursor_wait);
        Tkx::update();
        Tkx::wm_resizable($pbar_window,0,0);

#       FFmpeg options:
#         -hide_banner      Do not print banner message
#         -y                Overwrite output files without asking
#         -loglevel quiet   Do not print log messages
#         -framerate X      Specify frame rate of X frames per second
#         -i file_%03d.png  Input files of the form "file_000.png"
#         -c:v codelib      Use the "codelib" encoder library (e.g., mpeg4, flv1, libx265)
#
#         -force_key_frames expr:gte(t,n_forced*5)  will force a key frame every 5 seconds

        @cmd_args = ($FFmpeg_PROG, "-hide_banner", "-y", "-loglevel", "quiet",
                     "-framerate", $frame_rate, "-i", "${base_file}\%0${w}d\.png");
        if ($fmt eq "avi") {
            push (@cmd_args, "-c:v", "mpeg4", "-qscale:v", "5", "-vtag", "xvid", $anim_file);

        } elsif ($fmt eq "flv") {
            push (@cmd_args, "-c:v", "flv1", "-qscale:v", "5", $anim_file);

        } elsif ($fmt eq "mov") {
            push (@cmd_args, "-c:v", "libx265", "-x265-params", "log-level=quiet",
                                                "-crf", "28", $anim_file);

        } elsif ($fmt eq "mp4") {
            push (@cmd_args, "-c:v", "libx265", "-x265-params", "log-level=quiet",
                                                "-crf", "28", "-tag:v", "hvc1", $anim_file);
        }

#       Run the process in the background
        $bg_proc = Proc::Background->new({ autodie => 1,
                                           command => \@cmd_args,
                                         });

#       Update the screen while the process runs
        while ($bg_proc->alive) {
            Tkx::update();
        }
        foreach $id (Tkx::SplitList(Tkx::after_info())) {
            Tkx::after_cancel($id) if ($id eq $delay_frame_id);
        }
    }
    $delay_autosave = 0;

#   Remove progress window and unset the busy status.
    $pbar_window->g_destroy();
    Tkx::tk_busy_forget($main);
    $status_line = "Export completed.";
    Tkx::update_idletasks();

#   Remove image files, if requested.
    if ($delete_frames) {
        unlink glob "${base_file}*.png" || return &pop_up_error($main,
                                                                "Unable to remove image files:\n $!");
    } else {
        $answer = &pop_up_question($main, "Do you want to make another video file\n"
                                        . "using the same series of images, but\n"
                                        . "with a different format or frame rate?");
        if (lc($answer) eq "yes") {
            return &scale_output("Animation", $rnum);
        }
    }
}


sub next_gif_frame {
    my ($img, $nf, $gif_frames, $frame_delay) = @_;

    return if (defined($bg_proc) && ! $bg_proc->alive);
    $nf = ($nf < $gif_frames-1) ? $nf+1 : 0;
    $img->configure(-format => "gif -index $nf");
    $delay_frame_id = Tkx::after($frame_delay, [\&next_gif_frame, $img, $nf, $gif_frames, $frame_delay]);
}


sub stop_and_reset {
    my ($grab, $grab_window, $delete_frames, $base_file, $msg) = @_;

    if ($grab) {
        $grab_window->g_grab_release();
        $grab_window->g_bind('<Destroy>' => "");
        $grab_window->g_destroy();
        $canvas->configure(-cursor => $cursor_norm);
        $main->configure(-cursor => $cursor_norm);
    } else {
        Tkx::tk_busy_forget($main);
    }
    $status_line    = "Processing stopped.";
    $delay_autosave = 0;
    Tkx::update_idletasks();

    if ($msg ne "") {
        if ($delete_frames) {
            unlink glob "${base_file}*.png" || do { $msg .= "\nUnable to remove image files:\n $!"; };
        }
        return &pop_up_error($main, $msg);
    } elsif ($delete_frames) {
        unlink glob "${base_file}*.png" || return &pop_up_error($main, "Unable to remove image files:\n $!");
    }
}


################################################################################
#
# Window-related routines
#
################################################################################

sub footer {
    my ($window, $which) = @_;
    my ($frame, $geom, $label, $bgcolor, $r, $g, $b);

    $frame = $window->new_tk__frame(
                          -relief      => 'groove',
                          -borderwidth => 2,
                          );
    $frame->g_pack(-side => 'bottom', -fill => 'x');
    if ($which eq "main") {
        $frame->new_label(
                    -textvariable => \$status_line,
                    -justify      => 'left',
                    -font         => 'default',
                    )->g_pack(-side => 'left');
        Tkx::update();
        $geom = $frame->g_winfo_geometry();
        (undef, $main_footer_height, undef, undef) = split(/x|\+/, $geom);
    } else {
        $frame->new_label(
                    -textvariable => \$link_status{$window},
                    -justify      => 'left',
                    -font         => 'default',
                    )->g_pack(-side => 'left');
    }
    $label = $frame->new_label(
                -text       => "v" . $version,
                -justify    => 'right',
                -font       => 'default',
                );
    $label->g_pack(-side => 'right');
    $bgcolor = $label->cget(-background);
    ($r, $g, $b) = Tkx::SplitList(Tkx::winfo_rgb($window, $bgcolor));
    $bgcolor = &get_rgb_name(sprintf("#%02X%02X%02X", $r/256, $g/256, $b/256));
    return $bgcolor;
}


sub configure_helper_apps {
    my (
        $f, $FFmpeg_file_btn, $FFmpeg_frame, $FFmpeg_label, $FFmpeg_PROG_tmp,
        $FFmpeg_scan_btn, $frame, $geom, $GS_file_btn, $GS_frame, $GS_label,
        $GS_PROG_tmp, $GS_scan_btn, $initialdir, $initialfile, $ok_btn,
        $row, $temp_dir_tmp, $temp_file_btn, $temp_frame, $temp_label,
        $use_FFmpeg_tmp, $use_GS_tmp, $use_temp_tmp, $X, $Y,
       );

    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $geom = sprintf("+%d+%d", $X+70, $Y+60);

    if (defined($configure_helper_menu) && Tkx::winfo_exists($configure_helper_menu)) {
        if ($configure_helper_menu->g_wm_title() eq "Configure Helper Apps") {
            $configure_helper_menu->g_destroy();
            undef $configure_helper_menu;
        }
    }
    $configure_helper_menu = $main->new_toplevel();
    $configure_helper_menu->g_wm_transient($main);
    $configure_helper_menu->g_wm_title("Configure Helper Apps");
    $configure_helper_menu->configure(-cursor => $cursor_norm);
    $configure_helper_menu->g_wm_geometry($geom);

    $GS_PROG_tmp     = $GS_PROG;
    $FFmpeg_PROG_tmp = $FFmpeg_PROG;
    $temp_dir_tmp    = $temp_dir;
    $use_GS_tmp      = $use_GS;
    $use_FFmpeg_tmp  = $use_FFmpeg;
    $use_temp_tmp    = $use_temp;

    $frame = $configure_helper_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -state   => 'disabled',
            -command => sub { my ($i, $success);
                              if ($use_GS_tmp && ($GS_PROG_tmp eq "" || ! -e $GS_PROG_tmp)) {
                                  return &pop_up_error($configure_helper_menu,
                                  "Ghostscript program file not set or does not exist:\n$GS_PROG_tmp");
                              }
                              if ($use_FFmpeg_tmp && ($FFmpeg_PROG_tmp eq "" || ! -e $FFmpeg_PROG_tmp)) {
                                  return &pop_up_error($configure_helper_menu,
                                  "FFmpeg program file not set or does not exist:\n$FFmpeg_PROG_tmp");
                              }
                              if ($use_temp_tmp) {
                                  if ($temp_dir_tmp eq "" || ! -e $temp_dir_tmp || ! -d $temp_dir_tmp) {
                                      return &pop_up_error($configure_helper_menu,
                                      "Temporary directory not set or does not exist:\n$temp_dir_tmp");
                                  }
                                  if (! -r $temp_dir_tmp || ! -w $temp_dir_tmp) {
                                      return &pop_up_error($configure_helper_menu,
                                      "Temporary directory not readable or writeable:\n$temp_dir_tmp");
                                  }
                              }
                              $use_GS     = $use_GS_tmp;
                              $use_FFmpeg = $use_FFmpeg_tmp;
                              $use_temp   = $use_temp_tmp;
                              if ($use_GS) {
                                  $GS_PROG = $GS_PROG_tmp;
                                  $export_menu->entryconfigure(1, -state => 'normal');
                                  $export_menu->entryconfigure(2, -state => 'normal');
                                  for ($i=0; $i<=$#animate_ids; $i++) {
                                      if ($props{$animate_ids[$i]}{meta}
                              =~ /^(data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)$/) {
                                          $export_menu->entryconfigure(3, -state => 'normal');
                                          last;
                                      }
                                  }
                              } else {
                                  $export_menu->entryconfigure(1, -state => 'disabled');
                                  $export_menu->entryconfigure(2, -state => 'disabled');
                                  $export_menu->entryconfigure(3, -state => 'disabled');
                              }
                              if ($use_FFmpeg) {
                                  $FFmpeg_PROG = $FFmpeg_PROG_tmp;
                              }
                              if (! $use_temp) {
                                  $temp_dir_tmp = File::Spec->rel2abs(abs_path(), $prog_path);
                                  $success = opendir($dir_handle, $temp_dir_tmp);
                                  if ($success) {
                                      while (defined($dir_entry = readdir($dir_handle))) {
                                          next if (! -d $dir_entry);
                                          next if (! -r $dir_entry || ! -w $dir_entry);
                                          if (lc($dir_entry) eq "tmp") {
                                              $temp_dir_tmp = File::Spec->rel2abs($dir_entry, $temp_dir_tmp);
                                              last;
                                          } elsif (lc($dir_entry) eq "temp") {
                                              $temp_dir_tmp = File::Spec->rel2abs($dir_entry, $temp_dir_tmp);
                                              last;
                                          }
                                      }
                                      closedir($dir_handle);
                                  }
                              }
                              if ($temp_dir_tmp ne $temp_dir) {
                                  &reassign_autosave_files($temp_dir_tmp);
                                  $temp_dir = $temp_dir_tmp;
                              }
                              $configure_helper_menu->g_destroy();
                              undef $configure_helper_menu;
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $configure_helper_menu->g_destroy();
                              undef $configure_helper_menu;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

    $f = $configure_helper_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f->g_pack(-side => 'top');

    ($GS_frame = $f->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_pack(-side => 'top', -fill => 'x', -expand => 1);
    ($FFmpeg_frame = $f->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_pack(-side => 'top', -fill => 'x', -expand => 1, -pady => 1);
    ($temp_frame = $f->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_pack(-side => 'top', -fill => 'x', -expand => 1, -pady => 1);

    $row = 0;
    $GS_frame->new_checkbutton(
            -onvalue  => 1,
            -offvalue => 0,
            -text     => "Use Ghostscript for PDF and raster output",
            -font     => 'default',
            -variable => \$use_GS_tmp,
            -command  => sub { if ($use_GS_tmp) {
                                   $GS_label->configure(-state => 'normal');
                                   $GS_scan_btn->configure(-state => 'normal');
                                   $GS_file_btn->configure(-state => 'normal');
                                   if ($GS_PROG_tmp ne "" && -e $GS_PROG_tmp) {
                                       $ok_btn->configure(-state => 'normal');
                                   } else {
                                       $ok_btn->configure(-state => 'disabled');
                                   }
                               } else {
                                   $GS_label->configure(-state => 'disabled');
                                   $GS_scan_btn->configure(-state => 'disabled');
                                   $GS_file_btn->configure(-state => 'disabled');
                                   $ok_btn->configure(-state => 'normal');
                               }
                               if ($use_FFmpeg_tmp) {
                                   if ($FFmpeg_PROG_tmp eq "" || ! -e $FFmpeg_PROG_tmp) {
                                       $ok_btn->configure(-state => 'disabled');
                                   }
                               }
                               if ($use_temp_tmp) {
                                   if ($temp_dir_tmp eq "" || ! -e $temp_dir_tmp
                                                           || ! -d $temp_dir_tmp) {
                                       $ok_btn->configure(-state => 'disabled');
                                   }
                               }
                             },
            )->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'w');

    $row++;
    $GS_frame->new_label(
            -text => "Program Location: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    ($GS_label = $GS_frame->new_label(
            -textvariable => \$GS_PROG_tmp,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'ew');
    ($GS_scan_btn = $GS_frame->new_button(
            -text    => "Scan",
            -command => sub { my ($cancelled);
                              $geom = $configure_helper_menu->g_wm_geometry();
                              (undef, $X, $Y) = split(/\+/, $geom);
                              $cancelled = &helper_autosearch($X, $Y, "GS");
                              if (! $cancelled) {
                                  $GS_scan_btn->configure(-state => 'disabled');
                              }
                            },
            ))->g_grid(-row => $row, -column => 2, -sticky => 'ew', -padx => 2);
    ($GS_file_btn = $GS_frame->new_button(
            -text    => "Browse",
            -command => sub { my ($file);
                              if ( $^O =~ /MSWin32/i ) {
                                  if ($GS_PROG_tmp ne "" && -e $GS_PROG_tmp) {
                                      ($initialdir  = $GS_PROG_tmp) =~ s/^(.*)\\.*/$1/;
                                      ($initialfile = $GS_PROG_tmp) =~ s/^.*\\(.*)/$1/;
                                      $file = Tkx::tk___getOpenFile(
                                              -parent           => $configure_helper_menu,
                                              -title            => "Ghostscript Program File",
                                              -defaultextension => ".exe",
                                              -initialdir       => $initialdir,
                                              -initialfile      => $initialfile,
                                              -filetypes => [ ['Executable Files', '.exe'],
                                                              ['All Files',  '*'],
                                                            ],
                                              );
                                  } else {
                                      if (-e 'C:\Program Files') {
                                          $initialdir = 'C:\Program Files';
                                      } else {
                                          $initialdir = abs_path();
                                      }
                                      $file = Tkx::tk___getOpenFile(
                                              -parent           => $configure_helper_menu,
                                              -title            => "Ghostscript Program File",
                                              -initialdir       => $initialdir,
                                              -defaultextension => ".exe",
                                              -filetypes => [ ['Executable Files', '.exe'],
                                                              ['All Files',  '*'],
                                                            ],
                                              );
                                  }
                              } else {
                                  if ($GS_PROG_tmp ne "" && -e $GS_PROG_tmp) {
                                      ($initialdir  = $GS_PROG_tmp) =~ s/^(.*)\/.*/$1/;
                                      ($initialfile = $GS_PROG_tmp) =~ s/^.*\/(.*)/$1/;
                                      $file = Tkx::tk___getOpenFile(
                                              -parent      => $configure_helper_menu,
                                              -title       => "Ghostscript Program File",
                                              -initialdir  => $initialdir,
                                              -initialfile => $initialfile,
                                              -filetypes   => [ ['All Files',  '*'],
                                                              ],
                                              );
                                  } else {
                                      if (-e '/usr/bin') {
                                          $initialdir = '/usr/bin';
                                      } else {
                                          $initialdir = abs_path();
                                      }
                                      $file = Tkx::tk___getOpenFile(
                                              -parent     => $configure_helper_menu,
                                              -title      => "Ghostscript Program File",
                                              -initialdir => $initialdir,
                                              -filetypes  => [ ['All Files',  '*'],
                                                             ],
                                              );
                                  }
                              }
                              if (defined($file) && -e $file) {
                                  $GS_PROG_tmp = File::Spec->rel2abs($file, $prog_path);
                                  $ok_btn->configure(-state => 'normal');
                                  if ($use_FFmpeg_tmp) {
                                      if ($FFmpeg_PROG_tmp eq "" || ! -e $FFmpeg_PROG_tmp) {
                                          $ok_btn->configure(-state => 'disabled');
                                      }
                                  }
                                  if ($use_temp_tmp) {
                                      if ($temp_dir_tmp eq "" || ! -e $temp_dir_tmp
                                                              || ! -d $temp_dir_tmp) {
                                          $ok_btn->configure(-state => 'disabled');
                                      }
                                  }
                              } else {
                                  $ok_btn->configure(-state => 'disabled');
                              }
                            },
            ))->g_grid(-row => $row, -column => 3, -sticky => 'ew', -padx => 2);
    if (! $use_GS_tmp) {
        $GS_label->configure(-state => 'disabled');
        $GS_scan_btn->configure(-state => 'disabled');
        $GS_file_btn->configure(-state => 'disabled');
    }

    $row = 0;
    $FFmpeg_frame->new_checkbutton(
            -onvalue  => 1,
            -offvalue => 0,
            -text     => "Use FFmpeg for animation file creation",
            -font     => 'default',
            -variable => \$use_FFmpeg_tmp,
            -command  => sub { if ($use_FFmpeg_tmp) {
                                   $FFmpeg_label->configure(-state => 'normal');
                                   $FFmpeg_scan_btn->configure(-state => 'normal');
                                   $FFmpeg_file_btn->configure(-state => 'normal');
                                   if ($FFmpeg_PROG_tmp ne "" && -e $FFmpeg_PROG_tmp) {
                                       $ok_btn->configure(-state => 'normal');
                                   } else {
                                       $ok_btn->configure(-state => 'disabled');
                                   }
                               } else {
                                   $FFmpeg_label->configure(-state => 'disabled');
                                   $FFmpeg_scan_btn->configure(-state => 'disabled');
                                   $FFmpeg_file_btn->configure(-state => 'disabled');
                                   $ok_btn->configure(-state => 'normal');
                               }
                               if ($use_GS_tmp) {
                                   if ($GS_PROG_tmp eq "" || ! -e $GS_PROG_tmp) {
                                       $ok_btn->configure(-state => 'disabled');
                                   }
                               }
                               if ($use_temp_tmp) {
                                   if ($temp_dir_tmp eq "" || ! -e $temp_dir_tmp
                                                           || ! -d $temp_dir_tmp) {
                                       $ok_btn->configure(-state => 'disabled');
                                   }
                               }
                             },
            )->g_grid(-row => $row, -column => 0, -columnspan => 4, -sticky => 'w');

    $row++;
    $FFmpeg_frame->new_label(
            -text => "Program Location: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    ($FFmpeg_label = $FFmpeg_frame->new_label(
            -textvariable => \$FFmpeg_PROG_tmp,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'ew');
    ($FFmpeg_scan_btn = $FFmpeg_frame->new_button(
            -text    => "Scan",
            -command => sub { my ($cancelled);
                              $geom = $configure_helper_menu->g_wm_geometry();
                              (undef, $X, $Y) = split(/\+/, $geom);
                              $cancelled = &helper_autosearch($X, $Y, "FFmpeg");
                              if (! $cancelled) {
                                  $FFmpeg_scan_btn->configure(-state => 'disabled');
                              }
                            },
            ))->g_grid(-row => $row, -column => 2, -sticky => 'ew', -padx => 2);
    ($FFmpeg_file_btn = $FFmpeg_frame->new_button(
            -text    => "Browse",
            -command => sub { my ($file);
                              if ( $^O =~ /MSWin32/i ) {
                                  if ($FFmpeg_PROG_tmp ne "" && -e $FFmpeg_PROG_tmp) {
                                      ($initialdir  = $FFmpeg_PROG_tmp) =~ s/^(.*)\\.*/$1/;
                                      ($initialfile = $FFmpeg_PROG_tmp) =~ s/^.*\\(.*)/$1/;
                                      $file = Tkx::tk___getOpenFile(
                                              -parent           => $configure_helper_menu,
                                              -title            => "FFmpeg Program File",
                                              -defaultextension => ".exe",
                                              -initialdir       => $initialdir,
                                              -initialfile      => $initialfile,
                                              -filetypes => [ ['Executable Files', '.exe'],
                                                              ['All Files',  '*'],
                                                            ],
                                              );
                                  } else {
                                      if (-e 'C:\Program Files') {
                                          $initialdir = 'C:\Program Files';
                                      } else {
                                          $initialdir = abs_path();
                                      }
                                      $file = Tkx::tk___getOpenFile(
                                              -parent           => $configure_helper_menu,
                                              -title            => "FFmpeg Program File",
                                              -initialdir       => $initialdir,
                                              -defaultextension => ".exe",
                                              -filetypes => [ ['Executable Files', '.exe'],
                                                              ['All Files',  '*'],
                                                            ],
                                              );
                                  }
                              } else {
                                  if ($FFmpeg_PROG_tmp ne "" && -e $FFmpeg_PROG_tmp) {
                                      ($initialdir  = $FFmpeg_PROG_tmp) =~ s/^(.*)\/.*/$1/;
                                      ($initialfile = $FFmpeg_PROG_tmp) =~ s/^.*\/(.*)/$1/;
                                      $file = Tkx::tk___getOpenFile(
                                              -parent      => $configure_helper_menu,
                                              -title       => "FFmpeg Program File",
                                              -initialdir  => $initialdir,
                                              -initialfile => $initialfile,
                                              -filetypes   => [ ['All Files',  '*'],
                                                              ],
                                              );
                                  } else {
                                      if (-e '/usr/bin') {
                                          $initialdir = '/usr/bin';
                                      } else {
                                          $initialdir = abs_path();
                                      }
                                      $file = Tkx::tk___getOpenFile(
                                              -parent     => $configure_helper_menu,
                                              -title      => "FFmpeg Program File",
                                              -initialdir => $initialdir,
                                              -filetypes  => [ ['All Files',  '*'],
                                                             ],
                                              );
                                  }
                              }
                              if (defined($file) && -e $file) {
                                  $FFmpeg_PROG_tmp = File::Spec->rel2abs($file, $prog_path);
                                  $ok_btn->configure(-state => 'normal');
                                  if ($use_GS_tmp) {
                                      if ($GS_PROG_tmp eq "" || ! -e $GS_PROG_tmp) {
                                          $ok_btn->configure(-state => 'disabled');
                                      }
                                  }
                                  if ($use_temp_tmp) {
                                      if ($temp_dir_tmp eq "" || ! -e $temp_dir_tmp
                                                              || ! -d $temp_dir_tmp) {
                                          $ok_btn->configure(-state => 'disabled');
                                      }
                                  }
                              } else {
                                  $ok_btn->configure(-state => 'disabled');
                              }
                            },
            ))->g_grid(-row => $row, -column => 3, -sticky => 'ew', -padx => 2);
    if (! $use_FFmpeg_tmp) {
        $FFmpeg_label->configure(-state => 'disabled');
        $FFmpeg_scan_btn->configure(-state => 'disabled');
        $FFmpeg_file_btn->configure(-state => 'disabled');
    }

    $row = 0;
    $temp_frame->new_checkbutton(
            -onvalue  => 1,
            -offvalue => 0,
            -text     => "Use a specific directory for temporary files",
            -font     => 'default',
            -variable => \$use_temp_tmp,
            -command  => sub { if ($use_temp_tmp) {
                                   $temp_label->configure(-state => 'normal');
                                   $temp_file_btn->configure(-state => 'normal');
                                   if ($temp_dir_tmp ne "" && -e $temp_dir_tmp
                                                           && -d $temp_dir_tmp) {
                                       $ok_btn->configure(-state => 'normal');
                                   } else {
                                       $ok_btn->configure(-state => 'disabled');
                                   }
                               } else {
                                   $temp_label->configure(-state => 'disabled');
                                   $temp_file_btn->configure(-state => 'disabled');
                                   $ok_btn->configure(-state => 'normal');
                               }
                               if ($use_GS_tmp) {
                                   if ($GS_PROG_tmp eq "" || ! -e $GS_PROG_tmp) {
                                       $ok_btn->configure(-state => 'disabled');
                                   }
                               }
                               if ($use_FFmpeg_tmp) {
                                   if ($FFmpeg_PROG_tmp eq "" || ! -e $FFmpeg_PROG_tmp) {
                                       $ok_btn->configure(-state => 'disabled');
                                   }
                               }
                             },
            )->g_grid(-row => $row, -column => 0, -columnspan => 4, -sticky => 'w');

    $row++;
    $temp_frame->new_label(
            -text => "Temp directory: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    ($temp_label = $temp_frame->new_label(
            -textvariable => \$temp_dir_tmp,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'ew');
    ($temp_file_btn = $temp_frame->new_button(
            -text    => "Browse",
            -command => sub { my ($dir);
                              if ($temp_dir_tmp ne "" && -e $temp_dir_tmp
                                                      && -d $temp_dir_tmp) {
                                  $dir = Tkx::tk___chooseDirectory(
                                          -parent     => $configure_helper_menu,
                                          -title      => "Directory for Temporary Files",
                                          -initialdir => $temp_dir_tmp,
                                          );
                              } else {
                                  $dir = Tkx::tk___chooseDirectory(
                                          -parent     => $configure_helper_menu,
                                          -title      => "Directory for Temporary Files",
                                          -initialdir => abs_path(),
                                          );
                              }
                              if (defined($dir) && $dir ne "" && ! -e $dir) {
                                  mkdir( $dir ) or 
                                      return &pop_up_error($main,
                                                  "Failed to create temporary directory:\n  $dir");
                              }
                              if (defined($dir) && -e $dir && -d $dir) {
                                  $temp_dir_tmp = File::Spec->rel2abs($dir, $prog_path);
                                  $ok_btn->configure(-state => 'normal');
                                  if ($use_GS_tmp) {
                                      if ($GS_PROG_tmp eq "" || ! -e $GS_PROG_tmp) {
                                          $ok_btn->configure(-state => 'disabled');
                                      }
                                  }
                                  if ($use_FFmpeg_tmp) {
                                      if ($FFmpeg_PROG_tmp eq "" || ! -e $FFmpeg_PROG_tmp) {
                                          $ok_btn->configure(-state => 'disabled');
                                      }
                                  }
                              } else {
                                  $ok_btn->configure(-state => 'disabled');
                              }
                            },
            ))->g_grid(-row => $row, -column => 3, -sticky => 'ew', -padx => 2);
    if (! $use_temp_tmp) {
        $temp_label->configure(-state => 'disabled');
        $temp_file_btn->configure(-state => 'disabled');
    }

    $GS_frame->g_grid_columnconfigure(1, -weight => 2);
    $FFmpeg_frame->g_grid_columnconfigure(1, -weight => 2);
    $temp_frame->g_grid_columnconfigure(1, -weight => 2);

    Tkx::wm_resizable($configure_helper_menu,0,0);
    &adjust_window_position($configure_helper_menu);
    $configure_helper_menu->g_focus;
}


sub helper_prog_notice {
    my ($frame, $geom, $msg, $warn_img, $X, $Y);

    if ( $^O =~ /MSWin32/i ) {
        if (! $use_GS && $GS_PROG eq "" && ! $use_FFmpeg && $FFmpeg_PROG eq "") {
            $msg = "Unable to find the Ghostscript and FFmpeg helper programs.\n"
                 . "Use the Help/Configure menu to specify their locations.\n\n"
                 . "Ghostscript:\n"
                 . "Looking for the \"gswin64c.exe\" or \"gswin32c.exe\" program.\n"
                 . "Already searched under:\n"
                 . "  C:\\Program Files\\gs\n"
                 . "  C:\\Program Files\\Ghostscript\n"
                 . "  C:\\Program Files (x86)\\gs\n"
                 . "  C:\\Program Files (x86)\\Ghostscript\n\n"
                 . "FFmpeg:\n"
                 . "Looking for the \"ffmpeg.exe\" program.\n"
                 . "Already searched under:\n"
                 . "  C:\\Program Files\\FFmpeg\n"
                 . "  C:\\Program Files (x86)\\FFmpeg";
        } elsif (! $use_GS && $GS_PROG eq "") {
            $msg = "Unable to find the Ghostscript helper program.\n"
                 . "Use the Help/Configure menu to specify its location.\n\n"
                 . "Looking for the \"gswin64c.exe\" or \"gswin32c.exe\" program.\n"
                 . "Already searched under:\n"
                 . "  C:\\Program Files\\gs\n"
                 . "  C:\\Program Files\\Ghostscript\n"
                 . "  C:\\Program Files (x86)\\gs\n"
                 . "  C:\\Program Files (x86)\\Ghostscript";
        } elsif (! $use_FFmpeg && $FFmpeg_PROG eq "") {
            $msg = "Unable to find the FFmpeg helper program.\n"
                 . "Use the Help/Configure menu to specify its location.\n\n"
                 . "Looking for the \"ffmpeg.exe\" program.\n"
                 . "Already searched under:\n"
                 . "  C:\\Program Files\\FFmpeg\n"
                 . "  C:\\Program Files (x86)\\FFmpeg";
        }
    } else {
        if (! $use_GS && $GS_PROG eq "" && ! $use_FFmpeg && $FFmpeg_PROG eq "") {
            $msg = "Unable to find the Ghostscript and FFmpeg helper programs.\n"
                 . "Use the Help/Configure menu to specify their locations.\n\n"
                 . "Ghostscript:\n"
                 . "Looking for the \"gs\" program.\n"
                 . "Already searched under:\n"
                 . "  /usr/bin\n"
                 . "  /usr/local/bin\n"
                 . "  /bin\n\n"
                 . "FFmpeg:\n"
                 . "Looking for the \"ffmpeg\" program.\n"
                 . "Already searched under:\n"
                 . "  /usr/bin\n"
                 . "  /usr/local/bin\n"
                 . "  /bin";
        } elsif (! $use_GS && $GS_PROG eq "") {
            $msg = "Unable to find the Ghostscript helper program.\n"
                 . "Use the Help/Configure menu to specify its location.\n\n"
                 . "Looking for the \"gs\" program.\n"
                 . "Already searched under:\n"
                 . "  /usr/bin\n"
                 . "  /usr/local/bin\n"
                 . "  /bin";
        } elsif (! $use_FFmpeg && $FFmpeg_PROG eq "") {
            $msg = "Unable to find the FFmpeg helper program.\n"
                 . "Use the Help/Configure menu to specify its location.\n\n"
                 . "Looking for the \"ffmpeg\" program.\n"
                 . "Already searched under:\n"
                 . "  /usr/bin\n"
                 . "  /usr/local/bin\n"
                 . "  /bin";
        }
    }

#   Make an information window. Not using pop_up_info() because that takes control.
    if (defined($helper_note_win) && Tkx::winfo_exists($helper_note_win)) {
        if ($helper_note_win->g_wm_title() eq "Helper Program Problem") {
            $helper_note_win->g_destroy();
            undef $helper_note_win;
        }
    }

    Tkx::update_idletasks();
    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $geom = sprintf("+%d+%d", $X+100, $Y+90);

    $helper_note_win = $main->new_toplevel();
    $helper_note_win->g_wm_transient($main);
    $helper_note_win->g_wm_title("Helper Program Problem");
    $helper_note_win->configure(-cursor => $cursor_norm);
    $helper_note_win->g_wm_geometry($geom);

    ($frame = $helper_note_win->new_frame(
                  -borderwidth => 1,
                  -relief      => 'groove',
                  -background  => 'white',
                  ))->g_pack(-side => 'top', -expand => 1, -fill => 'both');

    if ( $^O =~ /MSWin32/i ) {   # If Windows, offer an automated search
        $msg .= "\n\nTry Auto Search, but it may take a few minutes.";
        $frame->new_button(
                      -text       => "Auto Search",
                      -background => '#F2F2F2',
                      -command    => sub { $geom = $helper_note_win->g_wm_geometry();
                                           (undef, $X, $Y) = split(/\+/, $geom);
                                           $helper_note_win->g_destroy();
                                           undef $helper_note_win;
                                           &helper_autosearch($X, $Y); },
                      )->g_grid(-row => 1, -column => 1, -sticky => 'e', -pady => 4);
    }
    $warn_img = Tkx::image_create_photo(-file => "${prog_path}images/warn.png");
    $frame->new_label(
                  -image      => $warn_img,
                  -background => 'white',
                  )->g_grid(-row => 0, -column => 0, -sticky => 'nw', -padx => 5, -pady => 2);
    $frame->new_label(
                  -text       => $msg,
                  -font       => 'default',
                  -background => 'white',
                  -justify    => 'left',
                  )->g_grid(-row => 0, -column => 1, -columnspan => 2, -sticky => 'nw', -pady => 4);
    $frame->new_button(
                  -text       => "OK",
                  -background => '#F2F2F2',
                  -command    => sub { $helper_note_win->g_destroy();
                                       undef $helper_note_win; },
                  )->g_grid(-row => 1, -column => 2, -sticky => 'e', -padx => 8, -pady => 4);

    $frame->g_grid_columnconfigure(1, -weight => 2);

    Tkx::wm_resizable($helper_note_win,0,0);
    &adjust_window_position($helper_note_win);
    $helper_note_win->g_focus;
}


sub helper_autosearch {
    my ($X, $Y, $which) = @_;
    my (
        $cancel, $cancel_btn, $dh, $dir, $dir_tree, $entry, $file, $frame,
        $geom, $msg, $ok_btn, $old_FFmpeg_PROG, $old_GS_PROG, $search_FFmpeg,
        $search_GS, $search_img,

        @dir_list2,
       );

    $which           = "" if (! defined($which));
    $geom            = sprintf("+%d+%d", $X, $Y);
    $cancel          = 0;
    $msg             = "";
    $old_GS_PROG     = $GS_PROG;
    $old_FFmpeg_PROG = $FFmpeg_PROG;
    $search_GS       = 0;
    $search_FFmpeg   = 0;

    if ($which eq "GS") {
        $search_GS     = 1;
        $search_FFmpeg = 0;
    } elsif ($which eq "FFmpeg") {
        $search_GS     = 0;
        $search_FFmpeg = 1;
    } else {
        $search_GS     = (! $GS_off     && $GS_PROG     eq "") ? 1 : 0;
        $search_FFmpeg = (! $FFmpeg_off && $FFmpeg_PROG eq "") ? 1 : 0;
    }
    $GS_PROG         = "" if ($search_GS);
    $FFmpeg_PROG     = "" if ($search_FFmpeg);

    if (defined($helper_search_win) && Tkx::winfo_exists($helper_search_win)) {
        if ($helper_search_win->g_wm_title() eq "Helper Program AutoSearch") {
            $helper_search_win->g_destroy();
            undef $helper_search_win;
        }
    }
    $helper_search_win = $main->new_toplevel();
    $helper_search_win->g_wm_transient($main);
    $helper_search_win->g_wm_title("Helper Program AutoSearch");
    $helper_search_win->configure(-cursor => $cursor_norm);
    $helper_search_win->g_wm_geometry($geom);

    ($frame = $helper_search_win->new_frame(
                  -borderwidth => 1,
                  -relief      => 'groove',
                  -background  => 'white',
                  ))->g_pack(-side => 'top', -expand => 1, -fill => 'both');

    $search_img = Tkx::image_create_photo(-file => "${prog_path}images/search.png");
    $frame->new_label(
                  -image      => $search_img,
                  -background => 'white',
                  )->g_grid(-row => 0, -column => 0, -sticky => 'nw', -padx => 2);
    $frame->new_label(
                  -textvariable => \$msg,
                  -font         => 'default',
                  -background   => 'white',
                  -width        => 80,
                  -anchor       => 'w',
                  )->g_grid(-row => 0, -column => 1, -sticky => 'w', -pady => 4);
    ($cancel_btn = $frame->new_button(
                  -text       => "Cancel",
                  -background => '#F2F2F2',
                  -state      => 'normal',
                  -command    => sub { $cancel = 1; },
                  ))->g_grid(-row => 0, -column => 2, -padx => 2, -pady => 4);
    ($ok_btn = $frame->new_button(
                  -text       => "OK",
                  -background => '#F2F2F2',
                  -state      => 'disabled',
                  -command    => sub { $helper_search_win->g_destroy();
                                       undef $helper_search_win; },
                  ))->g_grid(-row => 0, -column => 3, -padx => 8, -pady => 4);

    $frame->g_grid_columnconfigure(1, -weight => 2);
    Tkx::wm_resizable($helper_search_win,0,0);
#   &adjust_window_position($helper_search_win);
    $helper_search_win->g_focus;
    Tkx::update();

    {   local $SIG{__WARN__} = sub { warn @_  unless $_[0] =~ /^Can't opendir/; };
        @search_dirs = @dir_list2 = ();
        $dir = 'C:\Program Files';
        if (-e $dir && -r $dir) {
            opendir($dh, $dir) or &pop_up_error($main, "Failed to read directory:\n $dir");
            while (readdir($dh)) {
                next if ($_ eq "." || $_ eq ".." || $_ =~ /^Uninstall/i);
                $entry = File::Spec->rel2abs($_, $dir);
                if (-d $entry && -r $entry) {
                    if ($_ !~ /^Adobe/i && $_ !~ /^Microsoft/i && $_ !~ /^Windows/i && $_ !~ /^DearMob/i) {
                        push (@search_dirs, $entry);
                    } else {
                        push (@dir_list2, $entry);
                    }
                }
            }
            closedir($dh);
        }
        $dir = 'C:\Program Files (x86)';
        if (-e $dir && -r $dir) {
            opendir($dh, $dir) or &pop_up_error($main, "Failed to read directory:\n $dir");
            while (readdir($dh)) {
                next if ($_ eq "." || $_ eq ".." || $_ =~ /^Uninstall/i);
                $entry = File::Spec->rel2abs($_, $dir);
                if (-d $entry && -r $entry) {
                    if ($_ !~ /^Adobe/i && $_ !~ /^Microsoft/i && $_ !~ /^Windows/i && $_ !~ /^DearMob/i) {
                        push (@search_dirs, $entry);
                    } else {
                        push (@dir_list2, $entry);
                    }
                }
            }
            closedir($dh);
        }
        push (@search_dirs, @dir_list2) if ($#dir_list2 >= 0);

        if ($#search_dirs >= 0) {
            if ($FileFindObject) {
                $dir_tree = File::Find::Object->new({}, @search_dirs);
                while ($file = $dir_tree->next()) {
                    ($dir = $file) =~ s/(.*)[\/\\][^\/\\]+$/$1/;
                    if ($dir ne $msg) {
                        if (length($dir) > 90) {
                            $dir = substr($dir,0,50) . "..." . substr($dir,-40);
                        }
                        if ($dir ne $msg) {
                            $msg = $dir;
                            Tkx::update();
                        }
                    }
                    if ($search_GS) {
                        if ($file =~ /gswin\d\dc\.exe$/) {
                            $GS_PROG = $file;
                            last if (! $search_FFmpeg);
                        }
                    }
                    if ($search_FFmpeg) {
                        if ($file =~ /ffmpeg\.exe$/) {
                            $FFmpeg_PROG = $file;
                            last if (! $search_GS);
                        }
                    }
                    last if ($search_GS && $GS_PROG ne "" && $search_FFmpeg && $FFmpeg_PROG ne "");
                    last if ($cancel);
                }
            } else {
                foreach $search_dir (@search_dirs) {
                    find( { wanted => sub { $dir = $File::Find::dir;
                                            if ($dir ne $msg) {
                                                if (length($dir) > 90) {
                                                    $dir = substr($dir,0,50) . "..." . substr($dir,-40);
                                                }
                                                if ($dir ne $msg) {
                                                    $msg = $dir;
                                                    Tkx::update();
                                                }
                                            }
                                            if ($search_GS) {
                                                if ($_ =~ /gswin\d\dc\.exe$/) {
                                                    ($GS_PROG = $File::Find::name) =~ s/\//\\/g;
                                                }
                                            }
                                            if ($search_FFmpeg) {
                                                if ($_ =~ /ffmpeg\.exe$/) {
                                                    ($FFmpeg_PROG = $File::Find::name) =~ s/\//\\/g;
                                                }
                                            }
                                          },
                            no_chdir => 1 }, $search_dir);
                    $GS_PROG     = "" if ($search_GS     && $GS_PROG     !~ /gswin\d\dc\.exe$/);
                    $FFmpeg_PROG = "" if ($search_FFmpeg && $FFmpeg_PROG !~ /ffmpeg\.exe$/);
                    last if ($search_GS     && $GS_PROG     ne "" && ! $search_FFmpeg);
                    last if ($search_FFmpeg && $FFmpeg_PROG ne "" && ! $search_GS);
                    last if ($search_GS     && $GS_PROG     ne "" &&
                             $search_FFmpeg && $FFmpeg_PROG ne "");
                    last if ($cancel);
                }
            }
            $msg = "";
            if ($cancel) {
                $cancel_btn->configure(-state => 'disabled');
                $ok_btn->configure(-state => 'normal');
                $msg = "Search cancelled.";
                return $cancel;
            }
            if ($search_GS) {
                if ($GS_PROG =~ /gswin\d\dc\.exe$/) {
                    $use_GS  = 1;
                    $msg     = "Found Ghostscript.";
                } else {
                    if ($old_GS_PROG ne "" && -e $old_GS_PROG && ! -d $old_GS_PROG) {
                        $use_GS  = 1 if (! $GS_off);
                        $GS_PROG = $old_GS_PROG;
                    } else {
                        $use_GS  = 0;
                        $GS_PROG = "";
                    }
                    $msg = "Failed to find Ghostscript.";
                }
            }
            if ($search_FFmpeg) {
                $msg .= "  " if ($msg ne "");
                if ($FFmpeg_PROG =~ /ffmpeg\.exe$/) {
                    $use_FFmpeg  = 1;
                    $msg        .= "Found FFmpeg.";
                } else {
                    if ($old_FFmpeg_PROG ne "" && -e $old_FFmpeg_PROG && ! -d $old_FFmpeg_PROG) {
                        $use_FFmpeg  = 1 if (! $FFmpeg_off);
                        $FFmpeg_PROG = $old_FFmpeg_PROG;
                    } else {
                        $use_FFmpeg  = 0;
                        $FFmpeg_PROG = "";
                    }
                    $msg .= "Failed to find FFmpeg.";
                }
            }
            if ($msg =~ /Found/) {
                $msg .= "  Confirm with Help/Configure menu." if ($which eq "");
                if (defined($configure_helper_menu) && Tkx::winfo_exists($configure_helper_menu)) {
                    if ($configure_helper_menu->g_wm_title() eq "Configure Helper Apps") {
                        $configure_helper_menu->g_destroy();
                        undef $configure_helper_menu;
                    }
                }
                &configure_helper_apps;
                Tkx::after_idle(sub {Tkx::after(100, sub {$helper_search_win->g_raise();
                                                          $helper_search_win->g_focus;
                                                         });});
            }
        } else {
            $msg = 'Cannot search C:\Program Files or C:\Program Files (x86)';
        }
        $cancel_btn->configure(-state => 'disabled');
        $ok_btn->configure(-state => 'normal');
    }
}


sub support {
    my ($geom, $tw, $X, $Y);

    if (defined($support_window) && Tkx::winfo_exists($support_window)) {
        if ($support_window->g_wm_title() eq "W2 Animator Support") {
            $support_window->g_wm_deiconify();
            $support_window->g_raise();
            $support_window->g_focus;
            &adjust_window_position($support_window);
            return;
        }
    }

    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $geom = sprintf("+%d+%d", $X+70, $Y+60);

    $support_window = $main->new_toplevel();
    $support_window->g_wm_transient($main);
    $support_window->g_wm_title("W2 Animator Support");
    $support_window->g_wm_minsize(350,200);
    $support_window->configure(-cursor => $cursor_norm);
    $support_window->g_wm_geometry($geom);

    &footer($support_window, "support_window");

    $tw = $support_window->new_tkx_Scrolled('tkx_ROText',
            -width       => 91,
            -height      => 36,
            -relief      => 'flat',
            -font        => 'default',
            -cursor      => $cursor_norm,
            -background  => &get_rgb_code($background_color),
            -wrap        => 'word',
            -scrollbars  => 'oe',
            -insertwidth => 0,
            );
    $tw->g_pack(-fill => 'both', -expand => 1);

    &parse($tw, "
      <h1>W2Anim Support</h1>

      <h3>Updates</h3>

      <p>The latest release of The W2 Animator can be found on GitHub at
      <a href=\"https://github.com/sarounds/w2anim/releases/latest\">https://github.com/sarounds/w2anim/releases/latest</a>.</p>

      <h3>Documentation</h3>

      <p>Documentation for The W2 Animator is available in the form of a
      User Manual, available
      <a href=\"https://github.com/sarounds/w2anim/blob/main/src/user_manual/W2Anim_manual.pdf\">online</a>
      and in the W2Anim download package.  The manual will be updated as
      new features are added.</p>

      <h3>Questions and Bug Reports</h3>

      <p>If you have questions or wish to report a problem with The W2
      Animator, feel free to send me an email at
      <a href=\"mailto:roundsstewart\@gmail.com?subject=W2Anim\">roundsstewart\@gmail.com</a>.
      I will try to respond in a timely manner.  Alternatively, you can
      ask questions or report problems directly on the GitHub page for
      The W2 Animator at
      <a href=\"https://github.com/sarounds/w2anim\">https://github.com/sarounds/w2anim</a>.</p>

      <h3>Supporting W2 Tool Development</h3>

      <p>The W2 Animator is free and open-source software to assist anyone
      who uses the CE-QUAL-W2 water-quality model.  The W2 Animator
      may be redistributed and/or modified under the terms of the
      <a href=\"https://www.gnu.org/licenses/gpl.html\">GNU General Public
      License</a> as published by the Free Software Foundation, either
      version 3 of the License or (at your option) any later version.</p>

      <p>Developing The W2 Animator as a data visualization tool has been
      a hobby and obsession, and I am happy to make it available for free
      to the W2 user community.  Although this software is absolutely free
      of charge, it is my hope that some users of The W2 Animator, perhaps
      particularly those who may be using it as part of a business, will
      choose to independently support higher education in some fashion.
      Two worthy funds that might be considered are:<br>

      <ul>
        <li>The <i>CE-QUAL-W2 Model Development Fund (\#8610011)</i> at the
            <a href=\"https://giving.psuf.org/\">Portland State University
            Foundation</a>, and</li>
        <li>The <i>Stewart Rounds &amp; Bernadine Bonn Scholarship Fund</i>
            at the <a href=\"https://give.fororegonstate.org/\">Oregon
            State University Foundation</a>.</li>
      </ul></p>
      ");
    &adjust_window_position($support_window);
    $support_window->g_focus;
}


sub about {
    my ($geom, $tw, $X, $Y);

    if (defined($about_window) && Tkx::winfo_exists($about_window)) {
        if ($about_window->g_wm_title() eq "About the W2 Animator") {
            $about_window->g_wm_deiconify();
            $about_window->g_raise();
            $about_window->g_focus;
            &adjust_window_position($about_window);
            return;
        }
    }

    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $geom = sprintf("+%d+%d", $X+70, $Y+60);

    $about_window = $main->new_toplevel();
    $about_window->g_wm_transient($main);
    $about_window->g_wm_title("About the W2 Animator");
    $about_window->g_wm_minsize(350,200);
    $about_window->configure(-cursor => $cursor_norm);
    $about_window->g_wm_geometry($geom);

    $tw = $about_window->new_tkx_Scrolled('tkx_ROText',
            -width       => 59,
            -height      => 26,
            -relief      => 'flat',
            -font        => 'default',
            -cursor      => $cursor_norm,
            -background  => &get_rgb_code($background_color),
            -wrap        => 'word',
            -scrollbars  => 'oe',
            -insertwidth => 0,
            );
    $tw->g_pack(-fill => 'both', -expand => 1);

    &parse($tw, "
      <h1>The W2 Animator</h1>
      <p><b>Version:</b> $version
      <br><b>Author:</b> Stewart A. Rounds &lt;roundsstewart\@gmail.com&gt;
      <br>Copyright (c) 2022-2025</p>
      <p>The W2 Animator was developed as a free tool for anyone
      who uses the CE-QUAL-W2 water-quality model.  Although I used
      CE-QUAL-W2 in my work at the U.S. Geological Survey, this tool
      was created on my own time and with my own resources.  I offer it
      to the water-quality modeling community at no charge.  <b>Send me
      an <a href=\"mailto:roundsstewart\@gmail.com?subject=W2Anim\">email</a> if you
      like it!</b></p>
      <p>The W2 Animator was written in Perl with the Tcl/Tk toolkit
      and is free software; you may redistribute it and/or modify it
      under the terms of the GNU General Public License as published by
      the Free Software Foundation, either version 3 of the License or
      (at your option) any later version.</p>
      <p>This program is distributed in the hope that it will be
      useful, but WITHOUT ANY WARRANTY; without even the implied
      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
      See the GNU General Public License for more details:</p>
      <p><img src=\"${prog_path}images/gplv3.gif\" width=88 height=31> GNU
      <a href=\"https://www.gnu.org/licenses/gpl.html\">General Public License</a>.</p>
      ");
    &adjust_window_position($about_window);
    $about_window->g_focus;
}
