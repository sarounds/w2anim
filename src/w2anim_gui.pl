############################################################################
#
#  W2 Animator
#  Perl Tcl/Tk Interface
#  Copyright (c) 2022-2024, Stewart A. Rounds
#
#  Contact:
#    Stewart A. Rounds
#    roundsstewart@gmail.com
#
#  This program is free software; you may redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation, either version 3
#  of the License or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
############################################################################

#
# Organization of this source file:
#
# The first part of the code sets up some shared variables and creates
# the GUI's main window, the drawing canvas, the main menus, and finishes
# up with the main event loop.
#
# After the main code, a number of subroutines are provided in groups:
#  Menu group:
#    confirm_exit
#    make_menubar
#    prepare_to
#    popup_menu
#    edit_pts_menu
#
#  General-purpose routines:
#    read_ini_file
#    write_ini_file
#    adjust_main_position
#    adjust_window_position
#    initialize_canvas_scrollbars
#    manage_canvas_scrollbars
#    update_canvas_scrollbars
#    update_scrollable_menu
#    update_scrollable_tab
#    get_xy
#    show_xypos
#    make_crosshair
#    find_rect_from_text_or_image
#    get_coords
#    get_group_type
#    numeric_entry_only
#    reset_bindings
#    altp_popup
#    start_anew
#    remove_and_restore_menus
#    create_progress_bar
#    update_progress_bar
#    reset_progress_bar
#    destroy_progress_bar
#    create_alt_progress_bar
#    update_alt_progress_bar
#
#  Object drawing, movement, rotation, and manipulation:
#    draw
#    start_drawing
#    begin_resize
#    size_rde  (rectangle, diamond, ellipse)
#    size_poly
#    size_object
#    next_pt
#    add_pt
#    begin_move_pt
#    move_pt
#    delete_pt
#    edit_add_pt
#    exit_edit_pts
#    end_poly
#    end_drawing
#    forget_drawing
#    forget_resize
#    begin_move
#    move_object
#    move_selected
#    end_move_object
#    forget_move_object
#    begin_rotate
#    rotate_object
#    end_rotate_object
#    forget_rotate_object
#    align_objects
#    flip_object
#    raise_lower
#    begin_edit
#    duplicate
#    object_kill
#
#  Image placement and rotation:
#    draw_image
#    end_place_image
#    begin_resize_image
#    size_image
#    end_resize_image
#    revert_image
#    forget_resize_image
#    flip_image
#    begin_crop_image
#    highlight_crop_pt
#    adjust_crop
#    crop_image
#    uncrop_image
#    forget_crop_image
#    begin_rotate_image
#    rotate_image
#    end_rotate_image
#    forget_rotate_image
#
#  Object selection:
#    object_select
#    add_selection
#    group_items
#    ungroup_items
#    show_group
#    group_kill
#    clear_selection_marks
#    clear_selection
#    begin_select_box
#    draw_select_box
#    end_select_box
#    select_item
#    end_select
#    show_points
#    highlight_pt
#    show_anchors
#    highlight_anchor
#    set_anchor
#    forget_set_anchor
#
#  Show or edit object properties:
#    edit_text_props
#    set_text_props
#    edit_object_props
#    set_object_props
#    preview_object_props
#    restore_object_props
#    edit_graph_props
#    update_graph_props
#    edit_link
#    set_link
#    update_links
#    edit_stat_link
#    set_stat_link
#    update_stat_link
#    forget_link
#    add_ts_link
#    set_ts_link
#    start_ts_graph
#    show_info
#    edit_canvas_props
#    set_canvas_props
#    edit_defaults
#    set_defaults
#    
#  Graph objects:
#    setup_w2_profile
#    change_w2_profile
#    make_w2_profile
#    setup_w2_slice_or_tdmap_or_wlevels
#    setup_w2_slice_part2
#    setup_w2_slice_part3
#    change_w2_slice
#    make_w2_slice
#    setup_w2_tdmap_part2
#    setup_w2_tdmap_part3
#    setup_w2_tdmap_parmdiff
#    setup_w2_tdmap_filediff
#    undo_w2_tdmap_diffs
#    reverse_w2_tdmap_diffs
#    change_w2_tdmap
#    make_w2_tdmap
#    swap_w2_tdmap_axes
#    setup_data_profile
#    make_data_profile
#    setup_wd_zone
#    make_wd_zone
#    generate_outflow_temps
#    make_bulkhead_graphic
#    setup_w2_outflow
#    setup_w2_outflow_part2
#    make_w2_outflow
#    setup_w2_wlevels_part2
#    setup_w2_wlevels_part3
#    make_w2_wlevels
#    make_ts_graph
#    add_ts_data
#    plot_ts_data
#    add_ts_graph
#    add_ref_data
#    plot_ref_profile
#
#  Statistics, differences, limits, and references:
#    convert_to_diffs
#    calculate_diffs
#    undo_diffs
#    find_data_limits
#    find_w2_profile_limits
#    find_w2_outflow_limits
#    find_w2_slice_limits
#    find_w2_tdmap_limits
#    find_w2_wlevel_limits
#    find_ts_limits
#    setup_ref_stats
#    show_ref_stats
#    choose_datasets
#    show_ts_stats
#
#  Standard graph parts:
#    make_axis
#    make_seg_axis
#    make_date_axis
#    find_axis_limits
#    make_color_key
#    make_ts_legend
#    update_legend_box
#
#  Date calculations:
#    rebuild_datelist
#    set_global_date_limits
#
#  Animation tools:
#    animate_toolbar
#    restore_btn
#    get_animation_date
#    update_animate
#
#  Zoom tools:
#    zoom_toolbar
#    begin_zoom_box
#    draw_zoom_box
#    end_zoom_box
#    zoom_in
#    zoom_in_X
#    zoom_in_Y
#    zoom_out
#    zoom_out_X
#    zoom_out_Y
#    zoom_full
#    zoom_full_X
#    zoom_full_Y
#
#  Open or save project files:
#    open_file
#    pop_up_error2
#    add_to_recent
#    clear_recent
#    autosave
#    reassign_autosave_files
#    compare_saved
#    save_file
#    print_canvas
#    scale_output
#    make_anim_frames
#    make_animation
#    next_gif_frame
#    stop_and_reset
#
#  Window-related routines:
#    footer
#    configure_helper_apps
#    helper_prog_notice
#    helper_autosearch
#    support
#    about
#

use strict;
use warnings;
use diagnostics;

#
# Use the Perl Tkx interface to the Tcl/Tk toolkit for the GUI.
# Use the Perl Imager module for image manipulations.
# Use the Perl Proc::Background module for running a process in the background.
#
use Tkx;
use Tkx::Scrolled;
use Tkx::ROText;
use Math::Trig 'pi';
use Time::HiRes 'usleep';
use Imager;
use File::Copy;
use File::Spec;
use File::Find;
use Cwd 'abs_path';
use Proc::Background;

#
# The File::Find::Object module might not be available on all Perl systems.
# If not, set a flag so that other algorithms can be used, but print a message.
#
my $FileFindObject = 1;
unless (eval "use File::Find::Object; 1") {
    $FileFindObject = 0;
    print "\nModule File::Find::Object not found.\nInstall with `cpanm File::Find::Object`\n";
}

#
# Use the Win32 Process module if it becomes necessary to spawn an internet
#  browser on a Windows system, if needed.  Win32 systems don't have a
#  properly working fork, so the Win32 calls are needed.
# Use the Win32::GUI module to minimize or show the command prompt window.
#
if ( $^O =~ /MSWin32/i ) {
    require Win32::Process;
    use Win32::GUI;
}

#
# Set aside some global variables that can be shared with other source files.
#
our (
     $background_color, $cursor_norm, $default_size, $have_symbol_font,
     $load_w2a, $main, $pixels_per_pt, $prog_path, $version,

     @color_scheme_names, @color_scheme_names2, @conv_types, @days_in_month,
     @full_color_schemes, @mon_names, @tz_offsets, @valid_nc, @valid_nc_alt,

     %grid, %link_status,
    );

#
# Set aside some local variables.
#
my (

    $about_window, $add_ref_data_menu, $add_ts_data_menu,
    $add_ts_graph_menu, $add_ts_link_menu, $anchor_fill_color,
    $anchor_line_color, $anchor_select_color, $anim_tb_status, $animate_tb,
    $autosave_file, $autosave_file2, $autosave_id1, $autosave_id2,
    $autosave_interval, $autosave_menu, $bg_proc, $canvas, $canvas_color,
    $canvas_height, $canvas_props_menu, $canvas_width, $canvas_xscroll,
    $canvas_yscroll, $choose_sets_menu, $cmap_datemax, $cmap_datemin,
    $configure_helper_menu, $convert_diff_menu, $cursor_draw,
    $cursor_hand, $cursor_kill, $cursor_move, $cursor_select,
    $cursor_text, $cursor_wait, $date_limits_menu, $default_ahd1,
    $default_ahd2, $default_ahd3, $default_angle, $default_arrow,
    $default_canvas_color, $default_canvas_height, $default_canvas_width,
    $default_color, $default_family, $default_fill, $default_fillcolor,
    $default_grid_spacing, $default_props_menu, $default_slant,
    $default_smooth, $default_snap2grid, $default_text_select_color,
    $default_underline, $default_weight, $default_width, $delay,
    $delay_autosave, $delay_frame_id, $delete_frames, $dir_entry,
    $dir_handle, $dir_tree, $dti, $dti_max, $dti_old, $edit_link_menu,
    $edit_stat_link_menu, $export_menu, $FFmpeg_off, $FFmpeg_PROG,
    $file, $frame_end, $frame_rate, $frame_start, $global_dt_begin,
    $global_dt_end, $global_dt_limits, $graph_num, $graph_props_menu,
    $grid_spacing, $grid_spacing_max, $grid_spacing_min, $grprops_notebook,
    $GS_off, $GS_PROG, $helper_note_win, $helper_search_win, $icon_img,
    $ini_path, $main_footer_height, $main_frame, $max_canvas_height,
    $max_canvas_width, $max_main_height, $max_main_width, $min_canvas_height,
    $min_canvas_width, $move_delete_menu, $nconfig_events, $object_infobox,
    $object_props_menu, $old_id, $old_item, $popmenu, $pref_menu,
    $profile_setup_menu, $recent_menu, $ref_stats_interp_window,
    $ref_stats_menu, $ref_stats_window, $repeat_anim, $save_ahd1,
    $save_ahd2, $save_ahd3, $save_angle, $save_arrow, $save_color,
    $save_family, $save_fill, $save_fillcolor, $save_size, $save_slant,
    $save_smooth, $save_underline, $save_weight, $save_width, $savefile,
    $scale_output_menu, $scalefac, $screen_height, $screen_width,
    $search_dir, $snap2grid, $status_line, $support_window, $temp_dir,
    $text_props_menu, $text_select_color, $ts_datemax, $ts_datemin,
    $ts_stats_window, $undo_diff_menu, $use_FFmpeg, $use_GS, $use_temp,
    $w2a_dir, $w2a_error, $w2a_fh, $w2a_line, $w2a_vol, $w2levels_setup_menu,
    $w2profile_mod_menu, $w2profile_setup_menu, $w2outflow_setup_menu,
    $w2slice_mod_menu, $w2slice_setup_menu, $w2tdmap_diff_menu,
    $w2tdmap_mod_menu, $w2tdmap_rev_menu, $w2tdmap_setup_menu,
    $w2tdmap_undo_menu, $wdzone_setup_menu, $zoom_tb, $zoom_tip,

    @animate_ids, @arrow_options, @arrow_type, @available_fonts,
    @dates, @object_types, @search_dirs, @slant_options, @slant_type,
    @smooth_options, @smooth_type, @text_anchors,

    %anc_props, %gr_props, %link_props, %props, %pt_props,
   );

#
# Set the default mouse shapes.
#
$cursor_draw   = 'crosshair';
$cursor_hand   = 'hand2';
$cursor_kill   = 'pirate';
$cursor_move   = 'fleur';
$cursor_norm   = 'left_ptr';
$cursor_select = 'right_ptr';
$cursor_text   = 'xterm';
$cursor_wait   = 'watch';

#
# Create the main window.
#
$main = Tkx::widget->new(".");
$main->g_wm_title("W2 Animator");
$main->configure(-cursor => $cursor_norm);

#
# If a W2Anim project file was mentioned on the command line, get its path and go there.
#
if ($load_w2a =~ /.*\.w2a$/) {
    if (-e $load_w2a) {
        $load_w2a = File::Spec->rel2abs($load_w2a);
        ($w2a_vol, $w2a_dir, undef) = File::Spec->splitpath($load_w2a);
        chdir $w2a_vol . $w2a_dir;
        $w2a_error = 0;
    } else {
        $w2a_error = 1;
    }
}

#
# Set some defaults for text, drawing objects, autosave, and animations.
#
@object_types      = qw(text image line circle ellipse
                        rectangle diamond polygon polyline graph);
$default_size      = 10;
$default_weight    = "normal";
@slant_options     = ("normal", "italic");
@slant_type        = ("roman",  "italic");
$default_slant     = 0;
$default_underline = 0;
$default_angle     = 0;
$default_color     = "black";
$default_width     = 1;
$default_fill      = 0;
$default_fillcolor = "white";
@arrow_options     = ("none", "start", "end",  "both");
@arrow_type        = ("none", "first", "last", "both");
$default_arrow     = 0;
$default_ahd1      = 12;
$default_ahd2      = 15;
$default_ahd3      = 5;
@smooth_options    = ("standard", "rounded");
@smooth_type       = ("false",    "true");
$default_smooth    = 0;
$graph_num         = -1;
$savefile          = "";
$autosave_interval = -1;
$autosave_id1      = $autosave_id2 = $delay_frame_id = "";
$anim_tb_status    = "stopped";
$delay_autosave    = 0;
$repeat_anim       = 0;

$anchor_line_color   = "black";
$anchor_fill_color   = "cyan";
$anchor_select_color = "magenta";
@text_anchors        = qw(nw n ne e se s sw w center);
@animate_ids         = ();

#
# Get the available font list and a default font.
# Create some default fonts.  Determine whether the symbol font is available.
#
($default_family, $have_symbol_font, @available_fonts)
    = &create_fonts($main, $default_size);

#
# Try to find the helper programs:  Ghostscript and FFmpeg
# Ghostscript:  Under Windows, look for gswin64c.exe or gswin32c.exe
#               Under Linux, look for gs
# FFmpeg:  Look for ffmpeg.exe under Windows, and probably ffmpeg under Linux
#
# Default search directories:
#   Windows: 
#     Ghostscript:  C:\Program Files\gs
#                   C:\Program Files\Ghostscript
#                   C:\Program Files (x86)\gs
#                   C:\Program Files (x86)\Ghostscript
#     FFmpeg:       C:\Program Files\FFmpeg
#                   C:\Program Files (x86)\FFmpeg
#
#   Linux/other:
#     Ghostscript:  /usr/bin
#                   /usr/local/bin
#                   /bin
#     FFmpeg:       /usr/bin
#                   /usr/local/bin
#                   /bin
#
$GS_PROG = $FFmpeg_PROG = "";
$use_GS  = $use_FFmpeg  = 0;
$GS_off  = $FFmpeg_off  = 0;
if ( $^O =~ /MSWin32/i ) {
    {   local $SIG{__WARN__} = sub { warn @_  unless $_[0] =~ /^Can't opendir/; };
        @search_dirs = ();
        push (@search_dirs,'C:\Program Files\gs')                if (-e 'C:\Program Files\gs');
        push (@search_dirs,'C:\Program Files\Ghostscript')       if (-e 'C:\Program Files\Ghostscript');
        push (@search_dirs,'C:\Program Files (x86)\gs')          if (-e 'C:\Program Files (x86)\gs');
        push (@search_dirs,'C:\Program Files (x86)\Ghostscript') if (-e 'C:\Program Files (x86)\Ghostscript');
        if ($#search_dirs >= 0) {
            if ($FileFindObject) {
                $dir_tree = File::Find::Object->new({}, @search_dirs);
                while ($file = $dir_tree->next()) {
                    if ($file =~ /gswin\d\dc\.exe$/) {
                        $GS_PROG = $file;
                        last;
                    }
                }
            } else {
                foreach $search_dir (@search_dirs) {
                    find( { wanted => sub { if ($_ =~ /gswin\d\dc\.exe$/) {
                                              ($GS_PROG = $File::Find::name) =~ s/\//\\/g;
                                            }},
                            no_chdir => 1 }, $search_dir);
                    last if ($GS_PROG =~ /gswin\d\dc\.exe$/);
                    $GS_PROG = "";
                }
            }
        }
        @search_dirs = ();
        push (@search_dirs, 'C:\Program Files\FFmpeg')       if (-e 'C:\Program Files\FFmpeg');
        push (@search_dirs, 'C:\Program Files (x86)\FFmpeg') if (-e 'C:\Program Files (x86)\FFmpeg');
        if ($#search_dirs >= 0) {
            if ($FileFindObject) {
                $dir_tree = File::Find::Object->new({}, @search_dirs);
                while ($file = $dir_tree->next()) {
                    if ($file =~ /ffmpeg\.exe$/) {
                        $FFmpeg_PROG = $file;
                        last;
                    }
                }
            } else {
                foreach $search_dir (@search_dirs) {
                    find( { wanted => sub { if ($_ =~ /ffmpeg\.exe$/) {
                                              ($FFmpeg_PROG = $File::Find::name) =~ s/\//\\/g;
                                            }},
                            no_chdir => 1 }, $search_dir);
                    last if ($FFmpeg_PROG =~ /ffmpeg\.exe$/);
                    $FFmpeg_PROG = "";
                }
            }
        }
        undef @search_dirs;
    }
    if ($GS_PROG =~ /gswin\d\dc\.exe$/) {
        $use_GS  = 1;
    } else {
        $use_GS  = 0;
        $GS_PROG = "";
    }
    if ($FFmpeg_PROG =~ /ffmpeg\.exe$/) {
        $use_FFmpeg  = 1;
    } else {
        $use_FFmpeg  = 0;
        $FFmpeg_PROG = "";
    }

} else {
    {   local $SIG{__WARN__} = sub { warn @_  unless $_[0] =~ /^Can't opendir/; };
        @search_dirs = ();
        push (@search_dirs, '/usr/bin')       if (-e '/usr/bin');
        push (@search_dirs, '/usr/local/bin') if (-e '/usr/local/bin');
        push (@search_dirs, '/bin')           if (-e '/bin');
        if ($#search_dirs >= 0) {
            if ($FileFindObject) {
                $dir_tree = File::Find::Object->new({}, @search_dirs );
                while ($file = $dir_tree->next()) {
                    if ($GS_PROG eq "") {
                        $GS_PROG = $file if ($file =~ /gs$/);
                    }
                    if ($FFmpeg_PROG eq "") {
                        $FFmpeg_PROG = $file if ($file =~ /ffmpeg$/);
                    }
                    last if ($GS_PROG ne "" && $FFmpeg_PROG ne "");
                }
            } else {
                foreach $search_dir (@search_dirs) {
                    find( { wanted => sub { if ($_ =~ /gs$/) { $GS_PROG = $File::Find::name; }},
                            no_chdir => 1 }, $search_dir);
                    last if ($GS_PROG =~ /gs$/);
                    $GS_PROG = "";
                }
                foreach $search_dir (@search_dirs) {
                    find( { wanted => sub { if ($_ =~ /ffmpeg$/) { $FFmpeg_PROG = $File::Find::name; }},
                            no_chdir => 1 }, $search_dir);
                    last if ($FFmpeg_PROG =~ /ffmpeg$/);
                    $FFmpeg_PROG = "";
                }
            }
        }
        undef @search_dirs;
    }
    if ($GS_PROG =~ /gs$/) {
        $use_GS  = 1;
    } else {
        $use_GS  = 0;
        $GS_PROG = "";
    }
    if ($FFmpeg_PROG =~ /ffmpeg$/) {
        $use_FFmpeg  = 1;
    } else {
        $use_FFmpeg  = 0;
        $FFmpeg_PROG = "";
    }
}

#
# Set a default temporary directory as the current directory,
# or a subdirectory named tmp or temp
#
$use_temp = 1;
$temp_dir = File::Spec->rel2abs(abs_path(), $prog_path);
opendir($dir_handle, $temp_dir) or &pop_up_error($main,
                                    "Failed to read current directory:\n $temp_dir");
while (defined($dir_entry = readdir($dir_handle))) {
    next if (! -d $dir_entry);
    if (lc($dir_entry) eq "tmp") {
        $temp_dir = File::Spec->rel2abs($dir_entry, $temp_dir);
        last;
    } elsif (lc($dir_entry) eq "temp") {
        $temp_dir = File::Spec->rel2abs($dir_entry, $temp_dir);
        last;
    }
}
closedir($dir_handle);

#
# Set some canvas defaults and read the initialization file.
# The initialization file may redefine the temporary directory.
#
$canvas_width      = 600;
$canvas_height     = 450;
$canvas_color      = "white";
$text_select_color = "magenta";
$snap2grid         =   0;
$grid_spacing      =  10;
$ini_path          = $prog_path;
if (-e "w2anim.ini" && -r "w2anim.ini" && ! -z "w2anim.ini" && ! -d "w2anim.ini") {
    $ini_path = File::Spec->rel2abs(".");
    &read_ini_file("w2anim.ini");
} elsif (-e "${prog_path}w2anim.ini" && -r "${prog_path}w2anim.ini"
         && ! -z "${prog_path}w2anim.ini" && ! -d "${prog_path}w2anim.ini") {
    &read_ini_file("${prog_path}w2anim.ini");
}
$grid_spacing_min  =   2;
$grid_spacing_max  = 100;
$grid_spacing      = $grid_spacing_min if ($grid_spacing < $grid_spacing_min);
$grid_spacing      = $grid_spacing_max if ($grid_spacing > $grid_spacing_max);

#
# Set the name of the autosave files for this session. A unique random number is
# used to ensure that separate instances of W2Anim do not use the same files.
# Must do this after $temp_dir may be set in initialization file.
# Must reset these names if $temp_dir is reset later.
#
$autosave_file  = "_autosave" . &get_random_number() . ".w2a";
$autosave_file2 = "_autosave" . &get_random_number() . "_2.w2a";
$autosave_file  = File::Spec->rel2abs($autosave_file,  $temp_dir);
$autosave_file2 = File::Spec->rel2abs($autosave_file2, $temp_dir);

#
# Make the main menu bar.
#
&make_menubar($main);

#
# Create a footer for the main page.  Sets the main footer height.
#
$background_color = &footer($main, "main");

#
# Find the screen size.
# Revise the default canvas size and its limits based on screen size and footer height.
#
$screen_height     = Tkx::winfo_screenheight($main) -6 -3*$main_footer_height;
$screen_width      = Tkx::winfo_screenwidth($main)  -6;
$max_canvas_width  = &min(20000, $screen_width);
$max_canvas_height = &min(20000, $screen_height);
$min_canvas_width  = &min(200, $max_canvas_width);
$min_canvas_height = &min(150, $max_canvas_height);
$canvas_width      = $min_canvas_width  if ($canvas_width  < $min_canvas_width);
$canvas_height     = $min_canvas_height if ($canvas_height < $min_canvas_height);
$canvas_width      = 20000              if ($canvas_width  > 20000);
$canvas_height     = 20000              if ($canvas_height > 20000);
$max_canvas_width  = $canvas_width      if ($canvas_width  > $max_canvas_width);
$max_canvas_height = $canvas_height     if ($canvas_height > $max_canvas_height);
$pixels_per_pt     = Tkx::tk_scaling();
$scalefac          = 100;

#
# Save main default settings.
#
$default_canvas_width      = $canvas_width;
$default_canvas_height     = $canvas_height;
$default_canvas_color      = $canvas_color;
$default_text_select_color = $text_select_color;
$default_grid_spacing      = $grid_spacing;
$default_snap2grid         = $snap2grid;

$save_family    = $default_family;
$save_size      = $default_size;
$save_weight    = $default_weight;
$save_slant     = $default_slant;
$save_underline = $default_underline;
$save_angle     = $default_angle;
$save_width     = $default_width;
$save_color     = $default_color;
$save_smooth    = $default_smooth;
$save_fill      = $default_fill;
$save_fillcolor = $default_fillcolor;
$save_arrow     = $default_arrow;
$save_ahd1      = $default_ahd1;
$save_ahd2      = $default_ahd2;
$save_ahd3      = $default_ahd3;

#
# Create the canvas widget to hold the drawings.
# Add scrollbars that can be activated or inactivated later.
#
($main_frame = $main->new_frame(
          ))->g_pack(-anchor => 'nw', -expand => 1, -fill => 'both');
($canvas_xscroll = $main_frame->new_scrollbar(
          -orient => 'horizontal',
          -width  => 15,
          ))->g_grid(-row => 1, -column => 0, -sticky => 'ew');
($canvas_yscroll = $main_frame->new_scrollbar(
          -orient => 'vertical',
          -width  => 15,
          ))->g_grid(-row => 0, -column => 1, -sticky => 'ns');
($canvas = $main_frame->new_tk__canvas(
          -background  => $canvas_color,
          -cursor      => $cursor_norm,
          -width       => $canvas_width,
          -height      => $canvas_height,
          -scrollregion => [0, 0, $canvas_width, $canvas_height],
          -borderwidth => 1,
          -relief      => "groove",
          -xscrollcommand => [$canvas_xscroll, 'set'],
          -yscrollcommand => [$canvas_yscroll, 'set'],
          ))->g_grid(-row => 0, -column => 0, -sticky => 'nw');
$canvas_xscroll->configure(-command => [$canvas, 'xview']);
$canvas_yscroll->configure(-command => [$canvas, 'yview']);
$main_frame->g_grid_rowconfigure(0, -weight => 1);
$main_frame->g_grid_columnconfigure(0, -weight => 1);

#
# Allow the main window to be resized via window handles.
# Set the minimum main window size.
# Remove scrollbars if not needed.  Set the maximum main window size.
# Adjust scrollbar visibility when main window frame is resized.
#
Tkx::wm_resizable($main,1,1);
Tkx::wm_minsize($main, $min_canvas_width +21, $min_canvas_height +21 +$main_footer_height);
&initialize_canvas_scrollbars();
Tkx::update();
$nconfig_events = 0;
$main_frame->g_bind("<Configure>", [ \&manage_canvas_scrollbars, Tkx::Ev("%W")]);

#
# Trap for a Delete Window event from the main window manager.
#
Tkx::wm_protocol($main, 'WM_DELETE_WINDOW', \&confirm_exit);

#
# Bind some keyboard shortcuts
#
$main->g_bind("<Alt-p>", [ \&altp_popup,    Tkx::Ev("%x","%y","%X","%Y"), $canvas ]);
$main->g_bind("<Left>",  [ \&move_selected, Tkx::Ev("%k"), $canvas ]);
$main->g_bind("<Right>", [ \&move_selected, Tkx::Ev("%k"), $canvas ]);
$main->g_bind("<Up>",    [ \&move_selected, Tkx::Ev("%k"), $canvas ]);
$main->g_bind("<Down>",  [ \&move_selected, Tkx::Ev("%k"), $canvas ]);

#
# Reset bindings for the canvas
#
&reset_bindings;

#
# Minimize the command prompt window, if on a Win32 system.
# And set the icon bitmap.
#
if ( $^O =~ /MSWin32/i ) {
    Win32::GUI::Minimize(scalar(Win32::GUI::GetPerlWindow()));
    Tkx::wm_iconbitmap($main, -default => "${prog_path}w2anim.ico");
} else {
    $icon_img = Tkx::image_create_photo(-file => "${prog_path}images/w2anim.png");
    Tkx::wm_iconphoto($main, -default => $icon_img);
}

#
# Load a W2Anim project file from the command line, if present.
#
if ($load_w2a =~ /.*\.w2a$/) {
    if ($w2a_error) {
        &pop_up_error($main, "Unable to locate\n$load_w2a");
        $load_w2a = "";
    } else {
        open ($w2a_fh, "<", $load_w2a) || return &pop_up_error($main, "Unable to open\n$load_w2a");
        $w2a_line = <$w2a_fh>;
        close ($w2a_fh);
        if ($w2a_line =~ /^\# W2 Animator data file, version /) {
            &open_file($load_w2a);
        } else {
            &pop_up_error($main, "Unable to open\n$load_w2a");
            $load_w2a = "";
        }
    }
}

#
# Adjust main window position if part of it is not visible.
#
if ($load_w2a !~ /.*\.w2a$/) {
    &adjust_main_position();
}

#
# Remove any autosaved files in the temporary directory that are older than 5 days.
# Autosave files may exist in the temporary directory from other instances of
#   W2Anim that are running, or from sessions that terminated abnormally.
# Leave an autosave file alone if the user is in the process of opening it.
#
opendir($dir_handle, $temp_dir) or &pop_up_error($main,
                                    "Failed to read temporary directory:\n $temp_dir");
while (defined($dir_entry = readdir($dir_handle))) {
    next if (-d $dir_entry || $dir_entry !~ /^_autosave\d+\.w2a$/
                           || $dir_entry !~ /^_autosave\d+_2\.w2a$/);
    $dir_entry = File::Spec->rel2abs($dir_entry, $temp_dir);
    unlink $dir_entry if ($dir_entry ne $load_w2a && -M $dir_entry > 5.);
}
closedir($dir_handle);

#
# Pop up an information window if either of the helper programs was not found.
#
#$use_GS = 0; $GS_PROG = "";
#$use_FFmpeg = 0; $FFmpeg_PROG = "";
if ((! $use_GS && ! $GS_off) || (! $use_FFmpeg && ! $FFmpeg_off)) {
    &helper_prog_notice();
}

Tkx::MainLoop();

exit;


################################################################################
#
# Menu group
#
################################################################################

#
# When the user tries to exit the program, either via the File/Exit menu option
# or by destroying the application with the windows close function, test whether
# the current project might need to be saved. At least one object tagged "keep"
# must be present for something to be worth saving.
# Show the console window, remove various arrays and hashes, and delete any
# current autosave files before exiting.
#
sub confirm_exit {
    my ($answer, $different, $tmp_file, @id_list);
    @id_list = Tkx::SplitList($canvas->find_withtag("keep"));
    if ($#id_list >= 0) {
        $tmp_file = "";
        if (-e $autosave_file) {
            ($tmp_file = $autosave_file) =~ s/\.w2a$/tmp\.w2a/;
            copy($autosave_file, $tmp_file);
        }
        &save_file($autosave_file, 1);

      # If an autosave file already existed, push it to autosave_file2 if different
        if ($tmp_file ne "") {
            $different = &compare_saved($autosave_file, $tmp_file);
            if ($different) {
                unlink $autosave_file2 if (-e $autosave_file2);
                move($tmp_file, $autosave_file2);
                $autosave_menu->entryconfigure('end', -state => 'normal');
            } else {
                unlink $tmp_file;
            }
        }
        $autosave_menu->entryconfigure(8, -state => 'normal');  # entry 8 is "Revert, recent"

      # Compare current project file to saved file
        if ($savefile ne "" && -e $savefile) {
            $different = &compare_saved($autosave_file, $savefile);
            if ($different) {
                $answer = &pop_up_question($main,
                               "Current project is different than\n"
                             . "saved project file. Do you want to save\n"
                             . "the current project before exiting?");
                return if (lc($answer) eq "yes");
            }
        } else {
            $answer = &pop_up_question($main,
                           "Current project has not been saved.\n"
                         . "Do you want to save it before exiting?");
            return if (lc($answer) eq "yes");
        }
    }
    if ($^O =~ /MSWin32/i) {
        Win32::GUI::Show(scalar(Win32::GUI::GetPerlWindow()));
    }
    unlink $autosave_file  if (-e $autosave_file);
    unlink $autosave_file2 if (-e $autosave_file2);
    undef @dates;
    undef %grid;
    undef %props;
    undef %gr_props;
    undef %link_props;
    exit;
}


sub make_menubar {
    my ($window) = @_;
    my (
        $about_menu, $add_graph, $add_obj, $add_w2graph, $edit_menu,
        $fh, $file, $file_menu, $gs_status, $help_menu, $IS_AQUA, $line,
        $menubar, $mi, $nfiles, $success,
       );

#   Test for the Mac operating system, which has some of its own menu items.
    $IS_AQUA = Tkx::tk_windowingsystem() eq "aqua";

    $menubar = $window->new_menu(-tearoff => 0,
                                 -cursor  => $cursor_norm);
    $window->configure(-menu => $menubar);

    $file_menu = $menubar->new_menu(-tearoff => 0);
    $menubar->add_cascade(
                -label     => "File",
                -underline => 0,
                -menu      => $file_menu,
                );
    $file_menu->add_command(
                -label       => "New",
                -underline   => 0,
                -accelerator => "Ctrl+n",
                -command     => \&start_anew,
                );
    $window->g_bind("<Control-n>", \&start_anew);
    $file_menu->add_command(
                -label       => "Open",
                -underline   => 0,
                -accelerator => "Ctrl+o",
                -command     => \&open_file,
                );
    $window->g_bind("<Control-o>", \&open_file);
    $file_menu->add_command(
                -label       => "Save",
                -accelerator => "Ctrl+s",
                -underline   => 0,
                -command     => sub { &save_file($savefile, 0) },
                );
    $window->g_bind("<Control-s>", sub { &save_file($savefile, 0) });
    $file_menu->add_command(
                -label     => "Save As",
                -underline => 5,
                -command   => \&save_file,
                );

    if ($window eq $main) {
        $autosave_menu = $file_menu->new_menu(-tearoff => 0);
        $file_menu->add_cascade(
                    -label     => "Autosave",
                    -underline => 1,
                    -menu      => $autosave_menu,
                    );
        $autosave_menu->add_radiobutton(
                    -label     => "Off",
                    -underline => 0,
                    -variable  => \$autosave_interval,
                    -value     => -1,
                    -command   => sub { my ($id);
                                        $status_line = "Autosave turned off.";
                                        if ($autosave_id1 ne "" && $autosave_id2 ne "") {
                                            foreach $id (Tkx::SplitList(Tkx::after_info())) {
                                                Tkx::after_cancel($id) if ($id eq $autosave_id1 ||
                                                                           $id eq $autosave_id2);
                                            }
                                        }
                                      },
                    );
        foreach $mi (1, 2, 3, 4, 5, 10, 20) {
            $autosave_menu->add_radiobutton(
                        -label     => ($mi == 1) ? $mi . " minute" : $mi . " minutes",
                        -underline => ($mi < 10) ? 0 : ($mi == 10) ? 1 : 3,
                        -variable  => \$autosave_interval,
                        -value     => $mi,
                        -command   => sub { my ($id, $interval);
                                            if ($autosave_interval == 1) {
                                                $status_line = "Autosave turned on. Interval = 1 minute.";
                                            } else {
                                                $status_line = "Autosave turned on. Interval = "
                                                             . $autosave_interval . " minutes.";
                                            }
                                            if ($autosave_id1 ne "" && $autosave_id2 ne "") {
                                                foreach $id (Tkx::SplitList(Tkx::after_info())) {
                                                    Tkx::after_cancel($id) if ($id eq $autosave_id1 ||
                                                                               $id eq $autosave_id2);
                                                }
                                            }
                                            $interval = 60000 *$autosave_interval;
                                            $autosave_id2 = Tkx::after_idle(
                                                              sub {$autosave_id1
                                                                    = Tkx::after($interval, [\&autosave]);
                                                                  });
                                          },
                        );
        }
        $autosave_menu->add_command(
                    -label     => "Revert, recent",
                    -underline => 0,
                    -state     => 'disabled',
                    -command   => sub { if (-e $autosave_file) {
                                            $status_line = "Reverting to recent autosaved file.";
                                            &open_file($autosave_file, 1);
                                        } else {
                                            $status_line = "No recent autosaved file to open.";
                                        }
                                      },
                    );
        $autosave_menu->add_command(
                    -label     => "Revert, previous",
                    -underline => 8,
                    -state     => 'disabled',
                    -command   => sub { if (-e $autosave_file2) {
                                            $status_line = "Reverting to previous autosaved file.";
                                            &open_file($autosave_file2, 1);
                                        } else {
                                            $status_line = "No previous autosaved file to open.";
                                        }
                                      },
                    );

        $export_menu = $file_menu->new_menu(-tearoff => 0);
        $file_menu->add_cascade(
                    -label     => "Export",
                    -underline => 0,
                    -menu      => $export_menu,
                    );
        $export_menu->add_command(
                    -label     => "PostScript",
                    -underline => 4,
                    -command   => sub { &print_canvas("PostScript") },
                    );
        $gs_status = ($use_GS) ? 'normal' : 'disabled';
        $export_menu->add_command(
                    -label     => "PDF",
                    -underline => 0,
                    -state     => $gs_status,
                    -command   => sub { &print_canvas("PDF") },
                    );
        $export_menu->add_command(
                    -label     => "Raster",
                    -underline => 0,
                    -state     => $gs_status,
                    -command   => sub { &scale_output("Raster") },
                    );
        $export_menu->add_command(
                    -label     => "Animation",
                    -underline => 0,
                    -state     => 'disabled',
                    -command   => sub { &scale_output("Animation") },
                    );

        $recent_menu = $file_menu->new_menu(-tearoff => 0);
        $file_menu->add_cascade(
                    -label     => "Recent",
                    -underline => 0,
                    -menu      => $recent_menu,
                    );
        $file   = "${prog_path}w2anim_recent.txt";
        $nfiles = 0;
        if (-e $file && -s $file > 0) {
            $success = open ($fh, "<", $file);
            if (defined($success)) {
                $line = <$fh>;
                if ($line =~ /^\# W2 Animator recent files list/) {
                    while (defined( $line = <$fh> )) {
                        $line =~ s/^\s+//;
                        $line =~ s/\s+$//;
                        next if ($line =~ /^#/ || $line eq "");
                        $file = $line;
                        if ($file =~ /\.w2a$/ && -e $file && -s $file > 0) {
                            $file = File::Spec->rel2abs($file);
                            $recent_menu->add_command(
                                        -label   => $file,
                                        -command => [ \&open_file, $file, 0 ],
                                        );
                            $nfiles++;
                        }
                    }
                }
                close ($fh);
            }
        }
        if ($nfiles == 0) {
            $recent_menu->add_command(
                        -label     => "None",
                        -underline => 0,
                        -state     => 'disabled',
                        );
        } else {
            $recent_menu->add_command(
                        -label     => "Clear recent list",
                        -underline => 0,
                        -state     => 'normal',
                        -command   => \&clear_recent,
                        );
        }
    }

    $file_menu->add_separator();
    $file_menu->add_command(
                -label     => "Exit",
                -underline => 1,
                -command   => \&confirm_exit,
                ) unless $IS_AQUA;

    $edit_menu = $menubar->new_menu(-tearoff => 0);
    $menubar->add_cascade(
                -label     => "Edit",
                -underline => 0,
                -menu      => $edit_menu,
                );
    $add_obj = $edit_menu->new_menu(-tearoff => 0);
    $edit_menu->add_cascade(
                -label     => "Add Object",
                -underline => 4,
                -menu      => $add_obj,
                );
    $add_obj->add_command(
                -label     => "Line",
                -underline => 0,
                -command   => sub { &draw("line") },
                );
    $add_obj->add_command(
                -label     => "Circle",
                -underline => 0,
                -command   => sub { &draw("circle") },
                );
    $add_obj->add_command(
                -label     => "Ellipse",
                -underline => 0,
                -command   => sub { &draw("ellipse") },
                );
    $add_obj->add_command(
                -label     => "Rectangle",
                -underline => 0,
                -command   => sub { &draw("rectangle") },
                );
    $add_obj->add_command(
                -label     => "Diamond",
                -underline => 0,
                -command   => sub { &draw("diamond") },
                );
    $add_obj->add_command(
                -label     => "Polygon",
                -underline => 0,
                -command   => sub { &draw("polygon") },
                );
    $add_obj->add_command(
                -label     => "Polyline",
                -underline => 3,
                -command   => sub { &draw("polyline") },
                );
    $add_obj->add_command(
                -label     => "Text",
                -underline => 0,
                -command   => sub { &draw("text") },
                );
    $add_obj->add_command(
                -label     => "Image",
                -underline => 0,
                -command   => \&draw_image,
                );

    $add_graph = $edit_menu->new_menu(-tearoff => 0);
    $edit_menu->add_cascade(
                -label     => "Add Graph",
                -underline => 4,
                -menu      => $add_graph,
                );
    $add_graph->add_command(
                -label     => "Profile",
                -underline => 0,
                -command   => sub { &draw("graph", "data_profile") },
                );
    $add_graph->add_command(
                -label     => "Profile Colormap",
                -underline => 8,
                -command   => sub { &draw("graph", "data_profile_cmap") },
                );
    $add_graph->add_command(
                -label     => "Vertical Withdrawal Zone",
                -underline => 0,
                -command   => sub { &draw("graph", "vert_wd_zone") },
                );
    $add_graph->add_command(
                -label     => "Time-Series",
                -underline => 0,
                -command   => sub { &draw("graph", "time_series") },
                );

    $add_w2graph = $edit_menu->new_menu(-tearoff => 0);
    $edit_menu->add_cascade(
                -label     => "Add W2 Graph",
                -underline => 4,
                -menu      => $add_w2graph,
                );
    $add_w2graph->add_command(
                -label     => "W2 Profile",
                -underline => 3,
                -command   => sub { &draw("graph", "w2_profile") },
                );
    $add_w2graph->add_command(
                -label     => "W2 Profile Colormap",
                -underline => 11,
                -command   => sub { &draw("graph", "w2_profile_cmap") },
                );
    $add_w2graph->add_command(
                -label     => "W2 Longitudinal Slice",
                -underline => 3,
                -command   => sub { &draw("graph", "w2_slice") },
                );
    $add_w2graph->add_command(
                -label     => "W2 Time/Distance Map",
                -underline => 8,
                -command   => sub { &draw("graph", "w2_tdmap") },
                );
    $add_w2graph->add_command(
                -label     => "W2 Outflow Profile",
                -underline => 3,
                -command   => sub { &draw("graph", "w2_outflow") },
                );
    $add_w2graph->add_command(
                -label     => "W2 Water Levels",
                -underline => 3,
                -command   => sub { &draw("graph", "w2_wlevels") },
                );
    $add_w2graph->add_command(
                -label     => "Time-Series",
                -underline => 0,
                -command   => sub { &draw("graph", "time_series") },
                );

    $edit_menu->add_command(
                -label     => "Edit",
                -underline => 0,
                -command   => sub { &prepare_to("edit") },
                );
    $edit_menu->add_command(
                -label     => "Move",
                -underline => 0,
                -command   => sub { &prepare_to("move") },
                );
    $edit_menu->add_command(
                -label     => "Duplicate",
                -underline => 5,
                -command   => sub { &prepare_to("duplicate") },
                );
    $edit_menu->add_command(
                -label     => "Delete",
                -underline => 0,
                -command   => sub { &prepare_to("kill") },
                );

    $pref_menu = $edit_menu->new_menu(-tearoff => 0);
    $edit_menu->add_cascade(
                -label     => "Preferences",
                -underline => 0,
                -menu      => $pref_menu,
                );
    $pref_menu->add_command(
                -label     => "Date Limits",
                -underline => 5,
                -state     => 'disabled',
                -command   => sub { &set_global_date_limits(0, 0) },
                );
    $pref_menu->add_command(
                -label     => "Canvas Props",
                -underline => 0,
                -command   => sub { &edit_canvas_props(0, 0) },
                );
    $pref_menu->add_command(
                -label     => "Defaults",
                -underline => 0,
                -command   => sub { &edit_defaults(0, 0, 0) },
                );
    $pref_menu->add_command(
                -label     => "Save w2anim.ini",
                -underline => 0,
                -command   => sub { &write_ini_file },
                );

    $help_menu = $menubar->new_menu(-tearoff => 0,
                                    -name    => "help");
    $menubar->add_cascade(
                -label     => "Help",
                -underline => 0,
                -menu      => $help_menu,
                );
    $about_menu = $help_menu;
    if ($IS_AQUA) {
        # On Mac OS we want about box to appear in the application
        # menu.  Anything added to a menu with the name "apple" will
        # appear in this menu.
        $about_menu = $menubar->new_menu(-tearoff => 0,
                                         -name    => "apple");
        $menubar->add_cascade(-menu => $about_menu);
    }
    $help_menu->add_command(
                -label     => "Configure",
                -underline => 0,
                -command   => \&configure_helper_apps,
                );
    $help_menu->add_command(
                -label     => "Support",
                -underline => 0,
                -command   => \&support,
                );
    $help_menu->add_command(
                -label     => "About",
                -underline => 0,
                -command   => \&about,
                );
}


sub prepare_to {
    my ($action) = @_;      # kill, edit, move, duplicate, zoom

    if ($action eq "kill") {
        $canvas->configure(-cursor => $cursor_kill);
        $canvas->g_bind("<Button-3>", [ \&reset_bindings ]);
    } elsif ($action =~ /zoom_in/) {
        $canvas->configure(-cursor => $cursor_draw);
        $canvas->g_bind("<Button-3>", [ \&forget_drawing, '' ]);
    } else {
        $canvas->configure(-cursor => $cursor_hand);
        $canvas->g_bind("<Button-3>", [ \&forget_drawing, '' ]);
    }
    $canvas->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"), $canvas, $action ]);
}


sub popup_menu {
    my ($X, $Y, $canv, $id) = @_;
    my (
        $add_dt, $add_graph, $add_obj, $add_w2graph, $align_menu,
        $align_ready, $anchor_src, $bf_grp_status, $bf_status, $change_menu,
        $crop_menu, $cropped, $diff_menu, $flip_menu, $group_menu,
        $group_order, $group_ready, $group_tag, $hide_menu, $hide_txt, $i,
        $id_tmp, $item, $match, $next_id, $order, $ref_menu, $rotate_menu,
        $sb_grp_status, $sb_status, $tag, $type,

        @add_ts_setnum, @crop, @gtags, @ids, @items, @rev_tags, @tags,

        %add_ts_parms,
       );

    $popmenu = $canv->new_menu(-tearoff => 0);

    $id = "" if (! defined($id));
    $group_tag   = "";
    $group_ready = 0;
    $align_ready = 0;

    if ($id ne "") {

#       Check whether user has selected items
        @tags = Tkx::SplitList($canv->itemcget($id, -tags));
        if (&list_match("select", @tags) > -1) {
            @items = Tkx::SplitList($canv->find_withtag("select"));
            if ($#items > 0) {
                $align_ready = 1;
                $group_ready = 1;
            }
        }

#       Check whether a group tag is present.  Select the latest.
        if (&list_search("group_", @tags) > -1) {
            @rev_tags  = reverse @tags;
            $group_tag = @rev_tags[&list_search("group_", @rev_tags)];
            @gtags = ();
            foreach $tag (@tags) {
                push (@gtags, $tag) if ($tag =~ /^group_/);
            }
        }

#       Check whether the selection corresponds to existing group
        if ($align_ready && $group_tag ne "") {
            foreach $tag (@gtags) {
                @ids = Tkx::SplitList($canv->find_withtag($tag));
                next if ($#ids != $#items);
                $match = 1;
                foreach $item (@items) {
                    if (&list_match($item, @ids) == -1) {
                        $match = 0;
                        last;
                    }
                }
                if ($match) {
                    $group_ready = 0;
                    last;
                }
            }
        }
    }

    if ($id ne "" && ($group_ready || $align_ready)) {
        if ($group_ready) {
            $popmenu->add_command(-label     => "Group",
                                  -underline => 0,
                                  -command   => sub { &group_items($canv, @items) },
                                  );
        }
        $tag = "select";
        $align_menu = $popmenu->new_menu(-tearoff => 0);
        $popmenu->add_cascade(-label     => "Align",
                              -underline => 0,
                              -menu      => $align_menu,
                              );
        $align_menu->add_command(
                       -label     => "Align Left",
                       -underline => 6,
                       -command   => sub { &align_objects($canv, $id, "left", $tag) },
                       );
        $align_menu->add_command(
                       -label     => "Align Center",
                       -underline => 6,
                       -command   => sub { &align_objects($canv, $id, "center", $tag) },
                       );
        $align_menu->add_command(
                       -label     => "Align Right",
                       -underline => 6,
                       -command   => sub { &align_objects($canv, $id, "right", $tag) },
                       );
        $align_menu->add_separator();
        $align_menu->add_command(
                       -label     => "Align Top",
                       -underline => 6,
                       -command   => sub { &align_objects($canv, $id, "top", $tag) },
                       );
        $align_menu->add_command(
                       -label     => "Align Middle",
                       -underline => 6,
                       -command   => sub { &align_objects($canv, $id, "middle", $tag) },
                       );
        $align_menu->add_command(
                       -label     => "Align Bottom",
                       -underline => 6,
                       -command   => sub { &align_objects($canv, $id, "bottom", $tag) },
                       );
        $align_menu->add_separator();
        $align_menu->add_command(
                       -label     => "Align XY Centers",
                       -underline => 15,
                       -command   => sub { &align_objects($canv, $id, "xycenters", $tag) },
                       );
        $align_menu->add_separator();
        $align_menu->add_command(
                       -label     => "Align Anchors X",
                       -underline => 14,
                       -command   => sub { &align_objects($canv, $id, "anchor_x", $tag) },
                       );
        $align_menu->add_command(
                       -label     => "Align Anchors Y",
                       -underline => 14,
                       -command   => sub { &align_objects($canv, $id, "anchor_y", $tag) },
                       );
        $align_menu->add_command(
                       -label     => "Align Anchors XY",
                       -underline => 6,
                       -command   => sub { &align_objects($canv, $id, "anchor_xy", $tag) },
                       );

    } elsif ($id ne "") {
        &clear_selection($canv);

        $type   = $props{$id}{type};
        $id_tmp = ($type eq "graph") ? "graph" . $id : $id;

        $bf_status = 'disabled';
        while (($next_id = $canv->find_above($id_tmp)) ne "") {
            @tags = Tkx::SplitList($canv->itemcget($next_id, -tags));
            if (&list_match("working", @tags) > -1) {
                $canv->lower($next_id, $id_tmp);
                next;
            }
            $bf_status = 'normal';
            last;
        }
        $sb_status = 'disabled';
        while (($next_id = $canv->find_below($id_tmp)) ne "") {
            @tags = Tkx::SplitList($canv->itemcget($next_id, -tags));
            if (&list_match("working", @tags) > -1) {
                $canv->raise($next_id, $id_tmp);
                next;
            }
            $sb_status = 'normal';
            last;
        }

        if ($group_tag ne "") {
            $bf_grp_status = 'disabled';
            $sb_grp_status = 'disabled';

            @items = ();
            foreach $item (Tkx::SplitList($canv->find_withtag($group_tag))) {
                next if (! defined($props{$item}{type}));
                push (@items, $item);
            }
            foreach $item (@items) {
                $id_tmp = ($props{$item}{type} eq "graph") ? "graph" . $item : $item;
                while ($bf_grp_status eq 'disabled' && ($next_id = $canv->find_above($id_tmp)) ne "") {
                    if (&list_match($next_id, @items) > -1) {
                        $id_tmp = ($props{$next_id}{type} eq "graph") ? "graph" . $next_id : $next_id;
                        next;
                    }
                    @tags = Tkx::SplitList($canv->itemcget($next_id, -tags));
                    if (&list_match("working", @tags) > -1) {
                        $canv->lower($next_id, $id_tmp);
                        next;
                    }
                    $bf_grp_status = 'normal';
                }
                $id_tmp = ($props{$item}{type} eq "graph") ? "graph" . $item : $item;
                while ($sb_grp_status eq 'disabled' && ($next_id = $canv->find_below($id_tmp)) ne "") {
                    if (&list_match($next_id, @items) > -1) {
                        $id_tmp = ($props{$next_id}{type} eq "graph") ? "graph" . $next_id : $next_id;
                        next;
                    }
                    @tags = Tkx::SplitList($canv->itemcget($next_id, -tags));
                    if (&list_match("working", @tags) > -1) {
                        $canv->raise($next_id, $id_tmp);
                        next;
                    }
                    $sb_grp_status = 'normal';
                }
                last if ($bf_grp_status eq 'normal' && $sb_grp_status eq 'normal');
            }

            $group_menu = $popmenu->new_menu(-tearoff => 0);
            $popmenu->add_cascade(-label     => "Group",
                                  -underline => 0,
                                  -menu      => $group_menu,
                                  );
            $group_menu->add_command(
                           -label     => "Ungroup",
                           -underline => 0,
                           -command   => sub { &ungroup_items($canv, $group_tag) },
                           );
            $group_menu->add_command(
                           -label     => "Show Group",
                           -underline => 0,
                           -command   => sub { &show_group($canv, $group_tag) },
                           );
            $group_menu->add_command(
                           -label     => "Move Group",
                           -underline => 0,
                           -command   => sub { &begin_move($canv, $group_tag, "group") },
                           );
            $align_menu = $group_menu->new_menu(-tearoff => 0);
            $group_menu->add_cascade(-label     => "Align",
                                     -underline => 0,
                                     -menu      => $align_menu,
                                     );
            $align_menu->add_command(
                           -label     => "Align Left",
                           -underline => 6,
                           -command   => sub { &align_objects($canv, $id, "left", $group_tag) },
                           );
            $align_menu->add_command(
                           -label     => "Align Center",
                           -underline => 6,
                           -command   => sub { &align_objects($canv, $id, "center", $group_tag) },
                           );
            $align_menu->add_command(
                           -label     => "Align Right",
                           -underline => 6,
                           -command   => sub { &align_objects($canv, $id, "right", $group_tag) },
                           );
            $align_menu->add_separator();
            $align_menu->add_command(
                           -label     => "Align Top",
                           -underline => 6,
                           -command   => sub { &align_objects($canv, $id, "top", $group_tag) },
                           );
            $align_menu->add_command(
                           -label     => "Align Middle",
                           -underline => 6,
                           -command   => sub { &align_objects($canv, $id, "middle", $group_tag) },
                           );
            $align_menu->add_command(
                           -label     => "Align Bottom",
                           -underline => 6,
                           -command   => sub { &align_objects($canv, $id, "bottom", $group_tag) },
                           );
            $align_menu->add_separator();
            $align_menu->add_command(
                           -label     => "Align XY Centers",
                           -underline => 15,
                           -command   => sub { &align_objects($canv, $id, "xycenters", $group_tag) },
                           );
            $align_menu->add_separator();
            $align_menu->add_command(
                           -label     => "Align Anchors X",
                           -underline => 14,
                           -command   => sub { &align_objects($canv, $id, "anchor_x", $group_tag) },
                           );
            $align_menu->add_command(
                           -label     => "Align Anchors Y",
                           -underline => 14,
                           -command   => sub { &align_objects($canv, $id, "anchor_y", $group_tag) },
                           );
            $align_menu->add_command(
                           -label     => "Align Anchors XY",
                           -underline => 6,
                           -command   => sub { &align_objects($canv, $id, "anchor_xy", $group_tag) },
                           );
            $group_order = $group_menu->new_menu(-tearoff => 0);
            $group_menu->add_cascade(
                           -label     => "Order Group",
                           -underline => 0,
                           -menu      => $group_order,
                           );
            $group_order->add_command(
                           -label     => "Bring to Front",
                           -underline => 13,
                           -state     => $bf_grp_status,
                           -command   => sub { &raise_lower($canv, $group_tag, "top") },
                           );
            $group_order->add_command(
                           -label     => "Bring Forward",
                           -underline => 6,
                           -state     => $bf_grp_status,
                           -command   => sub { &raise_lower($canv, $group_tag, "raise") },
                           );
            $group_order->add_command(
                           -label     => "Send to Back",
                           -underline => 11,
                           -state     => $sb_grp_status,
                           -command   => sub { &raise_lower($canv, $group_tag, "bottom") },
                           );
            $group_order->add_command(
                           -label     => "Send Backward",
                           -underline => 5,
                           -state     => $sb_grp_status,
                           -command   => sub { &raise_lower($canv, $group_tag, "lower") },
                           );
            $group_menu->add_command(
                           -label     => "Delete Members",
                           -underline => 0,
                           -command   => sub { &group_kill($canv, $group_tag) },
                           );
        }

        if ($type ne "image") {
            $popmenu->add_command(
                        -label     => "Edit",
                        -underline => 0,
                        -command   => sub { &begin_edit($X, $Y, $canv, $id) },
                        );
        }
        if ($type =~ /^(text|circle|ellipse|rectangle|diamond|polygon)$/
                && defined($link_props{$id}{id}) && $link_props{$id}{form} ne "stat") {
            $popmenu->add_command(
                        -label     => "Edit Link",
                        -underline => 5,
                        -command   => sub { &edit_link($canv, $link_props{$id}{id}, $X+5, $Y+5, $id) },
                        );
        }
        if ($type eq "text" && defined($link_props{$id}{id})
                            && $link_props{$id}{form} eq "stat") {
            $popmenu->add_command(
                        -label     => "Edit Link",
                        -underline => 5,
                        -command   => sub { &edit_stat_link($canv, $link_props{$id}{id}, $X+5, $Y+5, $id) },
                        );
        }
        if ($type =~ /^(polygon|polyline)$/) {
            $popmenu->add_command(
                        -label     => "Edit Points",
                        -underline => 5,
                        -command   => sub { &show_points($canv, $id) },
                        );
        }

        if ($type eq "graph") {
            if ($props{$id}{meta}
                    =~ /^(data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)$/) {
                $popmenu->add_command(
                            -label     => "Animate",
                            -underline => 0,
                            -command   => sub { &animate_toolbar($X, $Y, $id) },
                            );
            }
        }

        $popmenu->add_command(
                    -label     => "Move",
                    -underline => 0,
                    -command   => sub { &begin_move($canv, $id, "") },
                    );
        if ($type eq "graph"
              && $props{$id}{meta} =~ /(data_profile|w2_profile|w2_tdmap|w2_slice|w2_outflow|vert_wd_zone)/) {
            if ($gr_props{$id}{add_cs} && ! $gr_props{$id}{cs_hide}) {
                $popmenu->add_command(
                            -label     => "Move Color Key",
                            -underline => 11,
                            -command   => sub { &begin_move($canv, $id, "Color Key") },
                            );
            }
            if ($props{$id}{meta} eq "vert_wd_zone") {
                if ($props{$id}{wd_alg} eq "Libby Dam" &&   $gr_props{$id}{bh_show}
                                                       && ! $gr_props{$id}{bh_docked}) {
                    $popmenu->add_command(
                                -label     => "Move Bulkhead Key",
                                -underline => 5,
                                -command   => sub { &begin_move($canv, $id, "Bulkhead Key") },
                                );
                }
            }
        }
        if ($type eq "graph" && $props{$id}{meta} =~ /time_series/) {
            $popmenu->add_command(
                        -label     => "Move Legend",
                        -underline => 5,
                        -command   => sub { &begin_move($canv, $id, "Legend") },
                        );
            $popmenu->add_command(
                        -label     => "Zoom Toolbar",
                        -underline => 0,
                        -command   => sub { &end_select($canv, $id, 1);
                                            &zoom_toolbar($X, $Y);
                                          },
                        );
        }

        if ($type !~ /^(image|text)$/) {
            $popmenu->add_command(
                        -label     => "Resize",
                        -underline => 4,
                        -command   => sub { &begin_resize($canv, $id) },
                        );
        } elsif ($type eq "image") {
            $popmenu->add_command(
                        -label     => "Resize",
                        -underline => 4,
                        -command   => sub { &begin_resize_image($canv, $id) },
                        );
            if ($props{$id}{iw} != $props{$id}{iwo} ||
                $props{$id}{ih} != $props{$id}{iho} ||
                $props{$id}{angle} != 0 || $props{$id}{flip} ne "none") {
                $popmenu->add_command(
                            -label     => "Revert",
                            -underline => 2,
                            -command   => sub { &revert_image($canv, $id) },
                            );
            }
        }

        if ($type =~ /^(text|ellipse|rectangle|diamond|polygon|polyline)$/) {
            $popmenu->add_command(
                        -label     => "Rotate",
                        -underline => 0,
                        -command   => sub { &begin_rotate($canv, $id) },
                        );
        } elsif ($type eq "image") {
            $rotate_menu = $popmenu->new_menu(-tearoff => 0);
            $popmenu->add_cascade(
                        -label     => "Rotate",
                        -underline => 0,
                        -menu      => $rotate_menu,
                        );
            $rotate_menu->add_command(
                        -label     => "Clockwise 90",
                        -underline => 1,
                        -command   => sub { &rotate_image($canv, $id, -90, 0) },
                        );
            $rotate_menu->add_command(
                        -label     => "Counterclockwise 90",
                        -underline => 0,
                        -command   => sub { &rotate_image($canv, $id, 90, 0) },
                        );
            if ($props{$id}{angle} != 0) {
                $rotate_menu->add_command(
                            -label     => "To Zero",
                            -underline => 3,
                            -command   => sub { &rotate_image($canv, $id, -1 *$props{$id}{angle}, 0) },
                            );
            }
            $rotate_menu->add_command(
                        -label     => "Free Rotate",
                        -underline => 0,
                        -command   => sub { &begin_rotate($canv, $id) },
                        );
        }
        if ($type =~ /^(line|ellipse|rectangle|diamond|polygon|polyline)$/) {
            $flip_menu = $popmenu->new_menu(-tearoff => 0);
            $popmenu->add_cascade(
                        -label     => "Flip",
                        -underline => 0,
                        -menu      => $flip_menu,
                        );
            $flip_menu->add_command(
                        -label     => "Left to Right",
                        -underline => 0,
                        -command   => sub { &flip_object($canv, $id, "left_right") },
                        );
            if ($props{$id}{anchor} ne 'center') {
                $flip_menu->add_command(
                            -label     => "Left to Right, via Anchor",
                            -underline => 8,
                            -command   => sub { &flip_object($canv, $id, "left_right_anchor") },
                            );
            }
            $flip_menu->add_command(
                        -label     => "Top to Bottom",
                        -underline => 0,
                        -command   => sub { &flip_object($canv, $id, "top_bottom") },
                        );
            if ($props{$id}{anchor} ne 'center') {
                $flip_menu->add_command(
                            -label     => "Top to Bottom, via Anchor",
                            -underline => 7,
                            -command   => sub { &flip_object($canv, $id, "top_bottom_anchor") },
                            );
            }
        }
        if ($type eq "image" && $props{$id}{angle} == 0) {
            $flip_menu = $popmenu->new_menu(-tearoff => 0);
            $popmenu->add_cascade(
                        -label     => "Flip",
                        -underline => 0,
                        -menu      => $flip_menu,
                        );
            $flip_menu->add_command(
                        -label     => "Left to Right",
                        -underline => 0,
                        -command   => sub { &flip_image($canv, $id, "left_right") },
                        );
            if ($props{$id}{anchor} !~ /^(n|s|center)$/) {
                $flip_menu->add_command(
                            -label     => "Left to Right, via Anchor",
                            -underline => 8,
                            -command   => sub { &flip_image($canv, $id, "left_right_anchor") },
                            );
            }
            $flip_menu->add_command(
                        -label     => "Top to Bottom",
                        -underline => 0,
                        -command   => sub { &flip_image($canv, $id, "top_bottom") },
                        );
            if ($props{$id}{anchor} !~ /^(e|w|center)$/) {
                $flip_menu->add_command(
                            -label     => "Top to Bottom, via Anchor",
                            -underline => 7,
                            -command   => sub { &flip_image($canv, $id, "top_bottom_anchor") },
                            );
            }
            if ($props{$id}{flip} ne "none") {
                $flip_menu->add_command(
                            -label     => "Original",
                            -underline => 0,
                            -command   => sub { &flip_image($canv, $id, "original") },
                            );
            }
        }
        if ($type eq "image") {
            @crop = @{ $props{$id}{crop} };
            $cropped = 0;
            for ($i=0; $i<4; $i++) {
                if ($crop[$i] != 0.0) {
                    $cropped = 1;
                    last;
                }
            }
            if ($cropped) {
                $crop_menu = $popmenu->new_menu(-tearoff => 0);
                $popmenu->add_cascade(
                            -label     => "Crop",
                            -underline => 3,
                            -menu      => $crop_menu,
                            );
                $crop_menu->add_command(
                            -label     => "Modify",
                            -underline => 0,
                            -command   => sub { &begin_crop_image($canv, $id) },
                            );
                $crop_menu->add_command(
                            -label     => "Uncrop",
                            -underline => 0,
                            -command   => sub { &uncrop_image($canv, $id) },
                            );
            } else {
                $popmenu->add_command(
                            -label     => "Crop",
                            -underline => 3,
                            -command   => sub { &begin_crop_image($canv, $id) },
                            );
            }
        }
        if ($type =~ /^(circle|ellipse|rectangle|diamond|text|image|line|graph)$/) {
            $popmenu->add_command(
                        -label     => "Select Anchor",
                        -underline => 0,
                        -command   => sub { &show_anchors($canv, $id) },
                        );
        } elsif ($type =~ /^(polygon|polyline)$/) {
            $anchor_src = $popmenu->new_menu(-tearoff => 0);
            $popmenu->add_cascade(
                        -label     => "Select Anchor",
                        -underline => 0,
                        -menu      => $anchor_src,
                        );
            $anchor_src->add_command(
                        -label     => "from Bounding Box",
                        -underline => 5,
                        -command   => sub { &show_anchors($canv, $id, "bbox") },
                        );
            $anchor_src->add_command(
                        -label     => "from Points",
                        -underline => 5,
                        -command   => sub { &show_anchors($canv, $id, "pts") },
                        );
        }
        $order = $popmenu->new_menu(-tearoff => 0);
        $popmenu->add_cascade(
                    -label     => "Order",
                    -underline => 0,
                    -menu      => $order,
                    );
        $order->add_command(
                    -label     => "Bring to Front",
                    -underline => 13,
                    -state     => $bf_status,
                    -command   => sub { &raise_lower($canv, $id, "top") },
                    );
        $order->add_command(
                    -label     => "Bring Forward",
                    -underline => 6,
                    -state     => $bf_status,
                    -command   => sub { &raise_lower($canv, $id, "raise") },
                    );
        $order->add_command(
                    -label     => "Send to Back",
                    -underline => 11,
                    -state     => $sb_status,
                    -command   => sub { &raise_lower($canv, $id, "bottom") },
                    );
        $order->add_command(
                    -label     => "Send Backward",
                    -underline => 5,
                    -state     => $sb_status,
                    -command   => sub { &raise_lower($canv, $id, "lower") },
                    );
        if ($type eq "graph") {
            if ($props{$id}{meta} =~ /w2_profile|w2_slice|w2_wlevels/
                  || ($props{$id}{meta} eq "w2_tdmap" && $props{$id}{src_type} !~ /RiverCon/i)) {
                $change_menu = $popmenu->new_menu(-tearoff => 0);
                $popmenu->add_cascade(
                            -label     => "Change",
                            -underline => 1,
                            -menu      => $change_menu,
                            );
                if ($props{$id}{meta} =~ /w2_profile/) {
                    if ($props{$id}{src_type} =~ /LakeCon/i) {
                        $change_menu->add_command(
                                    -label     => "Base Year",
                                    -underline => 0,
                                    -command   => sub { &change_w2_profile($canv, $id, $X+5, $Y+5, "base") },
                                    );
                    } else {
                        $change_menu->add_command(
                                    -label     => "Segment",
                                    -underline => 0,
                                    -command   => sub { &change_w2_profile($canv, $id, $X+5, $Y+5, "seg") },
                                    );
                        $change_menu->add_command(
                                    -label     => "Parameter",
                                    -underline => 0,
                                    -command   => sub { &change_w2_profile($canv, $id, $X+5, $Y+5, "parm") },
                                    );
                        $change_menu->add_command(
                                    -label     => "Misc",
                                    -underline => 0,
                                    -command   => sub { &change_w2_profile($canv, $id, $X+5, $Y+5, "misc") },
                                    );
                    }
                    $change_menu->add_command(
                                -label     => "Data Source",
                                -underline => 0,
                                -command   => sub { &setup_w2_profile($canv, $id) },
                                );
                } elsif ($props{$id}{meta} eq "w2_slice") {
                    $change_menu->add_command(
                                -label     => "Parameter",
                                -underline => 0,
                                -command   => sub { &change_w2_slice($canv, $id, $X+5, $Y+5, "parm") },
                                );
                    $change_menu->add_command(
                                -label     => "Misc",
                                -underline => 0,
                                -command   => sub { &change_w2_slice($canv, $id, $X+5, $Y+5, "misc") },
                                );
                } elsif ($props{$id}{meta} eq "w2_wlevels") {
                    $change_menu->add_command(
                                -label     => "Misc",
                                -underline => 0,
                                -command   => sub { &setup_w2_wlevels_part3($canv, $id, $X+5, $Y+5, "misc") },
                                );
                } elsif ($props{$id}{meta} eq "w2_tdmap" && $props{$id}{src_type} !~ /RiverCon/i) {
                    $change_menu->add_command(
                                -label     => "Parameter",
                                -underline => 0,
                                -command   => sub { &change_w2_tdmap($canv, $id, $X+5, $Y+5, "parm") },
                                );
                    $change_menu->add_command(
                                -label     => "Misc",
                                -underline => 0,
                                -command   => sub { &change_w2_tdmap($canv, $id, $X+5, $Y+5, "misc") },
                                );
                }
            }
            if ($props{$id}{meta} eq "w2_tdmap") {
                if ($props{$id}{map_type} eq "standard") {
                    $diff_menu = $popmenu->new_menu(-tearoff => 0);
                    $popmenu->add_cascade(
                                -label     => "Convert to Diff",
                                -underline => 3,
                                -menu      => $diff_menu,
                                );
                    $diff_menu->add_command(
                                -label     => "Same Parameter, Different Run",
                                -underline => 0,
                                -command   => sub { &setup_w2_tdmap_filediff($canv, $id, $X+5, $Y+5) },
                                );
                    if ($props{$id}{src_type} !~ /RiverCon/i) {
                        $diff_menu->add_command(
                                    -label     => "Different Parameter, Same Run",
                                    -underline => 0,
                                    -command   => sub { &setup_w2_tdmap_parmdiff($canv, $id, $X+5, $Y+5) },
                                    );
                    }
                } else {
                    $popmenu->add_command(
                                -label     => "Undo Difference",
                                -underline => 0,
                                -command   => sub { &undo_w2_tdmap_diffs($canv, $id, $X+5, $Y+5) },
                                );
                    $popmenu->add_command(
                                -label     => "Reverse Difference",
                                -underline => 0,
                                -command   => sub { &reverse_w2_tdmap_diffs($canv, $id, $X+5, $Y+5) },
                                );
                }
                $hide_menu = $popmenu->new_menu(-tearoff => 0);
                $popmenu->add_cascade(
                            -label     => "Hide/Show",
                            -underline => 8,
                            -menu      => $hide_menu,
                            );
                if ($gr_props{$id}{hide_title} || $gr_props{$id}{hide_taxis}
                                               || $gr_props{$id}{hide_daxis}) {
                    $hide_menu->add_command(
                                -label     => "Show All",
                                -underline => 0,
                                -command   => sub { my ($gtag);
                                                    $gtag = "graph" . $id;
                                                    if ($gr_props{$id}{hide_title}) {
                                                        $gr_props{$id}{hide_title} = 0;
                                                        $canv->itemconfigure($gtag . "_gtitle",
                                                                             -state => 'normal');
                                                    }
                                                    if ($gr_props{$id}{hide_taxis}) {
                                                        $gr_props{$id}{hide_taxis} = 0;
                                                        if ($gr_props{$id}{date_axis} eq "X") {
                                                            $canv->itemconfigure($gtag . "_xaxis",
                                                                                 -state => 'normal');
                                                            $canv->itemconfigure($gtag . "_xaxisTitle",
                                                                                 -state => 'normal');
                                                        } else {
                                                            $canv->itemconfigure($gtag . "_yaxis",
                                                                                 -state => 'normal');
                                                            $canv->itemconfigure($gtag . "_yaxisTitle",
                                                                                 -state => 'normal');
                                                        }
                                                    }
                                                    if ($gr_props{$id}{hide_daxis}) {
                                                        $gr_props{$id}{hide_daxis} = 0;
                                                        if ($gr_props{$id}{date_axis} eq "Y") {
                                                            $canv->itemconfigure($gtag . "_xaxis",
                                                                                 -state => 'normal');
                                                            $canv->itemconfigure($gtag . "_xaxisTitle",
                                                                                 -state => 'normal');
                                                        } else {
                                                            $canv->itemconfigure($gtag . "_yaxis",
                                                                                 -state => 'normal');
                                                            $canv->itemconfigure($gtag . "_yaxisTitle",
                                                                                 -state => 'normal');
                                                        }
                                                    }
                                                  },
                                );
                }
                if (! $gr_props{$id}{hide_title} || ! $gr_props{$id}{hide_taxis}
                                                 || ! $gr_props{$id}{hide_daxis}) {
                    $hide_menu->add_command(
                                -label     => "Hide All",
                                -underline => 0,
                                -command   => sub { my ($gtag);
                                                    $gtag = "graph" . $id;
                                                    if (! $gr_props{$id}{hide_title}) {
                                                        $gr_props{$id}{hide_title} = 1;
                                                        $canv->itemconfigure($gtag . "_gtitle",
                                                                             -state => 'hidden');
                                                    }
                                                    if (! $gr_props{$id}{hide_taxis}) {
                                                        $gr_props{$id}{hide_taxis} = 1;
                                                        if ($gr_props{$id}{date_axis} eq "X") {
                                                            $canv->itemconfigure($gtag . "_xaxis",
                                                                                 -state => 'hidden');
                                                            $canv->itemconfigure($gtag . "_xaxisTitle",
                                                                                 -state => 'hidden');
                                                        } else {
                                                            $canv->itemconfigure($gtag . "_yaxis",
                                                                                 -state => 'hidden');
                                                            $canv->itemconfigure($gtag . "_yaxisTitle",
                                                                                 -state => 'hidden');
                                                        }
                                                    }
                                                    if (! $gr_props{$id}{hide_daxis}) {
                                                        $gr_props{$id}{hide_daxis} = 1;
                                                        if ($gr_props{$id}{date_axis} eq "Y") {
                                                            $canv->itemconfigure($gtag . "_xaxis",
                                                                                 -state => 'hidden');
                                                            $canv->itemconfigure($gtag . "_xaxisTitle",
                                                                                 -state => 'hidden');
                                                        } else {
                                                            $canv->itemconfigure($gtag . "_yaxis",
                                                                                 -state => 'hidden');
                                                            $canv->itemconfigure($gtag . "_yaxisTitle",
                                                                                 -state => 'hidden');
                                                        }
                                                    }
                                                  },
                                );
                }
                $hide_txt = ($gr_props{$id}{hide_title}) ? "Show Titles" : "Hide Titles";
                $hide_menu->add_command(
                            -label     => $hide_txt,
                            -underline => 5,
                            -command   => sub { my ($gtag, $state);
                                                $gtag = "graph" . $id;
                                                if ($gr_props{$id}{hide_title}) {
                                                    $state = 'normal';
                                                    $gr_props{$id}{hide_title} = 0;
                                                } else {
                                                    $state = 'hidden';
                                                    $gr_props{$id}{hide_title} = 1;
                                                }
                                                $canv->itemconfigure($gtag . "_gtitle", -state => $state);
                                              },
                            );
                if ($gr_props{$id}{date_axis} eq "X") {
                    $hide_txt = ($gr_props{$id}{hide_taxis}) ? "Show X Axis" : "Hide X Axis";
                } else {
                    $hide_txt = ($gr_props{$id}{hide_daxis}) ? "Show X Axis" : "Hide X Axis";
                }
                $hide_menu->add_command(
                            -label     => $hide_txt,
                            -underline => 5,
                            -command   => sub { my ($gtag, $proptag, $state);
                                                $gtag = "graph" . $id;
                                                if ($gr_props{$id}{date_axis} eq "X") {
                                                    $proptag = "hide_taxis";
                                                } else {
                                                    $proptag = "hide_daxis";
                                                }
                                                if ($gr_props{$id}{$proptag}) {
                                                    $state = 'normal';
                                                    $gr_props{$id}{$proptag} = 0;
                                                } else {
                                                    $state = 'hidden';
                                                    $gr_props{$id}{$proptag} = 1;
                                                }
                                                $canv->itemconfigure($gtag . "_xaxis", -state => $state);
                                                $canv->itemconfigure($gtag . "_xaxisTitle", -state => $state);
                                              },
                            );
                if ($gr_props{$id}{date_axis} eq "Y") {
                    $hide_txt = ($gr_props{$id}{hide_taxis}) ? "Show Y Axis" : "Hide Y Axis";
                } else {
                    $hide_txt = ($gr_props{$id}{hide_daxis}) ? "Show Y Axis" : "Hide Y Axis";
                }
                $hide_menu->add_command(
                            -label     => $hide_txt,
                            -underline => 5,
                            -command   => sub { my ($gtag, $proptag, $state);
                                                $gtag = "graph" . $id;
                                                if ($gr_props{$id}{date_axis} eq "Y") {
                                                    $proptag = "hide_taxis";
                                                } else {
                                                    $proptag = "hide_daxis";
                                                }
                                                if ($gr_props{$id}{$proptag}) {
                                                    $state = 'normal';
                                                    $gr_props{$id}{$proptag} = 0;
                                                } else {
                                                    $state = 'hidden';
                                                    $gr_props{$id}{$proptag} = 1;
                                                }
                                                $canv->itemconfigure($gtag . "_yaxis", -state => $state);
                                                $canv->itemconfigure($gtag . "_yaxisTitle", -state => $state);
                                              },
                            );
                $popmenu->add_command(
                            -label     => "Swap Axes",
                            -underline => 1,
                            -command   => sub { &swap_w2_tdmap_axes($canv, $id) },
                            );
            }
        }
        $popmenu->add_command(
                    -label     => "Info",
                    -underline => 0,
                    -command   => sub { &show_info($canv, $id, $X+5, $Y+5) },
                    );
        if ($type eq "graph" && $props{$id}{meta} =~ /^(data_profile|vert_wd_zone)$/) {
            $popmenu->add_command(
                        -label     => "Add Link",
                        -underline => 4,
                        -command   => sub { &edit_link($canv, $id, $X+5, $Y+5, 0) },
                        );
            $popmenu->add_command(
                        -label     => "Add Time Series Link",
                        -underline => 4,
                        -command   => sub { &add_ts_link($canv, $id, $X+5, $Y+5) },
                        );
        }
        if ($type eq "graph" && $props{$id}{meta} =~ /time_series/) {
            $popmenu->add_command(
                        -label     => "Add Dataset",
                        -underline => 0,
                        -command   => sub { &add_ts_data($canv, $id, $X+5, $Y+5) },
                        );
            if (defined($props{$id}{add_ts_parms})) {
                %add_ts_parms  = %{ $props{$id}{add_ts_parms} };
                @add_ts_setnum = @{ $add_ts_parms{ts_setnum}  };
                if (($props{$id}{meta} eq "linked_time_series" && $#add_ts_setnum >= 0)
                        || ($props{$id}{meta} eq "time_series" && $#add_ts_setnum >= 1)) {
                    $popmenu->add_command(
                                -label     => "Fit Statistics",
                                -underline => 0,
                                -command   => sub { &choose_datasets($canv, $id, $X+5, $Y+5) },
                                );
                }
            }
        }
        if ($type eq "graph" && $props{$id}{meta} =~ /data_profile/) {
            if ($props{$id}{prof_type} =~ /standard/i) {
                $popmenu->add_command(
                            -label     => "Convert to Difference",
                            -underline => 3,
                            -command   => sub { &convert_to_diffs($canv, $id, $X+5, $Y+5) },
                            );
            } else {
                $popmenu->add_command(
                            -label     => "Undo Differences",
                            -underline => 0,
                            -command   => sub { &undo_diffs($canv, $id, $X+5, $Y+5); },
                            );
            }
        }
        if ($type eq "graph" && $props{$id}{meta} eq "w2_profile") {
            if (! defined($props{$id}{ref_file})) {
                $popmenu->add_command(
                            -label     => "Add Reference Data",
                            -underline => 4,
                            -command   => sub { &add_ref_data($canv, $id, $X+5, $Y+5) },
                            );
            } else {
                $ref_menu = $popmenu->new_menu(-tearoff => 0);
                $popmenu->add_cascade(
                            -label     => "Reference Data",
                            -underline => 2,
                            -menu      => $ref_menu,
                            );
                if ($props{$id}{ref_hide}) {
                    $ref_menu->add_command(
                                -label     => "Show Reference Data",
                                -underline => 0,
                                -command   => sub { $canv->itemconfigure("graph" . $id . "_refData",
                                                                         -state => 'normal');
                                                    $props{$id}{ref_hide} = 0;
                                                  },
                                );
                } else {
                    $ref_menu->add_command(
                                -label     => "Hide Reference Data",
                                -underline => 0,
                                -command   => sub { $canv->itemconfigure("graph" . $id . "_refData",
                                                                         -state => 'hidden');
                                                    $props{$id}{ref_hide} = 1;
                                                  },
                                );
                }
                $ref_menu->add_command(
                            -label     => "Delete Reference Data",
                            -underline => 0,
                            -command   => sub { $canv->delete("graph" . $id . "_refData");
                                                undef $props{$id}{ref_file};
                                                undef $gr_props{$id}{ref_data};
                                              },
                            );
                $ref_menu->add_command(
                            -label     => "Fit Statistics Table",
                            -underline => 0,
                            -command   => sub { &setup_ref_stats($canv, $id, $X+5, $Y+5) },
                            );
                $ref_menu->add_command(
                            -label     => "Add Goodness-of-Fit Link",
                            -underline => 0,
                            -command   => sub { &edit_stat_link($canv, $id, $X+5, $Y+5, 0) },
                            );
            }
        }
        if ($type eq "graph" && $props{$id}{meta} eq "w2_outflow") {
            if ($props{$id}{add_parm}) {
                $popmenu->add_command(
                            -label     => "Change Color Parameter",
                            -underline => 13,
                            -command   => sub { &setup_w2_outflow_part2($canv, $id, $X+5, $Y+5, 1) },
                            );
            } else {
                $popmenu->add_command(
                            -label     => "Add Color Parameter",
                            -underline => 10,
                            -command   => sub { &setup_w2_outflow_part2($canv, $id, $X+5, $Y+5, 1) },
                            );
            }
        }
        $popmenu->add_command(
                    -label     => "Duplicate",
                    -underline => 5,
                    -command   => sub { &duplicate($canv, $id) },
                    );
        $popmenu->add_command(
                    -label     => "Delete",
                    -underline => 0,
                    -command   => sub { &object_kill($canv, $id) },
                    );

#   No object selected
    } else {
        &clear_selection($canv);

        $add_obj = $popmenu->new_menu(-tearoff => 0);
        $popmenu->add_cascade(
                    -label     => "Add Object",
                    -underline => 4,
                    -menu      => $add_obj,
                    );
        $add_obj->add_command(
                    -label     => "Line",
                    -underline => 0,
                    -command   => sub { &draw("line") },
                    );
        $add_obj->add_command(
                    -label     => "Circle",
                    -underline => 0,
                    -command   => sub { &draw("circle") },
                    );
        $add_obj->add_command(
                    -label     => "Ellipse",
                    -underline => 0,
                    -command   => sub { &draw("ellipse") },
                    );
        $add_obj->add_command(
                    -label     => "Rectangle",
                    -underline => 0,
                    -command   => sub { &draw("rectangle") },
                    );
        $add_obj->add_command(
                    -label     => "Diamond",
                    -underline => 0,
                    -command   => sub { &draw("diamond") },
                    );
        $add_obj->add_command(
                    -label     => "Polygon",
                    -underline => 0,
                    -command   => sub { &draw("polygon") },
                    );
        $add_obj->add_command(
                    -label     => "Polyline",
                    -underline => 3,
                    -command   => sub { &draw("polyline") },
                    );
        $add_obj->add_command(
                    -label     => "Text",
                    -underline => 0,
                    -command   => sub { &draw("text") },
                    );
        $add_obj->add_command(
                    -label     => "Image",
                    -underline => 0,
                    -command   => \&draw_image,
                    );

        $add_graph = $popmenu->new_menu(-tearoff => 0);
        $popmenu->add_cascade(
                    -label     => "Add Graph",
                    -underline => 4,
                    -menu      => $add_graph,
                    );
        $add_graph->add_command(
                    -label     => "Profile",
                    -underline => 0,
                    -command   => sub { &draw("graph", "data_profile") },
                    );
        $add_graph->add_command(
                    -label     => "Profile Colormap",
                    -underline => 8,
                    -command   => sub { &draw("graph", "data_profile_cmap") },
                    );
        $add_graph->add_command(
                    -label     => "Vertical Withdrawal Zone",
                    -underline => 0,
                    -command   => sub { &draw("graph", "vert_wd_zone") },
                    );
        $add_graph->add_command(
                    -label     => "Time-Series",
                    -underline => 0,
                    -command   => sub { &draw("graph", "time_series") },
                    );

        $add_w2graph = $popmenu->new_menu(-tearoff => 0);
        $popmenu->add_cascade(
                    -label     => "Add W2 Graph",
                    -underline => 4,
                    -menu      => $add_w2graph,
                    );
        $add_w2graph->add_command(
                    -label     => "W2 Profile",
                    -underline => 3,
                    -command   => sub { &draw("graph", "w2_profile") },
                    );
        $add_w2graph->add_command(
                    -label     => "W2 Profile Colormap",
                    -underline => 11,
                    -command   => sub { &draw("graph", "w2_profile_cmap") },
                    );
        $add_w2graph->add_command(
                    -label     => "W2 Longitudinal Slice",
                    -underline => 3,
                    -command   => sub { &draw("graph", "w2_slice") },
                    );
        $add_w2graph->add_command(
                    -label     => "W2 Time/Distance Map",
                    -underline => 8,
                    -command   => sub { &draw("graph", "w2_tdmap") },
                    );
        $add_w2graph->add_command(
                    -label     => "W2 Outflow Profile",
                    -underline => 3,
                    -command   => sub { &draw("graph", "w2_outflow") },
                    );
        $add_w2graph->add_command(
                    -label     => "W2 Water Levels",
                    -underline => 3,
                    -command   => sub { &draw("graph", "w2_wlevels") },
                    );
        $add_w2graph->add_command(
                    -label     => "Time-Series",
                    -underline => 0,
                    -command   => sub { &draw("graph", "time_series") },
                    );

        if (@animate_ids && $#animate_ids >= 0) {
            foreach $item (@animate_ids) {
                if ($props{$item}{meta}
                         =~ /^(data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)$/) {
                    $popmenu->add_command(
                                -label     => "Date Limits",
                                -underline => 5,
                                -command   => sub { &set_global_date_limits($X, $Y) },
                                );
                    last;
                }
            }
        }
        $popmenu->add_command(
                    -label     => "Canvas Props",
                    -underline => 0,
                    -command   => sub { &edit_canvas_props($X, $Y) },
                    );
        $popmenu->add_command(
                    -label     => "Defaults",
                    -underline => 0,
                    -command   => sub { &edit_defaults($X, $Y, 0) },
                    );
    }

    $popmenu->post($X, $Y);
    &reset_bindings;
}


sub edit_pts_menu {
    my ($X, $Y, $canv, $id, $insert_pt) = @_;

    $move_delete_menu = $canv->new_menu(-tearoff => 0);
    $move_delete_menu->add_command(
                -label     => "Move point",
                -underline => 0,
                -command   => sub { &begin_move_pt($canv, $id, $insert_pt) },
                );
    $move_delete_menu->add_command(
                -label     => "Delete point",
                -underline => 0,
                -command   => sub { &delete_pt($canv, $id, $insert_pt) },
                );
    $move_delete_menu->post($X, $Y);
}


################################################################################
#
# General-purpose routines
#
################################################################################

sub read_ini_file {
    my ($ini_file) = @_;
    my (
        $arrow, $acl, $ahw, $asl, $canvas_color_tmp, $canvas_height_tmp,
        $canvas_width_tmp, $error, $f_angle, $f_size, $f_slant, $f_under,
        $f_weight, $family, $ffmp_path, $fh, $grid_spacing_tmp, $gs_path,
        $i, $key, $line, $ob_color, $ob_corner, $ob_fcolor, $ob_fill,
        $ob_width, $pos, $select_color_tmp, $snap2grid_tmp, $tmp_path, $val,
       );

    $canvas_width_tmp  = $canvas_width;
    $canvas_height_tmp = $canvas_height;
    $canvas_color_tmp  = $canvas_color;
    $select_color_tmp  = $text_select_color;
    $snap2grid_tmp     = $snap2grid;
    $grid_spacing_tmp  = $grid_spacing;

    $family    = $default_family;
    $f_size    = $default_size;
    $f_weight  = $default_weight;
    $f_slant   = $default_slant;
    $f_under   = $default_underline;
    $f_angle   = $default_angle;

    $ob_width  = $default_width;
    $ob_color  = $default_color;
    $ob_corner = $default_smooth;
    $ob_fill   = $default_fill;
    $ob_fcolor = $default_fillcolor;

    $arrow     = $default_arrow;
    $acl       = $default_ahd1;   # arrow center length
    $asl       = $default_ahd2;   # arrow side length
    $ahw       = $default_ahd3;   # arrow half width

    $tmp_path  = "";
    $gs_path   = "";
    $ffmp_path = "";

#   Open the initialization file
    open ($fh, "<", $ini_file) || return &pop_up_error($main, "Unable to open\n$ini_file");

    while (defined($line = <$fh>)) {
        $line =~ s/^\s+//;
        $line =~ s/\s+$//;
        next if ($line =~ /^#/ || $line eq "" || $line =~ /^===/);

        if ($line =~ /[a-zA-Z_]+: /) {
            $pos = index($line, ":");
            $key = substr($line, 0, $pos);
            $val = substr($line, $pos + 1);
            $val =~ s/^\s+//;
            $val =~ s/\s+$//;

            $canvas_width_tmp  = $val if ($key eq "width");
            $canvas_height_tmp = $val if ($key eq "height");
            $canvas_color_tmp  = $val if ($key eq "color");
            $select_color_tmp  = $val if ($key eq "text_slct");
            $snap2grid_tmp     = $val if ($key eq "snap2grid");
            $grid_spacing_tmp  = $val if ($key eq "grid_spac");

            $family    = $val if ($key eq "family");
            $f_size    = $val if ($key eq "f_size");
            $f_weight  = $val if ($key eq "f_weight");
            $f_slant   = $val if ($key eq "f_slant");
            $f_under   = $val if ($key eq "f_under");
            $f_angle   = $val if ($key eq "f_angle");

            $ob_width  = $val if ($key eq "ob_width");
            $ob_color  = $val if ($key eq "ob_color");
            $ob_corner = $val if ($key eq "ob_corner");
            $ob_fill   = $val if ($key eq "ob_fill");
            $ob_fcolor = $val if ($key eq "ob_fcolor");

            $arrow     = $val if ($key eq "arrow");
            $acl       = $val if ($key eq "center");
            $asl       = $val if ($key eq "side");
            $ahw       = $val if ($key eq "halfwidth");

            $tmp_path  = $val if ($key eq "tmp_path");
            $gs_path   = $val if ($key eq "gs_path");
            $ffmp_path = $val if ($key eq "ffmp_path");
        }
    }

#   Close the initialization file
    close ($fh);

#   Check canvas inputs
    if ($canvas_width_tmp +0 >= 200) {
        $canvas_width = int($canvas_width_tmp +0.000001);
    }
    if ($canvas_height_tmp +0 >= 150) {
        $canvas_height = int($canvas_height_tmp +0.000001);
    }
    if (&get_rgb_code($canvas_color_tmp)) {
        $canvas_color = &get_rgb_code($canvas_color_tmp);
    } else {
        print "The specified canvas color is unrecognized.\n";
    }
    if (&get_rgb_code($select_color_tmp)) {
        $text_select_color = &get_rgb_code($select_color_tmp);
    } else {
        print "The specified text selection color is unrecognized.\n";
    }
    $snap2grid = ($snap2grid_tmp +0 == 1) ? 1 : 0;
    if ($grid_spacing_tmp +0 >= 2 && $grid_spacing_tmp +0 <= 100) {
        $grid_spacing = int($grid_spacing_tmp +0.000001);
    }

#   Check text inputs
    if (&list_match($family, @available_fonts) >= 0) {
        $default_family = $family;
    } else {
        print "The specified font family is not available.\n";
    }
    if ($f_size +0 >= 5 && $f_size +0 <= 32) {
        $default_size = int($f_size +0.000001);
    }
    if ($f_weight =~ /^(normal|bold)$/) {
        $default_weight = ($f_weight eq "bold") ? "bold" : "normal";
    }
    if ($f_slant =~ /^(normal|italic)$/) {
        $default_slant = ($f_slant eq "italic") ? 1 : 0;
    }
    if ($f_under =~ /^(no|yes)$/) {
        $default_underline = ($f_under eq "yes") ? 1 : 0;
    }
    if ($f_angle +0  >= 0 && $f_angle +0  <= 359) {
        $default_angle = int($f_angle +0.000001);
    }

#   Check object inputs
    if ($ob_width +0 >= 1 && $ob_width +0 <= 10) {
        $default_width = int($ob_width +0.000001);
    }
    if (&get_rgb_code($ob_color)) {
        $default_color = &get_rgb_code($ob_color);
    } else {
        print "The specified object color is unrecognized.\n";
    }
    if ($ob_corner =~ /^(standard|rounded)$/) {
        $default_smooth = ($ob_corner eq "rounded") ? 1 : 0;
    }
    if ($ob_fill =~ /^(no|yes)$/) {
        $default_fill = ($ob_fill eq "yes") ? 1 : 0;
    }
    if (&get_rgb_code($ob_fcolor)) {
        $default_fillcolor = &get_rgb_code($ob_fcolor);
    } else {
        print "The specified object fill color is unrecognized.\n";
    }

#   Check arrow inputs
    if ($arrow =~ /^(none|start|end|both)$/) {
        $default_arrow = &list_match($arrow, @arrow_options);
    }
    if ($acl +0 >= 6 && $acl +0 <= 100) {
        $default_ahd1 = int($acl +0.000001);
    }
    if ($asl +0 >= 10 && $asl +0 <= 100) {
        $default_ahd2 = int($asl +0.000001);
    }
    if ($ahw +0 >= 3 && $ahw +0 <= 40) {
        $default_ahd3 = int($ahw +0.000001);
    }

#   Check the tmp path, if present
    if ($tmp_path ne "") {
        if ($ini_file eq "${prog_path}w2anim.ini") {
            $tmp_path = File::Spec->rel2abs($tmp_path, $prog_path);
        } else {
            $tmp_path = File::Spec->rel2abs($tmp_path);
        }
        $error = 0;
        if (! -e $tmp_path) {
            print "The temporary space specified in w2anim.ini does not exist.\n"
                . "Using $temp_dir instead.\n";
            $error = 1;
        } elsif (! -d $tmp_path) {
            print "The temporary space specified in w2anim.ini is not a directory.\n"
                . "Using $temp_dir instead.\n";
            $error = 1;
        } elsif (! -r $tmp_path) {
            print "The temporary space specified in w2anim.ini is not readable.\n"
                . "Using $temp_dir instead.\n";
            $error = 1;
        } elsif (! -w $tmp_path) {
            print "The temporary space specified in w2anim.ini is not writable.\n"
                . "Using $temp_dir instead.\n";
            $error = 1;
        }
        $temp_dir = $tmp_path if (! $error);
    }

#   Check the GS path, if present
    if ($gs_path ne "") {
        if (lc($gs_path) eq "off") {
            $use_GS = 0;
            $GS_off = 1;
        } else {
            $gs_path = File::Spec->rel2abs($gs_path);
            $error = 0;
            if (! -e $gs_path) {
                print "The path to Ghostscript specified in w2anim.ini does not exist.\n";
                $error = 1;
            } elsif (-d $gs_path) {
                print "The path to Ghostscript specified in w2anim.ini is a directory.\n";
                $error = 1;
            }
            if (! $error) {
                $GS_PROG = $gs_path;
                $use_GS  = 1;
            } else {
                if ($GS_PROG ne "" && -e $GS_PROG) {
                    print "Using $GS_PROG instead.\n";
                    $use_GS = 1;
                } else {
                    $GS_PROG = "";
                    $use_GS  = 0;
                }
            }
        }
        if ($use_GS) {
            $export_menu->entryconfigure(1, -state => 'normal');
            $export_menu->entryconfigure(2, -state => 'normal');
            for ($i=0; $i<=$#animate_ids; $i++) {
                if ($props{$animate_ids[$i]}{meta} =~
                        /^(data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)$/) {
                    $export_menu->entryconfigure(3, -state => 'normal');
                    last;
                }
            }
        } else {
            $export_menu->entryconfigure(1, -state => 'disabled');
            $export_menu->entryconfigure(2, -state => 'disabled');
            $export_menu->entryconfigure(3, -state => 'disabled');
        }
    }

#   Check the FFmpeg path, if present
    if ($ffmp_path ne "") {
        if (lc($ffmp_path) eq "off") {
            $use_FFmpeg = 0;
            $FFmpeg_off = 1;
        } else {
            $ffmp_path = File::Spec->rel2abs($ffmp_path);
            $error = 0;
            if (! -e $ffmp_path) {
                print "The path to FFmpeg specified in w2anim.ini does not exist.\n";
                $error = 1;
            } elsif (-d $ffmp_path) {
                print "The path to FFmpeg specified in w2anim.ini is a directory.\n";
                $error = 1;
            }
            if (! $error) {
                $FFmpeg_PROG = $ffmp_path;
                $use_FFmpeg  = 1;
            } else {
                if ($FFmpeg_PROG ne "" && -e $FFmpeg_PROG) {
                    print "Using $FFmpeg_PROG instead.\n";
                    $use_FFmpeg = 1;
                } else {
                    $FFmpeg_PROG = "";
                    $use_FFmpeg  = 0;
                }
            }
        }
    }
}


sub write_ini_file {
    my (
        $arrow, $canv_color, $dir, $fill, $fill_color, $ini_file,
        $object_color, $select_color, $slant, $smooth, $underline,
       );

#   Ask the user for the directory where the w2anim.ini file will reside
    $dir = Tkx::tk___chooseDirectory(-parent     => $main,
                                     -title      => "Directory for w2anim.ini File",
                                     -initialdir => $ini_path,
                                    );
    return if (! defined($dir) || $dir eq "");
    if (! -e $dir) {
        return &pop_up_error($main, "Directory does not exist.\n$dir");
    } elsif (! -d $dir) {
        return &pop_up_error($main, "Selection is not a directory.\n$dir");
    } elsif (! -r $dir) {
        return &pop_up_error($main, "Directory is not readable.\n$dir");
    } elsif (! -w $dir) {
        return &pop_up_error($main, "Directory is not writeable.\n$dir");
    }

    $ini_file = File::Spec->rel2abs("w2anim.ini", $dir);
    if (-e $ini_file) {
        return if ( lc(&pop_up_question($main, "Overwrite $ini_file?")) eq "no" );
    }

#   Open the w2anim.ini file and write out its contents
    open (OUT, ">", $ini_file) || return &pop_up_error($main, "Unable to open\n$ini_file");

    $canv_color   = &get_rgb_name($canvas_color);
    $select_color = &get_rgb_name($text_select_color);
    $object_color = &get_rgb_name($default_color);
    $fill_color   = &get_rgb_name($default_fillcolor);
    $slant        = ($default_slant)     ? "italic"  : "normal";
    $underline    = ($default_underline) ? "yes"     : "no";
    $smooth       = ($default_smooth)    ? "rounded" : "standard";
    $fill         = ($default_fill)      ? "yes"     : "no";
    $arrow        = $arrow_options[$default_arrow];

    print OUT << "end_of_input";
# W2 Animator initialization file, version $version

==== CANVAS ====
  width:     $canvas_width
  height:    $canvas_height
  color:     $canv_color
  text_slct: $select_color
  snap2grid: $snap2grid
  grid_spac: $grid_spacing
==== END CANVAS ====

==== FONT DEFAULTS ====
  family:    $default_family
  f_size:    $default_size
  f_weight:  $default_weight
  f_slant:   $slant
  f_under:   $underline
  f_angle:   $default_angle
==== END FONT DEFAULTS ====

==== OBJECT DEFAULTS ====
  ob_width:  $default_width
  ob_color:  $object_color
  ob_corner: $smooth
  ob_fill:   $fill
  ob_fcolor: $fill_color
==== END OBJECT DEFAULTS ====

==== ARROW DEFAULTS ====
  arrow:     $arrow
  center:    $default_ahd1
  side:      $default_ahd2
  halfwidth: $default_ahd3
==== END ARROW DEFAULTS ====

==== CONFIG ====
  tmp_path:  $temp_dir
end_of_input

    if ($GS_off && $GS_PROG eq "") {
        print OUT "  gs_path:   off\n";
    } else {
        print OUT "  gs_path:   $GS_PROG\n";
    }
    if ($FFmpeg_off && $FFmpeg_PROG eq "") {
        print OUT "  ffmp_path: off\n";
    } else {
        print OUT "  ffmp_path: $FFmpeg_PROG\n";
    }
    print OUT "==== END CONFIG ====\n";

#   Close the w2anim.ini file
    close (OUT) || return &pop_up_error($main, "Trouble closing\n$ini_file");
    &pop_up_info($main, "Successfully wrote initialization file:\n$ini_file");
}


sub adjust_main_position {
    my ($geom, $main_h, $main_w, $X, $Y);

    Tkx::update_idletasks();
    $geom = $main->g_wm_geometry();
    ($main_w, $main_h, $X, $Y) = split(/x|\+/, $geom);
    if ($X < -8 || $Y < 0 || $X +$main_w > $screen_width -6 || $Y +$main_h > $screen_height -8) {
        $X    = $screen_width  -$main_w -6 if ($X +$main_w > $screen_width  -6);
        $Y    = $screen_height -$main_h -8 if ($Y +$main_h > $screen_height -8);
        $X    = -8 if ($X < -8);
        $Y    =  0 if ($Y <  0);
        $geom = sprintf("%dx%d+%d+%d", $main_w, $main_h, $X, $Y);
        $main->g_wm_geometry($geom);
    }
}


sub adjust_window_position {
    my ($window) = @_;
    my ($geom, $height, $width, $X, $Y);

    Tkx::update_idletasks();
    $geom = $window->g_wm_geometry();
    ($width, $height, $X, $Y) = split(/x|\+/, $geom);
    if ($X < 5 || $Y < 5 || $X +$width > $screen_width -6 || $Y +$height > $screen_height -8) {
        $X    = $screen_width  -$width  -6 if ($X +$width  > $screen_width  -6);
        $Y    = $screen_height -$height -8 if ($Y +$height > $screen_height -8);
        $X    = 5 if ($X < 5);
        $Y    = 5 if ($Y < 5);
        $geom = sprintf("+%d+%d", $X, $Y);
        $window->g_wm_geometry($geom);
    }
}


sub initialize_canvas_scrollbars {
    my ($geom, $X, $Y);

#   This subroutine initializes the canvas scrollbars either when W2Anim first begins
#   or when a saved W2Anim project is loaded.

    $geom = $main->g_wm_geometry();
    (undef, undef, $X, $Y) = split(/x|\+/, $geom);

    if ($canvas_width <= $screen_width && $canvas_height <= $screen_height) {
        $canvas_xscroll->g_grid_remove();
        $canvas_yscroll->g_grid_remove();
        $max_main_width  = $canvas_width  +6;
        $max_main_height = $canvas_height +6 +$main_footer_height;

    } elsif ($canvas_width > $screen_width -15 && $canvas_height > $screen_height -15) {
        $canvas_xscroll->g_grid();
        $canvas_yscroll->g_grid();
        $max_main_width  = $screen_width  +6;
        $max_main_height = $screen_height +6 +$main_footer_height;

    } elsif ($canvas_width > $screen_width) {
        $canvas_xscroll->g_grid();
        $canvas_yscroll->g_grid_remove();
        $max_main_width  = $screen_width  +6;
        $max_main_height = $canvas_height +21 +$main_footer_height;

    } elsif ($canvas_height > $screen_height) {
        $canvas_xscroll->g_grid_remove();
        $canvas_yscroll->g_grid();
        $max_main_width  = $canvas_width  +21;
        $max_main_height = $screen_height +6 +$main_footer_height;
    }
    $geom = sprintf("%dx%d+%d+%d", $max_main_width, $max_main_height, $X, $Y);
    $main->g_wm_geometry($geom);
    Tkx::wm_maxsize($main, $max_main_width, $max_main_height);
}


sub manage_canvas_scrollbars {
    my ($widget) = @_;
    return if ($widget ne $main_frame);

    $nconfig_events++;
    return if ($nconfig_events > 1);

    Tkx::after_idle(sub {Tkx::after(100, [\&update_canvas_scrollbars]);});
}


sub update_canvas_scrollbars {
    my ($fh, $fw, $geom, $main_dx, $main_dy, $main_h, $main_w, $X, $xscroll, $Y, $yscroll,
        @grid_kids,
       );

#   This subroutine manages the canvas scrollbars in response to a main window frame resize event.
#   It doesn't work perfectly, due to issues with the GUI updates and window configure events.

    $geom = $main->g_wm_geometry();
    ($main_w, $main_h, $X, $Y) = split(/x|\+/, $geom);

    $geom = $main_frame->g_winfo_geometry();
    ($fw, $fh, undef, undef) = split(/x|\+/, $geom);
    @grid_kids = Tkx::SplitList($main_frame->g_grid_slaves());
    $xscroll = (&list_match($canvas_xscroll, @grid_kids) == -1) ? 0 : 1;
    $yscroll = (&list_match($canvas_yscroll, @grid_kids) == -1) ? 0 : 1;

    $main_dx = $main_dy = 0;
    if ($xscroll && $yscroll) {
        if ($fw >= $canvas_width +21 && $fh >= $canvas_height +21) {
            $canvas_xscroll->g_grid_remove();
            $canvas_yscroll->g_grid_remove();
            $max_main_width  -= 15;
            $max_main_height -= 15;
            $main_dx         -= 15;
            $main_dy         -= 15;
        } elsif ($fw >= $canvas_width +21) {
            $canvas_xscroll->g_grid_remove();
            $max_main_height -= 15;
            $main_dy         -= 15;
            if ($fh >= $canvas_height +6) {
                $canvas_yscroll->g_grid_remove();
                $max_main_width -= 15;
                $main_dx        -= 15;
            }
        } elsif ($fh >= $canvas_height +21) {
            $canvas_yscroll->g_grid_remove();
            $max_main_width -= 15;
            $main_dx        -= 15;
            if ($fw >= $canvas_width +6) {
                $canvas_xscroll->g_grid_remove();
                $max_main_height -= 15;
                $main_dy         -= 15;
            }
        }
    } elsif (! $xscroll && ! $yscroll) {
        if ($fw < $canvas_width +6 && $fh < $canvas_height +6) {
            $canvas_xscroll->g_grid();
            $canvas_yscroll->g_grid();
            $max_main_width  += 15;
            $max_main_height += 15;
            $main_dx         += 15;
            $main_dy         += 15;
        } elsif ($fw < $canvas_width +6) {
            $canvas_xscroll->g_grid();
            $max_main_height += 15;
            $main_dy         += 15;
        } elsif ($fh < $canvas_height +6) {
            $canvas_yscroll->g_grid();
            $max_main_width  += 15;
            $main_dx         += 15;
        }
    } elsif ($xscroll) {
        if ($fw >= $canvas_width +6) {
            $canvas_xscroll->g_grid_remove();
            $max_main_height -= 15;
            $main_dy         -= 15;
        }
        if ($fh < $canvas_height +21) {
            $canvas_yscroll->g_grid();
            $max_main_width  += 15;
            $main_dx         += 15;
        }
    } else {
        if ($fw < $canvas_width +21) {
            $canvas_xscroll->g_grid();
            $max_main_height += 15;
            $main_dy         += 15;
        }
        if ($fh >= $canvas_height +6) {
            $canvas_yscroll->g_grid_remove();
            $max_main_width  -= 15;
            $main_dx         -= 15;
        }
    }
    if ($main_dx != 0 || $main_dy != 0) {
        Tkx::wm_maxsize($main, $max_main_width, $max_main_height);
        $geom = sprintf("%dx%d+%d+%d", $main_w +$main_dx, $main_h +$main_dy, $X, $Y);
        $main->g_wm_geometry($geom);
    }
    $nconfig_events = 0;
}


sub update_scrollable_menu {
    my ($parent_menu, $sc_frame, $sc_canvas, $tag, $vsbar) = @_;
    my ($height, $width, $yscroll,
        @grid_kids,
       );

    @grid_kids = Tkx::SplitList($sc_frame->g_grid_slaves());
    $yscroll   = (&list_match($vsbar, @grid_kids) == -1) ? 0 : 1;

    Tkx::update_idletasks();
    (undef, undef, $width, $height) = Tkx::SplitList($sc_canvas->bbox($tag));

    if ($height <= $screen_height -100) {
        $vsbar->g_grid_remove() if ($yscroll);
    } else {
        $vsbar->g_grid() if (! $yscroll);
    }
    $sc_canvas->configure(-width        => $width,
                          -height       => &min($height, $screen_height-100),
                          -scrollregion => [0, 0, $width, $height],
                         );

    &adjust_window_position($parent_menu);
}


sub update_scrollable_tab {
    my ($parent_menu, $sc_tab, $sc_canvas, $tag, $vsbar) = @_;
    my ($height, $width, $yscroll,
        @grid_kids,
       );

    @grid_kids = Tkx::SplitList($sc_tab->g_grid_slaves());
    $yscroll   = (&list_match($vsbar, @grid_kids) == -1) ? 0 : 1;

    Tkx::update_idletasks();
    (undef, undef, $width, $height) = Tkx::SplitList($sc_canvas->bbox($tag));

    if ($height <= &min(350, $screen_height -200)) {
        $vsbar->g_grid_remove() if ($yscroll);
    } else {
        $vsbar->g_grid() if (! $yscroll);
    }
    $sc_canvas->configure(-width        => $width,
                          -height       => &min($height, &min(350, $screen_height-200)),
                          -scrollregion => [0, 0, $width, $height],
                         );

    &adjust_window_position($parent_menu);
}


sub get_xy {
    my ($canv, $x, $y, $snap) = @_;

    $x = &min(&max(3, $canv->canvasx($x)), $canvas_width  +2);
    $y = &min(&max(3, $canv->canvasy($y)), $canvas_height +2);
    if ($snap && $snap2grid) {
        $x = &min(3+ $grid_spacing * &round_to_int(($x-3) /$grid_spacing), $canvas_width  +2);
        $y = &min(3+ $grid_spacing * &round_to_int(($y-3) /$grid_spacing), $canvas_height +2);
    }
    return ($x, $y);
}


sub show_xypos {
    my ($x, $y, $canv, $simple) = @_;
    my ($got_graph, $i, $id, $tol, $x1, $x2, $xloc, $xmax, $xmin, $y1,
        $y2, $yloc, $ymax, $ymin,
        @ids, @tags,
       );

    ($x, $y) = &get_xy($canv, $x, $y, $snap2grid);
    if ($snap2grid) {
        $canv->delete("target");
        $canv->create_rectangle($x-2, $y-2, $x+2, $y+2,
                         -outline => "",
                         -width   => 0,
                         -fill    => &get_rgb_code($anchor_select_color),
                         -tags    => "target");
    }
    $status_line = sprintf("X,Y: %d, %d", $x-3, $y-3);
    return if ($simple);

#   If over a graph, show the internal graph coordinates as well
    $got_graph = 0;
    $tol = 4;
    @ids = Tkx::SplitList($canv->find_overlapping($x-$tol, $y-$tol, $x+$tol, $y+$tol));
    for ($i=$#ids; $i>=0; $i--) {
        @tags = Tkx::SplitList($canv->itemcget($ids[$i], -tags));
        next if (&list_match("working",    @tags) > -1);
        next if (&list_match("target",     @tags) > -1);
        next if (&list_match("select_box", @tags) > -1);
        next if (&list_match("select_pts", @tags) > -1);
        next if (&list_match("zoom_bar",   @tags) > -1);
        if (&list_search("^graph", @tags) > -1) {
            $id = $tags[&list_search("^graph", @tags)];
            $id =~ s/^graph//;
            $id =~ s/_.*$//;
            $got_graph = 1;
            last;
        } else {
            last if (&select_item($canv, $ids[$i], $x, $y, $tol));
        }
    }
    if ($got_graph) {
        return if (! defined($gr_props{$id}));
        ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
        if ($x >= $x1 && $x <= $x2 && $y >= $y1 && $y <= $y2) {
            if ($props{$id}{meta} eq "w2_tdmap") {
                if ($gr_props{$id}{date_axis} eq "Y") {
                    $xmin = $gr_props{$id}{dmin};
                    $xmax = $gr_props{$id}{dmax};
                    if ($gr_props{$id}{dflip}) {
                        $xloc = $xmin +($xmax -$xmin) *(1.0 -($x -$x1) /($x2 -$x1));
                    } else {
                        $xloc = $xmin +($xmax -$xmin) *($x -$x1) /($x2 -$x1);
                    }
                    if ($gr_props{$id}{ttype} eq "Date/Time") {
                        $ymin = &datelabel2jdate($gr_props{$id}{tmin});
                        $ymax = &datelabel2jdate($gr_props{$id}{tmax});
                    } else {
                        $ymin = $gr_props{$id}{tmin};
                        $ymax = $gr_props{$id}{tmax};
                    }
                    if ($gr_props{$id}{tflip}) {
                        $yloc = $ymin +($ymax -$ymin) *(1.0 -($y -$y1) /($y2 -$y1));
                    } else {
                        $yloc = $ymin +($ymax -$ymin) *($y -$y1) /($y2 -$y1);
                    }
                    if ($gr_props{$id}{ttype} eq "Date/Time") {
                        $yloc = &jdate2datelabel($yloc, "Mon-DD-YYYY");
                        $status_line .= sprintf("  [%.2f, %s]", $xloc, $yloc);
                    } else {
                        $status_line .= sprintf("  [%.2f, %.2f]", $xloc, $yloc);
                    }
                } else {
                    $ymin = $gr_props{$id}{dmin};
                    $ymax = $gr_props{$id}{dmax};
                    if ($gr_props{$id}{dflip}) {
                        $yloc = $ymin +($ymax -$ymin) *($y -$y1) /($y2 -$y1);
                    } else {
                        $yloc = $ymin +($ymax -$ymin) *(1.0 -($y -$y1) /($y2 -$y1));
                    }
                    if ($gr_props{$id}{ttype} eq "Date/Time") {
                        $xmin = &datelabel2jdate($gr_props{$id}{tmin});
                        $xmax = &datelabel2jdate($gr_props{$id}{tmax});
                    } else {
                        $xmin = $gr_props{$id}{tmin};
                        $xmax = $gr_props{$id}{tmax};
                    }
                    if ($gr_props{$id}{tflip}) {
                        $xloc = $xmin +($xmax -$xmin) *(1.0 -($x -$x1) /($x2 -$x1));
                    } else {
                        $xloc = $xmin +($xmax -$xmin) *($x -$x1) /($x2 -$x1);
                    }
                    if ($gr_props{$id}{ttype} eq "Date/Time") {
                        $xloc = &jdate2datelabel($xloc, "Mon-DD-YYYY");
                        $status_line .= sprintf("  [%s, %.2f]", $xloc, $yloc);
                    } else {
                        $status_line .= sprintf("  [%.2f, %.2f]", $xloc, $yloc);
                    }
                }
            } else {
                $ymin = $gr_props{$id}{ymin};
                $ymax = $gr_props{$id}{ymax};
                if ($props{$id}{meta} =~ /(data_profile|w2_profile|w2_slice|w2_outflow|vert_wd_zone)/
                    && $gr_props{$id}{ytype} eq "Depth") {
                    $yloc = $ymax *($y -$y1) /($y2 -$y1);
                } else {
                    $yloc = $ymin +($ymax -$ymin) *($y2 -$y) /($y2 -$y1);
                }
                if ($props{$id}{meta} =~ /(data_profile_cmap|w2_profile_cmap|time_series)/
                     && (! defined($gr_props{$id}{xtype}) || $gr_props{$id}{xtype} eq "Date/Time")) {
                    $xmin = &datelabel2jdate($gr_props{$id}{xmin});
                    $xmax = &datelabel2jdate($gr_props{$id}{xmax});
                    $xloc = $xmin +($xmax -$xmin) *($x -$x1) /($x2 -$x1);
                    $xloc = &jdate2datelabel($xloc, "Mon-DD-YYYY");
                    $status_line .= sprintf("  [%s, %.2f]", $xloc, $yloc);
                } else {
                    $xmin = $gr_props{$id}{xmin};
                    $xmax = $gr_props{$id}{xmax};
                    if ($props{$id}{meta} =~ /w2_slice|w2_wlevels/ && $gr_props{$id}{xflip}) {
                        $xloc = $xmin +($xmax -$xmin) *(1.0 -($x -$x1) /($x2 -$x1));
                    } else {
                        $xloc = $xmin +($xmax -$xmin) *($x -$x1) /($x2 -$x1);
                    }
                    $status_line .= sprintf("  [%.2f, %.2f]", $xloc, $yloc);
                }
            }
        }
    }
}


sub make_crosshair {
    my ($xo, $yo, $canv, $ang) = @_;
    my ($i, $next_id, $top_id, $x1, $x2, $y1, $y2,
        @items, @tags,
       );

    $canv->delete("crosshair");
    $x1 = $xo -10 *cos($ang *pi/180.);
    $y1 = $yo +10 *sin($ang *pi/180.);
    $x2 = $xo +10 *cos($ang *pi/180.);
    $y2 = $yo -10 *sin($ang *pi/180.);
    $canv->create_line($x1, $y1, $x2, $y2,
             -fill  => &get_rgb_code($anchor_select_color),
             -width => 1,
             -tags  => "crosshair");
    $x1 = $xo -10 *cos(($ang +90) *pi/180.);
    $y1 = $yo +10 *sin(($ang +90) *pi/180.);
    $x2 = $xo +10 *cos(($ang +90) *pi/180.);
    $y2 = $yo -10 *sin(($ang +90) *pi/180.);
    $canv->create_line($x1, $y1, $x2, $y2,
             -fill  => &get_rgb_code($anchor_select_color),
             -width => 1,
             -tags  => "crosshair");
    
    @items = Tkx::SplitList($canv->find_overlapping($xo, $yo, $xo, $yo));
    for ($i=$#items; $i>=0; $i--) {
        @tags = Tkx::SplitList($canv->itemcget($items[$i], -tags));
        if ( &list_match("anchor", @tags) > -1 ) {
            $top_id = $canv->find_above($items[$i]);
            if ($top_id ne "") {
                while (($next_id = $canv->find_above($top_id)) ne "") {
                    $top_id = $next_id;
                }
                $canv->raise($items[$i], $top_id);
            }
            last;
        }
    }
}


sub find_rect_from_text_or_image {
    my ($canv, $id) = @_;
    my ($anc, $ang, $ang2, $d, $hh, $hw, $i, $type,
        $x, $x1, $x2, $xo, $y, $y1, $y2, $yo,
        @coords, @new_coords, @xvals, @yvals,
       );

    $type = $props{$id}{type};
    $xo   = $props{$id}{x};
    $yo   = $props{$id}{y};
    $anc  = $props{$id}{anchor};
    $ang  = $props{$id}{angle};

    if ($type eq "text") {
        $canv->itemconfigure($id, -angle => 0) if ($ang != 0);
        ($x1, $y1, $x2, $y2) = Tkx::SplitList($canv->bbox($id));
        $canv->itemconfigure($id, -angle => $ang) if ($ang != 0);
        $hw = abs($x2-$x1)/2.;
        $hh = abs($y2-$y1)/2.;
    } else {
        $hw = ($props{$id}{iw} -1)/2.;
        $hh = ($props{$id}{ih} -1)/2.;
    }

#   Set the encompassing rectangle for an un-rotated object
#   Estimate locations based on anchor (n, ne, e, se, s, sw, w, nw, center)
    if ($anc eq 'nw') {
        @coords = ($xo, $yo, $xo+2*$hw, $yo, $xo+2*$hw, $yo+2*$hh, $xo, $yo+2*$hh);
    } elsif ($anc eq 'n') {
        @coords = ($xo-$hw, $yo, $xo+$hw, $yo, $xo+$hw, $yo+2*$hh, $xo-$hw, $yo+2*$hh);
    } elsif ($anc eq 'ne') {
        @coords = ($xo-2*$hw, $yo, $xo, $yo, $xo, $yo+2*$hh, $xo-2*$hw, $yo+2*$hh);
    } elsif ($anc eq 'e') {
        @coords = ($xo-2*$hw, $yo-$hh, $xo, $yo-$hh, $xo, $yo+$hh, $xo-2*$hw, $yo+$hh);
    } elsif ($anc eq 'se') {
        @coords = ($xo-2*$hw, $yo-2*$hh, $xo, $yo-2*$hh, $xo, $yo, $xo-2*$hw, $yo);
    } elsif ($anc eq 's') {
        @coords = ($xo-$hw, $yo-2*$hh, $xo+$hw, $yo-2*$hh, $xo+$hw, $yo, $xo-$hw, $yo);
    } elsif ($anc eq 'sw') {
        @coords = ($xo, $yo-2*$hh, $xo+2*$hw, $yo-2*$hh, $xo+2*$hw, $yo, $xo, $yo);
    } elsif ($anc eq 'w') {
        @coords = ($xo, $yo-$hh, $xo+2*$hw, $yo-$hh, $xo+2*$hw, $yo+$hh, $xo, $yo+$hh);
    } else {
        @coords = ($xo-$hw, $yo-$hh, $xo+$hw, $yo-$hh, $xo+$hw, $yo+$hh, $xo-$hw, $yo+$hh);
    }

#   Rotate the rectangle, if needed
    if ($ang != 0) {
        @new_coords = ();
        for ($i=0; $i<4; $i++) {
            $x = $coords[2*$i];
            $y = $coords[2*$i+1];
            if ($x == $xo && $y == $yo) {
                push (@new_coords, $x, $y);
                next;
            }
            $d = sqrt(($x-$xo)*($x-$xo) + ($y-$yo)*($y-$yo));
            if ($x == $xo) {
                $ang2 = ($y > $yo) ? 270 : 90;
            } elsif ($y == $yo) {
                $ang2 = ($x > $xo) ? 0 : 180;
            } else {
                $ang2 = (180./pi)*atan2(($yo-$y),($x-$xo));
            }
            $ang2 += 360 if ($ang2 < 0);
            $x = $xo +$d *cos(($ang2 +$ang) *pi/180.);
            $y = $yo -$d *sin(($ang2 +$ang) *pi/180.);
            push (@new_coords, $x, $y);
        }
        @coords = @new_coords;
    }

#   Find the center point
    if ($anc eq 'center') {
        $props{$id}{xc} = $xo;
        $props{$id}{yc} = $yo;
    } else {
        @xvals = @yvals = ();
        for ($i=0; $i<4; $i++) {
            push (@xvals, $coords[2*$i]  );
            push (@yvals, $coords[2*$i+1]);
        }
        $props{$id}{xc} = (&min(@xvals) + &max(@xvals))/2.;
        $props{$id}{yc} = (&min(@yvals) + &max(@yvals))/2.;
    }
    return @coords;
}


sub get_coords {
    my ($canv, $id, $method) = @_;
    my ($type, @coords);

    $method = "bbox" if (! defined($method) || $method ne "pts");
    $type   = $props{$id}{type};
    @coords = @{ $props{$id}{coordlist} } if ($type !~ /^(text|image)$/);

    if ($type eq "text" || $type eq "image") {
        @coords = &find_rect_from_text_or_image($canv, $id);

    } elsif ($type eq "circle" || ($type eq "graph" && $method eq "pts")) {
        push(@coords, $coords[0], $coords[3]);
        splice(@coords, 2, 0, $coords[2], $coords[1]);

    } elsif ($method eq "bbox") {
        if ($type =~ /^(ellipse|diamond)$/) {
            @coords = &find_rect_from_shape(\@coords, $props{$id}{angle});

        } elsif ($type =~ /^(polygon|polyline)$/) {
            @coords = &find_rect_from_poly(\@coords, $props{$id}{angle});

        } elsif ($type eq "graph") {
            @coords = Tkx::SplitList($canv->bbox("graph" . $id));
            push(@coords, $coords[0], $coords[3]);
            splice(@coords, 2, 0, $coords[2], $coords[1]);
        }
    }
    return @coords;
}


sub get_group_type {
    my ($id, @tags) = @_;
    my ($label, $grp);

    if ($props{$id}{meta} eq "data_profile") {
        $label = "Profile Graph";
    } elsif ($props{$id}{meta} eq "data_profile_cmap") {
        $label = "Profile Colormap";
    } elsif ($props{$id}{meta} eq "w2_profile") {
        $label = "W2 Profile Graph";
    } elsif ($props{$id}{meta} eq "w2_profile_cmap") {
        $label = "W2 Profile Colormap";
    } elsif ($props{$id}{meta} eq "w2_slice") {
        $label = "W2 Longitudinal Slice";
    } elsif ($props{$id}{meta} eq "w2_tdmap") {
        $label = "W2 Time/Distance Map";
        if ($props{$id}{map_type} =~ /^(parmdiff|filediff)$/) {
            $label = "W2 Time/Distance Difference Map";
        }
    } elsif ($props{$id}{meta} eq "w2_outflow") {
        $label = "W2 Outflow Profile";
    } elsif ($props{$id}{meta} eq "w2_wlevels") {
        $label = "W2 Water Levels Graph";
    } elsif ($props{$id}{meta} eq "vert_wd_zone") {
        $label = "Wthdrawal Zone Graph";
    } elsif ($props{$id}{meta} eq "linked_time_series") {
        $label = "Linked Time Series Graph";
    } elsif ($props{$id}{meta} eq "time_series") {
        $label = "Time Series Graph";
    } else {
        $label = "";
    }
    ($grp = $tags[&list_search("^graph.*_", @tags)]) =~ s/^graph.*_//;
    if ($grp eq "gtitle") {
        $label .= " - Graph Title";
    } elsif ($grp eq "date") {
        $label .= " - Graph Subtitle";
    } elsif ($grp eq "xaxisTitle") {
        $label .= " - X Axis Title";
    } elsif ($grp eq "yaxisTitle") {
        $label .= " - Y Axis Title";
    } elsif ($grp eq "saxisTitle") {
        $label .= " - Segment Axis Title";
    } elsif ($grp eq "xaxis") {
        $label .= " - X Axis";
    } elsif ($grp eq "yaxis") {
        $label .= " - Y Axis";
    } elsif ($grp eq "saxis") {
        $label .= " - Segment Axis";
    } elsif ($grp eq "colorKeyTitle") {
        $label .= " - Color Key Title";
    } elsif ($grp eq "colorKey") {
        $label .= " - Color Key";
    } elsif ($grp eq "legend") {
        $label .= " - Legend";
    }
    $label =~ s/^ - // if ($label =~ /^ - /);
    return $label;
}


sub numeric_entry_only {
    my ($entry, $auto) = @_;
    my ($i, $len, $pos, $tmp);

    $auto = 0 if (! defined($auto) || $auto != 1);

#   An entry of "auto" is okay
    $tmp = $entry->get();
    if ($auto) {
        return if ($tmp eq 'auto');
        if ($tmp =~ /^auto/) {
            $len = length($tmp);
            for ($i=$len-1; $i>=4; $i--) {
                $entry->delete($i,$i+1);
            }
            return;
        }
        if ($tmp eq 'a') {
            $entry->insert(1,'uto');
            return;
        }
        if ($tmp eq 'A') {
            $entry->delete(0,1);
            $entry->insert(0,'auto');
            return;
        }
    }

#   Make sure that if a "-" is present, it is first
    if ($tmp =~ /-/ && length($tmp) > 1) {
        $pos = index($tmp, "-", 1);
        if ($pos > 0) {
            $entry->delete($pos,$pos+1);
        }
    }

#   Remove any characters other than -, 0-9, and .
    $tmp = $entry->get();
    if ($tmp =~ /[^-0-9\.]/) {
        $len = length($tmp);
        for ($i=$len-1; $i>=0; $i--) {
            if (substr($tmp,$i,1) =~ /[^-0-9\.]/) {
                $entry->delete($i,$i+1);
            }
        }
    }

#   Remove any further instances of .
    $tmp = $entry->get();
    if ($tmp =~ /\./) {
        $pos = index($tmp, ".");
        $len = length($tmp);
        for ($i=$len-1; $i>$pos; $i--) {
            if (substr($tmp,$i,1) eq ".") {
                $entry->delete($i,$i+1);
            }
        }
    }
}


sub reset_bindings {
    my ($geom, $X, $Y);

    $canvas->g_bind("<Motion>",               "");
    $canvas->g_bind("<Shift-Motion>",         "");
    $canvas->g_bind("<Control-Motion>",       "");
    $canvas->g_bind("<Control-Shift-Motion>", "");
    $canvas->g_bind("<Button1-Motion>",       "");
    $canvas->g_bind("<Button-1>",             "");
    $canvas->g_bind("<ButtonRelease-1>",      "");
    $canvas->g_bind("<Shift-Button-1>",       "");
    $canvas->g_bind("<Double-Button-1>",      "");
    $canvas->g_bind("<Button-3>",             "");

    $canvas->delete($popmenu) if ($popmenu);

    $canvas->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"), $canvas, "menu" ]);

    $canvas->configure(-cursor => $cursor_norm);
    if (defined($zoom_tb) && Tkx::winfo_exists($zoom_tb)) {
        if ($zoom_tb->g_wm_title() eq "Zoom toolbar") {
            if ($zoom_tip =~ /(Select|Draw)/) {
                $geom = $zoom_tb->g_wm_geometry();
                (undef, $X, $Y) = split(/\+/, $geom);
                &zoom_toolbar($X, $Y);
            }
        }
    }
    $status_line = "";
}


sub altp_popup {
    my ($x, $y, $menuX, $menuY, $canv) = @_;
    my ($i, $id, $tol,
        @ids, @tags,
       );

    ($x, $y) = &get_xy($canv, $x, $y, 0);
    $id  = "";
    $tol = 4;

#   The find method will find a polygon for every point inside that polygon
#   regardless of whether the polygon is filled, so some extra searching is
#   required when polygons are used.  Rectangles, diamonds, polygons, and
#   ellipses are polygons in this program.

    @ids = Tkx::SplitList($canv->find_overlapping($x-$tol, $y-$tol, $x+$tol, $y+$tol));
    for ($i=$#ids; $i>=0; $i--) {
        @tags = Tkx::SplitList($canv->itemcget($ids[$i], -tags));
        next if (&list_match("working",    @tags) > -1);
        next if (&list_match("select_box", @tags) > -1);
        next if (&list_match("select_pts", @tags) > -1);
        next if (&list_match("zoom_bar",   @tags) > -1);
        if (&list_search("^graph", @tags) > -1) {
            $id = $tags[&list_search("^graph", @tags)];
            $id =~ s/^graph//;
            $id =~ s/_.*$//;
            last;

        } elsif (&select_item($canv, $ids[$i], $x, $y, $tol)) {
            $id = $ids[$i];
            last;
        }
    }
    &popup_menu($menuX, $menuY, $canv, $id);
}


sub start_anew {
    my ($answer, $different, $i, $tmp_file, @id_list);

#   Are any objects on the canvas labeled "keep"?
#   Does the user wish to save them before starting anew?
    @id_list = Tkx::SplitList($canvas->find_withtag("keep"));
    if ($#id_list >= 0) {
        $tmp_file = "";
        if (-e $autosave_file) {
            ($tmp_file = $autosave_file) =~ s/\.w2a$/tmp\.w2a/;
            copy($autosave_file, $tmp_file);
        }
        &save_file($autosave_file, 1);

      # If an autosave file already existed, push it to autosave_file2 if different
        if ($tmp_file ne "") {
            $different = &compare_saved($autosave_file, $tmp_file);
            if ($different) {
                unlink $autosave_file2 if (-e $autosave_file2);
                move($tmp_file, $autosave_file2);
                $autosave_menu->entryconfigure('end', -state => 'normal');
            } else {
                unlink $tmp_file;
            }
        }
        $autosave_menu->entryconfigure(8, -state => 'normal');  # entry 8 is "Revert, recent"

      # Compare current project file to saved file
        if ($savefile ne "" && -e $savefile) {
            $different = &compare_saved($autosave_file, $savefile);
            if ($different) {
                $answer = &pop_up_question($main,
                               "Current project is different than\n"
                             . "saved project file. Do you want to save\n"
                             . "the current project before starting over?");
                return if (lc($answer) eq "yes");
            }
        } else {
            $answer = &pop_up_question($main,
                           "Current project has not been saved.\n"
                         . "Do you want to save it before starting over?");
            return if (lc($answer) eq "yes");
        }
    }

#   Delete existing stuff on the canvas
    @id_list = Tkx::SplitList($canvas->find_all());
    for ($i=0; $i<=$#id_list; $i++) {
        $canvas->delete($id_list[$i]);
    }
    undef $ts_datemin;
    undef $ts_datemax;
    undef $cmap_datemin;
    undef $cmap_datemax;
    undef @dates;
    undef @id_list;
    undef %grid;
    undef %props;
    undef %gr_props;
    undef %link_props;
    undef $old_id if (defined($old_id));
    @animate_ids = ();
    $graph_num   = -1;
    $savefile    = "";
    $global_dt_limits = 0;
    $global_dt_begin  = $global_dt_end = "na";
    $anim_tb_status   = "stopped";
    $delay_autosave   = 0;
    $export_menu->entryconfigure(3, -state => 'disabled');
    $pref_menu->entryconfigure(0,   -state => 'disabled');

#   Kill any open pop-up menus that might be tied to old objects
#   Reset the general and canvas defaults
    &remove_and_restore_menus();

#   Reset canvas to defaults
    $canvas->configure(-background   => &get_rgb_code($default_canvas_color),
                       -width        => $default_canvas_width,
                       -height       => $default_canvas_height,
                       -scrollregion => [0, 0, $default_canvas_width, $default_canvas_height],
                      );
    &initialize_canvas_scrollbars();
    &adjust_main_position();

#   Clear the title bar of any file name
    $main->g_wm_title("W2 Animator");
}


sub remove_and_restore_menus {

    $canvas_width      = $default_canvas_width;
    $canvas_height     = $default_canvas_height;
    $canvas_color      = $default_canvas_color;
    $snap2grid         = $default_snap2grid;
    $grid_spacing      = $default_grid_spacing;
    $text_select_color = $default_text_select_color;

    $default_family    = $save_family;
    $default_size      = $save_size;
    $default_weight    = $save_weight;
    $default_slant     = $save_slant;
    $default_underline = $save_underline;
    $default_angle     = $save_angle;
    $default_width     = $save_width;
    $default_color     = $save_color;
    $default_smooth    = $save_smooth;
    $default_fill      = $save_fill;
    $default_fillcolor = $save_fillcolor;
    $default_arrow     = $save_arrow;
    $default_ahd1      = $save_ahd1;
    $default_ahd2      = $save_ahd2;
    $default_ahd3      = $save_ahd3;

    if (defined($default_props_menu) && Tkx::winfo_exists($default_props_menu)) {
        if ($default_props_menu->g_wm_title() eq "Set Defaults") {
            $default_props_menu->g_destroy();
            undef $default_props_menu;
        }
    }
    if (defined($canvas_props_menu) && Tkx::winfo_exists($canvas_props_menu)) {
        if ($canvas_props_menu->g_wm_title() eq "Canvas Properties") {
            $canvas_props_menu->g_destroy();
            undef $canvas_props_menu;
        }
    }
    if (defined($date_limits_menu) && Tkx::winfo_exists($date_limits_menu)) {
        if ($date_limits_menu->g_wm_title() eq "Global Date Limits") {
            $date_limits_menu->g_destroy();
            undef $date_limits_menu;
        }
    }
    if (defined($animate_tb) && Tkx::winfo_exists($animate_tb)) {
        if ($animate_tb->g_wm_title() eq "Animation toolbar") {
            $animate_tb->g_destroy();
            undef $animate_tb;
        }
    }
    if (defined($zoom_tb) && Tkx::winfo_exists($zoom_tb)) {
        if ($zoom_tb->g_wm_title() eq "Zoom toolbar") {
            $zoom_tb->g_destroy();
            undef $zoom_tb;
        }
    }
    if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
        if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
            $graph_props_menu->g_destroy();
            undef $graph_props_menu;
        }
    }
    if (defined($w2profile_setup_menu) && Tkx::winfo_exists($w2profile_setup_menu)) {
        if ($w2profile_setup_menu->g_wm_title() eq "W2 Profile Setup") {
            $w2profile_setup_menu->g_destroy();
            undef $w2profile_setup_menu;
        }
    }
    if (defined($w2profile_mod_menu) && Tkx::winfo_exists($w2profile_mod_menu)) {
        if ($w2profile_mod_menu->g_wm_title() eq "Modify W2 Profile") {
            $w2profile_mod_menu->g_destroy();
            undef $w2profile_mod_menu;
        }
    }
    if (defined($w2slice_setup_menu) && Tkx::winfo_exists($w2slice_setup_menu)) {
        if ($w2slice_setup_menu->g_wm_title() eq "W2 Longitudinal Slice Setup"
             || $w2slice_setup_menu->g_wm_title() eq "W2 Time/Distance Map Setup"
             || $w2slice_setup_menu->g_wm_title() eq "W2 Water Levels Graph Setup") {
            $w2slice_setup_menu->g_destroy();
            undef $w2slice_setup_menu;
        }
    }
    if (defined($w2slice_mod_menu) && Tkx::winfo_exists($w2slice_mod_menu)) {
        if ($w2slice_mod_menu->g_wm_title() eq "Modify W2 Longitudinal Slice") {
            $w2slice_mod_menu->g_destroy();
            undef $w2slice_mod_menu;
        }
    }
    if (defined($w2tdmap_setup_menu) && Tkx::winfo_exists($w2tdmap_setup_menu)) {
        if ($w2tdmap_setup_menu->g_wm_title() eq "W2 Time/Distance Map Setup") {
            $w2tdmap_setup_menu->g_destroy();
            undef $w2tdmap_setup_menu;
        }
    }
    if (defined($w2tdmap_diff_menu) && Tkx::winfo_exists($w2tdmap_diff_menu)) {
        if ($w2tdmap_diff_menu->g_wm_title() eq "W2 Time/Distance Difference Setup") {
            $w2tdmap_diff_menu->g_destroy();
            undef $w2tdmap_diff_menu;
        }
    }
    if (defined($w2tdmap_mod_menu) && Tkx::winfo_exists($w2tdmap_mod_menu)) {
        if ($w2tdmap_mod_menu->g_wm_title() eq "Modify W2 Time/Distance Map") {
            $w2tdmap_mod_menu->g_destroy();
            undef $w2tdmap_mod_menu;
        }
    }
    if (defined($w2tdmap_undo_menu) && Tkx::winfo_exists($w2tdmap_undo_menu)) {
        if ($w2tdmap_undo_menu->g_wm_title() eq "W2 Time/Distance Map - Undo Difference") {
            $w2tdmap_undo_menu->g_destroy();
            undef $w2tdmap_undo_menu;
        }
    }
    if (defined($w2tdmap_rev_menu) && Tkx::winfo_exists($w2tdmap_rev_menu)) {
        if ($w2tdmap_rev_menu->g_wm_title() eq "W2 Time/Distance Map - Reverse Difference") {
            $w2tdmap_rev_menu->g_destroy();
            undef $w2tdmap_rev_menu;
        }
    }
    if (defined($profile_setup_menu) && Tkx::winfo_exists($profile_setup_menu)) {
        if ($profile_setup_menu->g_wm_title() eq "Profile Setup") {
            $profile_setup_menu->g_destroy();
            undef $profile_setup_menu;
        }
    }
    if (defined($wdzone_setup_menu) && Tkx::winfo_exists($wdzone_setup_menu)) {
        if ($wdzone_setup_menu->g_wm_title() eq "Withdrawal Zone Setup") {
            $wdzone_setup_menu->g_destroy();
            undef $wdzone_setup_menu;
        }
    }
    if (defined($w2outflow_setup_menu) && Tkx::winfo_exists($w2outflow_setup_menu)) {
        if ($w2outflow_setup_menu->g_wm_title() eq "W2 Layer Outflows Setup") {
            $w2outflow_setup_menu->g_destroy();
            undef $w2outflow_setup_menu;
        }
    }
    if (defined($w2levels_setup_menu) && Tkx::winfo_exists($w2levels_setup_menu)) {
        if ($w2levels_setup_menu->g_wm_title() eq "W2 Water Levels Graph Setup"
             || $w2levels_setup_menu->g_wm_title() eq "Modify W2 Water Levels Graph") {
            $w2levels_setup_menu->g_destroy();
            undef $w2levels_setup_menu;
        }
    }
    if (defined($text_props_menu) && Tkx::winfo_exists($text_props_menu)) {
        if ($text_props_menu->g_wm_title() eq "Text Properties") {
            $text_props_menu->g_destroy();
            undef $text_props_menu;
        }
    }
    if (defined($object_props_menu) && Tkx::winfo_exists($object_props_menu)) {
        if ($object_props_menu->g_wm_title() eq "Object Properties") {
            $object_props_menu->g_destroy();
            undef $object_props_menu;
        }
    }
    if (defined($edit_link_menu) && Tkx::winfo_exists($edit_link_menu)) {
        if ($edit_link_menu->g_wm_title() eq "Add or Edit Link") {
            $edit_link_menu->g_destroy();
            undef $edit_link_menu;
        }
    }
    if (defined($edit_stat_link_menu) && Tkx::winfo_exists($edit_stat_link_menu)) {
        if ($edit_stat_link_menu->g_wm_title() eq "Add or Edit Goodness-of-Fit Link") {
            $edit_stat_link_menu->g_destroy();
            undef $edit_stat_link_menu;
        }
    }
    if (defined($add_ts_link_menu) && Tkx::winfo_exists($add_ts_link_menu)) {
        if ($add_ts_link_menu->g_wm_title() eq "Add Time Series Link") {
            $add_ts_link_menu->g_destroy();
            undef $add_ts_link_menu;
        }
    }
    if (defined($add_ts_data_menu) && Tkx::winfo_exists($add_ts_data_menu)) {
        if ($add_ts_data_menu->g_wm_title() eq "Add Time Series Data") {
            $add_ts_data_menu->g_destroy();
            undef $add_ts_data_menu;
        }
    }
    if (defined($add_ts_graph_menu) && Tkx::winfo_exists($add_ts_graph_menu)) {
        if ($add_ts_graph_menu->g_wm_title() eq "Add Time Series Graph") {
            $add_ts_graph_menu->g_destroy();
            undef $add_ts_graph_menu;
        }
    }
    if (defined($add_ref_data_menu) && Tkx::winfo_exists($add_ref_data_menu)) {
        if ($add_ref_data_menu->g_wm_title() eq "Add Reference Profile Data") {
            $add_ref_data_menu->g_destroy();
            undef $add_ref_data_menu;
        }
    }
    if (defined($ref_stats_menu) && Tkx::winfo_exists($ref_stats_menu)) {
        if ($ref_stats_menu->g_wm_title() eq "Choose Profile Fit Statistics") {
            $ref_stats_menu->g_destroy();
            undef $ref_stats_menu;
        }
    }
    if (defined($ref_stats_window) && Tkx::winfo_exists($ref_stats_window)) {
        if ($ref_stats_window->g_wm_title() eq "Profile Goodness-of-Fit Statistics") {
            $ref_stats_window->g_destroy();
            undef $ref_stats_window;
        }
    }
    if (defined($ref_stats_interp_window) && Tkx::winfo_exists($ref_stats_interp_window)) {
        if ($ref_stats_interp_window->g_wm_title()
                eq "Profile Goodness-of-Fit Statistics (Vertically Interpolated)") {
            $ref_stats_interp_window->g_destroy();
            undef $ref_stats_interp_window;
        }
    }
    if (defined($convert_diff_menu) && Tkx::winfo_exists($convert_diff_menu)) {
        if ($convert_diff_menu->g_wm_title() eq "Convert to Difference") {
            $convert_diff_menu->g_destroy();
            undef $convert_diff_menu;
        }
    }
    if (defined($undo_diff_menu) && Tkx::winfo_exists($undo_diff_menu)) {
        if ($undo_diff_menu->g_wm_title() eq "Undo Difference") {
            $undo_diff_menu->g_destroy();
            undef $undo_diff_menu;
        }
    }
    if (defined($object_infobox) && Tkx::winfo_exists($object_infobox)) {
        if ($object_infobox->g_wm_title() eq "Object Info") {
            $object_infobox->g_destroy();
            undef $object_infobox;
        }
    }
    if (defined($choose_sets_menu) && Tkx::winfo_exists($choose_sets_menu)) {
        if ($choose_sets_menu->g_wm_title() eq "Choose Datasets for Fit Statistics") {
            $choose_sets_menu->g_destroy();
            undef $choose_sets_menu;
        }
    }
    if (defined($ts_stats_window) && Tkx::winfo_exists($ts_stats_window)) {
        if ($ts_stats_window->g_wm_title() eq "TS Goodness-of-Fit Statistics") {
            $ts_stats_window->g_destroy();
            undef $ts_stats_window;
        }
    }
    if (defined($scale_output_menu) && Tkx::winfo_exists($scale_output_menu)) {
        if ($scale_output_menu->g_wm_title() eq "Select and Scale Output") {
            $scale_output_menu->g_destroy();
            undef $scale_output_menu;
        }
    }
    if (defined($configure_helper_menu) && Tkx::winfo_exists($configure_helper_menu)) {
        if ($configure_helper_menu->g_wm_title() eq "Configure Helper Apps") {
            $configure_helper_menu->g_destroy();
            undef $configure_helper_menu;
        }
    }
    if (defined($helper_note_win) && Tkx::winfo_exists($helper_note_win)) {
        if ($helper_note_win->g_wm_title() eq "Helper Program Problem") {
            $helper_note_win->g_destroy();
            undef $helper_note_win;
        }
    }
    if (defined($helper_search_win) && Tkx::winfo_exists($helper_search_win)) {
        if ($helper_search_win->g_wm_title() eq "Helper Program AutoSearch") {
            $helper_search_win->g_destroy();
            undef $helper_search_win;
        }
    }
}


sub create_progress_bar {
    my ($parent, $obj_id, $pbar_length, $pbar_max, $title) = @_;
    my ($geom, $pbar, $pbar_frame, $pbar_window, $X, $x1, $x2, $Y, $y1, $y2);

#   Get placement geometry
    $geom = $parent->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    ($x1, $y1, $x2, $y2) = @{ $props{$obj_id}{coordlist} };
    $geom = sprintf("+%d+%d", $X+($x1+$x2)/2-($pbar_length/2), $Y+($y1+$y2)/2);

#   Create progress bar and its toplevel window
    $pbar_window = $parent->new_toplevel();
    $pbar_window->g_wm_transient($parent);
    $pbar_window->g_wm_title($title);
    $pbar_window->g_wm_geometry($geom);
    $pbar_window->configure(-cursor => $cursor_wait);
    $pbar_window->g_focus;

    ($pbar_frame = $pbar_window->new_frame(
                        -borderwidth => 2,
                        -relief      => 'groove',
                   ))->g_pack(-anchor => 'nw', -expand => 1, -fill => 'x');
    ($pbar = $pbar_frame->new_ttk__progressbar(
                        -orient  => 'horizontal',
                        -length  => $pbar_length,
                        -mode    => 'determinate',
                        -value   => 0,
                        -maximum => $pbar_max,
                     ))->g_pack();

#   Initialize status line and place a busy hold on the parent window
    $status_line = $title . " line 1";
    Tkx::tk_busy_hold($parent, -cursor => $cursor_wait);
    Tkx::update();
    Tkx::wm_resizable($pbar_window,0,0);

    return ($pbar_window, $pbar);
}


sub update_progress_bar {
    my ($pbar, $val, $dt) = @_;

    $pbar->configure(-value => $val);
    if (defined($dt)) {
        $status_line =~ s/ \d+$/ $dt/;
    } else {
        $status_line =~ s/ \d+$/ $val/;
    }
    Tkx::update_idletasks();
}


sub reset_progress_bar {
    my ($pbar, $pbar_max, $txt) = @_;

    $pbar->configure(-value   => 0,
                     -maximum => $pbar_max);
    $status_line = $txt;
    Tkx::update_idletasks();
}


sub destroy_progress_bar {
    my ($parent, $pbar_window) = @_;

    $pbar_window->g_destroy();
    $status_line = "";
    Tkx::tk_busy_forget($parent);
    Tkx::update();
}


{
    my ($gif_frames);

    sub create_alt_progress_bar {
        my ($parent, $obj_id, $title) = @_;
        my (
            $geom, $pbar, $pbar_frame, $pbar_img, $pbar_window, $X, $x1, $x2, $Y,
            $y1, $y2,
            );

        $gif_frames = 80;

#       Get placement geometry
        $geom = $parent->g_wm_geometry();
        (undef, $X, $Y) = split(/\+/, $geom);
        ($x1, $y1, $x2, $y2) = @{ $props{$obj_id}{coordlist} };
        $geom = sprintf("+%d+%d", $X+($x1+$x2)/2-175, $Y+($y1+$y2)/2);

#       Create progress bar and its toplevel window
        $pbar_window = $parent->new_toplevel();
        $pbar_window->g_wm_transient($parent);
        $pbar_window->g_wm_title($title);
        $pbar_window->g_wm_geometry($geom);
        $pbar_window->configure(-cursor => $cursor_wait);
        $pbar_window->g_focus;

        ($pbar_frame = $pbar_window->new_frame(
                            -borderwidth => 2,
                            -relief      => 'groove',
                       ))->g_pack(-anchor => 'nw', -expand => 1, -fill => 'x');

        $pbar_img = Tkx::image_create_photo(-file   => "${prog_path}images/pbar.gif",
                                            -format => "gif -index 0");
        $pbar_img = Tkx::widget->new($pbar_img);
        ($pbar = $pbar_frame->new_label(-image => $pbar_img,
                                        ))->g_pack(-side => 'left');

#       Initialize status line and place a busy hold on the parent window
        $status_line = $title . " line 1";
        Tkx::tk_busy_hold($parent, -cursor => $cursor_wait);
        Tkx::update();
        Tkx::wm_resizable($pbar_window,0,0);

        return ($pbar_window, $pbar, $pbar_img);
    }

    sub update_alt_progress_bar {
        my ($img, $val, $nf) = @_;

        $nf = ($nf < $gif_frames-1) ? $nf+1 : 0;
        $img->configure(-format => "gif -index $nf");
        $status_line =~ s/ \d+$/ $val/;
        Tkx::update_idletasks();

        return $nf;
    }
}


################################################################################
#
# Object drawing, moving, and rotation
#
################################################################################

sub draw {
    my ($type, $meta) = @_;

    &forget_drawing('');

    $meta = "" if (! defined($meta));
    $canvas->g_bind("<Motion>",   "");
    $canvas->g_bind("<Motion>",   [ \&show_xypos,    Tkx::Ev("%x","%y"),           $canvas, 0 ]);
    $canvas->g_bind("<Button-1>", [ \&start_drawing, Tkx::Ev("%X","%Y","%x","%y"), $canvas, $type, $meta ]);
    $canvas->g_bind("<Button-3>", [ \&forget_drawing, '' ]);
    if ($type eq "text") {
        $canvas->configure(-cursor => $cursor_text);
    } else {
        $canvas->configure(-cursor => $cursor_draw);
    }
}


sub start_drawing {
    my ($X, $Y, $x, $y, $canv, $type, $meta) = @_;
    my ($id);

    ($x, $y) = &get_xy($canv, $x, $y, $snap2grid);
    $canv->delete("target");

    if ($type eq "line") {
        $id = $canv->create_line($x, $y, $x, $y,
                 -fill       => &get_rgb_code($default_color),
                 -width      => $default_width,
                 -arrow      => $arrow_type[$default_arrow],
                 -arrowshape => [ $default_ahd1, $default_ahd2, $default_ahd3 ],
                 -tags       => "working");
        $props{$id}{type}      = $type;
        $props{$id}{x}         = $x;
        $props{$id}{y}         = $y;
        $props{$id}{xc}        = $x;
        $props{$id}{yc}        = $y;
        $props{$id}{anchor}    = 'point';
        $props{$id}{coordlist} = [$x, $y, $x, $y];
        $props{$id}{color}     = $default_color;
        $props{$id}{width}     = $default_width;
        $props{$id}{arrow}     = $default_arrow;
        $props{$id}{ahd1}      = $default_ahd1;
        $props{$id}{ahd2}      = $default_ahd2;
        $props{$id}{ahd3}      = $default_ahd3;

    } elsif ($type eq "circle") {
        $id = $canv->create_oval($x, $y, $x, $y,
                 -outline => &get_rgb_code($default_color),
                 -width   => $default_width,
                 -tags    => "working");
        if ($default_fill) {
            $canv->itemconfigure($id, -fill => &get_rgb_code($default_fillcolor));
        } else {
            $canv->itemconfigure($id, -fill => "");
        }
        $props{$id}{type}      = $type;
        $props{$id}{x}         = $x;
        $props{$id}{y}         = $y;
        $props{$id}{xc}        = $x;
        $props{$id}{yc}        = $y;
        $props{$id}{anchor}    = 'corner';
        $props{$id}{coordlist} = [$x, $y, $x, $y];
        $props{$id}{color}     = $default_color;
        $props{$id}{width}     = $default_width;
        $props{$id}{fill}      = $default_fill;
        $props{$id}{fillcolor} = $default_fillcolor;

    } elsif ($type eq "ellipse") {
        $id = $canv->create_polygon($x, $y, $x, $y, $x, $y,
                 -outline => &get_rgb_code($default_color),
                 -width   => $default_width,
                 -smooth  => 'false',
                 -tags    => "working");
        if ($default_fill) {
            $canv->itemconfigure($id, -fill => &get_rgb_code($default_fillcolor));
        } else {
            $canv->itemconfigure($id, -fill => "");
        }
        $props{$id}{type}      = $type;
        $props{$id}{x}         = $x;
        $props{$id}{y}         = $y;
        $props{$id}{xc}        = $x;
        $props{$id}{yc}        = $y;
        $props{$id}{anchor}    = 'corner';
        $props{$id}{coordlist} = [$x, $y, $x, $y, $x, $y];
        $props{$id}{color}     = $default_color;
        $props{$id}{width}     = $default_width;
        $props{$id}{fill}      = $default_fill;
        $props{$id}{fillcolor} = $default_fillcolor;
        $props{$id}{angle}     = $default_angle;
        $props{$id}{angle_tmp} = $default_angle;
        $props{$id}{smooth}    = 0;

    } elsif ($type eq "rectangle") {
        $id = $canv->create_polygon($x, $y, $x+1, $y, $x+1, $y+1, $x, $y+1,
                 -outline => &get_rgb_code($default_color),
                 -width   => $default_width,
                 -smooth  => $smooth_type[$default_smooth],
                 -tags    => "working");
        if ($default_fill) {
            $canv->itemconfigure($id, -fill => &get_rgb_code($default_fillcolor));
        } else {
            $canv->itemconfigure($id, -fill => "");
        }
        $props{$id}{type}      = $type;
        $props{$id}{x}         = $x;
        $props{$id}{y}         = $y;
        $props{$id}{xc}        = $x;
        $props{$id}{yc}        = $y;
        $props{$id}{anchor}    = 'corner';
        $props{$id}{coordlist} = [$x, $y, $x+1, $y, $x+1, $y+1, $x, $y+1];
        $props{$id}{color}     = $default_color;
        $props{$id}{width}     = $default_width;
        $props{$id}{fill}      = $default_fill;
        $props{$id}{fillcolor} = $default_fillcolor;
        $props{$id}{angle}     = $default_angle;
        $props{$id}{angle_tmp} = $default_angle;
        $props{$id}{smooth}    = $default_smooth;

    } elsif ($type eq "diamond") {
        $id = $canv->create_polygon($x, $y, $x+1, $y+1, $x, $y+2, $x-1, $y+1,
                 -outline => &get_rgb_code($default_color),
                 -width   => $default_width,
                 -smooth  => $smooth_type[$default_smooth],
                 -tags    => "working");
        if ($default_fill) {
            $canv->itemconfigure($id, -fill => &get_rgb_code($default_fillcolor));
        } else {
            $canv->itemconfigure($id, -fill => "");
        }
        $props{$id}{type}      = $type;
        $props{$id}{x}         = $x;
        $props{$id}{y}         = $y;
        $props{$id}{xc}        = $x;
        $props{$id}{yc}        = $y;
        $props{$id}{anchor}    = 'corner';
        $props{$id}{coordlist} = [$x, $y, $x+1, $y, $x+1, $y+1, $x, $y+1];
        $props{$id}{color}     = $default_color;
        $props{$id}{width}     = $default_width;
        $props{$id}{fill}      = $default_fill;
        $props{$id}{fillcolor} = $default_fillcolor;
        $props{$id}{angle}     = $default_angle;
        $props{$id}{angle_tmp} = $default_angle;
        $props{$id}{smooth}    = $default_smooth;

    } elsif ($type eq "polygon") {
        $id = $canv->create_line($x, $y, $x, $y,
                 -fill  => &get_rgb_code($default_color),
                 -width => $default_width,
                 -arrow => 'none',
                 -tags  => "working");
        $props{$id}{type}      = $type;
        $props{$id}{x}         = $x;
        $props{$id}{y}         = $y;
        $props{$id}{xc}        = $x;
        $props{$id}{yc}        = $y;
        $props{$id}{xc_rot}    = $x;
        $props{$id}{yc_rot}    = $y;
        $props{$id}{anchor}    = 'point';
        $props{$id}{coordlist} = [$x, $y, $x, $y];
        $props{$id}{color}     = $default_color;
        $props{$id}{width}     = $default_width;
        $props{$id}{fill}      = $default_fill;
        $props{$id}{fillcolor} = $default_fillcolor;
        $props{$id}{angle}     = $default_angle;
        $props{$id}{angle_tmp} = $default_angle;

    } elsif ($type eq "polyline") {
        $id = $canv->create_line($x, $y, $x, $y,
                 -fill       => &get_rgb_code($default_color),
                 -width      => $default_width,
                 -arrow      => $arrow_type[$default_arrow],
                 -arrowshape => [ $default_ahd1, $default_ahd2, $default_ahd3 ],
                 -tags       => "working");
        $props{$id}{type}      = $type;
        $props{$id}{x}         = $x;
        $props{$id}{y}         = $y;
        $props{$id}{xc}        = $x;
        $props{$id}{yc}        = $y;
        $props{$id}{xc_rot}    = $x;
        $props{$id}{yc_rot}    = $y;
        $props{$id}{anchor}    = 'point';
        $props{$id}{coordlist} = [$x, $y, $x, $y];
        $props{$id}{color}     = $default_color;
        $props{$id}{width}     = $default_width;
        $props{$id}{arrow}     = $default_arrow;
        $props{$id}{ahd1}      = $default_ahd1;
        $props{$id}{ahd2}      = $default_ahd2;
        $props{$id}{ahd3}      = $default_ahd3;
        $props{$id}{angle}     = $default_angle;
        $props{$id}{angle_tmp} = $default_angle;

    } elsif ($type eq "text") {
        $id = $canv->create_text($x, $y,
                 -anchor => 'w', 
                 -text   => "add text",
                 -fill   => &get_rgb_code($default_color),
                 -angle  => $default_angle,
                 -font   => [-family     => $default_family,
                             -size       => $default_size,
                             -weight     => $default_weight,
                             -slant      => $slant_type[$default_slant],
                             -underline  => $default_underline,
                             -overstrike => 0,
                            ]);
        $props{$id}{type}      = $type;
        $props{$id}{text}      = "add text";
        $props{$id}{x}         = $x;
        $props{$id}{y}         = $y;
        $props{$id}{xc}        = $x;
        $props{$id}{yc}        = $y;
        $props{$id}{anchor}    = 'w';
        $props{$id}{coordlist} = [$x, $y];
        $props{$id}{color}     = $default_color;
        $props{$id}{family}    = $default_family;
        $props{$id}{size}      = $default_size;
        $props{$id}{weight}    = $default_weight;
        $props{$id}{slant}     = $default_slant;
        $props{$id}{underline} = $default_underline;
        $props{$id}{angle}     = $default_angle;
        &reset_bindings;
        &edit_text_props($id, $X, $Y);
        return;

    } elsif ($type eq "graph") {
        $id = $canv->create_rectangle($x, $y, $x, $y,
                 -outline => &get_rgb_code($default_color),
                 -width   => 1,
                 -fill    => "",
                 -tags    => "working");
        $props{$id}{type}      = "graph";
        $props{$id}{meta}      = $meta;
        $props{$id}{x}         = $x;
        $props{$id}{y}         = $y;
        $props{$id}{xc}        = $x;
        $props{$id}{yc}        = $y;
        $props{$id}{anchor}    = 'corner';
        $props{$id}{coordlist} = [$x, $y, $x, $y];
        $props{$id}{color}     = $default_color;
        $props{$id}{width}     = $default_width;
        $props{$id}{fill}      = 0;
        $canv->addtag("graph" . $id, withtag => $id);

    } else {
        &reset_bindings;
        return;
    }

    $canv->create_rectangle($x-2, $y-2, $x+2, $y+2,
                 -outline => &get_rgb_code($anchor_line_color),
                 -width   => 1,
                 -fill    => &get_rgb_code($anchor_select_color),
                 -tags    => "anchor");

    if ($type =~ /^(rectangle|diamond|ellipse)$/) {
        $canv->g_bind("<Shift-Motion>",   [ \&size_rde,    Tkx::Ev("%x","%y"), $canv, $x, $y, $id, 1 ]);
        $canv->g_bind("<Motion>",         [ \&size_rde,    Tkx::Ev("%x","%y"), $canv, $x, $y, $id, 0 ]);
        $canv->g_bind("<Button-1>",       [ \&end_drawing, Tkx::Ev("%x","%y"), $canv, $x, $y, $id ]);

    } elsif ($type =~ /^(polygon|polyline)$/) {
        $canv->g_bind("<Shift-Motion>",   [ \&next_pt,  Tkx::Ev("%x","%y"), $canv, $x, $y, $id, 1 ]);
        $canv->g_bind("<Motion>",         [ \&next_pt,  Tkx::Ev("%x","%y"), $canv, $x, $y, $id, 0 ]);
        $canv->g_bind("<Shift-Button-1>", [ \&add_pt,   Tkx::Ev("%x","%y"), $canv, $x, $y, $id, 1 ]);
        $canv->g_bind("<Button-1>",       [ \&add_pt,   Tkx::Ev("%x","%y"), $canv, $x, $y, $id, 0 ]);
        $canv->g_bind("<Double-Button-1>",[ \&end_poly, Tkx::Ev("%x","%y"), $canv, $id ]);

    } else {
        $canv->g_bind("<Shift-Motion>", [ \&size_object, Tkx::Ev("%x","%y"), $canv, $x, $y, $id, 1 ]);
        $canv->g_bind("<Motion>",       [ \&size_object, Tkx::Ev("%x","%y"), $canv, $x, $y, $id, 0 ]);
        $canv->g_bind("<Button-1>",     [ \&end_drawing, Tkx::Ev("%x","%y"), $canv, $x, $y, $id ]);
    }
    $canv->g_bind("<Button-3>", [ \&forget_drawing, $id ]);
}


sub begin_resize {
    my ($canv, $id) = @_;
    my ($type, $xo, $yo);

    &end_select($canv, $id, 1);

    $type = $props{$id}{type};
    $xo   = $props{$id}{x};
    $yo   = $props{$id}{y};
    $canv->configure(-cursor => $cursor_draw);

    if ($type !~ /^(circle|line|graph)$/) {
        &make_crosshair($xo, $yo, $canv, $props{$id}{angle});
    }
    $canv->create_rectangle($xo-2, $yo-2, $xo+2, $yo+2,
                 -outline => &get_rgb_code($anchor_line_color),
                 -width   => 1,
                 -fill    => &get_rgb_code($anchor_select_color),
                 -tags    => "anchor");

    if ($type =~ /^(rectangle|diamond|ellipse)$/) {
        $canv->g_bind("<Control-Shift-Motion>",
                                          [ \&size_rde, Tkx::Ev("%x","%y"), $canv, $xo, $yo, $id, 3 ]);
        $canv->g_bind("<Control-Motion>", [ \&size_rde, Tkx::Ev("%x","%y"), $canv, $xo, $yo, $id, 2 ]);
        $canv->g_bind("<Shift-Motion>",   [ \&size_rde, Tkx::Ev("%x","%y"), $canv, $xo, $yo, $id, 1 ]);
        $canv->g_bind("<Motion>",         [ \&size_rde, Tkx::Ev("%x","%y"), $canv, $xo, $yo, $id, 0 ]);

    } elsif ($type =~ /^(polygon|polyline)$/) {
        $canv->g_bind("<Control-Shift-Motion>",
                                          [ \&size_poly, Tkx::Ev("%x","%y"), $canv, $xo, $yo, $id, 3 ]);
        $canv->g_bind("<Control-Motion>", [ \&size_poly, Tkx::Ev("%x","%y"), $canv, $xo, $yo, $id, 2 ]);
        $canv->g_bind("<Shift-Motion>",   [ \&size_poly, Tkx::Ev("%x","%y"), $canv, $xo, $yo, $id, 1 ]);
        $canv->g_bind("<Motion>",         [ \&size_poly, Tkx::Ev("%x","%y"), $canv, $xo, $yo, $id, 0 ]);

    } else {
        $canv->g_bind("<Shift-Motion>", [ \&size_object, Tkx::Ev("%x","%y"), $canv, $xo, $yo, $id, 1 ]);
        $canv->g_bind("<Motion>",       [ \&size_object, Tkx::Ev("%x","%y"), $canv, $xo, $yo, $id, 0 ]);
    }
    $canv->g_bind("<Button-1>",   [ \&end_drawing, Tkx::Ev("%x","%y"), $canv, $xo, $yo, $id ]);
    $canv->g_bind("<Button-3>",   [ \&forget_resize, $canv, $id ]);
}


sub size_rde {         # rde: rectangle, diamond, ellipse
    my ($x, $y, $canv, $xo, $yo, $id, $keys) = @_;
    my ($ang, $ang2, $ang3, $angc, $ctrl, $dx, $dy, $h, $hc, $hh, $hw,
        $shft, $snap, $type, $xc, $xct, $yc, $yct,
        @coords,
       );

    $ctrl = ($keys == 2 || $keys == 3) ? 1 : 0;
    $shft = ($keys == 1 || $keys == 3) ? 1 : 0;
    $type = $props{$id}{type};
    $ang  = $props{$id}{angle};
    $snap = ($ang % 90 == 0 || $ctrl) ? 1 : 0;

    ($x, $y) = &get_xy($canv, $x, $y, $snap);

    if ($ang != 0 && $type =~ /^(ellipse|rectangle|diamond)$/) {
        if ($ctrl) {
            $ang = 0;
            if ($props{$id}{angle_tmp} != 0) {
                $props{$id}{angle_tmp} = 0;
                &make_crosshair($xo, $yo, $canv, $ang);
            }
        } elsif ($props{$id}{angle_tmp} != $props{$id}{angle}) {
            $props{$id}{angle_tmp} = $props{$id}{angle};
            &make_crosshair($xo, $yo, $canv, $ang);
        }
    }

    if ($ang % 90 == 0) {     # mod ok, ang already an integer
        if ($shft) {
            if (abs($x-$xo) < abs($y-$yo)) {
                $y = ($y > $yo) ? $yo + abs($x-$xo) : $yo - abs($x-$xo);
            } else {
                $x = ($x > $xo) ? $xo + abs($y-$yo) : $xo - abs($y-$yo);
            }
        }
        $hw = abs($x - $xo)/2.;
        $hh = abs($y - $yo)/2.;

        if ($props{$id}{anchor} eq 'midpoint') {
            if ($ctrl) {
                $xc = $props{$id}{xc};
                $yc = $props{$id}{yc};
                if ($xc == $xo) {
                    if ($yc == $yo) {
                        $angc = 0;
                    } else {
                        $angc = ($yc > $yo) ? 270 : 90;
                    }
                } elsif ($yc == $yo) {
                    $angc = ($xc > $xo) ? 0 : 180;
                } else {
                    $angc = (180./pi)*atan2(($yo-$yc),($xc-$xo));
                }
                $angc = $angc - $props{$id}{angle} + 360;
                $hc   = sqrt(($xc-$xo)*($xc-$xo)+($yc-$yo)*($yc-$yo));
                $dx   = -$hc *cos($angc *pi/180.);
                $dy   =  $hc *sin($angc *pi/180.);
            } else {
                $dx = $xo - $props{$id}{xc};
                $dy = $yo - $props{$id}{yc};
            }
            if (abs($dx) < abs($dy)) {
                $xc  = $xo;
                $yc  = ($y + $yo)/2.;
                $hw *= 2. if (! $shft);
            } else {
                $xc  = ($x + $xo)/2.;
                $yc  = $yo;
                $hh *= 2. if (! $shft);
            }
        } elsif ($props{$id}{anchor} eq 'center') {
            $xc  = $xo;
            $yc  = $yo;
            $hw *= 2.;
            $hh *= 2.;
        } else {
            $xc = ($x + $xo)/2.;
            $yc = ($y + $yo)/2.;
        }

    } else {
        if ($x == $xo) {
            if ($y == $yo) {
                $ang2 = 0;
            } else {
                $ang2 = ($y > $yo) ? 270 : 90;
            }
        } elsif ($y == $yo) {
            $ang2 = ($x > $xo) ? 0 : 180;
        } else {
            $ang2 = (180./pi)*atan2(($yo-$y),($x-$xo));
        }
        $h  = sqrt(($x-$xo)*($x-$xo)+($y-$yo)*($y-$yo));
        $dx =  $h *cos(($ang2 -$ang) *pi/180.);
        $dy = -$h *sin(($ang2 -$ang) *pi/180.);

        if ($shft) {
            if ($dx != 0. || $dy != 0.) {
                if ($dx == 0.) {
                    $ang3 = (180./pi)*atan2(abs($dy),0.0001);
                    $ang3 = 90 - $ang3 if ($dy > 0);
                } else {
                    $ang3 = (180./pi)*atan2(abs($dy),abs($dx));
                    $ang3 = 90 - $ang3 if ($dx * $dy > 0);
                }
                if (abs($dx) <= abs($dy)) {
                    $dy = abs($dx) * $dy/abs($dy);
                } else {
                    $dx = abs($dy) * $dx/abs($dx);
                }
                $x = $xo +abs($dx) *sqrt(2.) *cos(($ang2 -$ang3 +45) *pi/180.);
                $y = $yo -abs($dx) *sqrt(2.) *sin(($ang2 -$ang3 +45) *pi/180.);
            }
        }
        $hw = abs($dx)/2.;
        $hh = abs($dy)/2.;

        if ($props{$id}{anchor} eq 'midpoint') {
            $xc = $props{$id}{xc};
            $yc = $props{$id}{yc};
            if ($xc == $xo) {
                if ($yc == $yo) {
                    $angc = 0;
                } else {
                    $angc = ($yc > $yo) ? 270 : 90;
                }
            } elsif ($yc == $yo) {
                $angc = ($xc > $xo) ? 0 : 180;
            } else {
                $angc = (180./pi)*atan2(($yo-$yc),($xc-$xo));
            }
            $angc = $angc - $ang + 360;
            $hc   = sqrt(($xc-$xo)*($xc-$xo)+($yc-$yo)*($yc-$yo));
            $xct  = $xo + $hc *cos($angc *pi/180.);
            $yct  = $yo - $hc *sin($angc *pi/180.);

            if (abs($xo - $xct) < abs($yo - $yct)) {
                $xc  = $xo +($dy/2.) *cos(($ang +270) *pi/180.);
                $yc  = $yo -($dy/2.) *sin(($ang +270) *pi/180.);
                $hw *= 2. if (! $shft);
            } else {
                $xc  = $xo +($dx/2.) *cos($ang *pi/180.);
                $yc  = $yo -($dx/2.) *sin($ang *pi/180.);
                $hh *= 2. if (! $shft);
            }
        } elsif ($props{$id}{anchor} eq 'center') {
            $xc  = $xo;
            $yc  = $yo;
            $hw *= 2.;
            $hh *= 2.;
        } else {
            $xc = ($x + $xo)/2.;
            $yc = ($y + $yo)/2.;
        }
    }
    if ($type eq "ellipse") {
        $props{$id}{hw_tmp} = $hw;
        $props{$id}{hh_tmp} = $hh;
    }
    @coords = &make_shape_coords($type, $xc, $yc, $hw, $hh, $ang);
    $canv->coords($id, @coords);
    $status_line = sprintf("X,Y,W,H: %d, %d, %d, %d", $x-3, $y-3, 2*$hw, 2*$hh);
}


sub size_poly {
    my ($x, $y, $canv, $xo, $yo, $id, $keys) = @_;
    my ($ang, $ang2, $ang3, $angc, $ctrl, $dx, $dy, $h, $hc, $shft, $snap,
        $xc, $xct, $xsameside, $xt, $yc, $yct, $ysameside, $yt,
        @coords,
       );

    $ctrl = ($keys == 2 || $keys == 3) ? 1 : 0;
    $shft = ($keys == 1 || $keys == 3) ? 1 : 0;
    $ang  = $props{$id}{angle};
    $snap = ($ang % 90 == 0 || $ctrl) ? 1 : 0;

    ($x, $y) = &get_xy($canv, $x, $y, $snap);

    if ($ang != 0) {
        if ($ctrl) {
            $ang = 0;
            if ($props{$id}{angle_tmp} != 0) {
                $props{$id}{angle_tmp} = 0;
                &make_crosshair($xo, $yo, $canv, $ang);
            }
        } elsif ($props{$id}{angle_tmp} != $props{$id}{angle}) {
            $props{$id}{angle_tmp} = $props{$id}{angle};
            &make_crosshair($xo, $yo, $canv, $ang);
        }
    }

    if ($ang == 0) {
        if ($shft) {
            if (abs($x-$xo) < abs($y-$yo)) {
                $y = ($y > $yo) ? $yo + abs($x-$xo) : $yo - abs($x-$xo);
            } else {
                $x = ($x > $xo) ? $xo + abs($y-$yo) : $xo - abs($y-$yo);
            }
        }
        $dx = $x - $xo;
        $dy = $y - $yo;

        $xc = $props{$id}{xc};
        $yc = $props{$id}{yc};
        if ($ctrl) {
            if ($xc == $xo) {
                if ($yc == $yo) {
                    $angc = 0;
                } else {
                    $angc = ($yc > $yo) ? 270 : 90;
                }
            } elsif ($yc == $yo) {
                $angc = ($xc > $xo) ? 0 : 180;
            } else {
                $angc = (180./pi)*atan2(($yo-$yc),($xc-$xo));
            }
            $angc = $angc - $props{$id}{angle} + 360;
            $hc   = sqrt(($xc-$xo)*($xc-$xo)+($yc-$yo)*($yc-$yo));
            $xct  = $xo +$hc *cos($angc *pi/180.);
            $yct  = $yo -$hc *sin($angc *pi/180.);
        } else {
            $xct = $xc;
            $yct = $yc;
        }
        $xsameside = (($x-$xo)*($xct-$xo) > 0) ? 1 : 0;
        $ysameside = (($y-$yo)*($yct-$yo) > 0) ? 1 : 0;

        if ($props{$id}{anchor} eq 'midpoint') {
            if (abs($xct-$xo) < abs($yct-$yo)) {
                $dx *= 2. if (! $shft);
                $dy *= -1 if (($ysameside && $dy < 0) || (! $ysameside && $dy > 0));
            } else {
                $dy *= 2. if (! $shft);
                $dx *= -1 if (($xsameside && $dx < 0) || (! $xsameside && $dx > 0));
            }
        } elsif ($props{$id}{anchor} =~ /^(center|center_rot)$/) {
            $dx *= 2.;
            $dy *= 2.;
        } else {
            $dx *= -1 if (($xsameside && $dx < 0) || (! $xsameside && $dx > 0));
            $dy *= -1 if (($ysameside && $dy < 0) || (! $ysameside && $dy > 0));
        }

    } else {
        if ($x == $xo) {
            if ($y == $yo) {
                $ang2 = 0;
            } else {
                $ang2 = ($y > $yo) ? 270 : 90;
            }
        } elsif ($y == $yo) {
            $ang2 = ($x > $xo) ? 0 : 180;
        } else {
            $ang2 = (180./pi)*atan2(($yo-$y),($x-$xo));
        }
        $h  = sqrt(($x-$xo)*($x-$xo)+($y-$yo)*($y-$yo));
        $dx =  $h *cos(($ang2 -$ang) *pi/180.);
        $dy = -$h *sin(($ang2 -$ang) *pi/180.);
        $xt = $xo + $dx;
        $yt = $yo + $dy;

        if ($shft) {
            if ($dx != 0. || $dy != 0.) {
                if ($dx == 0.) {
                    $ang3 = (180./pi)*atan2(abs($dy),0.0001);
                    $ang3 = 90 - $ang3 if ($dy > 0);
                } else {
                    $ang3 = (180./pi)*atan2(abs($dy),abs($dx));
                    $ang3 = 90 - $ang3 if ($dx * $dy > 0);
                }
                if (abs($dx) <= abs($dy)) {
                    $dy = abs($dx) * $dy/abs($dy);
                } else {
                    $dx = abs($dy) * $dx/abs($dx);
                }
                $x = $xo +abs($dx) *sqrt(2.) *cos(($ang2 -$ang3 +45) *pi/180.);
                $y = $yo -abs($dx) *sqrt(2.) *sin(($ang2 -$ang3 +45) *pi/180.);
            }
        }

        $xc = $props{$id}{xc};
        $yc = $props{$id}{yc};
        if ($xc == $xo) {
            if ($yc == $yo) {
                $angc = 0;
            } else {
                $angc = ($yc > $yo) ? 270 : 90;
            }
        } elsif ($yc == $yo) {
            $angc = ($xc > $xo) ? 0 : 180;
        } else {
            $angc = (180./pi)*atan2(($yo-$yc),($xc-$xo));
        }
        $angc = $angc - $ang + 360;
        $hc   = sqrt(($xc-$xo)*($xc-$xo)+($yc-$yo)*($yc-$yo));
        $xct  = $xo + $hc *cos($angc *pi/180.);
        $yct  = $yo - $hc *sin($angc *pi/180.);

        $xsameside = (($xt-$xo)*($xct-$xo) > 0) ? 1 : 0;
        $ysameside = (($yt-$yo)*($yct-$yo) > 0) ? 1 : 0;

        if ($props{$id}{anchor} eq 'midpoint') {
            if (abs($xo - $xct) < abs($yo - $yct)) {
                $dx *= 2. if (! $shft);
                $dy *= -1 if (($ysameside && $dy < 0) || (! $ysameside && $dy > 0));
            } else {
                $dy *= 2. if (! $shft);
                $dx *= -1 if (($xsameside && $dx < 0) || (! $xsameside && $dx > 0));
            }
        } elsif ($props{$id}{anchor} =~ /^(center|center_rot)$/) {
            $dx *= 2.;
            $dy *= 2.;
        } else {
            $dx *= -1 if (($xsameside && $dx < 0) || (! $xsameside && $dx > 0));
            $dy *= -1 if (($ysameside && $dy < 0) || (! $ysameside && $dy > 0));
        }
    }
    @coords = @{ $props{$id}{coordlist} };
    @coords = &resize_shape(\@coords, $props{$id}{angle}, $xo, $yo, $dx, $dy, $ang);
    $canv->coords($id, @coords);
    $status_line = sprintf("X,Y,W,H: %d, %d, %d, %d", $x-3, $y-3, abs($dx), abs($dy));
}


sub size_object {
    my ($x, $y, $canv, $xo, $yo, $id, $shift) = @_;
    my ($type, $dx, $dy, $xc, $yc);

    $type = $props{$id}{type};
    if ($type !~ /^(circle|line|graph)$/) {
        &reset_bindings;
        return;
    }
    $shift   = 0 if (! defined($shift) || $shift != 1);
    ($x, $y) = &get_xy($canv, $x, $y, $snap2grid);

    if ($type eq "circle") {
        $dx = abs($x - $xo);
        $dy = abs($y - $yo);
        if ($props{$id}{anchor} eq 'center') {
            if ($dx < $dy) {
                $y = ($y > $yo) ? $yo + $dx : $yo - $dx;
            } else {
                $x = ($x > $xo) ? $xo + $dy : $xo - $dy;
            }
            $xo = $xo - ($x - $xo);
            $yo = $yo - ($y - $yo);

        } elsif ($props{$id}{anchor} eq 'midpoint') {
            $xc = $props{$id}{xc};
            $yc = $props{$id}{yc};
            if (abs($xc-$xo) < abs($yc-$yo)) {  # x midpoint
                $dx *= 2.;
                if ($dx < $dy) {
                    $y = ($y > $yo) ? $yo + $dx : $yo - $dx;
                } else {
                    $x = ($x > $xo) ? $xo + 0.5*$dy : $xo - 0.5*$dy;
                }
                $xo = $xo - ($x - $xo);
            } else {
                $dy *= 2.;
                if ($dx < $dy) {
                    $y = ($y > $yo) ? $yo + 0.5*$dx : $yo - 0.5*$dx;
                } else {
                    $x = ($x > $xo) ? $xo + $dy : $xo - $dy;
                }
                $yo = $yo - ($y - $yo);
            }
        } else {
            if ($dx < $dy) {
                $y = ($y > $yo) ? $yo + $dx : $yo - $dx;
            } else {
                $x = ($x > $xo) ? $xo + $dy : $xo - $dy;
            }
        }
        $status_line = sprintf("X,Y,W,H: %d, %d, %d, %d",
                                         $x-3, $y-3, abs($x-$xo), abs($y-$yo));

    } elsif ($type eq "line") {
        if ($shift) {
            if (abs($x - $xo) <= abs($y - $yo)) {
                $x = $xo;
            } else {
                $y = $yo;
            }
        }
        if ($props{$id}{anchor} eq 'midpoint') {
            $xo = $xo - ($x - $xo);
            $yo = $yo - ($y - $yo);
        }
        $status_line = sprintf("X1,Y1,X2,Y2: %d, %d, %d, %d", $xo-3, $yo-3, $x-3, $y-3);

    } elsif ($type eq "graph") {
        $dx = abs($x - $xo);
        $dy = abs($y - $yo);
        if ($shift) {
            if ($dx < $dy) {
                $y = ($y > $yo) ? $yo + $dx : $yo - $dx;
            } else {
                $x = ($x > $xo) ? $xo + $dy : $xo - $dy;
            }
        }
        if ($props{$id}{anchor} eq 'center') {
            $xo = $xo - ($x - $xo);
            $yo = $yo - ($y - $yo);

        } elsif ($props{$id}{anchor} eq 'midpoint') {
            $xc = $props{$id}{xc};
            $yc = $props{$id}{yc};
            if (abs($xc-$xo) < abs($yc-$yo)) {  # x midpoint
                $dx *= 2.;
                if ($shift) {
                    if ($dx < $dy) {
                        $y = ($y > $yo) ? $yo + $dx : $yo - $dx;
                    } else {
                        $x = ($x > $xo) ? $xo + 0.5*$dy : $xo - 0.5*$dy;
                    }
                }
                $xo = $xo - ($x - $xo);
            } else {
                $dy *= 2.;
                if ($shift) {
                    if ($dx < $dy) {
                        $y = ($y > $yo) ? $yo + 0.5*$dx : $yo - 0.5*$dx;
                    } else {
                        $x = ($x > $xo) ? $xo + $dy : $xo - $dy;
                    }
                }
                $yo = $yo - ($y - $yo);
            }
        }
        $status_line = sprintf("X,Y,W,H: %d, %d, %d, %d",
                                           $x-3, $y-3, abs($x-$xo), abs($y-$yo));
    }
    return if ($x == $xo && $y == $yo);

    $canv->coords($id, $xo, $yo, $x, $y);
}


sub next_pt {
    my ($x, $y, $canv, $sx, $sy, $id, $shift) = @_;
    my ($npts, $type, $xp, $yp,
        @coords,
       );

    ($x, $y) = &get_xy($canv, $x, $y, $snap2grid);

    $shift  = 0 if (! defined($shift) || $shift != 1);
    @coords = Tkx::SplitList($canv->coords($id));
    pop @coords;
    pop @coords;
    if ($shift) {
        $xp = $coords[$#coords-1];
        $yp = $coords[$#coords];
        if (abs($x - $xp) <= abs($y - $yp)) {
            $x = $xp;
        } else {
            $y = $yp;
        }
    }
    $status_line = sprintf("X,Y: %d, %d", $x-3, $y-3);
    return if ($x == $sx && $y == $sy);

    push (@coords, $x, $y);
    $npts = ($#coords + 1) /2;
    $type = $props{$id}{type};
    if ($type eq "polygon" && $npts == 3) {
        delete $props{$id};
        $canv->delete($id);
        $id = $canv->create_polygon(@coords,
                 -outline => &get_rgb_code($default_color),
                 -width   => $default_width,
                 -tags    => "working");
        if ($default_fill) {
            $canv->itemconfigure($id, -fill => &get_rgb_code($default_fillcolor));
        } else {
            $canv->itemconfigure($id, -fill => "");
        }
        $props{$id}{type}      = $type;
        $props{$id}{x}         = $coords[0];
        $props{$id}{y}         = $coords[1];
        $props{$id}{xc}        = $coords[0];
        $props{$id}{yc}        = $coords[1];
        $props{$id}{xc_rot}    = $coords[0];
        $props{$id}{yc_rot}    = $coords[1];
        $props{$id}{anchor}    = 'point';
        $props{$id}{coordlist} = [ @coords ];
        $props{$id}{color}     = $default_color;
        $props{$id}{width}     = $default_width;
        $props{$id}{fill}      = $default_fill;
        $props{$id}{fillcolor} = $default_fillcolor;
        $props{$id}{angle}     = $default_angle;
        $props{$id}{angle_tmp} = $default_angle;
        $canv->g_bind("<Shift-Motion>",   [ \&next_pt,  Tkx::Ev("%x","%y"), $canv, $sx, $sy, $id, 1 ]);
        $canv->g_bind("<Motion>",         [ \&next_pt,  Tkx::Ev("%x","%y"), $canv, $sx, $sy, $id, 0 ]);
        $canv->g_bind("<Shift-Button-1>", [ \&add_pt,   Tkx::Ev("%x","%y"), $canv, $sx, $sy, $id, 1 ]);
        $canv->g_bind("<Button-1>",       [ \&add_pt,   Tkx::Ev("%x","%y"), $canv, $sx, $sy, $id, 0 ]);
        $canv->g_bind("<Double-Button-1>",[ \&end_poly, Tkx::Ev("%x","%y"), $canv, $id ]);
    } else {
        $canv->coords($id, @coords);
    }
}


sub add_pt {
    my ($x, $y, $canv, $sx, $sy, $id, $shift) = @_;
    my ($xp, $yp, @coords);

    ($x, $y) = &get_xy($canv, $x, $y, $snap2grid);

    $shift  = 0 if (! defined($shift) || $shift != 1);
    @coords = Tkx::SplitList($canv->coords($id));
    pop @coords;
    pop @coords;
    if ($shift) {
        $xp = $coords[$#coords-1];
        $yp = $coords[$#coords];
        if (abs($x - $xp) <= abs($y - $yp)) {
            $x = $xp;
        } else {
            $y = $yp;
        }
    }
    $status_line = sprintf("X,Y: %d, %d", $x-3, $y-3);
    return if ($x == $sx && $y == $sy);

    push (@coords, $x, $y, $x, $y);
    $canv->coords($id, @coords);
    $canv->g_bind("<Shift-Motion>",  [ \&next_pt, Tkx::Ev("%x","%y"), $canv, $x, $y, $id, 1 ]);
    $canv->g_bind("<Motion>",        [ \&next_pt, Tkx::Ev("%x","%y"), $canv, $x, $y, $id, 0 ]);
    $canv->g_bind("<Shift-Button-1>",[ \&add_pt,  Tkx::Ev("%x","%y"), $canv, $x, $y, $id, 1 ]);
    $canv->g_bind("<Button-1>",      [ \&add_pt,  Tkx::Ev("%x","%y"), $canv, $x, $y, $id, 0 ]);
}


sub begin_move_pt {
    my ($canv, $id, $insert_pt) = @_;

    $canv->delete($move_delete_menu) if ($move_delete_menu);
    if (defined($old_item)) {
        $canv->delete($old_item);
        undef $old_item;
    }
    $canv->configure(-cursor => $cursor_draw);
    $canv->g_bind("<Motion>",   [ \&move_pt, Tkx::Ev("%x", "%y"), $canv, $id, $insert_pt ]);
    $canv->g_bind("<Button-1>", [ \&show_points,   $canv, $id ]);
    $canv->g_bind("<Button-3>", [ \&exit_edit_pts, $canv, $id ]);
}


sub move_pt {
    my ($x, $y, $canv, $id, $insert_pt) = @_;
    my (@coords);

    ($x, $y) = &get_xy($canv, $x, $y, $snap2grid);
    $status_line = sprintf("X,Y: %d, %d", $x-3, $y-3);

    @coords = Tkx::SplitList($canv->coords($id));
    splice(@coords, $insert_pt, 2, $x, $y);
    $canv->coords($id, @coords);
}


sub delete_pt {
    my ($canv, $id, $insert_pt) = @_;
    my (@coords);

    $canv->delete($move_delete_menu) if ($move_delete_menu);

    @coords = Tkx::SplitList($canv->coords($id));
    splice(@coords, $insert_pt, 2);
    $canv->coords($id, @coords);
    &show_points($canv, $id);
}


sub edit_add_pt {                  # only for polygon or polyline
    my ($x, $y, $canv, $id) = @_;
    my ($dist, $i, $insert_pt, $npts, $selected, $tol, $type,
        $x1, $x2, $y1, $y2,
        @coords,
       );

    $tol      = 4;
    ($x, $y)  = &get_xy($canv, $x, $y, 0);
    $selected = &select_item($canv, $id, $x, $y, $tol, 1);
    return if (! $selected);

    $type   = $props{$id}{type};
    @coords = Tkx::SplitList($canv->coords($id));
    push (@coords, $coords[0], $coords[1]) if ($type eq "polygon");

    $npts      = ($#coords + 1) /2;
    $insert_pt = 0;
    for ($i=0; $i<$npts-1; $i++) {
        $x1 = $coords[2*$i];
        $y1 = $coords[2*$i+1];
        $x2 = $coords[2*$i+2];
        $y2 = $coords[2*$i+3];
        if ( $x >= &min($x1,$x2)-$tol && $x <= &max($x1,$x2)+$tol &&
             $y >= &min($y1,$y2)-$tol && $y <= &max($y1,$y2)+$tol ) {
            if ($x1 == $x2) {
                $insert_pt = 2*$i+2;
                last;
            } else {
                $dist = ($x2 - $x1)
                        * (($y2 - $y1)*($x - $x1)/($x2 - $x1) + $y1 - $y)
                        / sqrt(($x2-$x1)*($x2-$x1) + ($y2-$y1)*($y2-$y1));
                if (abs($dist) <= $tol) {
                    $insert_pt = 2*$i+2;
                    last;
                }
            }
        }
    }
    if ($insert_pt > 0) {
        splice(@coords, -2, 2) if ($type eq "polygon");
        splice(@coords, $insert_pt, 0, $x, $y);
        $canv->coords($id, @coords);
        $canv->g_bind("<Motion>",   [ \&move_pt, Tkx::Ev("%x", "%y"), $canv, $id, $insert_pt ]);
        $canv->g_bind("<Button-1>", [ \&show_points, $canv, $id ]);
    }
}


sub exit_edit_pts {
    my ($canv, $id) = @_;
    my ($diff, $found, $i, $npts, $old_npts, $r, $xc, $yc,
        @coords, @old_coords, @xvals, @yvals,
       );

    @coords = Tkx::SplitList($canv->coords($id));
    $npts   = ($#coords+1)/2;
    $found  = 0;
    for ($i=0; $i<$npts; $i++) {
        if ($coords[2*$i] == $props{$id}{x} && $coords[2*$i+1] == $props{$id}{y}) {
            $found = 1;
            last;
        }
    }
    if (! $found) {
        $props{$id}{x} = $coords[0];
        $props{$id}{y} = $coords[1];
    }
    @old_coords = @{ $props{$id}{coordlist} };
    $old_npts   = ($#old_coords+1)/2;
    $diff       = 0;
    if ($npts != $old_npts) {
        $diff = 1;
    } else {
        for ($i=0; $i<=$#coords; $i++) {
            if ($coords[$i] != $old_coords[$i]) {
                $diff = 1;
                last;
            }
        }
    }
    if ($diff) {
        $props{$id}{coordlist} = [ @coords ];
        ($xc, $yc, $r) = &smallest_circle(@coords);
        $props{$id}{xc_rot} = $xc;
        $props{$id}{yc_rot} = $yc;

        @xvals  = @yvals = ();
        @coords = &find_rect_from_poly(\@coords, $props{$id}{angle});
        $npts   = ($#coords + 1) /2;
        for ($i=0; $i<$npts; $i++) {
            push(@xvals, $coords[2*$i]);
            push(@yvals, $coords[2*$i+1]);
        }
        $props{$id}{xc} = (&min(@xvals) + &max(@xvals))/2.;
        $props{$id}{yc} = (&min(@yvals) + &max(@yvals))/2.;
    }

    undef %pt_props;
    undef $old_item if (defined($old_item));
    $canv->delete("points");
    &reset_bindings;
}


sub end_poly {
    my ($x, $y, $canv, $id) = @_;
    my ($i, $npts, $r, $xo, $yo,
        @coords, @new_coords, @xvals, @yvals,
       );

    @xvals  = @yvals = ();
    @coords = Tkx::SplitList($canv->coords($id));
    $npts   = ($#coords + 1) /2;
    return if ($npts < 3);

    @new_coords = @coords[0,1];
    for ($i=1; $i<$npts; $i++) {
        if ($coords[2*$i]   != $coords[2*$i-2] ||
            $coords[2*$i+1] != $coords[2*$i-1]) {
            push (@new_coords, $coords[2*$i], $coords[2*$i+1]);
        }
    }
    $canv->coords($id, @new_coords);
    $props{$id}{coordlist} = [ @new_coords ];

    ($xo, $yo, $r) = &smallest_circle(@new_coords);
    $props{$id}{xc_rot} = $xo;
    $props{$id}{yc_rot} = $yo;

    @coords = &find_rect_from_poly(\@new_coords, $props{$id}{angle});
    $npts   = ($#coords + 1) /2;
    for ($i=0; $i<$npts; $i++) {
        push(@xvals, $coords[2*$i]);
        push(@yvals, $coords[2*$i+1]);
    }
    $props{$id}{xc} = (&min(@xvals) + &max(@xvals))/2.;
    $props{$id}{yc} = (&min(@yvals) + &max(@yvals))/2.;

    $canv->delete("anchor");
    $canv->dtag("working");
    $canv->itemconfigure($id, -tags => "keep");
    &reset_bindings;
}


sub end_drawing {
    my ($x, $y, $canv, $sx, $sy, $id) = @_;
    my ($i, $npts, $r, $type, $xo, $yo,
        @coords, @xvals, @yvals,
       );

    &end_select($canv, $id, 1);

    @xvals = @yvals = ();
    $type  = $props{$id}{type};

    ($x, $y) = &get_xy($canv, $x, $y, $snap2grid);

    if ($x == $sx && $y == $sy) {
        &pop_up_error($main, "Object has no length or width.\nPlease continue or reset.");
        return;
    } elsif (($x == $sx || $y == $sy) && $type ne "line") {
        &pop_up_error($main, "Object either has no length or width.\nPlease continue or reset.");
        return;
    }

    @coords = Tkx::SplitList($canv->coords($id));
    $props{$id}{coordlist} = [ @coords ];

    if ($type !~ /^(line|circle|graph)$/) {
        $props{$id}{angle} = $props{$id}{angle_tmp};
    }
    if ($type =~ /^(polygon|polyline)$/) {
        ($xo, $yo, $r) = &smallest_circle(@coords);
        $props{$id}{xc_rot} = $xo;
        $props{$id}{yc_rot} = $yo;
    }
    if ($props{$id}{anchor} ne 'center') {
        if ($type =~ /^(polygon|polyline)$/) {
            @coords = &find_rect_from_poly(\@coords, $props{$id}{angle});
        }
        $npts = ($#coords + 1) /2;
        for ($i=0; $i<$npts; $i++) {
            push(@xvals, $coords[2*$i]);
            push(@yvals, $coords[2*$i+1]);
        }
        $props{$id}{xc} = (&min(@xvals) + &max(@xvals))/2.;
        $props{$id}{yc} = (&min(@yvals) + &max(@yvals))/2.;
    }
    if ($type eq "ellipse") {
        $props{$id}{hw} = $props{$id}{hw_tmp};
        $props{$id}{hh} = $props{$id}{hh_tmp};
    }

    $canv->delete("anchor");
    $canv->delete("crosshair");
    $canv->delete("target");
    $canv->dtag("working");
    $canv->addtag("keep", withtag => $id);
    &reset_bindings;

    if ($type eq "graph") {
        if ($props{$id}{meta} =~ /data_profile/) {
            &make_data_profile($canv, $id, 0);
        } elsif ($props{$id}{meta} =~ /w2_profile/) {
            &make_w2_profile($canv, $id, 0);
        } elsif ($props{$id}{meta} eq "w2_slice") {
            &make_w2_slice($canv, $id, 0);
        } elsif ($props{$id}{meta} eq "w2_tdmap") {
            &make_w2_tdmap($canv, $id, 0);
        } elsif ($props{$id}{meta} eq "w2_outflow") {
            &make_w2_outflow($canv, $id, 0);
        } elsif ($props{$id}{meta} eq "w2_wlevels") {
            &make_w2_wlevels($canv, $id, 0);
        } elsif ($props{$id}{meta} =~ /vert_wd_zone/) {
            &make_wd_zone($canv, $id, 0);
        } elsif ($props{$id}{meta} eq "linked_time_series") {
            &make_ts_graph($canv, $id, 0);
        } elsif ($props{$id}{meta} eq "time_series") {
            if (! defined($props{$id}{data})) {
                &add_ts_graph($canv, $id);
            } else {
                &make_ts_graph($canv, $id, 0);
            }
        }
    }
}


sub forget_drawing {
    my ($id) = @_;

    delete $props{$id} if ($id ne "");
    $canvas->delete("working");
    $canvas->delete("anchor");
    $canvas->delete("target");
    $canvas->delete("zoom_bar");
    &reset_bindings;
}


sub forget_resize {
    my ($canv, $id) = @_;

    $canv->coords($id, $props{$id}{coordlist});
    $canv->delete("anchor");
    $canv->delete("crosshair");
    &reset_bindings;
}


sub begin_move {
    my ($canv, $id, $grp) = @_;
    my ($item, $xo, $yo,
        @items, @coords,
       );

    $grp = "" if (! defined($grp));
    if ($grp eq "group") {
        @items = Tkx::SplitList($canv->find_withtag($id));
        foreach $item (@items) {
            next if (! defined($props{$item}{type}));
            &end_select($canv, $item, 1);
        }
    } else {
        &end_select($canv, $id, 1);
    }
    if ($grp =~ /(Color Key|Legend)/) {
        @coords = @{ $props{$id}{coordlist} };
        $xo = $coords[2] + $gr_props{$id}{xleg_off};
        $yo = $coords[1] + $gr_props{$id}{yleg_off};
    } elsif ($grp =~ /Bulkhead Key/) {
        $xo = $gr_props{$id}{bh_xpos};
        $yo = $gr_props{$id}{bh_ypos};
    } elsif ($grp eq "group") {
        $props{$id}{type} = "group";
        @coords = Tkx::SplitList($canv->bbox($id));
        $xo = $props{$id}{x} = $coords[0];
        $yo = $props{$id}{y} = $coords[1];
    } else {
        $xo = $props{$id}{x};
        $yo = $props{$id}{y};
    }
    if ($snap2grid) {
        $canv->create_rectangle($xo-2, $yo-2, $xo+2, $yo+2,
                     -outline => &get_rgb_code($anchor_line_color),
                     -width   => 1,
                     -fill    => &get_rgb_code($anchor_select_color),
                     -tags    => "anchor");
    }
    $canv->configure(-cursor => $cursor_move);
    $canv->g_bind("<Shift-Motion>", [ \&move_object, Tkx::Ev("%x","%y"), $canv, $id, $xo, $yo, $grp, 1 ]);
    $canv->g_bind("<Motion>",       [ \&move_object, Tkx::Ev("%x","%y"), $canv, $id, $xo, $yo, $grp, 0 ]);
    $canv->g_bind("<Button-1>",     [ \&end_move_object, $canv, $id, $grp ]);
    $canv->g_bind("<Button-3>",     [ \&forget_move_object, $canv, $id, $xo, $yo, $grp ]);
}


sub move_object {
    my ($x, $y, $canv, $id, $xo, $yo, $grp, $shft) = @_;
    my ($ch, $cw, $dx, $dy, $gs, $gtag, $i, $item, $npts, $type, $x1, $x2,
        $xmove, $xoffset, $xp, $y1, $y2, $ymove, $yoffset, $yp,
        @coords, @items, @xvals, @yvals,
       );

    $shft = 0 if (! defined($shft) || $shft != 1);
    $type = $props{$id}{type};
    $grp  = "" if (! defined($grp));
    if ($type eq "text" || $type eq "image") {
        @coords = &find_rect_from_text_or_image($canv, $id);
    } elsif ($type eq "graph") {
        $gtag   = "graph" . $id;
        $gtag  .= "_colorKey" if ($grp =~ /Color Key/);
        $gtag  .= "_legend"   if ($grp =~ /Legend/);
        $gtag  .= "_openBH"   if ($grp =~ /Bulkhead Key/);
        @coords = Tkx::SplitList($canv->bbox($gtag));
    } elsif ($type eq "group") {
        @coords = Tkx::SplitList($canv->bbox($id));
        @items  = Tkx::SplitList($canv->find_withtag($id));
    } else {
        @coords = Tkx::SplitList($canv->coords($id));
    }
    @xvals = @yvals = ();
    $npts  = ($#coords + 1) /2;
    for ($i=0; $i<$npts; $i++) {
        push(@xvals, $coords[2*$i]);
        push(@yvals, $coords[2*$i+1]);
    }
    $x1 = &min(@xvals);
    $x2 = &max(@xvals);
    $y1 = &min(@yvals);
    $y2 = &max(@yvals);
    $xoffset = ($x2 -$x1)/2.;
    $yoffset = ($y2 -$y1)/2.;

    ($x, $y) = &get_xy($canv, $x, $y, 0);

    $dx = $x -($x1 +$xoffset);
    $dy = $y -($y1 +$yoffset);
    $cw = $canvas_width;
    $ch = $canvas_height;
    if ($snap2grid) {
        if ($grp =~ /(Color Key|Legend)/) {
            @coords = @{ $props{$id}{coordlist} };
            $xp     = $coords[2] +$gr_props{$id}{xleg_off};
            $yp     = $coords[1] +$gr_props{$id}{yleg_off};
        } elsif ($grp =~ /Bulkhead Key/) {
            $xp = $gr_props{$id}{bh_xpos};
            $yp = $gr_props{$id}{bh_ypos};
        } else {
            $xp = $props{$id}{x};
            $yp = $props{$id}{y};
        }
        $gs = $grid_spacing;
        $dx = 3+ $gs * &round_to_int(($xp+$dx)/$gs) - $xp;
        $dy = 3+ $gs * &round_to_int(($yp+$dy)/$gs) - $yp;
        until ($x1 + $dx >= 3)      { $dx += $gs; }
        until ($x2 + $dx <= $cw +2) { $dx -= $gs; }
        until ($y1 + $dy >= 3)      { $dy += $gs; }
        until ($y2 + $dy <= $ch +2) { $dy -= $gs; }
    } else {
        if ($x1 + $dx < 3) {
            $dx = 3 - $x1;
        } elsif ($x2 + $dx > $cw +2) {
            $dx = $cw +2 - $x2;
        }
        if ($y1 + $dy < 3) {
            $dy = 3 - $y1;
        } elsif ($y2 + $dy > $ch +2) {
            $dy = $ch +2 - $y2;
        }
    }
    if ($shft) {
        if ($grp =~ /(Color Key|Legend)/) {
            @coords = @{ $props{$id}{coordlist} };
            $xmove  = $xo -($coords[2] +$gr_props{$id}{xleg_off} +$dx);
            $ymove  = $yo -($coords[1] +$gr_props{$id}{yleg_off} +$dy);
            if (abs($xmove) >= abs($ymove)) {
                $dy = $yo -($coords[1] +$gr_props{$id}{yleg_off});
            } else {
                $dx = $xo -($coords[2] +$gr_props{$id}{xleg_off});
            }
        } elsif ($grp =~ /Bulkhead Key/) {
            $xmove = $xo -($gr_props{$id}{bh_xpos} +$dx);
            $ymove = $yo -($gr_props{$id}{bh_ypos} +$dy);
            if (abs($xmove) >= abs($ymove)) {
                $dy = $yo -$gr_props{$id}{bh_ypos};
            } else {
                $dx = $xo -$gr_props{$id}{bh_xpos};
            }
        } else {
            $xmove = $xo -($props{$id}{x} +$dx);
            $ymove = $yo -($props{$id}{y} +$dy);
            if (abs($xmove) >= abs($ymove)) {
                $dy = $yo -$props{$id}{y};
            } else {
                $dx = $xo -$props{$id}{x};
            }
        }
    }
    if (abs($dx) > 0.0 || abs($dy) > 0.0) {
        if ($type eq "graph") {
            $canv->move($gtag, $dx, $dy);
        } else {
            $canv->move($id, $dx, $dy);
        }
        $canv->move("anchor", $dx, $dy);

        if ($type eq "graph" && $gtag =~ /(_colorKey|_legend)/) {
            $gr_props{$id}{xleg_off} += $dx;
            $gr_props{$id}{yleg_off} += $dy;
            @coords = @{ $props{$id}{coordlist} };
            $xp     = $coords[2] +$gr_props{$id}{xleg_off};
            $yp     = $coords[1] +$gr_props{$id}{yleg_off};
        } elsif ($type eq "graph" && $gtag =~ /_openBH/) {
            $gr_props{$id}{bh_xpos} += $dx;
            $gr_props{$id}{bh_ypos} += $dy;
            $xp = $gr_props{$id}{bh_xpos};
            $yp = $gr_props{$id}{bh_ypos};
        } elsif ($type eq "group") {
            $props{$id}{x} += $dx;
            $props{$id}{y} += $dy;
            foreach $item (@items) {
                next if (! defined($props{$item}{type}));
                $props{$item}{x}  += $dx;
                $props{$item}{y}  += $dy;
                $props{$item}{xc} += $dx;
                $props{$item}{yc} += $dy;
                if ($props{$item}{type} =~ /^(polygon|polyline)$/) {
                    $props{$item}{xc_rot} += $dx;
                    $props{$item}{yc_rot} += $dy;
                }
            }
            $xp = $props{$id}{x};
            $yp = $props{$id}{y};
        } else {
            $props{$id}{x}  += $dx;
            $props{$id}{y}  += $dy;
            $props{$id}{xc} += $dx;
            $props{$id}{yc} += $dy;
            if ($type =~ /^(polygon|polyline)$/) {
                $props{$id}{xc_rot} += $dx;
                $props{$id}{yc_rot} += $dy;
            }
            $xp = $props{$id}{x};
            $yp = $props{$id}{y};
        }
        $status_line = sprintf("X,Y: %d, %d  BBox: %d, %d, %d, %d",
                                $xp-3, $yp-3,
                                $x1+$dx-3, $y1+$dy-3, $x2+$dx-3, $y2+$dy-3);
    }
}


sub move_selected {
    my ($key, $canv) = @_;
    my ($ch, $cw, $default_dx, $default_dy, $dx, $dy, $gs, $gtag,
        $i, $id, $npts, $step, $type, $x1, $x2, $xp, $y1, $y2, $yp,
        @coords, @ids, @xvals, @yvals,
       );

    @ids = ();

#   Find whether any items are selected
    @ids = Tkx::SplitList($canv->find_withtag("select"));
    return if (! @ids || $#ids < 0);

#   Set the amount of movement
    $default_dx = $default_dy = 0;
    $step = ($snap2grid) ? $grid_spacing : 1;
    if ($key == 37) {
        $default_dx = -1 * $step;
    } elsif ($key == 38) {
        $default_dy = -1 * $step;
    } elsif ($key == 39) {
        $default_dx = $step;
    } elsif ($key == 40) {
        $default_dy = $step;
    }
    $cw = $canvas_width;
    $ch = $canvas_height;
    $gs = $grid_spacing;

#   Move each selected object independently
    foreach $id (@ids) {
        &end_select($canv, $id, 1);
        $type = $props{$id}{type};
        if ($type eq "text" || $type eq "image") {
            @coords = &find_rect_from_text_or_image($canv, $id);
        } elsif ($type eq "graph") {
            $gtag   = "graph" . $id;
            @coords = Tkx::SplitList($canv->bbox($gtag));
        } else {
            @coords = Tkx::SplitList($canv->coords($id));
        }
        @xvals = @yvals = ();
        $npts  = ($#coords + 1) /2;
        for ($i=0; $i<$npts; $i++) {
            push(@xvals, $coords[2*$i]);
            push(@yvals, $coords[2*$i+1]);
        }
        $x1 = &min(@xvals);
        $x2 = &max(@xvals);
        $y1 = &min(@yvals);
        $y2 = &max(@yvals);
        $dx = $default_dx;
        $dy = $default_dy;
        if ($snap2grid) {       # Honor the snap2grid mode
            $xp = $props{$id}{x};
            $yp = $props{$id}{y};
            $dx = 3+ $gs * &round_to_int(($xp+$dx)/$gs) - $xp;
            $dy = 3+ $gs * &round_to_int(($yp+$dy)/$gs) - $yp;
            until ($x1 + $dx >= 3)      { $dx += $gs; }
            until ($x2 + $dx <= $cw +2) { $dx -= $gs; }
            until ($y1 + $dy >= 3)      { $dy += $gs; }
            until ($y2 + $dy <= $ch +2) { $dy -= $gs; }
        } else {
            if ($x1 + $dx < 3) {
                $dx = 3 - $x1;
            } elsif ($x2 + $dx > $cw +2) {
                $dx = $cw +2 - $x2;
            }
            if ($y1 + $dy < 3) {
                $dy = 3 - $y1;
            } elsif ($y2 + $dy > $ch +2) {
                $dy = $ch +2 - $y2;
            }
        }
        if (abs($dx) > 0.0 || abs($dy) > 0.0) {
            if ($type eq "graph") {
                $canv->move($gtag, $dx, $dy);
            } else {
                $canv->move($id, $dx, $dy);
            }
            $canv->move("select_" . $type . $id, $dx, $dy);

            $props{$id}{x}  += $dx;
            $props{$id}{y}  += $dy;
            $props{$id}{xc} += $dx;
            $props{$id}{yc} += $dy;
            if ($type =~ /^(polygon|polyline)$/) {
                $props{$id}{xc_rot} += $dx;
                $props{$id}{yc_rot} += $dy;
            }
            $props{$id}{coordlist} = [ Tkx::SplitList($canv->coords($id)) ];
            if ($props{$id}{type} eq "graph") {
                $props{$id}{oldcoords} = $props{$id}{coordlist};
            }
        }
    }
}


sub end_move_object {
    my ($canv, $id, $grp) = @_;
    my ($item, @items);

    &end_select($canv, $id, 1) if ($grp ne "group");

    if ($grp eq "group") {
        @items = Tkx::SplitList($canv->find_withtag($id));
        foreach $item (@items) {
            next if (! defined($props{$item}{type}));
            $props{$item}{coordlist} = [ Tkx::SplitList($canv->coords($item)) ];
            if ($props{$item}{type} eq "graph") {
                $props{$item}{oldcoords} = $props{$item}{coordlist};
            }
        }
    } elsif (! defined($grp) || $grp !~ /(Color Key|Legend|Bulkhead Key)/) {
        $props{$id}{coordlist} = [ Tkx::SplitList($canv->coords($id)) ];
        if ($props{$id}{type} eq "graph") {
            $props{$id}{oldcoords} = $props{$id}{coordlist};
        }
    }
    $canv->delete("anchor");
    &reset_bindings;
}


sub forget_move_object {
    my ($canv, $id, $sx, $sy, $grp) = @_;
    my ($dx, $dy, $gtag, $item, $type,
        @coords, @items,
       );

    &end_select($canv, $id, 1) if ($grp ne "group");

    $type = $props{$id}{type};
    if ($grp eq "group") {
        $dx = $sx -$props{$id}{x};
        $dy = $sy -$props{$id}{y};
        @items = Tkx::SplitList($canv->find_withtag($id));
        foreach $item (@items) {
            next if (! defined($props{$item}{type}));
            if ($props{$item}{type} eq "graph") {
                $gtag = "graph" . $item;
                $canv->move($gtag, $dx, $dy);
            } else {
                $canv->coords($item, $props{$item}{coordlist});
            }
            if ($props{$item}{type} =~ /^(polygon|polyline)$/) {
                $props{$item}{xc_rot} += $dx;
                $props{$item}{yc_rot} += $dy;
            }
            $props{$item}{xc} += $dx;
            $props{$item}{yc} += $dy;
            $props{$item}{x}  += $dx;
            $props{$item}{y}  += $dy;
        }
    } elsif ($grp =~ /(Color Key|Legend)/) {
        @coords = @{ $props{$id}{coordlist} };
        $dx     = $sx -($coords[2] +$gr_props{$id}{xleg_off});
        $dy     = $sy -($coords[1] +$gr_props{$id}{yleg_off});
        $gtag   = "graph" . $id . "_colorKey" if ($grp =~ /Color Key/);
        $gtag   = "graph" . $id . "_legend"   if ($grp =~ /Legend/);
        $canv->move($gtag, $dx, $dy);
        $gr_props{$id}{xleg_off} = $sx -$coords[2];
        $gr_props{$id}{yleg_off} = $sy -$coords[1];
    } elsif ($grp =~ /Bulkhead Key/) {
        $dx   = $sx -$gr_props{$id}{bh_xpos};
        $dy   = $sy -$gr_props{$id}{bh_ypos};
        $gtag = "graph" . $id . "_openBH";
        $canv->move($gtag, $dx, $dy);
        $gr_props{$id}{bh_xpos} = $sx;
        $gr_props{$id}{bh_ypos} = $sy;
    } else {
        $dx = $sx -$props{$id}{x};
        $dy = $sy -$props{$id}{y};
        if ($type eq "graph") {
            $gtag = "graph" . $id;
            $canv->move($gtag, $dx, $dy);
        } else {
            $canv->coords($id, $props{$id}{coordlist});
        }
        if ($type =~ /^(polygon|polyline)$/) {
            $props{$id}{xc_rot} += $dx;
            $props{$id}{yc_rot} += $dy;
        }
        $props{$id}{xc} += $dx;
        $props{$id}{yc} += $dy;
        $props{$id}{x}   = $sx;
        $props{$id}{y}   = $sy;
    }

    $canv->delete("anchor");
    &reset_bindings;
}


sub begin_rotate {
    my ($canv, $id) = @_;
    my ($angle, $type, $xo, $yo);

    &end_select($canv, $id, 1);

    $xo    = $props{$id}{x};
    $yo    = $props{$id}{y};
    $type  = $props{$id}{type};
    $angle = $props{$id}{angle};

    $canv->create_rectangle($xo-2, $yo-2, $xo+2, $yo+2,
                 -outline => &get_rgb_code($anchor_line_color),
                 -width   => 1,
                 -fill    => &get_rgb_code($anchor_select_color),
                 -tags    => "anchor");

    $canv->configure(-cursor => $cursor_hand);
    if ($type eq "image") {
        $canv->g_bind("<Motion>",   [ \&begin_rotate_image, Tkx::Ev("%x","%y"), $canv, $id ]);
        $canv->g_bind("<Button-1>", [ \&end_rotate_image,   Tkx::Ev("%x","%y"), $canv, $id ]);
        $canv->g_bind("<Button-3>", [ \&forget_rotate_image, $canv, $id ]);
    } else {
        $canv->g_bind("<Motion>",   [ \&rotate_object, Tkx::Ev("%x","%y"), $canv, $id ]);
        $canv->g_bind("<Button-1>", [ \&end_rotate_object, $canv, $id ]);
        $canv->g_bind("<Button-3>", [ \&forget_rotate_object, $canv, $id, $angle ]);
    }
}


sub rotate_object {
    my ($x, $y, $canv, $id) = @_;
    my ($ang, $ang_tot, $ang2, $i, $npts, $r, $type, $xi, $xo, $yi, $yo,
        @coords, @new_coords,
       );

    $x  = $canv->canvasx($x);
    $y  = $canv->canvasy($y);
    $xo = $props{$id}{x};
    $yo = $props{$id}{y};
    if ($x == $xo) {
        if ($y == $yo) {
            $ang = 0;
        } else {
            $ang = ($y > $yo) ? 270 : 90;
        }
    } elsif ($y == $yo) {
        $ang = ($x > $xo) ? 0 : 180;
    } else {
        $ang = &round_to_int((180./pi)*atan2(($yo-$y),($x-$xo)));
    }
    $ang += 360 if ($ang < 0);

    $type = $props{$id}{type};
    if ($type eq "text") {
        $canv->itemconfigure($id, -angle => $ang);

    } elsif ($type =~ /^(ellipse|rectangle|diamond|polygon|polyline)$/) {
        @coords = @{ $props{$id}{coordlist} };
        $npts   = ($#coords + 1) /2;
        @new_coords = ();
        for ($i=0; $i<$npts; $i++) {
            $xi = $coords[2*$i];
            $yi = $coords[2*$i+1];
            if ($xi != $xo || $yi != $yo) {
                $r = sqrt(($xi-$xo)*($xi-$xo)+($yi-$yo)*($yi-$yo));
                if ($xi == $xo) {
                    $ang2 = ($yi > $yo) ? 270 : 90;
                } elsif ($yi == $yo) {
                    $ang2 = ($xi > $xo) ? 0 : 180;
                } else {
                    $ang2 = (180./pi)*atan2(($yo-$yi),($xi-$xo));
                }
                $ang2 += 360 if ($ang2 < 0);
                $ang_tot = $ang + $ang2 - $props{$id}{angle};
                $xi = $xo + $r * cos($ang_tot * pi/180.);
                $yi = $yo - $r * sin($ang_tot * pi/180.);
            }
            push (@new_coords, $xi, $yi);
        }
        $canv->coords($id, @new_coords);
        $props{$id}{angle_tmp} = $ang;
    }

    $status_line = sprintf("Rotation: %d", $ang);
}


sub end_rotate_object {
    my ($canv, $id) = @_;
    my ($angle, $i, $npts, $r, $type, $xo, $yo,
        @coords, @xvals, @yvals,
       );

    &end_select($canv, $id, 1);

    @coords = Tkx::SplitList($canv->coords($id));
    $type   = $props{$id}{type};

    if ($type eq "text") {
        $angle = $canv->itemcget($id, -angle);
        $props{$id}{angle} = $angle;

    } elsif ($type =~ /^(ellipse|rectangle|diamond|polygon|polyline)$/) {
        $props{$id}{angle}     = $props{$id}{angle_tmp};
        $props{$id}{coordlist} = [ @coords ];
        if ($props{$id}{anchor} ne 'center_rot' && $type =~ /^(polygon|polyline)$/) {
            ($xo, $yo, $r) = &smallest_circle(@coords);
            $props{$id}{xc_rot} = $xo;
            $props{$id}{yc_rot} = $yo;
        }
        if ($props{$id}{anchor} ne 'center') {
            if ($type =~ /^(polygon|polyline)$/) {
                @coords = &find_rect_from_poly(\@coords, $props{$id}{angle});
            }
            @xvals = @yvals = ();
            $npts  = ($#coords + 1) /2;
            for ($i=0; $i<$npts; $i++) {
                push(@xvals, $coords[2*$i]);
                push(@yvals, $coords[2*$i+1]);
            }
            $props{$id}{xc} = (&min(@xvals) + &max(@xvals))/2.;
            $props{$id}{yc} = (&min(@yvals) + &max(@yvals))/2.;
        }
    }
    $canv->delete("anchor");
    &reset_bindings;
}


sub forget_rotate_object {
    my ($canv, $id, $sa) = @_;
    my ($type);

    &end_select($canv, $id, 1);

    $props{$id}{angle} = $sa;
    $type              = $props{$id}{type};

    if ($type eq "text") {
        $canv->itemconfigure($id, -angle => $sa);

    } elsif ($type =~ /^(ellipse|rectangle|diamond|polygon|polyline)$/) {
        $canv->coords($id, $props{$id}{coordlist});
        $props{$id}{angle_tmp} = $props{$id}{angle};
    }
    $canv->delete("anchor");
    &reset_bindings;
}


sub align_objects {
    my ($canv, $id, $align, $tag) = @_;
    my ($dx, $dy, $i, $item, $np, $type, $xref, $yref,
        @coords, @items, @xvals, @yvals,
       );

#   Reference object
    if ($align eq "center") {
        $xref = $props{$id}{xc};
    } elsif ($align eq "middle") {
        $yref = $props{$id}{yc};
    } elsif ($align eq "xycenters") {
        $xref = $props{$id}{xc};
        $yref = $props{$id}{yc};
    } elsif ($align eq "anchor_x") {
        $xref = $props{$id}{x};
    } elsif ($align eq "anchor_y") {
        $yref = $props{$id}{y};
    } elsif ($align eq "anchor_xy") {
        $xref = $props{$id}{x};
        $yref = $props{$id}{y};
    } else {
        @xvals  = @yvals = ();
        @coords = &get_coords($canv, $id, "pts");
        $np = ($#coords +1)/2;
        for ($i=0; $i<$np; $i++) {
            push (@xvals, $coords[2*$i]);
            push (@yvals, $coords[2*$i+1]);
        }
        if ($align eq "left") {
            $xref = &min(@xvals);
        } elsif ($align eq "right") {
            $xref = &max(@xvals);
        } elsif ($align eq "top") {
            $yref = &min(@yvals);
        } elsif ($align eq "bottom") {
            $yref = &max(@yvals);
        }
    }

#   Objects to align to the reference
    $dx = $dy = 0;
    @items = Tkx::SplitList($canv->find_withtag($tag));
    foreach $item (@items) {
        next if ($item == $id);
        next if (! defined($props{$item}{type}));
        if ($align eq "center") {
            $dx = $xref -$props{$item}{xc};
        } elsif ($align eq "middle") {
            $dy = $yref -$props{$item}{yc};
        } elsif ($align eq "xycenters") {
            $dx = $xref -$props{$item}{xc};
            $dy = $yref -$props{$item}{yc};
        } elsif ($align eq "anchor_x") {
            $dx = $xref -$props{$item}{x};
        } elsif ($align eq "anchor_y") {
            $dy = $yref -$props{$item}{y};
        } elsif ($align eq "anchor_xy") {
            $dx = $xref -$props{$item}{x};
            $dy = $yref -$props{$item}{y};
        } else {
            @xvals  = @yvals = ();
            @coords = &get_coords($canv, $item, "pts");
            $np = ($#coords +1)/2;
            for ($i=0; $i<$np; $i++) {
                push (@xvals, $coords[2*$i]);
                push (@yvals, $coords[2*$i+1]);
            }
            if ($align eq "left") {
                $dx = $xref - &min(@xvals);
            } elsif ($align eq "right") {
                $dx = $xref - &max(@xvals);
            } elsif ($align eq "top") {
                $dy = $yref - &min(@yvals);
            } elsif ($align eq "bottom") {
                $dy = $yref - &max(@yvals);
            }
        }
        $type = $props{$item}{type};
        if ($type eq "graph") {
            $canv->move("graph" . $item, $dx, $dy);
        } else {
            $canv->move($item, $dx, $dy);
        }
        $props{$item}{x}  += $dx;
        $props{$item}{y}  += $dy;
        $props{$item}{xc} += $dx;
        $props{$item}{yc} += $dy;
        if ($type =~ /^(polygon|polyline)$/) {
            $props{$item}{xc_rot} += $dx;
            $props{$item}{yc_rot} += $dy;
        }
        $props{$item}{coordlist} = [ Tkx::SplitList($canv->coords($item)) ];
        if ($type eq "graph") {
            $props{$item}{oldcoords} = $props{$item}{coordlist};
        }
    }
    if ($tag eq "select") {
        &clear_selection_marks($canv);
        &show_group($canv, $tag);
    }
}


sub flip_object {
    my ($canv, $id, $arg) = @_;
    my ($ang, $i, $left_right, $npts, $r, $type, $x, $xo, $y, $yo,
        @coords, @new_coords, @xvals, @yvals,
       );

    &end_select($canv, $id, 1);

    $type   = $props{$id}{type};
    $ang    = $props{$id}{angle} if ($type ne "line");
    @coords = @{ $props{$id}{coordlist} };
    $npts   = ($#coords +1)/2;

    if ($arg =~ /anchor/) {    # use current anchor point
        $xo = $props{$id}{x};
        $yo = $props{$id}{y};
    } else {                   # use geometric center point
        $xo = $props{$id}{xc};
        $yo = $props{$id}{yc};
    }
    $left_right = ($arg =~ /left_right/) ? 1 : 0;
    @new_coords = ();

    for ($i=0; $i<$npts; $i++) {
        $x = $coords[2*$i];
        $y = $coords[2*$i+1];
        if ($left_right) {         # flip left to right
            $x = $xo + ($xo - $x);
        } else {                   # flip top to bottom
            $y = $yo + ($yo - $y);
        }
        push (@new_coords, $x, $y);
    }
    @coords = @new_coords;
    $canv->coords($id, @coords);
    $props{$id}{coordlist} = [ @coords ];

    if ($type ne "line" && $ang % 90 != 0) {
        $ang = ($left_right) ? -1 * $ang +180 : -1 * $ang;
        $ang = ($ang +360) % 360;
        $props{$id}{angle} = $ang;
    }
    if ($type =~ /^(polygon|polyline)$/) {
        if ($arg !~ /anchor/ || $props{$id}{anchor} ne 'center_rot') {
            ($xo, $yo, $r) = &smallest_circle(@coords);
            $props{$id}{xc_rot} = $xo;
            $props{$id}{yc_rot} = $yo;
        }
    }
    if ($arg =~ /anchor/ && $props{$id}{anchor} ne 'center') {
        if ($type =~ /^(polygon|polyline)$/) {
            @coords = &find_rect_from_poly(\@coords, $props{$id}{angle});
        }
        @xvals = @yvals = ();
        $npts  = ($#coords + 1) /2;
        for ($i=0; $i<$npts; $i++) {
            push(@xvals, $coords[2*$i]);
            push(@yvals, $coords[2*$i+1]);
        }
        $props{$id}{xc} = (&min(@xvals) + &max(@xvals))/2.;
        $props{$id}{yc} = (&min(@yvals) + &max(@yvals))/2.;
    }
}


sub raise_lower {
    my ($canv, $id, $action) = @_;
    my ($bot_id, $item, $next_id, $top_id,
        @ids, @items, @tags,
       );

    @ids = ();
    if ($id =~ /^group_/) {
        @items = Tkx::SplitList($canv->find_withtag($id));
        foreach $item (@items) {
            next if (! defined($props{$item}{type}));
            &end_select($canv, $item, 1);
            push (@ids, $item);
        }
        if ($action eq "bottom") {
            @ids = reverse @ids;
        }
    } else {
        &end_select($canv, $id, 1);
        push (@ids, $id);
    }

    foreach $id (@ids) {
        if ($props{$id}{type} eq "graph" && $action ne "tiptop") {
            $id = "graph" . $id;
        }
        $action = "top" if ($action eq "tiptop");

        if ($action eq "raise") {
            $next_id = $canv->find_above($id);
            @tags    = Tkx::SplitList($canv->itemcget($next_id, -tags));
            if (&list_search("^graph", @tags) > -1) {
                $next_id = $tags[&list_search("^graph", @tags)];
            }
            $canv->raise($id, $next_id) if ($next_id ne "");

        } elsif ($action eq "top") {
            $top_id = $canv->find_above($id);
            if ($top_id ne "") {
                while (($next_id = $canv->find_above($top_id)) ne "") {
                    $top_id = $next_id;
                }
                $canv->raise($id, $top_id);
            }

        } elsif ($action eq "lower") {
            $next_id = $canv->find_below($id);
            @tags    = Tkx::SplitList($canv->itemcget($next_id, -tags));
            if (&list_search("^graph", @tags) > -1) {
                $next_id = $tags[&list_search("^graph", @tags)];
            }
            $canv->lower($id, $next_id) if ($next_id ne "");

        } elsif ($action eq "bottom") {
            $bot_id = $canv->find_below($id);
            if ($bot_id ne "") {
                while (($next_id = $canv->find_below($bot_id)) ne "") {
                    $bot_id = $next_id;
                }
                $canv->lower($id, $bot_id);
            }
        }
    }
}


sub begin_edit {
    my ($X, $Y, $canv, $id) = @_;
    my ($type);

    &end_select($canv, $id, 1);

    $type = $props{$id}{type};
    if ($type eq "text") {
        &edit_text_props($id, $X, $Y);
    } elsif ($type =~ /^(line|polyline|rectangle|diamond|circle|ellipse|polygon)$/) {
        &edit_object_props($id, $X, $Y);
    } elsif ($type eq "graph") {
        &edit_graph_props($id, $X, $Y);
    }
    &reset_bindings;
}


sub duplicate {
    my ($canv, $id) = @_;
    my (
        $ahd1, $ahd2, $ahd3, $anchor, $angle, $arrow, $color, $family,
        $file, $fill, $fillcolor, $flip, $hh, $hw, $i, $ihc, $iho, $img,
        $img_data, $image, $iwc, $iwo, $new_id, $size, $slant, $smooth,
        $text, $type, $underline, $weight, $width, $x, $xc, $y, $yc,

        @coords, @crop,
        %grid_tmp, %profile_tmp,
       );

    &end_select($canv, $id, 1);

    $type   = $props{$id}{type};
    $x      = $props{$id}{x}  +10;
    $y      = $props{$id}{y}  +10;
    $xc     = $props{$id}{xc} +10;
    $yc     = $props{$id}{yc} +10;
    $anchor = $props{$id}{anchor};

    @coords = Tkx::SplitList($canv->coords($id));
    for ($i=0; $i<=$#coords; $i++) {
        $coords[$i] += 10;
    }

    if ($type =~ /^(line|polyline)$/) {
        $color  = $props{$id}{color};
        $width  = $props{$id}{width};
        $arrow  = $props{$id}{arrow};
        $ahd1   = $props{$id}{ahd1};
        $ahd2   = $props{$id}{ahd2};
        $ahd3   = $props{$id}{ahd3};
        $new_id = $canv->create_line(@coords,
                         -fill       => &get_rgb_code($color),
                         -width      => $width,
                         -arrow      => $arrow_type[$arrow],
                         -arrowshape => [ $ahd1, $ahd2, $ahd3 ],
                         -tags       => "keep");
        $props{$new_id}{type}      = $type;
        $props{$new_id}{x}         = $x;
        $props{$new_id}{y}         = $y;
        $props{$new_id}{xc}        = $xc;
        $props{$new_id}{yc}        = $yc;
        $props{$new_id}{anchor}    = $anchor;
        $props{$new_id}{coordlist} = [ @coords ];
        $props{$new_id}{color}     = $color;
        $props{$new_id}{width}     = $width;
        $props{$new_id}{arrow}     = $arrow;
        $props{$new_id}{ahd1}      = $ahd1;
        $props{$new_id}{ahd2}      = $ahd2;
        $props{$new_id}{ahd3}      = $ahd3;
        if ($type eq "polyline") {
            $props{$new_id}{xc_rot}    = $props{$id}{xc_rot} +10;
            $props{$new_id}{yc_rot}    = $props{$id}{yc_rot} +10;
            $props{$new_id}{angle}     = $props{$id}{angle};
            $props{$new_id}{angle_tmp} = $props{$id}{angle};
        }

    } elsif ($type eq "circle") {
        $color     = $props{$id}{color};
        $width     = $props{$id}{width};
        $fill      = $props{$id}{fill};
        $fillcolor = $props{$id}{fillcolor};
        $new_id    = $canv->create_oval(@coords,
                            -outline => &get_rgb_code($color),
                            -width   => $width,
                            -tags    => "keep");
        if ($fill && $fillcolor ne "") {
            $canv->itemconfigure($new_id, -fill => &get_rgb_code($fillcolor));
        } else {
            $canv->itemconfigure($new_id, -fill => "");
        }
        if ($width == 0) {
            $canv->itemconfigure($new_id, -outline => "");
        }
        $props{$new_id}{type}      = $type;
        $props{$new_id}{x}         = $x;
        $props{$new_id}{y}         = $y;
        $props{$new_id}{xc}        = $xc;
        $props{$new_id}{yc}        = $yc;
        $props{$new_id}{anchor}    = $anchor;
        $props{$new_id}{coordlist} = [ @coords ];
        $props{$new_id}{color}     = $color;
        $props{$new_id}{width}     = $width;
        $props{$new_id}{fill}      = $fill;
        $props{$new_id}{fillcolor} = $fillcolor;

    } elsif ($type eq "ellipse") {
        $color     = $props{$id}{color};
        $width     = $props{$id}{width};
        $fill      = $props{$id}{fill};
        $fillcolor = $props{$id}{fillcolor};
        $hw        = $props{$id}{hw};
        $hh        = $props{$id}{hh};
        $angle     = $props{$id}{angle};

        @coords = &make_shape_coords($type, $xc, $yc, $hw, $hh, $angle);
        $new_id = $canv->create_polygon(@coords,
                         -outline => &get_rgb_code($color),
                         -width   => $width,
                         -smooth  => 'false',
                         -tags    => "keep");
        if ($fill && $fillcolor ne "") {
            $canv->itemconfigure($new_id, -fill => &get_rgb_code($fillcolor));
        } else {
            $canv->itemconfigure($new_id, -fill => "");
        }
        if ($width == 0) {
            $canv->itemconfigure($new_id, -outline => "");
        }
        $props{$new_id}{type}      = $type;
        $props{$new_id}{x}         = $x;
        $props{$new_id}{y}         = $y;
        $props{$new_id}{xc}        = $xc;
        $props{$new_id}{yc}        = $yc;
        $props{$new_id}{hw}        = $hw;
        $props{$new_id}{hh}        = $hh;
        $props{$new_id}{anchor}    = $anchor;
        $props{$new_id}{coordlist} = [ @coords ];
        $props{$new_id}{color}     = $color;
        $props{$new_id}{width}     = $width;
        $props{$new_id}{fill}      = $fill;
        $props{$new_id}{fillcolor} = $fillcolor;
        $props{$new_id}{angle}     = $angle;
        $props{$new_id}{angle_tmp} = $angle;
        $props{$new_id}{smooth}    = 0;

    } elsif ($type =~ /^(rectangle|diamond)$/) {
        $color     = $props{$id}{color};
        $width     = $props{$id}{width};
        $fill      = $props{$id}{fill};
        $fillcolor = $props{$id}{fillcolor};
        $smooth    = $props{$id}{smooth};
        $new_id    = $canv->create_polygon(@coords,
                            -outline => &get_rgb_code($color),
                            -width   => $width,
                            -smooth  => $smooth_type[$smooth],
                            -tags    => "keep");
        if ($fill && $fillcolor ne "") {
            $canv->itemconfigure($new_id, -fill => &get_rgb_code($fillcolor));
        } else {
            $canv->itemconfigure($new_id, -fill => "");
        }
        if ($width == 0) {
            $canv->itemconfigure($new_id, -outline => "");
        }
        $props{$new_id}{type}      = $type;
        $props{$new_id}{x}         = $x;
        $props{$new_id}{y}         = $y;
        $props{$new_id}{xc}        = $xc;
        $props{$new_id}{yc}        = $yc;
        $props{$new_id}{anchor}    = $anchor;
        $props{$new_id}{coordlist} = [ @coords ];
        $props{$new_id}{color}     = $color;
        $props{$new_id}{width}     = $width;
        $props{$new_id}{fill}      = $fill;
        $props{$new_id}{fillcolor} = $fillcolor;
        $props{$new_id}{angle}     = $props{$id}{angle};
        $props{$new_id}{angle_tmp} = $props{$id}{angle};
        $props{$new_id}{smooth}    = $smooth;

    } elsif ($type eq "polygon") {
        $color     = $props{$id}{color};
        $width     = $props{$id}{width};
        $fill      = $props{$id}{fill};
        $fillcolor = $props{$id}{fillcolor};
        $new_id    = $canv->create_polygon(@coords,
                            -outline => &get_rgb_code($color),
                            -width   => $width,
                            -tags    => "keep");
        if ($fill && $fillcolor ne "") {
            $canv->itemconfigure($new_id, -fill => &get_rgb_code($fillcolor));
        } else {
            $canv->itemconfigure($new_id, -fill => "");
        }
        if ($width == 0) {
            $canv->itemconfigure($new_id, -outline => "");
        }
        $props{$new_id}{type}      = $type;
        $props{$new_id}{x}         = $x;
        $props{$new_id}{y}         = $y;
        $props{$new_id}{xc}        = $xc;
        $props{$new_id}{yc}        = $yc;
        $props{$new_id}{anchor}    = $anchor;
        $props{$new_id}{coordlist} = [ @coords ];
        $props{$new_id}{color}     = $color;
        $props{$new_id}{width}     = $width;
        $props{$new_id}{fill}      = $fill;
        $props{$new_id}{fillcolor} = $fillcolor;
        $props{$new_id}{angle}     = $props{$id}{angle};
        $props{$new_id}{angle_tmp} = $props{$id}{angle};
        $props{$new_id}{xc_rot}    = $props{$id}{xc_rot} +10;
        $props{$new_id}{yc_rot}    = $props{$id}{yc_rot} +10;

    } elsif ($type eq "text") {
        $text      = $props{$id}{text};
        $color     = $props{$id}{color};
        $angle     = $props{$id}{angle};
        $family    = $props{$id}{family};
        $size      = $props{$id}{size};
        $weight    = $props{$id}{weight};
        $slant     = $props{$id}{slant};
        $underline = $props{$id}{underline};
        $new_id    = $canv->create_text($x, $y,
                            -anchor => $anchor,
                            -text   => $text,
                            -fill   => &get_rgb_code($color),
                            -angle  => $angle,
                            -tags   => "keep",
                            -font   => [-family     => $family,
                                        -size       => $size,
                                        -weight     => $weight,
                                        -slant      => $slant_type[$slant],
                                        -underline  => $underline,
                                        -overstrike => 0,
                                       ]);
        $props{$new_id}{type}      = $type;
        $props{$new_id}{text}      = $text;
        $props{$new_id}{x}         = $x;
        $props{$new_id}{y}         = $y;
        $props{$new_id}{xc}        = $xc;
        $props{$new_id}{yc}        = $yc;
        $props{$new_id}{anchor}    = $anchor;
        $props{$new_id}{coordlist} = [$x, $y];
        $props{$new_id}{color}     = $color;
        $props{$new_id}{family}    = $family;
        $props{$new_id}{size}      = $size;
        $props{$new_id}{weight}    = $weight;
        $props{$new_id}{slant}     = $slant;
        $props{$new_id}{underline} = $underline;
        $props{$new_id}{angle}     = $angle;

    } elsif ($type eq "image") {
        $file  = $props{$id}{file};
        $angle = $props{$id}{angle};
        $flip  = $props{$id}{flip};
        @crop  = @{ $props{$id}{crop} };

        $img = Imager->new;
        $img->read(file => $file) or
                return &pop_up_error($main, "Failed to load $file\n $img->errstr");
        $img = $img->convert(preset => 'addalpha');
        $iwo = $img->getwidth();
        $iho = $img->getheight();
        if ($crop[0] > 0. || $crop[1] > 0. || $crop[2] > 0. || $crop[3] > 0.) {
            $img = $img->crop(left   => &round_to_int($iwo *$crop[0]),
                              right  => &round_to_int($iwo *(1.0 -$crop[1])),
                              top    => &round_to_int($iho *$crop[2]),
                              bottom => &round_to_int($iho *(1.0 -$crop[3])));
        }
        $iwc = $img->getwidth();
        $ihc = $img->getheight();
        if ($iwc != $props{$id}{iw}) {
            $img = $img->scale(xpixels => $props{$id}{iw});
        }
        if ($flip ne "none") {
            $img->flip(dir => $flip);
        }
        $img->write(data => \$img_data, type => 'png');
        $image = Tkx::image_create_photo(-data => $img_data);
        $new_id = $canv->create_image($xc, $yc,
                                      -anchor => 'center',
                                      -image  => $image,
                                      -tags   => "keep",
                                      -state  => 'hidden');
        $props{$new_id}{type}      = $type;
        $props{$new_id}{x}         = $x;
        $props{$new_id}{y}         = $y;
        $props{$new_id}{xc}        = $xc;
        $props{$new_id}{yc}        = $yc;
        $props{$new_id}{anchor}    = $anchor;
        $props{$new_id}{coordlist} = [$xc, $yc];
        $props{$new_id}{iw}        = Tkx::image_width($image);
        $props{$new_id}{ih}        = Tkx::image_height($image);
        $props{$new_id}{iwo}       = $iwo;
        $props{$new_id}{iho}       = $iho;
        $props{$new_id}{iwc}       = $iwc;
        $props{$new_id}{ihc}       = $ihc;
        $props{$new_id}{crop}      = [ @crop ];
        $props{$new_id}{file}      = $file;
        $props{$new_id}{image}     = $image;
        $props{$new_id}{idata}     = $img_data;
        $props{$new_id}{angle}     = $angle;
        $props{$new_id}{flip}      = $flip;
        if ($angle != 0) {
            $img = $img->rotate(degrees => -1 *$angle);
            $img->write(data => \$img_data, type => 'png');
            $image = Tkx::image_create_photo(-data => $img_data);
            $canv->itemconfigure($new_id, -image => $image);
        }
        $canv->itemconfigure($new_id, -state => 'normal');

    } elsif ($type eq "graph") {
        $color  = $props{$id}{color};
        $width  = $props{$id}{width};
        $new_id = $canv->create_rectangle(@coords,
                         -outline => &get_rgb_code($color),
                         -width   => $width,
                         -fill    => "",
                         -tags    => "keep");
        $props{$new_id}{type}      = $type;
        $props{$new_id}{meta}      = $props{$id}{meta};
        $props{$new_id}{x}         = $x;
        $props{$new_id}{y}         = $y;
        $props{$new_id}{xc}        = $xc;
        $props{$new_id}{yc}        = $yc;
        $props{$new_id}{anchor}    = $anchor;
        $props{$new_id}{coordlist} = [ @coords ];
        $props{$new_id}{oldcoords} = [ @coords ];
        $props{$new_id}{color}     = $color;
        $props{$new_id}{width}     = $width;
        $props{$new_id}{fill}      = $props{$id}{fill};
        $props{$new_id}{data}      = 1;
        $props{$new_id}{gnum}      = ++$graph_num;
        $canv->addtag("graph" . $new_id, withtag => $new_id);

        %profile_tmp               = %{ $gr_props{$id} };
        $gr_props{$new_id}         =  { %profile_tmp   };
        $gr_props{$new_id}{redraw} = 1;

        if ($props{$new_id}{meta} =~
              /data_profile|w2_profile|w2_tdmap|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone|time_series/) {
            push (@animate_ids, $new_id);
        }

        if ($props{$new_id}{meta} =~ /data_profile/) {
            $props{$new_id}{files}      = 1;
            $props{$new_id}{src_file}   = $props{$id}{src_file};
            $props{$new_id}{parm}       = $props{$id}{parm};
            $props{$new_id}{parm_units} = $props{$id}{parm_units};
            $props{$new_id}{prof_type}  = $props{$id}{prof_type};
            if ($props{$id}{prof_type} =~ /difference/i) {
                $props{$new_id}{dref_type} = $props{$id}{dref_type};
                if ($props{$id}{dref_type} =~ /Constant/i) {
                    $props{$new_id}{dref_val} = $props{$id}{dref_val};
                } else {
                    $props{$new_id}{dref_file}  = $props{$id}{dref_file};
                    $props{$new_id}{dref_ftype} = $props{$id}{dref_ftype};
                    $props{$new_id}{dref_lines} = $props{$id}{dref_lines};
                    $props{$new_id}{dref_parm}  = $props{$id}{dref_parm};
                    $props{$new_id}{dref_ctype} = $props{$id}{dref_ctype};
                    $props{$new_id}{dref_tol}   = $props{$id}{dref_tol};
                    if ($props{$id}{dref_ftype} =~ /^W2 /) {
                        $props{$new_id}{dref_byear} = $props{$id}{dref_byear};
                        $props{$new_id}{dref_tzoff} = $props{$id}{dref_tzoff};
                    }
                }
            }
            &make_data_profile($canv, $new_id, 1);

        } elsif ($props{$new_id}{meta} =~ /w2_profile/) {
            %grid_tmp                   = %{ $grid{$id} };
            $grid{$new_id}              = { %grid_tmp };
            $props{$new_id}{con_file}   = $props{$id}{con_file};
            $props{$new_id}{bth_file}   = $props{$id}{bth_file};
            $props{$new_id}{src_type}   = $props{$id}{src_type};
            $props{$new_id}{src_file}   = $props{$id}{src_file};
            $props{$new_id}{src_lines}  = $props{$id}{src_lines};
            $props{$new_id}{tplot}      = $props{$id}{tplot};
            $props{$new_id}{parm}       = $props{$id}{parm};
            $props{$new_id}{parm_div}   = $props{$id}{parm_div};
            $props{$new_id}{parm_units} = $props{$id}{parm_units};
            $props{$new_id}{ctype}      = $props{$id}{ctype};
            $props{$new_id}{seg}        = $props{$id}{seg};
            $props{$new_id}{byear}      = $props{$id}{byear};
            $props{$new_id}{tz_offset}  = $props{$id}{tz_offset};
            $props{$new_id}{jd_skip}    = $props{$id}{jd_skip};
            $props{$new_id}{files}      = 1;
            if (defined($props{$id}{ref_file})) {
                $props{$new_id}{ref_file}  = $props{$id}{ref_file};
                $props{$new_id}{ref_ctype} = $props{$id}{ref_ctype};
                $props{$new_id}{ref_tol}   = $props{$id}{ref_tol};
                $props{$new_id}{ref_color} = $props{$id}{ref_color};
                $props{$new_id}{ref_hide}  = $props{$id}{ref_hide};
            }
            &make_w2_profile($canv, $new_id, 1);

        } elsif ($props{$new_id}{meta} =~ /w2_slice/) {
            %grid_tmp                   = %{ $grid{$id} };
            $grid{$new_id}              = { %grid_tmp };
            $props{$new_id}{con_file}   = $props{$id}{con_file};
            $props{$new_id}{src_type}   = $props{$id}{src_type};
            $props{$new_id}{seg_list}   = $props{$id}{seg_list};
            $props{$new_id}{wb_list}    = $props{$id}{wb_list};
            $props{$new_id}{parm}       = $props{$id}{parm};
            $props{$new_id}{parm_div}   = $props{$id}{parm_div};
            $props{$new_id}{parm_units} = $props{$id}{parm_units};
            $props{$new_id}{ctype}      = $props{$id}{ctype};
            $props{$new_id}{byear}      = $props{$id}{byear};
            $props{$new_id}{tz_offset}  = $props{$id}{tz_offset};
            $props{$new_id}{jd_skip}    = $props{$id}{jd_skip};
            $props{$new_id}{dt_limits}  = $props{$id}{dt_limits};
            $props{$new_id}{files}      = 1;
            if ($props{$id}{src_type} =~ /Contour/i) {
                $props{$new_id}{tecplot}   = $props{$id}{tecplot};
                $props{$new_id}{cpl_lines} = $props{$id}{cpl_lines};
                $props{$new_id}{cpl_files} = $props{$id}{cpl_files};
                $props{$new_id}{bth_files} = $props{$id}{bth_files};
            } elsif ($props{$id}{src_type} =~ /Vector/i) {
                $props{$new_id}{w2l_file}  = $props{$id}{w2l_file};
                $props{$new_id}{bth_files} = $props{$id}{bth_files};
            }
            if ($props{$new_id}{dt_limits}) {
                $props{$new_id}{dt_begin}  = $props{$id}{dt_begin};
                $props{$new_id}{dt_end}    = $props{$id}{dt_end};
            }
            &make_w2_slice($canv, $new_id, 1);

        } elsif ($props{$new_id}{meta} =~ /w2_tdmap/) {
            %grid_tmp                   = %{ $grid{$id} };
            $grid{$new_id}              = { %grid_tmp };
            $props{$new_id}{con_file}   = $props{$id}{con_file};
            $props{$new_id}{src_type}   = $props{$id}{src_type};
            $props{$new_id}{seg_list}   = $props{$id}{seg_list};
            $props{$new_id}{wb_list}    = $props{$id}{wb_list};
            $props{$new_id}{map_type}   = $props{$id}{map_type};
            $props{$new_id}{parm}       = $props{$id}{parm};
            $props{$new_id}{parm_sav}   = $props{$id}{parm_sav};
            $props{$new_id}{parm_div}   = $props{$id}{parm_div};
            $props{$new_id}{pdiv_sav}   = $props{$id}{pdiv_sav};
            $props{$new_id}{parm_units} = $props{$id}{parm_units};
            $props{$new_id}{prof_stat}  = $props{$id}{prof_stat};
            $props{$new_id}{ctype}      = $props{$id}{ctype};
            $props{$new_id}{byear}      = $props{$id}{byear};
            $props{$new_id}{tz_offset}  = $props{$id}{tz_offset};
            $props{$new_id}{jd_skip}    = $props{$id}{jd_skip};
            $props{$new_id}{files}      = 1;
            if ($props{$id}{src_type} =~ /Contour/i) {
                $props{$new_id}{tecplot}   = $props{$id}{tecplot};
                $props{$new_id}{cpl_lines} = $props{$id}{cpl_lines};
                $props{$new_id}{cpl_files} = $props{$id}{cpl_files};
                $props{$new_id}{bth_files} = $props{$id}{bth_files};
            } elsif ($props{$id}{src_type} =~ /Vector/i) {
                $props{$new_id}{w2l_file}  = $props{$id}{w2l_file};
                $props{$new_id}{bth_files} = $props{$id}{bth_files};
            } elsif ($props{$id}{src_type} =~ /RiverCon/i) {
                $props{$new_id}{br_list}   = $props{$id}{br_list};
                $props{$new_id}{riv_lines} = $props{$id}{riv_lines};
                $props{$new_id}{riv_files} = $props{$id}{riv_files};
                $props{$new_id}{bth_files} = $props{$id}{bth_files};
            } elsif ($props{$id}{src_type} =~ /SurfTemp|VolTemp|FlowTemp/i) {
                $props{$new_id}{src_file}  = $props{$id}{src_file};
                $props{$new_id}{src_lines} = $props{$id}{src_lines};
                $props{$new_id}{bth_files} = $props{$id}{bth_files};
            }
            if ($props{$id}{map_type} =~ /^(parmdiff|filediff)$/) {
                $props{$new_id}{src_type2} = $props{$id}{src_type2};
                $props{$new_id}{parm2}     = $props{$id}{parm2};
                $props{$new_id}{parm2_sav} = $props{$id}{parm2_sav};
                $props{$new_id}{parm2_div} = $props{$id}{parm2_div};
                $props{$new_id}{pdiv2_sav} = $props{$id}{pdiv2_sav};
                $props{$new_id}{ctype2}    = $props{$id}{ctype2};
                $props{$new_id}{data2}     = 1;
                if ($props{$id}{src_type2} =~ /Contour/i) {
                    $props{$new_id}{tecplot2}   = $props{$id}{tecplot2};
                    $props{$new_id}{cpl_lines2} = $props{$id}{cpl_lines2};
                    $props{$new_id}{cpl_files2} = $props{$id}{cpl_files2};
                } elsif ($props{$id}{src_type2} =~ /Vector/i) {
                    $props{$new_id}{w2l_file2}  = $props{$id}{w2l_file2};
                } elsif ($props{$id}{src_type2} =~ /RiverCon/i) {
                    $props{$new_id}{br_list2}   = $props{$id}{br_list2};
                    $props{$new_id}{riv_lines2} = $props{$id}{riv_lines2};
                    $props{$new_id}{riv_files2} = $props{$id}{riv_files2};
                } elsif ($props{$id}{src_type2} =~ /SurfTemp|VolTemp|FlowTemp/i) {
                    $props{$new_id}{src_file2}  = $props{$id}{src_file2};
                    $props{$new_id}{src_lines2} = $props{$id}{src_lines2};
                }
                if ($props{$id}{map_type} eq "filediff") {
                    $props{$new_id}{match_tol} = $props{$id}{match_tol};
                }
            }
            &make_w2_tdmap($canv, $new_id, 1);

        } elsif ($props{$new_id}{meta} =~ /w2_outflow/) {
            %grid_tmp                   = %{ $grid{$id} };
            $grid{$new_id}              = { %grid_tmp };
            $props{$new_id}{con_file}   = $props{$id}{con_file};
            $props{$new_id}{bth_file}   = $props{$id}{bth_file};
            $props{$new_id}{qla_file}   = $props{$id}{qla_file};
            $props{$new_id}{qla_lines}  = $props{$id}{qla_lines};
            $props{$new_id}{seg}        = $props{$id}{seg};
            $props{$new_id}{byear}      = $props{$id}{byear};
            $props{$new_id}{tz_offset}  = $props{$id}{tz_offset};
            $props{$new_id}{jd_skip}    = $props{$id}{jd_skip};
            $props{$new_id}{add_parm}   = $props{$id}{add_parm};
            $props{$new_id}{files}      = 1;
            if ($props{$id}{add_parm}) {
                $props{$new_id}{src_type}   = $props{$id}{src_type};
                $props{$new_id}{src_file}   = $props{$id}{src_file};
                $props{$new_id}{src_lines}  = $props{$id}{src_lines};
                $props{$new_id}{tplot}      = $props{$id}{tplot};
                $props{$new_id}{parm}       = $props{$id}{parm};
                $props{$new_id}{parm_div}   = $props{$id}{parm_div};
                $props{$new_id}{parm_units} = $props{$id}{parm_units};
                $props{$new_id}{parm_ctype} = $props{$id}{parm_ctype};
                $props{$new_id}{parm_skip}  = $props{$id}{parm_skip};
                $props{$new_id}{match_tol}  = $props{$id}{match_tol};
            }
            &make_w2_outflow($canv, $new_id, 1);

        } elsif ($props{$new_id}{meta} =~ /w2_wlevels/) {
            %grid_tmp                  = %{ $grid{$id} };
            $grid{$new_id}             = { %grid_tmp };
            $props{$new_id}{con_file}  = $props{$id}{con_file};
            $props{$new_id}{src_type}  = $props{$id}{src_type};
            $props{$new_id}{seg_list}  = $props{$id}{seg_list};
            $props{$new_id}{wb_list}   = $props{$id}{wb_list};
            $props{$new_id}{byear}     = $props{$id}{byear};
            $props{$new_id}{tz_offset} = $props{$id}{tz_offset};
            $props{$new_id}{jd_skip}   = $props{$id}{jd_skip};
            $props{$new_id}{extra_chk} = $props{$id}{extra_chk};
            $props{$new_id}{files}     = 1;
            if ($props{$id}{src_type} =~ /Contour/i) {
                $props{$new_id}{tecplot}   = $props{$id}{tecplot};
                $props{$new_id}{cpl_lines} = $props{$id}{cpl_lines};
                $props{$new_id}{cpl_files} = $props{$id}{cpl_files};
                $props{$new_id}{bth_files} = $props{$id}{bth_files};
            } elsif ($props{$id}{src_type} =~ /Vector/i) {
                $props{$new_id}{w2l_file}  = $props{$id}{w2l_file};
                $props{$new_id}{bth_files} = $props{$id}{bth_files};
            } elsif ($props{$id}{src_type} =~ /Water Level/i) {
                $props{$new_id}{wl_file}   = $props{$id}{wl_file};
                $props{$new_id}{wl_lines}  = $props{$id}{wl_lines};
                $props{$new_id}{bth_files} = $props{$id}{bth_files};
            }
            &make_w2_wlevels($canv, $new_id, 1);

        } elsif ($props{$new_id}{meta} eq "vert_wd_zone") {
            $props{$new_id}{files}     = 1;
            $props{$new_id}{wt_file}   = $props{$id}{wt_file};
            $props{$new_id}{wd_alg}    = $props{$id}{wd_alg};
            $props{$new_id}{flow_file} = $props{$id}{flow_file};
            $props{$new_id}{bth_file}  = $props{$id}{bth_file};
            $props{$new_id}{seg}       = $props{$id}{seg};
            $props{$new_id}{elbot}     = $props{$id}{elbot};
            $props{$new_id}{wt_units}  = $props{$id}{wt_units};
            if ($props{$id}{wd_alg} eq "Libby Dam") {
                $props{$new_id}{lbc_file} = $props{$id}{lbc_file};
            }
            &make_wd_zone($canv, $new_id, 1);

        } elsif ($props{$new_id}{meta} eq "linked_time_series") {
            $props{$new_id}{link_id}  = $props{$id}{link_id};
            $props{$new_id}{ts_parms} = $props{$id}{ts_parms};
            if (defined($props{$id}{add_ts_parms})) {
                $props{$new_id}{add_ts_parms} = $props{$id}{add_ts_parms};
            }
            &make_ts_graph($canv, $new_id, 1);

        } elsif ($props{$new_id}{meta} eq "time_series") {
            $props{$new_id}{ts_parms}     = $props{$id}{ts_parms};
            $props{$new_id}{add_ts_parms} = $props{$id}{add_ts_parms};
            &make_ts_graph($canv, $new_id, 1);
        }
    }

#   Take care of links
    if ($type =~ /^(text|circle|ellipse|rectangle|diamond|polygon)$/
              && defined($link_props{$id}{id}) && $link_props{$id}{form} ne "stat") {
        $link_props{$new_id}{id}     = $link_props{$id}{id};
        $link_props{$new_id}{gnum}   = $link_props{$id}{gnum};
        $link_props{$new_id}{type}   = $link_props{$id}{type};
        $link_props{$new_id}{outlet} = $link_props{$id}{outlet};
        $link_props{$new_id}{form}   = $link_props{$id}{form};
        $link_props{$new_id}{units}  = $link_props{$id}{units};
        $link_props{$new_id}{digits} = $link_props{$id}{digits};

        $canv->addtag("link_gr" . $link_props{$id}{id}, withtag => $new_id);
    }
    if ($type eq "text" && defined($link_props{$id}{id})
                        && $link_props{$id}{form} eq "stat") {
        $link_props{$new_id}{id}     = $link_props{$id}{id};
        $link_props{$new_id}{gnum}   = $link_props{$id}{gnum};
        $link_props{$new_id}{type}   = $link_props{$id}{type};
        $link_props{$new_id}{form}   = $link_props{$id}{form};
        $link_props{$new_id}{tol}    = $link_props{$id}{tol};
        $link_props{$new_id}{interp} = $link_props{$id}{interp};
        $link_props{$new_id}{digits} = $link_props{$id}{digits};

        $canv->addtag("link_gr" . $link_props{$id}{id}, withtag => $new_id);
    }

#   Place the duplicate
    &begin_move($canv, $new_id, "");
}


sub object_kill {
    my ($canv, $id) = @_;
    my (
        $datemax, $datemin, $first, $i, $id0, $item, $keep_anim_menu,
        $n, $redo_dates, $ts_present,
        @cpl_files, @items, @mydates, @wbs,
        %pdata,
       );

    if ($props{$id}{type} eq "graph") {
        $canv->delete("graph" . $id);
        if (&list_match($id, @animate_ids) >= 0) {
            splice(@animate_ids, &list_match($id, @animate_ids), 1);
        }
        if ($props{$id}{meta} eq "vert_wd_zone") {
            if ($props{$id}{wd_alg} eq "Libby Dam") {
                if ($gr_props{$id}{bh_show} && ! $gr_props{$id}{bh_docked}) {
                    $canv->delete("graph" . $id . "_openBH");
                }
            }
        }
        delete $gr_props{$id};

#       Delete any associated links
        @items = Tkx::SplitList($canv->find_withtag("link_gr" . $id));
        if ($#items >= 0) {
            foreach $item (@items) {
                delete $props{$item};
                delete $link_props{$item};
            }
            $canv->delete("link_gr" . $id);
        }

#       Delete any associated linked time-series graphs
        @items = Tkx::SplitList($canv->find_withtag("tslink_gr" . $id));
        if ($#items >= 0) {
            foreach $item (@items) {
                $canv->delete("graph" . $item);
                if (&list_match($item, @animate_ids) >= 0) {
                    splice(@animate_ids, &list_match($item, @animate_ids), 1);
                }
                delete $props{$item};
                delete $gr_props{$item};
            }
        }
        if ($use_GS) {
            $keep_anim_menu = 0;
            $export_menu->entryconfigure(3, -state => 'disabled');
            for ($i=0; $i<=$#animate_ids; $i++) {
                if ($props{$animate_ids[$i]}{meta}
                       =~ /^(data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)$/) {
                    $export_menu->entryconfigure(3, -state => 'normal');
                    $keep_anim_menu = 1;
                    last;
                }
            }
            if (! $keep_anim_menu && defined($animate_tb) && Tkx::winfo_exists($animate_tb)) {
                if ($animate_tb->g_wm_title() eq "Animation toolbar") {
                    $animate_tb->g_destroy();
                    undef $animate_tb;
                }
            }
        }

#       Determine whether any animated graphs are present, and adjust the preferences menu
        $pref_menu->entryconfigure(0, -state => 'disabled');
        if (@animate_ids && $#animate_ids >= 0) {
            foreach $item (@animate_ids) {
                if ($props{$item}{meta}
                        =~ /^(data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)$/) {
                    $pref_menu->entryconfigure(0, -state => 'normal');
                    last;
                }
            }
        }

#       Remove the Graph Properties menu, if present
        if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
            if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
                $graph_props_menu->g_destroy();
                undef $graph_props_menu;
            }
        }

#       Remove the Object Information box, if present
        if (defined($object_infobox) && Tkx::winfo_exists($object_infobox)) {
            if ($object_infobox->g_wm_title() eq "Object Info") {
                $object_infobox->g_destroy();
                undef $object_infobox;
            }
        }

#       Reconstruct the @dates array, if needed
        if ($props{$id}{meta} =~ /^(data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)$/) {
            $redo_dates = 0;
            $id0 = -1;
            for ($i=0; $i<=$#animate_ids; $i++) {
                if ($props{$animate_ids[$i]}{meta}
                       =~ /^(data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)$/) {
                    $id0 = $animate_ids[$i];
                    last;
                }
            }
            if ($id0 == -1) {        # No animated graphs left.  Remove any vertical datelines.
                @dates = ();
                for ($i=0; $i<=$#animate_ids; $i++) {
                    $id0 = $animate_ids[$i];
                    if ($props{$id0}{meta} =~ /time_series/) {
                        $canv->delete("graph" . $id0 . "_dateline");
                    } elsif ($props{$id0}{meta} =~ /profile_cmap/) {
                        $canv->delete("graph" . $id0 . "_colorMapDateline");
                    }
                }
            } else {
                for ($i=0; $i<=$#animate_ids; $i++) {
                    $item = $animate_ids[$i];
                    next if ($props{$item}{meta}
                                !~ /^(data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)$/);
                    if ($props{$id}{meta} eq "data_profile") {
                        if ($props{$item}{meta} =~ /w2_profile|w2_slice|w2_outflow|w2_wlevels/ ||
                            ($props{$item}{meta} eq "data_profile"
                              && $props{$item}{src_file} ne $props{$id}{src_file}) ||
                            ($props{$item}{meta} eq "vert_wd_zone"
                              && $props{$item}{wt_file} ne $props{$id}{src_file})) {
                            $redo_dates = 1;
                            last;
                        }
                    } elsif ($props{$id}{meta} eq "vert_wd_zone") {
                        if ($props{$item}{meta} =~ /w2_profile|w2_slice|w2_outflow|w2_wlevels/ ||
                            ($props{$item}{meta} eq "vert_wd_zone"
                              && $props{$item}{wt_file} ne $props{$id}{wt_file}) ||
                            ($props{$item}{meta} eq "data_profile"
                              && $props{$item}{src_file} ne $props{$id}{wt_file})) {
                            $redo_dates = 1;
                            last;
                        }
                    } elsif ($props{$id}{meta} eq "w2_profile") {
                        if ($props{$item}{meta} =~ /data_profile|vert_wd_zone|w2_outflow/ ||
                            ($props{$item}{meta} eq "w2_profile"
                              && ($props{$item}{src_file}  ne $props{$id}{src_file}  ||
                                  $props{$item}{byear}     != $props{$id}{byear}     ||
                                  $props{$item}{tz_offset} ne $props{$id}{tz_offset} ||
                                  $props{$item}{jd_skip}   != $props{$id}{jd_skip})) ||
                            ($props{$item}{meta} eq "w2_slice"
                              && $props{$item}{dt_limits})) {
                            $redo_dates = 1;
                            last;
                        }
                        if ($props{$item}{meta} =~ /w2_slice|w2_wlevels/) {
                            if ($props{$item}{src_type}      ne $props{$id}{src_type}
                                 || $props{$item}{byear}     != $props{$id}{byear}
                                 || $props{$item}{tz_offset} ne $props{$id}{tz_offset}
                                 || $props{$item}{jd_skip}   != $props{$id}{jd_skip}) {
                                $redo_dates = 1;
                                last;
                            } elsif ($props{$item}{src_type} =~ /Contour/i) {
                                @wbs        = split(/,/, $props{$item}{wb_list});
                                @cpl_files  = @{ $props{$item}{cpl_files} };
                                $redo_dates = 1;
                                for ($n=0; $n<=$#wbs; $n++) {
                                    if ($cpl_files[$n] eq $props{$id}{src_file}) {
                                        $redo_dates = 0;
                                        last;
                                    }
                                }
                                last if ($redo_dates);
                            } elsif ($props{$item}{src_type} =~ /Vector/i) {
                                if ($props{$item}{w2l_file} ne $props{$id}{src_file}) {
                                    $redo_dates = 1;
                                    last;
                                }
                            }
                            if ($props{$item}{meta} eq "w2_slice") {
                                if ($props{$item}{dt_limits}) {
                                    $redo_dates = 1;
                                    last;
                                }
                            }
                        }
                    } elsif ($props{$id}{meta} =~ /w2_slice|w2_wlevels/) {
                        if ($props{$item}{meta} =~ /data_profile|vert_wd_zone|w2_outflow/) {
                            $redo_dates = 1;
                            last;
                        }
                        if ($props{$id}{meta} eq "w2_slice") {
                            if ($props{$id}{dt_limits}) {
                                $redo_dates = 1;
                                last;
                            }
                        }
                        if ($props{$item}{meta} eq "w2_slice") {
                            if ($props{$item}{dt_limits}) {
                                $redo_dates = 1;
                                last;
                            }
                        }
                        if ($props{$item}{meta} =~ /w2_slice|w2_wlevels/) {
                            if ($props{$item}{con_file}      ne $props{$id}{con_file}
                                 || $props{$item}{src_type}  ne $props{$id}{src_type}
                                 || $props{$item}{byear}     != $props{$id}{byear}
                                 || $props{$item}{tz_offset} ne $props{$id}{tz_offset}
                                 || $props{$item}{jd_skip}   != $props{$id}{jd_skip}) {
                                $redo_dates = 1;
                                last;
                            }
                        } elsif ($props{$item}{meta} eq "w2_profile") {
                            if ($props{$item}{src_type}      ne $props{$id}{src_type}
                                 || $props{$item}{byear}     != $props{$id}{byear}
                                 || $props{$item}{tz_offset} ne $props{$id}{tz_offset}
                                 || $props{$item}{jd_skip}   != $props{$id}{jd_skip}) {
                                $redo_dates = 1;
                                last;
                            } elsif ($props{$item}{src_type} =~ /Contour/i) {
                                @wbs        = split(/,/, $props{$id}{wb_list});
                                @cpl_files  = @{ $props{$id}{cpl_files} };
                                $redo_dates = 1;
                                for ($n=0; $n<=$#wbs; $n++) {
                                    if ($cpl_files[$n] eq $props{$item}{src_file}) {
                                        $redo_dates = 0;
                                        last;
                                    }
                                }
                                last if ($redo_dates);
                            } elsif ($props{$item}{src_type} =~ /Vector/i) {
                                if ($props{$item}{src_file} ne $props{$id}{w2l_file}) {
                                    $redo_dates = 1;
                                    last;
                                }
                            }
                        }
                    } elsif ($props{$id}{meta} eq "w2_outflow") {
                        if ($props{$item}{meta}
                                =~ /data_profile|vert_wd_zone|w2_profile|w2_slice|w2_wlevels/ ||
                            ($props{$item}{meta} eq "w2_outflow"
                              && ($props{$item}{qla_file}  ne $props{$id}{qla_file}  ||
                                  $props{$item}{byear}     != $props{$id}{byear}     ||
                                  $props{$item}{tz_offset} ne $props{$id}{tz_offset} ||
                                  $props{$item}{jd_skip}   != $props{$id}{jd_skip}))) {
                            $redo_dates = 1;
                            last;
                        }
                    }
                }
                &rebuild_datelist if ($redo_dates);
            }
        }

#       Reset the min and max dates for colormaps, if needed
        if ($props{$id}{meta} =~ /data_profile_cmap|w2_profile_cmap|w2_tdmap/) {
            $first = 1;
            for ($i=0; $i<=$#animate_ids; $i++) {
                $item = $animate_ids[$i];
                next if ($props{$item}{meta} !~ /data_profile_cmap|w2_profile_cmap|w2_tdmap/);
                if ($props{$item}{meta} eq "data_profile_cmap") {
                    %pdata = %{ $gr_props{$item}{pdata} };
                } elsif ($props{$item}{meta} eq "w2_profile_cmap") {
                    %pdata = %{ $gr_props{$item}{parm_data} };
                } elsif ($props{$item}{meta} eq "w2_tdmap") {
                    %pdata = %{ $gr_props{$item}{td_data} };
                }
                @mydates = sort keys %pdata;
                $datemin = substr($mydates[0],0,8);
                $datemax = substr($mydates[$#mydates],0,8);
                $cmap_datemin = $datemin if ($first || $datemin < $cmap_datemin);
                $cmap_datemax = $datemax if ($first || $datemax > $cmap_datemax);
                $first = 0;
                undef %pdata;
            }
        }

#       Reset the min and max dates for time-series graphs, if needed
        if ($props{$id}{meta} =~ /time_series/) {
            undef $ts_datemin;
            undef $ts_datemax;
            $ts_present = 0;
            @items = Tkx::SplitList($canv->find_withtag("keep"));
            if ($#items >= 0) {
                $first = 1;
                foreach $item (@items) {
                    next if ($props{$item}{type} ne "graph");
                    next if ($props{$item}{meta} !~ /time_series/);
                    $ts_present = 1;
                    ($datemin, $datemax, undef, undef) = &find_ts_limits($item);
                    if ($datemin != -999) {
                        $ts_datemin = $datemin if ($first || $datemin < $ts_datemin);
                        $ts_datemax = $datemax if ($first || $datemax > $ts_datemax);
                        $first = 0;
                    }
                }
            }

#           Remove the zoom toolbar if no time-series graphs are present
            if (! $ts_present && defined($zoom_tb) && Tkx::winfo_exists($zoom_tb)) {
                if ($zoom_tb->g_wm_title() eq "Zoom toolbar") {
                    $zoom_tb->g_destroy();
                    undef $zoom_tb;
                }
            }
        }

#   Not a graph object
    } else {
        $canv->delete($id);
        delete $link_props{$id} if (defined($link_props{$id}));
    }

    $canv->delete("working");
    delete $props{$id};
    undef $old_id if (defined($old_id));
    &reset_bindings;
}


################################################################################
#
# Image placement and rotation
#
################################################################################

sub draw_image {
    my ($file, $id, $ih, $iho, $image, $img, $img_data, $iw, $iwo, $x, $y);

    &forget_drawing('');

    $file = Tkx::tk___getOpenFile(
                 -parent           => $main,
                 -title            => "Open Image File",
                 -initialdir       => abs_path(),
                 -defaultextension => ".png",
                 -filetypes =>
                 [ ['All image formats',
                                 ['.bmp','.gif','.jpg','.jpeg','.png',
                                  '.ppm','.tga','.tif','.tiff']],
                   ['Win32 bitmaps', '.bmp'],
                   ['Graphics Interchange Format files', '.gif'],
                   ['Joint Photographic Experts Group files', ['.jpg','.jpeg']],
                   ['Portable Network Graphics files', '.png'],
                   ['Unix portable pixmaps', '.ppm'],
                   ['Targa images', '.tga'],
                   ['Tagged Image Format files', ['.tif','.tiff']],
                 ],
               );
    if (! defined($file) || $file eq "") {
        &reset_bindings;
        return;
    }
    $file = File::Spec->rel2abs($file);
    $img = Imager->new;
    $img->read(file => $file) or
            return &pop_up_error($main, "Failed to load $file\n $img->errstr");
    $img = $img->convert(preset => 'addalpha');
    $iwo = $img->getwidth();
    $iho = $img->getheight();

#   Resize if original image is larger than canvas
    if ($iwo > $canvas_width || $iho > $canvas_height) {
        if ($iwo /$canvas_width >= $iho /$canvas_height) {
            $img = $img->scale(xpixels => &round_to_int($canvas_width *0.8));
        } else {
            $img = $img->scale(ypixels => &round_to_int($canvas_height *0.8));
        }

#   Otherwise, invoke scale function to help fill in alpha channel
    } else {
        $img = $img->scale(xpixels => $iwo);
    }

    $iw = $img->getwidth();
    $ih = $img->getheight();
    $x  = $canvas_width/2  -$iw/2;
    $y  = $canvas_height/2 -$ih/2;
    $img->write(data => \$img_data, type => 'png');
    $image = Tkx::image_create_photo(-data => $img_data);
    $id = $canvas->create_image($x, $y,
                                -anchor => 'center',
                                -image  => $image,
                                -tags   => "working",
                                -state  => 'hidden');
    $props{$id}{type}   = "image";
    $props{$id}{x}      = $x;
    $props{$id}{y}      = $y;
    $props{$id}{anchor} = 'nw';
    $props{$id}{iw}     = $iw;
    $props{$id}{ih}     = $ih;
    $props{$id}{iwo}    = $iwo;
    $props{$id}{iho}    = $iho;
    $props{$id}{iwc}    = $iwo;
    $props{$id}{ihc}    = $iho;
    $props{$id}{crop}   = [ 0.0, 0.0, 0.0, 0.0 ];
    $props{$id}{file}   = $file;
    $props{$id}{image}  = $image;
    $props{$id}{idata}  = $img_data;
    $props{$id}{angle}  = 0;
    $props{$id}{flip}   = "none";

    &find_rect_from_text_or_image($canvas, $id);  # set xc, yc
    $props{$id}{coordlist} = [$props{$id}{xc}, $props{$id}{yc}];

    $canvas->coords($id, $props{$id}{xc}, $props{$id}{yc});
    $canvas->itemconfigure($id, -state => 'normal');

    $canvas->g_bind("<Shift-Motion>", [ \&move_object, Tkx::Ev("%x","%y"), $canvas, $id, $x, $y, "", 1 ]);
    $canvas->g_bind("<Motion>",       [ \&move_object, Tkx::Ev("%x","%y"), $canvas, $id, $x, $y, "", 0 ]);
    $canvas->g_bind("<Button-1>",     [ \&end_place_image, $canvas, $id ]);
    $canvas->g_bind("<Button-3>",     [ \&forget_drawing, $id ]);
}


sub end_place_image {
    my ($canv, $id) = @_;

    $props{$id}{coordlist} = [ Tkx::SplitList($canv->coords($id)) ];
    $canv->dtag("working");
    $canv->itemconfigure($id, -tags => "keep");
    &reset_bindings;
}


sub begin_resize_image {
    my ($canv, $id) = @_;
    my ($box_id, $xo, $yo,
        @coords,
       );

    &end_select($canv, $id, 1);

    $xo = $props{$id}{x};
    $yo = $props{$id}{y};
    $canv->configure(-cursor => $cursor_draw);

    &make_crosshair($xo, $yo, $canv, $props{$id}{angle});
    $props{$id}{angle_tmp} = $props{$id}{angle};

    $canv->create_rectangle($xo-2, $yo-2, $xo+2, $yo+2,
                 -outline => &get_rgb_code($anchor_line_color),
                 -width   => 1,
                 -fill    => &get_rgb_code($anchor_select_color),
                 -tags    => "anchor");

    @coords = &find_rect_from_text_or_image($canv, $id);
    $box_id = $canv->create_polygon(@coords,
                 -outline => '#000000',
                 -width   => 1,
                 -fill    => "",
                 -tags    => "working");
    $canv->raise($box_id, $id);

    $canv->g_bind("<Control-Motion>", [ \&size_image, Tkx::Ev("%x","%y"), $canv, $box_id, $id, 1 ]);
    $canv->g_bind("<Motion>",         [ \&size_image, Tkx::Ev("%x","%y"), $canv, $box_id, $id, 0 ]);
    $canv->g_bind("<Button-1>",       [ \&end_resize_image,    $canv, $id ]);
    $canv->g_bind("<Button-3>",       [ \&forget_resize_image, $canv ]);
}


sub size_image {
    my ($x, $y, $canv, $box_id, $id, $ctrl) = @_;
    my (
        $anc, $ang, $ang2, $aspr, $dx, $dy, $h, $hh, $hw, $snap, $w, $xc,
        $xo, $xp, $yc, $yo, $yp,
        @coords,
       );

    $aspr = $props{$id}{iw} /$props{$id}{ih};   # aspect ratio: width/height
    $xo   = $props{$id}{x};
    $yo   = $props{$id}{y};
    $ang  = $props{$id}{angle};
    $anc  = $props{$id}{anchor};
    $snap = ($ang % 90 == 0 || $ctrl) ? 1 : 0;
    ($x, $y) = &get_xy($canv, $x, $y, $snap);

#   Modify crosshair, if needed
    if ($ang != 0) {
        if ($ctrl) {
            $ang = 0;
            if ($props{$id}{angle_tmp} != 0) {
                $props{$id}{angle_tmp} = 0;
                &make_crosshair($xo, $yo, $canv, $ang);
            }
        } elsif ($props{$id}{angle_tmp} != $props{$id}{angle}) {
            $props{$id}{angle_tmp} = $props{$id}{angle};
            &make_crosshair($xo, $yo, $canv, $ang);
        }
    }

#   Do calculations in un-rotated space
#   Must calculate half-width (hw), half-height (hh),
#    center point (xc, yc), and mouse pointer (xp, yp)
    if ($ang == 0) {
        $dx = $x -$xo;
        $dy = $y -$yo;
        $xp = $x;
        $yp = $y;
    } else {
        if ($x == $xo) {
            if ($y == $yo) {
                $ang2 = 0;
            } else {
                $ang2 = ($y > $yo) ? 270 : 90;
            }
        } elsif ($y == $yo) {
            $ang2 = ($x > $xo) ? 0 : 180;
        } else {
            $ang2 = (180./pi)*atan2(($yo-$y),($x-$xo));
        }
        $h  = sqrt(($x-$xo)*($x-$xo)+($y-$yo)*($y-$yo));
        $dx =  $h *cos(($ang2 -$ang) *pi/180.);
        $dy = -$h *sin(($ang2 -$ang) *pi/180.);
        $xp = $xo +$dx;
        $yp = $yo +$dy;
    }
    $w  = abs($dx);
    $h  = abs($dy);
    $w *= 2. if ($anc =~ /^(n|s|center)$/);
    $h *= 2. if ($anc =~ /^(w|e|center)$/);
    $h  = 1  if ($h == 0);
    if ($w/$h >= $aspr) {
        $w = $aspr *$h;
        if ($anc =~ /^(n|s|center)$/) {
            $xp = ($xp > $xo) ? $xo +$w/2. : $xo -$w/2.;
            $dx = ($xp > $xo) ? $w/2. : -1 *$w/2.;
        } else {
            $xp = ($xp > $xo) ? $xo +$w : $xo -$w;
            $dx = ($xp > $xo) ? $w : -1 *$w;
        }
    } else {
        $h = $w /$aspr;
        if ($anc =~ /^(w|e|center)$/) {
            $yp = ($yp > $yo) ? $yo +$h/2. : $yo -$h/2.;
            $dy = ($yp > $yo) ? $h/2. : -1 *$h/2.;
        } else {
            $yp = ($yp > $yo) ? $yo +$h : $yo -$h;
            $dy = ($yp > $yo) ? $h : -1 *$h;
        }
    }
    $hw = $w/2.;
    $hh = $h/2.;

#   Assign un-rotated center point and adjust anchors
    if ($anc =~ /^(n|s)$/) {
        $xc = $xo;
        if ($yp < $yo) {
            $yc  = $yo -$hh;
            $anc = 's';
        } else {
            $yc  = $yo +$hh;
            $anc = 'n';
        }
    } elsif ($anc =~ /^(w|e)$/) {
        $yc = $yo;
        if ($xp < $xo) {
            $xc  = $xo -$hw;
            $anc = 'e';
        } else {
            $xc  = $xo +$hw;
            $anc = 'w';
        }
    } elsif ($anc eq 'center') {
        $xc = $xo;
        $yc = $yo;
    } else {
        $xc = ($xp +$xo)/2.;
        $yc = ($yp +$yo)/2.;
        if ($xp > $xo) {
            $anc = ($yp > $yo) ? 'nw' : 'sw';
        } else {
            $anc = ($yp > $yo) ? 'ne' : 'se';
        }
    }

#   Rotate ($xc, $yc) and ($xp, $yp) into position
    if ($ang != 0) {
        if ($anc ne 'center') {
            if ($xc == $xo) {
                if ($yc == $yo) {
                    $ang2 = 0;
                } else {
                    $ang2 = ($yc > $yo) ? 270 : 90;
                }
            } elsif ($yc == $yo) {
                $ang2 = ($xc > $xo) ? 0 : 180;
            } else {
                $ang2 = (180./pi)*atan2(($yo-$yc),($xc-$xo));
            }
            $h  = sqrt(($xc-$xo)*($xc-$xo)+($yc-$yo)*($yc-$yo));
            $xc = $xo + $h *cos(($ang2 +$ang) *pi/180.);
            $yc = $yo - $h *sin(($ang2 +$ang) *pi/180.);
        }
        if ($xp == $xo) {
            if ($yp == $yo) {
                $ang2 = 0;
            } else {
                $ang2 = ($yp > $yo) ? 270 : 90;
            }
        } elsif ($yp == $yo) {
            $ang2 = ($xp > $xo) ? 0 : 180;
        } else {
            $ang2 = (180./pi)*atan2(($yo-$yp),($xp-$xo));
        }
        $h  = sqrt(($xp-$xo)*($xp-$xo)+($yp-$yo)*($yp-$yo));
        $xp = $xo + $h *cos(($ang2 +$ang) *pi/180.);
        $yp = $yo - $h *sin(($ang2 +$ang) *pi/180.);
    }

#   Make some info accessible for final image resize later
    $props{$id}{iw_tmp}     = 2*$hw;
    $props{$id}{ih_tmp}     = 2*$hh;
    $props{$id}{anchor_tmp} = $anc;

    @coords = &make_shape_coords("rectangle", $xc, $yc, $hw, $hh, $ang);
    $canv->coords($box_id, @coords);
    $status_line = sprintf("X,Y,W,H: %d, %d, %d, %d", $xp-3, $yp-3, 2*$hw, 2*$hh);
}


sub end_resize_image {
    my ($canv, $id) = @_;
    my (
        $anc, $ang, $file, $flip, $ih, $iho, $image, $img, $img_data,
        $iw, $iwo,
        @crop,
       );

#   Get size, anchor, and angle
    $iw   = $props{$id}{iw_tmp};
    $ih   = $props{$id}{ih_tmp};
    $iwo  = $props{$id}{iwo};
    $iho  = $props{$id}{iho};
    $anc  = $props{$id}{anchor_tmp};
    $ang  = $props{$id}{angle_tmp};
    $flip = $props{$id}{flip};
    @crop = @{ $props{$id}{crop} };

    if ($iw == 0 || $ih == 0) {
        &pop_up_error($main, "Image either has no width or height.\nPlease continue or abort.");
        return;
    }

#   Use the original file.  Crop and flip as needed.
    $img  = Imager->new;
    $file = $props{$id}{file};
    $img->read(file => $file) or
            return &pop_up_error($main, "Failed to load $file\n $img->errstr");
    $img = $img->convert(preset => 'addalpha');
    if ($crop[0] > 0. || $crop[1] > 0. || $crop[2] > 0. || $crop[3] > 0.) {
        $img = $img->crop(left   => &round_to_int($iwo *$crop[0]),
                          right  => &round_to_int($iwo *(1.0 -$crop[1])),
                          top    => &round_to_int($iho *$crop[2]),
                          bottom => &round_to_int($iho *(1.0 -$crop[3])));
    }
    if ($flip ne "none") {
        $img->flip(dir => $flip);
    }

#   Scale the image.  Preserve the aspect ratio.
    if ($iw != $props{$id}{iwc} || $ih != $props{$id}{ihc}) {
        $img = $img->scale(xpixels => $iw);
    }

#   Write data to PNG format and save Tk photo image
    $img->write(data => \$img_data, type => 'png');
    $image = Tkx::image_create_photo(-data => $img_data);

#   Update the image, scaled, possibly flipped, but un-rotated
    $props{$id}{image}  = $image;
    $props{$id}{idata}  = $img_data;
    $props{$id}{anchor} = $anc;
    $props{$id}{iw}     = Tkx::image_width($image);
    $props{$id}{ih}     = Tkx::image_height($image);
    $props{$id}{angle}  = $ang;

    &find_rect_from_text_or_image($canv, $id);    # update xc, yc
    $canv->itemconfigure($id, -image => $image,
                              -state => 'hidden');
    $canv->coords($id, $props{$id}{xc}, $props{$id}{yc});
    $props{$id}{coordlist} = [ $props{$id}{xc}, $props{$id}{yc} ];

#   Rotate the re-scaled image
    if ($ang != 0) {
        $img = $img->rotate(degrees => -1 *$ang);
        $img->write(data => \$img_data, type => 'png');
        $image = Tkx::image_create_photo(-data => $img_data);
        $canv->itemconfigure($id, -image => $image);
    }
    $canv->itemconfigure($id, -state => 'normal');

    $canv->delete("crosshair");
    $canv->delete("anchor");
    $canv->delete("working");
    &reset_bindings;
}


sub revert_image {
    my ($canv, $id) = @_;
    my ($file, $iho, $image, $img, $img_data, $iwo);

    &end_select($canv, $id, 1);

    $iwo  = $props{$id}{iwo};
    $iho  = $props{$id}{iho};
    $file = $props{$id}{file};

#   Revert to original image size with no rotation, no crop, and no flip
    $img = Imager->new;
    $img->read(file => $file) or
            return &pop_up_error($main, "Failed to load $file\n $img->errstr");
    $img = $img->convert(preset => 'addalpha');

#   Resize if original image is larger than canvas
    if ($iwo > $canvas_width || $iho > $canvas_height) {
        if ($iwo /$canvas_width >= $iho /$canvas_height) {
            $img = $img->scale(xpixels => &round_to_int($canvas_width *0.8));
        } else {
            $img = $img->scale(ypixels => &round_to_int($canvas_height *0.8));
        }

#   Otherwise, invoke scale function to help fill in alpha channel
    } else {
        $img = $img->scale(xpixels => $iwo);
    }

    $img->write(data => \$img_data, type => 'png');
    $image = Tkx::image_create_photo(-data => $img_data);
    $canv->itemconfigure($id, -image => $image,
                              -state => 'hidden');
    $props{$id}{image} = $image;
    $props{$id}{idata} = $img_data;
    $props{$id}{iw}    = Tkx::image_width($image);
    $props{$id}{ih}    = Tkx::image_height($image);
    $props{$id}{iwc}   = $props{$id}{iwo};
    $props{$id}{ihc}   = $props{$id}{iho};
    $props{$id}{crop}  = [ 0.0, 0.0, 0.0, 0.0 ];
    $props{$id}{angle} = 0;
    $props{$id}{flip}  = "none";

    &find_rect_from_text_or_image($canv, $id);
    $props{$id}{coordlist} = [ $props{$id}{xc}, $props{$id}{yc} ];
    $canv->coords($id, $props{$id}{xc}, $props{$id}{yc});
    $canv->itemconfigure($id, -state => 'normal');
}


sub forget_resize_image {
    my ($canv) = @_;

    $canv->delete("crosshair");
    $canv->delete("anchor");
    $canv->delete("working");
    &reset_bindings;
}


sub flip_image {
    my ($canv, $id, $arg) = @_;
    my (
        $anc, $anchor_moved, $dx, $dy, $flip, $img, $img_data, $image,
        $left_right, $original, $use_anchor, $xc, $yc,
       );

    &end_select($canv, $id, 1);

    if ($props{$id}{angle} != 0) {
        &pop_up_error($main, "Unable to flip a rotated image.");
    }
    $flip     = $props{$id}{flip};
    $anc      = $props{$id}{anchor};
    $img_data = $props{$id}{idata};
    
#   Load the image.  Starting point is cropped, scaled, and un-rotated,
#     but possibly flipped image.
    $img = Imager->new;
    $img->read(data => $img_data);
    $img = $img->convert(preset => 'addalpha');
    $img = $img->scale(xpixels => $props{$id}{iw});

#   Interpret the command argument
    $left_right = ($arg =~ /left_right/) ? 1 : 0;
    $use_anchor = ($arg =~ /anchor/    ) ? 1 : 0;
    $original   = ($arg eq "original"  ) ? 1 : 0;

#   Flip the image
    if ($original) {
        $img->flip(dir => $flip) if ($flip ne "none");
    } else {
        if ($left_right) {
            $img->flip(dir => "h");
        } else {
            $img->flip(dir => "v");
        }
    }

#   Sort out the required changes
    if ($original) {
        $flip = "none";
    } else {
        if ($flip eq "none") {
            $flip = ($left_right) ? "h" : "v";
        } elsif ($flip eq "h") {
            $flip = ($left_right) ? "none" : "vh";
        } elsif ($flip eq "v") {
            $flip = ($left_right) ? "vh" : "none";
        } elsif ($flip eq "vh") {
            $flip = ($left_right) ? "v" : "h";
        }
    }
    $anchor_moved = 0;
    if ($use_anchor && $anc ne 'center') {
        $dx = $dy = 0;
        if ($left_right) {
            if ($anc =~ /e/) {
                $anc =~ s/e/w/;
                $dx = 2 *($props{$id}{x} -$props{$id}{xc});
            } elsif ($anc =~ /w/) {
                $anc =~ s/w/e/;
                $dx = 2 *($props{$id}{x} -$props{$id}{xc});
            }
        } else {
            if ($anc =~ /n/) {
                $anc =~ s/n/s/;
                $dy = 2 *($props{$id}{y} -$props{$id}{yc});
            } elsif ($anc =~ /s/) {
                $anc =~ s/s/n/;
                $dy = 2 *($props{$id}{y} -$props{$id}{yc});
            }
        }
        if ($dx != 0 || $dy != 0) {
            $anchor_moved = 1;
            $xc = $props{$id}{xc} +$dx;
            $yc = $props{$id}{yc} +$dy;
        }
    }

#   Update the image and its properties
    $img->write(data => \$img_data, type => 'png');
    $image = Tkx::image_create_photo(-data => $img_data);
    $canv->itemconfigure($id, -image => $image,
                              -state => 'hidden');
    $props{$id}{flip}  = $flip;
    $props{$id}{image} = $image;
    $props{$id}{idata} = $img_data;
    if ($anchor_moved) {
        $props{$id}{anchor}    = $anc;
        $props{$id}{xc}        = $xc;
        $props{$id}{yc}        = $yc;
        $props{$id}{coordlist} = [ $xc, $yc ];
        $canv->coords($id, $xc, $yc);
    }
    $canv->itemconfigure($id, -state => 'normal');
}


sub begin_crop_image {
    my ($canv, $id) = @_;
    my (
        $anc, $angle, $file, $flip, $i, $id2, $ih, $ihc, $iho, $image,
        $img, $img_data, $iw, $iwc, $iwo, $npts, $xi, $xm, $yi, $ym,
        @coords, @crop, @xvals, @yvals,
       );

    &end_select($canv, $id, 1);

    $angle = $props{$id}{angle};
    $flip  = $props{$id}{flip};
    $file  = $props{$id}{file};
    @crop  = @{ $props{$id}{crop} };

#   Make a copy of the image, uncropped
    $img = Imager->new;
    $img->read(file => $file) or
            return &pop_up_error($main, "Failed to load $file\n $img->errstr");
    $img = $img->convert(preset => 'addalpha');
    $iwo = $img->getwidth();
    $iho = $img->getheight();
    if ($crop[0] > 0. || $crop[1] > 0. || $crop[2] > 0. || $crop[3] > 0.) {
        $img = $img->crop(left   => &round_to_int($iwo *$crop[0]),
                          right  => &round_to_int($iwo *(1.0 -$crop[1])),
                          top    => &round_to_int($iho *$crop[2]),
                          bottom => &round_to_int($iho *(1.0 -$crop[3])));
    }
    $iwc = $img->getwidth();
    $ihc = $img->getheight();
    $img = $img->scale(xpixels => $props{$id}{iw});
    $iw  = $img->getwidth();
    $ih  = $img->getheight();
    if ($flip ne "none") {
        $img->flip(dir => $flip);
    }
    $img->write(data => \$img_data, type => 'png');
    $image = Tkx::image_create_photo(-data => $img_data);
    $id2   = $canv->create_image($props{$id}{xc}, $props{$id}{yc},
                                 -anchor => 'center',
                                 -image  => $image,
                                 -tags   => "image_copy",
                                 -state  => 'hidden');
    $props{$id2}{type}      = "image";
    $props{$id2}{x}         = $props{$id}{x};
    $props{$id2}{y}         = $props{$id}{y};
    $props{$id2}{xc}        = $props{$id}{xc};
    $props{$id2}{yc}        = $props{$id}{yc};
    $props{$id2}{coordlist} = [$props{$id}{xc}, $props{$id}{yc}];
    $props{$id2}{anchor}    = $props{$id}{anchor};
    $props{$id2}{iw}        = $iw;
    $props{$id2}{ih}        = $ih;
    $props{$id2}{iwo}       = $iwo;
    $props{$id2}{iho}       = $iho;
    $props{$id2}{iwc}       = $iwc;
    $props{$id2}{ihc}       = $ihc;
    $props{$id2}{crop}      = [ @crop ];
    $props{$id2}{crop_tmp}  = [ @crop ];
    $props{$id2}{file}      = $file;
    $props{$id2}{image}     = $image;
    $props{$id2}{idata}     = $img_data;
    $props{$id2}{flip}      = $flip;
    $props{$id2}{angle}     = $angle;
    if ($angle != 0) {
        $img = $img->rotate(degrees => -1 *$angle);
        $img->write(data => \$img_data, type => 'png');
        $image = Tkx::image_create_photo(-data => $img_data);
        $canv->itemconfigure($id2, -image => $image);
    }
    $canv->itemconfigure($id2, -state => 'normal');

#   Uncrop the image copy, if needed
    if ($crop[0] != 0. || $crop[1] != 0. || $crop[2] != 0. || $crop[3] != 0.) {
        &uncrop_image($canv, $id2);
    }

#   Hide the original image, for now
    $canv->itemconfigure($id, -state => 'hidden');

#   Draw boundary and add markers
    @xvals  = @yvals = ();
    @coords = &find_rect_from_text_or_image($canv, $id);
    $npts   = ($#coords +1) /2;
    for ($i=0; $i<$npts; $i++) {
        push(@xvals, $coords[2*$i]);
        push(@yvals, $coords[2*$i+1]);
    }
    $canv->create_polygon(@coords,
                    -outline => &get_rgb_code($anchor_select_color), 
                    -width   => 1, 
                    -fill    => "",
                    -tags    => "anchor_box");
    for ($i=0; $i<$npts; $i++) {
        $xi  = $xvals[$i];
        $yi  = $yvals[$i];
        $anc = $canv->create_rectangle($xi-2, $yi-2, $xi+2, $yi+2,
                         -outline => &get_rgb_code($anchor_line_color),
                         -width   => 1,
                         -fill    => &get_rgb_code($anchor_select_color),
                         -tags    => "anchor");
        $anc_props{$anc}{x}    = $xi;
        $anc_props{$anc}{y}    = $yi;
        $anc_props{$anc}{type} = $text_anchors[2*$i];
        if ($i < $npts-1) {
            $xm = ($xi +$xvals[$i+1])/2.;
            $ym = ($yi +$yvals[$i+1])/2.;
        } else {
            $xm = ($xi +$xvals[0])/2.;
            $ym = ($yi +$yvals[0])/2.;
        }
        $anc = $canv->create_rectangle($xm-2, $ym-2, $xm+2, $ym+2,
                         -outline => &get_rgb_code($anchor_line_color),
                         -width   => 1,
                         -fill    => &get_rgb_code($anchor_select_color),
                         -tags    => "anchor");
        $anc_props{$anc}{x}    = $xm;
        $anc_props{$anc}{y}    = $ym;
        $anc_props{$anc}{type} = $text_anchors[2*$i+1];
    }

#   Set bindings
    $canv->g_bind("<Motion>",          [ \&highlight_crop_pt, $canv, $id, $id2 ]);
    $canv->g_bind("<Double-Button-1>", [ \&crop_image,        $canv, $id, $id2 ]);
    $canv->g_bind("<Button-3>",        [ \&forget_crop_image, $canv, $id, $id2 ]);

    $status_line = "Adjust crop boundaries by dragging anchors...";
}


sub highlight_crop_pt {
    my ($canv, $id, $id2) = @_;
    my ($anchor_found, $atype, $item, $xo, $yo,
        @tags,
       );

    $anchor_found = 0;

    ($item) = $canv->find_withtag("current");
    if (defined($item) && $item ne "") {
        @tags = Tkx::SplitList($canv->itemcget($item, -tags));
        if (&list_match("anchor", @tags) > -1) {
            $xo = $anc_props{$item}{x};
            $yo = $anc_props{$item}{y};
            $canv->coords($item, $xo-4, $yo-4, $xo+4, $yo+4);
            if (defined($old_item) && $old_item ne $item) {
                $xo = $anc_props{$old_item}{x};
                $yo = $anc_props{$old_item}{y};
                $canv->coords($old_item, $xo-2, $yo-2, $xo+2, $yo+2);
            }
            $anchor_found = 1;
            $old_item = $item;
        }
    }
    if (! $anchor_found && defined($old_item) && $old_item ne "") {
        $xo = $anc_props{$old_item}{x};
        $yo = $anc_props{$old_item}{y};
        $canv->coords($old_item, $xo-2, $yo-2, $xo+2, $yo+2);
        undef $old_item;
    }
    if ($anchor_found) {
        $atype = $anc_props{$item}{type};
        $canv->g_bind("<Button1-Motion>", [ \&adjust_crop, Tkx::Ev("%x","%y"), $canv, $id, $id2, $atype ]);
    } else {
        $canv->g_bind("<Button1-Motion>", "");
    }
    $status_line = "Left-click & drag to move a crop anchor. Double-click to crop. Right-click to abort...";
}


sub adjust_crop {
    my ($x, $y, $canv, $id, $id2, $atype) = @_;
    my (
        $anc, $anc_type, $ang, $ang2, $crop_b, $crop_l, $crop_r, $crop_t, $d,
        $dx, $dy, $flip, $hh, $hw, $i, $ih, $iw, $snap, $xc, $xp, $yc, $yp,
        @anchors, @coords, @crop, @new_coords, @xvals, @yvals,
       );

#   Set some parameters
    $xc      = $props{$id2}{xc};
    $yc      = $props{$id2}{yc};
    $iw      = $props{$id2}{iw};     # uncropped width
    $ih      = $props{$id2}{ih};     # uncropped height
    $ang     = $props{$id2}{angle};
    $flip    = $props{$id2}{flip};
    @crop    = @{ $props{$id2}{crop_tmp} };
    @coords  = Tkx::SplitList($canv->coords("anchor_box"));
    $snap    = ($ang % 90 == 0) ? 1 : 0;
    ($x, $y) = &get_xy($canv, $x, $y, $snap);

#   Compute current crop distances in pixels
    $crop_l = ($flip =~ /h/) ? $iw *$crop[1] : $iw *$crop[0];
    $crop_r = ($flip =~ /h/) ? $iw *$crop[0] : $iw *$crop[1];
    $crop_t = ($flip =~ /v/) ? $ih *$crop[3] : $ih *$crop[2];
    $crop_b = ($flip =~ /v/) ? $ih *$crop[2] : $ih *$crop[3];

#   Un-rotate anchor box so calcs can be done in regular space
    if ($ang != 0) {
        @new_coords = ();
        for ($i=0; $i<4; $i++) {
            $xp = $coords[2*$i];
            $yp = $coords[2*$i+1];
            if ($xp == $xc && $yp == $yc) {
                push (@new_coords, $xp, $yp);
                next;
            }
            $d = sqrt(($xp-$xc)*($xp-$xc) + ($yp-$yc)*($yp-$yc));
            if ($xp == $xc) {
                $ang2 = ($yp > $yc) ? 270 : 90;
            } elsif ($yp == $yc) {
                $ang2 = ($xp > $xc) ? 0 : 180;
            } else {
                $ang2 = (180./pi)*atan2(($yc-$yp),($xp-$xc));
            }
            $ang2 += 360 if ($ang2 < 0);
            $xp = $xc +$d *cos(($ang2 -$ang) *pi/180.);
            $yp = $yc -$d *sin(($ang2 -$ang) *pi/180.);
            push (@new_coords, $xp, $yp);
        }
        @coords = @new_coords;

#       Also, un-rotate the x,y mouse position
        if ($x != $xc || $y != $yc) {
            $d = sqrt(($x-$xc)*($x-$xc) + ($y-$yc)*($y-$yc));
            if ($x == $xc) {
                $ang2 = ($y > $yc) ? 270 : 90;
            } elsif ($y == $yc) {
                $ang2 = ($x > $xc) ? 0 : 180;
            } else {
                $ang2 = (180./pi)*atan2(($yc-$y),($x-$xc));
            }
            $ang2 += 360 if ($ang2 < 0);
            $x = $xc +$d *cos(($ang2 -$ang) *pi/180.);
            $y = $yc -$d *sin(($ang2 -$ang) *pi/180.);
        }
    }
    @xvals = @yvals = ();
    for ($i=0; $i<4; $i++) {
        push (@xvals, $coords[2*$i]  );
        push (@yvals, $coords[2*$i+1]);
    }

#   Determine boundary movement
    if ($atype =~ /^(ne|e|se)$/) {
        $dx = $x - &max(@xvals);
        $dx = $crop_r if ($dx > $crop_r);
        $dx = &max($dx, -1 *($iw -$crop_r -$crop_l -1));
        $crop_r -= $dx;
    } elsif ($atype =~ /^(nw|w|sw)$/) {
        $dx = $x - &min(@xvals);
        $dx = -1 *$crop_l if ($dx < -1 *$crop_l);
        $dx = &min($dx, $iw -$crop_r -$crop_l -1);
        $crop_l += $dx;
    }
    if ($atype =~ /^(nw|n|ne)$/) {
        $dy = $y - &min(@yvals);
        $dy = -1 *$crop_t if ($dy < -1 *$crop_t);
        $dy = &min($dy, $ih -$crop_t -$crop_b -1);
        $crop_t += $dy;
    } elsif ($atype =~ /^(sw|s|se)$/) {
        $dy = $y - &max(@yvals);
        $dy = $crop_b if ($dy > $crop_b);
        $dy = &max($dy, -1 *($ih -$crop_t -$crop_b -1));
        $crop_b -= $dy;
    }

#   Save the temporary crop values
    $crop[0] = ($flip =~ /h/) ? $crop_r /$iw : $crop_l /$iw;
    $crop[1] = ($flip =~ /h/) ? $crop_l /$iw : $crop_r /$iw;
    $crop[2] = ($flip =~ /v/) ? $crop_b /$ih : $crop_t /$ih;
    $crop[3] = ($flip =~ /v/) ? $crop_t /$ih : $crop_b /$ih;
    $props{$id2}{crop_tmp} = [ @crop ];

#   Recompute the coordinates of the box
    $hw = ($iw-1)/2.;
    $hh = ($ih-1)/2.;
    @coords = ($xc-$hw+$crop_l, $yc-$hh+$crop_t, $xc+$hw-$crop_r, $yc-$hh+$crop_t,
               $xc+$hw-$crop_r, $yc+$hh-$crop_b, $xc-$hw+$crop_l, $yc+$hh-$crop_b);

#   Re-rotate the coordinates
    if ($ang != 0) {
        @new_coords = ();
        for ($i=0; $i<4; $i++) {
            $xp = $coords[2*$i];
            $yp = $coords[2*$i+1];
            if ($xp == $xc && $yp == $yc) {
                push (@new_coords, $xp, $yp);
                next;
            }
            $d = sqrt(($xp-$xc)*($xp-$xc) + ($yp-$yc)*($yp-$yc));
            if ($xp == $xc) {
                $ang2 = ($yp > $yc) ? 270 : 90;
            } elsif ($yp == $yc) {
                $ang2 = ($xp > $xc) ? 0 : 180;
            } else {
                $ang2 = (180./pi)*atan2(($yc-$yp),($xp-$xc));
            }
            $ang2 += 360 if ($ang2 < 0);
            $xp = $xc +$d *cos(($ang2 +$ang) *pi/180.);
            $yp = $yc -$d *sin(($ang2 +$ang) *pi/180.);
            push (@new_coords, $xp, $yp);
        }
        @coords = @new_coords;
    }

#   Display a modified box and move any modified anchors
    $canv->coords("anchor_box", @coords);
    @anchors = Tkx::SplitList($canv->find_withtag("anchor"));
    foreach $anc (@anchors) {
        $anc_type = $anc_props{$anc}{type};
        if ($anc_type eq "nw") {
            $xp = $coords[0];
            $yp = $coords[1];
        } elsif ($anc_type eq "n") {
            $xp = ($coords[0] +$coords[2])/2.;
            $yp = ($coords[1] +$coords[3])/2.;
        } elsif ($anc_type eq "ne") {
            $xp = $coords[2];
            $yp = $coords[3];
        } elsif ($anc_type eq "e") {
            $xp = ($coords[2] +$coords[4])/2.;
            $yp = ($coords[3] +$coords[5])/2.;
        } elsif ($anc_type eq "se") {
            $xp = $coords[4];
            $yp = $coords[5];
        } elsif ($anc_type eq "s") {
            $xp = ($coords[4] +$coords[6])/2.;
            $yp = ($coords[5] +$coords[7])/2.;
        } elsif ($anc_type eq "sw") {
            $xp = $coords[6];
            $yp = $coords[7];
        } elsif ($anc_type eq "w") {
            $xp = ($coords[0] +$coords[6])/2.;
            $yp = ($coords[1] +$coords[7])/2.;
        }
        if ($anc_type eq $atype) {
            $canv->coords($anc, $xp-4, $yp-4, $xp+4, $yp+4);
        } else {
            $canv->coords($anc, $xp-2, $yp-2, $xp+2, $yp+2);
        }
        $anc_props{$anc}{x} = $xp;
        $anc_props{$anc}{y} = $yp;
    }
    $status_line = "W,H: " . sprintf("%d", &round_to_int($iw -$crop_l -$crop_r))
                    . ", " . sprintf("%d", &round_to_int($ih -$crop_t -$crop_b));
}


sub crop_image {
    my ($canv, $id, $id2) = @_;
    my (
        $anc, $crop_b, $crop_l, $crop_r, $crop_t, $flip, $i, $ih, $iw,
        $img, $img_data, $image, $xc, $xo, $yc, $yo,
        @anchors, @coords, @crop, @xvals, @yvals,
       );

#   Set some variables
    $flip     = $props{$id2}{flip};
    $iw       = $props{$id2}{iw};     # uncropped width
    $ih       = $props{$id2}{ih};     # uncropped height
    $img_data = $props{$id2}{idata};
    @crop     = @{ $props{$id2}{crop_tmp} };

#   Start with data from uncropped id2, which is already sized and flipped
    $img = Imager->new;
    $img->read(data => $img_data);
    $img = $img->convert(preset => 'addalpha');

#   Compute current crop distances in pixels and recrop image
    $crop_l = ($flip =~ /h/) ? $iw *$crop[1] : $iw *$crop[0];
    $crop_r = ($flip =~ /h/) ? $iw *$crop[0] : $iw *$crop[1];
    $crop_t = ($flip =~ /v/) ? $ih *$crop[3] : $ih *$crop[2];
    $crop_b = ($flip =~ /v/) ? $ih *$crop[2] : $ih *$crop[3];
    if ($crop_l > 0. || $crop_r > 0. || $crop_t > 0. || $crop_b > 0.) {
        $img = $img->crop(left   => &round_to_int($crop_l),
                          right  => &round_to_int($iw -$crop_r),
                          top    => &round_to_int($crop_t),
                          bottom => &round_to_int($ih -$crop_b));
    }
    $img->write(data => \$img_data, type => 'png');
    $image = Tkx::image_create_photo(-data => $img_data);

#   Updated boundaries and anchor position are in image_box and anchors
    @coords = Tkx::SplitList($canv->coords("anchor_box"));
    @xvals  = @yvals = ();
    for ($i=0; $i<4; $i++) {
        push (@xvals, $coords[2*$i]  );
        push (@yvals, $coords[2*$i+1]);
    }
    $xc = (&min(@xvals) + &max(@xvals)) /2.;
    $yc = (&min(@yvals) + &max(@yvals)) /2.;
    if ($props{$id}{anchor} eq 'center') {
        $xo = $xc;
        $yo = $yc;
    } else {
        @anchors = Tkx::SplitList($canv->find_withtag("anchor"));
        foreach $anc (@anchors) {
            if ($anc_props{$anc}{type} eq $props{$id}{anchor}) {
                $xo = $anc_props{$anc}{x};
                $yo = $anc_props{$anc}{y};
                last;
            }
        }
    }
    
#   Update image properties
    $props{$id}{x}         = $xo;
    $props{$id}{y}         = $yo;
    $props{$id}{xc}        = $xc;
    $props{$id}{yc}        = $yc;
    $props{$id}{coordlist} = [ $xc, $yc ];
    $props{$id}{iw}        = $img->getwidth();
    $props{$id}{ih}        = $img->getheight();
    $props{$id}{iwc}       = &round_to_int($props{$id}{iwo} * (1.0 -$crop[0] -$crop[1]));
    $props{$id}{ihc}       = &round_to_int($props{$id}{iho} * (1.0 -$crop[2] -$crop[3]));
    $props{$id}{crop}      = [ @crop ];
    $props{$id}{image}     = $image;
    $props{$id}{idata}     = $img_data;

#   Rotate image if needed and redraw
    if ($props{$id}{angle} != 0) {
        $img = $img->rotate(degrees => -1 *$props{$id}{angle});
        $img->write(data => \$img_data, type => 'png');
        $image = Tkx::image_create_photo(-data => $img_data);
    }
    $canv->itemconfigure($id, -image => $image,
                              -state => 'hidden');
    $canv->coords($id, $xc, $yc);
    $canv->itemconfigure($id, -state => 'normal');

#   Clean up
    $canv->delete("image_copy");
    $canv->delete("anchor_box");
    $canv->delete("anchor");
    delete $props{$id2};
    undef %anc_props;
    undef $old_item if (defined($old_item));
    undef $old_id   if (defined($old_id));
    &reset_bindings;
}


sub uncrop_image {
    my ($canv, $id) = @_;
    my (
        $anc, $ang, $ang2, $crop_b, $crop_l, $crop_r, $crop_t, $file, $flip,
        $h, $ih, $image, $img, $img_data, $iw, $xc, $xo, $xp, $yc, $yo, $yp,
        @crop,
       );

    &end_select($canv, $id, 1);

    $xo   = $props{$id}{x};
    $yo   = $props{$id}{y};
    $xc   = $props{$id}{xc};
    $yc   = $props{$id}{yc};
    $anc  = $props{$id}{anchor};
    $ang  = $props{$id}{angle};
    $flip = $props{$id}{flip};
    $file = $props{$id}{file};
    @crop = @{ $props{$id}{crop} };

#   Start with original file.  Load it, flip it, re-scale it.
    $img = Imager->new;
    $img->read(file => $file) or
            return &pop_up_error($main, "Failed to load $file\n $img->errstr");
    $img = $img->convert(preset => 'addalpha');
    if ($flip ne "none") {
        $img->flip(dir => $flip);
    }
    $img = $img->scaleX(pixels => &round_to_int($props{$id}{iw} *$props{$id}{iwo} /$props{$id}{iwc}));
    $img = $img->scaleY(pixels => &round_to_int($props{$id}{ih} *$props{$id}{iho} /$props{$id}{ihc}));
    $iw  = $img->getwidth();
    $ih  = $img->getheight();

#   Un-rotate the anchor around the cropped center point
    $xp = $xc;  # pivot point is (xp,yp)
    $yp = $yc;
    if ($ang != 0) {
        if ($xo == $xp) {
            if ($yo == $yp) {
                $ang2 = 0;
            } else {
                $ang2 = ($yo > $yp) ? 270 : 90;
            }
        } elsif ($yo == $yp) {
            $ang2 = ($xo > $xp) ? 0 : 180;
        } else {
            $ang2 = (180./pi)*atan2(($yp-$yo),($xo-$xp));
        }
        $h  = sqrt(($xo-$xp)*($xo-$xp)+($yo-$yp)*($yo-$yp));
        $xo = $xp +$h *cos(($ang2 -$ang) *pi/180.);
        $yo = $yp -$h *sin(($ang2 -$ang) *pi/180.);
    }

#   Adjust the center point and anchor location in un-rotated space
    $crop_l = ($flip =~ /h/) ? $iw *$crop[1] : $iw *$crop[0];
    $crop_r = ($flip =~ /h/) ? $iw *$crop[0] : $iw *$crop[1];
    $crop_t = ($flip =~ /v/) ? $ih *$crop[3] : $ih *$crop[2];
    $crop_b = ($flip =~ /v/) ? $ih *$crop[2] : $ih *$crop[3];
    $xc += ($crop_r -$crop_l)/2.;
    $yc += ($crop_b -$crop_t)/2.;
    if ($anc =~ /^(nw|w|sw)$/) {
        $xo -= $crop_l;
    } elsif ($anc =~ /^(ne|e|se)$/) {
        $xo += $crop_r;
    } elsif ($anc =~ /^(n|s|center)$/) {
        $xo += ($crop_r -$crop_l)/2.;
    }
    if ($anc =~ /^(nw|n|ne)$/) {
        $yo -= $crop_t;
    } elsif ($anc =~ /^(sw|s|se)$/) {
        $yo += $crop_b;
    } elsif ($anc =~ /^(w|e|center)$/) {
        $yo += ($crop_b -$crop_t)/2.;
    }

#   Re-rotate anchor and center around the cropped center point (xp,yp)
    if ($ang != 0) {
        if ($xo == $xp) {
            if ($yo == $yp) {
                $ang2 = 0;
            } else {
                $ang2 = ($yo > $yp) ? 270 : 90;
            }
        } elsif ($yo == $yp) {
            $ang2 = ($xo > $xp) ? 0 : 180;
        } else {
            $ang2 = (180./pi)*atan2(($yp-$yo),($xo-$xp));
        }
        $h  = sqrt(($xo-$xp)*($xo-$xp)+($yo-$yp)*($yo-$yp));
        $xo = $xp +$h *cos(($ang2 +$ang) *pi/180.);
        $yo = $yp -$h *sin(($ang2 +$ang) *pi/180.);
        if ($xc == $xp) {
            if ($yc == $yp) {
                $ang2 = 0;
            } else {
                $ang2 = ($yc > $yp) ? 270 : 90;
            }
        } elsif ($yc == $yp) {
            $ang2 = ($xc > $xp) ? 0 : 180;
        } else {
            $ang2 = (180./pi)*atan2(($yp-$yc),($xc-$xp));
        }
        $h  = sqrt(($xc-$xp)*($xc-$xp)+($yc-$yp)*($yc-$yp));
        $xc = $xp +$h *cos(($ang2 +$ang) *pi/180.);
        $yc = $yp -$h *sin(($ang2 +$ang) *pi/180.);
    }

#   Update the image and its properties
    $img->write(data => \$img_data, type => 'png');
    $image = Tkx::image_create_photo(-data => $img_data);

    $props{$id}{image}     = $image;
    $props{$id}{idata}     = $img_data;
    $props{$id}{x}         = $xo;
    $props{$id}{y}         = $yo;
    $props{$id}{xc}        = $xc;
    $props{$id}{yc}        = $yc;
    $props{$id}{iw}        = $iw;
    $props{$id}{ih}        = $ih;
    $props{$id}{iwc}       = $props{$id}{iwo};
    $props{$id}{ihc}       = $props{$id}{iho};
    $props{$id}{crop}      = [ 0.0, 0.0, 0.0, 0.0 ];
    $props{$id}{coordlist} = [ $xc, $yc ];

    $canv->itemconfigure($id, -image => $image,
                              -state => 'hidden');
    $canv->coords($id, $xc, $yc);

#   Rotate the re-scaled image
    if ($ang != 0) {
        $img = $img->rotate(degrees => -1 *$ang);
        $img->write(data => \$img_data, type => 'png');
        $image = Tkx::image_create_photo(-data => $img_data);
        $canv->itemconfigure($id, -image => $image);
    }
    $canv->itemconfigure($id, -state => 'normal');
}


sub forget_crop_image {
    my ($canv, $id, $id2) = @_;

    $canv->delete("image_copy");
    $canv->delete("anchor_box");
    $canv->delete("anchor");
    $canv->itemconfigure($id, -state => 'normal');
    delete $props{$id2};
    undef %anc_props;
    undef $old_item if (defined($old_item));
    undef $old_id   if (defined($old_id));
    &reset_bindings;
}


sub begin_rotate_image {
    my ($x, $y, $canv, $id) = @_;
    my ($xo, $yo, $ang);

    $x  = $canv->canvasx($x);
    $y  = $canv->canvasy($y);
    $xo = $props{$id}{x};
    $yo = $props{$id}{y};
    if ($x == $xo) {
        if ($y == $yo) {
            $ang = 0;
        } else {
            $ang = ($y > $yo) ? 270 : 90;
        }
    } elsif ($y == $yo) {
        $ang = ($x > $xo) ? 0 : 180;
    } else {
        $ang = &round_to_int((180./pi)*atan2(($yo-$y),($x-$xo)));
    }
    $ang += 360 if ($ang < 0);

    &rotate_image($canv, $id, $ang, 1);
}


sub rotate_image {
    my ($canv, $id, $ang, $free_rotate) = @_;
    my (
        $anc, $ang2, $d, $hh, $hw, $i, $ih, $img, $img_data, $image, $iw,
        $rot_img, $x, $xc, $xo, $y, $yc, $yo,
        @coords, @new_coords, @xvals, @yvals,
       );

    &end_select($canv, $id, 1);
    $free_rotate = 0 if (! defined($free_rotate) || $free_rotate != 1);
    if ($free_rotate) {
        $status_line = sprintf("Rotation: %d", $ang);
    }
    $xo       = $props{$id}{x};
    $yo       = $props{$id}{y};
    $anc      = $props{$id}{anchor};
    $iw       = $props{$id}{iw};
    $ih       = $props{$id}{ih};
    $image    = $props{$id}{image};
    $img_data = $props{$id}{idata};
    $ang     += $props{$id}{angle} if (! $free_rotate);
    $ang      = ($ang + 360) % 360;  # $ang is always an integer

#   Set the encompassing rectangle for the un-rotated image
#   Find corners based on anchor (n, ne, e, se, s, sw, w, nw, center)
    $hw = ($iw-1)/2.;
    $hh = ($ih-1)/2.;
    if ($anc eq 'nw') {
        @coords = ($xo, $yo, $xo+2*$hw, $yo, $xo+2*$hw, $yo+2*$hh, $xo, $yo+2*$hh);
        $xc = $xo + $hw;
        $yc = $yo + $hh;
    } elsif ($anc eq 'n') {
        @coords = ($xo-$hw, $yo, $xo+$hw, $yo, $xo+$hw, $yo+2*$hh, $xo-$hw, $yo+2*$hh);
        $xc = $xo;
        $yc = $yo + $hh;
    } elsif ($anc eq 'ne') {
        @coords = ($xo-2*$hw, $yo, $xo, $yo, $xo, $yo+2*$hh, $xo-2*$hw, $yo+2*$hh);
        $xc = $xo - $hw;
        $yc = $yo + $hh;
    } elsif ($anc eq 'e') {
        @coords = ($xo-2*$hw, $yo-$hh, $xo, $yo-$hh, $xo, $yo+$hh, $xo-2*$hw, $yo+$hh);
        $xc = $xo - $hw;
        $yc = $yo;
    } elsif ($anc eq 'se') {
        @coords = ($xo-2*$hw, $yo-2*$hh, $xo, $yo-2*$hh, $xo, $yo, $xo-2*$hw, $yo);
        $xc = $xo - $hw;
        $yc = $yo - $hh;
    } elsif ($anc eq 's') {
        @coords = ($xo-$hw, $yo-2*$hh, $xo+$hw, $yo-2*$hh, $xo+$hw, $yo, $xo-$hw, $yo);
        $xc = $xo;
        $yc = $yo - $hh;
    } elsif ($anc eq 'sw') {
        @coords = ($xo, $yo-2*$hh, $xo+2*$hw, $yo-2*$hh, $xo+2*$hw, $yo, $xo, $yo);
        $xc = $xo + $hw;
        $yc = $yo - $hh;
    } elsif ($anc eq 'w') {
        @coords = ($xo, $yo-$hh, $xo+2*$hw, $yo-$hh, $xo+2*$hw, $yo+$hh, $xo, $yo+$hh);
        $xc = $xo + $hw;
        $yc = $yo;
    } else {
        @coords = ($xo-$hw, $yo-$hh, $xo+$hw, $yo-$hh, $xo+$hw, $yo+$hh, $xo-$hw, $yo+$hh);
        $xc = $xo;
        $yc = $yo;
    }

#   Just show the original image if the angle is zero.
    if ($ang == 0) {
        $canv->itemconfigure($id, -state => 'hidden');
        $canv->coords($id, $xc, $yc);
        $canv->itemconfigure($id, -image => $image,
                                  -state => 'normal');
        return if ($free_rotate);
        $props{$id}{xc}        = $xc;
        $props{$id}{yc}        = $yc;
        $props{$id}{coordlist} = [$xc, $yc];
        $props{$id}{angle}     = $ang;
        return;
    }

#   Find the center point of the rotated bounding rectangle
    if ($ang != 0 && $anc ne 'center') {
        @new_coords = ();
        for ($i=0; $i<4; $i++) {
            $x = $coords[2*$i];
            $y = $coords[2*$i+1];
            if ($x == $xo && $y == $yo) {
                push (@new_coords, $x, $y);
                next;
            }
            $d = sqrt(($x-$xo)*($x-$xo) + ($y-$yo)*($y-$yo));
            if ($x == $xo) {
                $ang2 = ($y > $yo) ? 270 : 90;
            } elsif ($y == $yo) {
                $ang2 = ($x > $xo) ? 0 : 180;
            } else {
                $ang2 = (180./pi)*atan2(($yo-$y),($x-$xo));
            }
            $ang2 += 360 if ($ang2 < 0);
            $x = $xo +$d *cos(($ang2 +$ang) *pi/180.);
            $y = $yo -$d *sin(($ang2 +$ang) *pi/180.);
            push (@new_coords, $x, $y);
        }
        @coords = @new_coords;
        @xvals  = @yvals = ();
        for ($i=0; $i<4; $i++) {
            push (@xvals, $coords[2*$i]  );
            push (@yvals, $coords[2*$i+1]);
        }
        $xc = (&min(@xvals) + &max(@xvals))/2.;
        $yc = (&min(@yvals) + &max(@yvals))/2.;
    }

#   Prepare for a delay due to image processing
    $canv->configure(-cursor => $cursor_wait);
    Tkx::update_idletasks();

#   Rotate the image.  Use the scale function to ensure alpha data for transparency.
    $img = Imager->new;
    $img->read(data => $img_data);
    $img = $img->convert(preset => 'addalpha');
    $img = $img->scale(xpixels => $props{$id}{iw});
    $rot_img = $img->rotate(degrees => -1 *$ang);
    $rot_img->write(data => \$img_data, type => 'png');
    $image = Tkx::image_create_photo(-data => $img_data);

#   Update the item
    $canv->itemconfigure($id, -state => 'hidden');
    $canv->coords($id, $xc, $yc);
    $canv->itemconfigure($id, -image => $image,
                              -state => 'normal');
    if ($free_rotate) {
        $canv->configure(-cursor => $cursor_hand);
        return;
    }
    $props{$id}{xc}        = $xc;
    $props{$id}{yc}        = $yc;
    $props{$id}{coordlist} = [$xc, $yc];
    $props{$id}{angle}     = $ang;
    $canv->configure(-cursor => $cursor_norm);
    return;
}


sub end_rotate_image {
    my ($x, $y, $canv, $id) = @_;
    my ($xo, $yo, $ang);

    $x  = $canv->canvasx($x);
    $y  = $canv->canvasy($y);
    $xo = $props{$id}{x};
    $yo = $props{$id}{y};
    if ($x == $xo) {
        if ($y == $yo) {
            $ang = 0;
        } else {
            $ang = ($y > $yo) ? 270 : 90;
        }
    } elsif ($y == $yo) {
        $ang = ($x > $xo) ? 0 : 180;
    } else {
        $ang = &round_to_int((180./pi)*atan2(($yo-$y),($x-$xo)));
    }
    $ang += 360 if ($ang < 0);
    $ang -= $props{$id}{angle};

    &rotate_image($canv, $id, $ang, 0);

    $canv->delete("anchor");
    &reset_bindings;
}


sub forget_rotate_image {
    my ($canv, $id) = @_;

    &rotate_image($canv, $id, 0, 0);

    $canv->delete("anchor");
    &reset_bindings;
}


################################################################################
#
# Object selection
#
################################################################################

sub object_select {
    my ($x, $y, $canv, $action) = @_;
    my (
        $box_id, $code, $fg, $geom, $grp, $i, $id, $item_selected, $tol,
        $type, $x1, $x2, $xloc, $xmax, $xmin, $xp, $y1, $y2, $yloc, $ymax,
        $ymin, $yp,

        @coords, @ids, @tags,
       );

    ($x, $y) = &get_xy($canv, $x, $y, 0);
    $status_line = sprintf("X,Y: %d, %d", $x-3, $y-3);

    $tol = 4;
    $item_selected = 0;

#   The find method will find a polygon for every point inside that polygon
#   regardless of whether the polygon is filled, so some extra searching is
#   required when polygons are used.  Rectangles, diamonds, polygons, and
#   ellipses are polygons in this program.

    @ids = Tkx::SplitList($canv->find_overlapping($x-$tol, $y-$tol, $x+$tol, $y+$tol));
    for ($i=$#ids; $i>=0; $i--) {
        @tags = Tkx::SplitList($canv->itemcget($ids[$i], -tags));
        next if (&list_match("working",    @tags) > -1);
        next if (&list_match("select_box", @tags) > -1);
        next if (&list_match("select_pts", @tags) > -1);
        next if (&list_match("zoom_bar",   @tags) > -1);
        if (&list_search("^graph", @tags) > -1) {
            $id   = $tags[&list_search("^graph", @tags)];
            $id   =~ s/^graph//;
            $id   =~ s/_.*$//;
            $type = $props{$id}{type};
            $item_selected = 1;
            last;
        } else {
            $item_selected = &select_item($canv, $ids[$i], $x, $y, $tol);
            if ($item_selected) {
                $id   = $ids[$i];
                $type = $props{$id}{type};
                last;
            }
        }
    }

    if ($item_selected) {
        if ($type eq "graph") {
            $grp = &get_group_type($id, @tags);
            $status_line .= "  " . $grp;
            if (! defined($gr_props{$id})) {
                if ($props{$id}{meta} eq "vert_wd_zone") {
                    $status_line .= " (incomplete)";
                }
                return;
            }
            ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
            if ($x >= $x1 && $x <= $x2 && $y >= $y1 && $y <= $y2) {
                if ($props{$id}{meta} eq "w2_tdmap") {
                    if ($gr_props{$id}{date_axis} eq "Y") {
                        $xmin = $gr_props{$id}{dmin};
                        $xmax = $gr_props{$id}{dmax};
                        if ($gr_props{$id}{dflip}) {
                            $xloc = $xmin +($xmax -$xmin) *(1.0 -($x -$x1) /($x2 -$x1));
                        } else {
                            $xloc = $xmin +($xmax -$xmin) *($x -$x1) /($x2 -$x1);
                        }
                        if ($gr_props{$id}{ttype} eq "Date/Time") {
                            $ymin = &datelabel2jdate($gr_props{$id}{tmin});
                            $ymax = &datelabel2jdate($gr_props{$id}{tmax});
                        } else {
                            $ymin = $gr_props{$id}{tmin};
                            $ymax = $gr_props{$id}{tmax};
                        }
                        if ($gr_props{$id}{tflip}) {
                            $yloc = $ymin +($ymax -$ymin) *(1.0 -($y -$y1) /($y2 -$y1));
                        } else {
                            $yloc = $ymin +($ymax -$ymin) *($y -$y1) /($y2 -$y1);
                        }
                        if ($gr_props{$id}{ttype} eq "Date/Time") {
                            $yloc = &jdate2datelabel($yloc, "Mon-DD-YYYY");
                            $status_line .= sprintf("  [%.2f, %s]", $xloc, $yloc);
                        } else {
                            $status_line .= sprintf("  [%.2f, %.2f]", $xloc, $yloc);
                        }
                    } else {
                        $ymin = $gr_props{$id}{dmin};
                        $ymax = $gr_props{$id}{dmax};
                        if ($gr_props{$id}{dflip}) {
                            $yloc = $ymin +($ymax -$ymin) *($y -$y1) /($y2 -$y1);
                        } else {
                            $yloc = $ymin +($ymax -$ymin) *(1.0 -($y -$y1) /($y2 -$y1));
                        }
                        if ($gr_props{$id}{ttype} eq "Date/Time") {
                            $xmin = &datelabel2jdate($gr_props{$id}{tmin});
                            $xmax = &datelabel2jdate($gr_props{$id}{tmax});
                        } else {
                            $xmin = $gr_props{$id}{tmin};
                            $xmax = $gr_props{$id}{tmax};
                        }
                        if ($gr_props{$id}{tflip}) {
                            $xloc = $xmin +($xmax -$xmin) *(1.0 -($x -$x1) /($x2 -$x1));
                        } else {
                            $xloc = $xmin +($xmax -$xmin) *($x -$x1) /($x2 -$x1);
                        }
                        if ($gr_props{$id}{ttype} eq "Date/Time") {
                            $xloc = &jdate2datelabel($xloc, "Mon-DD-YYYY");
                            $status_line .= sprintf("  [%s, %.2f]", $xloc, $yloc);
                        } else {
                            $status_line .= sprintf("  [%.2f, %.2f]", $xloc, $yloc);
                        }
                    }
                } else {
                    $ymin = $gr_props{$id}{ymin};
                    $ymax = $gr_props{$id}{ymax};
                    if ($props{$id}{meta} =~ /(data_profile|w2_profile|w2_slice|w2_outflow|vert_wd_zone)/
                        && $gr_props{$id}{ytype} eq "Depth") {
                        $yloc = $ymax *($y -$y1) /($y2 -$y1);
                    } else {
                        $yloc = $ymin +($ymax -$ymin) *($y2 -$y) /($y2 -$y1);
                    }
                    if ($props{$id}{meta} =~ /(data_profile_cmap|w2_profile_cmap|time_series)/
                         && (! defined($gr_props{$id}{xtype}) || $gr_props{$id}{xtype} eq "Date/Time")) {
                        $xmin = &datelabel2jdate($gr_props{$id}{xmin});
                        $xmax = &datelabel2jdate($gr_props{$id}{xmax});
                        $xloc = $xmin +($xmax -$xmin) *($x -$x1) /($x2 -$x1);
                        $xloc = &jdate2datelabel($xloc, "Mon-DD-YYYY");
                        $status_line .= sprintf("  [%s, %.2f]", $xloc, $yloc);
                    } else {
                        $xmin = $gr_props{$id}{xmin};
                        $xmax = $gr_props{$id}{xmax};
                        if ($props{$id}{meta} =~ /w2_slice|w2_wlevels/ && $gr_props{$id}{xflip}) {
                            $xloc = $xmin +($xmax -$xmin) *(1.0 -($x -$x1) /($x2 -$x1));
                        } else {
                            $xloc = $xmin +($xmax -$xmin) *($x -$x1) /($x2 -$x1);
                        }
                        $status_line .= sprintf("  [%.2f, %.2f]", $xloc, $yloc);
                    }
                }
            }

        } else {
            $grp = "";
            $status_line .= "  " . ucfirst($type);
            if ($type =~ /^(text|circle|ellipse|rectangle|diamond|polygon)$/
                && defined($link_props{$id}{id})) {
                $status_line .= " Link";
            }
        }
        if (! defined($old_id) || $id != $old_id) {
            &end_select($canv, $old_id) if (defined($old_id));
            $code = &get_rgb_code($canvas_color);
            if ($type eq "image") {
                $fg = &get_rgb_code("black");
                if ($code eq $fg) {
                    if ($code =~ /^\#[0-9a-f]/i) {
                        $fg = &get_rgb_code(&get_bw_contrast($code));
                    }
                }
                @coords = &find_rect_from_text_or_image($canv, $id);
                $box_id = $canv->create_polygon(@coords, -width   => 2,
                                               -outline => $fg,
                                               -fill    => "",
                                               -smooth  => 'false',
                                               -tags    => "working");
                $canv->raise($box_id, $id);

            } elsif ($type eq "text") {
                $canv->itemconfigure($id, -fill => &get_rgb_code($text_select_color));

            } elsif ($type eq "graph") {
                $canv->itemconfigure($id, -width => $props{$id}{width} +1,
                                        -outline => &get_rgb_code($text_select_color));

            } else {
                if ($props{$id}{width} == 0) {
                    $canv->itemconfigure($id, -width => 1,
                                            -outline => &get_rgb_code($props{$id}{color}));
                } else {
                    $canv->itemconfigure($id, -width => $props{$id}{width} +1);
                }
                if ($code eq &get_rgb_code($props{$id}{color})) {
                    if ($code =~ /^\#[0-9a-f]/i) {
                        $fg = &get_rgb_code(&get_bw_contrast($code));
                        if ($type eq "line" || $type eq "polyline") {
                            $canv->itemconfigure($id, -fill => $fg);
                        } else {
                            $canv->itemconfigure($id, -outline => $fg);
                        }
                    }
                }
            }
        }
        if ($action eq "move") {
            $canv->g_bind("<Button-1>", [ \&begin_move, $canv, $id, $grp ]);
        } elsif ($action eq "edit") {
            $canv->g_bind("<Button-1>", [ \&begin_edit, Tkx::Ev("%X","%Y"), $canv, $id ]);
        } elsif ($action eq "duplicate") {
            $canv->g_bind("<Button-1>", [ \&duplicate, $canv, $id ]);
        } elsif ($action eq "kill") {
            $canv->g_bind("<Button-1>", [ \&object_kill, $canv, $id ]);
        } elsif ($action eq "menu") {
            $canv->configure(-cursor => $cursor_select);
            $canv->g_bind("<Shift-Button-1>", [ \&add_selection, $canv, $id, 0 ]);
            $canv->g_bind("<Button-1>",       [ \&add_selection, $canv, $id, 1 ]);
            $canv->g_bind("<Button-3>",       [ \&popup_menu, Tkx::Ev("%X","%Y"), $canv, $id ]);
        } elsif ($action =~ /zoom/ && $type eq "graph" && $props{$id}{meta} =~ /time_series/) {
            if ($action =~ /zoom_in/) {
                $canv->delete("zoom_bar");
                if ($action =~ /^(zoom_in|zoom_in_X)$/) {
                    $x = $x1 if ($x < $x1);
                    $x = $x2 if ($x > $x2);
                    $canv->create_rectangle($x, $y2, $x, $y2+4,
                           -outline => "",
                           -width   => 0,
                           -fill    => &get_rgb_code($text_select_color),
                           -tags    => "zoom_bar");
                }
                if ($action =~ /^(zoom_in|zoom_in_Y)$/) {
                    $y = $y1 if ($y < $y1);
                    $y = $y2 if ($y > $y2);
                    $canv->create_rectangle($x1-4, $y, $x1, $y,
                           -outline => "",
                           -width   => 0,
                           -fill    => &get_rgb_code($text_select_color),
                           -tags    => "zoom_bar");
                }
                $canv->g_bind("<Button-1>", [ \&begin_zoom_box, Tkx::Ev("%x","%y"), $canv, $id, $action ]);
            } elsif ($action eq "zoom_out") {
                $canv->g_bind("<Button-1>", [ \&zoom_out, $canv, $id ]);
            } elsif ($action eq "zoom_out_X") {
                $canv->g_bind("<Button-1>", [ \&zoom_out_X, $canv, $id ]);
            } elsif ($action eq "zoom_out_Y") {
                $canv->g_bind("<Button-1>", [ \&zoom_out_Y, $canv, $id ]);
            } elsif ($action eq "zoom_full") {
                $canv->g_bind("<Button-1>", [ \&zoom_full, $canv, $id ]);
            } elsif ($action eq "zoom_full_X") {
                $canv->g_bind("<Button-1>", [ \&zoom_full_X, $canv, $id ]);
            } elsif ($action eq "zoom_full_Y") {
                $canv->g_bind("<Button-1>", [ \&zoom_full_Y, $canv, $id ]);
            }
        }
        $old_id = $id;

    } else {
        &end_select($canv, $id)     if (defined($id) && $id ne "");
        &end_select($canv, $old_id) if (defined($old_id));
        undef $old_id               if (defined($old_id));
        $canv->g_bind("<Button-1>",       "");
        $canv->g_bind("<Shift-Button-1>", "");
        if ($action eq "menu") {
            $canv->configure(-cursor => $cursor_norm);
            $canv->g_bind("<Button-1>", [ \&begin_select_box, Tkx::Ev("%x","%y"), $canv ]);
            $canv->g_bind("<Button-3>", [ \&popup_menu,       Tkx::Ev("%X","%Y"), $canv ]);
        }
    }
}


sub add_selection {
    my ($canv, $id, $start) = @_;
    my ($i, $np, $tag, $type, $xp, $yp,
        @coords, @tags,
       );

    &clear_selection($canv) if ($start);
    &end_select($canv, $id, 1);

#   Deselect and return if already selected
    $type = $props{$id}{type};
    @tags = Tkx::SplitList($canv->itemcget($id, -tags));
    if (&list_match("select", @tags) > -1) {
        $canv->dtag($id, "select");
        $canv->delete("select_" . $type . $id);
        return;
    }

#   Tag the object and provide selection markers
    $canv->addtag("select", withtag => $id);
    $tag    = "select_box" . " " . "select_" . $type . $id;
    @coords = &get_coords($canv, $id, "bbox");
    $canv->create_polygon(@coords,
                            -outline => &get_rgb_code("gray50"),
                            -width   => 2,
                            -fill    => "",
                            -tags    => $tag);
    $np  = ($#coords +1)/2.;
    $tag = "select_pts" . " " . "select_" . $type . $id;
    for ($i=0; $i<$np; $i++) {
        $xp = $coords[2*$i];
        $yp = $coords[2*$i+1];
        $canv->create_rectangle($xp-2, $yp-2, $xp+2, $yp+2,
                            -outline => &get_rgb_code("gray50"),
                            -width   => 1,
                            -fill    => &get_rgb_code("gray70"),
                            -tags    => $tag);
    }
    $canv->raise("select_" . $type . $id, $id);
}


sub group_items {
    my ($canv, @items) = @_;
    my ($rnum, $group_tag, $id, $type);

    $rnum      = &get_random_number();
    $group_tag = "group_" . $rnum;
    foreach $id (@items) {
        $type = $props{$id}{type};
        if ($type ne "graph") {
            $canv->addtag($group_tag, withtag => $id);
        } else {
            $canv->addtag($group_tag, withtag => "graph" . $id);
        }
    }
    &clear_selection($canv);
    return $group_tag;
}


sub ungroup_items {
    my ($canv, $tag) = @_;

    &clear_selection($canv);
    $canv->dtag($tag);
    delete $props{$tag};
}


sub show_group {
    my ($canv, $tag) = @_;
    my ($i, $item, $np, $type, $xp, $yp,
        @coords, @items,
       );

    @items = Tkx::SplitList($canv->find_withtag($tag));
    foreach $item (@items) {
        next if (! defined($props{$item}{type}));
        $canv->addtag("select", withtag => $item);
        $type   = $props{$item}{type};
        $tag    = "select_box" . " " . "select_" . $type . $item;
        @coords = &get_coords($canv, $item, "bbox");
        $canv->create_polygon(@coords,
                                -outline => &get_rgb_code("gray50"),
                                -width   => 2,
                                -fill    => "",
                                -tags    => $tag);
        $np  = ($#coords +1)/2.;
        $tag = "select_pts" . " " . "select_" . $type . $item;
        for ($i=0; $i<$np; $i++) {
            $xp = $coords[2*$i];
            $yp = $coords[2*$i+1];
            $canv->create_rectangle($xp-2, $yp-2, $xp+2, $yp+2,
                                -outline => &get_rgb_code("gray50"),
                                -width   => 1,
                                -fill    => &get_rgb_code("gray70"),
                                -tags    => $tag);
        }
        $canv->raise("select_" . $type . $item, $item);
    }
}


sub group_kill {
    my ($canv, $tag) = @_;
    my ($item, @items);

    @items = Tkx::SplitList($canv->find_withtag($tag));
    foreach $item (@items) {
        next if (! defined($props{$item}));
        next if (! defined($props{$item}{type}));
        &object_kill($canv, $item);
    }
}


sub clear_selection_marks {
    my ($canv) = @_;

    $canv->delete("select_box");
    $canv->delete("select_pts");
}


sub clear_selection {
    my ($canv) = @_;

    $canv->dtag("select");
    &clear_selection_marks($canv);
}


sub begin_select_box {
    my ($x, $y, $canv) = @_;
    my ($box_id);

    &clear_selection($canv);

    ($x, $y) = &get_xy($canv, $x, $y, 0);
    $box_id = $canv->create_rectangle($x, $y, $x, $y,
                     -outline => &get_rgb_code("gray50"),
                     -width   => 1,
                     -fill    => "",
                     -tags    => "working");

    $canv->g_bind("<Motion>",          [ \&draw_select_box, Tkx::Ev("%x","%y"), $canv, $box_id, $x, $y ]);
    $canv->g_bind("<ButtonRelease-1>", [ \&end_select_box,  Tkx::Ev("%x","%y"), $canv, $box_id, $x, $y ]);
}


sub draw_select_box {
    my ($x, $y, $canv, $box_id, $xo, $yo) = @_;

    ($x, $y) = &get_xy($canv, $x, $y, 0);
    $canv->coords($box_id, $xo, $yo, $x, $y);
    $status_line = sprintf("Selection X,Y,W,H: %d, %d, %d, %d", $x-3, $y-3, abs($x-$xo), abs($y-$yo));
}


sub end_select_box {
    my ($x, $y, $canv, $box_id, $xo, $yo) = @_;
    my ($id, @ids);

    ($x, $y) = &get_xy($canv, $x, $y, 0);
    @ids = Tkx::SplitList($canv->find_enclosed($x, $y, $xo, $yo));
    foreach $id (@ids) {
        next if (! defined($props{$id}{type}));
        &add_selection($canv, $id, 0);
    }
    $canv->delete($box_id);
    &reset_bindings;
}


sub select_item {
    my ($canv, $id, $x, $y, $tol, $edge_only) = @_;
    my ($ang, $ang2, $d, $dist, $i, $npts, $r, $selected, $type,
        $x1, $x2, $xo, $y1, $y2, $yo,
        @coords, @xvals, @yvals,
       );

    $selected  = 0;
    $type      = $props{$id}{type};
    $edge_only = 0 if (! defined($edge_only) || $edge_only != 1);

    if ($type eq "text" || $type eq "image") {
        @coords = &find_rect_from_text_or_image($canv, $id);
        @xvals  = @yvals = ();
        for ($i=0; $i<4; $i++) {
            push(@xvals, $coords[2*$i]);
            push(@yvals, $coords[2*$i+1]);
        }
        $ang = $props{$id}{angle};

#       Rotate rectangle around x,y if angle not zero
        if ($ang != 0) {
            for ($i=0; $i<4; $i++) {
                $x1 = $xvals[$i];
                $y1 = $yvals[$i];
                next if ($x1 == $x && $y1 == $y);
                $d = sqrt(($x1-$x)*($x1-$x) + ($y1-$y)*($y1-$y));
                if ($x1 == $x) {
                    $ang2 = ($y1 > $y) ? 270 : 90;
                } elsif ($y1 == $y) {
                    $ang2 = ($x1 > $x) ? 0 : 180;
                } else {
                    $ang2 = (180./pi)*atan2(($y-$y1),($x1-$x));
                }
                $ang2 += 360 if ($ang2 < 0);
                $xvals[$i] = $x +$d *cos(($ang2 -$ang) *pi/180.);
                $yvals[$i] = $y -$d *sin(($ang2 -$ang) *pi/180.);
            }
        }

#       Selected if x,y is inside the rectangle, within tol
        if ( $x >= &min(@xvals) - $tol && $x <= &max(@xvals) + $tol &&
             $y >= &min(@yvals) - $tol && $y <= &max(@yvals) + $tol ) {
            $selected = 1;
        }

    } elsif ($type eq "line") {
        ($x1, $y1, $x2, $y2) = Tkx::SplitList($canv->coords($id));
        if ($x1 == $x2) {
            $selected = 1;
        } else {
            $dist = ($x2 - $x1) * (($y2 - $y1)*($x - $x1)/($x2 - $x1) + $y1 - $y)
                                / sqrt(($x2-$x1)*($x2-$x1) + ($y2-$y1)*($y2-$y1));
            $selected = 1 if (abs($dist) <= $tol);
        }

    } elsif ($type eq "circle") {
        ($x1, $y1, $x2, $y2) = Tkx::SplitList($canv->bbox($id));

        $xo   = ($x2 + $x1) / 2.0;
        $yo   = ($y2 + $y1) / 2.0;
        $r    = abs($xo - $x1);
        $dist = sqrt(($x - $xo)*($x - $xo) + ($y - $yo)*($y - $yo));

        if (abs($dist - $r) <= $tol || ($props{$id}{fill} && $dist <= $r)) {
            $selected = 1;
        }

    } elsif ($type =~ /^(rectangle|diamond|polygon|ellipse)$/) {
        return 1 if ($props{$id}{fill} && ! $edge_only);

        @coords = Tkx::SplitList($canv->coords($id));
        push (@coords, $coords[0], $coords[1]);
        $npts = ($#coords + 1)/2;
        for ($i=0; $i<$npts-1; $i++) {
            $x1 = $coords[2*$i];
            $y1 = $coords[2*$i+1];
            $x2 = $coords[2*$i+2];
            $y2 = $coords[2*$i+3];
            if ( $x >= &min($x1,$x2)-$tol && $x <= &max($x1,$x2)+$tol &&
                 $y >= &min($y1,$y2)-$tol && $y <= &max($y1,$y2)+$tol ) {
                if ($x1 == $x2) {
                    $selected = 1;
                    last;
                } else {
                    $dist = ($x2 - $x1)
                            * (($y2 - $y1)*($x - $x1)/($x2 - $x1) + $y1 - $y)
                            / sqrt(($x2-$x1)*($x2-$x1) + ($y2-$y1)*($y2-$y1));
                    if (abs($dist) <= $tol) {
                        $selected = 1;
                        last;
                    }
                }
            }
        }

    } elsif ($type eq "polyline") {
        @coords = Tkx::SplitList($canv->coords($id));
        $npts   = ($#coords + 1)/2;
        for ($i=0; $i<$npts-1; $i++) {
            $x1 = $coords[2*$i];
            $y1 = $coords[2*$i+1];
            $x2 = $coords[2*$i+2];
            $y2 = $coords[2*$i+3];
            if ( $x >= &min($x1,$x2)-$tol && $x <= &max($x1,$x2)+$tol &&
                 $y >= &min($y1,$y2)-$tol && $y <= &max($y1,$y2)+$tol ) {
                if ($x1 == $x2) {
                    $selected = 1;
                    last;
                } else {
                    $dist = ($x2 - $x1)
                            * (($y2 - $y1)*($x - $x1)/($x2 - $x1) + $y1 - $y)
                            / sqrt(($x2-$x1)*($x2-$x1) + ($y2-$y1)*($y2-$y1));
                    if (abs($dist) <= $tol) {
                        $selected = 1;
                        last;
                    }
                }
            }
        }
    }
    return $selected;
}


sub end_select {
    my ($canv, $id, $flag) = @_;
    my ($code, $type);

    $type = $props{$id}{type};
    $code = &get_rgb_code($props{$id}{color}) if ($type ne "image");

    if ($type eq "image") {
        $canv->delete("working");

    } elsif ($type eq "text") {
        $canv->itemconfigure($id, -fill => $code);

    } elsif ($type eq "graph") {
        $canv->itemconfigure($id, -width   => $props{$id}{width},
                                  -outline => $code);

    } elsif ($type eq "line" || $type eq "polyline") {
        $canv->itemconfigure($id, -width => $props{$id}{width},
                                  -fill  => $code);

    } elsif ($type =~ /^(circle|ellipse|rectangle|diamond|polygon)$/) {
        if ($props{$id}{width} == 0) {
            $canv->itemconfigure($id, -width   => 0,
                                      -outline => "");
        } else {
            $canv->itemconfigure($id, -width   => $props{$id}{width},
                                      -outline => $code);
        }
    }
    undef $old_id if ($flag && defined($old_id));
}


sub show_points {
    my ($canv, $id) = @_;
    my ($i, $npts, $pt, $xi, $yi,
        @coords,
       );

    end_select($canv, $id);
    undef %pt_props;
    undef $old_item if (defined($old_item));
    $canv->delete("points");

    @coords = Tkx::SplitList($canv->coords($id));
    $npts   = ($#coords + 1) /2;
    for ($i=0; $i<$npts; $i++) {
        $xi = $coords[2*$i];
        $yi = $coords[2*$i+1];
        $pt = $canv->create_rectangle($xi-2, $yi-2, $xi+2, $yi+2,
                     -outline => &get_rgb_code($anchor_line_color),
                     -width   => 1,
                     -fill    => &get_rgb_code($anchor_fill_color),
                     -tags    => "points");
        $pt_props{$pt}{x} = $xi;
        $pt_props{$pt}{y} = $yi;
    }

    $canv->g_bind("<Motion>",   [ \&highlight_pt, Tkx::Ev("%x", "%y"), $canv, $id ]);
    $canv->g_bind("<Button-1>", [ \&edit_add_pt,  Tkx::Ev("%x", "%y"), $canv, $id ]);
    $canv->g_bind("<Button-3>", [ \&exit_edit_pts, $canv, $id ]);
}


sub highlight_pt {
    my ($x, $y, $canv, $id) = @_;
    my ($i, $insert_pt, $item, $npts, $point_found, $selected, $tol, $xo, $yo,
        @coords, @tags,
       );

    ($x, $y) = &get_xy($canv, $x, $y, 0);
    $status_line = sprintf("X,Y: %d, %d", $x-3, $y-3);

    $point_found = 0;

    ($item) = $canv->find_withtag("current");
    if (defined($item) && $item ne "") {
        @tags = Tkx::SplitList($canv->itemcget($item, -tags));
        if (&list_match("points", @tags) > -1) {
            $xo = $pt_props{$item}{x};
            $yo = $pt_props{$item}{y};
            $canv->coords($item, $xo-4, $yo-4, $xo+4, $yo+4);
            if (defined($old_item) && $old_item ne $item) {
                $xo = $pt_props{$old_item}{x};
                $yo = $pt_props{$old_item}{y};
                $canv->coords($old_item, $xo-2, $yo-2, $xo+2, $yo+2);
            }
            $point_found = 1;
            $old_item = $item;
        }
    }
    if (! $point_found && defined($old_item) && $old_item ne "") {
        $xo = $pt_props{$old_item}{x};
        $yo = $pt_props{$old_item}{y};
        $canv->coords($old_item, $xo-2, $yo-2, $xo+2, $yo+2);
        undef $old_item;
    }
    if ($point_found) {
        @coords    = Tkx::SplitList($canv->coords($id));
        $npts      = ($#coords + 1) /2;
        $insert_pt = 0;
        for ($i=0; $i<$npts; $i++) {
            $xo = $coords[2*$i];
            $yo = $coords[2*$i+1];
            if ( $xo == $pt_props{$item}{x} && $yo == $pt_props{$item}{y}) {
                $insert_pt = 2*$i;
                last;
            }
        }
        $canv->configure(-cursor => $cursor_select);
        $status_line = sprintf("X,Y: %d, %d  %s", $x-3, $y-3, "Right click to move or delete...");
        $canv->g_bind("<Button-3>", [ \&edit_pts_menu, Tkx::Ev("%X", "%Y"), $canv, $id, $insert_pt ]);

    } else {
        $tol      = 4;
        $selected = &select_item($canv, $id, $x, $y, $tol, 1);
        if ($selected) {
            $canv->configure(-cursor => $cursor_draw);
            $status_line = sprintf("X,Y: %d, %d  %s", $x-3, $y-3, "Click to add point...");
        } else {
            $canv->configure(-cursor => $cursor_norm);
        }
        $canv->g_bind("<Button-3>", [ \&exit_edit_pts, $canv, $id ]);
    }
}


sub show_anchors {
    my ($canv, $id, $choice) = @_;
    my ($anc, $i, $npts, $type, $xi, $xm, $yi, $ym,
        @coords, @xvals, @yvals,
       );

    @xvals  = @yvals = ();
    $type   = $props{$id}{type};
    @coords = @{ $props{$id}{coordlist} } if ($type !~ /^(text|image)$/);

    if ($type eq "ellipse" || $type eq "diamond") {
        @coords = &find_rect_from_shape(\@coords, $props{$id}{angle});
    } elsif ($type =~ /^(polygon|polyline)$/ && $choice eq "bbox") {
        @coords = &find_rect_from_poly(\@coords, $props{$id}{angle});
    } elsif ($type eq "text" || $type eq "image") {
        @coords = &find_rect_from_text_or_image($canv, $id);
        &end_select($canv, $id, 1);
    } elsif ($type eq "circle" || $type eq "graph") {
        push(@coords, $coords[0], $coords[3]);
        splice(@coords, 2, 0, $coords[2], $coords[1]);
    }
    $npts = ($#coords + 1) /2;
    for ($i=0; $i<$npts; $i++) {
        push(@xvals, $coords[2*$i]);
        push(@yvals, $coords[2*$i+1]);
    }

    if ($type =~ /^(rectangle|diamond|ellipse|circle|text|image|line|graph)$/ ||
        ($type =~ /^(polygon|polyline)$/ && $choice eq "bbox")) {
        for ($i=0; $i<$npts; $i++) {
            $xi  = $xvals[$i];
            $yi  = $yvals[$i];
            $anc = $canv->create_rectangle($xi-2, $yi-2, $xi+2, $yi+2,
                         -outline => &get_rgb_code($anchor_line_color),
                         -width   => 1,
                         -fill    => &get_rgb_code($anchor_fill_color),
                         -tags    => "anchor");
            if (abs($xi - $props{$id}{x}) < 0.01 && abs($yi - $props{$id}{y}) < 0.01) {
                $canv->itemconfigure($anc, -fill => &get_rgb_code($anchor_select_color));
            }
            $anc_props{$anc}{x} = $xi;
            $anc_props{$anc}{y} = $yi;
            if ($type eq "text" || $type eq "image") {
                $anc_props{$anc}{type} = $text_anchors[2*$i];
            } elsif ($type eq "line") {
                $anc_props{$anc}{type} = 'point';
            } else {
                $anc_props{$anc}{type} = 'corner';
            }

            if ($i < $npts-1) {
                $xm = ($xi + $xvals[$i+1])/2.;
                $ym = ($yi + $yvals[$i+1])/2.;
            } else {
                $xm = ($xi + $xvals[0])/2.;
                $ym = ($yi + $yvals[0])/2.;
            }
            $anc = $canv->create_rectangle($xm-2, $ym-2, $xm+2, $ym+2,
                         -outline => &get_rgb_code($anchor_line_color),
                         -width   => 1,
                         -fill    => &get_rgb_code($anchor_fill_color),
                         -tags    => "anchor");
            if (abs($xm - $props{$id}{x}) < 0.01 && abs($ym - $props{$id}{y}) < 0.01) {
                $canv->itemconfigure($anc, -fill => &get_rgb_code($anchor_select_color));
            }
            $anc_props{$anc}{x} = $xm;
            $anc_props{$anc}{y} = $ym;
            if ($type eq "text" || $type eq "image") {
                $anc_props{$anc}{type} = $text_anchors[2*$i+1];
            } else {
                $anc_props{$anc}{type} = 'midpoint';
            }
        }
        if ($type ne "line") {
            $xm  = $props{$id}{xc};
            $ym  = $props{$id}{yc};
            $anc = $canv->create_rectangle($xm-2, $ym-2, $xm+2, $ym+2,
                         -outline => &get_rgb_code($anchor_line_color),
                         -width   => 1,
                         -fill    => &get_rgb_code($anchor_fill_color),
                         -tags    => "anchor");
            if (abs($xm - $props{$id}{x}) < 0.01 && abs($ym - $props{$id}{y}) < 0.01) {
                $canv->itemconfigure($anc, -fill => &get_rgb_code($anchor_select_color));
            }
            $anc_props{$anc}{x}    = $xm;
            $anc_props{$anc}{y}    = $ym;
            $anc_props{$anc}{type} = 'center';
        }
    }
    if ($type =~ /^(polygon|polyline)$/ && $choice eq "pts") {
        for ($i=0; $i<$npts; $i++) {
            $xi  = $xvals[$i];
            $yi  = $yvals[$i];
            $anc = $canv->create_rectangle($xi-2, $yi-2, $xi+2, $yi+2,
                         -outline => &get_rgb_code($anchor_line_color),
                         -width   => 1,
                         -fill    => &get_rgb_code($anchor_fill_color),
                         -tags    => "anchor");
            if (abs($xi - $props{$id}{x}) < 0.01 && abs($yi - $props{$id}{y}) < 0.01) {
                $canv->itemconfigure($anc, -fill => &get_rgb_code($anchor_select_color));
            }
            $anc_props{$anc}{x}    = $xi;
            $anc_props{$anc}{y}    = $yi;
            $anc_props{$anc}{type} = 'point';
        }
        $xm  = $props{$id}{xc_rot};
        $ym  = $props{$id}{yc_rot};
        $anc = $canv->create_rectangle($xm-2, $ym-2, $xm+2, $ym+2,
                     -outline => &get_rgb_code($anchor_line_color),
                     -width   => 1,
                     -fill    => &get_rgb_code($anchor_fill_color),
                     -tags    => "anchor");
        if (abs($xm - $props{$id}{x}) < 0.01 && abs($ym - $props{$id}{y}) < 0.01) {
            $canv->itemconfigure($anc, -fill => &get_rgb_code($anchor_select_color));
        }
        $anc_props{$anc}{x}    = $xm;
        $anc_props{$anc}{y}    = $ym;
        $anc_props{$anc}{type} = 'center_rot';
    }

    $canv->g_bind("<Motion>",   [ \&highlight_anchor,  $canv, $id ]);
    $canv->g_bind("<Button-1>", [ \&set_anchor,        $canv, $id ]);
    $canv->g_bind("<Button-3>", [ \&forget_set_anchor, $canv, $id ]);

    $status_line = "Select anchor point...";
}


sub highlight_anchor {
    my ($canv, $id) = @_;
    my ($anchor_found, $item, $xo, $yo,
        @tags,
       );

    $anchor_found = 0;

    ($item) = $canv->find_withtag("current");
    if (defined($item) && $item ne "") {
        @tags = Tkx::SplitList($canv->itemcget($item, -tags));
        if (&list_match("anchor", @tags) > -1) {
            $xo = $anc_props{$item}{x};
            $yo = $anc_props{$item}{y};
            $canv->coords($item, $xo-4, $yo-4, $xo+4, $yo+4);
            if (defined($old_item) && $old_item ne $item) {
                $xo = $anc_props{$old_item}{x};
                $yo = $anc_props{$old_item}{y};
                $canv->coords($old_item, $xo-2, $yo-2, $xo+2, $yo+2);
            }
            $anchor_found = 1;
            $old_item = $item;
        }
    }
    if (! $anchor_found && defined($old_item) && $old_item ne "") {
        $xo = $anc_props{$old_item}{x};
        $yo = $anc_props{$old_item}{y};
        $canv->coords($old_item, $xo-2, $yo-2, $xo+2, $yo+2);
        undef $old_item;
    }
}


sub set_anchor {
    my ($canv, $id) = @_;
    my ($anc, $anchor_found, $i, $item, $xo, $yo,
        @items, @tags,
       );

    $anchor_found = 0;

    ($item) = $canv->find_withtag("current");
    if (defined($item) && $item ne "") {
        @tags = Tkx::SplitList($canv->itemcget($item, -tags));
        if (&list_match("anchor", @tags) > -1) {
            $xo                 = $anc_props{$item}{x};
            $yo                 = $anc_props{$item}{y};
            $props{$id}{x}      = $xo;
            $props{$id}{y}      = $yo;
            $props{$id}{anchor} = $anc_props{$item}{type};
            $canv->itemconfigure($item, -fill => &get_rgb_code($anchor_select_color));
            $anchor_found = 1;
            if ($props{$id}{type} eq "text") {
                $anc = $canv->itemcget($id, -anchor);
                if ($anc ne $props{$id}{anchor}) {
                    $canv->coords($id, $xo, $yo);
                    $canv->itemconfigure($id, -anchor => $props{$id}{anchor});
                }
            }

        }
    }
    if ($anchor_found) {
        @items = Tkx::SplitList($canv->find_withtag("anchor"));
        for ($i=0; $i<=$#items; $i++) {
            next if ($xo == $anc_props{$items[$i]}{x} && $yo == $anc_props{$items[$i]}{y});
            $canv->itemconfigure($items[$i], -fill => &get_rgb_code($anchor_fill_color));
        }
        Tkx::update_idletasks();
        sleep 1;
        $canv->delete("anchor");
        &reset_bindings;

    } elsif (defined($old_item) && $old_item ne "") {
        $xo = $anc_props{$old_item}{x};
        $yo = $anc_props{$old_item}{y};
        $canv->coords($old_item, $xo-2, $yo-2, $xo+2, $yo+2);
    }
    undef $old_item if (defined($old_item));
}


sub forget_set_anchor {
    my ($canv, $id) = @_;

    undef %anc_props;
    undef $old_item if (defined($old_item));
    end_select($canv, $id);
    $canv->delete("anchor");
    &reset_bindings;
}


################################################################################
#
# Show or edit object properties
#
################################################################################

sub edit_text_props {
    my ($id, $X, $Y) = @_;
    my (
        $code, $color, $color_btn, $f, $family, $fg, $fontfamily_cb,
        $fontsize_cb, $frame, $geom, $linked, $size, $slant, $text,
        $text_entry, $underline, $weight,
       );

#   Get current text properties and a window placement.
    $color     = $props{$id}{color};
    $family    = $props{$id}{family};
    $size      = $props{$id}{size};
    $weight    = $props{$id}{weight};
    $slant     = $props{$id}{slant};
    $underline = $props{$id}{underline};
    $text      = $canvas->itemcget($id, -text);
    $geom      = sprintf("+%d+%d", $X, $Y+7);

#   Determine whether the text object is a link
    $linked = (defined($link_props{$id}{id})) ? 1 : 0;

#   Create a new menu each time, because the old one was tied to
#   the previous text item, and it's too much hassle to clean that up.

    if (defined($text_props_menu) && Tkx::winfo_exists($text_props_menu)) {
        if ($text_props_menu->g_wm_title() eq "Text Properties") {
            $text_props_menu->g_destroy();
            undef $text_props_menu;
        }
    }

    $text_props_menu = $main->new_toplevel();
    $text_props_menu->g_wm_transient($main);
    $text_props_menu->g_wm_title("Text Properties");
    $text_props_menu->configure(-cursor => $cursor_norm);
    $text_props_menu->g_wm_geometry($geom);

    $frame = $text_props_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    $frame->new_button(
            -text    => "OK",
            -command => sub { \&set_text_props($id, $text, $color,
                                  $family, $size, $weight, $slant,
                                  $underline, "OK");
                            }
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Apply",
            -command => sub { \&set_text_props($id, $text, $color,
                                  $family, $size, $weight, $slant,
                                  $underline, "Apply");
                            }
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text => "Cancel",
            -command => sub { my (@tags);
                              @tags = Tkx::SplitList($canvas->itemcget($id, -tags));
                              if (&list_match("keep", @tags) == -1) {
                                  $canvas->dtag("working");
                                  $canvas->delete($id);
                                  delete $props{$id};
                                  undef $old_id if (defined($old_id));
                              }
                              $text_props_menu->g_destroy();
                              undef $text_props_menu;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

    $f = $text_props_menu->new_frame();
    $f->g_pack(-side => 'top');

    $f->new_label(-text => "Family:")->g_pack(-side => 'left');
    $fontfamily_cb = $f->new_ttk__combobox(
                         -textvariable => \$family,
                         -values       => [ sort @available_fonts ],
                         -state        => 'readonly',
                         );
    $fontfamily_cb->g_pack(-fill => 'x', -side => 'left');
    $fontfamily_cb->g_bind("<<ComboboxSelected>>",
                    sub { $text_entry->configure(
                          -font => [-family     => $family,
                                    -size       => $size,
                                    -weight     => $weight,
                                    -slant      => $slant_type[$slant],
                                    -underline  => $underline,
                                    -overstrike => 0,
                                   ]) }
                    );

    $f->new_label(-text => "Size:")->g_pack(-side => 'left');
    $fontsize_cb = $f->new_ttk__combobox(
                       -textvariable => \$size,
                       -values       => [(5 .. 32)],
                       -width        => 2,
                       -state        => 'readonly',
                       );
    $fontsize_cb->g_pack(-side => 'left');
    $fontsize_cb->g_bind("<<ComboboxSelected>>",
                  sub { $text_entry->configure(
                        -font => [-family     => $family,
                                  -size       => $size,
                                  -weight     => $weight,
                                  -slant      => $slant_type[$slant],
                                  -underline  => $underline,
                                  -overstrike => 0,
                                 ]) }
                  );

    $f->new_checkbutton(
               -text     => 'Weight',
               -variable => \$weight,
               -onvalue  => 'bold',
               -offvalue => 'normal',
               -command  => sub { $text_entry->configure(
                                  -font => [-family     => $family,
                                            -size       => $size,
                                            -weight     => $weight,
                                            -slant      => $slant_type[$slant],
                                            -underline  => $underline,
                                            -overstrike => 0,
                                           ]) }
               )->g_pack(-side => 'left');

    $f->new_checkbutton(
               -text     => 'Slant',
               -variable => \$slant,
               -onvalue  => 1,
               -offvalue => 0,
               -command  => sub { $text_entry->configure(
                                  -font => [-family     => $family,
                                            -size       => $size,
                                            -weight     => $weight,
                                            -slant      => $slant_type[$slant],
                                            -underline  => $underline,
                                            -overstrike => 0,
                                           ]) }
               )->g_pack(-side => 'left');

    $f->new_checkbutton(
               -text     => 'Underline',
               -variable => \$underline,
               -command  => sub { $text_entry->configure(
                                  -font => [-family     => $family,
                                            -size       => $size,
                                            -weight     => $weight,
                                            -slant      => $slant_type[$slant],
                                            -underline  => $underline,
                                            -overstrike => 0,
                                           ]) }
               )->g_pack(-side => 'left');

    $f->new_label( -text => "Color:",
                   -font => 'default',
                 )->g_pack(-side => 'left');

    $code  = &get_rgb_code($color);
    $color = &get_rgb_name($code);
    $fg    = &get_rgb_code("black");
    if ($code =~ /^\#[0-9a-f]/i) {
        $fg = &get_rgb_code(&get_bw_contrast($code));
    }
    $color_btn = $f->new_button(
               -textvariable => \$color,
               -background   => $code,
               -foreground   => $fg,
               -width        => -7,
               -command => sub {
                              my ($newc, $code, $fg);
                              $code = &get_rgb_code($color);
                              $newc = Tkx::tk___chooseColor(
                                         -initialcolor => $code,
                                         -parent       => $text_props_menu);
                              if ($newc) {
                                $code  = &get_rgb_code($newc);
                                $color = &get_rgb_name($code);
                                $fg    = &get_rgb_code("black");
                                if ($code =~ /^\#[0-9a-f]/i) {
                                    $fg = &get_rgb_code(&get_bw_contrast($code));
                                }
                                $color_btn->configure(-foreground => $fg,
                                                      -background => $code);
                                $text_entry->configure(-foreground => $code);
                              }
                            }
               );
    $color_btn->g_pack(-side => 'left', -padx => 2, -pady => 2);

    $text_entry = $text_props_menu->new_entry(
                -textvariable => \$text,
                -foreground   => $color,
                -background   => $canvas_color,
                -font => [-family     => $family,
                          -size       => $size,
                          -weight     => $weight,
                          -slant      => $slant_type[$slant],
                          -underline  => $underline,
                          -overstrike => 0,
                         ],
                );
    $text_entry->g_pack(-fill => 'x');

    if ($linked) {
        $text_entry->configure(-state => 'readonly');
    }
    Tkx::wm_resizable($text_props_menu,0,0);
    &adjust_window_position($text_props_menu);
    $text_props_menu->g_focus;
}


sub set_text_props {
    my ($id, $text, $col, $fam, $siz, $wei, $sla, $und, $action) = @_;

    if ($text eq "") {
        &pop_up_error($main, "Text string is empty.\nPlease add some text.");
        $text_props_menu->g_raise();
        $text_props_menu->g_focus;
        return;
    }
    $canvas->itemconfigure($id,
                           -text => $text,
                           -fill => &get_rgb_code($col),
                           -font => [-family     => $fam,
                                     -size       => $siz,
                                     -weight     => $wei,
                                     -slant      => $slant_type[$sla],
                                     -underline  => $und,
                                     -overstrike => 0,
                                    ],
                          );
    $canvas->addtag("keep", withtag => $id);

    $props{$id}{text}      = $text;
    $props{$id}{color}     = $col;
    $props{$id}{family}    = $fam;
    $props{$id}{size}      = $siz;
    $props{$id}{weight}    = $wei;
    $props{$id}{slant}     = $sla;
    $props{$id}{underline} = $und;

    if ($action eq "OK") {
        $text_props_menu->g_destroy();
        undef $text_props_menu;
    }
}


sub edit_object_props {
    my ($id, $X, $Y) = @_;
    my ($ahd1, $ahd2, $ahd3, $amenu, $arrow, $arrow_opt, $code, $color,
        $color_btn, $f, $f_bot, $fc_btn, $fc_ck, $fcfg, $fcode, $fcolor,
        $fg, $fill, $frame, $geom, $is_link, $old_width, $ph, $preview, $pid,
        $pw, $row, $smenu, $smooth, $smooth_opt, $txt, $type, $width, $wmenu,
       );

    $geom = sprintf("+%d+%d", $X, $Y);

#   Get current properties of object.
    $type  = $props{$id}{type};
    $color = $props{$id}{color};
    $width = $props{$id}{width};
    if ($type eq "line" || $type eq "polyline") {
        $arrow = $props{$id}{arrow};
        $ahd1  = $props{$id}{ahd1};
        $ahd2  = $props{$id}{ahd2};
        $ahd3  = $props{$id}{ahd3};
    } else {
        $fill   = $props{$id}{fill};
        $fcolor = $props{$id}{fillcolor};
        $smooth = $props{$id}{smooth} if ($type =~ /^(rectangle|diamond)$/);
    }
    $is_link = (defined($link_props{$id}{id})) ? 1 : 0;

#   Create a new menu each time, because the old one was tied to
#   the previous object, and it's too much hassle to clean that up.

    if (defined($object_props_menu) && Tkx::winfo_exists($object_props_menu)) {
        if ($object_props_menu->g_wm_title() eq "Object Properties") {
            $object_props_menu->g_destroy();
            undef $object_props_menu;
        }
    }
    $object_props_menu = $main->new_toplevel();
    $object_props_menu->g_wm_transient($main);
    $object_props_menu->g_wm_title("Object Properties");
    $object_props_menu->configure(-cursor => $cursor_norm);
    $object_props_menu->g_wm_geometry($geom);

    $frame = $object_props_menu->new_frame();
    $frame->g_pack(-side => 'bottom');

    $frame->new_button(
            -text    => "OK",
            -command => sub { &set_object_props($id, $color, $width,
                                     $fill, $fcolor, $smooth,
                                     $arrow, $ahd1, $ahd2, $ahd3,
                                     "OK") },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Apply",
            -command => sub { &set_object_props($id, $color, $width,
                                     $fill, $fcolor, $smooth,
                                     $arrow, $ahd1, $ahd2, $ahd3,
                                     "Apply") },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Preview",
            -command => sub { &preview_object_props($id, $color, $width,
                                     $fill, $fcolor, $smooth,
                                     $arrow, $ahd1, $ahd2, $ahd3) },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { &restore_object_props($id) },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

    $f = $object_props_menu->new_frame();
    $f->g_pack(-side => 'top');

    $pw = 220;
    $ph = 80;
    $preview = $f->new_canvas(
            -background  => &get_rgb_code($canvas_color),
            -width       => $pw,
            -height      => $ph,
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $preview->g_pack(-side => 'top', -fill => 'x', -expand => 1);

    if ($type eq "rectangle") {
        $pid = $preview->create_polygon($pw*0.2 + 3, $ph*0.2 + 3,
                                        $pw*0.8 + 3, $ph*0.2 + 3,
                                        $pw*0.8 + 3, $ph*0.8 + 3,
                                        $pw*0.2 + 3, $ph*0.8 + 3,
                 -outline => &get_rgb_code($color),
                 -smooth  => $smooth_type[$smooth],
                 -width   => $width);
        if (! $fill || ($is_link && $fcolor eq "")) {
            $preview->itemconfigure($pid, -fill => "");
        } else {
            $preview->itemconfigure($pid, -fill => &get_rgb_code($fcolor));
        }
    } elsif ($type eq "diamond") {
        $pid = $preview->create_polygon($pw*0.5 + 3, $ph*0.2 + 3,
                                        $pw*0.8 + 3, $ph*0.5 + 3,
                                        $pw*0.5 + 3, $ph*0.8 + 3,
                                        $pw*0.2 + 3, $ph*0.5 + 3,
                 -outline => &get_rgb_code($color),
                 -smooth  => $smooth_type[$smooth],
                 -width   => $width);
        if (! $fill || ($is_link && $fcolor eq "")) {
            $preview->itemconfigure($pid, -fill => "");
        } else {
            $preview->itemconfigure($pid, -fill => &get_rgb_code($fcolor));
        }
    } elsif ($type eq "polygon") {
        $pid = $preview->create_polygon($pw*0.25 + 3, $ph*0.2 + 3,
                                        $pw*0.75 + 3, $ph*0.2 + 3,
                                        $pw*0.80 + 3, $ph*0.8 + 3,
                                        $pw*0.20 + 3, $ph*0.8 + 3,
                 -outline => &get_rgb_code($color),
                 -width   => $width);
        if (! $fill || ($is_link && $fcolor eq "")) {
            $preview->itemconfigure($pid, -fill => "");
        } else {
            $preview->itemconfigure($pid, -fill => &get_rgb_code($fcolor));
        }
    } elsif ($type eq "circle") {
        $pid = $preview->create_oval($pw*0.5 - $ph*0.3 + 3, $ph*0.2 + 3,
                                     $pw*0.5 + $ph*0.3 + 3, $ph*0.8 + 3,
                 -outline => &get_rgb_code($color),
                 -width   => $width);
        if (! $fill || ($is_link && $fcolor eq "")) {
            $preview->itemconfigure($pid, -fill => "");
        } else {
            $preview->itemconfigure($pid, -fill => &get_rgb_code($fcolor));
        }
    } elsif ($type eq "ellipse") {
        $pid = $preview->create_oval($pw*0.2 + 3, $ph*0.2 + 3,
                                     $pw*0.8 + 3, $ph*0.8 + 3,
                 -outline => &get_rgb_code($color),
                 -width   => $width);
        if (! $fill || ($is_link && $fcolor eq "")) {
            $preview->itemconfigure($pid, -fill => "");
        } else {
            $preview->itemconfigure($pid, -fill => &get_rgb_code($fcolor));
        }
    } elsif ($type eq "line" || $type eq "polyline") {
        $pid = $preview->create_line($pw*0.2 + 3, $ph*0.5 + 3,
                                     $pw*0.8 + 3, $ph*0.5 + 3,
                 -fill  => &get_rgb_code($color),
                 -width => $width,
                 -arrow => $arrow_type[$arrow],
            -arrowshape => [ $ahd1, $ahd2, $ahd3 ]);
    }

    $f_bot = $f->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f_bot->g_pack(-side => 'bottom', -fill => 'x', -expand => 1);

    $row = 0;
    if ($type eq "line" || $type eq "polyline") {
        $f_bot->new_label(
                -text => "Outline Width: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $wmenu = &native_optionmenu(
                $f_bot, 
                \$width,
                $width - 1,
                [ sub { $preview->itemconfigure($pid, -width => $width); } ],
                (1 .. 10),
                );
    } else {
        $f_bot->new_label(
                -text => "Outline Width: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $wmenu = &native_optionmenu(
                $f_bot, 
                \$width,
                $width,
                [ sub { my ($oc);
                        if ($width == 0) {
                            $preview->itemconfigure($pid, -outline => "");
                            $color_btn->configure(-state => 'disabled');
                        } elsif ($old_width == 0) {
                            $oc = $color_btn->cget(-background);
                            $preview->itemconfigure($pid, -width => $width,
                                                        -outline => &get_rgb_code($oc));
                            $color_btn->configure(-state => 'normal');
                        } else {
                            $preview->itemconfigure($pid, -width => $width);
                        }
                        $old_width = $width;
                      } ],
                (0 .. 10),
                );
        $old_width = $width;
    }
    $wmenu->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    if ($type =~ /^(rectangle|diamond)$/) {
        $row++;
        $f_bot->new_label(
                -text => "Corners: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $smooth_opt = $smooth_options[$smooth];
        $smenu = &native_optionmenu(
                $f_bot, 
                \$smooth_opt,
                $smooth,
                [ sub { my $s = &list_match($smooth_opt, @smooth_options);
                        if ($s >= 0) {
                          $smooth = $s;
                          $preview->itemconfigure($pid,
                                      -smooth => $smooth_type[$smooth]);
                        }
                      } ],
                @smooth_options,
                );
        $smenu->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    }

    $row++;
    $txt = "Outline Color: ";
    $txt = "Line Color: " if ($type eq "line" || $type eq "polyline");
    $f_bot->new_label(
            -text => $txt,
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);

    $code  = &get_rgb_code($color);
    $color = &get_rgb_name($code);
    $fg    = &get_rgb_code("black");
    if ($code =~ /^\#[0-9a-f]/i) {
        $fg = &get_rgb_code(&get_bw_contrast($code));
    }
    $color_btn = $f_bot->new_button(
            -textvariable => \$color,
            -background   => $code,
            -foreground   => $fg,
            -width        => -7,
            -command => sub {
                          my ($newc, $code, $fg);
                          $code = &get_rgb_code($color);
                          $newc = Tkx::tk___chooseColor(
                                        -initialcolor => $code,
                                        -parent       => $object_props_menu);
                          if ($newc) {
                            $code  = &get_rgb_code($newc);
                            $color = &get_rgb_name($code);
                            $fg    = &get_rgb_code("black");
                            if ($code =~ /^\#[0-9a-f]/i) {
                                $fg = &get_rgb_code(&get_bw_contrast($code));
                            }
                            $color_btn->configure(-foreground => $fg,
                                                  -background => $code);
                            if ($type ne "line" && $type ne "polyline") {
                                $preview->itemconfigure($pid, -outline => $code);
                            } else {
                                $preview->itemconfigure($pid, -fill => $code);
                            }
                          }
                        }
            );
    $color_btn->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);

    if ($type ne "line" && $type ne "polyline") {
        $row++;
        if ($is_link && $fcolor eq "") {
            $fcode = &get_rgb_code($canvas_color);
        } else {
            $fcode  = &get_rgb_code($fcolor);
            $fcolor = &get_rgb_name($fcode);
        }
        $fcfg = &get_rgb_code("black");
        if ($fcode =~ /^\#[0-9a-f]/i) {
            $fcfg = &get_rgb_code(&get_bw_contrast($fcode));
        }
        $fc_btn = $f_bot->new_button(
                -textvariable => \$fcolor,
                -background   => $fcode,
                -foreground   => $fcfg,
                -command => sub {
                              my ($newc, $code, $fg);
                              $code = &get_rgb_code($fcolor);
                              $newc = Tkx::tk___chooseColor(
                                            -initialcolor => $code,
                                            -parent       => $object_props_menu);
                              if ($newc) {
                                $code   = &get_rgb_code($newc);
                                $fcolor = &get_rgb_name($code);
                                $fg     = &get_rgb_code("black");
                                if ($code =~ /^#?[0-9a-f]/i) {
                                    $fg = &get_rgb_code(&get_bw_contrast($code));
                                }
                                $fc_btn->configure(-foreground => $fg,
                                                   -background => $code);
                                $preview->itemconfigure($pid, -fill => $code);
                              }
                            }
                );
        $fc_btn->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
        ($fc_ck = $f_bot->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "Fill with Color: ",
                -font     => 'default',
                -variable => \$fill,
                -command  => sub { 
                              if ($fill) {
                                $preview->itemconfigure($pid, -fill => &get_rgb_code($fcolor));
                                $fc_btn->configure(-state => 'normal');
                              } else {
                                $preview->itemconfigure($pid, -fill => "");
                                $fc_btn->configure(-state => 'disabled');
                              }
                             }
                ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        if ($is_link) {
            $fc_btn->configure(-state => 'disabled');
            $fc_ck->configure(-state => 'disabled');
        } elsif ($fill) {
            $fc_btn->configure(-state => 'normal');
        } else {
            $fc_btn->configure(-state => 'disabled');
        }
        if ($width == 0) {
            $color_btn->configure(-state => 'disabled');
        }

    } else {  # object is a line or polyline
        $row++;
        $f_bot->new_label(
                -text => "Arrowheads: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $arrow_opt = $arrow_options[$arrow];
        $amenu = &native_optionmenu(
                $f_bot, 
                \$arrow_opt,
                $arrow,
                [ sub { my $a = &list_match($arrow_opt, @arrow_options);
                        if ($a >= 0) {
                          $arrow = $a;
                          $preview->itemconfigure($pid,
                                      -arrow => $arrow_type[$arrow]);
                        }
                      } ],
                @arrow_options,
                );
        $amenu->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);

        $row++;
        $f_bot->new_label(
                -text    => "Arrowhead  \nCenter Length: ",
                -justify => 'right',
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'se', -pady => 2);
        $f_bot->new_scale(
                -orient   => 'horizontal',
                -from     => 6,
                -to       => 100,
                -variable => \$ahd1,
                -width    => 10,
                -sliderlength => 20,
                -takefocus    => 1,
                -command  => sub { $preview->itemconfigure($pid,
                                      -arrowshape => [ $ahd1, $ahd2, $ahd3 ]);
                                 },
                )->g_grid(-row => $row, -column => 1,
                                        -sticky => 'ew', -pady => 2);
        $row++;
        $f_bot->new_label(
                -text    => "Arrowhead  \nSide Length: ",
                -justify => 'right',
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'se', -pady => 2);
        $f_bot->new_scale(
                -orient   => 'horizontal',
                -from     => 10,
                -to       => 100,
                -variable => \$ahd2,
                -width    => 10,
                -sliderlength => 20,
                -takefocus    => 1,
                -command  => sub { $preview->itemconfigure($pid,
                                      -arrowshape => [ $ahd1, $ahd2, $ahd3 ]);
                                 },
                )->g_grid(-row => $row, -column => 1,
                                        -sticky => 'ew', -pady => 2);
        $row++;
        $f_bot->new_label(
                -text    => "Arrowhead  \nHalf Width: ",
                -justify => 'right',
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'se', -pady => 2);
        $f_bot->new_scale(
                -orient   => 'horizontal',
                -from     => 3,
                -to       => 40,
                -variable => \$ahd3,
                -width    => 10,
                -sliderlength => 20,
                -takefocus    => 1,
                -command  => sub { $preview->itemconfigure($pid,
                                      -arrowshape => [ $ahd1, $ahd2, $ahd3 ]);
                                 },
                )->g_grid(-row => $row, -column => 1,
                                        -sticky => 'ew', -pady => 2);
    }

    Tkx::wm_resizable($object_props_menu,0,0);
    &adjust_window_position($object_props_menu);
    $object_props_menu->g_focus;
}


sub set_object_props {
    my ($id, $color, $width, $fill, $fcolor, $smooth,
        $arrow, $ahd1, $ahd2, $ahd3, $action) = @_;
    my ($type);

    $props{$id}{color} = $color;
    $props{$id}{width} = $width;
    $type              = $props{$id}{type};

    if ($type =~ /^(circle|ellipse|rectangle|diamond|polygon)$/) {
        $props{$id}{fill}      = $fill;
        $props{$id}{fillcolor} = $fcolor;
        if ($fill && $fcolor ne "") {
            $canvas->itemconfigure($id, -fill => &get_rgb_code($fcolor));
        } else {
            $canvas->itemconfigure($id, -fill => "");
        }
        if ($type =~ /^(rectangle|diamond)$/) {
            $props{$id}{smooth} = $smooth;
            $canvas->itemconfigure($id, -smooth => $smooth_type[$smooth]);
        }
        if ($width == 0) {
            $canvas->itemconfigure($id, -outline => "");
        } else {
            $canvas->itemconfigure($id, -outline => &get_rgb_code($color),
                                        -width   => $width);
        }

    } elsif ($type eq "line" || $type eq "polyline") {
        $props{$id}{arrow} = $arrow;
        $props{$id}{ahd1}  = $ahd1;
        $props{$id}{ahd2}  = $ahd2;
        $props{$id}{ahd3}  = $ahd3;
        $canvas->itemconfigure($id, -fill  => &get_rgb_code($color),
                                    -width => $width,
                                    -arrow => $arrow_type[$arrow],
                               -arrowshape => [ $ahd1, $ahd2, $ahd3 ]);
    }
    if ($action eq "OK") {
        $object_props_menu->g_destroy();
        undef $object_props_menu;
    }
}


sub preview_object_props {
    my ($id, $color, $width, $fill, $fcolor, $smooth,
        $arrow, $ahd1, $ahd2, $ahd3) = @_;
    my ($type);

    $type = $props{$id}{type};

    if ($type =~ /^(circle|ellipse|rectangle|diamond|polygon)$/) {
        if ($fill && $fcolor ne "") {
            $canvas->itemconfigure($id, -fill => &get_rgb_code($fcolor));
        } else {
            $canvas->itemconfigure($id, -fill => "");
        }
        if ($type =~ /^(rectangle|diamond)$/) {
            $canvas->itemconfigure($id, -smooth => $smooth_type[$smooth]);
        }
        if ($width == 0) {
            $canvas->itemconfigure($id, -outline => "");
        } else {
            $canvas->itemconfigure($id, -outline => &get_rgb_code($color),
                                        -width   => $width);
        }

    } elsif ($type eq "line" || $type eq "polyline") {
        $canvas->itemconfigure($id, -fill  => &get_rgb_code($color),
                                    -width => $width,
                                    -arrow => $arrow_type[$arrow],
                               -arrowshape => [ $ahd1, $ahd2, $ahd3 ]);
    }
}


sub restore_object_props {
    my ($id) = @_;
    my ($ahd1, $ahd2, $ahd3, $arrow, $color, $fcolor, $fill, $smooth, $type, $width);

    $type  = $props{$id}{type};
    $color = $props{$id}{color};
    $width = $props{$id}{width};

    if ($type =~ /^(circle|ellipse|rectangle|diamond|polygon)$/) {
        $fill   = $props{$id}{fill};
        $fcolor = $props{$id}{fillcolor};
        if ($fill && $fcolor ne "") {
            $canvas->itemconfigure($id, -fill => &get_rgb_code($fcolor));
        } else {
            $canvas->itemconfigure($id, -fill => "");
        }
        if ($type =~ /^(rectangle|diamond)$/) {
            $smooth = $props{$id}{smooth};
            $canvas->itemconfigure($id, -smooth => $smooth_type[$smooth]);
        }
        if ($width == 0) {
            $canvas->itemconfigure($id, -outline => "");
        } else {
            $canvas->itemconfigure($id, -outline => &get_rgb_code($color),
                                        -width   => $width);
        }

    } elsif ($type eq "line" || $type eq "polyline") {
        $arrow = $props{$id}{arrow};
        $ahd1  = $props{$id}{ahd1};
        $ahd2  = $props{$id}{ahd2};
        $ahd3  = $props{$id}{ahd3};
        $canvas->itemconfigure($id, -fill  => &get_rgb_code($color),
                                    -width => $width,
                                    -arrow => $arrow_type[$arrow],
                               -arrowshape => [ $ahd1, $ahd2, $ahd3 ]);
    }
    $object_props_menu->g_destroy();
    undef $object_props_menu;
}


sub edit_graph_props {
    my ($id, $X, $Y, $tabid) = @_;
    my (

        $anc, $bgrid, $bgrid_ck, $bgrid_col, $bgrid_col_btn, $bh_bcellh,
        $bh_bcellh_entry, $bh_bcellh_label, $bh_bcellh_label2, $bh_bcellw,
        $bh_bcolor, $bh_bcolor_btn, $bh_bwidth, $bh_docked, $bh_font,
        $bh_font_cb, $bh_frame, $bh_show, $bh_size, $bh_size_cb,
        $bh_status, $bh_status_cb, $bh_status_opt, $bh_tcolor,
        $bh_tcolor_btn, $bh_weight, $bh_weight_cb, $bulkhead_box,
        $bulkhead_tab, $bulkhead_txt, $byear, $byear_cb, $byear_frame,
        $byear_label, $code, $color_btn, $cs_height, $cs_link, $cs_major,
        $cs_max, $cs_min, $cs_rev, $cs_status, $cs_width, $csinc_entry,
        $cslink_cb, $cslink_opt, $csmajor_entry, $csmax_entry, $csmin_entry,
        $cstatus_cb, $cstatus_opt, $dateline, $dateline_ok, $datelinec,
        $datelinec_btn, $down_img, $elev_base, $f, $fg, $fmt, $fmt_w,
        $frame, $gap_tol, $gaptol_frame, $gaptol_entry, $geom, $grid_frame,
        $grid_tab, $gridcolor, $gridcolor_btn, $gridwidth, $gridwidth_sb,
        $gridx, $gridy, $gs_size, $gs_size_cb, $gs_weight, $gs_weight_cb,
        $gstitle, $gsubtitle_txt, $gt_size, $gt_size_cb, $gt_weight,
        $gt_weight_cb, $gtfont, $gtfont_cb, $gtitle, $gtitle_frame,
        $gtitle_tab, $gtitle_txt, $i, $indx, $jd_max, $jd_min, $keyfont,
        $keyfont_cb, $keynum_txt, $keytxt_frame, $keytxt_tab, $keytitle,
        $keytitle_txt, $kn_digits, $kn_size, $kn_size_cb, $kn_weight,
        $kn_weight_cb, $kt_size, $kt_size_cb, $kt_weight, $kt_weight_cb,
        $label_txt, $le_edge, $le_edgec, $le_edgec_btn, $le_fill, $le_fillc,
        $le_fillc_btn, $le_size, $le_size_cb, $le_weight, $le_weight_cb,
        $legend_box, $legend_frame, $legend_line, $legend_tab, $legend_txt,
        $legfont, $legfont_cb, $legtitle, $legtitle_txt, $link_id, $lt_size,
        $lt_size_cb, $lt_weight, $lt_weight_cb, $n, $ncolors, $ncolors_cb,
        $old_stic_loc, $old_wl_style, $old_xunits, $old_yaxis_type,
        $old_yunits, $outlet_frame, $ph, $pre_color, $pre_width,
        $preview_bh, $preview_grid, $preview_gtitle, $preview_keytxt,
        $preview_legend, $preview_levels, $preview_saxis, $preview_scheme,
        $preview_tsdata, $preview_xaxis_txt, $preview_yaxis_txt, $pw,
        $qaxis_units, $reverse_cb, $reverse_opt, $row, $row2, $saxis_frame,
        $saxis_opt, $saxis_tab, $sc_canv, $sc_fr, $scheme_tab, $scheme_frame,
        $scheme1, $scheme2, $scheme1_cb, $scheme2_cb, $scroll_frame, $sfont,
        $sfont_cb, $sgrid, $sgrid_ck, $sgrid_col, $sgrid_col_btn, $sl_size,
        $sl_size_cb, $sl_weight, $sl_weight_cb, $smajor, $smajor_entry,
        $sop_tics, $sop_tics_cb, $spr_tics, $spr_tics_cb, $st_size,
        $st_size_cb, $st_weight, $st_weight_cb, $stic_dx, $stic_loc,
        $stic_loc_cb, $stitle, $stitle_entry, $stitle_txt, $stype,
        $stype_cb, $swapsets, $ts_type, $tsdata_frame, $tsdata_line,
        $tsdata_tab, $tsdata_txt, $tsxmin, $up_img, $vscroll, $wl_color,
        $wl_frame, $wl_grid, $wl_gridc, $wl_gridc_btn, $wl_style,
        $wlcolor_btn, $wlevel_frame, $wlevel_tab, $wlstyle_cb,
        $wt_oldunits, $wt_units, $wt_units_cb, $x1, $x2, $xaxis_flip,
        $xaxis_frame, $xaxis_tab, $xaxis_type, $xaxis_type_cb, $xaxis_units,
        $xbase, $xbase_entry, $xfirst, $xfirst_entry, $xfont, $xfont_cb,
        $xformat, $xformat_cb, $xformat_label, $xgrid_line1, $xgrid_line2,
        $xgrid_line3, $xl_size, $xl_size_cb, $xl_weight, $xl_weight_cb,
        $xmaj_auto, $xmajor, $xmajor_entry, $xmax, $xmax_auto, $xmax_cb,
        $xmax_entry, $xmax_frame, $xmin, $xmin_cb, $xmin_entry, $xop_tics,
        $xpr_tics, $xt_size, $xt_size_cb, $xt_weight, $xt_weight_cb,
        $xtick_auto_cb, $xtick_int_sb, $xtick_frame, $xticklabel_txt,
        $xtitle, $xtitle_entry, $xtitle_frame, $xtitle_label,
        $xtitle_txt, $xtype_frame, $xtype_old, $xtype_sav, $xunits_cb,
        $xunits_frame, $yaxis_flip, $yaxis_frame, $yaxis_tab, $yaxis_type,
        $yaxis_type_cb, $yaxis_units, $yaxis_units_cb, $yaxis_units_label,
        $ybase, $ybase_entry, $yfirst, $yfirst_entry, $yfont, $yfont_cb,
        $yformat, $yformat_cb, $yformat_label, $ygrid_line1, $ygrid_line2,
        $yl_size, $yl_size_cb, $yl_weight, $yl_weight_cb, $ymaj_auto,
        $ymajor, $ymajor_entry, $ymajor_label, $ymax, $ymax_auto,
        $ymax_cb, $ymax_entry, $ymax_frame, $ymax_label, $ymin, $ymin_cb,
        $ymin_entry, $ymin_label, $yop_tics, $ypr_tics, $yr_max, $yr_min,
        $yt_size, $yt_size_cb, $yt_weight, $yt_weight_cb, $ytick_auto_cb,
        $ytick_frame, $ytick_int_sb, $yticklabel_txt, $ytitle, $ytitle_entry,
        $ytitle_frame, $ytitle_label, $ytitle_txt, $ytype_frame, $ytype_old,
        $ytype_sav, $yunits_cb, $yunits_frame,

        @add_ts_byear, @add_ts_color, @add_ts_ctype, @add_ts_delete,
        @add_ts_file, @add_ts_ftype, @add_ts_limits, @add_ts_lines,
        @add_ts_param, @add_ts_seg, @add_ts_setnum, @add_ts_show,
        @add_ts_text, @add_ts_tsdata, @add_ts_tzoff, @add_ts_width,
        @bh_status_opts, @color_btns, @colors, @coords, @cslink_opts,
        @date_axis_choices, @datelist1, @datelist2, @down_btn, @names,
        @saxis_opts, @saxis_types, @tic_opts, @ts_color, @ts_color_btns,
        @ts_show, @ts_text_entry, @ts_width, @ts_width_sbs, @up_btn,
        @width_sbs,

        %add_ts_parms, %parms,
       );

    $tabid = 0 if (! defined($tabid));
    $geom  = sprintf("+%d+%d", $X, $Y);

    if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
        if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
            $graph_props_menu->g_destroy();
            undef $graph_props_menu;
        }
    }
    $graph_props_menu = $main->new_toplevel();
    $graph_props_menu->g_wm_transient($main);
    $graph_props_menu->g_wm_title("Graph Properties, ID $id");
    $graph_props_menu->configure(-cursor => $cursor_norm);
    $graph_props_menu->g_wm_geometry($geom);

    $xfirst = $yfirst = $xbase = $ybase = "";
    if ($props{$id}{meta} eq "w2_tdmap") {
        if ($gr_props{$id}{date_axis} eq "X") {
            $xfont     = $gr_props{$id}{tfont};
            $xt_size   = $gr_props{$id}{tt_size};
            $xt_weight = $gr_props{$id}{tt_weight};
            $xl_size   = $gr_props{$id}{tl_size};
            $xl_weight = $gr_props{$id}{tl_weight};
            $xmin      = $gr_props{$id}{tmin};
            $xmax      = $gr_props{$id}{tmax};
            $xmajor    = $gr_props{$id}{tmajor};
            $xpr_tics  = $gr_props{$id}{tpr_tics};
            $xop_tics  = $gr_props{$id}{top_tics};
            $xtitle    = $gr_props{$id}{ttitle};
            $yfont     = $gr_props{$id}{dfont};
            $yt_size   = $gr_props{$id}{dt_size};
            $yt_weight = $gr_props{$id}{dt_weight};
            $yl_size   = $gr_props{$id}{dl_size};
            $yl_weight = $gr_props{$id}{dl_weight};
            $ybase     = $gr_props{$id}{dbase};
            $ymin      = $gr_props{$id}{dmin};
            $ymax      = $gr_props{$id}{dmax};
            $yfirst    = $gr_props{$id}{dfirst};
            $ymajor    = $gr_props{$id}{dmajor};
            $ypr_tics  = $gr_props{$id}{dpr_tics};
            $yop_tics  = $gr_props{$id}{dop_tics};
            $ytitle    = $gr_props{$id}{dtitle};
        } else {
            $xfont     = $gr_props{$id}{dfont};
            $xt_size   = $gr_props{$id}{dt_size};
            $xt_weight = $gr_props{$id}{dt_weight};
            $xl_size   = $gr_props{$id}{dl_size};
            $xl_weight = $gr_props{$id}{dl_weight};
            $xbase     = $gr_props{$id}{dbase};
            $xmin      = $gr_props{$id}{dmin};
            $xmax      = $gr_props{$id}{dmax};
            $xfirst    = $gr_props{$id}{dfirst};
            $xmajor    = $gr_props{$id}{dmajor};
            $xpr_tics  = $gr_props{$id}{dpr_tics};
            $xop_tics  = $gr_props{$id}{dop_tics};
            $xtitle    = $gr_props{$id}{dtitle};
            $yfont     = $gr_props{$id}{tfont};
            $yt_size   = $gr_props{$id}{tt_size};
            $yt_weight = $gr_props{$id}{tt_weight};
            $yl_size   = $gr_props{$id}{tl_size};
            $yl_weight = $gr_props{$id}{tl_weight};
            $ymin      = $gr_props{$id}{tmin};
            $ymax      = $gr_props{$id}{tmax};
            $ymajor    = $gr_props{$id}{tmajor};
            $ypr_tics  = $gr_props{$id}{tpr_tics};
            $yop_tics  = $gr_props{$id}{top_tics};
            $ytitle    = $gr_props{$id}{ttitle};
        }
    } else {
        $xfont     = $gr_props{$id}{xfont};
        $xt_size   = $gr_props{$id}{xt_size};
        $xt_weight = $gr_props{$id}{xt_weight};
        $xl_size   = $gr_props{$id}{xl_size};
        $xl_weight = $gr_props{$id}{xl_weight};
        $xmin      = $gr_props{$id}{xmin};
        $xmax      = $gr_props{$id}{xmax};
        $xmajor    = $gr_props{$id}{xmajor};
        $xpr_tics  = $gr_props{$id}{xpr_tics};
        $xop_tics  = $gr_props{$id}{xop_tics};
        $xtitle    = $gr_props{$id}{xtitle};
        $yfont     = $gr_props{$id}{yfont};
        $yt_size   = $gr_props{$id}{yt_size};
        $yt_weight = $gr_props{$id}{yt_weight};
        $yl_size   = $gr_props{$id}{yl_size};
        $yl_weight = $gr_props{$id}{yl_weight};
        $ymin      = $gr_props{$id}{ymin};
        $ymax      = $gr_props{$id}{ymax};
        $ymajor    = $gr_props{$id}{ymajor};
        $ypr_tics  = $gr_props{$id}{ypr_tics};
        $yop_tics  = $gr_props{$id}{yop_tics};
        $ytitle    = $gr_props{$id}{ytitle};
    }
    if ($props{$id}{meta} =~ /w2_slice|w2_wlevels/) {
        $xbase     = $gr_props{$id}{xbase};
        $xfirst    = $gr_props{$id}{xfirst};
        $stype     = $gr_props{$id}{stype};
        $sfont     = $gr_props{$id}{sfont};
        $st_size   = $gr_props{$id}{st_size};
        $st_weight = $gr_props{$id}{st_weight};
        $sl_size   = $gr_props{$id}{sl_size};
        $sl_weight = $gr_props{$id}{sl_weight};
        $smajor    = $gr_props{$id}{smajor};
        $stic_loc  = $gr_props{$id}{stic_loc};
        $sgrid     = $gr_props{$id}{sgrid};
        $sgrid_col = $gr_props{$id}{sgrid_col};
        $bgrid     = $gr_props{$id}{bgrid};
        $bgrid_col = $gr_props{$id}{bgrid_col};
        $stitle    = $gr_props{$id}{stitle};
        $spr_tics  = $gr_props{$id}{spr_tics};
        $sop_tics  = $gr_props{$id}{sop_tics};
    } else {
        $stype    = $sfont    = $st_size = $st_weight = $sl_size = $sl_weight = "";
        $smajor   = $stic_loc = $sgrid   = $sgrid_col = $bgrid   = $bgrid_col = $stitle = "";
        $spr_tics = $sop_tics = "";
    }
    $gtfont    = $gr_props{$id}{gtfont};
    $gt_size   = $gr_props{$id}{gt_size};
    $gt_weight = $gr_props{$id}{gt_weight};
    $gtitle    = $gr_props{$id}{gtitle};
    $swapsets  = 0;
    $bh_status = 0;
    $gap_tol   = $wl_color = $wl_style = $wl_grid  = $wl_gridc = $dateline = $datelinec = "";
    $le_edge   = $le_edgec = $le_fill  = $le_fillc = "";
    @tic_opts  = ("outside", "inside", "cross", "none");

    if ($props{$id}{meta} =~ /data_profile|w2_profile|w2_slice|w2_outflow|vert_wd_zone/) {
        $yaxis_type     = $gr_props{$id}{ytype};
        $old_yaxis_type = $yaxis_type;
        $yaxis_units    = $gr_props{$id}{yunits};
        $elev_base      = -999;
        $qaxis_units    = $wt_units   = $wt_oldunits = "";
        $xaxis_units    = $xaxis_flip = "";
        $xmax_auto      = 0;
        if ($props{$id}{meta} eq "vert_wd_zone") {
            $qaxis_units = $gr_props{$id}{qunits};
            $wt_units    = $props{$id}{wt_units};
            $wt_oldunits = $wt_units;
            $xmin        = 0;
        }
        if ($props{$id}{meta} =~ /data_profile|w2_profile/ && $props{$id}{parm} eq "Temperature") {
            $wt_units    = $props{$id}{parm_units};
            $wt_oldunits = $wt_units;
        }
        if ($props{$id}{meta} eq "w2_slice") {
            $xaxis_units = $gr_props{$id}{xunits};
            $xaxis_flip  = $gr_props{$id}{xflip};
            $xmax_auto   = $gr_props{$id}{xmax_auto};
            $old_xunits  = $xaxis_units;
            if ($props{$id}{parm} eq "Temperature") {
                $wt_units    = $props{$id}{parm_units};
                $wt_oldunits = $wt_units;
            }
        }
        if ($props{$id}{meta} eq "w2_outflow") {
            if ($props{$id}{add_parm} && $props{$id}{parm} eq "Temperature") {
                $wt_units    = $props{$id}{parm_units};
                $wt_oldunits = $wt_units;
            }
            $qaxis_units = $gr_props{$id}{qunits};
            $xmin        = 0;
        }
    } else {
        $yaxis_type  = $yaxis_units = $qaxis_units = $wt_units = "";
        $xaxis_units = $xaxis_flip  = $old_xunits  = "";
        $xmax_auto   = $ymax_auto   = 0;
        if ($props{$id}{meta} eq "w2_tdmap") {
            if ($gr_props{$id}{date_axis} eq "X") {
                $yaxis_flip  = $gr_props{$id}{dflip};
                $yaxis_units = $gr_props{$id}{dunits};
                $ymax_auto   = $gr_props{$id}{dmax_auto};
                $old_yunits  = $yaxis_units;
            } else {
                $xaxis_flip  = $gr_props{$id}{dflip};
                $xaxis_units = $gr_props{$id}{dunits};
                $xmax_auto   = $gr_props{$id}{dmax_auto};
                $old_xunits  = $xaxis_units;
            }
            if ($props{$id}{parm} eq "Temperature") {
                $wt_units    = $props{$id}{parm_units};
                $wt_oldunits = $wt_units;
            }
        } elsif ($props{$id}{meta} eq "w2_wlevels") {
            $yaxis_type  = "Elevation";
            $yaxis_units = $gr_props{$id}{yunits};
            $xaxis_units = $gr_props{$id}{xunits};
            $xaxis_flip  = $gr_props{$id}{xflip};
            $xmax_auto   = $gr_props{$id}{xmax_auto};
            $old_xunits  = $xaxis_units;
        }
    }
    if ($props{$id}{meta} =~ /(data_profile_cmap|w2_profile_cmap|w2_tdmap|time_series)/) {
        if ($props{$id}{meta} eq "w2_tdmap") {
            if ($gr_props{$id}{date_axis} eq "X") {
                $xaxis_type = $gr_props{$id}{ttype};
                $xaxis_flip = $gr_props{$id}{tflip};
                $xformat    = $gr_props{$id}{datefmt};
                $xtype_sav  = $xtype_old = $xaxis_type;
                $xmaj_auto  = ($xmajor eq "auto" || $xformat eq "Month") ? 1 : 0;
                $xmajor     = 10 if ($xmajor eq "auto");
            } else {
                $yaxis_type = $gr_props{$id}{ttype};
                $yaxis_flip = $gr_props{$id}{tflip};
                $yformat    = $gr_props{$id}{datefmt};
                $ytype_sav  = $ytype_old = $yaxis_type;
                $ymaj_auto  = ($ymajor eq "auto" || $yformat eq "Month") ? 1 : 0;
                $ymajor     = 10 if ($ymajor eq "auto");
            }
        } else {
            $xaxis_type = (defined($gr_props{$id}{xtype})) ? $gr_props{$id}{xtype} : "Date/Time";
            $xtype_sav  = $xtype_old = $xaxis_type;
            $xformat    = $gr_props{$id}{datefmt};
            $xmaj_auto  = ($xmajor eq "auto" || $xformat eq "Month") ? 1 : 0;
            $xmajor     = 10 if ($xmajor eq "auto");
            $xaxis_flip = 0;
            $dateline   = $gr_props{$id}{dateline};
            $datelinec  = $gr_props{$id}{datelinec};
        }
        $gs_size    = "";
        $gs_weight  = "";
        $gstitle    = "";
        $yr_max     = (localtime(time))[5] +1900;
        $yr_min     = $yr_max -25;
        $byear      = $yr_max;
        if (defined($gr_props{$id}{base_yr})) {
            $byear  = $gr_props{$id}{base_yr};
            $yr_min = $byear -5 if ($byear <= $yr_min);
            $yr_max = $byear +5 if ($byear >  $yr_max);
        }
        if ($props{$id}{meta} eq "linked_time_series") {
            ($jd_min, $jd_max) = &dates2jdates($dates[0], $dates[$#dates]);
        } elsif ($props{$id}{meta} eq "time_series") {
            if (defined($ts_datemin)) {
                ($jd_min, $jd_max) = &dates2jdates($ts_datemin, $ts_datemax);
            } else {
                $jd_min = &datelabel2jdate($xmin);   # fallback option
                $jd_max = &datelabel2jdate($xmax);
            }
        } else {
            ($jd_min, $jd_max) = &dates2jdates($cmap_datemin, $cmap_datemax);
        }
        $jd_min    = &floor($jd_min +0.0000001);
        $jd_max    = &floor($jd_max +1.0000001);
        @datelist1 = &jdates2datelabels("Mon-DD-YYYY", ($jd_min .. $jd_max));
        @datelist2 = @datelist1;
        pop   @datelist1;               # remove last  entry from list 1
        shift @datelist2;               # remove first entry from list 2
        $xmin = $datelist1[0]           if ($xmin eq "first");
        $xmax = $datelist2[$#datelist2] if ($xmax eq "last");
        @date_axis_choices = ("Year", "Month", "Mon-DD", "Mon-DD-YYYY");
        shift @date_axis_choices if ($jd_max -$jd_min <= 365 *2);
    } else {
        $xformat   = "";
        $gstitle   = "";
        $gs_size   = $gr_props{$id}{gs_size};
        $gs_weight = $gr_props{$id}{gs_weight};
    }
    if ($props{$id}{meta} eq "w2_tdmap") {
        $gs_size   = $gr_props{$id}{gs_size};
        $gs_weight = $gr_props{$id}{gs_weight};
        $gstitle   = $gr_props{$id}{gstitle};
    }
    @ts_color = @ts_show = @ts_width = ();
    @add_ts_color = @add_ts_setnum = @add_ts_show = @add_ts_text = @add_ts_width = ();

    $frame = $graph_props_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    $frame->new_button(
            -text    => "OK",
            -command => sub { &update_graph_props($id,
                               $xfont, $xt_size, $xt_weight, $xl_size, $xl_weight, $xbase, $xmin, $xmax,
                               $xfirst, $xmajor, $xmaj_auto, $xformat, $xtitle, $xpr_tics, $xop_tics,
                               $xaxis_type, $xaxis_units, $xaxis_flip, $xmax_auto, $byear,
                               $yfont, $yt_size, $yt_weight, $yl_size, $yl_weight, $ybase, $ymin, $ymax,
                               $yfirst, $ymajor, $ymaj_auto, $yformat, $ytitle, $ypr_tics, $yop_tics,
                               $yaxis_type, $yaxis_units, $yaxis_flip, $ymax_auto, $qaxis_units, $wt_units,
                               $stype, $sfont, $st_size, $st_weight, $sl_size, $sl_weight, $stic_loc,
                               $smajor, $sgrid, $sgrid_col, $bgrid, $bgrid_col, $stitle, $spr_tics, $sop_tics,
                               $gtfont, $gt_size, $gt_weight, $gs_size, $gs_weight, $gtitle, $gstitle,
                               $cs_status, $cs_link, $scheme1, $scheme2, $ncolors, $cs_rev,
                               $cs_min, $cs_max, $cs_major, $cs_width, $cs_height,
                               $keyfont, $keytitle, $kt_size, $kt_weight,
                               $kn_size, $kn_weight, $kn_digits,
                               $bh_status, $bh_font, $bh_size, $bh_weight, $bh_tcolor,
                               $bh_bwidth, $bh_bcolor, $bh_bcellw, $bh_bcellh,
                               $legfont, $lt_size, $lt_weight, $le_size, $le_weight,
                               $le_edge, $le_edgec, $le_fill, $le_fillc, $gap_tol,
                               $gridx, $gridy, $gridwidth, $gridcolor, $dateline, $datelinec,
                               $wl_color, $wl_style, $wl_grid, $wl_gridc,
                               \@ts_show, \@ts_color, \@ts_width, $legtitle, $swapsets,
                               \@add_ts_show, \@add_ts_setnum, \@add_ts_color, \@add_ts_width,
                               \@add_ts_text, \@add_ts_delete, \@add_ts_file, \@add_ts_ftype,
                               \@add_ts_lines, \@add_ts_param, \@add_ts_byear, \@add_ts_tzoff,
                               \@add_ts_seg, \@add_ts_ctype, \@add_ts_limits, \@add_ts_tsdata,
                               "OK");
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Apply",
            -command => sub { my $tabid = $grprops_notebook->index('current');
                              my $geom  = $graph_props_menu->g_wm_geometry();
                              (undef, $X, $Y) = split(/\+/, $geom);
                              &update_graph_props($id,
                               $xfont, $xt_size, $xt_weight, $xl_size, $xl_weight, $xbase, $xmin, $xmax,
                               $xfirst, $xmajor, $xmaj_auto, $xformat, $xtitle, $xpr_tics, $xop_tics,
                               $xaxis_type, $xaxis_units, $xaxis_flip, $xmax_auto, $byear,
                               $yfont, $yt_size, $yt_weight, $yl_size, $yl_weight, $ybase, $ymin, $ymax,
                               $yfirst, $ymajor, $ymaj_auto, $yformat, $ytitle, $ypr_tics, $yop_tics,
                               $yaxis_type, $yaxis_units, $yaxis_flip, $ymax_auto, $qaxis_units, $wt_units,
                               $stype, $sfont, $st_size, $st_weight, $sl_size, $sl_weight, $stic_loc,
                               $smajor, $sgrid, $sgrid_col, $bgrid, $bgrid_col, $stitle, $spr_tics, $sop_tics,
                               $gtfont, $gt_size, $gt_weight, $gs_size, $gs_weight, $gtitle, $gstitle,
                               $cs_status, $cs_link, $scheme1, $scheme2, $ncolors, $cs_rev,
                               $cs_min, $cs_max, $cs_major, $cs_width, $cs_height,
                               $keyfont, $keytitle, $kt_size, $kt_weight,
                               $kn_size, $kn_weight, $kn_digits,
                               $bh_status, $bh_font, $bh_size, $bh_weight, $bh_tcolor,
                               $bh_bwidth, $bh_bcolor, $bh_bcellw, $bh_bcellh,
                               $legfont, $lt_size, $lt_weight, $le_size, $le_weight,
                               $le_edge, $le_edgec, $le_fill, $le_fillc, $gap_tol,
                               $gridx, $gridy, $gridwidth, $gridcolor, $dateline, $datelinec,
                               $wl_color, $wl_style, $wl_grid, $wl_gridc,
                               \@ts_show, \@ts_color, \@ts_width, $legtitle, $swapsets,
                               \@add_ts_show, \@add_ts_setnum, \@add_ts_color, \@add_ts_width,
                               \@add_ts_text, \@add_ts_delete, \@add_ts_file, \@add_ts_ftype,
                               \@add_ts_lines, \@add_ts_param, \@add_ts_byear, \@add_ts_tzoff,
                               \@add_ts_seg, \@add_ts_ctype, \@add_ts_limits, \@add_ts_tsdata,
                               "Apply", $X, $Y, $tabid);
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $graph_props_menu->g_destroy();
                              undef $graph_props_menu; },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

    $f = $graph_props_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f->g_pack(-side => 'top');

#   Create tabbed notebook
    $grprops_notebook = $f->new_ttk__notebook();
    $grprops_notebook->g_pack();
    $pw = 270;
    $ph = 45;

#   X axis tab
    $xaxis_tab = $grprops_notebook->new_frame();
    $grprops_notebook->add($xaxis_tab,
            -text      => "X Axis",
            -underline => 0,
            -sticky    => 'nsew',
            );

    $preview_xaxis_txt = $xaxis_tab->new_canvas(
            -background  => &get_rgb_code($canvas_color),
            -width       => $pw,
            -height      => $ph,
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $preview_xaxis_txt->g_grid(-row => 0, -column => 0, -sticky => 'wne');

    $xtitle_txt = $preview_xaxis_txt->create_text($pw*0.3 +3, $ph*0.5 +3,
            -anchor => 'center', 
            -text   => "Axis Title",
            -fill   => "#000000",
            -angle  => 0,
            -font   => [-family     => $xfont,
                        -size       => $xt_size,
                        -weight     => $xt_weight,
                        -slant      => 'roman',
                        -underline  => 0,
                        -overstrike => 0,
                       ]);
    $xticklabel_txt = $preview_xaxis_txt->create_text($pw*0.7 +3, $ph*0.5 +3,
            -anchor => 'center', 
            -text   => "Tick Label",
            -fill   => "#000000",
            -angle  => 0,
            -font   => [-family     => $xfont,
                        -size       => $xl_size,
                        -weight     => $xl_weight,
                        -slant      => 'roman',
                        -underline  => 0,
                        -overstrike => 0,
                       ]);

    $xaxis_frame = $xaxis_tab->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $xaxis_frame->g_grid(-row => 1, -column => 0, -sticky => 'wnes');

    $row = 0;
    $xaxis_frame->new_label(
            -text => "X Axis Font: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($xfont_cb = $xaxis_frame->new_ttk__combobox(
            -textvariable => \$xfont,
            -values       => [ sort @available_fonts ],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
    $xfont_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_xaxis_txt->itemconfigure($xtitle_txt,
                          -font => [ -family     => $xfont,
                                     -size       => $xt_size,
                                     -weight     => $xt_weight,
                                     -slant      => 'roman',
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                    $preview_xaxis_txt->itemconfigure($xticklabel_txt,
                          -font => [ -family     => $xfont,
                                     -size       => $xl_size,
                                     -weight     => $xl_weight,
                                     -slant      => 'roman',
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                  });
    $row++;
    $xaxis_frame->new_label(
            -text => "X Title/Label Size: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($xt_size_cb = $xaxis_frame->new_ttk__combobox(
            -textvariable => \$xt_size,
            -values       => [(5 .. 24)],
            -width        => 5,
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
    $xt_size_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_xaxis_txt->itemconfigure($xtitle_txt,
                          -font => [ -family     => $xfont,
                                     -size       => $xt_size,
                                     -weight     => $xt_weight,
                                     -slant      => 'roman',
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                  });
    ($xl_size_cb = $xaxis_frame->new_ttk__combobox(
            -textvariable => \$xl_size,
            -values       => [(5 .. 24)],
            -width        => 5,
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 2, -sticky => 'ew', -pady => 2);
    $xl_size_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_xaxis_txt->itemconfigure($xticklabel_txt,
                          -font => [ -family     => $xfont,
                                     -size       => $xl_size,
                                     -weight     => $xl_weight,
                                     -slant      => 'roman',
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                  });
    $row++;
    $xaxis_frame->new_label(
            -text => "X Title/Label Weight: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($xt_weight_cb = $xaxis_frame->new_ttk__combobox(
            -textvariable => \$xt_weight,
            -values       => [("normal", "bold")],
            -width        => 5,
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
    $xt_weight_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_xaxis_txt->itemconfigure($xtitle_txt,
                          -font => [ -family     => $xfont,
                                     -size       => $xt_size,
                                     -weight     => $xt_weight,
                                     -slant      => 'roman',
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                  });
    ($xl_weight_cb = $xaxis_frame->new_ttk__combobox(
            -textvariable => \$xl_weight,
            -values       => [("normal", "bold")],
            -width        => 5,
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 2, -sticky => 'ew', -pady => 2);
    $xl_weight_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_xaxis_txt->itemconfigure($xticklabel_txt,
                          -font => [ -family     => $xfont,
                                     -size       => $xl_size,
                                     -weight     => $xl_weight,
                                     -slant      => 'roman',
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                  });

    if ($props{$id}{meta} =~ /(data_profile_cmap|w2_profile_cmap|time_series)/
          || ($props{$id}{meta} eq "w2_tdmap" && $gr_props{$id}{date_axis} eq "X")) {
        $row++;
        $xaxis_frame->new_label(
                -text => "X Axis Type: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        if ($props{$id}{meta} eq "w2_tdmap") {
            ($xtype_frame = $xaxis_frame->new_frame(
                    -borderwidth => 0,
                    -relief      => 'flat',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew');
            ($xaxis_type_cb = $xtype_frame->new_ttk__combobox(
                    -textvariable => \$xaxis_type,
                    -values       => [ ("Date/Time", "Julian Date") ],
                    -state        => 'readonly',
                    -width        => 11,
                    ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
            $xtype_frame->new_checkbutton(
                    -onvalue  => 1,
                    -offvalue => 0,
                    -text     => "Flip?",
                    -font     => 'default',
                    -variable => \$xaxis_flip,
                    )->g_pack(-side => 'left', -anchor => 'w');
        } else {
            ($xaxis_type_cb = $xaxis_frame->new_ttk__combobox(
                    -textvariable => \$xaxis_type,
                    -values       => [ ("Date/Time", "Julian Date") ],
                    -state        => 'readonly',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        }
        $xaxis_type_cb->g_bind("<<ComboboxSelected>>",
                                sub { my ($base_jd);
                                      return if ($xaxis_type eq $xtype_old);
                                      $xtype_old = $xaxis_type;
                                      $base_jd   = &date2jdate(sprintf("%04d%02d%02d", $byear, 1, 1));
                                      if ($xaxis_type eq "Date/Time") {
                                          $xmin_entry->g_grid_remove();
                                          $xmax_entry->g_grid_remove();
                                          $xmajor_entry->g_grid_remove();
                                          $byear_label->g_grid_remove();
                                          $byear_frame->g_grid_remove();
                                          $xtitle_label->g_grid_remove();
                                          $xtitle_entry->g_grid_remove();
                                          $xformat_label->g_grid();
                                          $xformat_cb->g_grid();
                                          $xmin_cb->g_grid();
                                          $xmax_cb->g_grid();
                                          $xtick_frame->g_grid();

                                          $xmajor = &max(1, &min(500, &round_to_int($xmajor)));
                                          $xmin  += $base_jd -1;
                                          $xmax  += $base_jd -1;
                                          if ($xmin >= $jd_min && $xmin <= $jd_max) {
                                              $xmin = &jdate2datelabel($xmin, "Mon-DD-YYYY");
                                          } else {
                                              $xmin = $datelist1[0];
                                          }
                                          if ($xmax >= $jd_min && $xmax <= $jd_max) {
                                              $xmax = &jdate2datelabel($xmax, "Mon-DD-YYYY");
                                          } else {
                                              $xmax = $datelist2[$#datelist2];
                                          }
                                          if (&datelabel2jdate($xmax) - &datelabel2jdate($xmin) > 365 *2) {
                                              if ($#date_axis_choices == 2) {
                                                  unshift (@date_axis_choices, "Year");
                                                  $xformat_cb->configure(-values => [ @date_axis_choices ]);
                                              }
                                          } elsif ($#date_axis_choices == 3) {
                                              shift @date_axis_choices;
                                              $xformat_cb->configure(-values => [ @date_axis_choices ]);
                                              if ($xformat eq "Year") {
                                                  $xformat = "Month";
                                                  Tkx::event_generate($xformat_cb, "<<ComboboxSelected>>");
                                              }
                                          }
                                      } else {
                                          $xformat_label->g_grid_remove();
                                          $xformat_cb->g_grid_remove();
                                          $xmin_cb->g_grid_remove();
                                          $xmax_cb->g_grid_remove();
                                          $xtick_frame->g_grid_remove();
                                          $byear_label->g_grid();
                                          $byear_frame->g_grid();
                                          $xmin_entry->g_grid();
                                          $xmax_entry->g_grid();
                                          $xmajor_entry->g_grid();
                                          $xtitle_label->g_grid();
                                          $xtitle_entry->g_grid();

                                          $xmin = &datelabel2jdate($xmin) -$base_jd +1;
                                          $xmax = &datelabel2jdate($xmax) -$base_jd +1;
                                          if ($xmin < 1 || $xmax <= $xmin || $xmax <= 1) {
                                              if ($xtype_sav eq "Date/Time") {
                                                  $xmin = 1 if ($xmin < 1);
                                                  if ($xmax <= $xmin || $xmax <= 1) {
                                                      $xmax = ($xmin < 366) ? 366 : $xmin +365;
                                                  }
                                              } else {
                                                  $xmin = $gr_props{$id}{xmin};
                                                  $xmax = $gr_props{$id}{xmax};
                                              }
                                          }
                                      }
                                    });

        $row++;
        ($byear_label = $xaxis_frame->new_label(
                -text => "Base Year: ",
                -font => 'default',
                ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($byear_frame = $xaxis_frame->new_frame(
                -borderwidth => 0,
                -relief      => 'flat',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew');
        ($byear_cb = $byear_frame->new_ttk__combobox(
                -textvariable => \$byear,
                -values       => [ reverse($yr_min .. $yr_max) ],
                -state        => 'readonly',
                -width        => 5,
                ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        $byear_cb->g_bind("<<ComboboxSelected>>",
                          sub { if ($byear == $yr_min) {
                                    $yr_min -= 5;
                                    $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                }
                              }
                         );
        $byear_frame->new_label(
                -text   => " for JDAY = 1",
                -anchor => 'w',
                -font   => 'default',
                )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);

        $row++;
        ($xformat_label = $xaxis_frame->new_label(
                -text => "X Ticklabel Format: ",
                -font => 'default',
                ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($xformat_cb = $xaxis_frame->new_ttk__combobox(
                -textvariable => \$xformat,
                -values       => [ @date_axis_choices ],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $xformat_cb->g_bind("<<ComboboxSelected>>",
                  sub { if ($xformat =~ /Year|Mon-DD/) {
                            $xtick_int_sb->configure(-state => ($xmaj_auto) ? 'disabled' : 'normal');
                            $xtick_auto_cb->configure(-state => 'normal');
                        } else {
                            $xtick_int_sb->configure(-state => 'disabled');
                            $xtick_auto_cb->configure(-state => 'disabled');
                        }
                      });

        $row++;
        $xaxis_frame->new_label(
                -text    => "X Axis Minimum: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($xmin_entry = $xaxis_frame->new_entry(
                -textvariable => \$xmin,
                -font         => 'default',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $xmin_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($xmin_entry);
                                                  if ($xmin ne "" && $xmin ne "." && $xmin ne "-") {
                                                      my $tmp = &round_to_int(1000.*$xmin)/1000.;
                                                      $xmin = $tmp if ($xmin != $tmp);
                                                  }
                                                });
        $xmin_entry->g_grid_remove();
        ($xmin_cb = $xaxis_frame->new_ttk__combobox(
                -textvariable => \$xmin,
                -values       => [ @datelist1 ],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $xmin_cb->g_bind("<<ComboboxSelected>>",
                          sub { if (&datelabel2jdate($xmax) - &datelabel2jdate($xmin) > 365 *2) {
                                    if ($#date_axis_choices == 2) {
                                        unshift (@date_axis_choices, "Year");
                                        $xformat_cb->configure(-values => [ @date_axis_choices ]);
                                    }
                                } elsif ($#date_axis_choices == 3) {
                                    shift @date_axis_choices;
                                    $xformat_cb->configure(-values => [ @date_axis_choices ]);
                                    if ($xformat eq "Year") {
                                        $xformat = "Month";
                                        Tkx::event_generate($xformat_cb, "<<ComboboxSelected>>");
                                    }
                                }
                              }
                        );

        $row++;
        $xaxis_frame->new_label(
                -text    => "X Axis Maximum: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($xmax_entry = $xaxis_frame->new_entry(
                -textvariable => \$xmax,
                -font         => 'default',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $xmax_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($xmax_entry);
                                                  if ($xmax ne "" && $xmax ne "." && $xmax ne "-") {
                                                      my $tmp = &round_to_int(1000.*$xmax)/1000.;
                                                      $xmax = $tmp if ($xmax != $tmp);
                                                  }
                                                });
        $xmax_entry->g_grid_remove();
        ($xmax_cb = $xaxis_frame->new_ttk__combobox(
                -textvariable => \$xmax,
                -values       => [ @datelist2 ],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $xmax_cb->g_bind("<<ComboboxSelected>>",
                          sub { if (&datelabel2jdate($xmax) - &datelabel2jdate($xmin) > 365 *2) {
                                    if ($#date_axis_choices == 2) {
                                        unshift (@date_axis_choices, "Year");
                                        $xformat_cb->configure(-values => [ @date_axis_choices ]);
                                    }
                                } elsif ($#date_axis_choices == 3) {
                                    shift @date_axis_choices;
                                    $xformat_cb->configure(-values => [ @date_axis_choices ]);
                                    if ($xformat eq "Year") {
                                        $xformat = "Month";
                                        Tkx::event_generate($xformat_cb, "<<ComboboxSelected>>");
                                    }
                                }
                              }
                        );

        $row++;
        $xaxis_frame->new_label(
                -text    => "X Tick Interval: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($xmajor_entry = $xaxis_frame->new_entry(
                -textvariable => \$xmajor,
                -font         => 'default',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $xmajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($xmajor_entry, 1);
                                                    $xmajor =~ s/^-//;
                                                  });
        $xmajor_entry->g_grid_remove();
        ($xtick_frame = $xaxis_frame->new_frame(
                -borderwidth => 0,
                -relief      => 'flat',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew');
        ($xtick_int_sb = $xtick_frame->new_spinbox(
                -textvariable => \$xmajor,
                -state        => 'normal',
                -font         => 'default',
                -from         => 1,
                -to           => 5000,
                -increment    => 1,
                -width        => 5,
                ))->g_pack(-side => 'left', -anchor => 'w', -pady => 0);
        $xtick_int_sb->g_bind("<KeyRelease>", sub { &numeric_entry_only($xtick_int_sb);
                                                    $xmajor =~ s/^-//;
                                                    $xmajor = 1 if ($xmajor eq "" || $xmajor == 0);
                                                    $xmajor = &round_to_int(abs($xmajor));
                                                  });
        ($xtick_auto_cb = $xtick_frame->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "Auto",
                -font     => 'default',
                -variable => \$xmaj_auto,
                -command  => sub { $xtick_int_sb->configure(-state => ($xmaj_auto) ? 'disabled' : 'normal');
                                 },
                ))->g_pack(-side => 'left', -anchor => 'w', -pady => 0);
        $xtick_auto_cb->configure(-state => ($xformat eq "Month") ? 'disabled' : 'normal');
        $xtick_int_sb->configure(-state => ($xformat eq "Month" || $xmaj_auto) ? 'disabled' : 'normal');

        $row++;
        $xaxis_frame->new_label(
                -text    => "X Primary Ticks: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $xaxis_frame->new_ttk__combobox(
                -textvariable => \$xpr_tics,
                -values       => [ @tic_opts ],
                -state        => 'readonly',
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

        $row++;
        $xaxis_frame->new_label(
                -text    => "X Opposite Ticks: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $xaxis_frame->new_ttk__combobox(
                -textvariable => \$xop_tics,
                -values       => [ @tic_opts ],
                -state        => 'readonly',
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

        if ($props{$id}{meta} =~ /profile_cmap|time_series/) {
            $dateline_ok = 0;
            for ($i=0; $i<=$#animate_ids; $i++) {
                next if ($id == $animate_ids[$i]);
                if ($props{$animate_ids[$i]}{meta}
                       =~ /^(data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)$/) {
                    $dateline_ok = 1;
                    last;
                }
            }
            if ($dateline_ok) {
                $row++;
                $xaxis_frame->new_label(
                        -text    => "Animation Dateline: ",
                        -font    => 'default',
                        )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
                $xaxis_frame->new_checkbutton(
                        -onvalue  => 1,
                        -offvalue => 0,
                        -text     => "Show",
                        -font     => 'default',
                        -variable => \$dateline,
                        -command  => sub { my $status = ($dateline) ? 'normal' : 'disabled';
                                           $datelinec_btn->configure(-state => $status);
                                         },
                        )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
                $code      = &get_rgb_code($datelinec);
                $datelinec = &get_rgb_name($code);
                $fg        = &get_rgb_code("black");
                if ($code =~ /^\#[0-9a-f]/i) {
                    $fg = &get_rgb_code(&get_bw_contrast($code));
                }
                ($datelinec_btn = $xaxis_frame->new_button(
                                -textvariable => \$datelinec,
                                -background   => $code,
                                -foreground   => $fg,
                                -width        => -7,
                                -command => sub { my ($newc, $code, $fg);
                                                  $code = &get_rgb_code($datelinec);
                                                  $newc = Tkx::tk___chooseColor(
                                                             -initialcolor => $code,
                                                             -parent       => $graph_props_menu);
                                                  if ($newc) {
                                                      $code      = &get_rgb_code($newc);
                                                      $datelinec = &get_rgb_name($code);
                                                      $fg        = &get_rgb_code("black");
                                                      if ($code =~ /^#?[0-9a-f]/i) {
                                                          $fg = &get_rgb_code(&get_bw_contrast($code));
                                                      }
                                                      $datelinec_btn->configure(-foreground => $fg,
                                                                                -background => $code);
                                                  }
                                                }
                                ))->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);
                if (! $dateline) {
                    $datelinec_btn->configure(-state => 'disabled');
                }
            }
        }

        $row++;
        ($xtitle_label = $xaxis_frame->new_label(
                -text => "X Axis Title: ",
                -font => 'default',
                ))->g_grid(-row => $row, -column => 0, -sticky => 'w', -pady => 2);
        $row++;
        ($xtitle_entry = $xaxis_frame->new_entry(
                -textvariable => \$xtitle,
                -font         => 'default',
                ))->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew', -pady => 2);

        if ($xaxis_type eq "Date/Time") {
            $xmin_entry->g_grid_remove();
            $xmax_entry->g_grid_remove();
            $xmajor_entry->g_grid_remove();
            $byear_label->g_grid_remove();
            $byear_frame->g_grid_remove();
            $xtitle_label->g_grid_remove();
            $xtitle_entry->g_grid_remove();
            $xformat_label->g_grid();
            $xformat_cb->g_grid();
            $xmin_cb->g_grid();
            $xmax_cb->g_grid();
            $xtick_frame->g_grid();
        } else {
            $xformat_label->g_grid_remove();
            $xformat_cb->g_grid_remove();
            $xmin_cb->g_grid_remove();
            $xmax_cb->g_grid_remove();
            $xtick_frame->g_grid_remove();
            $byear_label->g_grid();
            $byear_frame->g_grid();
            $xmin_entry->g_grid();
            $xmax_entry->g_grid();
            $xmajor_entry->g_grid();
            $xtitle_label->g_grid();
            $xtitle_entry->g_grid();
        }
        $xaxis_frame->g_grid_columnconfigure(0, -weight => 2);

    } else {
        if ($props{$id}{meta} =~ /w2_slice|w2_wlevels|w2_tdmap/) {
            $row++;
            $xaxis_frame->new_label(
                    -text    => "X Axis Base: ",
                    -font    => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($xbase_entry = $xaxis_frame->new_entry(
                    -textvariable => \$xbase,
                    -font         => 'default',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
            $xbase_entry->g_bind("<KeyRelease>",
                                  sub { my ($mult);
                                        &numeric_entry_only($xbase_entry);
                                        if ($xbase ne "" && $xbase ne "." && $xbase ne "-") {
                                            my $tmp = &round_to_int(1000.*$xbase)/1000.;
                                            $xbase = $tmp if ($xbase != $tmp);
                                            if ($xmax_auto) {
                                                $mult = ($xaxis_units eq "miles") ? 3280.84/5280. : 1.0;
                                                if ($props{$id}{meta} =~ /w2_slice|w2_wlevels/) {
                                                    $xmax = $xbase +$gr_props{$id}{x_km} *$mult;
                                                } else {
                                                    $xmax = $xbase +$gr_props{$id}{d_km} *$mult;
                                                }
                                                $xmax = &round_to_int(1000.*$xmax)/1000.;
                                            }
                                        } elsif ($xbase eq "" || $xbase eq ".") {
                                            if ($xmax_auto) {
                                                $mult = ($xaxis_units eq "miles") ? 3280.84/5280. : 1.0;
                                                if ($props{$id}{meta} =~ /w2_slice|w2_wlevels/) {
                                                    $xmax = $gr_props{$id}{x_km} *$mult;
                                                } else {
                                                    $xmax = $gr_props{$id}{d_km} *$mult;
                                                }
                                                $xmax = &round_to_int(1000.*$xmax)/1000.;
                                            }
                                        }
                                      });
        }

        if ($props{$id}{meta} !~ /vert_wd_zone|w2_outflow/) {
            $row++;
            $xaxis_frame->new_label(
                    -text    => "X Axis Minimum: ",
                    -font    => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($xmin_entry = $xaxis_frame->new_entry(
                    -textvariable => \$xmin,
                    -font         => 'default',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
            $xmin_entry->g_bind("<KeyRelease>",
                                 sub { &numeric_entry_only($xmin_entry);
                                       if ($xmin ne "" && $xmin ne "." && $xmin ne "-") {
                                           my $tmp = &round_to_int(1000.*$xmin)/1000.;
                                           $xmin = $tmp if ($xmin != $tmp);
                                           if ($props{$id}{meta} =~ /w2_slice|w2_wlevels|w2_tdmap/) {
                                               if ($xfirst ne "" && $xfirst ne "."
                                                                 && $xfirst ne "-" && $xfirst < $xmin) {
                                                   if (&ceil($xmin) != $xmin) {
                                                       $xfirst = &ceil($xmin);
                                                   } else {
                                                       $xfirst = $xmin;
                                                   }
                                               }
                                           }
                                       }
                                     });
        }

        if ($props{$id}{meta} =~ /w2_slice|w2_wlevels|w2_tdmap/) {
            $row++;
            $xaxis_frame->new_label(
                    -text    => "X Axis First Label: ",
                    -font    => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($xfirst_entry = $xaxis_frame->new_entry(
                    -textvariable => \$xfirst,
                    -font         => 'default',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
            $xfirst_entry->g_bind("<KeyRelease>",
                                   sub { &numeric_entry_only($xfirst_entry);
                                         if ($xfirst ne "" && $xfirst ne "." && $xfirst ne "-") {
                                             my $tmp = &round_to_int(1000.*$xfirst)/1000.;
                                             $xfirst = $tmp if ($xfirst != $tmp);
                                         }
                                       });

            $row++;
            $xaxis_frame->new_label(
                    -text    => "X Axis Maximum: ",
                    -font    => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($xmax_frame = $xaxis_frame->new_frame(
                    -borderwidth => 0,
                    -relief      => 'flat',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew');
            ($xmax_entry = $xmax_frame->new_entry(
                    -textvariable => \$xmax,
                    -font         => 'default',
                    -width        => 10,
                    ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
            $xmax_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($xmax_entry);
                                                      $xmax =~ s/^-//;
                                                      if ($xmax ne "" && $xmax ne ".") {
                                                          my $tmp = &round_to_int(1000.*$xmax)/1000.;
                                                          $xmax = $tmp if ($xmax != $tmp);
                                                      }
                                                    });
            $xmax_frame->new_checkbutton(
                    -onvalue  => 1,
                    -offvalue => 0,
                    -text     => "Auto",
                    -font     => 'default',
                    -variable => \$xmax_auto,
                    -command  => sub { my ($mult);
                                       if ($xmax_auto) {
                                           if ($xbase ne "" && $xbase ne "." && $xbase ne "-") {
                                               $mult = ($xaxis_units eq "miles") ? 3280.84/5280. : 1.0;
                                               if ($props{$id}{meta} =~ /w2_slice|w2_wlevels/) {
                                                   $xmax = $xbase +$gr_props{$id}{x_km} *$mult;
                                               } else {
                                                   $xmax = $xbase +$gr_props{$id}{d_km} *$mult;
                                               }
                                               $xmax = &round_to_int(1000.*$xmax)/1000.;
                                           } elsif ($xbase eq "" || $xbase eq ".") {
                                               $mult = ($xaxis_units eq "miles") ? 3280.84/5280. : 1.0;
                                               if ($props{$id}{meta} =~ /w2_slice|w2_wlevels/) {
                                                   $xmax = $gr_props{$id}{x_km} *$mult;
                                               } else {
                                                   $xmax = $gr_props{$id}{d_km} *$mult;
                                               }
                                               $xmax = &round_to_int(1000.*$xmax)/1000.;
                                           }
                                           $xmax_entry->configure(-state => 'disabled');
                                       } else {
                                           $xmax_entry->configure(-state => 'normal');
                                       }
                                     }
                    )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
            $xmax_entry->configure(-state => ($xmax_auto) ? 'disabled' : 'normal');

        } else {
            $row++;
            $xaxis_frame->new_label(
                    -text    => "X Axis Maximum: ",
                    -font    => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($xmax_entry = $xaxis_frame->new_entry(
                    -textvariable => \$xmax,
                    -font         => 'default',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
            $xmax_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($xmax_entry);
                                                      if ($props{$id}{meta} =~ /vert_wd_zone|w2_outflow/) {
                                                          $xmax =~ s/^-//;
                                                      }
                                                      if ($xmax ne "" && $xmax ne "." && $xmax ne "-") {
                                                          my $tmp = &round_to_int(1000.*$xmax)/1000.;
                                                          $xmax = $tmp if ($xmax != $tmp);
                                                      }
                                                    });
        }

        $row++;
        $xaxis_frame->new_label(
                -text    => "X Tick Interval: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($xmajor_entry = $xaxis_frame->new_entry(
                -textvariable => \$xmajor,
                -font         => 'default',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $xmajor_entry->g_bind("<KeyRelease>",
                               sub { &numeric_entry_only($xmajor_entry, 1);
                                     if ($props{$id}{meta}
                                             =~ /w2_slice|w2_wlevels|w2_tdmap|vert_wd_zone|w2_outflow/) {
                                         $xmajor =~ s/^-//;
                                     }
                                   });

        $row++;
        $xaxis_frame->new_label(
                -text    => "X Primary Ticks: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $xaxis_frame->new_ttk__combobox(
                -textvariable => \$xpr_tics,
                -values       => [ @tic_opts ],
                -state        => 'readonly',
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

        $row++;
        $xaxis_frame->new_label(
                -text    => "X Opposite Ticks: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $xaxis_frame->new_ttk__combobox(
                -textvariable => \$xop_tics,
                -values       => [ @tic_opts ],
                -state        => 'readonly',
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

        if ($props{$id}{meta} =~ /vert_wd_zone|w2_outflow/) {
            $row++;
            $xaxis_frame->new_label(
                    -text => "X Axis Units: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($xunits_cb = $xaxis_frame->new_ttk__combobox(
                    -textvariable => \$qaxis_units,
                    -values       => [ ("cfs/ft", "cms/m", "ft/s", "m/s") ],
                    -state        => 'readonly',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
            $xunits_cb->g_bind("<<ComboboxSelected>>",
                                sub { if ($qaxis_units eq "cfs/ft") {
                                          $xtitle = "Release Rate, in cfs/(vert. ft)";
                                      } elsif ($qaxis_units eq "cms/m") {
                                          $xtitle = "Release Rate, in cms/(vert. m)";
                                      } elsif ($qaxis_units eq "ft/s") {
                                          $xtitle = "Velocity, in ft/s";
                                      } else {
                                          $xtitle = "Velocity, in m/s";
                                      }
                                    });

        } elsif ($props{$id}{meta} =~ /w2_slice|w2_wlevels|w2_tdmap/) {
            $row++;
            $xaxis_frame->new_label(
                    -text => "X Axis Units: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($xunits_frame = $xaxis_frame->new_frame(
                    -borderwidth => 0,
                    -relief      => 'flat',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew');
            ($xunits_cb = $xunits_frame->new_ttk__combobox(
                    -textvariable => \$xaxis_units,
                    -values       => [ ("miles", "kilometers") ],
                    -state        => 'readonly',
                    -width        => 10,
                    ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
            $xunits_cb->g_bind("<<ComboboxSelected>>",
                                sub { return if ($xaxis_units eq $old_xunits);
                                      if ($xaxis_units eq "miles") {
                                          if ($xbase ne "" && $xbase ne "." && $xbase ne "-") {
                                              $xbase *= 3280.84/5280.;
                                              $xbase = &round_to_int(1000.*$xbase)/1000.;
                                          }
                                          if ($xmin ne "" && $xmin ne "." && $xmin ne "-") {
                                              $xmin *= 3280.84/5280.;
                                              $xmin = &round_to_int(1000.*$xmin)/1000.;
                                          }
                                          if ($xfirst ne "" && $xfirst ne "." && $xfirst ne "-") {
                                              $xfirst *= 3280.84/5280.;
                                              $xfirst = &round_to_int(1000.*$xfirst)/1000.;
                                          }
                                          if ($xmax ne "" && $xmax ne "." && $xmax ne "-") {
                                              $xmax *= 3280.84/5280.;
                                              $xmax = &round_to_int(1000.*$xmax)/1000.;
                                          }
                                          $xtitle =~ s/kilometer/mile/;
                                          $xtitle =~ s/Kilometer/Mile/;
                                          $xtitle =~ s/KILOMETER/MILE/;
                                      } else {
                                          if ($xbase ne "" && $xbase ne "." && $xbase ne "-") {
                                              $xbase *= 5280./3280.84;
                                              $xbase = &round_to_int(1000.*$xbase)/1000.;
                                          }
                                          if ($xmin ne "" && $xmin ne "." && $xmin ne "-") {
                                              $xmin *= 5280./3280.84;
                                              $xmin = &round_to_int(1000.*$xmin)/1000.;
                                          }
                                          if ($xfirst ne "" && $xfirst ne "." && $xfirst ne "-") {
                                              $xfirst *= 5280./3280.84;
                                              $xfirst = &round_to_int(1000.*$xfirst)/1000.;
                                          }
                                          if ($xmax ne "" && $xmax ne "." && $xmax ne "-") {
                                              $xmax *= 5280./3280.84;
                                              $xmax = &round_to_int(1000.*$xmax)/1000.;
                                          }
                                          $xtitle =~ s/mile/kilometer/;
                                          $xtitle =~ s/Mile/Kilometer/;
                                          $xtitle =~ s/MILE/KILOMETER/;
                                      }
                                      $old_xunits = $xaxis_units;
                                    });
            $xunits_frame->new_checkbutton(
                    -onvalue  => 1,
                    -offvalue => 0,
                    -text     => "Flip?",
                    -font     => 'default',
                    -variable => \$xaxis_flip,
                    )->g_pack(-side => 'left', -anchor => 'w');

        } elsif (($props{$id}{meta} eq "data_profile" || $props{$id}{meta} eq "w2_profile")
                  && $props{$id}{parm} eq "Temperature") {
            $row++;
            $xaxis_frame->new_label(
                    -text => "X Axis Units: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($wt_units_cb = $xaxis_frame->new_ttk__combobox(
                    -textvariable => \$wt_units,
                    -values       => [ ("Celsius", "Fahrenheit") ],
                    -state        => 'readonly',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
            $wt_units_cb->g_bind("<<ComboboxSelected>>",
                                 sub { my ($diff);
                                       if ($props{$id}{meta} eq "data_profile"
                                            && $props{$id}{prof_type} eq "difference") {
                                           $diff = 0;
                                       } else {
                                           $diff = 32;
                                       }
                                       if ($wt_units eq "Celsius"
                                            && $wt_oldunits eq "Fahrenheit") {
                                           $xtitle   =~ s/Fahrenheit/Celsius/;
                                           $keytitle =~ s/Fahrenheit/Celsius/;
                                           if ($xmin ne "" && $xmin ne "." && $xmin ne "-") {
                                               $xmin = &floor(($xmin -$diff) /1.8);
                                           }
                                           if ($xmax ne "" && $xmax ne "." && $xmax ne "-") {
                                               $xmax = &ceil(($xmax -$diff) /1.8);
                                           }
                                           if ($xmajor ne "" && $xmajor ne "." && $xmajor ne "-") {
                                               $xmajor = &round_to_int($xmajor /1.8);
                                           }
                                           if ($cs_min ne "" && $cs_min ne "." && $cs_min ne "-") {
                                               $cs_min = &floor(($cs_min -$diff) /1.8);
                                           }
                                           if ($cs_max ne "" && $cs_max ne "." && $cs_max ne "-") {
                                               $cs_max = &ceil(($cs_max -$diff) /1.8);
                                           }
                                           if ($cs_major ne "" && $cs_major ne "." && $cs_major ne "auto") {
                                               $cs_major = sprintf("%.4f", $cs_major/1.8);
                                               $cs_major =~ s/0+$//;
                                           }
                                       } elsif ($wt_units eq "Fahrenheit"
                                            && $wt_oldunits eq "Celsius") {
                                           $xtitle   =~ s/Celsius/Fahrenheit/;
                                           $keytitle =~ s/Celsius/Fahrenheit/;
                                           if ($xmin ne "" && $xmin ne "." && $xmin ne "-") {
                                               $xmin = &floor($xmin *1.8 +$diff);
                                           }
                                           if ($xmax ne "" && $xmax ne "." && $xmax ne "-") {
                                               $xmax = &ceil($xmax *1.8 +$diff);
                                           }
                                           if ($xmajor ne "" && $xmajor ne "." && $xmajor ne "-") {
                                               $xmajor = &round_to_int($xmajor *1.8);
                                           }
                                           if ($cs_min ne "" && $cs_min ne "." && $cs_min ne "-") {
                                               $cs_min = &floor($cs_min *1.8 +$diff);
                                           }
                                           if ($cs_max ne "" && $cs_max ne "." && $cs_max ne "-") {
                                               $cs_max = &ceil($cs_max *1.8 +$diff);
                                           }
                                           if ($cs_major ne "" && $cs_major ne "." && $cs_major ne "auto") {
                                               $cs_major = sprintf("%.4f", $cs_major*1.8);
                                               $cs_major =~ s/0+$//;
                                           }
                                       }
                                       $wt_oldunits = $wt_units;
                                     });
        }

        if ($props{$id}{meta} =~ /w2_slice|w2_wlevels|w2_tdmap/) {
            $row++;
            ($xtitle_frame = $xaxis_frame->new_frame(
                    -borderwidth => 0,
                    -relief      => 'flat',
                    ))->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew');
            $xtitle_frame->new_label(
                    -text => "X Axis Title: ",
                    -font => 'default',
                    )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
            $xtitle_frame->new_entry(
                    -textvariable => \$xtitle,
                    -font         => 'default',
                    )->g_pack(-side => 'left', -anchor => 'w', -expand => 1, -fill => 'x', -pady => 2);
        } else {
            $row++;
            $xaxis_frame->new_label(
                    -text => "X Axis Title: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'w', -pady => 2);
            $row++;
            $xaxis_frame->new_entry(
                    -textvariable => \$xtitle,
                    -font         => 'default',
                    )->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew', -pady => 2);
        }
    }
    $xaxis_frame->g_grid_columnconfigure(0, -weight => 2);

#   Y axis tab
    $yaxis_tab = $grprops_notebook->new_frame();
    $grprops_notebook->add($yaxis_tab,
            -text      => "Y Axis",
            -underline => 0,
            -sticky    => 'nsew',
            );

    $preview_yaxis_txt = $yaxis_tab->new_canvas(
            -background  => &get_rgb_code($canvas_color),
            -width       => $pw,
            -height      => $ph,
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $preview_yaxis_txt->g_grid(-row => 0, -column => 0, -sticky => 'wne');

    $ytitle_txt = $preview_yaxis_txt->create_text($pw*0.3 +3, $ph*0.5 +3,
            -anchor => 'center', 
            -text   => "Axis Title",
            -fill   => "#000000",
            -angle  => 0,
            -font   => [-family     => $yfont,
                        -size       => $yt_size,
                        -weight     => $yt_weight,
                        -slant      => 'roman',
                        -underline  => 0,
                        -overstrike => 0,
                       ]);
    $yticklabel_txt = $preview_yaxis_txt->create_text($pw*0.7 +3, $ph*0.5 +3,
            -anchor => 'center', 
            -text   => "Tick Label",
            -fill   => "#000000",
            -angle  => 0,
            -font   => [-family     => $yfont,
                        -size       => $yl_size,
                        -weight     => $yl_weight,
                        -slant      => 'roman',
                        -underline  => 0,
                        -overstrike => 0,
                       ]);

    $yaxis_frame = $yaxis_tab->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $yaxis_frame->g_grid(-row => 1, -column => 0, -sticky => 'wnes');

    $row = 0;
    $yaxis_frame->new_label(
            -text => "Y Axis Font: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($yfont_cb = $yaxis_frame->new_ttk__combobox(
            -textvariable => \$yfont,
            -values       => [ sort @available_fonts ],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
    $yfont_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_yaxis_txt->itemconfigure($ytitle_txt,
                          -font => [ -family     => $yfont,
                                     -size       => $yt_size,
                                     -weight     => $yt_weight,
                                     -slant      => 'roman',
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                    $preview_yaxis_txt->itemconfigure($yticklabel_txt,
                          -font => [ -family     => $yfont,
                                     -size       => $yl_size,
                                     -weight     => $yl_weight,
                                     -slant      => 'roman',
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                  });
    $row++;
    $yaxis_frame->new_label(
            -text => "Y Title/Label Size: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($yt_size_cb = $yaxis_frame->new_ttk__combobox(
            -textvariable => \$yt_size,
            -values       => [(5 .. 24)],
            -width        => 5,
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
    $yt_size_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_yaxis_txt->itemconfigure($ytitle_txt,
                          -font => [ -family     => $yfont,
                                     -size       => $yt_size,
                                     -weight     => $yt_weight,
                                     -slant      => 'roman',
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                  });
    ($yl_size_cb = $yaxis_frame->new_ttk__combobox(
            -textvariable => \$yl_size,
            -values       => [(5 .. 24)],
            -width        => 5,
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 2, -sticky => 'ew', -pady => 2);
    $yl_size_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_yaxis_txt->itemconfigure($yticklabel_txt,
                          -font => [ -family     => $yfont,
                                     -size       => $yl_size,
                                     -weight     => $yl_weight,
                                     -slant      => 'roman',
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                  });
    $row++;
    $yaxis_frame->new_label(
            -text => "Y Title/Label Weight: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($yt_weight_cb = $yaxis_frame->new_ttk__combobox(
            -textvariable => \$yt_weight,
            -values       => [("normal", "bold")],
            -state        => 'readonly',
            -width        => 5,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
    $yt_weight_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_yaxis_txt->itemconfigure($ytitle_txt,
                          -font => [ -family     => $yfont,
                                     -size       => $yt_size,
                                     -weight     => $yt_weight,
                                     -slant      => 'roman',
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                  });
    ($yl_weight_cb = $yaxis_frame->new_ttk__combobox(
            -textvariable => \$yl_weight,
            -values       => [("normal", "bold")],
            -state        => 'readonly',
            -width        => 5,
            ))->g_grid(-row => $row, -column => 2, -sticky => 'ew', -pady => 2);
    $yl_weight_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_yaxis_txt->itemconfigure($yticklabel_txt,
                          -font => [ -family     => $yfont,
                                     -size       => $yl_size,
                                     -weight     => $yl_weight,
                                     -slant      => 'roman',
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                  });

    if ($props{$id}{meta} =~ /data_profile|w2_profile|w2_slice|w2_outflow|vert_wd_zone/) {
        $row++;
        $yaxis_frame->new_label(
                -text => "Y Axis Type: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($yaxis_type_cb = $yaxis_frame->new_ttk__combobox(
                -textvariable => \$yaxis_type,
                -values       => [ ("Elevation", "Depth") ],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $yaxis_type_cb->g_bind("<<ComboboxSelected>>",
                               sub { return if ($yaxis_type eq $old_yaxis_type);
                                     if ($yaxis_type eq "Elevation") {
                                         $ymin_label->g_grid();
                                         $ymin_entry->g_grid();
                                         $ymax_label->configure(-text => "Elevation Max: ");
                                         $ymajor_label->configure(-text => "Elevation Major: ");
                                         $yaxis_units_label->configure(-text => "Elevation Units: ");
                                         if ($elev_base != -999 && $ymax ne "") {
                                             $ymin  = $elev_base;
                                             $ymax += $elev_base;
                                         } else {
                                             $ymin = "";
                                         }
                                         $ytitle =~ s/Depth/Elevation/;
                                         $ytitle =~ s/depth/elevation/;
                                         $ytitle =~ s/DEPTH/ELEVATION/;
                                     } else {
                                         $ymin_label->g_grid_remove();
                                         $ymin_entry->g_grid_remove();
                                         $ymax_label->configure(-text => "Depth Max: ");
                                         $ymajor_label->configure(-text => "Depth Major: ");
                                         $yaxis_units_label->configure(-text => "Depth Units: ");
                                         if ($ymax ne "" && $ymin ne "" && $ymax -$ymin != 0) {
                                             $elev_base = &min($ymin, $ymax);
                                             $ymax      = abs($ymax -$ymin);
                                         } else {
                                             $ymax = "";
                                         }
                                         $ymin   = 0;
                                         $ytitle =~ s/Elevation/Depth/;
                                         $ytitle =~ s/elevation/depth/;
                                         $ytitle =~ s/ELEVATION/DEPTH/;
                                     }
                                     $old_yaxis_type = $yaxis_type;
                                   }
                              );
    }

    if ($props{$id}{meta} ne "w2_tdmap") {
        $row++;
        ($ymin_label = $yaxis_frame->new_label(
                -text    => "Y Axis Minimum: ",
                -font    => 'default',
                ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($ymin_entry = $yaxis_frame->new_entry(
                -textvariable => \$ymin,
                -font         => 'default',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $ymin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $ymin_entry ]);

        $row++;
        ($ymax_label = $yaxis_frame->new_label(
                -text    => "Y Axis Maximum: ",
                -font    => 'default',
                ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($ymax_entry = $yaxis_frame->new_entry(
                -textvariable => \$ymax,
                -font         => 'default',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $ymax_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($ymax_entry);
                                                  $ymax =~ s/^-// if ($yaxis_type eq "Depth");
                                                });

        $row++;
        ($ymajor_label = $yaxis_frame->new_label(
                -text    => "Y Tick Interval: ",
                -font    => 'default',
                ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($ymajor_entry = $yaxis_frame->new_entry(
                -textvariable => \$ymajor,
                -font         => 'default',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $ymajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($ymajor_entry, 1);
                                                    $ymajor =~ s/^-//;
                                                  });

        $row++;
        $yaxis_frame->new_label(
                -text    => "Y Primary Ticks: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $yaxis_frame->new_ttk__combobox(
                -textvariable => \$ypr_tics,
                -values       => [ @tic_opts ],
                -state        => 'readonly',
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

        $row++;
        $yaxis_frame->new_label(
                -text    => "Y Opposite Ticks: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $yaxis_frame->new_ttk__combobox(
                -textvariable => \$yop_tics,
                -values       => [ @tic_opts ],
                -state        => 'readonly',
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

        if ($props{$id}{meta} =~ /data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone/) {
            $row++;
            ($yaxis_units_label = $yaxis_frame->new_label(
                    -text => "Elevation Units: ",
                    -font => 'default',
                    ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($yaxis_units_cb = $yaxis_frame->new_ttk__combobox(
                    -textvariable => \$yaxis_units,
                    -values       => [ ("feet", "meters") ],
                    -state        => 'readonly',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
            $yaxis_units_cb->g_bind("<<ComboboxSelected>>",
                                     sub { if ($yaxis_units eq "feet") {
                                               $ytitle =~ s/meters/feet/;
                                               $ytitle =~ s/Meters/Feet/;
                                               $ytitle =~ s/METERS/FEET/;
                                           } else {
                                               $ytitle =~ s/feet/meters/;
                                               $ytitle =~ s/Feet/Meters/;
                                               $ytitle =~ s/FEET/METERS/;
                                           }
                                         });

            $ymin_label->configure(-text => "Elevation Min: ");
            if ($yaxis_type eq "Elevation") {
                $ymax_label->configure(-text => "Elevation Max: ");
                $ymajor_label->configure(-text => "Elevation Major: ");
                $yaxis_units_label->configure(-text => "Elevation Units: ");
            } else {
                $ymin_label->g_grid_remove();
                $ymin_entry->g_grid_remove();
                $ymax_label->configure(-text => "Depth Max: ");
                $ymajor_label->configure(-text => "Depth Major: ");
                $yaxis_units_label->configure(-text => "Depth Units: ");
            }
        }

        $row++;
        $yaxis_frame->new_label(
                -text    => "Y Axis Title: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'w', -pady => 2);
        $row++;
        $yaxis_frame->new_entry(
                -textvariable => \$ytitle,
                -font         => 'default',
                )->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew', -pady => 2);

        $yaxis_frame->g_grid_columnconfigure(0, -weight => 2);

    } else {                                      # w2_tdmap
        if ($gr_props{$id}{date_axis} eq "Y") {
            $row++;
            $yaxis_frame->new_label(
                    -text => "Y Axis Type: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($ytype_frame = $yaxis_frame->new_frame(
                    -borderwidth => 0,
                    -relief      => 'flat',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew');
            ($yaxis_type_cb = $ytype_frame->new_ttk__combobox(
                    -textvariable => \$yaxis_type,
                    -values       => [ ("Date/Time", "Julian Date") ],
                    -state        => 'readonly',
                    -width        => 11,
                    ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
            $yaxis_type_cb->g_bind("<<ComboboxSelected>>",
                                    sub { my ($base_jd);
                                          return if ($yaxis_type eq $ytype_old);
                                          $ytype_old = $yaxis_type;
                                          $base_jd   = &date2jdate(sprintf("%04d%02d%02d", $byear, 1, 1));
                                          if ($yaxis_type eq "Date/Time") {
                                              $ymin_entry->g_grid_remove();
                                              $ymax_entry->g_grid_remove();
                                              $ymajor_entry->g_grid_remove();
                                              $byear_label->g_grid_remove();
                                              $byear_frame->g_grid_remove();
                                              $ytitle_label->g_grid_remove();
                                              $ytitle_entry->g_grid_remove();
                                              $yformat_label->g_grid();
                                              $yformat_cb->g_grid();
                                              $ymin_cb->g_grid();
                                              $ymax_cb->g_grid();
                                              $ytick_frame->g_grid();

                                              $ymajor = &max(1, &min(500, &round_to_int($ymajor)));
                                              $ymin  += $base_jd -1;
                                              $ymax  += $base_jd -1;
                                              if ($ymin >= $jd_min && $ymin <= $jd_max) {
                                                  $ymin = &jdate2datelabel($ymin, "Mon-DD-YYYY");
                                              } else {
                                                  $ymin = $datelist1[0];
                                              }
                                              if ($ymax >= $jd_min && $ymax <= $jd_max) {
                                                  $ymax = &jdate2datelabel($ymax, "Mon-DD-YYYY");
                                              } else {
                                                  $ymax = $datelist2[$#datelist2];
                                              }
                                              if (&datelabel2jdate($ymax) - &datelabel2jdate($ymin) >365*2) {
                                                  if ($#date_axis_choices == 2) {
                                                      unshift (@date_axis_choices, "Year");
                                                      $yformat_cb->configure(-values=>[ @date_axis_choices ]);
                                                  }
                                              } elsif ($#date_axis_choices == 3) {
                                                  shift @date_axis_choices;
                                                  $yformat_cb->configure(-values => [ @date_axis_choices ]);
                                                  if ($yformat eq "Year") {
                                                      $yformat = "Month";
                                                      Tkx::event_generate($yformat_cb,"<<ComboboxSelected>>");
                                                  }
                                              }
                                          } else {
                                              $yformat_label->g_grid_remove();
                                              $yformat_cb->g_grid_remove();
                                              $ymin_cb->g_grid_remove();
                                              $ymax_cb->g_grid_remove();
                                              $ytick_frame->g_grid_remove();
                                              $byear_label->g_grid();
                                              $byear_frame->g_grid();
                                              $ymin_entry->g_grid();
                                              $ymax_entry->g_grid();
                                              $ymajor_entry->g_grid();
                                              $ytitle_label->g_grid();
                                              $ytitle_entry->g_grid();

                                              $ymin = &datelabel2jdate($ymin) -$base_jd +1;
                                              $ymax = &datelabel2jdate($ymax) -$base_jd +1;
                                              if ($ymin < 1 || $ymax <= $ymin || $ymax <= 1) {
                                                  if ($ytype_sav eq "Date/Time") {
                                                      $ymin = 1 if ($ymin < 1);
                                                      if ($ymax <= $ymin || $ymax <= 1) {
                                                          $ymax = ($ymin < 366) ? 366 : $ymin +365;
                                                      }
                                                  } else {
                                                      $ymin = $gr_props{$id}{ymin};
                                                      $ymax = $gr_props{$id}{ymax};
                                                  }
                                              }
                                          }
                                        });
            $ytype_frame->new_checkbutton(
                    -onvalue  => 1,
                    -offvalue => 0,
                    -text     => "Flip?",
                    -font     => 'default',
                    -variable => \$yaxis_flip,
                    )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);

            $row++;
            ($byear_label = $yaxis_frame->new_label(
                    -text => "Base Year: ",
                    -font => 'default',
                    ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($byear_frame = $yaxis_frame->new_frame(
                    -borderwidth => 0,
                    -relief      => 'flat',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew');
            ($byear_cb = $byear_frame->new_ttk__combobox(
                    -textvariable => \$byear,
                    -values       => [ reverse($yr_min .. $yr_max) ],
                    -state        => 'readonly',
                    -width        => 5,
                    ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
            $byear_cb->g_bind("<<ComboboxSelected>>",
                              sub { if ($byear == $yr_min) {
                                        $yr_min -= 5;
                                        $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                    }
                                  }
                             );
            $byear_frame->new_label(
                    -text   => " for JDAY = 1",
                    -anchor => 'w',
                    -font   => 'default',
                    )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);

            $row++;
            ($yformat_label = $yaxis_frame->new_label(
                    -text => "Y Ticklabel Format: ",
                    -font => 'default',
                    ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($yformat_cb = $yaxis_frame->new_ttk__combobox(
                    -textvariable => \$yformat,
                    -values       => [ @date_axis_choices ],
                    -state        => 'readonly',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
            $yformat_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($yformat =~ /Year|Mon-DD/) {
                                $ytick_int_sb->configure(-state => ($ymaj_auto) ? 'disabled' : 'normal');
                                $ytick_auto_cb->configure(-state => 'normal');
                            } else {
                                $ytick_int_sb->configure(-state => 'disabled');
                                $ytick_auto_cb->configure(-state => 'disabled');
                            }
                          });

            $row++;
            $yaxis_frame->new_label(
                    -text    => "Y Axis Minimum: ",
                    -font    => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($ymin_entry = $yaxis_frame->new_entry(
                    -textvariable => \$ymin,
                    -font         => 'default',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
            $ymin_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($ymin_entry);
                                                      if ($ymin ne "" && $ymin ne "." && $ymin ne "-") {
                                                          my $tmp = &round_to_int(1000.*$ymin)/1000.;
                                                          $ymin = $tmp if ($ymin != $tmp);
                                                      }
                                                    });
            $ymin_entry->g_grid_remove();
            ($ymin_cb = $yaxis_frame->new_ttk__combobox(
                    -textvariable => \$ymin,
                    -values       => [ @datelist1 ],
                    -state        => 'readonly',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
            $ymin_cb->g_bind("<<ComboboxSelected>>",
                              sub { if (&datelabel2jdate($ymax) - &datelabel2jdate($ymin) > 365 *2) {
                                        if ($#date_axis_choices == 2) {
                                            unshift (@date_axis_choices, "Year");
                                            $yformat_cb->configure(-values => [ @date_axis_choices ]);
                                        }
                                    } elsif ($#date_axis_choices == 3) {
                                        shift @date_axis_choices;
                                        $yformat_cb->configure(-values => [ @date_axis_choices ]);
                                        if ($yformat eq "Year") {
                                            $yformat = "Month";
                                            Tkx::event_generate($yformat_cb, "<<ComboboxSelected>>");
                                        }
                                    }
                                  }
                            );

            $row++;
            $yaxis_frame->new_label(
                    -text    => "Y Axis Maximum: ",
                    -font    => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($ymax_entry = $yaxis_frame->new_entry(
                    -textvariable => \$ymax,
                    -font         => 'default',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
            $ymax_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($ymax_entry);
                                                      if ($ymax ne "" && $ymax ne "." && $ymax ne "-") {
                                                          my $tmp = &round_to_int(1000.*$ymax)/1000.;
                                                          $ymax = $tmp if ($ymax != $tmp);
                                                      }
                                                    });
            $ymax_entry->g_grid_remove();
            ($ymax_cb = $yaxis_frame->new_ttk__combobox(
                    -textvariable => \$ymax,
                    -values       => [ @datelist2 ],
                    -state        => 'readonly',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
            $ymax_cb->g_bind("<<ComboboxSelected>>",
                              sub { if (&datelabel2jdate($ymax) - &datelabel2jdate($ymin) > 365 *2) {
                                        if ($#date_axis_choices == 2) {
                                            unshift (@date_axis_choices, "Year");
                                            $yformat_cb->configure(-values => [ @date_axis_choices ]);
                                        }
                                    } elsif ($#date_axis_choices == 3) {
                                        shift @date_axis_choices;
                                        $yformat_cb->configure(-values => [ @date_axis_choices ]);
                                        if ($yformat eq "Year") {
                                            $yformat = "Month";
                                            Tkx::event_generate($yformat_cb, "<<ComboboxSelected>>");
                                        }
                                    }
                                  }
                            );

            $row++;
            $yaxis_frame->new_label(
                    -text    => "Y Tick Interval: ",
                    -font    => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($ymajor_entry = $yaxis_frame->new_entry(
                    -textvariable => \$ymajor,
                    -font         => 'default',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
            $ymajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($ymajor_entry, 1);
                                                        $ymajor =~ s/^-//;
                                                  });
            $ymajor_entry->g_grid_remove();
            ($ytick_frame = $yaxis_frame->new_frame(
                    -borderwidth => 0,
                    -relief      => 'flat',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew');
            ($ytick_int_sb = $ytick_frame->new_spinbox(
                    -textvariable => \$ymajor,
                    -state        => 'normal',
                    -font         => 'default',
                    -from         => 1,
                    -to           => 5000,
                    -increment    => 1,
                    -width        => 5,
                    ))->g_pack(-side => 'left', -anchor => 'w', -pady => 0);
            $ytick_int_sb->g_bind("<KeyRelease>", sub { &numeric_entry_only($ytick_int_sb);
                                                        $ymajor =~ s/^-//;
                                                        $ymajor = 1 if ($ymajor eq "" || $ymajor == 0);
                                                        $ymajor = &round_to_int(abs($ymajor));
                                                      });
            ($ytick_auto_cb = $ytick_frame->new_checkbutton(
                    -onvalue  => 1,
                    -offvalue => 0,
                    -text     => "Auto",
                    -font     => 'default',
                    -variable => \$ymaj_auto,
                    -command  => sub { $ytick_int_sb->configure(-state => ($ymaj_auto) ? 'disabled':'normal');
                                     },
                    ))->g_pack(-side => 'left', -anchor => 'w', -pady => 0);
            $ytick_auto_cb->configure(-state => ($yformat eq "Month") ? 'disabled' : 'normal');
            $ytick_int_sb->configure(-state => ($yformat eq "Month" || $ymaj_auto) ? 'disabled' : 'normal');

            $row++;
            $yaxis_frame->new_label(
                    -text    => "Y Primary Ticks: ",
                    -font    => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            $yaxis_frame->new_ttk__combobox(
                    -textvariable => \$ypr_tics,
                    -values       => [ @tic_opts ],
                    -state        => 'readonly',
                    )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

            $row++;
            $yaxis_frame->new_label(
                    -text    => "Y Opposite Ticks: ",
                    -font    => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            $yaxis_frame->new_ttk__combobox(
                    -textvariable => \$yop_tics,
                    -values       => [ @tic_opts ],
                    -state        => 'readonly',
                    )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

            $row++;
            ($ytitle_label = $yaxis_frame->new_label(
                    -text => "Y Axis Title: ",
                    -font => 'default',
                    ))->g_grid(-row => $row, -column => 0, -sticky => 'w', -pady => 2);
            $row++;
            ($ytitle_entry = $yaxis_frame->new_entry(
                    -textvariable => \$ytitle,
                    -font         => 'default',
                    ))->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew', -pady => 2);

            if ($yaxis_type eq "Date/Time") {
                $ymin_entry->g_grid_remove();
                $ymax_entry->g_grid_remove();
                $ymajor_entry->g_grid_remove();
                $byear_label->g_grid_remove();
                $byear_frame->g_grid_remove();
                $ytitle_label->g_grid_remove();
                $ytitle_entry->g_grid_remove();
                $yformat_label->g_grid();
                $yformat_cb->g_grid();
                $ymin_cb->g_grid();
                $ymax_cb->g_grid();
                $ytick_frame->g_grid();
            } else {
                $yformat_label->g_grid_remove();
                $yformat_cb->g_grid_remove();
                $ymin_cb->g_grid_remove();
                $ymax_cb->g_grid_remove();
                $ytick_frame->g_grid_remove();
                $byear_label->g_grid();
                $byear_frame->g_grid();
                $ymin_entry->g_grid();
                $ymax_entry->g_grid();
                $ymajor_entry->g_grid();
                $ytitle_label->g_grid();
                $ytitle_entry->g_grid();
            }
            $yaxis_frame->g_grid_columnconfigure(2, -weight => 2);

        } else {
            $row++;
            $yaxis_frame->new_label(
                    -text    => "Y Axis Base: ",
                    -font    => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($ybase_entry = $yaxis_frame->new_entry(
                    -textvariable => \$ybase,
                    -font         => 'default',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
            $ybase_entry->g_bind("<KeyRelease>",
                                  sub { my ($mult);
                                        &numeric_entry_only($ybase_entry);
                                        if ($ybase ne "" && $ybase ne "." && $ybase ne "-") {
                                            my $tmp = &round_to_int(1000.*$ybase)/1000.;
                                            $ybase = $tmp if ($ybase != $tmp);
                                            if ($ymax_auto) {
                                                $mult = ($yaxis_units eq "miles") ? 3280.84/5280. : 1.0;
                                                $ymax = $ybase +$gr_props{$id}{d_km} *$mult;
                                                $ymax = &round_to_int(1000.*$ymax)/1000.;
                                            }
                                        } elsif ($ybase eq "" || $ybase eq ".") {
                                            if ($ymax_auto) {
                                                $mult = ($yaxis_units eq "miles") ? 3280.84/5280. : 1.0;
                                                $ymax = $gr_props{$id}{d_km} *$mult;
                                                $ymax = &round_to_int(1000.*$ymax)/1000.;
                                            }
                                        }
                                      });

            $row++;
            $yaxis_frame->new_label(
                    -text    => "Y Axis Minimum: ",
                    -font    => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($ymin_entry = $yaxis_frame->new_entry(
                    -textvariable => \$ymin,
                    -font         => 'default',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
            $ymin_entry->g_bind("<KeyRelease>",
                                 sub { &numeric_entry_only($ymin_entry);
                                       if ($ymin ne "" && $ymin ne "." && $ymin ne "-") {
                                           my $tmp = &round_to_int(1000.*$ymin)/1000.;
                                           $ymin = $tmp if ($ymin != $tmp);
                                           if ($yfirst ne "" && $yfirst ne "."
                                                             && $yfirst ne "-" && $yfirst < $ymin) {
                                               if (&ceil($ymin) != $ymin) {
                                                   $yfirst = &ceil($ymin);
                                               } else {
                                                   $yfirst = $ymin;
                                               }
                                           }
                                       }
                                     });

            $row++;
            $yaxis_frame->new_label(
                    -text    => "Y Axis First Label: ",
                    -font    => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($yfirst_entry = $yaxis_frame->new_entry(
                    -textvariable => \$yfirst,
                    -font         => 'default',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
            $yfirst_entry->g_bind("<KeyRelease>",
                                   sub { &numeric_entry_only($yfirst_entry);
                                         if ($yfirst ne "" && $yfirst ne "." && $yfirst ne "-") {
                                             my $tmp = &round_to_int(1000.*$yfirst)/1000.;
                                             $yfirst = $tmp if ($yfirst != $tmp);
                                         }
                                       });

            $row++;
            $yaxis_frame->new_label(
                    -text    => "Y Axis Maximum: ",
                    -font    => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($ymax_frame = $yaxis_frame->new_frame(
                    -borderwidth => 0,
                    -relief      => 'flat',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew');
            ($ymax_entry = $ymax_frame->new_entry(
                    -textvariable => \$ymax,
                    -font         => 'default',
                    -width        => 10,
                    ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
            $ymax_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($ymax_entry);
                                                      $ymax =~ s/^-//;
                                                      if ($ymax ne "" && $ymax ne ".") {
                                                          my $tmp = &round_to_int(1000.*$ymax)/1000.;
                                                          $ymax = $tmp if ($ymax != $tmp);
                                                      }
                                                    });
            $ymax_frame->new_checkbutton(
                    -onvalue  => 1,
                    -offvalue => 0,
                    -text     => "Auto",
                    -font     => 'default',
                    -variable => \$ymax_auto,
                    -command  => sub { my ($mult);
                                       if ($ymax_auto) {
                                           $mult = ($gr_props{$id}{dunits} eq "miles") ? 3280.84/5280. : 1.0;
                                           if ($ybase ne "" && $ybase ne "." && $ybase ne "-") {
                                               $ymax = $ybase + $gr_props{$id}{d_km} *$mult;
                                               $ymax = &round_to_int(1000.*$ymax)/1000.;
                                           } elsif ($ybase eq "" || $ybase eq ".") {
                                               $ymax = $gr_props{$id}{d_km} *$mult;
                                               $ymax = &round_to_int(1000.*$ymax)/1000.;
                                           }
                                           $ymax_entry->configure(-state => 'disabled');
                                       } else {
                                           $ymax_entry->configure(-state => 'normal');
                                       }
                                     }
                    )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
            $ymax_entry->configure(-state => ($ymax_auto) ? 'disabled' : 'normal');

            $row++;
            $yaxis_frame->new_label(
                    -text    => "Y Tick Interval: ",
                    -font    => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($ymajor_entry = $yaxis_frame->new_entry(
                    -textvariable => \$ymajor,
                    -font         => 'default',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
            $ymajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($ymajor_entry, 1);
                                                        $ymajor =~ s/^-//;
                                                      });

            $row++;
            $yaxis_frame->new_label(
                    -text    => "Y Primary Ticks: ",
                    -font    => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            $yaxis_frame->new_ttk__combobox(
                    -textvariable => \$ypr_tics,
                    -values       => [ @tic_opts ],
                    -state        => 'readonly',
                    )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

            $row++;
            $yaxis_frame->new_label(
                    -text    => "Y Opposite Ticks: ",
                    -font    => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            $yaxis_frame->new_ttk__combobox(
                    -textvariable => \$yop_tics,
                    -values       => [ @tic_opts ],
                    -state        => 'readonly',
                    )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

            $row++;
            $yaxis_frame->new_label(
                    -text => "Y Axis Units: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($yunits_frame = $yaxis_frame->new_frame(
                    -borderwidth => 0,
                    -relief      => 'flat',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew');
            ($yunits_cb = $yunits_frame->new_ttk__combobox(
                    -textvariable => \$yaxis_units,
                    -values       => [ ("miles", "kilometers") ],
                    -state        => 'readonly',
                    -width        => 10,
                    ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
            $yunits_cb->g_bind("<<ComboboxSelected>>",
                                sub { return if ($yaxis_units eq $old_yunits);
                                      if ($yaxis_units eq "miles") {
                                          if ($ybase ne "" && $ybase ne "." && $ybase ne "-") {
                                              $ybase *= 3280.84/5280.;
                                              $ybase = &round_to_int(1000.*$ybase)/1000.;
                                          }
                                          if ($ymin ne "" && $ymin ne "." && $ymin ne "-") {
                                              $ymin *= 3280.84/5280.;
                                              $ymin = &round_to_int(1000.*$ymin)/1000.;
                                          }
                                          if ($yfirst ne "" && $yfirst ne "." && $yfirst ne "-") {
                                              $yfirst *= 3280.84/5280.;
                                              $yfirst = &round_to_int(1000.*$yfirst)/1000.;
                                          }
                                          if ($ymax ne "" && $ymax ne "." && $ymax ne "-") {
                                              $ymax *= 3280.84/5280.;
                                              $ymax = &round_to_int(1000.*$ymax)/1000.;
                                          }
                                          $ytitle =~ s/kilometer/mile/;
                                          $ytitle =~ s/Kilometer/Mile/;
                                          $ytitle =~ s/KILOMETER/MILE/;
                                      } else {
                                          if ($ybase ne "" && $ybase ne "." && $ybase ne "-") {
                                              $ybase *= 5280./3280.84;
                                              $ybase = &round_to_int(1000.*$ybase)/1000.;
                                          }
                                          if ($ymin ne "" && $ymin ne "." && $ymin ne "-") {
                                              $ymin *= 5280./3280.84;
                                              $ymin = &round_to_int(1000.*$ymin)/1000.;
                                          }
                                          if ($yfirst ne "" && $yfirst ne "." && $yfirst ne "-") {
                                              $yfirst *= 5280./3280.84;
                                              $yfirst = &round_to_int(1000.*$yfirst)/1000.;
                                          }
                                          if ($ymax ne "" && $ymax ne "." && $ymax ne "-") {
                                              $ymax *= 5280./3280.84;
                                              $ymax = &round_to_int(1000.*$ymax)/1000.;
                                          }
                                          $ytitle =~ s/mile/kilometer/;
                                          $ytitle =~ s/Mile/Kilometer/;
                                          $ytitle =~ s/MILE/KILOMETER/;
                                      }
                                      $old_yunits = $yaxis_units;
                                    });
            $yunits_frame->new_checkbutton(
                    -onvalue  => 1,
                    -offvalue => 0,
                    -text     => "Flip?",
                    -font     => 'default',
                    -variable => \$yaxis_flip,
                    )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);

            $row++;
            ($ytitle_frame = $yaxis_frame->new_frame(
                    -borderwidth => 0,
                    -relief      => 'flat',
                    ))->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew');
            $ytitle_frame->new_label(
                    -text => "Y Axis Title: ",
                    -font => 'default',
                    )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
            $ytitle_frame->new_entry(
                    -textvariable => \$ytitle,
                    -font         => 'default',
                    )->g_pack(-side => 'left', -anchor => 'w', -expand => 1, -fill => 'x', -pady => 2);
        }
        $yaxis_frame->g_grid_columnconfigure(0, -weight => 2);
    }

#   Segment axis tab
    if ($props{$id}{meta} =~ /w2_slice|w2_wlevels/) {
        @saxis_opts  = ("None", "Above X Axis", "Below X Axis", "Replace X Axis");
        @saxis_types = ("none", "above", "below", "replace");
        if (&list_match($stype, @saxis_types) >= 0) {
            $saxis_opt = $saxis_opts[&list_match($stype, @saxis_types)]; 
        } else {
            $stype     = "none";
            $saxis_opt = "None";
        }
        $old_stic_loc = $stic_loc;
        $stic_dx = 0;
        $anc = 'n';
        if ($stic_loc =~ /^down/) {
            $stic_dx = 0.05*$pw;
            $anc = 'ne';
        } elsif ($stic_loc =~ /^up/) {
            $stic_dx = -0.05*$pw;
            $anc = 'nw';
        }

        $saxis_tab = $grprops_notebook->new_frame();
        $grprops_notebook->add($saxis_tab,
                -text      => "S Axis",
                -underline => 0,
                -sticky    => 'nsew',
                );

        $preview_saxis = $saxis_tab->new_canvas(
                -background  => &get_rgb_code($canvas_color),
                -width       => $pw,
                -height      => $ph,
                -borderwidth => 1,
                -relief      => 'groove',
                );
        $preview_saxis->g_grid(-row => 0, -column => 0, -sticky => 'wne');

        $stitle_txt = $preview_saxis->create_text($pw*0.3 +3, $ph*0.5 +3,
                -anchor => 'center', 
                -text   => "Axis Title",
                -fill   => "#000000",
                -angle  => 0,
                -font   => [-family     => $sfont,
                            -size       => $st_size,
                            -weight     => $st_weight,
                            -slant      => 'roman',
                            -underline  => 0,
                            -overstrike => 0,
                           ]);
        $preview_saxis->create_rectangle($pw*0.6, $ph*0.15, $pw*0.7, $ph*0.35,
                                         -outline => "#000000",
                                         -width   => 1,
                                         -fill    => "#C0C0C0",
                                         -tags    => "saxis_box",
                                        );
        $preview_saxis->create_rectangle($pw*0.7, $ph*0.15, $pw*0.8, $ph*0.35,
                                         -outline => "#000000",
                                         -width   => 1,
                                         -fill    => "#C0C0C0",
                                         -tags    => "saxis_box",
                                        );
        $preview_saxis->create_rectangle($pw*0.8, $ph*0.15, $pw*0.9, $ph*0.35,
                                         -outline => "#000000",
                                         -width   => 1,
                                         -fill    => "#C0C0C0",
                                         -tags    => "saxis_box",
                                        );
        $preview_saxis->create_line($pw*0.65+$stic_dx, $ph*0.35, $pw*0.65+$stic_dx, $ph*0.5,
                                    -width => 1,
                                    -fill  => "#000000",
                                    -arrow => 'none',
                                    -tags  => "stic_line",
                                   );
        $preview_saxis->create_line($pw*0.75+$stic_dx, $ph*0.35, $pw*0.75+$stic_dx, $ph*0.5,
                                    -width => 1,
                                    -fill  => "#000000",
                                    -arrow => 'none',
                                    -tags  => "stic_line",
                                   );
        $preview_saxis->create_line($pw*0.85+$stic_dx, $ph*0.35, $pw*0.85+$stic_dx, $ph*0.5,
                                    -width => 1,
                                    -fill  => "#000000",
                                    -arrow => 'none',
                                    -tags  => "stic_line",
                                   );
        $preview_saxis->create_text($pw*0.65+$stic_dx, $ph*0.5,
                -anchor => $anc, 
                -text   => "2",
                -fill   => "#000000",
                -angle  => 0,
                -tags   => "stic_txt",
                -font   => [-family     => $sfont,
                            -size       => $sl_size,
                            -weight     => $sl_weight,
                            -slant      => 'roman',
                            -underline  => 0,
                            -overstrike => 0,
                           ]);
        $preview_saxis->create_text($pw*0.75+$stic_dx, $ph*0.5,
                -anchor => $anc, 
                -text   => "3",
                -fill   => "#000000",
                -angle  => 0,
                -tags   => "stic_txt",
                -font   => [-family     => $sfont,
                            -size       => $sl_size,
                            -weight     => $sl_weight,
                            -slant      => 'roman',
                            -underline  => 0,
                            -overstrike => 0,
                           ]);
        $preview_saxis->create_text($pw*0.85+$stic_dx, $ph*0.5,
                -anchor => $anc, 
                -text   => "4",
                -fill   => "#000000",
                -angle  => 0,
                -tags   => "stic_txt",
                -font   => [-family     => $sfont,
                            -size       => $sl_size,
                            -weight     => $sl_weight,
                            -slant      => 'roman',
                            -underline  => 0,
                            -overstrike => 0,
                           ]);

        $saxis_frame = $saxis_tab->new_frame(
                -borderwidth => 1,
                -relief      => 'groove',
                );
        $saxis_frame->g_grid(-row => 1, -column => 0, -sticky => 'wnes');

        $row = 0;
        $saxis_frame->new_label(
                -text => "Segment Axis: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($stype_cb = $saxis_frame->new_ttk__combobox(
                -textvariable => \$saxis_opt,
                -values       => [ ("None", "Below X Axis", "Above X Axis", "Replace X Axis") ],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $stype_cb->g_bind("<<ComboboxSelected>>",
                          sub { $stype = $saxis_types[&list_match($saxis_opt, @saxis_opts)];
                                if ($stype eq "none") {
                                    $sfont_cb->configure(-state => 'disabled');
                                    $st_size_cb->configure(-state => 'disabled');
                                    $st_weight_cb->configure(-state => 'disabled');
                                    $sl_size_cb->configure(-state => 'disabled');
                                    $sl_weight_cb->configure(-state => 'disabled');
                                    $stic_loc_cb->configure(-state => 'disabled');
                                    $smajor_entry->configure(-state => 'disabled');
                                    $sgrid_ck->configure(-state => 'disabled');
                                    $sgrid_col_btn->configure(-state => 'disabled');
                                    $bgrid_ck->configure(-state => 'disabled');
                                    $bgrid_col_btn->configure(-state => 'disabled');
                                    $stitle_entry->configure(-state => 'disabled');
                                } else {
                                    $sfont_cb->configure(-state => 'readonly');
                                    $st_size_cb->configure(-state => 'readonly');
                                    $st_weight_cb->configure(-state => 'readonly');
                                    $sl_size_cb->configure(-state => 'readonly');
                                    $sl_weight_cb->configure(-state => 'readonly');
                                    $stic_loc_cb->configure(-state => 'readonly');
                                    $smajor_entry->configure(-state => 'normal');
                                    $sgrid_ck->configure(-state => 'normal');
                                    $sgrid_col_btn->configure(-state => 'normal') if ($sgrid);
                                    $bgrid_ck->configure(-state => 'normal');
                                    $bgrid_col_btn->configure(-state => 'normal') if ($bgrid);
                                    $stitle_entry->configure(-state => 'normal');
                                }
                              });

        $row++;
        $saxis_frame->new_label(
                -text => "S Axis Font: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($sfont_cb = $saxis_frame->new_ttk__combobox(
                -textvariable => \$sfont,
                -values       => [ sort @available_fonts ],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
        $sfont_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_saxis->itemconfigure($stitle_txt,
                              -font => [ -family     => $sfont,
                                         -size       => $st_size,
                                         -weight     => $st_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                        $preview_saxis->itemconfigure("stic_txt",
                              -font => [ -family     => $sfont,
                                         -size       => $sl_size,
                                         -weight     => $sl_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });
        $row++;
        $saxis_frame->new_label(
                -text => "S Title/Label Size: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($st_size_cb = $saxis_frame->new_ttk__combobox(
                -textvariable => \$st_size,
                -values       => [(5 .. 24)],
                -width        => 5,
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
        $st_size_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_saxis->itemconfigure($stitle_txt,
                              -font => [ -family     => $sfont,
                                         -size       => $st_size,
                                         -weight     => $st_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });
        ($sl_size_cb = $saxis_frame->new_ttk__combobox(
                -textvariable => \$sl_size,
                -values       => [(5 .. 24)],
                -width        => 5,
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 2, -sticky => 'ew', -pady => 2);
        $sl_size_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_saxis->itemconfigure("stic_txt",
                              -font => [ -family     => $sfont,
                                         -size       => $sl_size,
                                         -weight     => $sl_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });
        $row++;
        $saxis_frame->new_label(
                -text => "S Title/Label Weight: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($st_weight_cb = $saxis_frame->new_ttk__combobox(
                -textvariable => \$st_weight,
                -values       => [("normal", "bold")],
                -width        => 5,
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
        $st_weight_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_saxis->itemconfigure($stitle_txt,
                              -font => [ -family     => $sfont,
                                         -size       => $st_size,
                                         -weight     => $st_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });
        ($sl_weight_cb = $saxis_frame->new_ttk__combobox(
                -textvariable => \$sl_weight,
                -values       => [("normal", "bold")],
                -width        => 5,
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 2, -sticky => 'ew', -pady => 2);
        $sl_weight_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_saxis->itemconfigure("stic_txt",
                              -font => [ -family     => $sfont,
                                         -size       => $sl_size,
                                         -weight     => $sl_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });

        $row++;
        $saxis_frame->new_label(
                -text => "S Tick Placement: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($stic_loc_cb = $saxis_frame->new_ttk__combobox(
                -textvariable => \$stic_loc,
                -values       => [("upstream edge", "center", "downstream edge")],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $stic_loc_cb->g_bind("<<ComboboxSelected>>",
                  sub { return if ($stic_loc eq $old_stic_loc);
                        if ($old_stic_loc eq "center") {
                            $stic_dx = ($stic_loc =~ /down/) ? 0.05*$pw : -0.05*$pw;
                        } elsif ($old_stic_loc =~ /down/) {
                            $stic_dx = ($stic_loc eq "center") ? -0.05*$pw : -0.1*$pw;
                        } else {
                            $stic_dx = ($stic_loc eq "center") ? 0.05*$pw : 0.1*$pw;
                        }
                        $anc = 'n';
                        if ($stic_loc =~ /down/) {
                            $anc = 'ne';
                        } elsif ($stic_loc =~ /up/) {
                            $anc = 'nw';
                        }
                        $preview_saxis->move("stic_line", $stic_dx, 0);
                        $preview_saxis->move("stic_txt", $stic_dx, 0);
                        $preview_saxis->itemconfigure("stic_txt", -anchor => $anc);
                        $old_stic_loc = $stic_loc;
                      });

        $row++;
        $saxis_frame->new_label(
                -text => "S Major Interval: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($smajor_entry = $saxis_frame->new_entry(
                -textvariable => \$smajor,
                -font         => 'default',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $smajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($smajor_entry, 1);
                                                    $smajor =~ s/^-//;
                                                    if ($smajor ne "auto" and $smajor ne "") {
                                                        $smajor = int($smajor);
                                                    }
                                                  });

        $row++;
        $saxis_frame->new_label(
                -text    => "S Primary Ticks: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $saxis_frame->new_ttk__combobox(
                -textvariable => \$spr_tics,
                -values       => [ @tic_opts ],
                -state        => 'readonly',
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

        $row++;
        $saxis_frame->new_label(
                -text    => "S Opposite Ticks: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $saxis_frame->new_ttk__combobox(
                -textvariable => \$sop_tics,
                -values       => [ @tic_opts ],
                -state        => 'readonly',
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

        $row++;
        $saxis_frame->new_label(
                -text => "S Grid Lines: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($sgrid_ck = $saxis_frame->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "Show",
                -font     => 'default',
                -variable => \$sgrid,
                -command  => sub { my $status = ($sgrid) ? 'normal' : 'disabled';
                                   $sgrid_col_btn->configure(-state => $status);
                                 },
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $code      = &get_rgb_code($sgrid_col);
        $sgrid_col = &get_rgb_name($code);
        $fg        = &get_rgb_code("black");
        if ($code =~ /^\#[0-9a-f]/i) {
            $fg = &get_rgb_code(&get_bw_contrast($code));
        }
        ($sgrid_col_btn = $saxis_frame->new_button(
                        -textvariable => \$sgrid_col,
                        -background   => $code,
                        -foreground   => $fg,
                        -width        => -7,
                        -command => sub { my ($newc, $code, $fg);
                                          $code = &get_rgb_code($sgrid_col);
                                          $newc = Tkx::tk___chooseColor(
                                                     -initialcolor => $code,
                                                     -parent       => $graph_props_menu);
                                          if ($newc) {
                                              $code      = &get_rgb_code($newc);
                                              $sgrid_col = &get_rgb_name($code);
                                              $fg        = &get_rgb_code("black");
                                              if ($code =~ /^#?[0-9a-f]/i) {
                                                  $fg = &get_rgb_code(&get_bw_contrast($code));
                                              }
                                              $sgrid_col_btn->configure(-foreground => $fg,
                                                                        -background => $code);
                                          }
                                        }
                        ))->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

        $row++;
        $saxis_frame->new_label(
                -text => "Branch Edge Grid: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($bgrid_ck = $saxis_frame->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "Show",
                -font     => 'default',
                -variable => \$bgrid,
                -command  => sub { my $status = ($bgrid) ? 'normal' : 'disabled';
                                   $bgrid_col_btn->configure(-state => $status);
                                 },
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $code      = &get_rgb_code($bgrid_col);
        $bgrid_col = &get_rgb_name($code);
        $fg        = &get_rgb_code("black");
        if ($code =~ /^\#[0-9a-f]/i) {
            $fg = &get_rgb_code(&get_bw_contrast($code));
        }
        ($bgrid_col_btn = $saxis_frame->new_button(
                        -textvariable => \$bgrid_col,
                        -background   => $code,
                        -foreground   => $fg,
                        -width        => -7,
                        -command => sub { my ($newc, $code, $fg);
                                          $code = &get_rgb_code($bgrid_col);
                                          $newc = Tkx::tk___chooseColor(
                                                     -initialcolor => $code,
                                                     -parent       => $graph_props_menu);
                                          if ($newc) {
                                              $code      = &get_rgb_code($newc);
                                              $bgrid_col = &get_rgb_name($code);
                                              $fg        = &get_rgb_code("black");
                                              if ($code =~ /^#?[0-9a-f]/i) {
                                                  $fg = &get_rgb_code(&get_bw_contrast($code));
                                              }
                                              $bgrid_col_btn->configure(-foreground => $fg,
                                                                        -background => $code);
                                          }
                                        }
                        ))->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

        $row++;
        $saxis_frame->new_label(
                -text => "S Axis Title: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'w', -pady => 2);
        $row++;
        ($stitle_entry = $saxis_frame->new_entry(
                -textvariable => \$stitle,
                -font         => 'default',
                ))->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew', -pady => 2);

        if ($stype eq "none") {
            $sfont_cb->configure(-state => 'disabled');
            $st_size_cb->configure(-state => 'disabled');
            $st_weight_cb->configure(-state => 'disabled');
            $sl_size_cb->configure(-state => 'disabled');
            $sl_weight_cb->configure(-state => 'disabled');
            $stic_loc_cb->configure(-state => 'disabled');
            $smajor_entry->configure(-state => 'disabled');
            $sgrid_ck->configure(-state => 'disabled');
            $sgrid_col_btn->configure(-state => 'disabled');
            $bgrid_ck->configure(-state => 'disabled');
            $bgrid_col_btn->configure(-state => 'disabled');
            $stitle_entry->configure(-state => 'disabled');
        }
        $saxis_frame->g_grid_columnconfigure(0, -weight => 2);
    }

#   Graph title tab
    $gtitle_tab = $grprops_notebook->new_frame();
    $grprops_notebook->add($gtitle_tab,
            -text      => "Title",
            -underline => 0,
            -sticky    => 'nsew',
            );

    $preview_gtitle = $gtitle_tab->new_canvas(
            -background  => &get_rgb_code($canvas_color),
            -width       => $pw,
            -height      => $ph,
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $preview_gtitle->g_grid(-row => 0, -column => 0, -sticky => 'wne');

    if ($props{$id}{meta} =~ /(data_profile_cmap|w2_profile_cmap|time_series)/) {
        $gtitle_txt = $preview_gtitle->create_text($pw*0.5 +3, $ph*0.5 +3,
                -anchor => 'center', 
                -text   => "Graph Title",
                -fill   => "#000000",
                -angle  => 0,
                -font   => [-family     => $gtfont,
                            -size       => $gt_size,
                            -weight     => $gt_weight,
                            -slant      => 'roman',
                            -underline  => 0,
                            -overstrike => 0,
                           ]);
    } else {
        $preview_gtitle->configure(-height => 2 *$ph);
        $gtitle_txt = $preview_gtitle->create_text($pw*0.5 +3, $ph*0.6 +3,
                -anchor => 'center', 
                -text   => "Graph Title",
                -fill   => "#000000",
                -angle  => 0,
                -font   => [-family     => $gtfont,
                            -size       => $gt_size,
                            -weight     => $gt_weight,
                            -slant      => 'roman',
                            -underline  => 0,
                            -overstrike => 0,
                           ]);
        $gsubtitle_txt = $preview_gtitle->create_text($pw*0.5 +3, $ph*1.4 +3,
                -anchor => 'center', 
                -text   => "Graph Subtitle",
                -fill   => "#000000",
                -angle  => 0,
                -font   => [-family     => $gtfont,
                            -size       => $gs_size,
                            -weight     => $gs_weight,
                            -slant      => 'roman',
                            -underline  => 0,
                            -overstrike => 0,
                           ]);
    }

    $gtitle_frame = $gtitle_tab->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $gtitle_frame->g_grid(-row => 1, -column => 0, -sticky => 'wnes');

    $row = 0;
    $gtitle_frame->new_label(
            -text => "Title Font: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($gtfont_cb = $gtitle_frame->new_ttk__combobox(
            -textvariable => \$gtfont,
            -values       => [ sort @available_fonts ],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $gtfont_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_gtitle->itemconfigure($gtitle_txt,
                          -font => [ -family     => $gtfont,
                                     -size       => $gt_size,
                                     -weight     => $gt_weight,
                                     -slant      => 'roman',
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                    if ($props{$id}{meta} !~ /(data_profile_cmap|w2_profile_cmap|time_series)/) {
                        $preview_gtitle->itemconfigure($gsubtitle_txt,
                              -font => [ -family     => $gtfont,
                                         -size       => $gs_size,
                                         -weight     => $gs_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                    }
                  });
    $row++;
    $gtitle_frame->new_label(
            -text => "Title Size: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($gt_size_cb = $gtitle_frame->new_ttk__combobox(
            -textvariable => \$gt_size,
            -values       => [(5 .. 24)],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $gt_size_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_gtitle->itemconfigure($gtitle_txt,
                          -font => [ -family     => $gtfont,
                                     -size       => $gt_size,
                                     -weight     => $gt_weight,
                                     -slant      => 'roman',
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                  });
    $row++;
    $gtitle_frame->new_label(
            -text => "Title Weight: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($gt_weight_cb = $gtitle_frame->new_ttk__combobox(
            -textvariable => \$gt_weight,
            -values       => [("normal", "bold")],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $gt_weight_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_gtitle->itemconfigure($gtitle_txt,
                          -font => [ -family     => $gtfont,
                                     -size       => $gt_size,
                                     -weight     => $gt_weight,
                                     -slant      => 'roman',
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                  });
    if ($props{$id}{meta} !~ /(data_profile_cmap|w2_profile_cmap|time_series)/) {
        $row++;
        $gtitle_frame->new_label(
                -text => "Subtitle Size: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($gs_size_cb = $gtitle_frame->new_ttk__combobox(
                -textvariable => \$gs_size,
                -values       => [(5 .. 24)],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $gs_size_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_gtitle->itemconfigure($gsubtitle_txt,
                              -font => [ -family     => $gtfont,
                                         -size       => $gs_size,
                                         -weight     => $gs_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });
        $row++;
        $gtitle_frame->new_label(
                -text => "Subtitle Weight: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($gs_weight_cb = $gtitle_frame->new_ttk__combobox(
                -textvariable => \$gs_weight,
                -values       => [("normal", "bold")],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $gs_weight_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_gtitle->itemconfigure($gsubtitle_txt,
                              -font => [ -family     => $gtfont,
                                         -size       => $gs_size,
                                         -weight     => $gs_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });
    }

    $row++;
    $gtitle_frame->new_label(
            -text    => "Graph Title: ",
            -font    => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'w', -pady => 2);
    $row++;
    $gtitle_frame->new_entry(
            -textvariable => \$gtitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 0, -columnspan => 2, -sticky => 'ew', -pady => 2);

    if ($props{$id}{meta} eq "w2_tdmap") {
        $row++;
        $gtitle_frame->new_label(
                -text    => "Graph Subtitle: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'w', -pady => 2);
        $row++;
        $gtitle_frame->new_entry(
                -textvariable => \$gstitle,
                -font         => 'default',
                )->g_grid(-row => $row, -column => 0, -columnspan => 2, -sticky => 'ew', -pady => 2);
    }
    $gtitle_frame->g_grid_columnconfigure(0, -weight => 2);

#   Water Levels tab
    if ($props{$id}{meta} eq "w2_wlevels") {
        $wl_color     = $gr_props{$id}{wl_color};
        $wl_style     = $gr_props{$id}{wl_style};
        $wl_grid      = $gr_props{$id}{wl_grid};
        $wl_gridc     = $gr_props{$id}{wl_gridc};
        $old_wl_style = $wl_style;

        $wlevel_tab = $grprops_notebook->new_frame();
        $grprops_notebook->add($wlevel_tab,
                -text      => "Levels",
                -underline => 0,
                -sticky    => 'nsew',
                );

        $preview_levels = $wlevel_tab->new_canvas(
                -background  => &get_rgb_code($canvas_color),
                -width       => $pw,
                -height      => $ph,
                -borderwidth => 1,
                -relief      => 'groove',
                );
        $preview_levels->g_grid(-row => 0, -column => 0, -sticky => 'wne');

        $preview_levels->create_line($pw*0.20, $ph*0.70, $pw*0.25, $ph*0.70,
                                     $pw*0.35, $ph*0.80, $pw*0.45, $ph*0.60,
                                     $pw*0.55, $ph*0.45, $pw*0.65, $ph*0.30,
                                     $pw*0.75, $ph*0.40, $pw*0.80, $ph*0.40,
                                     -width => 1,
                                     -fill  => "#000000",
                                     -arrow => 'none',
                                     -tags  => "_interp_line",
                                    );
        $preview_levels->create_line($pw*0.20, $ph*0.70, $pw*0.30, $ph*0.70,
                                     $pw*0.30, $ph*0.80, $pw*0.40, $ph*0.80,
                                     $pw*0.40, $ph*0.60, $pw*0.50, $ph*0.60,
                                     $pw*0.50, $ph*0.45, $pw*0.60, $ph*0.45,
                                     $pw*0.60, $ph*0.30, $pw*0.70, $ph*0.30,
                                     $pw*0.70, $ph*0.40, $pw*0.80, $ph*0.40,
                                     -width => 1,
                                     -fill  => "#000000",
                                     -arrow => 'none',
                                     -tags  => "_flat_line",
                                    );
        $preview_levels->create_line($pw*0.20, $ph*0.74, $pw*0.30, $ph*0.66,
                                     $pw*0.30, $ph*0.84, $pw*0.40, $ph*0.76,
                                     $pw*0.40, $ph*0.64, $pw*0.50, $ph*0.56,
                                     $pw*0.50, $ph*0.49, $pw*0.60, $ph*0.41,
                                     $pw*0.60, $ph*0.34, $pw*0.70, $ph*0.26,
                                     $pw*0.70, $ph*0.44, $pw*0.80, $ph*0.36,
                                     -width => 1,
                                     -fill  => "#000000",
                                     -arrow => 'none',
                                     -tags  => "_sloped_line",
                                    );
        if ($wl_style =~ /Interpolate/i) {
            $wl_style = "Interpolate";
            $preview_levels->itemconfigure("_flat_line",   -fill => "#C9C9C9");
            $preview_levels->itemconfigure("_interp_line", -fill => &get_rgb_code($wl_color));
            $preview_levels->itemconfigure("_sloped_line", -fill => "#C9C9C9");
            $preview_levels->raise("_interp_line", "_sloped_line");
        } elsif ($wl_style =~ /Branch slope/i) {
            $wl_style = "Branch slope";
            $preview_levels->itemconfigure("_flat_line",   -fill => "#C9C9C9");
            $preview_levels->itemconfigure("_interp_line", -fill => "#C9C9C9");
            $preview_levels->itemconfigure("_sloped_line", -fill => &get_rgb_code($wl_color));
        } else {
            $wl_style = "Flat surface";
            $preview_levels->itemconfigure("_flat_line",   -fill => &get_rgb_code($wl_color));
            $preview_levels->itemconfigure("_interp_line", -fill => "#C9C9C9");
            $preview_levels->itemconfigure("_sloped_line", -fill => "#C9C9C9");
            $preview_levels->raise("_flat_line", "_sloped_line");
        }

        ($wlevel_frame = $wlevel_tab->new_frame(
                -borderwidth => 1,
                -relief      => 'groove',
                ))->g_grid(-row => 1, -column => 0, -sticky => 'wnes');

        $row = 0;
        $wlevel_frame->new_label(
                -text => "Level Line Style: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($wlstyle_cb = $wlevel_frame->new_ttk__combobox(
                -textvariable => \$wl_style,
                -values       => [("Flat surface", "Interpolate", "Branch slope")],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $wlstyle_cb->g_bind("<<ComboboxSelected>>",
                sub { my ($above_id);
                      return if ($wl_style eq $old_wl_style);
                      if ($wl_style =~ /Interpolate/i) {
                          $wl_style = "Interpolate";
                          $preview_levels->itemconfigure("_flat_line",   -fill => "#C9C9C9");
                          $preview_levels->itemconfigure("_interp_line", -fill => &get_rgb_code($wl_color));
                          $preview_levels->itemconfigure("_sloped_line", -fill => "#C9C9C9");
                          while (($above_id = $preview_levels->find_above("_interp_line")) ne "") {
                              $preview_levels->raise("_interp_line", $above_id);
                          }
                      } elsif ($wl_style =~ /Branch slope/i) {
                          $wl_style = "Branch slope";
                          $preview_levels->itemconfigure("_flat_line",   -fill => "#C9C9C9");
                          $preview_levels->itemconfigure("_interp_line", -fill => "#C9C9C9");
                          $preview_levels->itemconfigure("_sloped_line", -fill => &get_rgb_code($wl_color));
                          while (($above_id = $preview_levels->find_above("_sloped_line")) ne "") {
                              $preview_levels->raise("_sloped_line", $above_id);
                          }
                      } else {
                          $wl_style = "Flat surface";
                          $preview_levels->itemconfigure("_flat_line",   -fill => &get_rgb_code($wl_color));
                          $preview_levels->itemconfigure("_interp_line", -fill => "#C9C9C9");
                          $preview_levels->itemconfigure("_sloped_line", -fill => "#C9C9C9");
                          while (($above_id = $preview_levels->find_above("_flat_line")) ne "") {
                              $preview_levels->raise("_flat_line", $above_id);
                          }
                      }
                      $old_wl_style = $wl_style;
                    });

        $row++;
        $wlevel_frame->new_label(
                -text => "Level Line Color: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);

        $code     = &get_rgb_code($wl_color);
        $wl_color = &get_rgb_name($code);
        $fg       = &get_rgb_code("White");
        if ($code =~ /^\#[0-9a-f]/i) {
            $fg = &get_rgb_code(&get_bw_contrast($code));
        }
        ($wlcolor_btn = $wlevel_frame->new_button(
                -textvariable => \$wl_color,
                -background   => $code,
                -foreground   => $fg,
                -width        => -7,
                -command => sub { my ($newc);
                                  $code = &get_rgb_code($wl_color);
                                  $newc = Tkx::tk___chooseColor(
                                             -initialcolor => $code,
                                             -parent       => $graph_props_menu);
                                  if ($newc) {
                                      $code     = &get_rgb_code($newc);
                                      $wl_color = &get_rgb_name($code);
                                      $fg       = &get_rgb_code("black");
                                      if ($code =~ /^#?[0-9a-f]/i) {
                                          $fg = &get_rgb_code(&get_bw_contrast($code));
                                      }
                                      $wlcolor_btn->configure(-foreground => $fg,
                                                              -background => $code);
                                      if ($wl_style =~ /Interpolate/i) {
                                          $preview_levels->itemconfigure("_interp_line",
                                                              -fill => &get_rgb_code($wl_color));
                                      } elsif ($wl_style =~ /Branch slope/i) {
                                          $preview_levels->itemconfigure("_sloped_line",
                                                              -fill => &get_rgb_code($wl_color));
                                      } else {
                                          $preview_levels->itemconfigure("_flat_line",
                                                              -fill => &get_rgb_code($wl_color));
                                      }
                                  }
                                }
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

        $row++;
        $wlevel_frame->new_label(
                -text => "Show Grid Layers: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $wlevel_frame->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "",
                -font     => 'default',
                -variable => \$wl_grid,
                -command  => sub { my $status = ($wl_grid) ? 'normal' : 'disabled';
                                   $wl_gridc_btn->configure(-state => $status);
                                 },
                )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

        $row++;
        $wlevel_frame->new_label(
                -text => "Grid Line Color: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);

        $code     = &get_rgb_code($wl_gridc);
        $wl_gridc = &get_rgb_name($code);
        $fg       = &get_rgb_code("black");
        if ($code =~ /^\#[0-9a-f]/i) {
            $fg = &get_rgb_code(&get_bw_contrast($code));
        }
        ($wl_gridc_btn = $wlevel_frame->new_button(
                -textvariable => \$wl_gridc,
                -background   => $code,
                -foreground   => $fg,
                -width        => -7,
                -command => sub { my ($newc);
                                  $code = &get_rgb_code($wl_gridc);
                                  $newc = Tkx::tk___chooseColor(
                                             -initialcolor => $code,
                                             -parent       => $graph_props_menu);
                                  if ($newc) {
                                      $code     = &get_rgb_code($newc);
                                      $wl_gridc = &get_rgb_name($code);
                                      $fg       = &get_rgb_code("black");
                                      if ($code =~ /^#?[0-9a-f]/i) {
                                          $fg = &get_rgb_code(&get_bw_contrast($code));
                                      }
                                      $wl_gridc_btn->configure(-foreground => $fg,
                                                               -background => $code);
                                  }
                                }
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        if (! $wl_grid) {
            $wl_gridc_btn->configure(-state => 'disabled');
        }

        $wlevel_frame->g_grid_columnconfigure(0, -weight => 2);
    }

#   Color key tabs
    if (defined($gr_props{$id}{add_cs})) {
        $scheme1     = $gr_props{$id}{cscheme1};
        $scheme2     = $gr_props{$id}{cscheme2};
        $ncolors     = $gr_props{$id}{ncolors};
        $cs_rev      = $gr_props{$id}{cs_rev};
        $cs_min      = $gr_props{$id}{cs_min};
        $cs_max      = $gr_props{$id}{cs_max};
        $cs_major    = $gr_props{$id}{cs_major};
        $cs_width    = $gr_props{$id}{cs_width};
        $cs_height   = $gr_props{$id}{cs_height};
        @colors      = @{ $gr_props{$id}{colors} };
        $reverse_opt = ("no", "yes")[$cs_rev];

        $keyfont     = $gr_props{$id}{keyfont};
        $keytitle    = $gr_props{$id}{keytitle};
        $kt_size     = $gr_props{$id}{kt_size};
        $kt_weight   = $gr_props{$id}{kt_weight};
        $kn_size     = $gr_props{$id}{kn_size};
        $kn_weight   = $gr_props{$id}{kn_weight};
        $kn_digits   = $gr_props{$id}{kn_digits};

        $cs_link     = $gr_props{$id}{cs_link};
        @cslink_opts = ("No links", "Linked, same source", "Linked, same parameter");
        $cslink_opt  = $cslink_opts[$cs_link];

        if (&list_match($scheme1, @full_color_schemes) >= 0) {
            $ncolors = &max($valid_nc_alt[0], &min($ncolors, $valid_nc_alt[$#valid_nc_alt]));
            $scheme2 = "None";
        } else {
            $ncolors = &max($valid_nc[0], &min($ncolors, $valid_nc[$#valid_nc]));
            if (&list_match($ncolors, @valid_nc) == -1) {
                for ($i=0; $i<$#valid_nc; $i++) {
                    if ($ncolors > $valid_nc[$i] && $ncolors < $valid_nc[$i+1]) {
                        if (abs($ncolors -$valid_nc[$i]) <=
                            abs($ncolors -$valid_nc[$i+1])) {
                            $ncolors = $valid_nc[$i];
                        } else {
                            $ncolors = $valid_nc[$i+1];
                        }
                        last;
                    }
                }
            }
        }

        $fmt_w = length(int(abs($cs_max)));
        $fmt_w++ if ($cs_max < 0);
        if ($kn_digits > 0) {
            $fmt_w += $kn_digits +1;
            $fmt = "%${fmt_w}.${kn_digits}f";
        } else {
            $fmt = "%${fmt_w}d";
        }

        if ($props{$id}{meta} =~ /^(data_profile|w2_profile|w2_outflow|vert_wd_zone)$/) {
            $cs_status   = $gr_props{$id}{add_cs};
            $cs_status   = 2 if ($cs_status > 0 && $gr_props{$id}{cs_hide});
            $cstatus_opt = ("Inactive", "Key visible", "Key hidden")[$cs_status];

        } elsif ($props{$id}{meta} =~ /data_profile_cmap|w2_profile_cmap|w2_slice|w2_tdmap/) {
            $cs_status   = $gr_props{$id}{cs_hide};
            $cstatus_opt = ("Key visible", "Key hidden")[$cs_status];
        }

        $scheme_tab = $grprops_notebook->new_frame();
        $grprops_notebook->add($scheme_tab,
                -text      => "Color Key",
                -underline => 0,
                -sticky    => 'nsew',
                );

        $preview_scheme = $scheme_tab->new_canvas(
                -background  => &get_rgb_code($canvas_color),
                -width       => $pw,
                -height      => $ph,
                -borderwidth => 1,
                -relief      => 'groove',
                );
        $preview_scheme->g_grid(-row => 0, -column => 0, -sticky => 'wne');

        for ($i=0; $i<=$#colors; $i++) {
            $x1 = $pw*(0.05 + 0.9* $i   /($#colors+1));
            $x2 = $pw*(0.05 + 0.9*($i+1)/($#colors+1));
            $preview_scheme->create_rectangle($x1 +3, $ph*0.2 +3, $x2 +3, $ph*0.8 +3,
                                -outline => "",
                                -width   => 0,
                                -fill    => $colors[$i],
                                );
        }

        $scheme_frame = $scheme_tab->new_frame(
                -borderwidth => 1,
                -relief      => 'groove',
                );
        $scheme_frame->g_grid(-row => 1, -column => 0, -sticky => 'wnes');

        $row = 0;
        $scheme_frame->new_label(
                -text => "Status: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        if ($props{$id}{meta} =~ /^(data_profile|w2_profile|w2_outflow|vert_wd_zone)$/) {
            ($cstatus_cb = $scheme_frame->new_ttk__combobox(
                    -textvariable => \$cstatus_opt,
                    -values       => [("Key visible", "Key hidden", "Inactive")],
                    -state        => 'readonly',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2,
                               -sticky => 'ew', -pady => 2);
            $cstatus_cb->g_bind("<<ComboboxSelected>>",
                      sub { my $s = &list_match($cstatus_opt, ("Inactive", "Key visible", "Key hidden"));
                            return if ($s < 0);
                            $cs_status = $s;
                          });
        } elsif ($props{$id}{meta} =~ /data_profile_cmap|w2_profile_cmap|w2_slice|w2_tdmap/) {
            ($cstatus_cb = $scheme_frame->new_ttk__combobox(
                    -textvariable => \$cstatus_opt,
                    -values       => [("Key visible", "Key hidden")],
                    -state        => 'readonly',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2,
                               -sticky => 'ew', -pady => 2);
            $cstatus_cb->g_bind("<<ComboboxSelected>>",
                      sub { my $s = &list_match($cstatus_opt, ("Key visible", "Key hidden"));
                            return if ($s < 0);
                            $cs_status = $s;
                          });
        }

        $row++;
        $scheme_frame->new_label(
                -text => "Links: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($cslink_cb = $scheme_frame->new_ttk__combobox(
                -textvariable => \$cslink_opt,
                -values       => [ @cslink_opts ],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2,
                           -sticky => 'ew', -pady => 2);
        $cslink_cb->g_bind("<<ComboboxSelected>>",
                  sub { my $s = &list_match($cslink_opt, @cslink_opts);
                        return if ($s < 0);
                        $cs_link = $s;
                      });

        $row++;
        $scheme_frame->new_label(
                -text => "Color Scheme 1: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($scheme1_cb = $scheme_frame->new_ttk__combobox(
                -textvariable => \$scheme1,
                -values       => [ @color_scheme_names ],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
        $scheme1_cb->g_bind("<<ComboboxSelected>>",
                  sub { my ($i, $x1, $x2, @colors);
                        if (&list_match($scheme1, @color_scheme_names) == -1) {
                            &pop_up_error($main, "Color scheme $scheme1 not found.");
                            return;
                        }
                        $preview_scheme->delete("all");
                        if (&list_match($scheme1, @full_color_schemes) >= 0) {
                            $scheme2 = "None";
                            $scheme2_cb->configure(-state  => 'disabled');
                            $ncolors_cb->configure(-values => [ @valid_nc_alt ]);
                        } else {
                            $scheme2_cb->configure(-state  => 'readonly');
                            $ncolors_cb->configure(-values => [ @valid_nc ]);
                            $ncolors = &max($valid_nc[0], &min($ncolors, $valid_nc[$#valid_nc]));
                            if (&list_match($ncolors, @valid_nc) == -1) {
                                for ($i=0; $i<$#valid_nc; $i++) {
                                    if ($ncolors > $valid_nc[$i] && $ncolors < $valid_nc[$i+1]) {
                                        if (abs($ncolors -$valid_nc[$i]) <=
                                            abs($ncolors -$valid_nc[$i+1])) {
                                            $ncolors = $valid_nc[$i];
                                        } else {
                                            $ncolors = $valid_nc[$i+1];
                                        }
                                        last;
                                    }
                                }
                            }
                        }
                        @colors = &make_color_scheme($ncolors, $cs_rev, $scheme1, $scheme2);
                        for ($i=0; $i<=$#colors; $i++) {
                            $x1 = $pw*(0.05 + 0.9* $i   /($#colors+1));
                            $x2 = $pw*(0.05 + 0.9*($i+1)/($#colors+1));
                            $preview_scheme->create_rectangle($x1 +3, $ph*0.2 +3,
                                                              $x2 +3, $ph*0.8 +3,
                                                -outline => "",
                                                -width   => 0,
                                                -fill    => $colors[$i],
                                                );
                        }
                      });
        $row++;
        $scheme_frame->new_label(
                -text => "Color Scheme 2: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($scheme2_cb = $scheme_frame->new_ttk__combobox(
                -textvariable => \$scheme2,
                -values       => [ @color_scheme_names2 ],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
        $scheme2_cb->g_bind("<<ComboboxSelected>>",
                  sub { my ($i, $x1, $x2, @colors);
                        if (&list_match($scheme2, @color_scheme_names2) == -1) {
                            &pop_up_error($main, "Color scheme $scheme2 not found.");
                            return;
                        }
                        $preview_scheme->delete("all");
                        @colors = &make_color_scheme($ncolors, $cs_rev, $scheme1, $scheme2);
                        for ($i=0; $i<=$#colors; $i++) {
                            $x1 = $pw*(0.05 + 0.9* $i   /($#colors+1));
                            $x2 = $pw*(0.05 + 0.9*($i+1)/($#colors+1));
                            $preview_scheme->create_rectangle($x1 +3, $ph*0.2 +3,
                                                              $x2 +3, $ph*0.8 +3,
                                                -outline => "",
                                                -width   => 0,
                                                -fill    => $colors[$i],
                                                );
                        }
                      });

        $row++;
        $scheme_frame->new_label(
                -text => "Steps per Scheme: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($ncolors_cb = $scheme_frame->new_ttk__combobox(
                -textvariable => \$ncolors,
                -values       => [ @valid_nc ],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
        $ncolors_cb->g_bind("<<ComboboxSelected>>",
                  sub { my ($i, $x1, $x2, @colors);
                        $preview_scheme->delete("all");
                        @colors = &make_color_scheme($ncolors, $cs_rev, $scheme1, $scheme2);
                        for ($i=0; $i<=$#colors; $i++) {
                            $x1 = $pw*(0.05 + 0.9* $i   /($#colors+1));
                            $x2 = $pw*(0.05 + 0.9*($i+1)/($#colors+1));
                            $preview_scheme->create_rectangle($x1 +3, $ph*0.2 +3,
                                                              $x2 +3, $ph*0.8 +3,
                                                -outline => "",
                                                -width   => 0,
                                                -fill    => $colors[$i],
                                                );
                        }
                      });

        if (&list_match($scheme1, @full_color_schemes) >= 0) {
            $scheme2_cb->configure(-state  => 'disabled');
            $ncolors_cb->configure(-values => [ @valid_nc_alt ]);
        }

        $row++;
        $scheme_frame->new_label(
                -text => "Reverse Colors: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($reverse_cb = $scheme_frame->new_ttk__combobox(
                -textvariable => \$reverse_opt,
                -values       => [("no", "yes")],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
        $reverse_cb->g_bind("<<ComboboxSelected>>",
                  sub { my ($r, $i, $x1, $x2, @colors);
                        $r = &list_match($reverse_opt, ("no", "yes"));
                        return if ($r < 0);
                        $cs_rev = $r;
                        $preview_scheme->delete("all");
                        @colors = &make_color_scheme($ncolors, $cs_rev, $scheme1, $scheme2);
                        for ($i=0; $i<=$#colors; $i++) {
                            $x1 = $pw*(0.05 + 0.9* $i   /($#colors+1));
                            $x2 = $pw*(0.05 + 0.9*($i+1)/($#colors+1));
                            $preview_scheme->create_rectangle($x1 +3, $ph*0.2 +3,
                                                              $x2 +3, $ph*0.8 +3,
                                                -outline => "",
                                                -width   => 0,
                                                -fill    => $colors[$i],
                                                );
                        }
                      });

        $row++;
        $scheme_frame->new_label(
                -text    => "Scale Minimum: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($csmin_entry = $scheme_frame->new_entry(
                -textvariable => \$cs_min,
                -font         => 'default',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
        $csmin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $csmin_entry ]);

        $row++;
        $scheme_frame->new_label(
                -text    => "Scale Maximum: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($csmax_entry = $scheme_frame->new_entry(
                -textvariable => \$cs_max,
                -font         => 'default',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
        $csmax_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $csmax_entry ]);

        $row++;
        $scheme_frame->new_label(
                -text    => "Scale Increment: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($csmajor_entry = $scheme_frame->new_entry(
                -textvariable => \$cs_major,
                -font         => 'default',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
        $csmajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($csmajor_entry, 1);
                                                     $cs_major =~ s/^-//;
                                                   });

        if ($props{$id}{meta} eq "vert_wd_zone"
                || ($props{$id}{meta} =~ /data_profile_cmap|w2_profile_cmap|w2_slice|w2_tdmap|w2_outflow/
                    && $props{$id}{parm} eq "Temperature")) {
            $row++;
            $scheme_frame->new_label(
                    -text => "Scale Units: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($wt_units_cb = $scheme_frame->new_ttk__combobox(
                    -textvariable => \$wt_units,
                    -values       => [ ("Celsius", "Fahrenheit") ],
                    -state        => 'readonly',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
            $wt_units_cb->g_bind("<<ComboboxSelected>>",
                                 sub { my ($diff);
                                       if (($props{$id}{meta} eq "data_profile_cmap"
                                             && $props{$id}{prof_type} eq "difference") ||
                                           ($props{$id}{meta} eq "w2_tdmap"
                                             && $props{$id}{map_type} =~ /^(parmdiff|filediff)$/)) {
                                           $diff = 0;
                                       } else {
                                           $diff = 32;
                                       }
                                       if ($wt_units eq "Celsius"
                                            && $wt_oldunits eq "Fahrenheit") {
                                           $keytitle =~ s/Fahrenheit/Celsius/;
                                           if ($cs_min ne "") {
                                               $cs_min = &floor(($cs_min -$diff) /1.8);
                                           }
                                           if ($cs_max ne "") {
                                               $cs_max = &ceil(($cs_max -$diff) /1.8);
                                           }
                                           if ($cs_major ne "" && $cs_major ne "." && $cs_major ne "auto") {
                                               $cs_major = sprintf("%.4f", $cs_major/1.8);
                                               $cs_major =~ s/0+$//;
                                           }
                                       } elsif ($wt_units eq "Fahrenheit"
                                            && $wt_oldunits eq "Celsius") {
                                           $keytitle =~ s/Celsius/Fahrenheit/;
                                           if ($cs_min ne "") {
                                               $cs_min = &floor($cs_min *1.8 +$diff);
                                           }
                                           if ($cs_max ne "") {
                                               $cs_max = &ceil($cs_max *1.8 +$diff);
                                           }
                                           if ($cs_major ne "" && $cs_major ne "." && $cs_major ne "auto") {
                                               $cs_major = sprintf("%.4f", $cs_major*1.8);
                                               $cs_major =~ s/0+$//;
                                           }
                                       }
                                       $wt_oldunits = $wt_units;
                                     });
        }

        $row++;
        $scheme_frame->new_label(
                -text    => "Cell Width: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $scheme_frame->new_spinbox(
                -textvariable => \$cs_width,
                -state        => 'readonly',
                -font         => 'default',
                -from         => 10,
                -to           => 35,
                -increment    => 1,
                -width        => 3,
                )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $scheme_frame->new_label(
                -text    => "pixels wide",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

        $row++;
        $scheme_frame->new_label(
                -text    => "Cell Height: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $scheme_frame->new_spinbox(
                -textvariable => \$cs_height,
                -state        => 'readonly',
                -font         => 'default',
                -from         =>  2,
                -to           => 30,
                -increment    => 1,
                -width        => 3,
                )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $scheme_frame->new_label(
                -text    => "pixels high",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);
        $scheme_frame->g_grid_columnconfigure(2, -weight => 1);

#       Color key text tab
        $keytxt_tab = $grprops_notebook->new_frame();
        $grprops_notebook->add($keytxt_tab,
                -text      => "Key Text",
                -underline => 0,
                -sticky    => 'nsew',
                );

        $preview_keytxt = $keytxt_tab->new_canvas(
                -background  => &get_rgb_code($canvas_color),
                -width       => $pw,
                -height      => $ph,
                -borderwidth => 1,
                -relief      => 'groove',
                );
        $preview_keytxt->g_grid(-row => 0, -column => 0, -sticky => 'wne');

        $keytitle_txt = $preview_keytxt->create_text($pw*0.3 +3, $ph*0.5 +3,
                -anchor => 'center', 
                -text   => "Key Title",
                -fill   => "#000000",
                -angle  => 0,
                -font   => [-family     => $keyfont,
                            -size       => $kt_size,
                            -weight     => $kt_weight,
                            -slant      => 'roman',
                            -underline  => 0,
                            -overstrike => 0,
                           ]);
        $keynum_txt = $preview_keytxt->create_text($pw*0.7 +3, $ph*0.5 +3,
                -anchor => 'center', 
                -text   => sprintf($fmt, $cs_max),
                -fill   => "#000000",
                -angle  => 0,
                -font   => [-family     => $keyfont,
                            -size       => $kn_size,
                            -weight     => $kn_weight,
                            -slant      => 'roman',
                            -underline  => 0,
                            -overstrike => 0,
                           ]);

        $keytxt_frame = $keytxt_tab->new_frame(
                -borderwidth => 1,
                -relief      => 'groove',
                );
        $keytxt_frame->g_grid(-row => 1, -column => 0, -sticky => 'wnes');

        $row = 0;
        $keytxt_frame->new_label(
                -text => "Color Key Font: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($keyfont_cb = $keytxt_frame->new_ttk__combobox(
                -textvariable => \$keyfont,
                -values       => [ sort @available_fonts ],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $keyfont_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_keytxt->itemconfigure($keytitle_txt,
                              -font => [ -family     => $keyfont,
                                         -size       => $kt_size,
                                         -weight     => $kt_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                        $preview_keytxt->itemconfigure($keynum_txt,
                              -font => [ -family     => $keyfont,
                                         -size       => $kn_size,
                                         -weight     => $kn_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });
        $row++;
        $keytxt_frame->new_label(
                -text => "Key Title Size: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($kt_size_cb = $keytxt_frame->new_ttk__combobox(
                -textvariable => \$kt_size,
                -values       => [(5 .. 24)],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $kt_size_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_keytxt->itemconfigure($keytitle_txt,
                              -font => [ -family     => $keyfont,
                                         -size       => $kt_size,
                                         -weight     => $kt_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });
        $row++;
        $keytxt_frame->new_label(
                -text => "Key Title Weight: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($kt_weight_cb = $keytxt_frame->new_ttk__combobox(
                -textvariable => \$kt_weight,
                -values       => [("normal", "bold")],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $kt_weight_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_keytxt->itemconfigure($keytitle_txt,
                              -font => [ -family     => $keyfont,
                                         -size       => $kt_size,
                                         -weight     => $kt_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });
        $row++;
        $keytxt_frame->new_label(
                -text => "Key Scale Size: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($kn_size_cb = $keytxt_frame->new_ttk__combobox(
                -textvariable => \$kn_size,
                -values       => [(5 .. 24)],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $kn_size_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_keytxt->itemconfigure($keynum_txt,
                              -font => [ -family     => $keyfont,
                                         -size       => $kn_size,
                                         -weight     => $kn_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });
        $row++;
        $keytxt_frame->new_label(
                -text => "Key Scale Weight: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($kn_weight_cb = $keytxt_frame->new_ttk__combobox(
                -textvariable => \$kn_weight,
                -values       => [("normal", "bold")],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $kn_weight_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_keytxt->itemconfigure($keynum_txt,
                              -font => [ -family     => $keyfont,
                                         -size       => $kn_size,
                                         -weight     => $kn_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });
        $row++;
        $keytxt_frame->new_label(
                -text    => "Decimal Digits: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $keytxt_frame->new_spinbox(
                -textvariable => \$kn_digits,
                -state        => 'readonly',
                -font         => 'default',
                -from         => 0,
                -to           => 6,
                -increment    => 1,
                -width        => 3,
                -command      => sub { my ($fmt_w, $fmt);
                                       $fmt_w = length(int(abs($cs_max)));
                                       $fmt_w++ if ($cs_max < 0);
                                       if ($kn_digits > 0) {
                                           $fmt_w += $kn_digits +1;
                                           $fmt = "%${fmt_w}.${kn_digits}f";
                                       } else {
                                           $fmt = "%${fmt_w}d";
                                       }
                                       $preview_keytxt->itemconfigure($keynum_txt,
                                               -text => sprintf($fmt, $cs_max));
                                     },
                )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $row++;
        $keytxt_frame->new_label(
                -text    => "Color Key Title: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'w', -pady => 2);
        $row++;
        $keytxt_frame->new_entry(
                -textvariable => \$keytitle,
                -font         => 'default',
                )->g_grid(-row => $row, -column => 0, -columnspan => 2, -sticky => 'ew', -pady => 2);

        $keytxt_frame->g_grid_columnconfigure(0, -weight => 2);
    }

#   Legend tab
    if ($props{$id}{meta} =~ /time_series/) {
        $legtitle  = $gr_props{$id}{legtitle};
        $legfont   = $gr_props{$id}{legfont};
        $lt_size   = $gr_props{$id}{lt_size};
        $lt_weight = $gr_props{$id}{lt_weight};
        $le_size   = $gr_props{$id}{le_size};
        $le_weight = $gr_props{$id}{le_weight};
        $le_edge   = $gr_props{$id}{le_edge};
        $le_edgec  = $gr_props{$id}{le_edgec};
        $le_fill   = $gr_props{$id}{le_fill};
        $le_fillc  = $gr_props{$id}{le_fillc};

        if ($props{$id}{meta} eq "linked_time_series") {
            $link_id  = $props{$id}{link_id};
            %parms    = %{ $props{$id}{ts_parms} };
            $ts_type  = $parms{ts_type};
            @ts_show  = @{ $parms{show}  };
            @ts_width = @{ $parms{width} };
            @ts_color = @{ $parms{color} };
            if ($ts_type eq "Water Surface Elevation") {
                $label_txt = "WS Elev";
                $pre_width = $ts_width[0];
                $pre_color = $ts_color[0];
            } elsif ($ts_type eq "Flow") {
                @names = @{ $gr_props{$link_id}{names} };
                push (@names, "All Outlets");
                $i = &max(0, &list_match("1", @ts_show));
                $label_txt = $names[$i];
                $pre_width = $ts_width[$i];
                $pre_color = $ts_color[$i];
            } else {
                @names = @{ $gr_props{$link_id}{names} };
                push (@names, "All Outlets");
                $i = &max(0, &list_match("1", @ts_show));
                $label_txt = $names[$i];
                $pre_width = $ts_width[$i];
                $pre_color = $ts_color[$i];
            }
        } else {
            $label_txt = "legend entry";
            $pre_width = 1;
            $pre_color = "black";
        }

        $legend_tab = $grprops_notebook->new_frame();
        $grprops_notebook->add($legend_tab,
                -text      => "Legend",
                -underline => 0,
                -sticky    => 'nsew',
                );

        $preview_legend = $legend_tab->new_canvas(
                -background  => &get_rgb_code($canvas_color),
                -width       => $pw,
                -height      => $ph,
                -borderwidth => 1,
                -relief      => 'groove',
                );
        $preview_legend->g_grid(-row => 0, -column => 0, -sticky => 'wne');

        $legtitle_txt = $preview_legend->create_text($pw*0.25 +3, $ph*0.5 +3,
                -anchor => 'center', 
                -text   => "Title",
                -fill   => "#000000",
                -angle  => 0,
                -font   => [-family     => $legfont,
                            -size       => $lt_size,
                            -weight     => $lt_weight,
                            -slant      => 'roman',
                            -underline  => 0,
                            -overstrike => 0,
                           ]);
        $legend_line = $preview_legend->create_line($pw*0.6  -3, $ph*0.5 +3,
                                                    $pw*0.6 -23, $ph*0.5 +3,
                            -width => $pre_width,
                            -fill  => &get_rgb_code($pre_color),
                            -arrow => 'none');
        $legend_txt = $preview_legend->create_text($pw*0.6 +3, $ph*0.5 +3,
                -anchor => 'w', 
                -text   => $label_txt,
                -fill   => "#000000",
                -angle  => 0,
                -font   => [-family     => $legfont,
                            -size       => $le_size,
                            -weight     => $le_weight,
                            -slant      => 'roman',
                            -underline  => 0,
                            -overstrike => 0,
                           ]);

        @coords = Tkx::SplitList($preview_legend->bbox($legend_txt));
        $coords[0] -= 31;
        $coords[1] -=  4;
        $coords[2] +=  5;
        $coords[3] +=  4;
        if ($le_fill && $le_fillc ne "") {
            $legend_box = $preview_legend->create_rectangle(@coords,
                            -outline => "",
                            -width   => 0,
                            -fill    => &get_rgb_code($le_fillc));
        } else {
            $legend_box = $preview_legend->create_rectangle(@coords,
                            -outline => "",
                            -width   => 0,
                            -fill    => "");
        }
        if ($le_edge) {
            $preview_legend->itemconfigure($legend_box,
                            -width   => 1,
                            -outline => &get_rgb_code($le_edgec));
        }
        $preview_legend->lower($legend_box, $legend_line);

        $legend_frame = $legend_tab->new_frame(
                -borderwidth => 1,
                -relief      => 'groove',
                );
        $legend_frame->g_grid(-row => 1, -column => 0, -sticky => 'wnes');

        $row = 0;
        $legend_frame->new_label(
                -text => "Legend Font: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($legfont_cb = $legend_frame->new_ttk__combobox(
                -textvariable => \$legfont,
                -values       => [ sort @available_fonts ],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
        $legfont_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_legend->itemconfigure($legtitle_txt,
                              -font => [ -family     => $legfont,
                                         -size       => $lt_size,
                                         -weight     => $lt_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                        $preview_legend->itemconfigure($legend_txt,
                              -font => [ -family     => $legfont,
                                         -size       => $le_size,
                                         -weight     => $le_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                        if (defined($props{$id}{add_ts_parms})) {
                            if ($#add_ts_setnum >= 0) {
                                $preview_tsdata->itemconfigure($tsdata_txt,
                                      -font => [ -family     => $legfont,
                                                 -size       => $le_size,
                                                 -weight     => $le_weight,
                                                 -slant      => 'roman',
                                                 -underline  => 0,
                                                 -overstrike => 0,
                                               ]);
                                @coords = Tkx::SplitList($preview_tsdata->bbox($tsdata_txt));
                                $preview_tsdata->coords($tsdata_line,
                                                        $coords[0]  -6, $ph*0.5 +3,
                                                        $coords[0] -26, $ph*0.5 +3);
                            }
                        }
                        @coords = Tkx::SplitList($preview_legend->bbox($legend_txt));
                        $preview_legend->coords($legend_box,
                                                $coords[0] -31, $coords[1] -4,
                                                $coords[2] + 5, $coords[3] +4);
                      });
        $row++;
        $legend_frame->new_label(
                -text => "Title/Entry Size: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($lt_size_cb = $legend_frame->new_ttk__combobox(
                -textvariable => \$lt_size,
                -values       => [(5 .. 24)],
                -width        => 5,
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
        $lt_size_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_legend->itemconfigure($legtitle_txt,
                              -font => [ -family     => $legfont,
                                         -size       => $lt_size,
                                         -weight     => $lt_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });
        ($le_size_cb = $legend_frame->new_ttk__combobox(
                -textvariable => \$le_size,
                -values       => [(5 .. 24)],
                -width        => 5,
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 2, -sticky => 'ew', -pady => 2);
        $le_size_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_legend->itemconfigure($legend_txt,
                              -font => [ -family     => $legfont,
                                         -size       => $le_size,
                                         -weight     => $le_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                        if (defined($props{$id}{add_ts_parms})) {
                            if ($#add_ts_setnum >= 0) {
                                $preview_tsdata->itemconfigure($tsdata_txt,
                                      -font => [ -family     => $legfont,
                                                 -size       => $le_size,
                                                 -weight     => $le_weight,
                                                 -slant      => 'roman',
                                                 -underline  => 0,
                                                 -overstrike => 0,
                                               ]);
                                @coords = Tkx::SplitList($preview_tsdata->bbox($tsdata_txt));
                                $preview_tsdata->coords($tsdata_line,
                                                        $coords[0]  -6, $ph*0.5 +3,
                                                        $coords[0] -26, $ph*0.5 +3);
                            }
                        }
                        @coords = Tkx::SplitList($preview_legend->bbox($legend_txt));
                        $preview_legend->coords($legend_box,
                                                $coords[0] -31, $coords[1] -4,
                                                $coords[2] + 5, $coords[3] +4);
                      });

        $row++;
        $legend_frame->new_label(
                -text => "Title/Entry Weight: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($lt_weight_cb = $legend_frame->new_ttk__combobox(
                -textvariable => \$lt_weight,
                -values       => [("normal", "bold")],
                -width        => 5,
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
        $lt_weight_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_legend->itemconfigure($legtitle_txt,
                              -font => [ -family     => $legfont,
                                         -size       => $lt_size,
                                         -weight     => $lt_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });
        ($le_weight_cb = $legend_frame->new_ttk__combobox(
                -textvariable => \$le_weight,
                -values       => [("normal", "bold")],
                -width        => 5,
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 2, -sticky => 'ew', -pady => 2);
        $le_weight_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_legend->itemconfigure($legend_txt,
                              -font => [ -family     => $legfont,
                                         -size       => $le_size,
                                         -weight     => $le_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                        if (defined($props{$id}{add_ts_parms})) {
                            if ($#add_ts_setnum >= 0) {
                                $preview_tsdata->itemconfigure($tsdata_txt,
                                      -font => [ -family     => $legfont,
                                                 -size       => $le_size,
                                                 -weight     => $le_weight,
                                                 -slant      => 'roman',
                                                 -underline  => 0,
                                                 -overstrike => 0,
                                               ]);
                                @coords = Tkx::SplitList($preview_tsdata->bbox($tsdata_txt));
                                $preview_tsdata->coords($tsdata_line,
                                                        $coords[0]  -6, $ph*0.5 +3,
                                                        $coords[0] -26, $ph*0.5 +3);
                            }
                        }
                        @coords = Tkx::SplitList($preview_legend->bbox($legend_txt));
                        $preview_legend->coords($legend_box,
                                                $coords[0] -31, $coords[1] -4,
                                                $coords[2] + 5, $coords[3] +4);
                      });

        $row++;
        $legend_frame->new_label(
                -text => "Legend Box Outline: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $legend_frame->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "Show",
                -font     => 'default',
                -variable => \$le_edge,
                -command  => sub { if ($le_edge) {
                                       $le_edgec_btn->configure(-state => 'normal');
                                       $preview_legend->itemconfigure($legend_box, -width => 1,
                                                        -outline => &get_rgb_code($le_edgec));
                                   } else {
                                       $le_edgec_btn->configure(-state => 'disabled');
                                       $preview_legend->itemconfigure($legend_box,
                                                        -width => 0, -outline => "");
                                   }
                                 },
                )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

        $code     = &get_rgb_code($le_edgec);
        $le_edgec = &get_rgb_name($code);
        $fg       = &get_rgb_code("black");
        if ($code =~ /^\#[0-9a-f]/i) {
            $fg = &get_rgb_code(&get_bw_contrast($code));
        }
        ($le_edgec_btn = $legend_frame->new_button(
                -textvariable => \$le_edgec,
                -background   => $code,
                -foreground   => $fg,
                -width        => -7,
                -command => sub { my ($newc, $code, $fg);
                                  $code = &get_rgb_code($le_edgec);
                                  $newc = Tkx::tk___chooseColor(
                                             -initialcolor => $code,
                                             -parent       => $graph_props_menu);
                                  if ($newc) {
                                      $code     = &get_rgb_code($newc);
                                      $le_edgec = &get_rgb_name($code);
                                      $fg       = &get_rgb_code("black");
                                      if ($code =~ /^#?[0-9a-f]/i) {
                                          $fg = &get_rgb_code(&get_bw_contrast($code));
                                      }
                                      $le_edgec_btn->configure(-foreground => $fg,
                                                               -background => $code);
                                      $preview_legend->itemconfigure($legend_box, -outline => $code);
                                  }
                                }
                ))->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);
        if (! $le_edge) {
            $le_edgec_btn->configure(-state => 'disabled');
        }

        $row++;
        $legend_frame->new_label(
                -text => "Legend Box Fill: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $legend_frame->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "Show",
                -font     => 'default',
                -variable => \$le_fill,
                -command  => sub { if ($le_fill) {
                                       $le_fillc_btn->configure(-state => 'normal');
                                       $preview_legend->itemconfigure($legend_box,
                                                        -fill => &get_rgb_code($le_fillc));
                                   } else {
                                       $le_fillc_btn->configure(-state => 'disabled');
                                       $preview_legend->itemconfigure($legend_box, -fill => "");
                                   }
                                 },
                )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

        $code     = &get_rgb_code($le_fillc);
        $le_fillc = &get_rgb_name($code);
        $fg       = &get_rgb_code("black");
        if ($code =~ /^\#[0-9a-f]/i) {
            $fg = &get_rgb_code(&get_bw_contrast($code));
        }
        ($le_fillc_btn = $legend_frame->new_button(
                -textvariable => \$le_fillc,
                -background   => $code,
                -foreground   => $fg,
                -width        => -7,
                -command => sub { my ($newc, $code, $fg);
                                  $code = &get_rgb_code($le_fillc);
                                  $newc = Tkx::tk___chooseColor(
                                             -initialcolor => $code,
                                             -parent       => $graph_props_menu);
                                  if ($newc) {
                                      $code     = &get_rgb_code($newc);
                                      $le_fillc = &get_rgb_name($code);
                                      $fg       = &get_rgb_code("black");
                                      if ($code =~ /^#?[0-9a-f]/i) {
                                          $fg = &get_rgb_code(&get_bw_contrast($code));
                                      }
                                      $le_fillc_btn->configure(-foreground => $fg,
                                                               -background => $code);
                                      $preview_legend->itemconfigure($legend_box, -fill => $code);
                                  }
                                }
                ))->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);
        if (! $le_fill) {
            $le_fillc_btn->configure(-state => 'disabled');
        }

        if ($props{$id}{meta} eq "linked_time_series") {
            if ($ts_type eq "Water Surface Elevation") {
                $row++;
                $legend_frame->new_label(
                        -text => "Line Width: ",
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
                $legend_frame->new_spinbox(
                        -textvariable => \$ts_width[0],
                        -state        => 'readonly',
                        -font         => 'default',
                        -from         => 1,
                        -to           => 10,
                        -increment    => 1,
                        -width        => 3,
                        -command      => sub { $preview_legend->itemconfigure($legend_line,
                                                     -width => $ts_width[0]);
                                             }
                        )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

                $row++;
                $legend_frame->new_label(
                        -text => "Line Color: ",
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);

                $code        = &get_rgb_code($ts_color[0]);
                $ts_color[0] = &get_rgb_name($code);
                $fg          = &get_rgb_code("black");
                if ($code =~ /^\#[0-9a-f]/i) {
                    $fg = &get_rgb_code(&get_bw_contrast($code));
                }
                ($color_btn = $legend_frame->new_button(
                        -textvariable => \$ts_color[0],
                        -background   => $code,
                        -foreground   => $fg,
                        -width        => -7,
                        -command => sub { my ($newc, $code, $fg);
                                          $code = &get_rgb_code($ts_color[0]);
                                          $newc = Tkx::tk___chooseColor(
                                                     -initialcolor => $code,
                                                     -parent       => $graph_props_menu);
                                          if ($newc) {
                                              $code        = &get_rgb_code($newc);
                                              $ts_color[0] = &get_rgb_name($code);
                                              $fg          = &get_rgb_code("black");
                                              if ($code =~ /^#?[0-9a-f]/i) {
                                                  $fg = &get_rgb_code(&get_bw_contrast($code));
                                              }
                                              $color_btn->configure(-foreground => $fg,
                                                                    -background => $code);
                                              $preview_legend->itemconfigure($legend_line,
                                                                    -fill => $code);
                                          }
                                        }
                        ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

            } else {
                $row++;
                ($outlet_frame = $legend_frame->new_frame(
                        -borderwidth => 1,
                        -relief      => 'groove',
                        ))->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew', -pady => 2);

                $row2 = 0;
                $outlet_frame->new_label(
                        -text => "Outlet",
                        -font => 'default',
                        )->g_grid(-row => $row2, -column => 0, -sticky => 'ew', -pady => 2);
                $outlet_frame->new_label(
                        -text => "Width  ",
                        -font => 'default',
                        )->g_grid(-row => $row2, -column => 1, -sticky => 'ew', -pady => 2);
                $outlet_frame->new_label(
                        -text => "  Color  ",
                        -font => 'default',
                        )->g_grid(-row => $row2, -column => 2, -sticky => 'ew', -pady => 2);
        
                for ($n=0; $n<=$#names; $n++) {
                    $row2++;
                    $outlet_frame->new_checkbutton(
                        -onvalue  => 1,
                        -offvalue => 0,
                        -text     => $names[$n],
                        -font     => 'default',
                        -variable => \$ts_show[$n],
                        -command  => [ sub { my ($nn) = @_;
                                             my ($i);
                                             if ($ts_show[$nn]) {
                                                 $width_sbs[$nn]->configure(-state  => 'normal');
                                                 $color_btns[$nn]->configure(-state => 'normal');
                                             } else {
                                                 $width_sbs[$nn]->configure(-state  => 'disabled');
                                                 $color_btns[$nn]->configure(-state => 'disabled');
                                             }
                                             for ($i=0; $i<=$#names; $i++) {
                                                 if ($ts_show[$i]) {
                                                     $preview_legend->itemconfigure($legend_line,
                                                             -width => $ts_width[$i],
                                                             -fill  => &get_rgb_code($ts_color[$i]));
                                                     $preview_legend->itemconfigure($legend_txt,
                                                             -text => $names[$i]);
                                                     last;
                                                 }
                                             }
                                           }, $n ]
                            )->g_grid(-row => $row2, -column => 0, -sticky => 'w', -pady => 2);
                    ($width_sbs[$n] = $outlet_frame->new_spinbox(
                        -textvariable => \$ts_width[$n],
                        -state        => 'readonly',
                        -font         => 'default',
                        -from         => 1,
                        -to           => 10,
                        -increment    => 1,
                        -width        => 3,
                        -command      => [ sub { my ($nn) = @_;
                                                 my ($i);
                                                 for ($i=0; $i<=$#names; $i++) {
                                                     if ($ts_show[$i]) {
                                                         if ($i == $nn) {
                                                             $preview_legend->itemconfigure($legend_line,
                                                                     -width => $ts_width[$i]);
                                                         }
                                                         last;
                                                     }
                                                 }
                                               }, $n ]
                            ))->g_grid(-row => $row2, -column => 1, -sticky => 'w', -padx => 4, -pady => 2);
        
                    $code         = &get_rgb_code($ts_color[$n]);
                    $ts_color[$n] = &get_rgb_name($code);
                    $fg           = &get_rgb_code("black");
                    if ($code =~ /^\#[0-9a-f]/i) {
                        $fg = &get_rgb_code(&get_bw_contrast($code));
                    }
                    ($color_btns[$n] = $outlet_frame->new_button(
                        -textvariable => \$ts_color[$n],
                        -background   => $code,
                        -foreground   => $fg,
                        -width        => -7,
                        -command => [ sub { my ($nn) = @_;
                                            my ($newc, $code, $fg, $i);
                                            $code = &get_rgb_code($ts_color[$nn]);
                                            $newc = Tkx::tk___chooseColor(
                                                       -initialcolor => $code,
                                                       -parent       => $graph_props_menu);
                                            if ($newc) {
                                                $code          = &get_rgb_code($newc);
                                                $ts_color[$nn] = &get_rgb_name($code);
                                                $fg            = &get_rgb_code("black");
                                                if ($code =~ /^#?[0-9a-f]/i) {
                                                    $fg = &get_rgb_code(&get_bw_contrast($code));
                                                }
                                                $color_btns[$nn]->configure(-foreground => $fg,
                                                                            -background => $code);
                                                for ($i=0; $i<=$#names; $i++) {
                                                    if ($ts_show[$i]) {
                                                        if ($i == $nn) {
                                                            $preview_legend->itemconfigure($legend_line,
                                                                -fill => &get_rgb_code($ts_color[$i]));
                                                        }
                                                        last;
                                                    }
                                                }
                                            }
                                          }, $n ]
                            ))->g_grid(-row => $row2, -column => 2, -sticky => 'ew', -pady => 0);
                    if ($ts_show[$n]) {
                        $width_sbs[$n]->configure(-state  => 'normal');
                        $color_btns[$n]->configure(-state => 'normal');
                    } else {
                        $width_sbs[$n]->configure(-state  => 'disabled');
                        $color_btns[$n]->configure(-state => 'disabled');
                    }
                }
            }
        }

        $row++;
        $legend_frame->new_label(
                -text    => "Optional Legend Title: ",
                -font    => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'w', -pady => 2);
        $row++;
        $legend_frame->new_entry(
                -textvariable => \$legtitle,
                -font         => 'default',
                )->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew', -pady => 2);

        $legend_frame->g_grid_columnconfigure(0, -weight => 2);
    }

#   Additional time-series dataset tab
    if (defined($props{$id}{add_ts_parms})) {
        %add_ts_parms  = %{ $props{$id}{add_ts_parms} };
        @add_ts_setnum = @{ $add_ts_parms{ts_setnum}  };
        @add_ts_show   = @{ $add_ts_parms{ts_show}    };
        @add_ts_width  = @{ $add_ts_parms{ts_width}   };
        @add_ts_color  = @{ $add_ts_parms{ts_color}   };
        @add_ts_text   = @{ $add_ts_parms{ts_text}    };
        @add_ts_file   = @{ $add_ts_parms{ts_file}    };
        @add_ts_ftype  = @{ $add_ts_parms{ts_ftype}   };
        @add_ts_lines  = @{ $add_ts_parms{ts_lines}   };
        @add_ts_param  = @{ $add_ts_parms{ts_param}   };
        @add_ts_byear  = @{ $add_ts_parms{ts_byear}   };
        @add_ts_tzoff  = @{ $add_ts_parms{ts_tzoff}   };
        @add_ts_seg    = @{ $add_ts_parms{ts_seg}     };
        @add_ts_ctype  = @{ $add_ts_parms{ts_ctype}   };
        @add_ts_limits = @{ $add_ts_parms{ts_limits}  };
        @add_ts_tsdata = @{ $add_ts_parms{ts_data}    };
        @add_ts_delete = (0) x @add_ts_setnum;
        $gap_tol       = $gr_props{$id}{gap_tol};

        if ($#add_ts_setnum >= 0) {
            $indx     = &max(0, &list_match("1", @add_ts_show));
            $up_img   = Tkx::image_create_photo(-file => "${prog_path}images/up.png");
            $down_img = Tkx::image_create_photo(-file => "${prog_path}images/down.png");

            $tsdata_tab = $grprops_notebook->new_frame();
            $grprops_notebook->add($tsdata_tab,
                    -text      => "TS Data",
                    -underline => 0,
                    -sticky    => 'nsew',
                    );

            $preview_tsdata = $tsdata_tab->new_canvas(
                    -background  => &get_rgb_code($canvas_color),
                    -width       => $pw,
                    -height      => $ph,
                    -borderwidth => 1,
                    -relief      => 'groove',
                    );
            $preview_tsdata->g_grid(-row => 0, -column => 0, -sticky => 'wne');

            $tsdata_txt = $preview_tsdata->create_text($pw*0.55 +3, $ph*0.5 +3,
                                -anchor => 'center', 
                                -text   => $add_ts_text[$indx],
                                -fill   => "#000000",
                                -angle  => 0,
                                -font   => [-family     => $legfont,
                                            -size       => $le_size,
                                            -weight     => $le_weight,
                                            -slant      => 'roman',
                                            -underline  => 0,
                                            -overstrike => 0,
                                           ]);
            ($tsxmin, undef, undef, undef) = Tkx::SplitList($preview_tsdata->bbox($tsdata_txt));
            $tsdata_line = $preview_tsdata->create_line($tsxmin  -6, $ph*0.5 +3,
                                                        $tsxmin -26, $ph*0.5 +3,
                                -width => $add_ts_width[$indx],
                                -fill  => &get_rgb_code($add_ts_color[$indx]),
                                -arrow => 'none');

            $tsdata_frame = $tsdata_tab->new_frame(
                    -borderwidth => 1,
                    -relief      => 'groove',
                    );
            $tsdata_frame->g_grid(-row => 1, -column => 0, -sticky => 'wnes');

            if ($props{$id}{meta} eq "linked_time_series") {
                $tsdata_frame->new_label(
                        -text   => "Additional Time-Series Datasets:",
                        -anchor => 'w',
                        -font   => 'default',
                        )->g_grid(-row => 0, -column => 0, -sticky => 'ew', -pady => 2);
            } else {
                $tsdata_frame->new_label(
                        -text   => "Time-Series Datasets:",
                        -anchor => 'w',
                        -font   => 'default',
                        )->g_grid(-row => 0, -column => 0, -sticky => 'ew', -pady => 2);
            }

          # Need a scrollable container, and a canvas is about the only container that works.
          # Create a parent frame (sc_fr) for the canvas (sc_canv) and scrollbar (vscroll).
          # Put a frame inside the canvas (scroll_frame) as a widget window to hold other menu items.
            ($sc_fr = $tsdata_frame->new_frame(
                    -borderwidth => 0,
                    -relief      => 'flat',
                    ))->g_grid(-row => 1, -column => 0, -sticky => 'wnes');
            ($vscroll = $sc_fr->new_scrollbar(
                    -orient => 'vertical',
                    -width  => 15,
                    ))->g_grid(-row => 0, -column => 1, -sticky => 'nse');
            ($sc_canv = $sc_fr->new_tk__canvas(
                    -highlightthickness => 0,
                    -yscrollcommand => [$vscroll, 'set'],
                    ))->g_grid(-row => 0, -column => 0, -sticky => 'nsew');
            $vscroll->configure(-command => [$sc_canv, 'yview']);
        
            $scroll_frame = $sc_canv->new_frame(
                    -borderwidth => 0,
                    -relief      => 'flat',
                    );

            $row = 0;
            $scroll_frame->new_label(
                    -text => "Set",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'ew', -pady => 2);
            $scroll_frame->new_label(
                    -text => "Width ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
            $scroll_frame->new_label(
                    -text => "  Color  ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 2, -sticky => 'ew', -pady => 2);
            $scroll_frame->new_label(
                    -text => "Delete",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 3, -sticky => 'ew', -pady => 2);
            $scroll_frame->new_label(
                    -text => "Order",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 4, -columnspan => 2, -sticky => 'ew', -pady => 2);

            for ($i=0; $i<=$#add_ts_setnum; $i++) {
                $row++;
                $scroll_frame->new_checkbutton(
                        -onvalue  => 1,
                        -offvalue => 0,
                        -text     => $add_ts_setnum[$i],
                        -font     => 'default',
                        -variable => \$add_ts_show[$i],
                        -command  => [ sub { my ($n) = @_;
                                             my ($indx);
                                             if ($add_ts_show[$n]) {
                                                 $ts_width_sbs[$n]->configure(-state  => 'readonly');
                                                 $ts_color_btns[$n]->configure(-state => 'normal');
                                                 $ts_text_entry[$n]->configure(-state => 'normal');
                                             } else {
                                                 $ts_width_sbs[$n]->configure(-state  => 'disabled');
                                                 $ts_color_btns[$n]->configure(-state => 'disabled');
                                                 $ts_text_entry[$n]->configure(-state => 'disabled');
                                             }
                                             $indx = &max(0, &list_match("1", @add_ts_show));
                                             $preview_tsdata->itemconfigure($tsdata_line,
                                                         -width => $add_ts_width[$indx],
                                                         -fill  => &get_rgb_code($add_ts_color[$indx]));
                                             $preview_tsdata->itemconfigure($tsdata_txt,
                                                         -text  => $add_ts_text[$indx]);
                                             @coords = Tkx::SplitList($preview_tsdata->bbox($tsdata_txt));
                                             $preview_tsdata->coords($tsdata_line,
                                                                     $coords[0]  -6, $ph*0.5 +3,
                                                                     $coords[0] -26, $ph*0.5 +3);
                                           }, $i ]
                        )->g_grid(-row => $row, -rowspan => 2, -column => 0, -sticky => 'e', -pady => 2);
                ($ts_width_sbs[$i] = $scroll_frame->new_spinbox(
                        -textvariable => \$add_ts_width[$i],
                        -state        => 'readonly',
                        -font         => 'default',
                        -from         => 1,
                        -to           => 10,
                        -increment    => 1,
                        -width        => 3,
                        -command      => [ sub { my ($n) = @_;
                                                 if ($n == &max(0, &list_match("1", @add_ts_show))) {
                                                     $preview_tsdata->itemconfigure($tsdata_line,
                                                             -width => $add_ts_width[$n]);
                                                 }
                                               }, $i ]
                        ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -padx => 4, -pady => 2);

                $code             = &get_rgb_code($add_ts_color[$i]);
                $add_ts_color[$i] = &get_rgb_name($code);
                $fg               = &get_rgb_code("black");
                if ($code =~ /^\#[0-9a-f]/i) {
                    $fg = &get_rgb_code(&get_bw_contrast($code));
                }
                ($ts_color_btns[$i] = $scroll_frame->new_button(
                        -textvariable => \$add_ts_color[$i],
                        -background   => $code,
                        -foreground   => $fg,
                        -width        => -7,
                        -command => [ sub { my ($n) = @_;
                                            my ($newc, $code, $fg);
                                            $code = &get_rgb_code($add_ts_color[$n]);
                                            $newc = Tkx::tk___chooseColor(
                                                       -initialcolor => $code,
                                                       -parent       => $graph_props_menu);
                                            if ($newc) {
                                                $code             = &get_rgb_code($newc);
                                                $add_ts_color[$n] = &get_rgb_name($code);
                                                $fg               = &get_rgb_code("black");
                                                if ($code =~ /^#?[0-9a-f]/i) {
                                                    $fg = &get_rgb_code(&get_bw_contrast($code));
                                                }
                                                $ts_color_btns[$n]->configure(-foreground => $fg,
                                                                              -background => $code);
                                                if ($n == &max(0, &list_match("1", @add_ts_show))) {
                                                    $preview_tsdata->itemconfigure($tsdata_line,
                                                            -fill => &get_rgb_code($add_ts_color[$n]));
                                                }
                                            }
                                          }, $i ]
                        ))->g_grid(-row => $row, -column => 2, -sticky => 'ew', -pady => 0);

                $scroll_frame->new_checkbutton(
                        -onvalue  => 1,
                        -offvalue => 0,
                        -text     => "Delete",
                        -font     => 'default',
                        -variable => \$add_ts_delete[$i],
                        )->g_grid(-row => $row, -column => 3, -sticky => 'e', -pady => 2);

                ($down_btn[$i] = $scroll_frame->new_button(
                        -repeatdelay    => 10000,
                        -repeatinterval => 10000,
                        -image   => $down_img,
                        -command => [ sub { my ($n) = @_;
                                            my ($code, $fg, $nn, $state);
                                            $swapsets = 1;

                                            @add_ts_show[$n,$n+1]   = @add_ts_show[$n+1,$n];
                                            @add_ts_width[$n,$n+1]  = @add_ts_width[$n+1,$n];
                                            @add_ts_color[$n,$n+1]  = @add_ts_color[$n+1,$n];
                                            @add_ts_delete[$n,$n+1] = @add_ts_delete[$n+1,$n];
                                            @add_ts_text[$n,$n+1]   = @add_ts_text[$n+1,$n];
                                            @add_ts_file[$n,$n+1]   = @add_ts_file[$n+1,$n];
                                            @add_ts_ftype[$n,$n+1]  = @add_ts_ftype[$n+1,$n];
                                            @add_ts_lines[$n,$n+1]  = @add_ts_lines[$n+1,$n];
                                            @add_ts_param[$n,$n+1]  = @add_ts_param[$n+1,$n];
                                            @add_ts_byear[$n,$n+1]  = @add_ts_byear[$n+1,$n];
                                            @add_ts_tzoff[$n,$n+1]  = @add_ts_tzoff[$n+1,$n];
                                            @add_ts_seg[$n,$n+1]    = @add_ts_seg[$n+1,$n];
                                            @add_ts_ctype[$n,$n+1]  = @add_ts_ctype[$n+1,$n];
                                            @add_ts_limits[$n,$n+1] = @add_ts_limits[$n+1,$n];
                                            @add_ts_tsdata[$n,$n+1] = @add_ts_tsdata[$n+1,$n];

                                            $code = &get_rgb_code($add_ts_color[$n]);
                                            $fg   = &get_rgb_code("black");
                                            if ($code =~ /^#?[0-9a-f]/i) {
                                                $fg = &get_rgb_code(&get_bw_contrast($code));
                                            }
                                            $ts_color_btns[$n]->configure(-foreground => $fg,
                                                                          -background => $code);
                                            $code = &get_rgb_code($add_ts_color[$n+1]);
                                            $fg   = &get_rgb_code("black");
                                            if ($code =~ /^#?[0-9a-f]/i) {
                                                $fg = &get_rgb_code(&get_bw_contrast($code));
                                            }
                                            $ts_color_btns[$n+1]->configure(-foreground => $fg,
                                                                            -background => $code);
                                            for ($nn=$n; $nn<=$n+1; $nn++) {
                                                $state = ($add_ts_show[$nn]) ? 'readonly' : 'disabled';
                                                $ts_width_sbs[$nn]->configure(-state  => $state);
                                                $state = ($add_ts_show[$nn]) ? 'normal' : 'disabled';
                                                $ts_color_btns[$nn]->configure(-state => $state);
                                                $ts_text_entry[$nn]->configure(-state => $state);
                                            }
                                            $n = &max(0, &list_match("1", @add_ts_show));
                                            $preview_tsdata->itemconfigure($tsdata_line,
                                                        -fill => &get_rgb_code($add_ts_color[$n]));
                                            $preview_tsdata->itemconfigure($tsdata_txt,
                                                                      -text => $add_ts_text[$n]);
                                            @coords = Tkx::SplitList($preview_tsdata->bbox($tsdata_txt));
                                            $preview_tsdata->coords($tsdata_line,
                                                                    $coords[0]  -6, $ph*0.5 +3,
                                                                    $coords[0] -26, $ph*0.5 +3);
                                          }, $i ]
                        ))->g_grid(-row => $row, -column => 4, -sticky => 'e', -pady => 2);
                ($up_btn[$i] = $scroll_frame->new_button(
                        -repeatdelay    => 10000,
                        -repeatinterval => 10000,
                        -image   => $up_img,
                        -command => [ sub { my ($n) = @_;
                                            my ($code, $fg, $nn, $state);
                                            $swapsets = 1;

                                            @add_ts_show[$n,$n-1]   = @add_ts_show[$n-1,$n];
                                            @add_ts_width[$n,$n-1]  = @add_ts_width[$n-1,$n];
                                            @add_ts_color[$n,$n-1]  = @add_ts_color[$n-1,$n];
                                            @add_ts_delete[$n,$n-1] = @add_ts_delete[$n-1,$n];
                                            @add_ts_text[$n,$n-1]   = @add_ts_text[$n-1,$n];
                                            @add_ts_file[$n,$n-1]   = @add_ts_file[$n-1,$n];
                                            @add_ts_ftype[$n,$n-1]  = @add_ts_ftype[$n-1,$n];
                                            @add_ts_lines[$n,$n-1]  = @add_ts_lines[$n-1,$n];
                                            @add_ts_param[$n,$n-1]  = @add_ts_param[$n-1,$n];
                                            @add_ts_byear[$n,$n-1]  = @add_ts_byear[$n-1,$n];
                                            @add_ts_tzoff[$n,$n-1]  = @add_ts_tzoff[$n-1,$n];
                                            @add_ts_seg[$n,$n-1]    = @add_ts_seg[$n-1,$n];
                                            @add_ts_ctype[$n,$n-1]  = @add_ts_ctype[$n-1,$n];
                                            @add_ts_limits[$n,$n-1] = @add_ts_limits[$n-1,$n];
                                            @add_ts_tsdata[$n,$n-1] = @add_ts_tsdata[$n-1,$n];

                                            $code = &get_rgb_code($add_ts_color[$n]);
                                            $fg   = &get_rgb_code("black");
                                            if ($code =~ /^#?[0-9a-f]/i) {
                                                $fg = &get_rgb_code(&get_bw_contrast($code));
                                            }
                                            $ts_color_btns[$n]->configure(-foreground => $fg,
                                                                          -background => $code);
                                            $code = &get_rgb_code($add_ts_color[$n-1]);
                                            $fg   = &get_rgb_code("black");
                                            if ($code =~ /^#?[0-9a-f]/i) {
                                                $fg = &get_rgb_code(&get_bw_contrast($code));
                                            }
                                            $ts_color_btns[$n-1]->configure(-foreground => $fg,
                                                                            -background => $code);
                                            for ($nn=$n-1; $nn<=$n; $nn++) {
                                                $state = ($add_ts_show[$nn]) ? 'readonly' : 'disabled';
                                                $ts_width_sbs[$nn]->configure(-state  => $state);
                                                $state = ($add_ts_show[$nn]) ? 'normal' : 'disabled';
                                                $ts_color_btns[$nn]->configure(-state => $state);
                                                $ts_text_entry[$nn]->configure(-state => $state);
                                            }
                                            $n = &max(0, &list_match("1", @add_ts_show));
                                            $preview_tsdata->itemconfigure($tsdata_line,
                                                        -fill => &get_rgb_code($add_ts_color[$n]));
                                            $preview_tsdata->itemconfigure($tsdata_txt,
                                                                      -text => $add_ts_text[$n]);
                                            @coords = Tkx::SplitList($preview_tsdata->bbox($tsdata_txt));
                                            $preview_tsdata->coords($tsdata_line,
                                                                    $coords[0]  -6, $ph*0.5 +3,
                                                                    $coords[0] -26, $ph*0.5 +3);
                                          }, $i ]
                        ))->g_grid(-row => $row, -column => 5, -sticky => 'e', -pady => 2);

                $row++;
                ($ts_text_entry[$i] = $scroll_frame->new_entry(
                        -textvariable => \$add_ts_text[$i],
                        -font         => 'default',
                        ))->g_grid(-row => $row, -column => 1, -columnspan => 5, -sticky => 'ew', -pady => 2);
                $ts_text_entry[$i]->g_bind("<KeyRelease>",
                                     [ sub { my ($n) = @_;
                                             if ($n == &max(0, &list_match("1", @add_ts_show))) {
                                                 $preview_tsdata->itemconfigure($tsdata_txt,
                                                                      -text => $add_ts_text[$n]);
                                                 @coords = Tkx::SplitList($preview_tsdata->bbox($tsdata_txt));
                                                 $preview_tsdata->coords($tsdata_line,
                                                                         $coords[0]  -6, $ph*0.5 +3,
                                                                         $coords[0] -26, $ph*0.5 +3);
                                             }
                                           }, $i ]);

                if ($add_ts_show[$i]) {
                    $ts_width_sbs[$i]->configure(-state  => 'readonly');
                    $ts_color_btns[$i]->configure(-state => 'normal');
                    $ts_text_entry[$i]->configure(-state => 'normal');
                } else {
                    $ts_width_sbs[$i]->configure(-state  => 'disabled');
                    $ts_color_btns[$i]->configure(-state => 'disabled');
                    $ts_text_entry[$i]->configure(-state => 'disabled');
                }
            }
            $scroll_frame->g_grid_columnconfigure(4, -weight => 2);
            $up_btn[0]->configure(-state => 'disabled');
            $down_btn[$#add_ts_setnum]->configure(-state => 'disabled');

            ($gaptol_frame = $tsdata_frame->new_frame(
                    -borderwidth => 1,
                    -relief      => 'groove',
                    ))->g_grid(-row => 2, -column => 0, -sticky => 'ew', -pady => 2);
            $gaptol_frame->new_label(
                    -text => "Gap Tolerance: ",
                    -font => 'default',
                    )->g_pack(-side => 'left', -pady => 2);
            ($gaptol_entry = $gaptol_frame->new_entry(
                    -textvariable => \$gap_tol,
                    -font         => 'default',
                    -width        => 10,
                    ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
            $gaptol_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($gaptol_entry);
                                                        $gap_tol =~ s/^-//;
                                                      });
            $gaptol_frame->new_label(
                    -text => " days",
                    -font => 'default',
                    )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);

            $sc_canv->create_window(0, 0,
                    -anchor => 'nw',
                    -window => $scroll_frame,
                    -tags   => 'scrollable',
                    );
            &update_scrollable_tab($graph_props_menu, $sc_fr, $sc_canv, 'scrollable', $vscroll);
            $sc_fr->g_grid_columnconfigure(0, -weight => 1);
        }
    }

#   Grid tab for time-series graphs
    if ($props{$id}{meta} =~ /time_series/) {
        if (defined($gr_props{$id}{gridx})) {
            $gridx     = $gr_props{$id}{gridx};
            $gridy     = $gr_props{$id}{gridy};
            $gridcolor = $gr_props{$id}{gridcolor};
            $gridwidth = $gr_props{$id}{gridwidth};
        } else {
            $gridx     = $gridy = 0;
            $gridcolor = '#C0C0C0';
            $gridwidth = 1;
        }

        $grid_tab = $grprops_notebook->new_frame();
        $grprops_notebook->add($grid_tab,
                -text      => "Grid",
                -underline => 0,
                -sticky    => 'nsew',
                );

        $preview_grid = $grid_tab->new_canvas(
                -background  => &get_rgb_code($canvas_color),
                -width       => $pw,
                -height      => $ph,
                -borderwidth => 1,
                -relief      => 'groove',
                );
        $preview_grid->g_grid(-row => 0, -column => 0, -sticky => 'wne');

        $xgrid_line1 = $preview_grid->create_line($pw*0.25 +3, $ph*0.1 +3,
                                                  $pw*0.25 +3, $ph*0.9 +3,
                                      -width => $gridwidth,
                                      -fill  => &get_rgb_code($gridcolor),
                                      -arrow => 'none',
                                      -state => ($gridx) ? 'normal' : 'hidden');
        $xgrid_line2 = $preview_grid->create_line($pw*0.5 +3, $ph*0.1 +3,
                                                  $pw*0.5 +3, $ph*0.9 +3,
                                      -width => $gridwidth,
                                      -fill  => &get_rgb_code($gridcolor),
                                      -arrow => 'none',
                                      -state => ($gridx) ? 'normal' : 'hidden');
        $xgrid_line3 = $preview_grid->create_line($pw*0.75 +3, $ph*0.1 +3,
                                                  $pw*0.75 +3, $ph*0.9 +3,
                                      -width => $gridwidth,
                                      -fill  => &get_rgb_code($gridcolor),
                                      -arrow => 'none',
                                      -state => ($gridx) ? 'normal' : 'hidden');
        $ygrid_line1 = $preview_grid->create_line($pw*0.1 +3, $ph*0.33 +3,
                                                  $pw*0.9 +3, $ph*0.33 +3,
                                      -width => $gridwidth,
                                      -fill  => &get_rgb_code($gridcolor),
                                      -arrow => 'none',
                                      -state => ($gridy) ? 'normal' : 'hidden');
        $ygrid_line2 = $preview_grid->create_line($pw*0.1 +3, $ph*0.67 +3,
                                                  $pw*0.9 +3, $ph*0.67 +3,
                                      -width => $gridwidth,
                                      -fill  => &get_rgb_code($gridcolor),
                                      -arrow => 'none',
                                      -state => ($gridy) ? 'normal' : 'hidden');

        $grid_frame = $grid_tab->new_frame(
                -borderwidth => 1,
                -relief      => 'groove',
                );
        $grid_frame->g_grid(-row => 1, -column => 0, -sticky => 'wnes');

        $row = 0;
        $grid_frame->new_label(
                -text   => "Time-Series Grid Lines:",
                -anchor => 'w',
                -font   => 'default',
                )->g_grid(-row => $row, -column => 0, -columnspan => 2, -sticky => 'ew', -pady => 2);

        $row++;
        $grid_frame->new_label(
                -text => "Vertical: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $grid_frame->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "Show",
                -font     => 'default',
                -variable => \$gridx,
                -command  => sub { my $status = ($gridx) ? 'normal' : 'hidden';
                                   $preview_grid->itemconfigure($xgrid_line1, -state => $status);
                                   $preview_grid->itemconfigure($xgrid_line2, -state => $status);
                                   $preview_grid->itemconfigure($xgrid_line3, -state => $status);
                                 },
                )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

        $row++;
        $grid_frame->new_label(
                -text => "Horizontal: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $grid_frame->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "Show",
                -font     => 'default',
                -variable => \$gridy,
                -command  => sub { my $status = ($gridy) ? 'normal' : 'hidden';
                                   $preview_grid->itemconfigure($ygrid_line1, -state => $status);
                                   $preview_grid->itemconfigure($ygrid_line2, -state => $status);
                                 },
                )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

        $row++;
        $grid_frame->new_label(
                -text => "Width: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($gridwidth_sb = $grid_frame->new_spinbox(
                -textvariable => \$gridwidth,
                -state        => 'readonly',
                -font         => 'default',
                -from         => 1,
                -to           => 10,
                -increment    => 1,
                -width        => 3,
                -command      => sub { $preview_grid->itemconfigure($xgrid_line1, -width => $gridwidth);
                                       $preview_grid->itemconfigure($xgrid_line2, -width => $gridwidth);
                                       $preview_grid->itemconfigure($xgrid_line3, -width => $gridwidth);
                                       $preview_grid->itemconfigure($ygrid_line1, -width => $gridwidth);
                                       $preview_grid->itemconfigure($ygrid_line2, -width => $gridwidth);
                                     },
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

        $row++;
        $grid_frame->new_label(
                -text => "Color: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $code       = &get_rgb_code($gridcolor);
        $gridcolor = &get_rgb_name($code);
        $fg         = &get_rgb_code("black");
        if ($code =~ /^\#[0-9a-f]/i) {
            $fg = &get_rgb_code(&get_bw_contrast($code));
        }
        ($gridcolor_btn = $grid_frame->new_button(
                -textvariable => \$gridcolor,
                -background   => $code,
                -foreground   => $fg,
                -width        => -7,
                -command => sub { my ($newc, $code, $fg);
                                  $code = &get_rgb_code($gridcolor);
                                  $newc = Tkx::tk___chooseColor(
                                             -initialcolor => $code,
                                             -parent       => $graph_props_menu);
                                  if ($newc) {
                                      $code      = &get_rgb_code($newc);
                                      $gridcolor = &get_rgb_name($code);
                                      $fg        = &get_rgb_code("black");
                                      if ($code =~ /^#?[0-9a-f]/i) {
                                          $fg = &get_rgb_code(&get_bw_contrast($code));
                                      }
                                      $gridcolor_btn->configure(-foreground => $fg,
                                                                -background => $code);
                                      $preview_grid->itemconfigure($xgrid_line1, -fill => $code);
                                      $preview_grid->itemconfigure($xgrid_line2, -fill => $code);
                                      $preview_grid->itemconfigure($xgrid_line3, -fill => $code);
                                      $preview_grid->itemconfigure($ygrid_line1, -fill => $code);
                                      $preview_grid->itemconfigure($ygrid_line2, -fill => $code);
                                  }
                                },
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 0);
    }

#   Bulkhead configuration tab
    if ($props{$id}{meta} eq "vert_wd_zone" && $props{$id}{wd_alg} eq "Libby Dam") {
        $bh_show   = $gr_props{$id}{bh_show};
        $bh_docked = $gr_props{$id}{bh_docked};
        $bh_font   = $gr_props{$id}{bh_font};
        $bh_size   = $gr_props{$id}{bh_size};
        $bh_weight = $gr_props{$id}{bh_weight};
        $bh_tcolor = $gr_props{$id}{bh_tcolor};
        $bh_bwidth = $gr_props{$id}{bh_bwidth};
        $bh_bcolor = $gr_props{$id}{bh_bcolor};
        $bh_bcellw = $gr_props{$id}{bh_bcellw};
        $bh_bcellh = $gr_props{$id}{bh_bcellh};
        if ($bh_bcellh -int($bh_bcellh) != 0.0) {
            $bh_bcellh = sprintf("%.6f", $bh_bcellh);
            $bh_bcellh =~ s/0+$//;
        }

        @bh_status_opts = ("Do not show", "Show, docked", "Show, undocked");
        if ($bh_show) {
            $bh_status = ($bh_docked) ? 1 : 2;
        } else {
            $bh_status = 0;
        }
        $bh_status_opt = $bh_status_opts[$bh_status];

        $bulkhead_tab = $grprops_notebook->new_frame();
        $grprops_notebook->add($bulkhead_tab,
                -text      => "Bulkheads",
                -underline => 0,
                -sticky    => 'nsew',
                );

        $preview_bh = $bulkhead_tab->new_canvas(
                -background  => &get_rgb_code($canvas_color),
                -width       => $pw,
                -height      => $ph,
                -borderwidth => 1,
                -relief      => 'groove',
                );
        $preview_bh->g_grid(-row => 0, -column => 0, -sticky => 'wne');

        $bulkhead_box = $preview_bh->create_rectangle($pw*0.5 -$bh_bcellw/2 +3, $ph*0.2 +3,
                                                      $pw*0.5 +$bh_bcellw/2 +3, $ph*0.8 +3,
                                -outline => &get_rgb_code($bh_bcolor),
                                -width   => $bh_bwidth,
                                -fill    => "",
                                );
        $bulkhead_txt = $preview_bh->create_text($pw*0.5 +3, $ph*0.5 +3,
                -anchor => 'center', 
                -text   => "3",
                -fill   => &get_rgb_code($bh_tcolor),
                -angle  => 0,
                -font   => [-family     => $bh_font,
                            -size       => $bh_size,
                            -weight     => $bh_weight,
                            -slant      => 'roman',
                            -underline  => 0,
                            -overstrike => 0,
                           ]);

        $bh_frame = $bulkhead_tab->new_frame(
                -borderwidth => 1,
                -relief      => 'groove',
                );
        $bh_frame->g_grid(-row => 1, -column => 0, -sticky => 'wnes');

        $row = 0;
        $bh_frame->new_label(
                -text => "Status: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($bh_status_cb = $bh_frame->new_ttk__combobox(
                -textvariable => \$bh_status_opt,
                -values       => [ @bh_status_opts ],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $bh_status_cb->g_bind("<<ComboboxSelected>>",
                  sub { my $s = &list_match($bh_status_opt, @bh_status_opts);
                        return if ($s < 0);
                        if ($s < 2 && $bh_status == 2) {
                            $bh_bcellh_label->g_grid_remove();
                            $bh_bcellh_entry->g_grid_remove();
                            $bh_bcellh_label2->g_grid_remove();
                        } elsif ($s == 2 && $bh_status != 2) {
                            $bh_bcellh_label->g_grid();
                            $bh_bcellh_entry->g_grid();
                            $bh_bcellh_label2->g_grid();
                            $bh_bcellh = $gr_props{$id}{bh_bcellh};
                            if ($bh_bcellh -int($bh_bcellh) != 0.0) {
                                $bh_bcellh = sprintf("%.6f", $bh_bcellh);
                                $bh_bcellh =~ s/0+$//;
                            }
                        }
                        $bh_status = $s;
                      });
        $row++;
        $bh_frame->new_label(
                -text => "Bulkhead Text Font: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($bh_font_cb = $bh_frame->new_ttk__combobox(
                -textvariable => \$bh_font,
                -values       => [ sort @available_fonts ],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $bh_font_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_bh->itemconfigure($bulkhead_txt,
                              -font => [ -family     => $bh_font,
                                         -size       => $bh_size,
                                         -weight     => $bh_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });
        $row++;
        $bh_frame->new_label(
                -text => "Bulkhead Text Size: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($bh_size_cb = $bh_frame->new_ttk__combobox(
                -textvariable => \$bh_size,
                -values       => [(5 .. 24)],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $bh_size_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_bh->itemconfigure($bulkhead_txt,
                              -font => [ -family     => $bh_font,
                                         -size       => $bh_size,
                                         -weight     => $bh_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });
        $row++;
        $bh_frame->new_label(
                -text => "Bulkhead Text Weight: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($bh_weight_cb = $bh_frame->new_ttk__combobox(
                -textvariable => \$bh_weight,
                -values       => [("normal", "bold")],
                -state        => 'readonly',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $bh_weight_cb->g_bind("<<ComboboxSelected>>",
                  sub { $preview_bh->itemconfigure($bulkhead_txt,
                              -font => [ -family     => $bh_font,
                                         -size       => $bh_size,
                                         -weight     => $bh_weight,
                                         -slant      => 'roman',
                                         -underline  => 0,
                                         -overstrike => 0,
                                       ]);
                      });
        $row++;
        $code      = &get_rgb_code($bh_tcolor);
        $bh_tcolor = &get_rgb_name($code);
        $fg        = &get_rgb_code("black");
        if ($code =~ /^\#[0-9a-f]/i) {
            $fg = &get_rgb_code(&get_bw_contrast($code));
        }
        $bh_frame->new_label(
                -text => "BH Text Color: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($bh_tcolor_btn = $bh_frame->new_button(
                -textvariable => \$bh_tcolor,
                -background   => $code,
                -foreground   => $fg,
                -width        => -7,
                -command => sub { my ($newc, $code, $fg);
                                  $code = &get_rgb_code($bh_tcolor);
                                  $newc = Tkx::tk___chooseColor(
                                             -initialcolor => $code,
                                             -parent       => $graph_props_menu);
                                  if ($newc) {
                                      $code      = &get_rgb_code($newc);
                                      $bh_tcolor = &get_rgb_name($code);
                                      $fg        = &get_rgb_code("black");
                                      if ($code =~ /^\#[0-9a-f]/i) {
                                          $fg = &get_rgb_code(&get_bw_contrast($code));
                                      }
                                      $bh_tcolor_btn->configure(-foreground => $fg,
                                                                -background => $code);
                                      $preview_bh->itemconfigure($bulkhead_txt,
                                                       -fill => &get_rgb_code($bh_tcolor));
                                  }
                                }
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
        $row++;
        $bh_frame->new_label(
                -text => "Box Outline Width: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $bh_frame->new_spinbox(
                -textvariable => \$bh_bwidth,
                -state        => 'readonly',
                -font         => 'default',
                -from         => 1,
                -to           => 10,
                -increment    => 1,
                -width        => 3,
                -command      => sub { $preview_bh->itemconfigure($bulkhead_box,
                                             -width => $bh_bwidth);
                                     }
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $row++;
        $code      = &get_rgb_code($bh_bcolor);
        $bh_bcolor = &get_rgb_name($code);
        $fg        = &get_rgb_code("black");
        if ($code =~ /^\#[0-9a-f]/i) {
            $fg = &get_rgb_code(&get_bw_contrast($code));
        }
        $bh_frame->new_label(
                -text => "Box Outline Color: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($bh_bcolor_btn = $bh_frame->new_button(
                -textvariable => \$bh_bcolor,
                -background   => $code,
                -foreground   => $fg,
                -width        => -7,
                -command => sub { my ($newc, $code, $fg);
                                  $code = &get_rgb_code($bh_bcolor);
                                  $newc = Tkx::tk___chooseColor(
                                             -initialcolor => $code,
                                             -parent       => $graph_props_menu);
                                  if ($newc) {
                                      $code      = &get_rgb_code($newc);
                                      $bh_bcolor = &get_rgb_name($code);
                                      $fg        = &get_rgb_code("black");
                                      if ($code =~ /^\#[0-9a-f]/i) {
                                          $fg = &get_rgb_code(&get_bw_contrast($code));
                                      }
                                      $bh_bcolor_btn->configure(-foreground => $fg,
                                                                -background => $code);
                                      $preview_bh->itemconfigure($bulkhead_box,
                                                       -outline => &get_rgb_code($bh_bcolor));
                                  }
                                }
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
        $row++;
        $bh_frame->new_label(
                -text => "Box Cell Width: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $bh_frame->new_spinbox(
                -textvariable => \$bh_bcellw,
                -state        => 'readonly',
                -font         => 'default',
                -from         => 10,
                -to           => 30,
                -increment    => 1,
                -width        => 3,
                -command      => sub { $preview_bh->coords($bulkhead_box,
                                                    $pw*0.5 -$bh_bcellw/2 +3, $ph*0.2 +3,
                                                    $pw*0.5 +$bh_bcellw/2 +3, $ph*0.8 +3);
                                     }
                )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $bh_frame->new_label(
                -text => "pixels",
                -font => 'default',
                )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);
        $bh_frame->g_grid_columnconfigure(2, -weight => 2);
        $row++;
        ($bh_bcellh_label = $bh_frame->new_label(
                -text => "Box Cell Height: ",
                -font => 'default',
                ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($bh_bcellh_entry = $bh_frame->new_entry(
                -textvariable => \$bh_bcellh,
                -font         => 'default',
                -width        => 10,
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        ($bh_bcellh_label2 = $bh_frame->new_label(
                -text => "pixels",
                -font => 'default',
                ))->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);
        $bh_bcellh_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $bh_bcellh_entry ]);
        if ($bh_status < 2) {
            $bh_bcellh_label->g_grid_remove();
            $bh_bcellh_entry->g_grid_remove();
            $bh_bcellh_label2->g_grid_remove();
        }
    }

    Tkx::ttk__notebook__enableTraversal($grprops_notebook);
    Tkx::wm_resizable($graph_props_menu,0,0);
    &adjust_window_position($graph_props_menu);
    $grprops_notebook->select(&min($tabid, $grprops_notebook->index('end')-1));
    $graph_props_menu->g_focus;
}


sub update_graph_props {
    my ($id, $xfont, $xt_size, $xt_weight, $xl_size, $xl_weight, $xbase, $xmin, $xmax,
             $xfirst, $xmajor, $xmaj_auto, $datefmt, $xtitle, $xpr_tics, $xop_tics,
             $xaxis_type, $xaxis_units, $xaxis_flip, $xmax_auto, $byear,
             $yfont, $yt_size, $yt_weight, $yl_size, $yl_weight, $ybase, $ymin, $ymax,
             $yfirst, $ymajor, $ymaj_auto, $yformat, $ytitle, $ypr_tics, $yop_tics,
             $yaxis_type, $yaxis_units, $yaxis_flip, $ymax_auto, $qaxis_units, $wt_units,
             $stype, $sfont, $st_size, $st_weight, $sl_size, $sl_weight, $stic_loc,
             $smajor, $sgrid, $sgrid_col, $bgrid, $bgrid_col, $stitle, $spr_tics, $sop_tics,
             $gtfont, $gt_size, $gt_weight, $gs_size, $gs_weight, $gtitle, $gstitle,
             $status, $cs_link, $cs1, $cs2, $nc, $rev, $cs_min, $cs_max, $cs_major, $cs_width, $cs_height,
             $keyfont, $keytitle, $kt_size, $kt_weight, $kn_size, $kn_weight, $kn_digits,
             $bh_status, $bh_font, $bh_size, $bh_weight, $bh_tcolor,
             $bh_bwidth, $bh_bcolor, $bh_bcellw, $bh_bcellh,
             $legfont, $lt_size, $lt_weight, $le_size, $le_weight,
             $le_edge, $le_edgec, $le_fill, $le_fillc, $gap_tol,
             $gridx, $gridy, $gridwidth, $gridcolor, $dateline, $datelinec,
             $wl_color, $wl_style, $wl_grid, $wl_gridc,
             $ts_show_ref, $ts_color_ref, $ts_width_ref, $legtitle, $sets_swapped,
             $add_ts_show_ref, $add_ts_setnum_ref, $add_ts_color_ref, $add_ts_width_ref,
             $add_ts_text_ref, $add_ts_delete_ref, $add_ts_file_ref, $add_ts_ftype_ref,
             $add_ts_lines_ref, $add_ts_param_ref, $add_ts_byear_ref, $add_ts_tzoff_ref,
             $add_ts_seg_ref, $add_ts_ctype_ref, $add_ts_limits_ref, $add_ts_tsdata_ref,
        $action, $X, $Y, $tabid) = @_;
    my (
        $base_jd, $datemax, $datemin, $dist1, $dist2, $geom, $gtag, $i,
        $ii, $item, $jd_max, $jd_max_old, $jd_min, $jd_min_old, $match,
        $move_mcursor, $n, $ncolors, $new_tag, $old_tag, $refresh_info,
        $refresh_menu, $update_cs, $x1, $x2, $y1, $y2,

        @add_ts_byear, @add_ts_color, @add_ts_ctype, @add_ts_delete,
        @add_ts_file, @add_ts_ftype, @add_ts_limits, @add_ts_lines,
        @add_ts_param, @add_ts_seg, @add_ts_setnum, @add_ts_show,
        @add_ts_text, @add_ts_tsdata, @add_ts_tzoff, @add_ts_width,
        @cpl_files, @ts_color, @ts_show, @ts_width, @wbs,

        %add_ts_parms, %parms,
       );

    $refresh_menu = $refresh_info = 0;
    ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };

    if (defined($gr_props{$id}{add_cs})) {
        if ($cs_min >= $cs_max) {
            return &pop_up_error($graph_props_menu,
                                 "The scale minimum must be\nless than the scale maximum.");
        }
        if ($cs_major ne "auto") {
            if ($cs_major > $cs_max -$cs_min) {
                return &pop_up_error($graph_props_menu,
                                     "The color scale increment is\nlarger than the scale range.");
            } elsif ($cs_major <= 0) {
                return &pop_up_error($graph_props_menu,
                                     "The color scale increment\nmust be greater than zero.");
            }
        }
    }
    if ($props{$id}{meta} eq "w2_tdmap") {
        if ($gr_props{$id}{date_axis} eq "X") {              # X: date/time, Y: distance
            $xmaj_auto = 0 if ($xaxis_type eq "Julian Date");
            if (! $xmaj_auto) {
                $xmajor = "auto" if (! defined($xmajor) || $xmajor eq "");
                if ($xmajor ne "auto") {
                    $xmajor = "auto" if ($xmajor+0 <= 0);
                }
            }
            if ($xaxis_type eq "Date/Time") {
                $jd_min = &datelabel2jdate($xmin);
                $jd_max = &datelabel2jdate($xmax);
                if ($jd_min >= $jd_max) {
                    return &pop_up_error($graph_props_menu,
                                         "The X axis minimum must be\nless than the X axis maximum.");
                }
            } else {
                if (! defined($xmin) || $xmin eq "" || ! defined($xmax) || $xmax eq "" || $xmin >= $xmax) {
                    return &pop_up_error($graph_props_menu,
                                         "The X axis minimum must be\nless than the X axis maximum.");
                }
            }
            $ymajor = "auto" if (! defined($ymajor) || $ymajor eq "");
            if ($ymajor ne "auto") {
                $ymajor = "auto" if ($ymajor+0 <= 0);
            }
            if (! $ymax_auto && (! defined($ymin) || $ymin eq "" ||
                                 ! defined($ymax) || $ymax eq "" || $ymin >= $ymax)) {
                return &pop_up_error($graph_props_menu,
                                     "The Y axis minimum must be\nless than the Y axis maximum.");
            }
            if ($yfirst ne "" && (($ymin ne "" && $yfirst < $ymin) || ($ymin eq "" && $yfirst < 0.))) {
                return &pop_up_error($graph_props_menu,
                                     "The first Y axis label should not\nbe less than the Y axis minimum.");
            }
            $ymin  = 0     if (! defined($ymin)  || $ymin  eq "");
            $ybase = $ymin if (! defined($ybase) || $ybase eq "");
            if ($ymax_auto) {
                if ($yaxis_units eq "miles") {
                    $dist2 = $gr_props{$id}{d_km} *3280.4/5280. +$ybase;
                } else {
                    $dist2 = $gr_props{$id}{d_km} +$ybase;
                }
                if ($dist2 <= $ymin) {
                    return &pop_up_error($graph_props_menu, "The Y axis minimum must be less\n"
                                                          . "than the automatic Y axis maximum.");
                }
            }
        } else {                                             # Y: date/time, X: distance
            $ymaj_auto = 0 if ($yaxis_type eq "Julian Date");
            if (! $ymaj_auto) {
                $ymajor = "auto" if (! defined($ymajor) || $ymajor eq "");
                if ($ymajor ne "auto") {
                    $ymajor = "auto" if ($ymajor+0 <= 0);
                }
            }
            if ($yaxis_type eq "Date/Time") {
                $jd_min = &datelabel2jdate($ymin);
                $jd_max = &datelabel2jdate($ymax);
                if ($jd_min >= $jd_max) {
                    return &pop_up_error($graph_props_menu,
                                         "The Y axis minimum must be\nless than the Y axis maximum.");
                }
            } else {
                if (! defined($ymin) || $ymin eq "" || ! defined($ymax) || $ymax eq "" || $ymin >= $ymax) {
                    return &pop_up_error($graph_props_menu,
                                         "The Y axis minimum must be\nless than the Y axis maximum.");
                }
            }
            $xmajor = "auto" if (! defined($xmajor) || $xmajor eq "");
            if ($xmajor ne "auto") {
                $xmajor = "auto" if ($xmajor+0 <= 0);
            }
            if (! $xmax_auto && (! defined($xmin) || $xmin eq "" ||
                                 ! defined($xmax) || $xmax eq "" || $xmin >= $xmax)) {
                return &pop_up_error($graph_props_menu,
                                     "The X axis minimum must be\nless than the X axis maximum.");
            }
            if ($xfirst ne "" && (($xmin ne "" && $xfirst < $xmin) || ($xmin eq "" && $xfirst < 0.))) {
                return &pop_up_error($graph_props_menu,
                                     "The first X axis label should not\nbe less than the X axis minimum.");
            }
            $xmin  = 0     if (! defined($xmin)  || $xmin  eq "");
            $xbase = $xmin if (! defined($xbase) || $xbase eq "");
            if ($xmax_auto) {
                if ($xaxis_units eq "miles") {
                    $dist2 = $gr_props{$id}{d_km} *3280.4/5280. +$xbase;
                } else {
                    $dist2 = $gr_props{$id}{d_km} +$xbase;
                }
                if ($dist2 <= $xmin) {
                    return &pop_up_error($graph_props_menu, "The X axis minimum must be less\n"
                                                          . "than the automatic X axis maximum.");
                }
            }
        }
    } else {
        if ($props{$id}{meta} =~ /data_profile_cmap|w2_profile_cmap|time_series/) {
            $xmaj_auto = 0 if ($xaxis_type eq "Julian Date");
            if (! $xmaj_auto) {
                $xmajor = "auto" if (! defined($xmajor) || $xmajor eq "");
                if ($xmajor ne "auto") {
                    $xmajor = "auto" if ($xmajor+0 <= 0);
                }
            }
        } else {
            $xmajor = "auto" if (! defined($xmajor) || $xmajor eq "");
            if ($xmajor ne "auto") {
                $xmajor = "auto" if ($xmajor+0 <= 0);
            }
        }
        if ($props{$id}{meta} =~ /(data_profile_cmap|w2_profile_cmap|time_series)/
               && $xaxis_type eq "Date/Time") {
            $jd_min = &datelabel2jdate($xmin);
            $jd_max = &datelabel2jdate($xmax);
            if ($jd_min >= $jd_max) {
                return &pop_up_error($graph_props_menu,
                                     "The X axis minimum must be\nless than the X axis maximum.");
            }
        } else {
            if (! $xmax_auto && (! defined($xmin) || $xmin eq "" ||
                                 ! defined($xmax) || $xmax eq "" || $xmin >= $xmax)) {
                return &pop_up_error($graph_props_menu,
                                     "The X axis minimum must be\nless than the X axis maximum.");
            }
            if ($props{$id}{meta} =~ /w2_slice|w2_wlevels/) {
                if ($xfirst ne "" && (($xmin ne "" && $xfirst < $xmin) || ($xmin eq "" && $xfirst < 0.))) {
                    return &pop_up_error($graph_props_menu, "The first X axis label should not\n"
                                                          . "be less than the X axis minimum.");
                }
                $xmin  = 0     if (! defined($xmin)  || $xmin  eq "");
                $xbase = $xmin if (! defined($xbase) || $xbase eq "");
                if ($xmax_auto) {
                    if ($xaxis_units eq "miles") {
                        $dist2 = $gr_props{$id}{x_km} *3280.4/5280. +$xbase;
                    } else {
                        $dist2 = $gr_props{$id}{x_km} +$xbase;
                    }
                    if ($dist2 <= $xmin) {
                        return &pop_up_error($graph_props_menu, "The X axis minimum must be less\n"
                                                              . "than the automatic X axis maximum.");
                    }
                }
            }
        }
        if (! defined($ymin) || ! defined($ymax) || $ymin eq "" || $ymax eq "" || $ymin >= $ymax) {
            return &pop_up_error($graph_props_menu,
                                 "The Y axis minimum must be\nless than the Y axis maximum.");
        }
        $ymajor = "auto" if (! defined($ymajor) || $ymajor eq "");
        if ($ymajor ne "auto") {
            $ymajor = "auto" if ($ymajor+0 <= 0);
        }
    }

    $gr_props{$id}{redraw} = 0;
    if ($props{$id}{meta} =~ /data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone/) {
        if ($props{$id}{meta} ne "w2_wlevels" && $gr_props{$id}{ytype} ne $yaxis_type) {
            $gr_props{$id}{redraw} = 1;
        } elsif ($gr_props{$id}{yunits} ne $yaxis_units) {
            if ($yaxis_units eq "feet") {
                if (abs($gr_props{$id}{ymax} *3.28084 -$ymax) > 0.1 ||
                    abs($gr_props{$id}{ymin} *3.28084 -$ymin) > 0.1) {
                    $gr_props{$id}{redraw} = 1;
                }
            } else {
                if (abs($gr_props{$id}{ymax} -3.28084 *$ymax) > 0.1 ||
                    abs($gr_props{$id}{ymin} -3.28084 *$ymin) > 0.1) {
                    $gr_props{$id}{redraw} = 1;
                }
            }
            if (! $gr_props{$id}{redraw}) {
                $gr_props{$id}{ymin} = $ymin;  # prevent later comparison from setting redraw
                $gr_props{$id}{ymax} = $ymax;
            }
        }
        $refresh_info = 1 if ($gr_props{$id}{yunits} ne $yaxis_units);
        $gr_props{$id}{ytype}  = $yaxis_type if ($props{$id}{meta} ne "w2_wlevels");
        $gr_props{$id}{yunits} = $yaxis_units;
    }
    if ($props{$id}{meta} =~ /^(data_profile|w2_profile|vert_wd_zone)$/) {
        if (($status == 0 &&   $gr_props{$id}{add_cs}) ||
            ($status  > 0 && ! $gr_props{$id}{add_cs})) {
            $gr_props{$id}{redraw} = 1;
        }
        $gr_props{$id}{add_cs}    = ($status  > 0) ? 1 : 0;
        $gr_props{$id}{cs_hide}   = ($status == 2) ? 1 : 0;
        $gr_props{$id}{gs_size}   = $gs_size;
        $gr_props{$id}{gs_weight} = $gs_weight;
        if ($props{$id}{meta} eq "vert_wd_zone") {
            $gr_props{$id}{redraw} = 1 if ($gr_props{$id}{qunits} ne $qaxis_units);
            $refresh_info          = 1 if ($gr_props{$id}{qunits} ne $qaxis_units);
            $gr_props{$id}{qunits} = $qaxis_units;
            $gr_props{$id}{redraw} = 1 if ($props{$id}{wt_units} ne $wt_units);
            $refresh_info          = 1 if ($props{$id}{wt_units} ne $wt_units);
            $props{$id}{wt_units}  = $wt_units;

        } elsif ($props{$id}{meta} =~ /^(data_profile|w2_profile)$/
                 && $props{$id}{parm} eq "Temperature") {
            $gr_props{$id}{redraw}  = 1 if ($props{$id}{parm_units} ne $wt_units);
            $refresh_info           = 1 if ($props{$id}{parm_units} ne $wt_units);
            $props{$id}{parm_units} = $wt_units;
        }

    } elsif ($props{$id}{meta} eq "w2_outflow") {
        if ($props{$id}{add_parm}) {
            if (($status == 0 &&   $gr_props{$id}{add_cs}) ||
                ($status  > 0 && ! $gr_props{$id}{add_cs})) {
                $gr_props{$id}{redraw} = 1;
            }
            $gr_props{$id}{add_cs}    = ($status  > 0) ? 1 : 0;
            $gr_props{$id}{cs_hide}   = ($status == 2) ? 1 : 0;
            $gr_props{$id}{gs_size}   = $gs_size;
            $gr_props{$id}{gs_weight} = $gs_weight;
            if ($props{$id}{parm} eq "Temperature") {
                $gr_props{$id}{redraw}  = 1 if ($props{$id}{parm_units} ne $wt_units);
                $refresh_info           = 1 if ($props{$id}{parm_units} ne $wt_units);
                $props{$id}{parm_units} = $wt_units;
            }
        }
        $gr_props{$id}{redraw} = 1 if ($gr_props{$id}{qunits} ne $qaxis_units);
        $refresh_info          = 1 if ($gr_props{$id}{qunits} ne $qaxis_units);
        $gr_props{$id}{qunits} = $qaxis_units;

    } elsif ($props{$id}{meta} =~ /w2_slice|w2_wlevels/) {
        if ($props{$id}{meta} eq "w2_slice") {
            if ($props{$id}{parm} eq "Temperature") {
                $gr_props{$id}{redraw}  = 1 if ($props{$id}{parm_units} ne $wt_units);
                $refresh_info           = 1 if ($props{$id}{parm_units} ne $wt_units);
                $props{$id}{parm_units} = $wt_units;
            }
            $gr_props{$id}{cs_hide}   = $status;
            $gr_props{$id}{xflip_img} = ($gr_props{$id}{xflip} != $xaxis_flip) ? 1 : 0;
        } else {
            $gr_props{$id}{redraw}    = 1 if ($gr_props{$id}{xflip}    != $xaxis_flip ||
                                              $gr_props{$id}{wl_color} ne $wl_color   ||
                                              $gr_props{$id}{wl_style} ne $wl_style   ||
                                              $gr_props{$id}{wl_grid}  != $wl_grid    ||
                                              $gr_props{$id}{wl_gridc} ne $wl_gridc);
            $gr_props{$id}{wl_color}  = $wl_color;
            $gr_props{$id}{wl_style}  = $wl_style;
            $gr_props{$id}{wl_grid}   = $wl_grid;
            $gr_props{$id}{wl_gridc}  = $wl_gridc;
        }
        if (! $gr_props{$id}{redraw}) {
            $dist1  = $gr_props{$id}{xmin} -$gr_props{$id}{xbase};
            $dist1 *= 5280./3280.84 if ($gr_props{$id}{xunits} eq "miles");
            $dist2  = $xmin -$xbase;
            $dist2 *= 5280./3280.84 if ($xaxis_units eq "miles");
            if (abs($dist1 -$dist2) > 0.002) {
                $gr_props{$id}{redraw} = 1;
            } else {
                $dist1  = $gr_props{$id}{xmax} -$gr_props{$id}{xmin};
                $dist1 *= 5280./3280.84 if ($gr_props{$id}{xunits} eq "miles");
                if (! $xmax_auto) {
                    $dist2  = $xmax -$xmin;
                    $dist2 *= 5280./3280.84 if ($xaxis_units eq "miles");
                } else {
                    if ($xaxis_units eq "miles") {
                        $dist2 = $gr_props{$id}{x_km} -($xmin -$xbase) *5280./3280.84;
                    } else {
                        $dist2 = $gr_props{$id}{x_km} -($xmin -$xbase);
                    }
                }
                $gr_props{$id}{redraw} = 1 if (abs($dist1 -$dist2) > 0.002);
            }
        }
        $refresh_info = 1 if ($gr_props{$id}{xunits} ne $xaxis_units);
        $gr_props{$id}{xunits}    = $xaxis_units;
        $gr_props{$id}{xbase}     = $xbase;
        $gr_props{$id}{xfirst}    = $xfirst;
        $gr_props{$id}{xflip}     = $xaxis_flip;
        $gr_props{$id}{xmax_auto} = $xmax_auto;
        $gr_props{$id}{gs_size}   = $gs_size;
        $gr_props{$id}{gs_weight} = $gs_weight;

        $smajor = "auto" if (! defined($smajor) || $smajor eq "");
        if ($smajor ne "auto") {
            $smajor = "auto" if ($smajor+0 <= 0);
        }
        $gr_props{$id}{stype}     = $stype;
        $gr_props{$id}{sfont}     = $sfont;
        $gr_props{$id}{st_size}   = $st_size;
        $gr_props{$id}{st_weight} = $st_weight;
        $gr_props{$id}{sl_size}   = $sl_size;
        $gr_props{$id}{sl_weight} = $sl_weight;
        $gr_props{$id}{stic_loc}  = $stic_loc;
        $gr_props{$id}{smajor}    = $smajor;
        $gr_props{$id}{spr_tics}  = $spr_tics;
        $gr_props{$id}{sop_tics}  = $sop_tics;
        $gr_props{$id}{sgrid}     = $sgrid;
        $gr_props{$id}{sgrid_col} = $sgrid_col;
        $gr_props{$id}{bgrid}     = $bgrid;
        $gr_props{$id}{bgrid_col} = $bgrid_col;
        $gr_props{$id}{stitle}    = $stitle;

    } elsif ($props{$id}{meta} eq "w2_tdmap") {
        $gr_props{$id}{cs_hide}   = $status;
        $gr_props{$id}{gstitle}   = $gstitle;
        $gr_props{$id}{gs_size}   = $gs_size;
        $gr_props{$id}{gs_weight} = $gs_weight;
        if ($props{$id}{parm} eq "Temperature") {
            $gr_props{$id}{redraw}  = 1 if ($props{$id}{parm_units} ne $wt_units);
            $refresh_info           = 1 if ($props{$id}{parm_units} ne $wt_units);
            $props{$id}{parm_units} = $wt_units;
        }
        if ($gr_props{$id}{date_axis} eq "X") {     # X: date/time, Y: distance
            $gr_props{$id}{datefmt} = $datefmt;
            if ($gr_props{$id}{ttype} ne $xaxis_type) {
                if ($xaxis_type eq "Date/Time") {
                    $base_jd = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
                    $datemin = &jdate2datelabel($gr_props{$id}{tmin} +$base_jd -1, "Mon-DD-YYYY");
                    $datemax = &jdate2datelabel($gr_props{$id}{tmax} +$base_jd -1, "Mon-DD-YYYY");
                    if ($xmin ne $datemin || $xmax ne $datemax) {
                        $gr_props{$id}{redraw} = 1;
                    } else {
                        $gr_props{$id}{tmin} = $xmin;
                        $gr_props{$id}{tmax} = $xmax;
                    }
                } else {
                    $base_jd = &date2jdate(sprintf("%04d%02d%02d", $byear, 1, 1));
                    $datemin = &jdate2datelabel($xmin +$base_jd -1, "Mon-DD-YYYY");
                    $datemax = &jdate2datelabel($xmax +$base_jd -1, "Mon-DD-YYYY");
                    if ($gr_props{$id}{tmin} ne $datemin || $gr_props{$id}{tmax} ne $datemax) {
                        $gr_props{$id}{redraw} = 1;
                    } else {
                        $gr_props{$id}{tmin} = $xmin;
                        $gr_props{$id}{tmax} = $xmax;
                    }
                }
            } elsif ($xaxis_type eq "Julian Date") {
                $base_jd    = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
                $jd_min_old = $gr_props{$id}{tmin} + $base_jd -1;
                $jd_max_old = $gr_props{$id}{tmax} + $base_jd -1;
                $base_jd    = &date2jdate(sprintf("%04d%02d%02d", $byear, 1, 1));
                $jd_min     = $xmin + $base_jd -1;
                $jd_max     = $xmax + $base_jd -1;
                if ($jd_min != $jd_min_old || $jd_max != $jd_max_old) {
                    $gr_props{$id}{redraw} = 1;
                } else {
                    $gr_props{$id}{tmin} = $xmin;
                    $gr_props{$id}{tmax} = $xmax;
                }
            }
            $gr_props{$id}{ttype}     = $xaxis_type;
            $gr_props{$id}{base_yr}   = $byear;
            $gr_props{$id}{tflip_img} = ($gr_props{$id}{tflip} != $xaxis_flip) ? 1 : 0;
            $gr_props{$id}{tflip}     = $xaxis_flip;
            $xmajor = "auto" if ($xmaj_auto);

            if (! $gr_props{$id}{redraw}) {
                $dist1  = $gr_props{$id}{dmin} -$gr_props{$id}{dbase};
                $dist1 *= 5280./3280.84 if ($gr_props{$id}{dunits} eq "miles");
                $dist2  = $ymin -$ybase;
                $dist2 *= 5280./3280.84 if ($yaxis_units eq "miles");
                if (abs($dist1 -$dist2) > 0.002) {
                    $gr_props{$id}{redraw} = 1;
                } else {
                    $dist1  = $gr_props{$id}{dmax} -$gr_props{$id}{dmin};
                    $dist1 *= 5280./3280.84 if ($gr_props{$id}{dunits} eq "miles");
                    if (! $ymax_auto) {
                        $dist2  = $ymax -$ymin;
                        $dist2 *= 5280./3280.84 if ($yaxis_units eq "miles");
                    } else {
                        if ($yaxis_units eq "miles") {
                            $dist2 = $gr_props{$id}{d_km} -($ymin -$ybase) *5280./3280.84;
                        } else {
                            $dist2 = $gr_props{$id}{d_km} -($ymin -$ybase);
                        }
                    }
                    $gr_props{$id}{redraw} = 1 if (abs($dist1 -$dist2) > 0.002);
                }
            }
            $refresh_info = 1 if ($gr_props{$id}{dunits} ne $yaxis_units);

        } else {                                    # Y: date/time, X: distance
            $gr_props{$id}{datefmt} = $yformat;
            if ($gr_props{$id}{ttype} ne $yaxis_type) {
                if ($yaxis_type eq "Date/Time") {
                    $base_jd = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
                    $datemin = &jdate2datelabel($gr_props{$id}{tmin} +$base_jd -1, "Mon-DD-YYYY");
                    $datemax = &jdate2datelabel($gr_props{$id}{tmax} +$base_jd -1, "Mon-DD-YYYY");
                    if ($ymin ne $datemin || $ymax ne $datemax) {
                        $gr_props{$id}{redraw} = 1;
                    } else {
                        $gr_props{$id}{tmin} = $ymin;
                        $gr_props{$id}{tmax} = $ymax;
                    }
                } else {
                    $base_jd = &date2jdate(sprintf("%04d%02d%02d", $byear, 1, 1));
                    $datemin = &jdate2datelabel($ymin +$base_jd -1, "Mon-DD-YYYY");
                    $datemax = &jdate2datelabel($ymax +$base_jd -1, "Mon-DD-YYYY");
                    if ($gr_props{$id}{tmin} ne $datemin || $gr_props{$id}{tmax} ne $datemax) {
                        $gr_props{$id}{redraw} = 1;
                    } else {
                        $gr_props{$id}{tmin} = $ymin;
                        $gr_props{$id}{tmax} = $ymax;
                    }
                }
            } elsif ($yaxis_type eq "Julian Date") {
                $base_jd    = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
                $jd_min_old = $gr_props{$id}{tmin} + $base_jd -1;
                $jd_max_old = $gr_props{$id}{tmax} + $base_jd -1;
                $base_jd    = &date2jdate(sprintf("%04d%02d%02d", $byear, 1, 1));
                $jd_min     = $ymin + $base_jd -1;
                $jd_max     = $ymax + $base_jd -1;
                if ($jd_min != $jd_min_old || $jd_max != $jd_max_old) {
                    $gr_props{$id}{redraw} = 1;
                } else {
                    $gr_props{$id}{tmin} = $ymin;
                    $gr_props{$id}{tmax} = $ymax;
                }
            }
            $gr_props{$id}{ttype}     = $yaxis_type;
            $gr_props{$id}{base_yr}   = $byear;
            $gr_props{$id}{tflip_img} = ($gr_props{$id}{tflip} != $yaxis_flip) ? 1 : 0;
            $gr_props{$id}{tflip}     = $yaxis_flip;
            $ymajor = "auto" if ($ymaj_auto);

            if (! $gr_props{$id}{redraw}) {
                $dist1  = $gr_props{$id}{dmin} -$gr_props{$id}{dbase};
                $dist1 *= 5280./3280.84 if ($gr_props{$id}{dunits} eq "miles");
                $dist2  = $xmin -$xbase;
                $dist2 *= 5280./3280.84 if ($xaxis_units eq "miles");
                if (abs($dist1 -$dist2) > 0.002) {
                    $gr_props{$id}{redraw} = 1;
                } else {
                    $dist1  = $gr_props{$id}{dmax} -$gr_props{$id}{dmin};
                    $dist1 *= 5280./3280.84 if ($gr_props{$id}{dunits} eq "miles");
                    if (! $xmax_auto) {
                        $dist2  = $xmax -$xmin;
                        $dist2 *= 5280./3280.84 if ($xaxis_units eq "miles");
                    } else {
                        if ($xaxis_units eq "miles") {
                            $dist2 = $gr_props{$id}{d_km} -($xmin -$xbase) *5280./3280.84;
                        } else {
                            $dist2 = $gr_props{$id}{d_km} -($xmin -$xbase);
                        }
                    }
                    $gr_props{$id}{redraw} = 1 if (abs($dist1 -$dist2) > 0.002);
                }
            }
            $refresh_info = 1 if ($gr_props{$id}{dunits} ne $xaxis_units);
        }

    } elsif ($props{$id}{meta} =~ /data_profile_cmap|w2_profile_cmap/) {
        $gr_props{$id}{datefmt} = $datefmt;
        $gr_props{$id}{cs_hide} = $status;
        if ($gr_props{$id}{xtype} ne $xaxis_type) {
            if ($xaxis_type eq "Date/Time") {
                $base_jd = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
                $datemin = &jdate2datelabel($gr_props{$id}{xmin} +$base_jd -1, "Mon-DD-YYYY");
                $datemax = &jdate2datelabel($gr_props{$id}{xmax} +$base_jd -1, "Mon-DD-YYYY");
                if ($xmin ne $datemin || $xmax ne $datemax) {
                    $gr_props{$id}{redraw} = 1;
                } else {
                    $gr_props{$id}{xmin} = $xmin;
                    $gr_props{$id}{xmax} = $xmax;
                }
            } else {
                $base_jd = &date2jdate(sprintf("%04d%02d%02d", $byear, 1, 1));
                $datemin = &jdate2datelabel($xmin +$base_jd -1, "Mon-DD-YYYY");
                $datemax = &jdate2datelabel($xmax +$base_jd -1, "Mon-DD-YYYY");
                if ($gr_props{$id}{xmin} ne $datemin || $gr_props{$id}{xmax} ne $datemax) {
                    $gr_props{$id}{redraw} = 1;
                } else {
                    $gr_props{$id}{xmin} = $xmin;
                    $gr_props{$id}{xmax} = $xmax;
                }
            }
        } elsif ($xaxis_type eq "Julian Date") {
            $base_jd    = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
            $jd_min_old = $gr_props{$id}{xmin} + $base_jd -1;
            $jd_max_old = $gr_props{$id}{xmax} + $base_jd -1;
            $base_jd    = &date2jdate(sprintf("%04d%02d%02d", $byear, 1, 1));
            $jd_min     = $xmin + $base_jd -1;
            $jd_max     = $xmax + $base_jd -1;
            if ($jd_min != $jd_min_old || $jd_max != $jd_max_old) {
                $gr_props{$id}{redraw} = 1;
            } else {
                $gr_props{$id}{xmin} = $xmin;
                $gr_props{$id}{xmax} = $xmax;
            }
        }
        $gr_props{$id}{xtype}     = $xaxis_type;
        $gr_props{$id}{base_yr}   = $byear;
        $gr_props{$id}{dateline}  = $dateline;
        $gr_props{$id}{datelinec} = $datelinec;
        if ($props{$id}{parm} eq "Temperature") {
            $gr_props{$id}{redraw}  = 1 if ($props{$id}{parm_units} ne $wt_units);
            $refresh_info           = 1 if ($props{$id}{parm_units} ne $wt_units);
            $props{$id}{parm_units} = $wt_units;
        }
        $xmajor = "auto" if ($xmaj_auto);

    } elsif ($props{$id}{meta} =~ /time_series/) {
        $xmajor = "auto" if ($xmaj_auto);
        $gr_props{$id}{datefmt}   = $datefmt;
        $gr_props{$id}{legtitle}  = $legtitle;
        $gr_props{$id}{legfont}   = $legfont;
        $gr_props{$id}{lt_size}   = $lt_size;
        $gr_props{$id}{lt_weight} = $lt_weight;
        $gr_props{$id}{le_size}   = $le_size;
        $gr_props{$id}{le_weight} = $le_weight;
        $gr_props{$id}{le_edge}   = $le_edge;
        $gr_props{$id}{le_edgec}  = $le_edgec;
        $gr_props{$id}{le_fill}   = $le_fill;
        $gr_props{$id}{le_fillc}  = $le_fillc;
        $gr_props{$id}{gridx}     = $gridx;
        $gr_props{$id}{gridy}     = $gridy;
        $gr_props{$id}{gridwidth} = $gridwidth;
        $gr_props{$id}{gridcolor} = $gridcolor;
        if ($gr_props{$id}{xtype} ne $xaxis_type) {
            if ($xaxis_type eq "Date/Time") {
                $base_jd = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
                $datemin = &jdate2datelabel($gr_props{$id}{xmin} +$base_jd -1, "Mon-DD-YYYY");
                $datemax = &jdate2datelabel($gr_props{$id}{xmax} +$base_jd -1, "Mon-DD-YYYY");
                if ($xmin ne $datemin || $xmax ne $datemax) {
                    $gr_props{$id}{redraw} = 1;
                } else {
                    $gr_props{$id}{xmin} = $xmin;
                    $gr_props{$id}{xmax} = $xmax;
                }
            } else {
                $base_jd = &date2jdate(sprintf("%04d%02d%02d", $byear, 1, 1));
                $datemin = &jdate2datelabel($xmin +$base_jd -1, "Mon-DD-YYYY");
                $datemax = &jdate2datelabel($xmax +$base_jd -1, "Mon-DD-YYYY");
                if ($gr_props{$id}{xmin} ne $datemin || $gr_props{$id}{xmax} ne $datemax) {
                    $gr_props{$id}{redraw} = 1;
                } else {
                    $gr_props{$id}{xmin} = $xmin;
                    $gr_props{$id}{xmax} = $xmax;
                }
            }
        } elsif ($xaxis_type eq "Julian Date") {
            $base_jd    = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
            $jd_min_old = $gr_props{$id}{xmin} + $base_jd -1;
            $jd_max_old = $gr_props{$id}{xmax} + $base_jd -1;
            $base_jd    = &date2jdate(sprintf("%04d%02d%02d", $byear, 1, 1));
            $jd_min     = $xmin + $base_jd -1;
            $jd_max     = $xmax + $base_jd -1;
            if ($jd_min != $jd_min_old || $jd_max != $jd_max_old) {
                $gr_props{$id}{redraw} = 1;
            } else {
                $gr_props{$id}{xmin} = $xmin;
                $gr_props{$id}{xmax} = $xmax;
            }
        }
        $gr_props{$id}{xtype}     = $xaxis_type;
        $gr_props{$id}{base_yr}   = $byear;
        $gr_props{$id}{dateline}  = $dateline;
        $gr_props{$id}{datelinec} = $datelinec;

        if ($props{$id}{meta} eq "linked_time_series") {
            %parms                = %{ $props{$id}{ts_parms} };
            @ts_show              = @{ $ts_show_ref  };
            @ts_width             = @{ $ts_width_ref };
            @ts_color             = @{ $ts_color_ref };
            $parms{show}          = [ @ts_show  ];
            $parms{width}         = [ @ts_width ];
            $parms{color}         = [ @ts_color ];
            $props{$id}{ts_parms} = { %parms };
        }

        if (defined($props{$id}{add_ts_parms})) {
            @add_ts_show   = @{ $add_ts_show_ref   };
            @add_ts_setnum = @{ $add_ts_setnum_ref };
            @add_ts_width  = @{ $add_ts_width_ref  };
            @add_ts_color  = @{ $add_ts_color_ref  };
            @add_ts_text   = @{ $add_ts_text_ref   };
            @add_ts_file   = @{ $add_ts_file_ref   };
            @add_ts_ftype  = @{ $add_ts_ftype_ref  };
            @add_ts_lines  = @{ $add_ts_lines_ref  };
            @add_ts_param  = @{ $add_ts_param_ref  };
            @add_ts_byear  = @{ $add_ts_byear_ref  };
            @add_ts_tzoff  = @{ $add_ts_tzoff_ref  };
            @add_ts_seg    = @{ $add_ts_seg_ref    };
            @add_ts_ctype  = @{ $add_ts_ctype_ref  };
            @add_ts_limits = @{ $add_ts_limits_ref };
            @add_ts_tsdata = @{ $add_ts_tsdata_ref };
            @add_ts_delete = @{ $add_ts_delete_ref };

#           Delete any datasets marked for deletion, and re-order the others
            $gtag = "graph" . $id;
            for ($i=$#add_ts_delete; $i>=0; $i--) {
                if ($add_ts_delete[$i]) {
                    $refresh_menu = 1;
                    $refresh_info = 1;
                    $canvas->delete($gtag . "_dataset" . $add_ts_setnum[$i]);
                    splice (@add_ts_show,   $i, 1);
                    splice (@add_ts_setnum, $i, 1);
                    splice (@add_ts_width,  $i, 1);
                    splice (@add_ts_color,  $i, 1);
                    splice (@add_ts_text,   $i, 1);
                    splice (@add_ts_file,   $i, 1);
                    splice (@add_ts_ftype,  $i, 1);
                    splice (@add_ts_lines,  $i, 1);
                    splice (@add_ts_param,  $i, 1);
                    splice (@add_ts_byear,  $i, 1);
                    splice (@add_ts_tzoff,  $i, 1);
                    splice (@add_ts_seg,    $i, 1);
                    splice (@add_ts_ctype,  $i, 1);
                    splice (@add_ts_limits, $i, 1);
                    splice (@add_ts_tsdata, $i, 1);
                    for ($ii=$i; $ii<=$#add_ts_show; $ii++) {
                        $old_tag = $gtag . "_dataset" . $add_ts_setnum[$ii];
                        $add_ts_setnum[$ii]--;
                        $new_tag = $gtag . "_dataset" . $add_ts_setnum[$ii];
                        $canvas->addtag($new_tag, withtag => $old_tag);
                        $canvas->dtag($old_tag);
                    }
                }
            }
            %add_ts_parms             = ();
            $add_ts_parms{ts_setnum}  = [ @add_ts_setnum ];
            $add_ts_parms{ts_show}    = [ @add_ts_show   ];
            $add_ts_parms{ts_width}   = [ @add_ts_width  ];
            $add_ts_parms{ts_color}   = [ @add_ts_color  ];
            $add_ts_parms{ts_text}    = [ @add_ts_text   ];
            $add_ts_parms{ts_file}    = [ @add_ts_file   ];
            $add_ts_parms{ts_ftype}   = [ @add_ts_ftype  ];
            $add_ts_parms{ts_lines}   = [ @add_ts_lines  ];
            $add_ts_parms{ts_param}   = [ @add_ts_param  ];
            $add_ts_parms{ts_byear}   = [ @add_ts_byear  ];
            $add_ts_parms{ts_tzoff}   = [ @add_ts_tzoff  ];
            $add_ts_parms{ts_seg}     = [ @add_ts_seg    ];
            $add_ts_parms{ts_ctype}   = [ @add_ts_ctype  ];
            $add_ts_parms{ts_limits}  = [ @add_ts_limits ];
            $add_ts_parms{ts_data}    = [ @add_ts_tsdata ];
            $props{$id}{add_ts_parms} = { %add_ts_parms  };

            $gr_props{$id}{redraw} = 1 if ($sets_swapped && $#add_ts_setnum > 0);
            if ($#add_ts_setnum >= 0) {
                $gr_props{$id}{redraw}  = 1 if ($gap_tol != $gr_props{$id}{gap_tol});
                $gr_props{$id}{gap_tol} = $gap_tol;
            }
        }
    }
    if (defined($gr_props{$id}{add_cs}) && $gr_props{$id}{add_cs}) {
        $gr_props{$id}{redraw} = 1 if ($gr_props{$id}{cscheme1} ne $cs1    ||
                                       $gr_props{$id}{cscheme2} ne $cs2    ||
                                       $gr_props{$id}{ncolors}  != $nc     ||
                                       $gr_props{$id}{cs_rev}   != $rev    ||
                                       $gr_props{$id}{cs_min}   != $cs_min ||
                                       $gr_props{$id}{cs_max}   != $cs_max
                                      );
    }
    if ($props{$id}{meta} =~ /w2_slice|w2_wlevels/) {
        $gr_props{$id}{redraw} = 1 if ($gr_props{$id}{ymin} != $ymin ||
                                       $gr_props{$id}{ymax} != $ymax
                                      );
    } elsif ($props{$id}{meta} eq "w2_tdmap") {
        if ($gr_props{$id}{date_axis} eq "X") {
            $gr_props{$id}{redraw} = 1 if ( $gr_props{$id}{tmin} ne $xmin ||
                                            $gr_props{$id}{tmax} ne $xmax );
        } else {
            $gr_props{$id}{redraw} = 1 if ( $gr_props{$id}{tmin} ne $ymin ||
                                            $gr_props{$id}{tmax} ne $ymax );
        }
    } elsif ($props{$id}{meta} =~ /(data_profile_cmap|w2_profile_cmap|time_series)/) {
        $gr_props{$id}{redraw} = 1 if ($gr_props{$id}{xmin} ne $xmin ||
                                       $gr_props{$id}{xmax} ne $xmax ||
                                       $gr_props{$id}{ymin} != $ymin ||
                                       $gr_props{$id}{ymax} != $ymax
                                      );
    } else {
        $gr_props{$id}{redraw} = 1 if ($gr_props{$id}{xmin} != $xmin ||
                                       $gr_props{$id}{xmax} != $xmax ||
                                       $gr_props{$id}{ymin} != $ymin ||
                                       $gr_props{$id}{ymax} != $ymax
                                      );
    }

    if (defined($gr_props{$id}{add_cs})) {
        $gr_props{$id}{cs_link}   = $cs_link;
        $gr_props{$id}{cscheme1}  = $cs1;
        $gr_props{$id}{cscheme2}  = $cs2;
        $gr_props{$id}{ncolors}   = $nc;
        $gr_props{$id}{cs_rev}    = $rev;
        $gr_props{$id}{cs_min}    = $cs_min;
        $gr_props{$id}{cs_max}    = $cs_max;
        $gr_props{$id}{cs_major}  = $cs_major;
        $gr_props{$id}{cs_width}  = $cs_width;
        $gr_props{$id}{cs_height} = $cs_height;

        $gr_props{$id}{keytitle}  = $keytitle;
        $gr_props{$id}{keyfont}   = $keyfont;
        $gr_props{$id}{kt_size}   = $kt_size;
        $gr_props{$id}{kt_weight} = $kt_weight;
        $gr_props{$id}{kn_size}   = $kn_size;
        $gr_props{$id}{kn_weight} = $kn_weight;
        $gr_props{$id}{kn_digits} = $kn_digits;

#       Update the consistency of color-scheme linkages
#       Don't check for links unless color scheme is active
        if ($props{$id}{meta} =~ /data_profile|w2_profile|w2_slice|w2_tdmap|w2_outflow|vert_wd_zone/) {
            foreach $item (@animate_ids) {
                next if ($item == $id);
                next if ($props{$item}{meta} =~ /time_series|w2_wlevels/);
                $gr_props{$item}{redraw} = 0;
            }
        }
        if ($props{$id}{meta} =~ /data_profile|w2_profile|w2_slice|w2_tdmap|w2_outflow|vert_wd_zone/
              && $gr_props{$id}{add_cs}) {
            foreach $item (@animate_ids) {
                next if ($item == $id);
                next if ($props{$item}{meta} =~ /time_series|w2_wlevels/);
                $update_cs = 0;

#               Test for same parameter and same units
                if ($cs_link == 2) {
                    if ($props{$item}{meta} =~ /w2_profile|w2_slice|w2_outflow/) {
                        if ($props{$id}{meta} =~ /w2_profile|w2_slice|w2_outflow/
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$item}{parm_div}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                        } elsif ($props{$id}{meta} eq "w2_tdmap"
                             && $props{$id}{map_type}     eq "standard"
                             && $props{$item}{parm}       eq $props{$id}{parm_sav}
                             && $props{$item}{parm_div}   eq $props{$id}{pdiv_sav}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                        } elsif ($props{$id}{meta} =~ /data_profile/
                             && $props{$id}{prof_type}    eq "standard"
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$item}{parm_div}   eq "None"
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                        } elsif ($props{$id}{meta} =~ /vert_wd_zone/
                             && $props{$item}{parm}       eq "Temperature"
                             && $props{$item}{parm_div}   eq "None"
                             && $props{$item}{parm_units} eq $props{$id}{wt_units}) {
                            $update_cs = 1;
                        }
                    } elsif ($props{$item}{meta} eq "w2_tdmap") {
                        if ($props{$id}{meta} =~ /w2_profile|w2_slice|w2_outflow/
                             && $props{$item}{map_type}   eq "standard"
                             && $props{$item}{parm_sav}   eq $props{$id}{parm}
                             && $props{$item}{pdiv_sav}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                        } elsif ($props{$id}{meta} eq "w2_tdmap"
                             && $props{$item}{map_type}   eq $props{$id}{map_type}
                             && $props{$item}{parm_sav}   eq $props{$id}{parm_sav}
                             && $props{$item}{pdiv_sav}   eq $props{$id}{pdiv_sav}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}
                             && ($props{$id}{map_type} eq "standard"
                                || ($props{$item}{parm2_sav} eq $props{$id}{parm2_sav}
                                 && $props{$item}{pdiv2_sav} eq $props{$id}{pdiv2_sav}))) {
                            $update_cs = 1;
                        } elsif ($props{$id}{meta} =~ /data_profile/
                             && $props{$item}{map_type}   eq "standard"
                             && $props{$id}{prof_type}    eq "standard"
                             && $props{$item}{parm_sav}   eq $props{$id}{parm}
                             && $props{$item}{pdiv_sav}   eq "None"
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                        } elsif ($props{$id}{meta} =~ /vert_wd_zone/
                             && $props{$item}{map_type}   eq "standard"
                             && $props{$item}{parm_sav}   eq "Temperature"
                             && $props{$item}{pdiv_sav}   eq "None"
                             && $props{$item}{parm_units} eq $props{$id}{wt_units}) {
                            $update_cs = 1;
                        }
                    } elsif ($props{$item}{meta} =~ /data_profile/) {
                        if ($props{$id}{meta} =~ /data_profile/
                             && $props{$item}{prof_type}  eq $props{$id}{prof_type}
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                        } elsif ($props{$id}{meta} =~ /w2_profile|w2_slice|w2_outflow/
                             && $props{$item}{prof_type}  eq "standard"
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$id}{parm_div}     eq "None"
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                        } elsif ($props{$id}{meta} eq "w2_tdmap"
                             && $props{$id}{map_type}     eq "standard"
                             && $props{$item}{prof_type}  eq "standard"
                             && $props{$item}{parm}       eq $props{$id}{parm_sav}
                             && $props{$id}{pdiv_sav}     eq "None"
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                        } elsif ($props{$id}{meta} =~ /vert_wd_zone/
                             && $props{$item}{prof_type}  eq "standard"
                             && $props{$item}{parm}       eq "Temperature"
                             && $props{$item}{parm_units} eq $props{$id}{wt_units}) {
                            $update_cs = 1;
                        }
                    } elsif ($props{$item}{meta} =~ /vert_wd_zone/) {
                        if ($props{$id}{meta} =~ /data_profile/
                             && $props{$id}{prof_type}  eq "standard"
                             && $props{$id}{parm}       eq "Temperature"
                             && $props{$item}{wt_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                        } elsif ($props{$id}{meta} =~ /w2_profile|w2_slice|w2_outflow/
                             && $props{$id}{parm}       eq "Temperature"
                             && $props{$id}{parm_div}   eq "None"
                             && $props{$item}{wt_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                        } elsif ($props{$id}{meta} eq "w2_tdmap"
                             && $props{$id}{map_type}   eq "standard"
                             && $props{$id}{parm_sav}   eq "Temperature"
                             && $props{$id}{pdiv_sav}   eq "None"
                             && $props{$item}{wt_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                        } elsif ($props{$id}{meta} =~ /vert_wd_zone/
                             && $props{$item}{wt_units} eq $props{$id}{wt_units}) {
                            $update_cs = 1;
                        }
                    }

#               Test for same source in addition to same parameter and same units
                } elsif ($cs_link == 1) {
                    if ($props{$item}{meta} =~ /w2_profile|w2_outflow/) {
                        if ($props{$id}{meta} =~ /w2_profile|w2_outflow/
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$item}{parm_div}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            if ($props{$item}{src_file} eq $props{$id}{src_file}) {
                                $update_cs = 1;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        } elsif (($props{$id}{meta} =~ /w2_slice/
                                  && $props{$item}{parm}       eq $props{$id}{parm}
                                  && $props{$item}{parm_div}   eq $props{$id}{parm_div}
                                  && $props{$item}{parm_units} eq $props{$id}{parm_units})
                              || ($props{$id}{meta} eq "w2_tdmap"
                                  && $props{$id}{map_type}     eq "standard"
                                  && $props{$item}{parm}       eq $props{$id}{parm_sav}
                                  && $props{$item}{parm_div}   eq $props{$id}{pdiv_sav}
                                  && $props{$item}{parm_units} eq $props{$id}{parm_units})) {
                            if ($props{$id}{src_type} =~ /Contour/i) {
                                @wbs       = split(/,/, $props{$id}{wb_list});
                                @cpl_files = @{ $props{$id}{cpl_files} };
                                for ($n=0; $n<=$#wbs; $n++) {
                                    if ($cpl_files[$n] eq $props{$item}{src_file}) {
                                        $update_cs = 1;
                                        last;
                                    }
                                }
                            } elsif ($props{$id}{src_type} =~ /Vector/i) {
                                $update_cs = 1 if ($props{$id}{w2l_file} eq $props{$item}{src_file});
                            }
                            if (! $update_cs && $gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        }
                    } elsif ($props{$item}{meta} =~ /w2_slice/) {
                        if ($props{$id}{meta} =~ /w2_slice/
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$item}{parm_div}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            if ($props{$item}{con_file} eq $props{$id}{con_file}
                                 && $props{$item}{src_type} eq $props{$id}{src_type}) {
                                $update_cs = 1;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        } elsif ($props{$id}{meta} eq "w2_tdmap"
                             && $props{$id}{map_type}     eq "standard"
                             && $props{$item}{parm}       eq $props{$id}{parm_sav}
                             && $props{$item}{parm_div}   eq $props{$id}{pdiv_sav}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            if ($props{$item}{con_file} eq $props{$id}{con_file}
                                 && $props{$item}{src_type} eq $props{$id}{src_type}) {
                                $update_cs = 1;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        } elsif ($props{$id}{meta} =~ /w2_profile|w2_outflow/
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$item}{parm_div}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            if ($props{$item}{src_type} =~ /Contour/i) {
                                @wbs       = split(/,/, $props{$item}{wb_list});
                                @cpl_files = @{ $props{$item}{cpl_files} };
                                for ($n=0; $n<=$#wbs; $n++) {
                                    if ($cpl_files[$n] eq $props{$id}{src_file}) {
                                        $update_cs = 1;
                                        last;
                                    }
                                }
                            } elsif ($props{$item}{src_type} =~ /Vector/i) {
                                $update_cs = 1 if ($props{$item}{w2l_file} eq $props{$id}{src_file});
                            }
                            if (! $update_cs && $gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        }
                    } elsif ($props{$item}{meta} eq "w2_tdmap") {
                        if ($props{$id}{meta} =~ /w2_slice/
                             && $props{$item}{map_type}   eq "standard"
                             && $props{$item}{parm_sav}   eq $props{$id}{parm}
                             && $props{$item}{pdiv_sav}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            if ($props{$item}{con_file} eq $props{$id}{con_file}
                                 && $props{$item}{src_type} eq $props{$id}{src_type}) {
                                $update_cs = 1;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        } elsif ($props{$id}{meta} eq "w2_tdmap"
                             && $props{$item}{map_type}   eq $props{$id}{map_type}
                             && $props{$item}{parm_sav}   eq $props{$id}{parm_sav}
                             && $props{$item}{pdiv_sav}   eq $props{$id}{pdiv_sav}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}
                             && ($props{$id}{map_type} eq "standard"
                                || ($props{$item}{parm2_sav} eq $props{$id}{parm2_sav}
                                 && $props{$item}{pdiv2_sav} eq $props{$id}{pdiv2_sav}))) {
                            if ($props{$item}{con_file} eq $props{$id}{con_file}
                                 && $props{$item}{src_type} eq $props{$id}{src_type}
                                 && ($props{$id}{map_type} eq "standard"
                                     || $props{$item}{src_type2} eq $props{$id}{src_type2})) {
                                $update_cs = 1;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        } elsif ($props{$id}{meta} =~ /w2_profile|w2_outflow/
                             && $props{$item}{map_type}   eq "standard"
                             && $props{$item}{parm_sav}   eq $props{$id}{parm}
                             && $props{$item}{pdiv_sav}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            if ($props{$item}{src_type} =~ /Contour/i) {
                                @wbs       = split(/,/, $props{$item}{wb_list});
                                @cpl_files = @{ $props{$item}{cpl_files} };
                                for ($n=0; $n<=$#wbs; $n++) {
                                    if ($cpl_files[$n] eq $props{$id}{src_file}) {
                                        $update_cs = 1;
                                        last;
                                    }
                                }
                            } elsif ($props{$item}{src_type} =~ /Vector/i) {
                                $update_cs = 1 if ($props{$item}{w2l_file} eq $props{$id}{src_file});
                            }
                            if (! $update_cs && $gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        }
                    } elsif ($props{$item}{meta} =~ /data_profile/) {
                        if ($props{$id}{meta} =~ /data_profile/
                             && $props{$item}{prof_type}  eq $props{$id}{prof_type}
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            if ($props{$item}{src_file} eq $props{$id}{src_file}) {
                                $update_cs = 1;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        } elsif ($props{$id}{meta} =~ /vert_wd_zone/
                             && $props{$item}{prof_type}  eq "standard"
                             && $props{$item}{parm}       eq "Temperature"
                             && $props{$item}{parm_units} eq $props{$id}{wt_units}) {
                            if ($props{$item}{src_file} eq $props{$id}{wt_file}) {
                                $update_cs = 1;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        }
                    } elsif ($props{$item}{meta} =~ /vert_wd_zone/) {
                        if ($props{$id}{meta} =~ /vert_wd_zone/
                             && $props{$item}{wt_units} eq $props{$id}{wt_units}) {
                            if ($props{$item}{wt_file} eq $props{$id}{wt_file}) {
                                $update_cs = 1;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        } elsif ($props{$id}{meta} =~ /data_profile/
                             && $props{$id}{prof_type}  eq "standard"
                             && $props{$id}{parm}       eq "Temperature"
                             && $props{$item}{wt_units} eq $props{$id}{parm_units}) {
                            if ($props{$item}{wt_file} eq $props{$id}{src_file}) {
                                $update_cs = 1;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        }
                    }

#               Test for no links
                } elsif ($cs_link == 0) {
                    if ($props{$item}{meta} =~ /w2_profile|w2_outflow/) {
                        if ($props{$id}{meta} =~ /w2_profile|w2_outflow/
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$item}{parm_div}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            if ($props{$item}{src_file} eq $props{$id}{src_file}
                                 && $gr_props{$item}{cs_link} > 0) {
                                $gr_props{$item}{cs_link} = 0;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        } elsif (($props{$id}{meta} =~ /w2_slice/
                                  && $props{$item}{parm}       eq $props{$id}{parm}
                                  && $props{$item}{parm_div}   eq $props{$id}{parm_div}
                                  && $props{$item}{parm_units} eq $props{$id}{parm_units})
                              || ($props{$id}{meta} eq "w2_tdmap"
                                  && $props{$id}{map_type}     eq "standard"
                                  && $props{$item}{parm}       eq $props{$id}{parm_sav}
                                  && $props{$item}{parm_div}   eq $props{$id}{pdiv_sav}
                                  && $props{$item}{parm_units} eq $props{$id}{parm_units})) {
                            $match = 0;
                            if ($props{$id}{src_type} =~ /Contour/i) {
                                @wbs       = split(/,/, $props{$id}{wb_list});
                                @cpl_files = @{ $props{$id}{cpl_files} };
                                for ($n=0; $n<=$#wbs; $n++) {
                                    if ($cpl_files[$n] eq $props{$item}{src_file}) {
                                        $match = 1;
                                        last;
                                    }
                                }
                            } elsif ($props{$id}{src_type} =~ /Vector/i) {
                                $match = 1 if ($props{$id}{w2l_file} eq $props{$item}{src_file});
                            }
                            if ($match && $gr_props{$item}{cs_link} > 0) {
                                $gr_props{$item}{cs_link} = 0;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        }
                    } elsif ($props{$item}{meta} =~ /w2_slice/) {
                        if ($props{$id}{meta} =~ /w2_slice/
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$item}{parm_div}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            if ($props{$item}{con_file} eq $props{$id}{con_file}
                                 && $props{$item}{src_type} eq $props{$id}{src_type}
                                 && $gr_props{$item}{cs_link} > 0) {
                                $gr_props{$item}{cs_link} = 0;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        } elsif ($props{$id}{meta} eq "w2_tdmap"
                             && $props{$id}{map_type}     eq "standard"
                             && $props{$item}{parm}       eq $props{$id}{parm_sav}
                             && $props{$item}{parm_div}   eq $props{$id}{pdiv_sav}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            if ($props{$item}{con_file} eq $props{$id}{con_file}
                                 && $props{$item}{src_type} eq $props{$id}{src_type}
                                 && $gr_props{$item}{cs_link} > 0) {
                                $gr_props{$item}{cs_link} = 0;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        } elsif ($props{$id}{meta} =~ /w2_profile|w2_outflow/
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$item}{parm_div}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            $match = 0;
                            if ($props{$item}{src_type} =~ /Contour/i) {
                                @wbs       = split(/,/, $props{$item}{wb_list});
                                @cpl_files = @{ $props{$item}{cpl_files} };
                                for ($n=0; $n<=$#wbs; $n++) {
                                    if ($cpl_files[$n] eq $props{$id}{src_file}) {
                                        $match = 1;
                                        last;
                                    }
                                }
                            } elsif ($props{$item}{src_type} =~ /Vector/i) {
                                $match = 1 if ($props{$item}{w2l_file} eq $props{$id}{src_file});
                            }
                            if ($match && $gr_props{$item}{cs_link} > 0) {
                                $gr_props{$item}{cs_link} = 0;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        }
                    } elsif ($props{$item}{meta} eq "w2_tdmap") {
                        if ($props{$id}{meta} =~ /w2_slice/
                             && $props{$item}{map_type}   eq "standard"
                             && $props{$item}{parm_sav}   eq $props{$id}{parm}
                             && $props{$item}{pdiv_sav}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            if ($props{$item}{con_file} eq $props{$id}{con_file}
                                 && $props{$item}{src_type} eq $props{$id}{src_type}
                                 && $gr_props{$item}{cs_link} > 0) {
                                $gr_props{$item}{cs_link} = 0;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        } elsif ($props{$id}{meta} eq "w2_tdmap"
                             && $props{$item}{map_type}   eq $props{$id}{map_type}
                             && $props{$item}{parm_sav}   eq $props{$id}{parm_sav}
                             && $props{$item}{pdiv_sav}   eq $props{$id}{pdiv_sav}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            if ($props{$item}{con_file} eq $props{$id}{con_file}
                                 && $props{$item}{src_type} eq $props{$id}{src_type}
                                 && ($props{$id}{map_type} eq "standard"
                                     || $props{$item}{src_type2} eq $props{$id}{src_type2})
                                 && $gr_props{$item}{cs_link} > 0) {
                                $gr_props{$item}{cs_link} = 0;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        } elsif ($props{$id}{meta} =~ /w2_profile|w2_outflow/
                             && $props{$item}{map_type}   eq "standard"
                             && $props{$item}{parm_sav}   eq $props{$id}{parm}
                             && $props{$item}{pdiv_sav}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            $match = 0;
                            if ($props{$item}{src_type} =~ /Contour/i) {
                                @wbs       = split(/,/, $props{$item}{wb_list});
                                @cpl_files = @{ $props{$item}{cpl_files} };
                                for ($n=0; $n<=$#wbs; $n++) {
                                    if ($cpl_files[$n] eq $props{$id}{src_file}) {
                                        $match = 1;
                                        last;
                                    }
                                }
                            } elsif ($props{$item}{src_type} =~ /Vector/i) {
                                $match = 1 if ($props{$item}{w2l_file} eq $props{$id}{src_file});
                            }
                            if ($match && $gr_props{$item}{cs_link} > 0) {
                                $gr_props{$item}{cs_link} = 0;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        }
                    } elsif ($props{$item}{meta} =~ /data_profile/) {
                        if ($props{$id}{meta} =~ /data_profile/
                             && $props{$item}{prof_type}  eq $props{$id}{prof_type}
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            if ($props{$item}{src_file} eq $props{$id}{src_file}
                                 && $gr_props{$item}{cs_link} > 0) {
                                $gr_props{$item}{cs_link} = 0;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        } elsif ($props{$id}{meta} =~ /vert_wd_zone/
                             && $props{$item}{prof_type}  eq "standard"
                             && $props{$item}{parm}       eq "Temperature"
                             && $props{$item}{parm_units} eq $props{$id}{wt_units}) {
                            if ($props{$item}{src_file} eq $props{$id}{wt_file}
                                 && $gr_props{$item}{cs_link} > 0) {
                                $gr_props{$item}{cs_link} = 0;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        }
                    } elsif ($props{$item}{meta} =~ /vert_wd_zone/) {
                        if ($props{$id}{meta} =~ /vert_wd_zone/
                             && $props{$item}{wt_units} eq $props{$id}{wt_units}) {
                            if ($props{$item}{wt_file} eq $props{$id}{wt_file}
                                 && $gr_props{$item}{cs_link} > 0) {
                                $gr_props{$item}{cs_link} = 0;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        } elsif ($props{$id}{meta} =~ /data_profile/
                             && $props{$id}{prof_type}  eq "standard"
                             && $props{$id}{parm}       eq "Temperature"
                             && $props{$item}{wt_units} eq $props{$id}{parm_units}) {
                            if ($props{$item}{wt_file} eq $props{$id}{src_file}
                                 && $gr_props{$item}{cs_link} > 0) {
                                $gr_props{$item}{cs_link} = 0;
                            } elsif ($gr_props{$item}{cs_link} == 2) {
                                $gr_props{$item}{cs_link} = 1;
                            }
                        }
                    }
                }
                next if (! $update_cs);
                if ($gr_props{$item}{add_cs}) {
                    $gr_props{$item}{redraw} = 1 if ($gr_props{$item}{cscheme1} ne $cs1    ||
                                                     $gr_props{$item}{cscheme2} ne $cs2    ||
                                                     $gr_props{$item}{ncolors}  != $nc     ||
                                                     $gr_props{$item}{cs_rev}   != $rev    ||
                                                     $gr_props{$item}{cs_min}   != $cs_min ||
                                                     $gr_props{$item}{cs_max}   != $cs_max
                                                    );
                }
                $ncolors                   = $gr_props{$item}{ncolors};
                $gr_props{$item}{cscheme1} = $cs1;
                $gr_props{$item}{cscheme2} = $cs2;
                $gr_props{$item}{ncolors}  = $nc;
                $gr_props{$item}{cs_rev}   = $rev;
                $gr_props{$item}{cs_min}   = $cs_min;
                $gr_props{$item}{cs_max}   = $cs_max;
                $gr_props{$item}{cs_major} = $cs_major;
                if ($ncolors != $nc) {
                    $gr_props{$item}{cs_height}
                        = &max(2, &min(30, &round_to_int($gr_props{$item}{cs_height} *$ncolors /$nc)));
                }
            }
        }
    }

    if ($props{$id}{meta} eq "w2_tdmap") {
        if ($gr_props{$id}{date_axis} eq "X") {
            $gr_props{$id}{ttitle}    = $xtitle;
            $gr_props{$id}{tfont}     = $xfont;
            $gr_props{$id}{tt_size}   = $xt_size;
            $gr_props{$id}{tt_weight} = $xt_weight;
            $gr_props{$id}{tl_size}   = $xl_size;
            $gr_props{$id}{tl_weight} = $xl_weight;
            $gr_props{$id}{tmin}      = $xmin;
            $gr_props{$id}{tmax}      = $xmax;
            $gr_props{$id}{tmajor}    = $xmajor;
            $gr_props{$id}{tpr_tics}  = $xpr_tics;
            $gr_props{$id}{top_tics}  = $xop_tics;
            $gr_props{$id}{dtitle}    = $ytitle;
            $gr_props{$id}{dfont}     = $yfont;
            $gr_props{$id}{dt_size}   = $yt_size;
            $gr_props{$id}{dt_weight} = $yt_weight;
            $gr_props{$id}{dl_size}   = $yl_size;
            $gr_props{$id}{dl_weight} = $yl_weight;
            $gr_props{$id}{dunits}    = $yaxis_units;
            $gr_props{$id}{dbase}     = $ybase;
            $gr_props{$id}{dmin}      = $ymin;
            $gr_props{$id}{dmax}      = $ymax;
            $gr_props{$id}{dfirst}    = $yfirst;
            $gr_props{$id}{dmajor}    = $ymajor;
            $gr_props{$id}{dpr_tics}  = $ypr_tics;
            $gr_props{$id}{dop_tics}  = $yop_tics;
            $gr_props{$id}{dmax_auto} = $ymax_auto;
            $gr_props{$id}{dflip_img} = ($gr_props{$id}{dflip} != $yaxis_flip) ? 1 : 0;
            $gr_props{$id}{dflip}     = $yaxis_flip;
        } else {
            $gr_props{$id}{dtitle}    = $xtitle;
            $gr_props{$id}{dfont}     = $xfont;
            $gr_props{$id}{dt_size}   = $xt_size;
            $gr_props{$id}{dt_weight} = $xt_weight;
            $gr_props{$id}{dl_size}   = $xl_size;
            $gr_props{$id}{dl_weight} = $xl_weight;
            $gr_props{$id}{dunits}    = $xaxis_units;
            $gr_props{$id}{dbase}     = $xbase;
            $gr_props{$id}{dmin}      = $xmin;
            $gr_props{$id}{dmax}      = $xmax;
            $gr_props{$id}{dfirst}    = $xfirst;
            $gr_props{$id}{dmajor}    = $xmajor;
            $gr_props{$id}{dpr_tics}  = $xpr_tics;
            $gr_props{$id}{dop_tics}  = $xop_tics;
            $gr_props{$id}{dmax_auto} = $xmax_auto;
            $gr_props{$id}{dflip_img} = ($gr_props{$id}{dflip} != $xaxis_flip) ? 1 : 0;
            $gr_props{$id}{dflip}     = $xaxis_flip;
            $gr_props{$id}{ttitle}    = $ytitle;
            $gr_props{$id}{tfont}     = $yfont;
            $gr_props{$id}{tt_size}   = $yt_size;
            $gr_props{$id}{tt_weight} = $yt_weight;
            $gr_props{$id}{tl_size}   = $yl_size;
            $gr_props{$id}{tl_weight} = $yl_weight;
            $gr_props{$id}{tmin}      = $ymin;
            $gr_props{$id}{tmax}      = $ymax;
            $gr_props{$id}{tmajor}    = $ymajor;
            $gr_props{$id}{tpr_tics}  = $ypr_tics;
            $gr_props{$id}{top_tics}  = $yop_tics;
        }
    } else {
        $gr_props{$id}{xtitle}    = $xtitle;
        $gr_props{$id}{xfont}     = $xfont;
        $gr_props{$id}{xt_size}   = $xt_size;
        $gr_props{$id}{xt_weight} = $xt_weight;
        $gr_props{$id}{xl_size}   = $xl_size;
        $gr_props{$id}{xl_weight} = $xl_weight;
        $gr_props{$id}{xmin}      = $xmin;
        $gr_props{$id}{xmax}      = $xmax;
        $gr_props{$id}{xmajor}    = $xmajor;
        $gr_props{$id}{xpr_tics}  = $xpr_tics;
        $gr_props{$id}{xop_tics}  = $xop_tics;
        $gr_props{$id}{ytitle}    = $ytitle;
        $gr_props{$id}{yfont}     = $yfont;
        $gr_props{$id}{yt_size}   = $yt_size;
        $gr_props{$id}{yt_weight} = $yt_weight;
        $gr_props{$id}{yl_size}   = $yl_size;
        $gr_props{$id}{yl_weight} = $yl_weight;
        $gr_props{$id}{ymin}      = $ymin;
        $gr_props{$id}{ymax}      = $ymax;
        $gr_props{$id}{ymajor}    = $ymajor;
        $gr_props{$id}{ypr_tics}  = $ypr_tics;
        $gr_props{$id}{yop_tics}  = $yop_tics;
    }

    $gr_props{$id}{gtitle}    = $gtitle;
    $gr_props{$id}{gtfont}    = $gtfont;
    $gr_props{$id}{gt_size}   = $gt_size;
    $gr_props{$id}{gt_weight} = $gt_weight;

    if ($props{$id}{meta} eq "vert_wd_zone" && $props{$id}{wd_alg} eq "Libby Dam") {
        if ($bh_status > 0) {
            $gr_props{$id}{bh_docked} = ($bh_status == 1) ? 1 : 0;
        }
        $gr_props{$id}{bh_show}   = ($bh_status > 0) ? 1 : 0;
        $gr_props{$id}{bh_font}   = $bh_font;
        $gr_props{$id}{bh_size}   = $bh_size;
        $gr_props{$id}{bh_weight} = $bh_weight;
        $gr_props{$id}{bh_tcolor} = $bh_tcolor;
        $gr_props{$id}{bh_bwidth} = $bh_bwidth;
        $gr_props{$id}{bh_bcolor} = $bh_bcolor;
        $gr_props{$id}{bh_bcellw} = $bh_bcellw;
        $gr_props{$id}{bh_bcellh} = $bh_bcellh;
    }

    if ($action eq "OK") {
        $graph_props_menu->g_destroy();
        undef $graph_props_menu;

#       When closing the graph properties menu window, if the mouse cursor is outside of the
#       main window, then a subsequent busy hold command won't change the mouse cursor shape.
#       Test for this condition, and move the mouse cursor if necessary.
        $move_mcursor = 0;
        if ($props{$id}{meta}
                =~ /(data_profile|w2_profile|w2_tdmap|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)/) {
            foreach $item (@animate_ids) {
                if (($props{$item}{meta} =~ /data_profile_cmap|w2_tdmap|w2_profile_cmap/
                       && $gr_props{$item}{redraw})
                   || ($props{$item}{meta} eq "w2_slice"
                       && ($gr_props{$item}{redraw} || $gr_props{$id}{xflip_img}))) {
                    $move_mcursor = 1;
                    last;
                }
            }
        }
        if ($move_mcursor) {
            if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
                $canvas->g_bind("<Motion>", "");
                Tkx::event_generate($main, "<Motion>", -warp => 1, -x => ($x1+$x2)/2, -y => ($y1+$y2)/2);
                $canvas->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"), $canvas, "menu" ]);
            }
        }
    } elsif ($action eq "Apply" && $refresh_menu) {
        &edit_graph_props($id, $X, $Y, $tabid);
    }
    &end_select($canvas, $id, 1);

    if ($props{$id}{meta}
            =~ /(data_profile|w2_profile|w2_tdmap|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)/) {
        foreach $item (@animate_ids) {
            next if ($props{$item}{meta} =~ /time_series/);
            if ($item == $id || $gr_props{$item}{redraw}) {
                if ($action eq "Apply" && defined($graph_props_menu)
                       && $props{$item}{meta} =~ /data_profile_cmap|w2_profile_cmap|w2_tdmap|w2_slice/) {
                    Tkx::tk_busy_hold($graph_props_menu, -cursor => $cursor_wait);
                    Tkx::update();
                }
                if ($props{$item}{meta} =~ /data_profile/) {
                    &make_data_profile($canvas, $item, 1);
                } elsif ($props{$item}{meta} =~ /w2_profile/) {
                    &make_w2_profile($canvas, $item, 1);
                } elsif ($props{$item}{meta} =~ /w2_slice/) {
                    &make_w2_slice($canvas, $item, 1);
                } elsif ($props{$item}{meta} =~ /w2_tdmap/) {
                    &make_w2_tdmap($canvas, $item, 1);
                } elsif ($props{$item}{meta} =~ /w2_outflow/) {
                    &make_w2_outflow($canvas, $item, 1);
                } elsif ($props{$item}{meta} =~ /w2_wlevels/) {
                    &make_w2_wlevels($canvas, $item, 1);
                } elsif ($props{$item}{meta} =~ /vert_wd_zone/) {
                    &make_wd_zone($canvas, $item, 1);
                }
                if ($action eq "Apply" && defined($graph_props_menu)
                       && $props{$item}{meta} =~ /data_profile_cmap|w2_profile_cmap|w2_tdmap|w2_slice/) {
                    Tkx::tk_busy_forget($graph_props_menu);
                }
            }
        }

    } elsif ($props{$id}{meta} =~ /time_series/) {
        &make_ts_graph($canvas, $id, 1);

    } else {   # some other type of graph -- future placeholder

    }

#   Refresh the Object Information box, if present
    if ($refresh_info && defined($object_infobox) && Tkx::winfo_exists($object_infobox)) {
        if ($object_infobox->g_wm_title() eq "Object Info") {
            $geom = $object_infobox->g_wm_geometry();
            (undef, $X, $Y) = split(/\+/, $geom);
            &show_info($canvas, $id, $X, $Y);
        }
    }

#   Refresh the Choose Datasets menu, if present
    if (defined($choose_sets_menu) && Tkx::winfo_exists($choose_sets_menu)) {
        if ($choose_sets_menu->g_wm_title() eq "Choose Datasets for Fit Statistics") {
            $geom = $choose_sets_menu->g_wm_geometry();
            (undef, $X, $Y) = split(/\+/, $geom);
            &choose_datasets($canvas, $id, $X, $Y);
        }
    }
}


sub edit_link {
    my ($canv, $id, $X, $Y, $link_id) = @_;
    my (
        $btn_txt, $code, $color, $color_btn, $color_label, $digits,
        $digits_label, $digits_sb, $f, $fg, $fmt, $font, $font_cb,
        $font_label, $form, $form_cb, $frame, $geom, $link_frame,
        $link_txt, $outlet, $outlet_cb, $outlet_label, $ph, $preview_canv,
        $preview_oval, $preview_poly, $preview_txt, $pw, $row, $size,
        $size_cb, $size_label, $slant, $type, $type_cb, $units, $units_cb,
        $units_label, $v, $weight, $weight_cb, $weight_label, $width,
        $width_label, $width_sb,

        @link_forms, @link_types, @names, @unit_opts,

        %form_coords,
       );

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($edit_link_menu) && Tkx::winfo_exists($edit_link_menu)) {
        if ($edit_link_menu->g_wm_title() eq "Add or Edit Link") {
            $edit_link_menu->g_destroy();
            undef $edit_link_menu;
        }
    }
    $edit_link_menu = $main->new_toplevel();
    $edit_link_menu->g_wm_transient($main);
    $edit_link_menu->g_wm_title("Add or Edit Link");
    $edit_link_menu->configure(-cursor => $cursor_norm);
    $edit_link_menu->g_wm_geometry($geom);

    if ($props{$id}{meta} eq "vert_wd_zone") {
        @link_types = ("Flow", "Temperature", "Water Surface Elevation");
        $type  = "Flow";
        $units = "cfs";
        @names = @{ $gr_props{$id}{names} };
        push (@names, "All Outlets");
    } else {
        @link_types = ("Water Surface Elevation");
        $type  = "Water Surface Elevation";
        $units = "ft";
        @names = ("All Outlets");
    }

    $outlet = "All Outlets";
    $form   = "Text";
    $digits = 0;
    $font   = $default_family;
    $weight = $default_weight;
    $size   = $default_size;
    $slant  = $default_slant;
    $width  = $default_width;
    $color  = $default_color;
    if ($link_id != 0) {
        $type   = $link_props{$link_id}{type};
        $outlet = $link_props{$link_id}{outlet};
        $form   = $link_props{$link_id}{form};
        $units  = $link_props{$link_id}{units};
        $digits = $link_props{$link_id}{digits};
        $font   = $props{$link_id}{family} if (defined($props{$link_id}{family}));
        $size   = $props{$link_id}{size}   if (defined($props{$link_id}{size}));
        $weight = $props{$link_id}{weight} if (defined($props{$link_id}{weight}));
        $slant  = $props{$link_id}{slant}  if (defined($props{$link_id}{slant}));
        $width  = $props{$link_id}{width}  if (defined($props{$link_id}{width}));
        $color  = $props{$link_id}{color};
    } else {
        &end_select($canv, $id, 1);
    }
    $form = "Text" if (! $gr_props{$id}{add_cs});
    $btn_txt = ($link_id == 0) ? "Create" : "Modify";

    $fmt = ($digits > 0) ? "%.${digits}f" : "%d";
    if ($type eq "Flow") {
        @unit_opts = ("cfs", "cms");
        $v         = ($units eq "cfs") ? 1000 : 50;
        $link_txt  = sprintf($fmt, $v) . " " . $units;
    } elsif ($type eq "Water Surface Elevation") {
        @unit_opts = ("ft", "m");
        $v         = ($units eq "ft") ? 1500 : 450;
        $link_txt  = sprintf($fmt, $v) . " " . $units;
    } else {
        @unit_opts = ("Celsius", "Fahrenheit");
        $v         = ($units eq "Celsius") ? 13 : 55;
        $link_txt  = sprintf($fmt, $v) . " "
                     . "\N{U+00B0}" . substr($units,0,1);
    }

    $pw = 270;
    $ph = 45;
    @link_forms  = ("Text", "Circle", "Ellipse", "Rectangle", "Diamond", "Polygon");
    %form_coords = ("Circle",    [ $pw*0.5 -$ph*0.3 +3, $ph*0.2 +3,
                                   $pw*0.5 +$ph*0.3 +3, $ph*0.8 +3  ],
                    "Ellipse",   [ $pw*0.2 +3, $ph*0.2 +3,
                                   $pw*0.8 +3, $ph*0.8 +3  ],
                    "Rectangle", [ $pw*0.2 +3, $ph*0.2 +3, $pw*0.8 +3, $ph*0.2 +3,
                                   $pw*0.8 +3, $ph*0.8 +3, $pw*0.2 +3, $ph*0.8 +3, ],
                    "Diamond",   [ $pw*0.5 +3, $ph*0.2 +3, $pw*0.8 +3, $ph*0.5 +3,
                                   $pw*0.5 +3, $ph*0.8 +3, $pw*0.2 +3, $ph*0.5 +3, ],
                    "Polygon",   [ $pw*0.25 +3, $ph*0.2 +3, $pw*0.6 +3, $ph*0.2 +3,
                                   $pw*0.75 +3, $ph*0.5 +3, $pw*0.6 +3, $ph*0.8 +3,
                                   $pw*0.25 +3, $ph*0.8 +3, ],
                   );

    $frame = $edit_link_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    $frame->new_button(
            -text    => $btn_txt,
            -command => sub { &set_link($canv, $id, $link_id, $type, $form, $units,
                                        $digits, $outlet, $font, $weight, $size,
                                        $width, $color,
                                        );
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $edit_link_menu->g_destroy();
                              undef $edit_link_menu; },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

    $f = $edit_link_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f->g_pack(-side => 'top');

    $preview_canv = $f->new_canvas(
            -background  => &get_rgb_code($canvas_color),
            -width       => $pw,
            -height      => $ph,
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $preview_canv->g_grid(-row => 0, -column => 0, -sticky => 'wne');

    $preview_txt = $preview_canv->create_text($pw*0.5 +3, $ph*0.5 +3,
            -anchor => 'center', 
            -text   => $link_txt,
            -fill   => "#000000",
            -angle  => 0,
            -font   => [-family     => $font,
                        -size       => $size,
                        -weight     => $weight,
                        -slant      => $slant_type[$slant],
                        -underline  => 0,
                        -overstrike => 0,
                       ]);
    $preview_poly = $preview_canv->create_polygon( @{ $form_coords{"Rectangle"} },
                       -width   => 1,
                       -outline => &get_rgb_code("black"),
                       -fill    => &get_rgb_code("yellow"),
                       -smooth  => 'false',
                       );
    $preview_oval = $preview_canv->create_oval( @{ $form_coords{"Circle"} },
                       -width   => 1,
                       -outline => &get_rgb_code("black"),
                       -fill    => &get_rgb_code("yellow"),
                       );

    if ($form eq "Text") {
        $preview_canv->itemconfigure($preview_poly, -state => 'hidden');
        $preview_canv->itemconfigure($preview_oval, -state => 'hidden');

    } elsif ($form =~ /^(Circle|Ellipse)$/) {
        $preview_canv->itemconfigure($preview_txt,  -state => 'hidden');
        $preview_canv->itemconfigure($preview_poly, -state => 'hidden');
        if ($form eq "Ellipse") {
            $preview_canv->coords($preview_oval, @{ $form_coords{"Ellipse"} });
        }
    } elsif ($form =~ /^(Rectangle|Diamond|Polygon)$/) {
        $preview_canv->itemconfigure($preview_txt,  -state => 'hidden');
        $preview_canv->itemconfigure($preview_oval, -state => 'hidden');
        if ($form =~ /^(Diamond|Polygon)$/) {
            $preview_canv->coords($preview_poly, @{ $form_coords{$form} });
        }
    }

    $link_frame = $f->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $link_frame->g_grid(-row => 1, -column => 0, -sticky => 'wnes');

    $row = 0;
    $link_frame->new_label(
            -text => "Link Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($type_cb = $link_frame->new_ttk__combobox(
            -textvariable => \$type,
            -values       => [ @link_types ],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $type_cb->g_bind("<<ComboboxSelected>>",
              sub { my ($add, $fmt, $v);
                    if ($type eq "Flow") {
                        @unit_opts = ("cfs", "cms");
                        $units = "cfs" if ($units !~ /^(cfs|cms)$/);
                        $v     = ($units eq "cfs") ? 1000 : 50;
                        $add   = " " . $units;
                        $form  = "Text";
                        $form_cb->configure(-state => 'disabled');
                        $outlet_label->g_grid();
                        $outlet_cb->g_grid();
                    } elsif ($type eq "Water Surface Elevation") {
                        @unit_opts = ("ft", "m");
                        $units = "ft" if ($units !~ /^(ft|m)$/);
                        $v     = ($units eq "ft") ? 1500 : 450;
                        $add   = " " . $units;
                        $form  = "Text";
                        $form_cb->configure(-state => 'disabled');
                        $outlet_label->g_grid_remove();
                        $outlet_cb->g_grid_remove();
                    } else {
                        @unit_opts = ("Celsius", "Fahrenheit");
                        $units = "Celsius" if ($units !~ /^(Celsius|Fahrenheit)$/);
                        $v     = ($units eq "Celsius") ? 13 : 55;
                        $add   = "\N{U+00B0}" . substr($units,0,1);
                        if ($gr_props{$id}{add_cs}) {
                            $form_cb->configure(-state => 'readonly');
                        }
                        $outlet_label->g_grid();
                        $outlet_cb->g_grid();
                    }
                    $units_cb->configure(-values => [ @unit_opts ]);
                    $fmt = ($digits > 0) ? "%.${digits}f" : "%d";
                    $preview_canv->itemconfigure($preview_txt,
                                       -state => 'normal',
                                       -text => sprintf($fmt, $v) . $add);
                    $preview_canv->itemconfigure($preview_poly, -state => 'hidden');
                    $preview_canv->itemconfigure($preview_oval, -state => 'hidden');
                    $width_label->g_grid_remove();
                    $width_sb->g_grid_remove();
                    $color_label->g_grid_remove();
                    $color_btn->g_grid_remove();
                    $units_label->g_grid();
                    $units_cb->g_grid();
                    $digits_label->g_grid();
                    $digits_sb->g_grid();
                    $font_label->g_grid();
                    $font_cb->g_grid();
                    $size_label->g_grid();
                    $size_cb->g_grid();
                    $weight_label->g_grid();
                    $weight_cb->g_grid();
                  });

    $row++;
    ($outlet_label = $link_frame->new_label(
            -text => "Link Outlet: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($outlet_cb = $link_frame->new_ttk__combobox(
            -textvariable => \$outlet,
            -values       => [ @names ],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    if ($type eq "Water Surface Elevation") {
        $outlet_label->g_grid_remove();
        $outlet_cb->g_grid_remove();
    }

    $row++;
    $link_frame->new_label(
            -text => "Link Form: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($form_cb = $link_frame->new_ttk__combobox(
            -textvariable => \$form,
            -values       => [ @link_forms ],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $form_cb->g_bind("<<ComboboxSelected>>",
              sub { my ($add, $fmt, $v);
                    if ($form eq "Text") {
                        if ($type eq "Flow") {
                            @unit_opts = ("cfs", "cms");
                            $units = "cfs" if ($units !~ /^(cfs|cms)$/);
                            $v     = ($units eq "cfs") ? 1000 : 50;
                            $add   = " " . $units;
                        } elsif ($type eq "Water Surface Elevation") {
                            @unit_opts = ("ft", "m");
                            $units = "ft" if ($units !~ /^(ft|m)$/);
                            $v     = ($units eq "ft") ? 1500 : 450;
                            $add   = " " . $units;
                        } else {
                            @unit_opts = ("Celsius", "Fahrenheit");
                            $units = "Celsius" if ($units =~ /^(cfs|cms)$/);
                            $v     = ($units eq "Celsius") ? 13 : 55;
                            $add   = "\N{U+00B0}" . substr($units,0,1);
                        }
                        $units_cb->configure(-values => [ @unit_opts ]);
                        $fmt = ($digits > 0) ? "%.${digits}f" : "%d";
                        $preview_canv->itemconfigure($preview_txt,
                                       -state => 'normal',
                                       -text  => sprintf($fmt, $v) . $add);
                        $preview_canv->itemconfigure($preview_poly, -state => 'hidden');
                        $preview_canv->itemconfigure($preview_oval, -state => 'hidden');
                        $width_label->g_grid_remove();
                        $width_sb->g_grid_remove();
                        $color_label->g_grid_remove();
                        $color_btn->g_grid_remove();
                        $units_label->g_grid();
                        $units_cb->g_grid();
                        $digits_label->g_grid();
                        $digits_sb->g_grid();
                        $font_label->g_grid();
                        $font_cb->g_grid();
                        $size_label->g_grid();
                        $size_cb->g_grid();
                        $weight_label->g_grid();
                        $weight_cb->g_grid();
                    } else {
                        $preview_canv->itemconfigure($preview_txt,  -state => 'hidden');
                        if ($form =~ /^(Circle|Ellipse)$/) {
                            $preview_canv->itemconfigure($preview_poly, -state => 'hidden');
                            $preview_canv->itemconfigure($preview_oval, -state => 'normal');
                            $preview_canv->coords($preview_oval, @{ $form_coords{$form} });
                        } else {
                            $preview_canv->itemconfigure($preview_oval, -state => 'hidden');
                            $preview_canv->itemconfigure($preview_poly, -state => 'normal');
                            $preview_canv->coords($preview_poly, @{ $form_coords{$form} });
                        }
                        $units_label->g_grid_remove();
                        $units_cb->g_grid_remove();
                        $digits_label->g_grid_remove();
                        $digits_sb->g_grid_remove();
                        $font_label->g_grid_remove();
                        $font_cb->g_grid_remove();
                        $size_label->g_grid_remove();
                        $size_cb->g_grid_remove();
                        $weight_label->g_grid_remove();
                        $weight_cb->g_grid_remove();
                        $width_label->g_grid();
                        $width_sb->g_grid();
                        $color_label->g_grid();
                        $color_btn->g_grid();
                    }
                  });
    if ($type =~ /^(Flow|Water Surface Elevation)$/ || ! $gr_props{$id}{add_cs}) {
        $form = "Text";
        $form_cb->configure(-state => 'disabled');
    }

    $row++;
    ($units_label = $link_frame->new_label(
            -text => "Link Units: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($units_cb = $link_frame->new_ttk__combobox(
            -textvariable => \$units,
            -values       => [ @unit_opts ],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $units_cb->g_bind("<<ComboboxSelected>>",
              sub { my ($add, $fmt, $v);
                    if ($type eq "Flow") {
                        $v   = ($units eq "cfs") ? 1000 : 50;
                        $add = " " . $units;
                    } elsif ($type eq "Water Surface Elevation") {
                        $v   = ($units eq "ft") ? 1500 : 450;
                        $add = " " . $units;
                    } else {
                        $v   = ($units eq "Celsius") ? 13 : 55;
                        $add = "\N{U+00B0}" . substr($units,0,1);
                    }
                    $fmt = ($digits > 0) ? "%.${digits}f" : "%d";
                    $preview_canv->itemconfigure($preview_txt,
                                   -text => sprintf($fmt, $v) . $add);
                  });

    $row++;
    ($digits_label = $link_frame->new_label(
            -text => "Decimal Digits: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($digits_sb = $link_frame->new_spinbox(
            -textvariable => \$digits,
            -state        => 'readonly',
            -font         => 'default',
            -from         => 0,
            -to           => 4,
            -increment    => 1,
            -width        => 3,
            -command      => sub { my ($add, $fmt, $v);
                                   if ($type eq "Flow") {
                                       $v   = ($units eq "cfs") ? 1000 : 50;
                                       $add = " " . $units;
                                   } elsif ($type eq "Water Surface Elevation") {
                                       $v   = ($units eq "ft") ? 1500 : 450;
                                       $add = " " . $units;
                                   } else {
                                       $v   = ($units eq "Celsius") ? 13 : 55;
                                       $add = "\N{U+00B0}" . substr($units,0,1);
                                   }
                                   $fmt = ($digits > 0) ? "%.${digits}f" : "%d";
                                   $preview_canv->itemconfigure($preview_txt,
                                                  -text => sprintf($fmt, $v) . $add);
                                 },
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    $row++;
    ($font_label = $link_frame->new_label(
            -text => "Link Text Font: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($font_cb = $link_frame->new_ttk__combobox(
            -textvariable => \$font,
            -values       => [ sort @available_fonts ],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $font_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_canv->itemconfigure($preview_txt,
                          -font => [ -family     => $font,
                                     -size       => $size,
                                     -weight     => $weight,
                                     -slant      => $slant_type[$slant],
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                  });
    $row++;
    ($size_label = $link_frame->new_label(
            -text => "Link Text Size: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($size_cb = $link_frame->new_ttk__combobox(
            -textvariable => \$size,
            -values       => [(5 .. 24)],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $size_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_canv->itemconfigure($preview_txt,
                          -font => [ -family     => $font,
                                     -size       => $size,
                                     -weight     => $weight,
                                     -slant      => $slant_type[$slant],
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                  });
    $row++;
    ($weight_label = $link_frame->new_label(
            -text => "Link Text Weight: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($weight_cb = $link_frame->new_ttk__combobox(
            -textvariable => \$weight,
            -values       => [("normal", "bold")],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $weight_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_canv->itemconfigure($preview_txt,
                          -font => [ -family     => $font,
                                     -size       => $size,
                                     -weight     => $weight,
                                     -slant      => $slant_type[$slant],
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                  });

    $row++;
    ($width_label = $link_frame->new_label(
            -text => "Outline Width: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($width_sb = $link_frame->new_spinbox(
            -textvariable => \$width,
            -state        => 'readonly',
            -font         => 'default',
            -from         => 0,
            -to           => 10,
            -increment    => 1,
            -width        => 3,
            -command      => sub { if ($width > 0) {
                                       $preview_canv->itemconfigure($preview_poly,
                                                      -outline => &get_rgb_code($color),
                                                      -width   => $width);
                                       $preview_canv->itemconfigure($preview_oval,
                                                      -outline => &get_rgb_code($color),
                                                      -width   => $width);
                                       $color_btn->configure(-state => 'normal');
                                   } else {
                                       $preview_canv->itemconfigure($preview_poly,
                                                      -outline => "",
                                                      -width   => $width);
                                       $preview_canv->itemconfigure($preview_oval,
                                                      -outline => "",
                                                      -width   => $width);
                                       $color_btn->configure(-state => 'disabled');
                                   }
                                 },
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    $row++;
    ($color_label = $link_frame->new_label(
            -text => "Outline Color: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);

    $code  = &get_rgb_code($color);
    $color = &get_rgb_name($code);
    $fg    = &get_rgb_code("black");
    if ($code =~ /^\#[0-9a-f]/i) {
        $fg = &get_rgb_code(&get_bw_contrast($code));
    }
    ($color_btn = $link_frame->new_button(
            -textvariable => \$color,
            -background   => $code,
            -foreground   => $fg,
            -width        => -7,
            -command => sub {
                          my ($newc, $code, $fg);
                          $code = &get_rgb_code($color);
                          $newc = Tkx::tk___chooseColor(
                                     -initialcolor => $code,
                                     -parent       => $edit_link_menu);
                          if ($newc) {
                            $code  = &get_rgb_code($newc);
                            $color = &get_rgb_name($code);
                            $fg    = &get_rgb_code("black");
                            if ($code =~ /^#?[0-9a-f]/i) {
                                $fg = &get_rgb_code(&get_bw_contrast($code));
                            }
                            $color_btn->configure(-foreground => $fg,
                                                  -background => $code);
                            if ($width > 0) {
                                $preview_canv->itemconfigure($preview_poly, -outline => $code);
                                $preview_canv->itemconfigure($preview_oval, -outline => $code);
                            } else {
                                $preview_canv->itemconfigure($preview_poly, -outline => "");
                                $preview_canv->itemconfigure($preview_oval, -outline => "");
                            }
                          }
                        }
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    if ($width == 0) {
        $color_btn->configure(-state => 'disabled');
    }

    if ($form ne "Text") {
        $units_label->g_grid_remove();
        $units_cb->g_grid_remove();
        $digits_label->g_grid_remove();
        $digits_sb->g_grid_remove();
        $font_label->g_grid_remove();
        $font_cb->g_grid_remove();
        $size_label->g_grid_remove();
        $size_cb->g_grid_remove();
        $weight_label->g_grid_remove();
        $weight_cb->g_grid_remove();
    } else {
        $width_label->g_grid_remove();
        $width_sb->g_grid_remove();
        $color_label->g_grid_remove();
        $color_btn->g_grid_remove();
    }

    Tkx::wm_resizable($edit_link_menu,0,0);
    &adjust_window_position($edit_link_menu);
    $edit_link_menu->g_focus;
}


sub set_link {
    my ($canv, $id, $link_id, $type, $form, $units, $digits,
        $outlet, $font, $weight, $size, $width, $color) = @_;
    my (
        $ang, $cs_max, $cs_min, $dt, $dt2, $fmt, $i, $link_txt, $mi, $qsum,
        $r, $save_id, $shade, $wt, $x1, $x2, $xo, $y1, $y2, $yo, $ws_elev,
        @colors, @coords, @names, @qstr, @tstr,
        %qdata, %tdata, %wsurf,
       );

    $dt    = $dates[$dti-1];
    $shade = "";
    $fmt   = ($digits > 0) ? "%.${digits}f" : "%d";
    ($x1, $y1, $x2, $y2) = Tkx::SplitList($canv->coords($id));

    if ($props{$id}{meta} eq "vert_wd_zone") {
        %qdata = %{ $gr_props{$id}{qdata} };

#       Adjust dt, if needed
        if (length($dt) == 12) {
            if ($gr_props{$id}{daily}) {
                $dt = substr($dt,0,8);
            } elsif (! defined($qdata{$dt})) {
                for ($mi=1; $mi<=10; $mi++) {
                    $dt2 = &adjust_dt($dt, $mi);
                    if (defined($qdata{$dt2})) {
                        $dt = $dt2;
                        last;
                    }
                    $dt2 = &adjust_dt($dt, -1 *$mi);
                    if (defined($qdata{$dt2})) {
                        $dt = $dt2;
                        last;
                    }
                }
            }
        }
    }

    if ($type eq "Water Surface Elevation") {
        %wsurf = %{ $gr_props{$id}{ws_elev} };

#       Adjust dt, if needed
        if (length($dt) == 12) {
            if ($gr_props{$id}{daily}) {
                $dt = substr($dt,0,8);
            } elsif (! defined($wsurf{$dt})) {
                for ($mi=1; $mi<=10; $mi++) {
                    $dt2 = &adjust_dt($dt, $mi);
                    if (defined($wsurf{$dt2})) {
                        $dt = $dt2;
                        last;
                    }
                    $dt2 = &adjust_dt($dt, -1 *$mi);
                    if (defined($wsurf{$dt2})) {
                        $dt = $dt2;
                        last;
                    }
                }
            }
        }

        if (defined($wsurf{$dt}) && $wsurf{$dt} ne "na") {
            $ws_elev  = $wsurf{$dt};
            $ws_elev *= 3.28084 if ($units eq "ft");
            $link_txt = sprintf($fmt, $ws_elev) . " " . $units;
        } else {
            $link_txt = "na " . $units;
        }
        undef %wsurf;

    } elsif (defined($qdata{$dt})) {
        $qsum  = 0;
        @names = @{ $gr_props{$id}{names} };
        @qstr  = @{ $qdata{$dt} };
        if ($type eq "Flow") {
            for ($i=0; $i<=$#qstr; $i++) {
                if ($outlet eq "All Outlets") {
                    $qsum += $qstr[$i];
                } elsif ($outlet eq $names[$i]) {
                    $qsum = $qstr[$i];
                    last;
                }
            }
            $qsum *= 35.31467 if ($units eq "cfs");
            $link_txt = sprintf($fmt, $qsum) . " " . $units;

        } else {
            if (defined($gr_props{$id}{tdata})) {
                %tdata = %{ $gr_props{$id}{tdata} };  # Celsius
            }
            if (defined($tdata{$dt})) {
                @tstr = @{ $tdata{$dt} };
                if ($outlet eq "All Outlets") {
                    $wt = $tstr[-1];
                } else {
                    $i  = &list_match($outlet, @names);
                    $wt = $tstr[$i];
                }
                if ($wt > -99) {
                    if ($form ne "Text") {
                        @colors = @{ $gr_props{$id}{colors} };
                        $cs_min = $gr_props{$id}{cs_min};
                        $cs_max = $gr_props{$id}{cs_max};
                        if ($props{$id}{wt_units} eq "Fahrenheit") {
                            $i = int(($#colors+1) *(($wt *1.8 +32)-$cs_min)/($cs_max-$cs_min));
                        } else {
                            $i = int(($#colors+1) *($wt-$cs_min)/($cs_max-$cs_min));
                        }
                        $i     = &max(0, &min($#colors, $i));
                        $shade = $colors[$i];
                    }
                    $wt = 1.8 *$wt +32 if ($units eq "Fahrenheit");
                    $link_txt = sprintf($fmt, $wt) . "\N{U+00B0}" . substr($units,0,1);
                } else {
                    $link_txt = "na " . "\N{U+00B0}" . substr($units,0,1);
                }
            } else {
                $link_txt = "na " . "\N{U+00B0}" . substr($units,0,1);
            }
            undef %tdata if (defined($gr_props{$id}{tdata}));
        }
    } else {
        if ($type eq "Flow") {
            $link_txt = "na " . $units;
        } else {
            $link_txt = "na " . "\N{U+00B0}" . substr($units,0,1);
        }
    }
    undef %qdata if ($props{$id}{meta} eq "vert_wd_zone");

#   New link
    if ($link_id == 0) {
        $xo = ($x1+$x2)/2;
        $yo = ($y1+$y2)/2;
        if ($form eq "Text") {
            $link_id = $canv->create_text($xo, $yo,
                              -anchor => 'e', 
                              -fill   => '#000000',
                              -angle  => 0,
                              -text   => $link_txt,
                              -tags   => "keep" . " link_gr" . $id,
                              -font   => [ -family     => $font,
                                           -size       => $size,
                                           -weight     => $weight,
                                           -slant      => $slant_type[$default_slant],
                                           -underline  => 0,
                                           -overstrike => 0,
                                         ]);
            $props{$link_id}{type}      = lc($form);
            $props{$link_id}{text}      = $link_txt;
            $props{$link_id}{x}         = $xo;
            $props{$link_id}{y}         = $yo;
            $props{$link_id}{anchor}    = 'e';
            $props{$link_id}{coordlist} = [$xo, $yo];
            $props{$link_id}{color}     = "black";
            $props{$link_id}{family}    = $font;
            $props{$link_id}{size}      = $size;
            $props{$link_id}{weight}    = $weight;
            $props{$link_id}{slant}     = $default_slant;
            $props{$link_id}{underline} = 0;
            $props{$link_id}{angle}     = 0;
            &find_rect_from_text_or_image($canv, $link_id);

        } elsif ($form eq "Circle") {
            $link_id = $canv->create_oval($xo-10, $yo-10, $xo+10, $yo+10,
                              -outline => &get_rgb_code($color),
                              -width   => $width,
                              -fill    => $shade,
                              -tags    => "keep" . " link_gr" . $id);
            if ($width == 0) {
                $canv->itemconfigure($link_id, -outline => "");
            }
            $props{$link_id}{type}      = lc($form);
            $props{$link_id}{x}         = $xo;
            $props{$link_id}{y}         = $yo;
            $props{$link_id}{xc}        = $xo;
            $props{$link_id}{yc}        = $yo;
            $props{$link_id}{anchor}    = 'center';
            $props{$link_id}{coordlist} = [$xo-10, $yo-10, $xo+10, $yo+10];
            $props{$link_id}{color}     = $color;
            $props{$link_id}{width}     = $width;
            $props{$link_id}{fill}      = 1;
            $props{$link_id}{fillcolor} = $shade;

        } else {
            if ($form eq "Ellipse") {
                @coords = &make_shape_coords("ellipse", $xo, $yo, 20, 10, 0);
            } elsif ($form eq "Rectangle") {
                @coords = ($xo-20, $yo-10, $xo+20, $yo-10,
                           $xo+20, $yo+10, $xo-20, $yo+10);
            } elsif ($form eq "Diamond") {
                @coords = ($xo-20, $yo, $xo, $yo-10,
                           $xo+20, $yo, $xo, $yo+10);
            } else {
                @coords = ($xo-20, $yo-10, $xo+10, $yo-10, $xo+20, $yo,
                           $xo+10, $yo+10, $xo-20, $yo+10);
            }
            $link_id = $canv->create_polygon(@coords,
                              -outline => &get_rgb_code($color),
                              -width   => $width,
                              -fill    => $shade,
                              -smooth  => 'false',
                              -tags    => "keep" . " link_gr" . $id);
            if ($width == 0) {
                $canv->itemconfigure($link_id, -outline => "");
            }
            $props{$link_id}{type}      = lc($form);
            $props{$link_id}{x}         = $xo;
            $props{$link_id}{y}         = $yo;
            $props{$link_id}{xc}        = $xo;
            $props{$link_id}{yc}        = $yo;
            $props{$link_id}{anchor}    = 'center';
            $props{$link_id}{coordlist} = [ @coords ];
            $props{$link_id}{color}     = $color;
            $props{$link_id}{width}     = $width;
            $props{$link_id}{fill}      = 1;
            $props{$link_id}{fillcolor} = $shade;
            $props{$link_id}{angle}     = 0;
            $props{$link_id}{angle_tmp} = 0;
            $props{$link_id}{smooth}    = 0;
            if ($form eq "Ellipse") {
                $props{$link_id}{hw}    = 20;
                $props{$link_id}{hh}    = 10;
            } elsif ($form eq "Polygon") {
                ($xo, $yo, $r) = &smallest_circle(@coords);
                $props{$link_id}{xc_rot} = $xo;
                $props{$link_id}{yc_rot} = $yo;
            }
        }
        $canv->g_bind("<Motion>",   [ \&move_object, Tkx::Ev("%x","%y"), $canv, $link_id, $xo, $yo, "", 0 ]);
        $canv->g_bind("<Button-1>", [ \&end_move_object, $canv, $link_id, "" ]);
        $canv->g_bind("<Button-3>", [ \&forget_link, $canv, $link_id ]);

#   Existing link
    } else {
        $save_id = $link_id;
        if ($form eq "Text") {
            if ($link_props{$link_id}{form} eq "Text") {
                $props{$link_id}{text}   = $link_txt;
                $props{$link_id}{family} = $font;
                $props{$link_id}{size}   = $size;
                $props{$link_id}{weight} = $weight;
                $canv->itemconfigure($link_id,
                              -text => $link_txt,
                              -font => [ -family     => $font,
                                         -size       => $size,
                                         -weight     => $weight,
                                         -slant      => $slant_type[$props{$link_id}{slant}],
                                         -underline  => $props{$link_id}{underline},
                                         -overstrike => 0,
                                       ]);
                &find_rect_from_text_or_image($canv, $link_id);
            } else {
                $xo  = $props{$save_id}{x};
                $yo  = $props{$save_id}{y};
                $ang = (defined($props{$save_id}{angle})) ? $props{$save_id}{angle} : 0;
                $link_id = $canv->create_text($xo, $yo,
                              -anchor => 'e', 
                              -fill   => &get_rgb_code($props{$save_id}{color}),
                              -angle  => $ang,
                              -text   => $link_txt,
                              -tags   => "keep" . " link_gr" . $id,
                              -font   => [ -family     => $font,
                                           -size       => $size,
                                           -weight     => $weight,
                                           -slant      => $slant_type[$default_slant],
                                           -underline  => 0,
                                           -overstrike => 0,
                                         ]);
                $props{$link_id}{type}      = lc($form);
                $props{$link_id}{text}      = $link_txt;
                $props{$link_id}{x}         = $xo;
                $props{$link_id}{y}         = $yo;
                $props{$link_id}{anchor}    = 'e';
                $props{$link_id}{coordlist} = [$xo, $yo];
                $props{$link_id}{color}     = $props{$save_id}{color};
                $props{$link_id}{family}    = $font;
                $props{$link_id}{size}      = $size;
                $props{$link_id}{weight}    = $weight;
                $props{$link_id}{slant}     = $default_slant;
                $props{$link_id}{underline} = 0;
                $props{$link_id}{angle}     = $ang;
                &find_rect_from_text_or_image($canv, $link_id);

                $canv->lower($link_id, $save_id);
                $canv->delete($save_id);
                delete $props{$save_id};
                delete $link_props{$save_id};
                undef $old_id if (defined($old_id));
            }
        } elsif ($form eq "Circle") {
            if ($link_props{$link_id}{form} eq "Circle") {
                $props{$link_id}{width} = $width;
                $props{$link_id}{color} = $color;
                $canv->itemconfigure($link_id,
                              -outline => &get_rgb_code($color),
                              -width   => $width);
                if ($width == 0) {
                    $canv->itemconfigure($link_id, -outline => "");
                }
            } else {
                if ($link_props{$link_id}{form} eq "Text") {
                    $xo = $props{$save_id}{x};
                    $yo = $props{$save_id}{y};
                } else {
                    $xo = $props{$save_id}{xc};
                    $yo = $props{$save_id}{yc};
                }
                $link_id = $canv->create_oval($xo-10, $yo-10, $xo+10, $yo+10,
                              -outline => &get_rgb_code($color),
                              -width   => $width,
                              -fill    => $shade,
                              -tags    => "keep" . " link_gr" . $id);
                if ($width == 0) {
                    $canv->itemconfigure($link_id, -outline => "");
                }
                $props{$link_id}{type}      = lc($form);
                $props{$link_id}{x}         = $xo;
                $props{$link_id}{y}         = $yo;
                $props{$link_id}{xc}        = $xo;
                $props{$link_id}{yc}        = $yo;
                $props{$link_id}{anchor}    = 'center';
                $props{$link_id}{coordlist} = [$xo-10, $yo-10, $xo+10, $yo+10];
                $props{$link_id}{color}     = $color;
                $props{$link_id}{width}     = $width;
                $props{$link_id}{fill}      = 1;
                $props{$link_id}{fillcolor} = $shade;

                $canv->lower($link_id, $save_id);
                $canv->delete($save_id);
                delete $props{$save_id};
                delete $link_props{$save_id};
                undef $old_id if (defined($old_id));
            }
        } else {
            if ($link_props{$link_id}{form} =~ /^(Ellipse|Rectangle|Diamond|Polygon)$/) {
                if ($form ne $link_props{$link_id}{form}) {
                    $xo  = $props{$link_id}{xc};
                    $yo  = $props{$link_id}{yc};
                    $ang = $props{$link_id}{angle};
                    if ($form eq "Ellipse") {
                        @coords = &make_shape_coords("ellipse", $xo, $yo, 20, 10, $ang);
                    } elsif ($form eq "Rectangle") {
                        @coords = &make_shape_coords("rectangle", $xo, $yo, 20, 10, $ang);
                        $props{$link_id}{smooth} = 0 if ($link_props{$link_id}{form} ne "Diamond");
                    } elsif ($form eq "Diamond") {
                        @coords = &make_shape_coords("diamond", $xo, $yo, 20, 10, $ang);
                        $props{$link_id}{smooth} = 0 if ($link_props{$link_id}{form} ne "Rectangle");
                    } else {
                        @coords = ($xo-20, $yo-10, $xo+10, $yo-10, $xo+20, $yo,
                                   $xo+10, $yo+10, $xo-20, $yo+10);
                        if ($ang != 0) {
                            @coords = &resize_shape(\@coords, 0, $xo, $yo, 40, 20, $ang);
                        }
                    }
                    $canv->coords($link_id, @coords);
                    $props{$link_id}{type}      = lc($form);
                    $props{$link_id}{coordlist} = [ @coords ];
                    if ($form eq "Ellipse") {
                        $props{$link_id}{hw}    = 20;
                        $props{$link_id}{hh}    = 10;
                    } elsif ($form eq "Polygon") {
                        ($xo, $yo, $r) = &smallest_circle(@coords);
                        $props{$link_id}{xc_rot} = $xo;
                        $props{$link_id}{yc_rot} = $yo;
                    }
                }
                $canv->itemconfigure($link_id,
                              -outline => &get_rgb_code($color),
                              -width   => $width);
                if ($width == 0) {
                    $canv->itemconfigure($link_id, -outline => "");
                }
                $props{$link_id}{width} = $width;
                $props{$link_id}{color} = $color;
            } else {
                if ($link_props{$link_id}{form} eq "Text") {
                    $xo  = $props{$save_id}{x};
                    $yo  = $props{$save_id}{y};
                    $ang = $props{$save_id}{angle};
                } else {
                    $xo  = $props{$save_id}{xc};
                    $yo  = $props{$save_id}{yc};
                    $ang = 0;
                }
                if ($form eq "Ellipse") {
                    @coords = &make_shape_coords("ellipse", $xo, $yo, 20, 10, $ang);
                } elsif ($form eq "Rectangle") {
                    @coords = &make_shape_coords("rectangle", $xo, $yo, 20, 10, $ang);
                } elsif ($form eq "Diamond") {
                    @coords = &make_shape_coords("diamond", $xo, $yo, 20, 10, $ang);
                } else {
                    @coords = ($xo-20, $yo-10, $xo+10, $yo-10, $xo+20, $yo,
                               $xo+10, $yo+10, $xo-20, $yo+10);
                    if ($ang != 0) {
                        @coords = &resize_shape(\@coords, 0, $xo, $yo, 40, 20, $ang);
                    }
                }
                $link_id = $canv->create_polygon(@coords,
                              -outline => &get_rgb_code($color),
                              -width   => $width,
                              -fill    => $shade,
                              -smooth  => 'false',
                              -tags    => "keep" . " link_gr" . $id);
                if ($width == 0) {
                    $canv->itemconfigure($link_id, -outline => "");
                }
                $props{$link_id}{type}      = lc($form);
                $props{$link_id}{x}         = $xo;
                $props{$link_id}{y}         = $yo;
                $props{$link_id}{xc}        = $xo;
                $props{$link_id}{yc}        = $yo;
                $props{$link_id}{anchor}    = 'center';
                $props{$link_id}{coordlist} = [ @coords ];
                $props{$link_id}{color}     = $color;
                $props{$link_id}{width}     = $width;
                $props{$link_id}{fill}      = 1;
                $props{$link_id}{fillcolor} = $shade;
                $props{$link_id}{angle}     = $ang;
                $props{$link_id}{angle_tmp} = $ang;
                $props{$link_id}{smooth}    = 0;
                if ($form eq "Ellipse") {
                    $props{$link_id}{hw}    = 20;
                    $props{$link_id}{hh}    = 10;
                } elsif ($form eq "Polygon") {
                    ($xo, $yo, $r) = &smallest_circle(@coords);
                    $props{$link_id}{xc_rot} = $xo;
                    $props{$link_id}{yc_rot} = $yo;
                }

                $canv->lower($link_id, $save_id);
                $canv->delete($save_id);
                delete $props{$save_id};
                delete $link_props{$save_id};
                undef $old_id if (defined($old_id));
            }
        }
    }

    $link_props{$link_id}{id}     = $id;
    $link_props{$link_id}{gnum}   = $props{$id}{gnum};
    $link_props{$link_id}{type}   = $type;
    $link_props{$link_id}{outlet} = $outlet;
    $link_props{$link_id}{form}   = $form;
    $link_props{$link_id}{units}  = $units;
    $link_props{$link_id}{digits} = $digits;

    $edit_link_menu->g_destroy();
    undef $edit_link_menu;
}


sub update_links {
    my ($canv, $id, $dt) = @_;
    my (
        $cs_max, $cs_min, $digits, $fmt, $form, $i, $item, $link_txt,
        $outlet, $qsum, $shade, $type, $units, $ws_elev, $wt,
        @colors, @items, @names, @qstr, @tstr,
        %qdata, %tdata, %wsurf,
       );

    @items = Tkx::SplitList($canv->find_withtag("link_gr" . $id));
    return if ($#items < 0);

    if ($props{$id}{meta} eq "vert_wd_zone") {
        %qdata = %{ $gr_props{$id}{qdata} };
    }

    foreach $item ( @items ) {
        next if ($link_props{$item}{id} != $id);

        $form = $link_props{$item}{form};
        if ($form eq "stat") {
            &update_stat_link($canv, $item, $dt);
            next;
        }
        if ($form ne "Text" && ! $gr_props{$id}{add_cs}) {
            $canv->itemconfigure($item, -fill => "");
            $props{$item}{fillcolor} = "";
            next;
        }
        $type   = $link_props{$item}{type};
        $units  = $link_props{$item}{units};
        $digits = $link_props{$item}{digits};
        $shade  = "";
        $fmt    = ($digits > 0) ? "%.${digits}f" : "%d";

        if ($type eq "Water Surface Elevation") {
            %wsurf = %{ $gr_props{$id}{ws_elev} };
            if (defined($wsurf{$dt}) && $wsurf{$dt} ne "na") {
                $ws_elev  = $wsurf{$dt};
                $ws_elev *= 3.28084 if ($units eq "ft");
                $link_txt = sprintf($fmt, $ws_elev) . " " . $units;
            } else {
                $link_txt = "na " . $units;
            }
            undef %wsurf;

        } elsif (defined($qdata{$dt})) {
            $qsum   = 0;
            $outlet = $link_props{$item}{outlet};
            @names  = @{ $gr_props{$id}{names} };
            @qstr   = @{ $qdata{$dt} };
            if ($type eq "Flow") {
                for ($i=0; $i<=$#qstr; $i++) {
                    if ($outlet eq "All Outlets") {
                        $qsum += $qstr[$i];
                    } elsif ($outlet eq $names[$i]) {
                        $qsum = $qstr[$i];
                        last;
                    }
                }
                $qsum *= 35.31467 if ($units eq "cfs");
                $link_txt = sprintf($fmt, $qsum) . " " . $units;

            } else {
                if (defined($gr_props{$id}{tdata})) {
                    %tdata = %{ $gr_props{$id}{tdata} };  # Celsius
                }
                if (defined($tdata{$dt})) {
                    @tstr = @{ $tdata{$dt} };
                    if ($outlet eq "All Outlets") {
                        $wt = $tstr[-1];
                    } else {
                        $i  = &list_match($outlet, @names);
                        $wt = $tstr[$i];
                    }
                    if ($wt > -99) {
                        if ($form ne "Text" && $gr_props{$id}{add_cs}) {
                            @colors = @{ $gr_props{$id}{colors} };
                            $cs_min = $gr_props{$id}{cs_min};
                            $cs_max = $gr_props{$id}{cs_max};
                            if ($props{$id}{wt_units} eq "Fahrenheit") {
                                $i = int(($#colors+1) *(($wt *1.8 +32)-$cs_min)/($cs_max-$cs_min));
                            } else {
                                $i = int(($#colors+1) *($wt-$cs_min)/($cs_max-$cs_min));
                            }
                            $i     = &max(0, &min($#colors, $i));
                            $shade = $colors[$i];
                        }
                        $wt = 1.8 *$wt +32 if ($units eq "Fahrenheit");
                        $link_txt = sprintf($fmt, $wt) . "\N{U+00B0}" . substr($units,0,1);
                    } else {
                        $link_txt = "na " . "\N{U+00B0}" . substr($units,0,1);
                    }
                } else {
                    $link_txt = "na " . "\N{U+00B0}" . substr($units,0,1);
                }
                undef %tdata if (defined($gr_props{$id}{tdata}));
            }

        } else {
            if ($type eq "Flow") {
                $link_txt = "na " . $units;
            } else {
                $link_txt = "na " . "\N{U+00B0}" . substr($units,0,1);
            }
        }

        if ($form eq "Text") {
            $canv->itemconfigure($item, -text => $link_txt);
            $props{$item}{text} = $link_txt;
        } else {
            $canv->itemconfigure($item, -fill => $shade);
            $props{$item}{fillcolor} = $shade;
        }
    }
    undef %qdata if ($props{$id}{meta} eq "vert_wd_zone");
}


sub edit_stat_link {
    my ($canv, $id, $X, $Y, $link_id) = @_;
    my (
        $btn_txt, $digits, $digits_sb, $digits_tmp, $f, $fmt, $font,
        $font_cb, $frame, $geom, $interp, $link_frame, $link_txt, $ph,
        $preview_canv, $preview_txt, $pw, $row, $size, $size_cb, $slant,
        $tol, $tol_frame, $type, $type_cb, $units, $weight, $weight_cb,

        @link_types,
       );

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($edit_stat_link_menu) && Tkx::winfo_exists($edit_stat_link_menu)) {
        if ($edit_stat_link_menu->g_wm_title() eq "Add or Edit Goodness-of-Fit Link") {
            $edit_stat_link_menu->g_destroy();
            undef $edit_stat_link_menu;
        }
    }
    $edit_stat_link_menu = $main->new_toplevel();
    $edit_stat_link_menu->g_wm_transient($main);
    $edit_stat_link_menu->g_wm_title("Add or Edit Goodness-of-Fit Link");
    $edit_stat_link_menu->configure(-cursor => $cursor_norm);
    $edit_stat_link_menu->g_wm_geometry($geom);

    if ($link_id != 0) {
        @link_types = ("Number of Points", "Mean Error", "Mean Absolute Error", "Root Mean Square Error");
        $type    = $link_props{$link_id}{type};
        $digits  = $link_props{$link_id}{digits};
        $interp  = $link_props{$link_id}{interp};
        $tol     = $link_props{$link_id}{tol};
        $font    = $props{$link_id}{family};
        $size    = $props{$link_id}{size};
        $weight  = $props{$link_id}{weight};
        $slant   = $slant_type[$props{$link_id}{slant}];
        $btn_txt = "Modify";
        if ($type eq "n") {
            $type     = "Number of Points";
            $link_txt = "N: 15";
        } else {
            $fmt      = ($digits > 0) ? "%.${digits}f" : "%d";
            $link_txt = uc($type) . ": " . sprintf($fmt, "1.234");
            if ($type eq "me") {
                $type = "Mean Error";
            } elsif ($type eq "mae") {
                $type = "Mean Absolute Error";
            } elsif ($type eq "rmse") {
                $type = "Root Mean Square Error";
            }
        }
    } else {
        @link_types = ("Mean Error", "Mean Absolute Error", "Root Mean Square Error", "Stats Table");
        $type     = "Mean Absolute Error";
        $font     = $default_family;
        $size     = $default_size;
        $weight   = $default_weight;
        $slant    = $slant_type[$default_slant];
        $digits   = 2;
        $interp   = 0;
        $tol      = 10;
        $fmt      = ($digits > 0) ? "%.${digits}f" : "%d";
        $link_txt = "MAE: " . sprintf($fmt, "1.234");
        $btn_txt  = "Create";
        &end_select($canv, $id, 1);
    }
    $digits_tmp = $digits;

    if ($props{$id}{parm} eq "Temperature") {
        $units = "\N{U+00B0}" . substr($props{$id}{parm_units},0,1);
    } else {
        $units = $props{$id}{parm_units};
        $units = " " . $units if ($units ne "");
    }
    $link_txt .= $units if ($type ne "Number of Points");

    $pw = 260;
    $ph =  45;

    $frame = $edit_stat_link_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    $frame->new_button(
            -text    => $btn_txt,
            -command => sub { $edit_stat_link_menu->g_destroy();
                              undef $edit_stat_link_menu;
                              &set_stat_link($canv, $id, $link_id, $type, $digits,
                                             $font, $weight, $size, $tol, $interp);
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $edit_stat_link_menu->g_destroy();
                              undef $edit_stat_link_menu; },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

    $f = $edit_stat_link_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f->g_pack(-side => 'top');

    ($preview_canv = $f->new_canvas(
            -background  => &get_rgb_code($canvas_color),
            -width       => $pw,
            -height      => $ph,
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_grid(-row => 0, -column => 0, -sticky => 'wne');

    $preview_txt = $preview_canv->create_text($pw*0.5 +3, $ph*0.5 +3,
            -anchor => 'center', 
            -text   => $link_txt,
            -fill   => "#000000",
            -angle  => 0,
            -font   => [-family     => $font,
                        -size       => $size,
                        -weight     => $weight,
                        -slant      => $slant,
                        -underline  => 0,
                        -overstrike => 0,
                       ]);

    ($link_frame = $f->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_grid(-row => 1, -column => 0, -sticky => 'wnes');

    $row = 0;
    $link_frame->new_label(
            -text => "Link Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($type_cb = $link_frame->new_ttk__combobox(
            -textvariable => \$type,
            -values       => [ @link_types ],
            -width        => 22,
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $type_cb->g_bind("<<ComboboxSelected>>",
              sub { my ($txt);
                    if ($type eq "Number of Points") {
                        $link_txt   = "N: 15";
                        $digits_tmp = $digits;
                        $digits     = 0;
                        $digits_sb->configure(-state => 'disabled');
                    } else {
                        if ($type eq "Mean Error") {
                            $txt = "ME: ";
                        } elsif ($type eq "Mean Absolute Error") {
                            $txt = "MAE: ";
                        } elsif ($type eq "Root Mean Square Error") {
                            $txt = "RMSE: ";
                        } elsif ($type eq "Stats Table") {
                            $txt = "Stat: ";
                        }
                        $digits_sb->configure(-state => 'readonly');
                        $digits   = $digits_tmp;
                        $fmt      = ($digits > 0) ? "%.${digits}f" : "%d";
                        $link_txt = $txt . sprintf($fmt, "1.234") . $units;
                    }
                    $preview_canv->itemconfigure($preview_txt, -text => $link_txt);
                  });

    $row++;
    $link_frame->new_label(
            -text => "Decimal Digits: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($digits_sb = $link_frame->new_spinbox(
            -textvariable => \$digits,
            -state        => 'readonly',
            -font         => 'default',
            -from         => 0,
            -to           => 4,
            -increment    => 1,
            -width        => 3,
            -command      => sub { my ($txt);
                                   if ($type eq "Mean Error") {
                                       $txt = "ME: ";
                                   } elsif ($type eq "Mean Absolute Error") {
                                       $txt = "MAE: ";
                                   } elsif ($type eq "Root Mean Square Error") {
                                       $txt = "RMSE: ";
                                   } elsif ($type eq "Stats Table") {
                                       $txt = "Stat: ";
                                   }
                                   $digits_tmp = $digits;
                                   $fmt        = ($digits > 0) ? "%.${digits}f" : "%d";
                                   $link_txt   = $txt . sprintf($fmt, "1.234") . $units;
                                   $preview_canv->itemconfigure($preview_txt, -text => $link_txt);
                                 },
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    $row++;
    $link_frame->new_label(
            -text => "Link Text Font: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($font_cb = $link_frame->new_ttk__combobox(
            -textvariable => \$font,
            -values       => [ sort @available_fonts ],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
    $font_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_canv->itemconfigure($preview_txt,
                          -font => [ -family     => $font,
                                     -size       => $size,
                                     -weight     => $weight,
                                     -slant      => $slant,
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                  });
    $row++;
    $link_frame->new_label(
            -text => "Link Text Size: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($size_cb = $link_frame->new_ttk__combobox(
            -textvariable => \$size,
            -values       => [(5 .. 24)],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
    $size_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_canv->itemconfigure($preview_txt,
                          -font => [ -family     => $font,
                                     -size       => $size,
                                     -weight     => $weight,
                                     -slant      => $slant,
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                  });
    $row++;
    $link_frame->new_label(
            -text => "Link Text Weight: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($weight_cb = $link_frame->new_ttk__combobox(
            -textvariable => \$weight,
            -values       => [("normal", "bold")],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
    $weight_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_canv->itemconfigure($preview_txt,
                          -font => [ -family     => $font,
                                     -size       => $size,
                                     -weight     => $weight,
                                     -slant      => $slant,
                                     -underline  => 0,
                                     -overstrike => 0,
                                   ]);
                  });

    $row++;
    $link_frame->new_label(
            -text => "Match Tolerance: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($tol_frame = $link_frame->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w');
    $tol_frame->new_spinbox(
            -textvariable => \$tol,
            -state        => 'readonly',
            -font         => 'default',
            -from         => 0,
            -to           => 180,
            -increment    => 1,
            -width        => 4,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $tol_frame->new_label(
            -text => " minutes",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');

    $row++;
    $link_frame->new_checkbutton(
            -onvalue  => 1,
            -offvalue => 0,
            -text     => "Interpolate model profile vertically",
            -font     => 'default',
            -variable => \$interp,
            )->g_grid(-row => $row, -column => 0, -columnspan => 2, -sticky => 'e', -pady => 2);

    if ($type eq "Number of Points") {
        $digits_sb->configure(-state => 'disabled');
    }
    Tkx::wm_resizable($edit_stat_link_menu,0,0);
    &adjust_window_position($edit_stat_link_menu);
    $edit_stat_link_menu->g_focus;
}


sub set_stat_link {
    my ($canv, $id, $link_id, $type, $digits, $font, $weight, $size, $tol, $interp) = @_;
    my (
        $dt, $fmt, $group_tag, $link_txt, $seg, $stat, $stat_type, $units,
        $x1, $x2, $xo, $y1, $y2, $yo,

        @coords, @items,

        %elev_data, %parm_data, %ref_data, %stats,
        );

    ($x1, $y1, $x2, $y2) = Tkx::SplitList($canv->coords($id));
    $xo = ($x1+$x2)/2;
    $yo = ($y1+$y2)/2;

    if ($props{$id}{parm} eq "Temperature") {
        $units = "\N{U+00B0}" . substr($props{$id}{parm_units},0,1);
    } else {
        $units = $props{$id}{parm_units};
        $units = " " . $units if ($units ne "");
    }
    $dt        = $dates[$dti-1];
    $seg       = $props{$id}{seg};
    %elev_data = %{ $gr_props{$id}{elev_data} };
    %parm_data = %{ $gr_props{$id}{parm_data} };
    %ref_data  = %{ $gr_props{$id}{ref_data}  };

#   Compute the stats for date/time dt
    %stats = &get_stats_single_profile($id, $dt, $seg, $tol, $interp,
                                       \%elev_data, \%parm_data, \%ref_data);
    undef %elev_data;
    undef %parm_data;
    undef %ref_data;

#   Create a new stats table with N, ME, MAE, RMSE
    if ($type eq "Stats Table" && $link_id == 0) {
        @items = ();
        foreach $stat_type ("n", "me", "mae", "rmse") {
            $stat = $stats{$stat_type};
            if ($stat eq "na" || $stat_type eq "n") {
                $link_txt = uc($stat_type) . ": " . $stat;
                if ($stat_type ne "n") {
                    if ($units =~ /^ /) {
                        $link_txt .= $units;
                    } else {
                        $link_txt .= " " . $units;
                    }
                }
            } else {
                if ($props{$id}{parm} eq "Temperature" && $props{$id}{parm_units} eq "Fahrenheit") {
                    $stat *= 1.8;
                }
                $fmt      = ($digits > 0) ? "%.${digits}f" : "%d";
                $link_txt = uc($stat_type) . ": " . sprintf($fmt, $stat) . $units;
            }
            $link_id = $canv->create_text($xo, $yo,
                                  -anchor => 'e', 
                                  -fill   => '#000000',
                                  -angle  => 0,
                                  -text   => $link_txt,
                                  -tags   => "keep" . " link_gr" . $id,
                                  -font   => [ -family     => $font,
                                               -size       => $size,
                                               -weight     => $weight,
                                               -slant      => $slant_type[$default_slant],
                                               -underline  => 0,
                                               -overstrike => 0,
                                             ]);
            $props{$link_id}{type}      = "text";
            $props{$link_id}{text}      = $link_txt;
            $props{$link_id}{x}         = $xo;
            $props{$link_id}{y}         = $yo;
            $props{$link_id}{anchor}    = 'e';
            $props{$link_id}{coordlist} = [$xo, $yo];
            $props{$link_id}{color}     = "black";
            $props{$link_id}{family}    = $font;
            $props{$link_id}{size}      = $size;
            $props{$link_id}{weight}    = $weight;
            $props{$link_id}{slant}     = $default_slant;
            $props{$link_id}{underline} = 0;
            $props{$link_id}{angle}     = 0;
            &find_rect_from_text_or_image($canv, $link_id);

            push (@items, $link_id);

            $link_props{$link_id}{id}     = $id;
            $link_props{$link_id}{gnum}   = $props{$id}{gnum};
            $link_props{$link_id}{form}   = "stat";
            $link_props{$link_id}{type}   = $stat_type;
            $link_props{$link_id}{tol}    = $tol;
            $link_props{$link_id}{interp} = $interp;
            if ($stat_type eq "n") {
                $link_props{$link_id}{digits} = 0;
            } else {
                $link_props{$link_id}{digits} = $digits;
            }
            @coords = Tkx::SplitList($canv->bbox($link_id));
            $yo    += &max(10, abs($coords[3] - $coords[1])) +2;
        }
        $group_tag = &group_items($canv, @items);
        &begin_move($canv, $group_tag, "group");

#   Create or edit a single stat link
    } else {
        if ($type eq "Number of Points" || $type eq "n") {
            $stat_type = "n";
        } elsif ($type eq "Mean Error" || $type eq "me") {
            $stat_type = "me";
        } elsif ($type eq "Mean Absolute Error" || $type eq "mae") {
            $stat_type = "mae";
        } elsif ($type eq "Root Mean Square Error" || $type eq "rmse") {
            $stat_type = "rmse";
        }
        $stat = $stats{$stat_type};
        if ($stat eq "na" || $type eq "Number of Points" || $type eq "n") {
            $link_txt = uc($stat_type) . ": " . $stat;
            if ($type ne "Number of Points" && $type ne "n") {
                if ($units =~ /^ /) {
                    $link_txt .= $units;
                } else {
                    $link_txt .= " " . $units;
                }
            }
        } else {
            if ($props{$id}{parm} eq "Temperature" && $props{$id}{parm_units} eq "Fahrenheit") {
                $stat *= 1.8;
            }
            $fmt      = ($digits > 0) ? "%.${digits}f" : "%d";
            $link_txt = uc($stat_type) . ": " . sprintf($fmt, $stat) . $units;
        }

#       Existing stat link
        if ($link_id != 0) {
            $link_props{$link_id}{type}   = $stat_type;
            $link_props{$link_id}{digits} = $digits;
            $link_props{$link_id}{interp} = $interp;
            $link_props{$link_id}{tol}    = $tol;
            $props{$link_id}{text}        = $link_txt;
            $props{$link_id}{family}      = $font;
            $props{$link_id}{size}        = $size;
            $props{$link_id}{weight}      = $weight;

            $canv->itemconfigure($link_id,
                                  -text => $link_txt,
                                  -font => [ -family     => $font,
                                             -size       => $size,
                                             -weight     => $weight,
                                             -slant      => $slant_type[$props{$link_id}{slant}],
                                             -underline  => $props{$link_id}{underline},
                                             -overstrike => 0,
                                           ]);

#       New stat link
        } else {
            $link_id = $canv->create_text($xo, $yo,
                                  -anchor => 'e', 
                                  -fill   => '#000000',
                                  -angle  => 0,
                                  -text   => $link_txt,
                                  -tags   => "keep" . " link_gr" . $id,
                                  -font   => [ -family     => $font,
                                               -size       => $size,
                                               -weight     => $weight,
                                               -slant      => $slant_type[$default_slant],
                                               -underline  => 0,
                                               -overstrike => 0,
                                             ]);
            $props{$link_id}{type}      = "text";
            $props{$link_id}{text}      = $link_txt;
            $props{$link_id}{x}         = $xo;
            $props{$link_id}{y}         = $yo;
            $props{$link_id}{anchor}    = 'e';
            $props{$link_id}{coordlist} = [$xo, $yo];
            $props{$link_id}{color}     = "black";
            $props{$link_id}{family}    = $font;
            $props{$link_id}{size}      = $size;
            $props{$link_id}{weight}    = $weight;
            $props{$link_id}{slant}     = $default_slant;
            $props{$link_id}{underline} = 0;
            $props{$link_id}{angle}     = 0;
            &find_rect_from_text_or_image($canv, $link_id);

            $link_props{$link_id}{id}     = $id;
            $link_props{$link_id}{gnum}   = $props{$id}{gnum};
            $link_props{$link_id}{form}   = "stat";
            $link_props{$link_id}{type}   = $stat_type;
            $link_props{$link_id}{tol}    = $tol;
            $link_props{$link_id}{interp} = $interp;
            $link_props{$link_id}{digits} = $digits;

            $canv->g_bind("<Motion>",   [ \&move_object, Tkx::Ev("%x","%y"), $canv, $link_id,
                                                         $xo, $yo, "", 0 ]);
            $canv->g_bind("<Button-1>", [ \&end_move_object, $canv, $link_id, "" ]);
            $canv->g_bind("<Button-3>", [ \&forget_link, $canv, $link_id ]);
        }
    }
}


sub update_stat_link {
    my ($canv, $link_id, $dt) = @_;
    my (
        $digits, $fmt, $id, $interp, $link_txt, $seg, $stat, $tol, $txt,
        $type, $units,

        %elev_data, %parm_data, %ref_data, %stats,
       );

    $id     = $link_props{$link_id}{id};
    $type   = $link_props{$link_id}{type};
    $tol    = $link_props{$link_id}{tol};
    $interp = $link_props{$link_id}{interp};
    $digits = $link_props{$link_id}{digits};

    if ($props{$id}{parm} eq "Temperature") {
        $units = "\N{U+00B0}" . substr($props{$id}{parm_units},0,1);
    } else {
        $units = $props{$id}{parm_units};
        $units = " " . $units if ($units ne "");
    }
    $seg       = $props{$id}{seg};
    %elev_data = %{ $gr_props{$id}{elev_data} };
    %parm_data = %{ $gr_props{$id}{parm_data} };
    %ref_data  = %{ $gr_props{$id}{ref_data}  };

    %stats = &get_stats_single_profile($id, $dt, $seg, $tol, $interp,
                                       \%elev_data, \%parm_data, \%ref_data);
    undef %elev_data;
    undef %parm_data;
    undef %ref_data;

    if ($type eq "n") {
        $txt  = "N: ";
    } elsif ($type eq "me") {
        $txt  = "ME: ";
    } elsif ($type eq "mae") {
        $txt  = "MAE: ";
    } elsif ($type eq "rmse") {
        $txt  = "RMSE: ";
    }
    $stat = $stats{$type};
    if ($stat eq "na" || $type eq "n") {
        $link_txt = $txt . $stat;
        if ($type ne "n") {
            if ($units =~ /^ /) {
                $link_txt .= $units;
            } else {
                $link_txt .= " " . $units;
            }
        }
    } else {
        if ($props{$id}{parm} eq "Temperature" && $props{$id}{parm_units} eq "Fahrenheit") {
            $stat *= 1.8;
        }
        $fmt      = ($digits > 0) ? "%.${digits}f" : "%d";
        $link_txt = $txt . sprintf($fmt, $stat) . $units;
    }
    $canv->itemconfigure($link_id, -text => $link_txt);
    $props{$link_id}{text} = $link_txt;
}


sub forget_link {
    my ($canv, $link_id) = @_;

    $canv->delete($link_id);
    delete $props{$link_id};
    delete $link_props{$link_id};
    &reset_bindings;
}


sub add_ts_link {
    my ($canv, $id, $X, $Y) = @_;
    my (
        $code, $color, $color_btn, $color_label, $fg, $frame, $geom,
        $jd_max, $jd_min, $n, $outlet_frame, $row, $row2, $ts_frame,
        $ts_type, $ts_type_cb, $units, $units_cb, $width, $width_label,
        $width_sb, $xmax, $xmin,

        @color, @color_btns, @datelist1, @datelist2, @def_colors,
        @link_types, @names, @show, @unit_opts, @width, @width_sbs,
       );

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($add_ts_link_menu) && Tkx::winfo_exists($add_ts_link_menu)) {
        if ($add_ts_link_menu->g_wm_title() eq "Add Time Series Link") {
            $add_ts_link_menu->g_destroy();
            undef $add_ts_link_menu;
        }
    }
    $add_ts_link_menu = $main->new_toplevel();
    $add_ts_link_menu->g_wm_transient($main);
    $add_ts_link_menu->g_wm_title("Add Time Series Link");
    $add_ts_link_menu->configure(-cursor => $cursor_norm);
    $add_ts_link_menu->g_wm_geometry($geom);

    if ($props{$id}{meta} eq "vert_wd_zone") {
        @link_types = ("Flow", "Temperature", "Water Surface Elevation");
        $ts_type = "Flow";
        $units   = "cfs";
        @names   = @{ $gr_props{$id}{names} };
        push (@names, "All Outlets");
    } else {
        @link_types = ("Water Surface Elevation");
        $ts_type = "Water Surface Elevation";
        $units   = "ft";
        @names   = ("All Outlets");
    }

    @def_colors = ("#000000", "#CC0000", "#0000FF", "#00E6FF", "#9900CC",
                   "#008B00", "#FF9900", "#990033", "#999999", "#FF00FF");
    for ($n=0; $n<=$#names; $n++) {
        $show[$n]  = 0;
        $width[$n] = $default_width;
        $color[$n] = $def_colors[$n % 10];
    }
    $show[-1] = 1;

    &end_select($canv, $id, 1);

    if ($ts_type eq "Flow") {
        @unit_opts = ("cfs", "cms");
    } elsif ($ts_type eq "Water Surface Elevation") {
        @unit_opts = ("ft", "m");
    } else {
        @unit_opts = ("Celsius", "Fahrenheit");
    }

#   Get date lists for start and end dates
    ($jd_min, $jd_max) = &dates2jdates($dates[0], $dates[$#dates]);
    $jd_min    = &floor($jd_min +0.0000001);
    $jd_max    = &floor($jd_max +1.0000001);
    @datelist1 = &jdates2datelabels("Mon-DD-YYYY", ($jd_min .. $jd_max));
    @datelist2 = @datelist1;
    pop   @datelist1;        # remove last  entry from list 1
    shift @datelist2;        # remove first entry from list 2
    $xmin = $datelist1[0];
    $xmax = $datelist2[-1];

    $frame = $add_ts_link_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    $frame->new_button(
            -text    => "Create",
            -command => sub { &set_ts_link($canv, $id, $ts_type, $units, \@show,
                                           \@width, \@color, $xmin, $xmax,
                                           );
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $add_ts_link_menu->g_destroy();
                              undef $add_ts_link_menu; },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

    $ts_frame = $add_ts_link_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $ts_frame->g_pack(-side => 'top');

    $row = 0;
    $ts_frame->new_label(
            -text => "Link Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ts_type_cb = $ts_frame->new_ttk__combobox(
            -textvariable => \$ts_type,
            -values       => [ @link_types ],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $ts_type_cb->g_bind("<<ComboboxSelected>>",
              sub { if ($ts_type eq "Flow") {
                        @unit_opts = ("cfs", "cms");
                        $units = "cfs" if ($units !~ /^(cfs|cms)$/);
                        $outlet_frame->g_grid();
                        $width_label->g_grid_remove();
                        $width_sb->g_grid_remove();
                        $color_label->g_grid_remove();
                        $color_btn->g_grid_remove();
                    } elsif ($ts_type eq "Water Surface Elevation") {
                        @unit_opts = ("ft", "m");
                        $units = "ft" if ($units !~ /^(ft|m)$/);
                        $outlet_frame->g_grid_remove();
                        $width_label->g_grid();
                        $width_sb->g_grid();
                        $color_label->g_grid();
                        $color_btn->g_grid();
                    } else {
                        @unit_opts = ("Celsius", "Fahrenheit");
                        $units = "Celsius" if ($units !~ /^(Celsius|Fahrenheit)$/);
                        $outlet_frame->g_grid();
                        $width_label->g_grid_remove();
                        $width_sb->g_grid_remove();
                        $color_label->g_grid_remove();
                        $color_btn->g_grid_remove();
                    }
                    $units_cb->configure(-values => [ @unit_opts ]);
                  });

    $row++;
    $ts_frame->new_label(
            -text => "Link Units: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($units_cb = $ts_frame->new_ttk__combobox(
            -textvariable => \$units,
            -values       => [ @unit_opts ],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    $row++;
    ($outlet_frame = $ts_frame->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_grid(-row => $row, -column => 0, -columnspan => 2, -sticky => 'ew', -pady => 2);

    $row2 = 0;
    $outlet_frame->new_label(
            -text => "Outlet",
            -font => 'default',
            )->g_grid(-row => $row2, -column => 1, -sticky => 'ew', -pady => 2);
    $outlet_frame->new_label(
            -text => "  Width  ",
            -font => 'default',
            )->g_grid(-row => $row2, -column => 2, -sticky => 'ew', -pady => 2);
    $outlet_frame->new_label(
            -text => "  Color  ",
            -font => 'default',
            )->g_grid(-row => $row2, -column => 3, -sticky => 'ew', -pady => 2);

    for ($n=0; $n<=$#names; $n++) {
        $row2++;
        $outlet_frame->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "",
                -font     => 'default',
                -variable => \$show[$n],
                -command  => [ sub { my ($nn) = @_;
                                     if ($show[$nn]) {
                                         $width_sbs[$nn]->configure(-state  => 'normal');
                                         $color_btns[$nn]->configure(-state => 'normal');
                                     } else {
                                         $width_sbs[$nn]->configure(-state  => 'disabled');
                                         $color_btns[$nn]->configure(-state => 'disabled');
                                     }
                                   }, $n ]
                )->g_grid(-row => $row2, -column => 0, -sticky => 'e', -pady => 2);
        $outlet_frame->new_label(
                -text => $names[$n],
                -font => 'default',
                )->g_grid(-row => $row2, -column => 1, -sticky => 'w', -pady => 2);
        ($width_sbs[$n] = $outlet_frame->new_spinbox(
                -textvariable => \$width[$n],
                -state        => 'readonly',
                -font         => 'default',
                -from         => 1,
                -to           => 10,
                -increment    => 1,
                -width        => 3,
                ))->g_grid(-row => $row2, -column => 2, -sticky => 'w', -padx => 4, -pady => 2);

        $code      = &get_rgb_code($color[$n]);
        $color[$n] = &get_rgb_name($code);
        $fg        = &get_rgb_code("black");
        if ($code =~ /^\#[0-9a-f]/i) {
            $fg = &get_rgb_code(&get_bw_contrast($code));
        }
        ($color_btns[$n] = $outlet_frame->new_button(
                -textvariable => \$color[$n],
                -background   => $code,
                -foreground   => $fg,
                -width        => -7,
                -command => [ sub { my ($nn) = @_;
                                    my ($newc, $code, $fg);
                                    $code = &get_rgb_code($color[$nn]);
                                    $newc = Tkx::tk___chooseColor(
                                               -initialcolor => $code,
                                               -parent       => $add_ts_link_menu);
                                    if ($newc) {
                                        $code       = &get_rgb_code($newc);
                                        $color[$nn] = &get_rgb_name($code);
                                        $fg         = &get_rgb_code("black");
                                        if ($code =~ /^#?[0-9a-f]/i) {
                                            $fg = &get_rgb_code(&get_bw_contrast($code));
                                        }
                                        $color_btns[$nn]->configure(-foreground => $fg,
                                                                    -background => $code);
                                        if ($nn == 0) {
                                            $color_btn->configure(-foreground => $fg,
                                                                  -background => $code);
                                        }
                                    }
                                  }, $n ]
                ))->g_grid(-row => $row2, -column => 3, -sticky => 'ew', -pady => 0);
        if ($show[$n]) {
            $width_sbs[$n]->configure(-state  => 'normal');
            $color_btns[$n]->configure(-state => 'normal');
        } else {
            $width_sbs[$n]->configure(-state  => 'disabled');
            $color_btns[$n]->configure(-state => 'disabled');
        }
    }

    $row++;
    ($width_label = $ts_frame->new_label(
            -text => "Outline Width: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($width_sb = $ts_frame->new_spinbox(
            -textvariable => \$width[0],
            -state        => 'readonly',
            -font         => 'default',
            -from         => 1,
            -to           => 10,
            -increment    => 1,
            -width        => 3,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    $row++;
    ($color_label = $ts_frame->new_label(
            -text => "Outline Color: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);

    $code     = &get_rgb_code($color[0]);
    $color[0] = &get_rgb_name($code);
    $fg       = &get_rgb_code("black");
    if ($code =~ /^\#[0-9a-f]/i) {
        $fg = &get_rgb_code(&get_bw_contrast($code));
    }
    ($color_btn = $ts_frame->new_button(
            -textvariable => \$color[0],
            -background   => $code,
            -foreground   => $fg,
            -width        => -7,
            -command => sub { my ($newc, $code, $fg);
                              $code = &get_rgb_code($color[0]);
                              $newc = Tkx::tk___chooseColor(
                                         -initialcolor => $code,
                                         -parent       => $add_ts_link_menu);
                              if ($newc) {
                                  $code     = &get_rgb_code($newc);
                                  $color[0] = &get_rgb_name($code);
                                  $fg       = &get_rgb_code("black");
                                  if ($code =~ /^#?[0-9a-f]/i) {
                                      $fg = &get_rgb_code(&get_bw_contrast($code));
                                  }
                                  $color_btn->configure(-foreground => $fg,
                                                        -background => $code);
                                  $color_btns[0]->configure(-foreground => $fg,
                                                            -background => $code);
                              }
                            }
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    if ($ts_type eq "Water Surface Elevation") {
        $outlet_frame->g_grid_remove();
    } else {
        $width_label->g_grid_remove();
        $width_sb->g_grid_remove();
        $color_label->g_grid_remove();
        $color_btn->g_grid_remove();
    }

    $row++;
    $ts_frame->new_label(
            -text    => "Start Date: ",
            -font    => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $ts_frame->new_ttk__combobox(
            -textvariable => \$xmin,
            -values       => [ @datelist1 ],
            -state        => 'readonly',
            )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $row++;
    $ts_frame->new_label(
            -text    => "End Date: ",
            -font    => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $ts_frame->new_ttk__combobox(
            -textvariable => \$xmax,
            -values       => [ @datelist2 ],
            -state        => 'readonly',
            )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    Tkx::wm_resizable($add_ts_link_menu,0,0);
    &adjust_window_position($add_ts_link_menu);
    $add_ts_link_menu->g_focus;
}


sub set_ts_link {
    my ($canv, $id, $ts_type, $units, $show_ref, $width_ref, $color_ref, $xmin, $xmax) = @_;
    my ($date, $flow, $jd, $jd_max, $jd_min, $max, $n,
        @color, @names, @qstr, @show, @width,
        %parms, %qdata,
       );

    @show  = @{ $show_ref  };
    @width = @{ $width_ref };
    @color = @{ $color_ref };

#   Ensure that xmin is less than xmax
    $jd_min = &datelabel2jdate($xmin);
    $jd_max = &datelabel2jdate($xmax);
    if ($jd_min >= $jd_max) {
        return &pop_up_error($add_ts_link_menu,
                             "The start date must be prior to the end date.");
    }
    if ($ts_type ne "Water Surface Elevation") {
        if (&list_search("1", @show) == -1) {
            return &pop_up_error($add_ts_link_menu,
                                 "At least one outlet must be chosen.\nPlease try again.");
        }
    }

    $parms{ts_type} = $ts_type;
    $parms{units}   = $units;
    $parms{show}    = [ @show  ];
    $parms{width}   = [ @width ];
    $parms{color}   = [ @color ];
    $parms{xmin}    = $xmin;
    $parms{xmax}    = $xmax;
    if ($ts_type eq "Water Surface Elevation") {
        $parms{ymin} = $gr_props{$id}{ymin};
        $parms{ymax} = $gr_props{$id}{ymax};
        if ($units eq "ft" && $gr_props{$id}{yunits} ne "feet") {
            $parms{ymin} =  int($parms{ymin} *3.28084 /100)     *100;
            $parms{ymax} = (int($parms{ymax} *3.28084 /100) +1) *100;
        } elsif ($units eq "m" && $gr_props{$id}{yunits} eq "feet") {
            $parms{ymin} =  int($parms{ymin} /3.28084 /100)     *100;
            $parms{ymax} = (int($parms{ymax} /3.28084 /100) +1) *100;
        }
    } elsif ($ts_type eq "Flow") {
        %qdata = %{ $gr_props{$id}{qdata} };
        @names = @{ $gr_props{$id}{names} };
        push (@names, "All Outlets");
        $max = 0;
        for ($n=0; $n<=$#names; $n++) {
            next if (! $show[$n]);
            foreach $date (@dates) {
                $jd = &date2jdate($date);
                next if ($jd < $jd_min);
                last if ($jd > $jd_max);
                if (defined($qdata{$date})) {
                    @qstr = @{ $qdata{$date} };
                    if ($names[$n] eq "All Outlets") {
                        $flow = &sum(@qstr);
                    } else {
                        $flow = $qstr[$n];
                    }
                    $max = $flow if ($flow > $max);
                }
            }
        }
        undef %qdata;
        $parms{ymin} = 0;
        $parms{ymax} = (int($max /10.) +1) *10;
        if ($units eq "cfs") {
            $parms{ymax} = (int($parms{ymax} *35.31467 /100.) +1) *100;
        }
    } elsif ($ts_type eq "Temperature") {
        if ($gr_props{$id}{add_cs}) {
            if ($props{$id}{wt_units} eq "Fahrenheit") {
                $parms{ymin} = ($gr_props{$id}{cs_min} -32) /1.8;
                $parms{ymax} = ($gr_props{$id}{cs_max} -32) /1.8;
            } else {
                $parms{ymin} = $gr_props{$id}{cs_min};
                $parms{ymax} = $gr_props{$id}{cs_max};
            }
        } else {
            $parms{ymin} =  0;
            $parms{ymax} = 24;
        }
        if ($units eq "Fahrenheit") {
            $parms{ymin} = 1.8 *$parms{ymin} +32;
            $parms{ymax} = 1.8 *$parms{ymax} +32;
        }
    }

    $canv->g_bind("<Motion>",   [ \&show_xypos,     Tkx::Ev("%x","%y"), $canv, 1 ]);
    $canv->g_bind("<Button-1>", [ \&start_ts_graph, Tkx::Ev("%x","%y"), $canv, $id, %parms ]);
    $canv->g_bind("<Button-3>", [ \&forget_drawing, '' ]);
    $canv->configure(-cursor => $cursor_draw);

    $add_ts_link_menu->g_destroy();
    undef $add_ts_link_menu;
}


sub start_ts_graph {
    my ($x, $y, $canv, $link_id, %parms) = @_;
    my ($id);

    ($x, $y) = &get_xy($canv, $x, $y, $snap2grid);
    $canv->delete("target");

    $id = $canv->create_rectangle($x, $y, $x, $y,
                 -outline => &get_rgb_code($default_color),
                 -width   => 1,
                 -fill    => "",
                 -tags    => "working");
    $props{$id}{type}      = "graph";
    $props{$id}{meta}      = "linked_time_series";
    $props{$id}{x}         = $x;
    $props{$id}{y}         = $y;
    $props{$id}{xc}        = $x;
    $props{$id}{yc}        = $y;
    $props{$id}{anchor}    = 'corner';
    $props{$id}{coordlist} = [$x, $y, $x, $y];
    $props{$id}{color}     = $default_color;
    $props{$id}{width}     = $default_width;
    $props{$id}{fill}      = 0;
    $props{$id}{link_id}   = $link_id;
    $props{$id}{ts_parms}  = { %parms };
    $canv->addtag("graph" . $id, withtag => $id);

    $canv->create_rectangle($x-2, $y-2, $x+2, $y+2,
                 -outline => &get_rgb_code($anchor_line_color),
                 -width   => 1,
                 -fill    => &get_rgb_code($anchor_select_color),
                 -tags    => "anchor");

    $canv->g_bind("<Shift-Motion>", [ \&size_object, Tkx::Ev("%x","%y"), $canv, $x, $y, $id, 1 ]);
    $canv->g_bind("<Motion>",       [ \&size_object, Tkx::Ev("%x","%y"), $canv, $x, $y, $id, 0 ]);
    $canv->g_bind("<Button-1>",     [ \&end_drawing, Tkx::Ev("%x","%y"), $canv, $x, $y, $id ]);
    $canv->g_bind("<Button-3>",     [ \&forget_drawing, $id ]);
}


sub show_info {
    my ($canv, $id, $X, $Y) = @_;
    my (
        $coordlist, $croplist, $diff, $dist_txt, $dpth_txt, $dt_txt,
        $dtmax, $dtmin, $elev_txt, $f, $flip, $flow_txt, $frame, $geom,
        $i, $npts, $obj_type, $parm_txt, $pmax, $pmin, $ptxt, $row, $scale,
        $tmp_frame, $txt, $type, $xmax, $xmin, $ymax, $ymin,

        @bfiles, @cfiles, @coords, @crop, @xvals, @yvals,
        %parms,
       );

    &end_select($canvas, $id, 1);

    $geom = sprintf("+%d+%d", $X, $Y);
    $type = $props{$id}{type};

    if (defined($object_infobox) && Tkx::winfo_exists($object_infobox)) {
        if ($object_infobox->g_wm_title() eq "Object Info") {
            $object_infobox->g_destroy();
            undef $object_infobox;
        }
    }
    $object_infobox = $main->new_toplevel();
    $object_infobox->g_wm_transient($main);
    $object_infobox->g_wm_title("Object Info");
    $object_infobox->configure(-cursor => $cursor_norm);
    $object_infobox->g_wm_geometry($geom);

    $frame = $object_infobox->new_frame();
    $frame->g_pack(-side => 'bottom');
    $frame->new_button(
            -text    => "OK",
            -command => sub { $object_infobox->g_destroy();
                              undef $object_infobox; },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

    $f = $object_infobox->new_frame(
                -borderwidth => 1,
                -relief => 'groove',
                );
    $f->g_pack(-side => 'top');

    $row = 0;
    $obj_type  = ucfirst($type);
    $obj_type .= " Link" if ($type =~ /^(text|circle|ellipse|rectangle|diamond|polygon)$/
                             && defined($link_props{$id}{id}));

    if ($type eq "graph") {
        if ($props{$id}{meta} eq "data_profile") {
            $obj_type = "Profile Graph";
        } elsif ($props{$id}{meta} eq "data_profile_cmap") {
            $obj_type = "Profile Colormap";
        } elsif ($props{$id}{meta} eq "w2_profile") {
            $obj_type = "W2 Profile Graph";
        } elsif ($props{$id}{meta} eq "w2_profile_cmap") {
            $obj_type = "W2 Profile Colormap";
        } elsif ($props{$id}{meta} eq "w2_outflow") {
            $obj_type = "W2 Outflow Profile";
        } elsif ($props{$id}{meta} eq "w2_wlevels") {
            $obj_type = "W2 Water Levels Graph";
        } elsif ($props{$id}{meta} eq "w2_slice") {
            $obj_type = "W2 Longitudinal Slice";
        } elsif ($props{$id}{meta} eq "w2_tdmap") {
            $obj_type = "W2 Time/Distance Map";
            if ($props{$id}{map_type} =~ /^(parmdiff|filediff)$/) {
                $obj_type = "W2 Time/Distance Difference Map";
            }
        } elsif ($props{$id}{meta} eq "vert_wd_zone") {
            $obj_type = "Vertical Withdrawal Zone";
        } elsif ($props{$id}{meta} eq "linked_time_series") {
            $obj_type = "Linked Time Series Graph";
        } elsif ($props{$id}{meta} eq "time_series") {
            $obj_type = "Time Series Graph";
        }
    }
    $f->new_label(
            -text => "Object: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $f->new_label(
            -text => $obj_type,
            -font => 'default',
            )->g_grid(-row => $row, -column => 1, -sticky => 'w');
    if ($type eq "graph") {
        if ($props{$id}{meta} =~ /data_profile/) {
            $row++;
            $f->new_label(
                    -text => "Profile Type: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => ucfirst($props{$id}{prof_type}),
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
        }
        if ($props{$id}{meta} =~ /data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone/) {
            if ($gr_props{$id}{elev_min} eq "n/a") {
                $elev_txt = "n/a to ";
            } else {
                if ($gr_props{$id}{yunits} eq "feet") {
                    $elev_txt = sprintf("%.2f", $gr_props{$id}{elev_min} *3.28084) . " to ";
                } else {
                    $elev_txt = sprintf("%.2f", $gr_props{$id}{elev_min}) . " to ";
                }
            }
            if ($gr_props{$id}{elev_max} eq "n/a") {
                if ($gr_props{$id}{yunits} eq "feet") {
                    $elev_txt .= "n/a ft";
                } else {
                    $elev_txt .= "n/a m";
                }
            } else {
                if ($gr_props{$id}{yunits} eq "feet") {
                    $elev_txt .= sprintf("%.2f", $gr_props{$id}{elev_max} *3.28084) . " ft";
                } else {
                    $elev_txt .= sprintf("%.2f", $gr_props{$id}{elev_max}) . " m";
                }
            }
            if ($props{$id}{meta} ne "w2_wlevels") {
                if ($gr_props{$id}{dpth_min} eq "n/a") {
                    $dpth_txt = "n/a to ";
                } else {
                    if ($gr_props{$id}{yunits} eq "feet") {
                        $dpth_txt = sprintf("%.2f", $gr_props{$id}{dpth_min} *3.28084) . " to ";
                    } else {
                        $dpth_txt = sprintf("%.2f", $gr_props{$id}{dpth_min}) . " to ";
                    }
                }
                if ($gr_props{$id}{dpth_max} eq "n/a") {
                    if ($gr_props{$id}{yunits} eq "feet") {
                        $dpth_txt .= "n/a ft";
                    } else {
                        $dpth_txt .= "n/a m";
                    }
                } else {
                    if ($gr_props{$id}{yunits} eq "feet") {
                        $dpth_txt .= sprintf("%.2f", $gr_props{$id}{dpth_max} *3.28084) . " ft";
                    } else {
                        $dpth_txt .= sprintf("%.2f", $gr_props{$id}{dpth_max}) . " m";
                    }
                }
            }
        }
        if ($props{$id}{meta} =~ /data_profile|w2_profile|w2_slice/) {
            if ($props{$id}{parm} eq "Temperature") {
                if ($props{$id}{parm_units} eq "Fahrenheit") {
                    if ($props{$id}{meta} =~ /data_profile/
                         && $props{$id}{prof_type} eq "difference") {
                        $diff = 0;
                    } else {
                        $diff = 32;
                    }
                    if ($gr_props{$id}{parm_min} eq "n/a") {
                        $parm_txt = "n/a to ";
                    } else {
                        $parm_txt = sprintf("%.2f", $gr_props{$id}{parm_min} *1.8 +$diff) . " to ";
                    }
                    if ($gr_props{$id}{parm_max} eq "n/a") {
                        $parm_txt .= "n/a " . " \N{U+00B0}" . substr($props{$id}{parm_units},0,1);
                    } else {
                        $parm_txt .= sprintf("%.2f", $gr_props{$id}{parm_max} *1.8 +$diff)
                                   . " \N{U+00B0}" . substr($props{$id}{parm_units},0,1);
                    }
                } else {
                    if ($gr_props{$id}{parm_min} eq "n/a") {
                        $parm_txt = "n/a to ";
                    } else {
                        $parm_txt = sprintf("%.2f", $gr_props{$id}{parm_min}) . " to ";
                    }
                    if ($gr_props{$id}{parm_max} eq "n/a") {
                        $parm_txt .= "n/a " . " \N{U+00B0}" . substr($props{$id}{parm_units},0,1);
                    } else {
                        $parm_txt .= sprintf("%.2f", $gr_props{$id}{parm_max})
                                   . " \N{U+00B0}" . substr($props{$id}{parm_units},0,1);
                    }
                }
            } else {
                if ($gr_props{$id}{parm_min} eq "n/a") {
                    $parm_txt = "n/a to ";
                } else {
                    $parm_txt = sprintf("%.2f", $gr_props{$id}{parm_min}) . " to ";
                }
                if ($gr_props{$id}{parm_max} eq "n/a") {
                    $parm_txt .= "n/a " . $props{$id}{parm_units};
                } else {
                    $parm_txt .= sprintf("%.2f", $gr_props{$id}{parm_max}) . " "
                               . $props{$id}{parm_units};
                }
            }
            $row++;
            $f->new_label(
                    -text => "Parameter: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            if ($props{$id}{meta} =~ /w2_profile|w2_slice/ && $props{$id}{parm_div} ne "None") {
                $f->new_label(
                        -text => $props{$id}{parm} . " / " . $props{$id}{parm_div},
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            } else {
                $f->new_label(
                        -text => $props{$id}{parm},
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            }
            $row++;
            $f->new_label(
                    -text => "Parameter Range: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $parm_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "Elevation Range: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $elev_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "Depth Range: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $dpth_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');

            if ($props{$id}{meta} eq "w2_slice") {
                if ($gr_props{$id}{xunits} eq "miles") {
                    $dist_txt = sprintf("%.3f", $gr_props{$id}{x_km} *3280.84/5280.) . " miles";
                } else {
                    $dist_txt = sprintf("%.3f", $gr_props{$id}{x_km}) . " kms";
                }
                $row++;
                $f->new_label(
                        -text => "Distance Range: ",
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                $f->new_label(
                        -text => $dist_txt,
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            }

        } elsif ($props{$id}{meta} eq "w2_tdmap") {
            if ($props{$id}{parm} eq "Temperature") {
                if ($props{$id}{parm_units} eq "Fahrenheit") {
                    $diff = ($props{$id}{map_type} eq "standard") ? 32 : 0;
                    if ($gr_props{$id}{parm_min} eq "n/a") {
                        $parm_txt = "n/a to ";
                    } else {
                        $parm_txt = sprintf("%.2f", $gr_props{$id}{parm_min} *1.8 +$diff) . " to ";
                    }
                    if ($gr_props{$id}{parm_max} eq "n/a") {
                        $parm_txt .= "n/a " . " \N{U+00B0}" . substr($props{$id}{parm_units},0,1);
                    } else {
                        $parm_txt .= sprintf("%.2f", $gr_props{$id}{parm_max} *1.8 +$diff)
                                   . " \N{U+00B0}" . substr($props{$id}{parm_units},0,1);
                    }
                } else {
                    if ($gr_props{$id}{parm_min} eq "n/a") {
                        $parm_txt = "n/a to ";
                    } else {
                        $parm_txt = sprintf("%.2f", $gr_props{$id}{parm_min}) . " to ";
                    }
                    if ($gr_props{$id}{parm_max} eq "n/a") {
                        $parm_txt .= "n/a " . " \N{U+00B0}" . substr($props{$id}{parm_units},0,1);
                    } else {
                        $parm_txt .= sprintf("%.2f", $gr_props{$id}{parm_max})
                                   . " \N{U+00B0}" . substr($props{$id}{parm_units},0,1);
                    }
                }
                if ($props{$id}{parm_div} ne "None" && $parm_txt =~ / \N{U+00B0}[CF]/) {
                    $parm_txt =~ s/ \N{U+00B0}[CF]//;
                }
            } else {
                if ($gr_props{$id}{parm_min} eq "n/a") {
                    $parm_txt = "n/a to ";
                } else {
                    $parm_txt = sprintf("%.2f", $gr_props{$id}{parm_min}) . " to ";
                }
                if ($gr_props{$id}{parm_max} eq "n/a") {
                    $parm_txt .= "n/a " . $props{$id}{parm_units};
                } else {
                    $parm_txt .= sprintf("%.2f", $gr_props{$id}{parm_max}) . " "
                               . $props{$id}{parm_units};
                }
            }
            if ($gr_props{$id}{dunits} eq "miles") {
                $dist_txt = sprintf("%.3f", $gr_props{$id}{d_km} *3280.84/5280.) . " miles";
            } else {
                $dist_txt = sprintf("%.3f", $gr_props{$id}{d_km}) . " kms";
            }
            if ($props{$id}{pdiv_sav} ne "None") {
                $txt = $props{$id}{parm_sav} . " / " . $props{$id}{pdiv_sav};
            } else {
                $txt = $props{$id}{parm_sav};
            }
            if ($props{$id}{map_type} eq "parmdiff") {
                if ($props{$id}{swap_order}) {
                    if ($props{$id}{pdiv2_sav} ne "None") {
                        $txt = $props{$id}{parm2_sav} . " / " . $props{$id}{pdiv2_sav} . " minus " . $txt;
                    } else {
                        $txt = $props{$id}{parm2_sav} . " minus " . $txt;
                    }
                } else {
                    if ($props{$id}{pdiv2_sav} ne "None") {
                        $txt .= " minus " . $props{$id}{parm2_sav} . " / " . $props{$id}{pdiv2_sav};
                    } else {
                        $txt .= " minus " . $props{$id}{parm2_sav};
                    }
                }
                $ptxt = "Difference: ";
            } else {
                $ptxt = "Parameter: ";
            }
            $row++;
            $f->new_label(
                    -text => $ptxt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "Profile Stat: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $props{$id}{prof_stat},
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "Parameter Range: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $parm_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "Distance Range: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $dist_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');

        } elsif ($props{$id}{meta} eq "w2_outflow") {
            if ($gr_props{$id}{qunits} eq "cfs/ft") {
                $txt      = "Outflow Range: ";
                $flow_txt = sprintf("%.2f", $gr_props{$id}{flow_min} *10.763911) . " to "
                          . sprintf("%.2f", $gr_props{$id}{flow_max} *10.763911) . " cfs/(vert. ft)";
            } elsif ($gr_props{$id}{qunits} eq "cms/m") {
                $txt      = "Outflow Range: ";
                $flow_txt = sprintf("%.2f", $gr_props{$id}{flow_min}) . " to "
                          . sprintf("%.2f", $gr_props{$id}{flow_max}) . " cms/(vert. m)";
            } elsif ($gr_props{$id}{qunits} eq "ft/s") {
                $txt      = "Velocity Range: ";
                $flow_txt = sprintf("%.3f", $gr_props{$id}{vel_min} *3.28084) . " to "
                          . sprintf("%.3f", $gr_props{$id}{vel_max} *3.28084) . " ft/s";
            } else {
                $txt      = "Velocity Range: ";
                $flow_txt = sprintf("%.3f", $gr_props{$id}{vel_min}) . " to "
                          . sprintf("%.3f", $gr_props{$id}{vel_max}) . " m/s";
            }
            $row++;
            $f->new_label(
                    -text => "Elevation Range: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $elev_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "Depth Range: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $dpth_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => $txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $flow_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            if ($props{$id}{add_parm}) {
                if ($props{$id}{parm} eq "Temperature") {
                    if ($props{$id}{parm_units} eq "Fahrenheit") {
                        if ($gr_props{$id}{parm_min} eq "n/a") {
                            $parm_txt = "n/a to ";
                        } else {
                            $parm_txt = sprintf("%.2f", $gr_props{$id}{parm_min} *1.8 +32) . " to ";
                        }
                        if ($gr_props{$id}{parm_max} eq "n/a") {
                            $parm_txt .= "n/a " . " \N{U+00B0}" . substr($props{$id}{parm_units},0,1);
                        } else {
                            $parm_txt .= sprintf("%.2f", $gr_props{$id}{parm_max} *1.8 +32)
                                       . " \N{U+00B0}" . substr($props{$id}{parm_units},0,1);
                        }
                    } else {
                        if ($gr_props{$id}{parm_min} eq "n/a") {
                            $parm_txt = "n/a to ";
                        } else {
                            $parm_txt = sprintf("%.2f", $gr_props{$id}{parm_min}) . " to ";
                        }
                        if ($gr_props{$id}{parm_max} eq "n/a") {
                            $parm_txt .= "n/a " . " \N{U+00B0}" . substr($props{$id}{parm_units},0,1);
                        } else {
                            $parm_txt .= sprintf("%.2f", $gr_props{$id}{parm_max})
                                       . " \N{U+00B0}" . substr($props{$id}{parm_units},0,1);
                        }
                    }
                } else {
                    if ($gr_props{$id}{parm_min} eq "n/a") {
                        $parm_txt = "n/a to ";
                    } else {
                        $parm_txt = sprintf("%.2f", $gr_props{$id}{parm_min}) . " to ";
                    }
                    if ($gr_props{$id}{parm_max} eq "n/a") {
                        $parm_txt .= "n/a " . $props{$id}{parm_units};
                    } else {
                        $parm_txt .= sprintf("%.2f", $gr_props{$id}{parm_max}) . " "
                                   . $props{$id}{parm_units};
                    }
                }
                $row++;
                $f->new_label(
                        -text => "Color Parameter: ",
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                if ($props{$id}{parm_div} ne "None") {
                    $f->new_label(
                            -text => $props{$id}{parm} . " / " . $props{$id}{parm_div},
                            -font => 'default',
                            )->g_grid(-row => $row, -column => 1, -sticky => 'w');
                } else {
                    $f->new_label(
                            -text => $props{$id}{parm},
                            -font => 'default',
                            )->g_grid(-row => $row, -column => 1, -sticky => 'w');
                }
                $row++;
                $f->new_label(
                        -text => "Parameter Range: ",
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                $f->new_label(
                        -text => $parm_txt,
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            }

        } elsif ($props{$id}{meta} eq "w2_wlevels") {
            if ($gr_props{$id}{xunits} eq "miles") {
                $dist_txt = sprintf("%.3f", $gr_props{$id}{x_km} *3280.84/5280.) . " miles";
            } else {
                $dist_txt = sprintf("%.3f", $gr_props{$id}{x_km}) . " kms";
            }
            $row++;
            $f->new_label(
                    -text => "Elevation Range: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $elev_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "Distance Range: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $dist_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');

        } elsif ($props{$id}{meta} eq "vert_wd_zone") {
            if ($props{$id}{wt_units} eq "Fahrenheit") {
                if ($gr_props{$id}{parm_min} eq "n/a") {
                    $parm_txt = "n/a to ";
                } else {
                    $parm_txt = sprintf("%.2f", $gr_props{$id}{parm_min} *1.8 +32) . " to ";
                }
                if ($gr_props{$id}{parm_max} eq "n/a") {
                    $parm_txt .= "n/a " . " \N{U+00B0}" . substr($props{$id}{wt_units},0,1);
                } else {
                    $parm_txt .= sprintf("%.2f", $gr_props{$id}{parm_max} *1.8 +32)
                               . " \N{U+00B0}" . substr($props{$id}{wt_units},0,1);
                }
            } else {
                if ($gr_props{$id}{parm_min} eq "n/a") {
                    $parm_txt = "n/a to ";
                } else {
                    $parm_txt = sprintf("%.2f", $gr_props{$id}{parm_min}) . " to ";
                }
                if ($gr_props{$id}{parm_max} eq "n/a") {
                    $parm_txt .= "n/a " . " \N{U+00B0}" . substr($props{$id}{wt_units},0,1);
                } else {
                    $parm_txt .= sprintf("%.2f", $gr_props{$id}{parm_max})
                               . " \N{U+00B0}" . substr($props{$id}{wt_units},0,1);
                }
            }
            if ($gr_props{$id}{qunits} eq "cfs/ft" || $gr_props{$id}{qunits} eq "ft/s") {
                $flow_txt = sprintf("%.2f", $gr_props{$id}{flow_min} *35.31467) . " to "
                          . sprintf("%.2f", $gr_props{$id}{flow_max} *35.31467) . " cfs";
            } else {
                $flow_txt = sprintf("%.2f", $gr_props{$id}{flow_min}) . " to "
                          . sprintf("%.2f", $gr_props{$id}{flow_max}) . " cms";
            }
            $row++;
            $f->new_label(
                    -text => "Temperature Range: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $parm_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "Elevation Range: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $elev_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "Depth Range: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $dpth_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "Total Outflow Range: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $flow_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');

            if (! defined($gr_props{$id}{qtot_min}) || $gr_props{$id}{qtot_min} eq "not determined") {
                if ($gr_props{$id}{qunits} eq "cfs/ft" || $gr_props{$id}{qunits} eq "cms/m") {
                    $txt = "Layer Flow Range: ";
                } else {
                    $txt = "Velocity Range: ";
                }
                $row++;
                $f->new_label(
                        -text => $txt,
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                ($tmp_frame = $f->new_frame(
                        -borderwidth => 0,
                        -relief      => 'flat',
                        ))->g_grid(-row => $row, -column => 1, -sticky => 'ew');
                $tmp_frame->new_label(
                        -text => "not determined ",
                        -font => 'default',
                        )->g_pack(-side => 'left', -anchor => 'w');
                $tmp_frame->new_button(
                        -text    => "Calculate",
                        -command => sub { my (%limits, %profile);
                                          &generate_outflow_temps($id, 0);
                                          %profile = %{ $gr_props{$id} };
                                          %limits  = &find_data_limits($id, %profile);

                                          $gr_props{$id}{date_min} = $limits{date_min};
                                          $gr_props{$id}{date_max} = $limits{date_max};
                                          $gr_props{$id}{dpth_min} = $limits{dpth_min};
                                          $gr_props{$id}{dpth_max} = $limits{dpth_max};
                                          $gr_props{$id}{elev_min} = $limits{elev_min};
                                          $gr_props{$id}{elev_max} = $limits{elev_max};
                                          $gr_props{$id}{parm_min} = $limits{parm_min};
                                          $gr_props{$id}{parm_max} = $limits{parm_max};
                                          $gr_props{$id}{flow_min} = $limits{flow_min};
                                          $gr_props{$id}{flow_max} = $limits{flow_max};
                                          $gr_props{$id}{qtot_min} = $limits{qtot_min};
                                          $gr_props{$id}{qtot_max} = $limits{qtot_max};
                                          $gr_props{$id}{vtot_min} = $limits{vtot_min};
                                          $gr_props{$id}{vtot_max} = $limits{vtot_max};
                                          undef %limits;
                                          undef %profile;

                                          $geom = $object_infobox->g_wm_geometry();
                                          (undef, $X, $Y) = split(/\+/, $geom);
                                          &show_info($canv, $id, $X, $Y);
                                        },
                        )->g_pack(-side => 'left', -anchor => 'w', -padx => 2);
            } else {
                if ($gr_props{$id}{qunits} eq "cfs/ft") {
                    $txt      = "Layer Flow Range: ";
                    $flow_txt = sprintf("%.2f", $gr_props{$id}{qtot_min} *10.763911) . " to "
                              . sprintf("%.2f", $gr_props{$id}{qtot_max} *10.763911) . " cfs/(vert. ft)";
                } elsif ($gr_props{$id}{qunits} eq "cms/m") {
                    $txt      = "Layer Flow Range: ";
                    $flow_txt = sprintf("%.2f", $gr_props{$id}{qtot_min}) . " to "
                              . sprintf("%.2f", $gr_props{$id}{qtot_max}) . " cms/(vert. m)";
                } elsif ($gr_props{$id}{qunits} eq "ft/s") {
                    $txt      = "Velocity Range: ";
                    $flow_txt = sprintf("%.3f", $gr_props{$id}{vtot_min} *3.28084) . " to "
                              . sprintf("%.3f", $gr_props{$id}{vtot_max} *3.28084) . " ft/s";
                } else {
                    $txt      = "Velocity Range: ";
                    $flow_txt = sprintf("%.3f", $gr_props{$id}{vtot_min}) . " to "
                              . sprintf("%.3f", $gr_props{$id}{vtot_max}) . " m/s";
                }
                $row++;
                $f->new_label(
                        -text => $txt,
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                $f->new_label(
                        -text => $flow_txt,
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            }

        } elsif ($props{$id}{meta} =~ /time_series/) {
            $txt   = ($props{$id}{meta} eq "linked_time_series") ? "Link " : "";
            %parms = %{ $props{$id}{ts_parms} };
            if ($parms{ts_type} =~ /Temperature/i) {
                $parm_txt = "Temperature (\N{U+00B0}" . substr($parms{units},0,1) . ")";
            } else {
                $parm_txt = $parms{ts_type} . " (" . $parms{units} . ")";
            }
            undef %parms;
            $row++;
            $f->new_label(
                    -text => $txt . "Parameter: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $parm_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');

            ($dtmin, $dtmax, $pmin, $pmax) = &find_ts_limits($id);
            if ($dtmin != -999) {
                $dt_txt = &date2datelabel($dtmin, "Mon-DD-YYYY") . " to ";
                if (substr($dtmax,8,4) eq "0000") {
                    $dt_txt .= &date2datelabel($dtmax, "Mon-DD-YYYY");
                } else {
                    $dt_txt .= &date2datelabel(&adjust_dt_by_day($dtmax, 1), "Mon-DD-YYYY");
                }
                $parm_txt = sprintf("%.2f", $pmin) . " to " . sprintf("%.2f", $pmax);
            } else {
                $dt_txt = $parm_txt = "n/a";
            }
            $row++;
            $f->new_label(
                    -text => "Parameter Range: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $parm_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "Date Range: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $dt_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
        }
        if ($props{$id}{meta}
                =~ /data_profile|w2_profile|w2_tdmap|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone/) {
            if ($gr_props{$id}{date_min} != -999) {
                $dt_txt = &date2datelabel($gr_props{$id}{date_min}, "Mon-DD-YYYY") . " to ";
                if (substr($gr_props{$id}{date_max},8,4) eq "0000") {
                    $dt_txt .= &date2datelabel($gr_props{$id}{date_max}, "Mon-DD-YYYY");
                } else {
                    $dt_txt .= &date2datelabel(&adjust_dt_by_day($gr_props{$id}{date_max}, 1), "Mon-DD-YYYY");
                }
                if ($props{$id}{meta} eq "w2_slice" && $props{$id}{dt_limits}) {
                    $dt_txt .= " (restricted)";
                }
            } else {
                $dt_txt = "n/a";
            }
            $row++;
            $f->new_label(
                    -text => "Date Range: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $dt_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
        }
    }
    if ($type eq "graph") {
        $row++;
        $f->new_label(
                -text => "Graph Number: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text => $props{$id}{gnum},
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
    }
    $row++;
    $f->new_label(
            -text => "ID: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $f->new_label(
            -text => $id,
            -font => 'default',
            )->g_grid(-row => $row, -column => 1, -sticky => 'w');
    $row++;
    $f->new_label(
            -text => "Anchor X: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $f->new_label(
            -text => sprintf("%.4f", $props{$id}{x} -3),
            -font => 'default',
            )->g_grid(-row => $row, -column => 1, -sticky => 'w');
    $row++;
    $f->new_label(
            -text => "Anchor Y: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $f->new_label(
            -text => sprintf("%.4f", $props{$id}{y} -3),
            -font => 'default',
            )->g_grid(-row => $row, -column => 1, -sticky => 'w');
    $row++;
    $f->new_label(
            -text => "Anchor Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $f->new_label(
            -text => $props{$id}{anchor},
            -font => 'default',
            )->g_grid(-row => $row, -column => 1, -sticky => 'w');

    if ($type !~ /^(circle|line|graph)$/) {
        $row++;
        $f->new_label(
                -text => "Angle: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text => sprintf("%d", $props{$id}{angle}),
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
    }

    if ($type eq "image") {
        $flip = "None";
        if ($props{$id}{flip} eq "h") {
            $flip = "Horizontal";
        } elsif ($props{$id}{flip} eq "v") {
            $flip = "Vertical";
        } elsif ($props{$id}{flip} eq "vh") {
            $flip = "Horizontal and Vertical";
        }
        @crop = @{ $props{$id}{crop} };
        $croplist = sprintf("%.5f, %.5f, %.5f, %.5f",
                             $crop[0], $crop[1], $crop[2], $crop[3]);
        $scale = sprintf("%.5f", $props{$id}{iw} /$props{$id}{iwc});
        $row++;
        $f->new_label(
                -text => "Flip: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text => $flip,
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
        $row++;
        $f->new_label(
                -text => "Image Width: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text => $props{$id}{iw},
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
        $row++;
        $f->new_label(
                -text => "Image Height: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text => $props{$id}{ih},
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
        $row++;
        $f->new_label(
                -text => "Crop (L,R,T,B): ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text    => $croplist,
                -font    => 'default',
                -justify => 'left',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
        $row++;
        $f->new_label(
                -text => "Scale: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text => $scale,
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
        $row++;
        $f->new_label(
                -text => "File: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text => $props{$id}{file},
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
        return;

    } elsif ($type eq "text") {
        $row++;
        $f->new_label(
                -text => "Font Family: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text => $props{$id}{family},
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
        $row++;
        $f->new_label(
                -text => "Font Size: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text => $props{$id}{size},
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
        $row++;
        $f->new_label(
                -text => "Font Weight: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text => $props{$id}{weight},
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
        $row++;
        $f->new_label(
                -text => "Font Slant: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text => $slant_options[$props{$id}{slant}],
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
        $row++;
        $f->new_label(
                -text => "Underline: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text => ("no", "yes")[$props{$id}{underline}],
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
        return;
    }

    @xvals     = @yvals = ();
    @coords    = Tkx::SplitList($canv->coords($id));
    $npts      = ($#coords +1)/2;
    $coordlist = "";
    for ($i=0; $i<$npts; $i++) {
        push (@xvals, $coords[2*$i]  -3);
        push (@yvals, $coords[2*$i+1]-3);
        $coordlist .= sprintf("%.4f, %.4f", $coords[2*$i]-3, $coords[2*$i+1]-3);
        $coordlist .= ", " if ($i % 2 == 0 && $i < $npts-1);
        $coordlist .= "\n" if ($i % 2 == 1 && $i < $npts-1);
    }
    $xmin = &min(@xvals);
    $xmax = &max(@xvals);
    $ymin = &min(@yvals);
    $ymax = &max(@yvals);

    if ($type =~ /^(circle|ellipse|rectangle|diamond|graph)$/) {
        $row++;
        $f->new_label(
                -text => "Center X: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text => sprintf("%.4f", $props{$id}{xc} -3),
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
        $row++;
        $f->new_label(
                -text => "Center Y: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text => sprintf("%.4f", $props{$id}{yc} -3),
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
    }

    if ($type eq "ellipse") {
        $row++;
        $f->new_label(
                -text => "Half Width: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text => $props{$id}{hw},
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
        $row++;
        $f->new_label(
                -text => "Half Height: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text => $props{$id}{hh},
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');

    } elsif ($type eq "circle") {
        $row++;
        $f->new_label(
                -text => "Diameter: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text => $xmax -$xmin,
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');

    } elsif ($type =~ /^(rectangle|diamond)$/) {
        $row++;
        $f->new_label(
                -text => "Corners: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text => $smooth_options[$props{$id}{smooth}],
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
    }

    if ($type eq "graph") {
        $row++;
        $f->new_label(
                -text => "Width: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'ne');
        $f->new_label(
                -text    => sprintf("%.4f", $xmax -$xmin),
                -font    => 'default',
                -justify => 'left',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
        $row++;
        $f->new_label(
                -text => "Height: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'ne');
        $f->new_label(
                -text    => sprintf("%.4f", $ymax -$ymin),
                -font    => 'default',
                -justify => 'left',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
    }
    if ($type ne "ellipse") {
        $row++;
        $f->new_label(
                -text => "Coordinates: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'ne');
        $f->new_label(
                -text    => $coordlist,
                -font    => 'default',
                -justify => 'left',
                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
    }

    if ($type eq "graph") {
        if ($props{$id}{meta} =~ /data_profile/) {
            $row++;
            $f->new_label(
                    -text => "Data File: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $props{$id}{src_file},
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
        } elsif ($props{$id}{meta} =~ /vert_wd_zone/) {
            $row++;
            $f->new_label(
                    -text => "WT Data File: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $props{$id}{wt_file},
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "Flow Data File: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $props{$id}{flow_file},
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "Bathymetry File: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $props{$id}{bth_file},
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            if ($props{$id}{wd_alg} eq "Libby Dam") {
                $row++;
                $f->new_label(
                        -text => "Bulkhead Config File: ",
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                $f->new_label(
                        -text => $props{$id}{lbc_file},
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            }
        } elsif ($props{$id}{meta} =~ /w2_profile/) {
            $row++;
            $f->new_label(
                    -text => "W2 Control File: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $props{$id}{con_file},
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => $props{$id}{src_type} . ": ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $props{$id}{src_file},
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "Bathymetry File: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $props{$id}{bth_file},
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            if (defined($props{$id}{ref_file})) {
                $row++;
                $f->new_label(
                        -text => "Reference File: ",
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                $f->new_label(
                        -text => $props{$id}{ref_file},
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            }
        } elsif ($props{$id}{meta} =~ /w2_slice|w2_wlevels/) {
            $row++;
            $f->new_label(
                    -text => "Y Exaggeration: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -textvariable => \$props{$id}{yexag_fac},
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "W2 Segments: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $props{$id}{seg_list},
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "W2 Waterbodies: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $props{$id}{wb_list},
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "W2 Control File: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $props{$id}{con_file},
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');

            if ($props{$id}{src_type} =~ /Contour/i) {
                @cfiles = @{ $props{$id}{cpl_files} };
                for ($i=0; $i<=$#cfiles; $i++) {
                    $row++;
                    $f->new_label(
                            -text => "W2 Contour File: ",
                            -font => 'default',
                            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                    $f->new_label(
                            -text => $cfiles[$i],
                            -font => 'default',
                            )->g_grid(-row => $row, -column => 1, -sticky => 'w');
                }
            } elsif ($props{$id}{src_type} =~ /Vector/i) {
                $row++;
                $f->new_label(
                        -text => "W2 Vector File: ",
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                $f->new_label(
                        -text => $props{$id}{w2l_file},
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            } elsif ($props{$id}{src_type} =~ /Water Level/i) {
                $row++;
                $f->new_label(
                        -text => "W2 Water Level File: ",
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                $f->new_label(
                        -text => $props{$id}{wl_file},
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            }
            @bfiles = @{ $props{$id}{bth_files} };
            for ($i=0; $i<=$#bfiles; $i++) {
                $row++;
                $f->new_label(
                        -text => "Bathymetry File: ",
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                $f->new_label(
                        -text => $bfiles[$i],
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            }
        } elsif ($props{$id}{meta} =~ /w2_tdmap/) {
            $row++;
            $f->new_label(
                    -text => "W2 Segments: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $props{$id}{seg_list},
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "W2 Waterbodies: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $props{$id}{wb_list},
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "W2 Control File: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $props{$id}{con_file},
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');

            if ($props{$id}{src_type} =~ /Contour/i) {
                @cfiles = @{ $props{$id}{cpl_files} };
                for ($i=0; $i<=$#cfiles; $i++) {
                    $row++;
                    $f->new_label(
                            -text => "W2 Contour File: ",
                            -font => 'default',
                            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                    $f->new_label(
                            -text => $cfiles[$i],
                            -font => 'default',
                            )->g_grid(-row => $row, -column => 1, -sticky => 'w');
                }
            } elsif ($props{$id}{src_type} =~ /RiverCon/i) {
                @cfiles = @{ $props{$id}{riv_files} };
                for ($i=0; $i<=$#cfiles; $i++) {
                    $row++;
                    $f->new_label(
                            -text => "W2 RiverCon File: ",
                            -font => 'default',
                            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                    $f->new_label(
                            -text => $cfiles[$i],
                            -font => 'default',
                            )->g_grid(-row => $row, -column => 1, -sticky => 'w');
                }
            } else {
                $row++;
                $f->new_label(
                        -text => $props{$id}{src_type} . ": ",
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                if ($props{$id}{src_type} =~ /Vector/i) {
                    $f->new_label(
                            -text => $props{$id}{w2l_file},
                            -font => 'default',
                            )->g_grid(-row => $row, -column => 1, -sticky => 'w');
                } else {
                    $f->new_label(
                            -text => $props{$id}{src_file},
                            -font => 'default',
                            )->g_grid(-row => $row, -column => 1, -sticky => 'w');
                }
            }
            @bfiles = @{ $props{$id}{bth_files} };
            for ($i=0; $i<=$#bfiles; $i++) {
                $row++;
                $f->new_label(
                        -text => "Bathymetry File: ",
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                $f->new_label(
                        -text => $bfiles[$i],
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            }
            if ($props{$id}{map_type} eq "filediff") {
                if ($props{$id}{src_type2} =~ /Contour/i) {
                    @cfiles = @{ $props{$id}{cpl_files2} };
                    for ($i=0; $i<=$#cfiles; $i++) {
                        $row++;
                        $f->new_label(
                                -text => "W2 Contour File 2: ",
                                -font => 'default',
                                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                        $f->new_label(
                                -text => $cfiles[$i],
                                -font => 'default',
                                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
                    }
                } elsif ($props{$id}{src_type2} =~ /RiverCon/i) {
                    @cfiles = @{ $props{$id}{riv_files2} };
                    for ($i=0; $i<=$#cfiles; $i++) {
                        $row++;
                        $f->new_label(
                                -text => "W2 RiverCon File 2: ",
                                -font => 'default',
                                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                        $f->new_label(
                                -text => $cfiles[$i],
                                -font => 'default',
                                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
                    }
                } else {
                    $row++;
                    $f->new_label(
                            -text => $props{$id}{src_type2} . " 2: ",
                            -font => 'default',
                            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                    if ($props{$id}{src_type2} =~ /Vector/i) {
                        $f->new_label(
                                -text => $props{$id}{w2l_file2},
                                -font => 'default',
                                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
                    } else {
                        $f->new_label(
                                -text => $props{$id}{src_file2},
                                -font => 'default',
                                )->g_grid(-row => $row, -column => 1, -sticky => 'w');
                    }
                }
            }
        } elsif ($props{$id}{meta} =~ /w2_outflow/) {
            $row++;
            $f->new_label(
                    -text => "W2 Control File: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $props{$id}{con_file},
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "Layer Outflow File: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $props{$id}{qla_file},
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            $row++;
            $f->new_label(
                    -text => "Bathymetry File: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e');
            $f->new_label(
                    -text => $props{$id}{bth_file},
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            if ($props{$id}{add_parm}) {
                $row++;
                $f->new_label(
                        -text => $props{$id}{src_type} . ": ",
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 0, -sticky => 'e');
                $f->new_label(
                        -text => $props{$id}{src_file},
                        -font => 'default',
                        )->g_grid(-row => $row, -column => 1, -sticky => 'w');
            }
        }
    }
    Tkx::wm_resizable($object_infobox,0,0);
    &adjust_window_position($object_infobox);
    $object_infobox->g_focus;
}


sub edit_canvas_props {
    my ($X, $Y) = @_;
    my (
        $cc, $ch, $ch_minus_btn, $ch_scale, $code, $color_btn, $cw,
        $cw_minus_btn, $cw_scale, $geom, $gs, $f, $fg, $frame, $grid_scale,
        $minus_img, $plus_img, $row, $s2g, $sc, $sel_color_btn, $sh, $sw,
       );

    $cw  = $canvas_width;
    $ch  = $canvas_height;
    $s2g = $snap2grid;
    $gs  = $grid_spacing;
    $cc  = $canvas_color;
    $sc  = $text_select_color;
    if ($s2g) {
        $sw = &round_to_int(($screen_width  -$min_canvas_width) /$gs) *$gs +$min_canvas_width;
        $sh = &round_to_int(($screen_height -$min_canvas_height)/$gs) *$gs +$min_canvas_height;
    } else {
        $sw = $screen_width;
        $sh = $screen_height;
    }
    if (abs($max_canvas_width -$sw) <= $gs) {
        $max_canvas_width = &max($cw, $sw);
    } else {
        $max_canvas_width = &max($cw, $max_canvas_width, $sw);
    }
    if (abs($max_canvas_height -$sh) <= $gs) {
        $max_canvas_height = &max($ch, $sh);
    } else {
        $max_canvas_height = &max($ch, $max_canvas_height, $sh);
    }
    if ($X == 0) {
        (undef, $X, $Y) = split(/\+/, $main->g_wm_geometry());
        $X += 100;
        $Y += 100;
    }
    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($canvas_props_menu) && Tkx::winfo_exists($canvas_props_menu)) {
        if ($canvas_props_menu->g_wm_title() eq "Canvas Properties") {
            $canvas_props_menu->g_wm_deiconify();
            $canvas_props_menu->g_wm_geometry($geom);
            $canvas_props_menu->g_raise();
            $canvas_props_menu->g_focus;
            &adjust_window_position($canvas_props_menu);
            return;
        }
    }

    $canvas_props_menu = $main->new_toplevel();
    $canvas_props_menu->g_wm_transient($main);
    $canvas_props_menu->g_wm_title("Canvas Properties");
    $canvas_props_menu->configure(-cursor => $cursor_norm);
    $canvas_props_menu->g_wm_geometry($geom);

    $frame = $canvas_props_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    $frame->new_button(
            -text => "OK",
            -command => sub { &set_canvas_props($cw, $ch, $s2g, $gs, $cc, $sc, "OK") },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text => "Apply",
            -command => sub { &set_canvas_props($cw, $ch, $s2g, $gs, $cc, $sc, "Apply") },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text => "Cancel",
            -command => sub { $canvas_props_menu->g_destroy();
                              undef $canvas_props_menu; },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

    $f = $canvas_props_menu->new_frame(
            -borderwidth => 2,
            -relief => 'groove',
            );
    $f->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "Canvas Width: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'se', -pady => 2);
    ($cw_scale = $f->new_scale(
            -orient       => 'horizontal',
            -from         => $min_canvas_width,
            -to           => $max_canvas_width,
            -variable     => \$cw,
            -resolution   => 1,
            -width        => 10,
            -sliderlength => 20,
            -takefocus    => 1,
            -command      => sub { if (&max($cw, $sw) == $max_canvas_width) {
                                       $cw_minus_btn->configure(-state => 'disabled');
                                   } else {
                                       $cw_minus_btn->configure(-state => 'normal');
                                   }
                                 },
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $f->new_label(
            -text => "pixels",
            -font => 'default',
            )->g_grid(-row => $row, -column => 2, -sticky => 'sw', -padx => 2, -pady => 2);

    $plus_img  = Tkx::image_create_photo(-file => "${prog_path}images/plus.png");
    $minus_img = Tkx::image_create_photo(-file => "${prog_path}images/minus.png");
    $f->new_button(
            -repeatdelay    => 10000,
            -repeatinterval => 10000,
            -image   => $plus_img,
            -command => sub { $max_canvas_width += 200;
                              $cw_minus_btn->configure(-state => 'normal');
                              $cw_scale->configure(-to => $max_canvas_width);
                            },
            )->g_grid(-row => $row, -column => 3, -sticky => 'sw', -padx => 2, -pady => 2);
    ($cw_minus_btn = $f->new_button(
            -repeatdelay    => 10000,
            -repeatinterval => 10000,
            -image   => $minus_img,
            -state   => 'normal',
            -command => sub { $max_canvas_width = &max($cw, $max_canvas_width -200, $sw);
                              if ($max_canvas_width == $sw || $max_canvas_width == $cw) {
                                  $cw_minus_btn->configure(-state => 'disabled');
                              }
                              $cw_scale->configure(-to => $max_canvas_width);
                            },
            ))->g_grid(-row => $row, -column => 4, -sticky => 'sw', -padx => 2, -pady => 2);
    if (&max($cw, $sw) == $max_canvas_width) {
        $cw_minus_btn->configure(-state => 'disabled');
    }

    $row++;
    $f->new_label(
            -text => "Canvas Height: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'se', -pady => 2);
    ($ch_scale = $f->new_scale(
            -orient       => 'horizontal',
            -from         => $min_canvas_height,
            -to           => $max_canvas_height,
            -variable     => \$ch,
            -resolution   => 1,
            -width        => 10,
            -sliderlength => 20,
            -takefocus    => 1,
            -command      => sub { if (&max($ch, $sh) == $max_canvas_height) {
                                       $ch_minus_btn->configure(-state => 'disabled');
                                   } else {
                                       $ch_minus_btn->configure(-state => 'normal');
                                   }
                                 },
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $f->new_label(
            -text => "pixels",
            -font => 'default',
            )->g_grid(-row => $row, -column => 2, -sticky => 'sw', -padx => 2, -pady => 2);
    $f->new_button(
            -repeatdelay    => 10000,
            -repeatinterval => 10000,
            -image   => $plus_img,
            -command => sub { $max_canvas_height += 200;
                              $ch_minus_btn->configure(-state => 'normal');
                              $ch_scale->configure(-to => $max_canvas_height);
                            },
            )->g_grid(-row => $row, -column => 3, -sticky => 'sw', -padx => 2, -pady => 2);
    ($ch_minus_btn = $f->new_button(
            -repeatdelay    => 10000,
            -repeatinterval => 10000,
            -image   => $minus_img,
            -state   => 'normal',
            -command => sub { $max_canvas_height = &max($ch, $max_canvas_height -200, $sh);
                              if ($max_canvas_height == $sh || $max_canvas_height == $ch) {
                                  $ch_minus_btn->configure(-state => 'disabled');
                              }
                              $ch_scale->configure(-to => $max_canvas_height);
                            },
            ))->g_grid(-row => $row, -column => 4, -sticky => 'sw', -padx => 2, -pady => 2);
    if (&max($ch, $sh) == $max_canvas_height) {
        $ch_minus_btn->configure(-state => 'disabled');
    }

    $row++;
    ($grid_scale = $f->new_scale(
            -orient       => 'horizontal',
            -from         => $grid_spacing_min,
            -to           => $grid_spacing_max,
            -variable     => \$gs,
            -width        => 10,
            -sliderlength => 20,
            -takefocus    => 1,
            -command      => sub { $sw = &round_to_int(($screen_width -$min_canvas_width) /$gs) *$gs
                                         +$min_canvas_width;
                                   $sh = &round_to_int(($screen_height -$min_canvas_height)/$gs) *$gs
                                         +$min_canvas_height;
                                   if (abs($max_canvas_width -$sw) <= $gs) {
                                       $max_canvas_width = &max($cw, $sw);
                                   } else {
                                       $max_canvas_width = &max($cw, $max_canvas_width, $sw);
                                   }
                                   if (abs($max_canvas_height -$sh) <= $gs) {
                                       $max_canvas_height = &max($ch, $sh);
                                   } else {
                                       $max_canvas_height = &max($ch, $max_canvas_height, $sh);
                                   }
                                   $cw_scale->configure(-to         => $max_canvas_width,
                                                        -resolution => $gs);
                                   $ch_scale->configure(-to         => $max_canvas_height,
                                                        -resolution => $gs);
                                   if (&max($ch, $sh) == $max_canvas_height) {
                                       $ch_minus_btn->configure(-state => 'disabled');
                                   } else {
                                       $ch_minus_btn->configure(-state => 'normal');
                                   }
                                   if (&max($cw, $sw) == $max_canvas_width) {
                                       $cw_minus_btn->configure(-state => 'disabled');
                                   } else {
                                       $cw_minus_btn->configure(-state => 'normal');
                                   }
                                 },
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $f->new_checkbutton(
            -onvalue  => 1,
            -offvalue => 0,
            -text     => "Snap to Grid: ",
            -font     => 'default',
            -variable => \$s2g,
            -command  => sub { if ($s2g) {
                                   $sw = &round_to_int(($screen_width -$min_canvas_width) /$gs) *$gs
                                         +$min_canvas_width;
                                   $sh = &round_to_int(($screen_height -$min_canvas_height)/$gs) *$gs
                                         +$min_canvas_height;
                               } else {
                                   $sw = $screen_width;
                                   $sh = $screen_height;
                               }
                               if (abs($max_canvas_width -$sw) <= $gs) {
                                   $max_canvas_width = &max($cw, $sw);
                               } else {
                                   $max_canvas_width = &max($cw, $max_canvas_width, $sw);
                               }
                               if (abs($max_canvas_height -$sh) <= $gs) {
                                   $max_canvas_height = &max($ch, $sh);
                               } else {
                                   $max_canvas_height = &max($ch, $max_canvas_height, $sh);
                               }
                               if ($s2g) {
                                   $grid_scale->configure(-state => 'normal');
                                   $cw_scale->configure(-to         => $max_canvas_width,
                                                        -resolution => $gs);
                                   $ch_scale->configure(-to         => $max_canvas_height,
                                                        -resolution => $gs);
                               } else {
                                   $grid_scale->configure(-state => 'disabled');
                                   $cw_scale->configure(-to         => $max_canvas_width,
                                                        -resolution => 1);
                                   $ch_scale->configure(-to         => $max_canvas_height,
                                                        -resolution => 1);
                               }
                               if (&max($ch, $sh) == $max_canvas_height) {
                                   $ch_minus_btn->configure(-state => 'disabled');
                               } else {
                                   $ch_minus_btn->configure(-state => 'normal');
                               }
                               if (&max($cw, $sw) == $max_canvas_width) {
                                   $cw_minus_btn->configure(-state => 'disabled');
                               } else {
                                   $cw_minus_btn->configure(-state => 'normal');
                               }
                             }
            )->g_grid(-row => $row, -column => 0, -sticky => 'se', -pady => 2);
    $f->new_label(
            -text => "pixels",
            -font => 'default',
            )->g_grid(-row => $row, -column => 2, -sticky => 'sw', -padx => 2, -pady => 2);
    if ($s2g) {
        $grid_scale->configure(-state => 'normal');
        $cw_scale->configure(-resolution => $gs);
        $ch_scale->configure(-resolution => $gs);
    } else {
        $grid_scale->configure(-state => 'disabled');
        $cw_scale->configure(-resolution => 1);
        $ch_scale->configure(-resolution => 1);
    }

    $row++;
    $f->new_label(
            -text => "Canvas Background Color: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);

    $code = &get_rgb_code($cc);
    $cc   = &get_rgb_name($code);
    $fg   = &get_rgb_code("black");
    if ($code =~ /^\#[0-9a-f]/i) {
        $fg = &get_rgb_code(&get_bw_contrast($code));
    }
    $color_btn = $f->new_button(
            -textvariable => \$cc,
            -background   => $code,
            -foreground   => $fg,
            -width        => -7,
            -command => sub {
                          my ($newc, $code, $fg);
                          $code = &get_rgb_code($cc);
                          $newc = Tkx::tk___chooseColor(
                                     -initialcolor => $code,
                                     -parent       => $canvas_props_menu);
                          if ($newc) {
                            $code = &get_rgb_code($newc);
                            $cc   = &get_rgb_name($code);
                            $fg   = &get_rgb_code("black");
                            if ($code =~ /^#?[0-9a-f]/i) {
                                $fg = &get_rgb_code(&get_bw_contrast($code));
                            }
                            $color_btn->configure(-foreground => $fg,
                                                  -background => $code);
                          }
                        }
            );
    $color_btn->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Text Selection Color: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);

    $code = &get_rgb_code($sc);
    $sc   = &get_rgb_name($code);
    $fg   = &get_rgb_code("black");
    if ($code =~ /^\#[0-9a-f]/i) {
        $fg = &get_rgb_code(&get_bw_contrast($code));
    }
    $sel_color_btn = $f->new_button(
            -textvariable => \$sc,
            -background   => $code,
            -foreground   => $fg,
            -width        => -7,
            -command => sub {
                          my ($newc, $code, $fg);
                          $code = &get_rgb_code($sc);
                          $newc = Tkx::tk___chooseColor(
                                     -initialcolor => $code,
                                     -parent       => $canvas_props_menu);
                          if ($newc) {
                            $code = &get_rgb_code($newc);
                            $sc   = &get_rgb_name($code);
                            $fg   = &get_rgb_code("black");
                            if ($code =~ /^\#[0-9a-f]/i) {
                                $fg = &get_rgb_code(&get_bw_contrast($code));
                            }
                            $sel_color_btn->configure(-foreground => $fg,
                                                      -background => $code);
                          }
                        }
            );
    $sel_color_btn->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);

    Tkx::wm_resizable($canvas_props_menu,0,0);
    &adjust_window_position($canvas_props_menu);
    $canvas_props_menu->g_focus;
}


sub set_canvas_props {
    my ($cw, $ch, $s2g, $gs, $cc, $sc, $action) = @_;

    if ($cc ne $canvas_color) {
        $canvas->configure(-background => &get_rgb_code($cc));
        $canvas_color = $cc;
    }
    if ($cw != $canvas_width || $ch != $canvas_height) {
        $canvas->configure(-width        => $cw,
                           -height       => $ch,
                           -scrollregion => [0, 0, $cw, $ch],
                          );
        $canvas_width  = $cw;
        $canvas_height = $ch;
        &initialize_canvas_scrollbars();
        &adjust_main_position();
    }
    $snap2grid         = $s2g;
    $grid_spacing      = &min(&max($grid_spacing_min, $gs), $grid_spacing_max);
    $text_select_color = $sc;
    if ($action eq "OK") {
        $canvas_props_menu->g_destroy();
        undef $canvas_props_menu;
    }
}


sub edit_defaults {
    my ($X, $Y, $tabid) = @_;
    my (
        $ahd1, $ahd2, $ahd3, $angle, $angle_cb, $arrow, $arrow_frame,
        $arrow_opt, $arrow_tab, $code, $color, $f, $family, $family_cb,
        $fc_btn, $fcolor, $fg, $fg_btn, $fill, $fill_opt, $frame, $geom,
        $notebook, $object_frame, $object_tab, $ph, $pid_arrow, $pid_obj,
        $pid_txt, $preview_arrow, $preview_obj, $preview_txt, $pw, $row,
        $size, $size_cb, $slant, $slant_cb, $slant_opt, $smooth, $smooth_opt,
        $text_frame, $text_tab, $under, $under_cb, $under_opt, $weight,
        $weight_cb, $width,
       );

    $family = $default_family;
    $size   = $default_size;
    $weight = $default_weight;
    $slant  = $default_slant;
    $under  = $default_underline;
    $angle  = $default_angle;
    $width  = $default_width;
    $color  = $default_color;
    $fill   = $default_fill;
    $fcolor = $default_fillcolor;
    $arrow  = $default_arrow;
    $ahd1   = $default_ahd1;
    $ahd2   = $default_ahd2;
    $ahd3   = $default_ahd3;
    $smooth = $default_smooth;

    if ($X == 0) {
        (undef, $X, $Y) = split(/\+/, $main->g_wm_geometry());
        $X += 100;
        $Y += 100;
    }
    $geom       = sprintf("+%d+%d", $X, $Y);
    $slant_opt  = $slant_options[$slant];
    $under_opt  = ("no", "yes")[$under];
    $fill_opt   = ("no", "yes")[$fill];
    $smooth_opt = $smooth_options[$smooth];
    $arrow_opt  = $arrow_options[$arrow];

    if (defined($default_props_menu) && Tkx::winfo_exists($default_props_menu)) {
        if ($default_props_menu->g_wm_title() eq "Set Defaults") {
            $default_props_menu->g_wm_deiconify();
            $default_props_menu->g_wm_geometry($geom);
            $default_props_menu->g_raise();
            $default_props_menu->g_focus;
            &adjust_window_position($default_props_menu);
            return;
        }
    }

    $default_props_menu = $main->new_toplevel();
    $default_props_menu->g_wm_transient($main);
    $default_props_menu->g_wm_title("Set Defaults");
    $default_props_menu->configure(-cursor => $cursor_norm);
    $default_props_menu->g_wm_geometry($geom);

    $frame = $default_props_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    $frame->new_button(
            -text    => "OK",
            -command => sub { &set_defaults($family, $size, $weight,
                                $slant, $under, $angle, $width, $color, $smooth,
                                $fill, $fcolor, $arrow, $ahd1, $ahd2, $ahd3,
                                "OK") },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Apply",
            -command => sub { &set_defaults($family, $size, $weight,
                                $slant, $under, $angle, $width, $color, $smooth,
                                $fill, $fcolor, $arrow, $ahd1, $ahd2, $ahd3,
                                "Apply") },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Restore",
            -command => sub { my $tabid = $notebook->index('current');
                              my $geom  = $default_props_menu->g_wm_geometry();
                              (undef, $X, $Y) = split(/\+/, $geom);
                              &set_defaults($family, $size, $weight,
                                $slant, $under, $angle, $width, $color, $smooth,
                                $fill, $fcolor, $arrow, $ahd1, $ahd2, $ahd3,
                                "Restore", $X, $Y, $tabid) },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $default_props_menu->g_destroy();
                              undef $default_props_menu; },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

    $f = $default_props_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f->g_pack(-side => 'top');

#   Create tabbed notebook
    $notebook = $f->new_ttk__notebook();
    $notebook->g_pack();

#   Text tab
    $text_tab = $notebook->new_frame();
    $notebook->add($text_tab,
            -text      => "Text",
            -underline => 0,
            -sticky    => 'nsew',
            );

    $row = 0;
    $pw  = 270;
    $ph  = 45;
    $preview_txt = $text_tab->new_canvas(
            -background  => &get_rgb_code($canvas_color),
            -width       => $pw,
            -height      => $ph,
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $preview_txt->g_grid(-row => 0, -column => 0, -sticky => 'wne');

    $pid_txt = $preview_txt->create_text($pw*0.5 +3, $ph*0.5 +3,
            -anchor => 'center', 
            -text   => "Default text",
            -fill   => &get_rgb_code($color),
            -angle  => $angle,
            -font   => [-family     => $family,
                        -size       => $size,
                        -weight     => $weight,
                        -slant      => $slant_type[$slant],
                        -underline  => $under,
                        -overstrike => 0,
                       ]);

    $text_frame = $text_tab->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $text_frame->g_grid(-row => 1, -column => 0, -sticky => 'wnes');

    $text_frame->new_label(
            -text => "Default Font Family: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($family_cb = $text_frame->new_ttk__combobox(
            -textvariable => \$family,
            -values       => [ sort @available_fonts ],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $family_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_txt->itemconfigure($pid_txt,
                          -font => [ -family     => $family,
                                     -size       => $size,
                                     -weight     => $weight,
                                     -slant      => $slant_type[$slant],
                                     -underline  => $under,
                                     -overstrike => 0,
                                   ]);
                  });

    $row++;
    $text_frame->new_label(
            -text => "Default Font Size: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($size_cb = $text_frame->new_ttk__combobox(
            -textvariable => \$size,
            -values       => [(5 .. 32)],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $size_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_txt->itemconfigure($pid_txt,
                          -font => [ -family     => $family,
                                     -size       => $size,
                                     -weight     => $weight,
                                     -slant      => $slant_type[$slant],
                                     -underline  => $under,
                                     -overstrike => 0,
                                   ]);
                  });

    $row++;
    $text_frame->new_label(
            -text => "Default Font Weight: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($weight_cb = $text_frame->new_ttk__combobox(
            -textvariable => \$weight,
            -values       => [("normal", "bold")],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $weight_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_txt->itemconfigure($pid_txt,
                          -font => [ -family     => $family,
                                     -size       => $size,
                                     -weight     => $weight,
                                     -slant      => $slant_type[$slant],
                                     -underline  => $under,
                                     -overstrike => 0,
                                   ]);
                  });

    $row++;
    $text_frame->new_label(
            -text => "Default Font Slant: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($slant_cb = $text_frame->new_ttk__combobox(
            -textvariable => \$slant_opt,
            -values       => [ @slant_options ],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $slant_cb->g_bind("<<ComboboxSelected>>",
              sub { my $s = &list_match($slant_opt, @slant_options);
                    return if ($s < 0);
                    $slant = $s;
                    $preview_txt->itemconfigure($pid_txt,
                          -font => [ -family     => $family,
                                     -size       => $size,
                                     -weight     => $weight,
                                     -slant      => $slant_type[$slant],
                                     -underline  => $under,
                                     -overstrike => 0,
                                   ]);
                  });

    $row++;
    $text_frame->new_label(
            -text => "Default Font Underline: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($under_cb = $text_frame->new_ttk__combobox(
            -textvariable => \$under_opt,
            -values       => [("no", "yes")],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $under_cb->g_bind("<<ComboboxSelected>>",
              sub { my $u = &list_match($under_opt, ("no", "yes"));
                    return if ($u < 0);
                    $under = $u;
                    $preview_txt->itemconfigure($pid_txt,
                          -font => [ -family     => $family,
                                     -size       => $size,
                                     -weight     => $weight,
                                     -slant      => $slant_type[$slant],
                                     -underline  => $under,
                                     -overstrike => 0,
                                   ])
                  });

    $row++;
    $text_frame->new_label(
            -text => "Default Text Angle: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($angle_cb = $text_frame->new_ttk__combobox(
            -textvariable => \$angle,
            -values       => [(0 .. 359)],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $angle_cb->g_bind("<<ComboboxSelected>>",
              sub { $preview_txt->itemconfigure($pid_txt,
                          -text  => "Default text",
                          -angle => $angle);
                  });

#   Object tab
    $object_tab = $notebook->new_frame();
    $notebook->add($object_tab,
            -text      => "Objects",
            -underline => 0,
            -sticky    => 'nsew',
            );

    $row = 0;
    $preview_obj = $object_tab->new_canvas(
            -background  => &get_rgb_code($canvas_color),
            -width       => $pw,
            -height      => $ph,
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $preview_obj->g_grid(-row => 0, -column => 0, -sticky => 'wne');

    $pid_obj = $preview_obj->create_polygon($pw*0.2 + 3, $ph*0.2 + 3,
                                            $pw*0.8 + 3, $ph*0.2 + 3,
                                            $pw*0.8 + 3, $ph*0.8 + 3,
                                            $pw*0.2 + 3, $ph*0.8 + 3,
                 -outline => &get_rgb_code($color),
                 -smooth  => $smooth_type[$smooth],
                 -width   => $width);
    if ($fill) {
        $preview_obj->itemconfigure($pid_obj, -fill => &get_rgb_code($fcolor));
    } else {
        $preview_obj->itemconfigure($pid_obj, -fill => "");
    }

    $object_frame = $object_tab->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $object_frame->g_grid(-row => 1, -column => 0, -sticky => 'wnes');

    $object_frame->new_label(
            -text => "Default Object Width: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    &native_optionmenu(
            $object_frame, 
            \$width,
            $width - 1,
            [ sub { $preview_obj->itemconfigure($pid_obj, -width => $width);
                    $preview_arrow->itemconfigure($pid_arrow, -width => $width);
                  } ],
            (1 .. 10),
            )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    $row++;
    $object_frame->new_label(
            -text => "Default Color: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);

    $code  = &get_rgb_code($color);
    $color = &get_rgb_name($code);
    $fg    = &get_rgb_code("black");
    if ($code =~ /^\#[0-9a-f]/i) {
        $fg = &get_rgb_code(&get_bw_contrast($code));
    }
    $fg_btn = $object_frame->new_button(
            -textvariable => \$color,
            -background   => $code,
            -foreground   => $fg,
            -command => sub {
                          my ($newc, $code, $fg);
                          $code = &get_rgb_code($color);
                          $newc = Tkx::tk___chooseColor(
                                     -initialcolor => $code,
                                     -parent       => $default_props_menu);
                          if ($newc) {
                            $code  = &get_rgb_code($newc);
                            $color = &get_rgb_name($code);
                            $fg    = &get_rgb_code("black");
                            if ($code =~ /^\#[0-9a-f]/i) {
                                $fg = &get_rgb_code(&get_bw_contrast($code));
                            }
                            $fg_btn->configure(-foreground => $fg,
                                               -background => $code);
                            $preview_txt->itemconfigure($pid_txt,
                                               -fill => $code);
                            $preview_obj->itemconfigure($pid_obj,
                                               -outline => $code);
                            $preview_arrow->itemconfigure($pid_arrow,
                                               -fill => $code);
                          }
                        }
            );
    $fg_btn->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);

    $row++;
    $object_frame->new_label(
            -text => "Default Corners: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    &native_optionmenu(
            $object_frame, 
            \$smooth_opt,
            $smooth,
            [ sub { my $s = &list_match($smooth_opt, @smooth_options);
                    return if ($s < 0);
                    $smooth = $s;
                    $preview_obj->itemconfigure($pid_obj,
                                     -smooth => $smooth_type[$smooth]);
                  } ],
            @smooth_options,
            )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    $row++;
    $object_frame->new_label(
            -text => "Default Fill: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    &native_optionmenu(
            $object_frame, 
            \$fill_opt,
            $fill,
            [ sub { my $f = &list_match($fill_opt, ("no", "yes"));
                    return if ($f < 0);
                    $fill = $f;
                    if ($fill) {
                        $preview_obj->itemconfigure($pid_obj, -fill => &get_rgb_code($fcolor));
                        $fc_btn->configure(-state => 'normal');
                    } else {
                        $preview_obj->itemconfigure($pid_obj, -fill => "");
                        $fc_btn->configure(-state => 'disabled');
                    }
                  } ],
            ("no", "yes"),
            )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    $row++;
    $object_frame->new_label(
            -text => "Default Fill Color: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);

    $code   = &get_rgb_code($fcolor);
    $fcolor = &get_rgb_name($code);
    $fg     = &get_rgb_code("black");
    if ($code =~ /^\#[0-9a-f]/i) {
        $fg = &get_rgb_code(&get_bw_contrast($code));
    }
    $fc_btn = $object_frame->new_button(
            -textvariable => \$fcolor,
            -background   => $code,
            -foreground   => $fg,
            -command => sub {
                          my ($newc, $code, $fg);
                          $code = &get_rgb_code($fcolor);
                          $newc = Tkx::tk___chooseColor(
                                     -initialcolor => $code,
                                     -parent       => $default_props_menu);
                          if ($newc) {
                            $code   = &get_rgb_code($newc);
                            $fcolor = &get_rgb_name($code);
                            $fg     = &get_rgb_code("black");
                            if ($code =~ /^\#[0-9a-f]/i) {
                                $fg = &get_rgb_code(&get_bw_contrast($code));
                            }
                            $fc_btn->configure(-foreground => $fg,
                                               -background => $code);
                            if ($fill) {
                                $preview_obj->itemconfigure($pid_obj,
                                               -fill => $code);
                            }
                          }
                        }
            );
    $fc_btn->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
    if ($fill) {
        $fc_btn->configure(-state => 'normal');
    } else {
        $fc_btn->configure(-state => 'disabled');
    }

#   Arrowhead tab
    $arrow_tab = $notebook->new_frame();
    $notebook->add($arrow_tab,
            -text      => "Arrowheads",
            -underline => 0,
            -sticky    => 'nsew',
            );

    $row = 0;
    $preview_arrow = $arrow_tab->new_canvas(
            -background  => &get_rgb_code($canvas_color),
            -width       => $pw,
            -height      => $ph,
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $preview_arrow->g_grid(-row => 0, -column => 0, -sticky => 'wne');

    $pid_arrow = $preview_arrow->create_line($pw*0.2 + 3, $ph*0.5 + 3,
                                             $pw*0.8 + 3, $ph*0.5 + 3,
                 -fill  => &get_rgb_code($color),
                 -width => $width,
                 -arrow => $arrow_type[$arrow],
            -arrowshape => [ $ahd1, $ahd2, $ahd3 ]);

    $arrow_frame = $arrow_tab->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $arrow_frame->g_grid(-row => 1, -column => 0, -sticky => 'wnes');

    $arrow_frame->new_label(
            -text => "Default Arrowhead: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    &native_optionmenu(
            $arrow_frame, 
            \$arrow_opt,
            $arrow,
            [ sub { my $a = &list_match($arrow_opt, @arrow_options);
                    if ($a >= 0) {
                        $arrow = $a;
                        $preview_arrow->itemconfigure($pid_arrow,
                                             -arrow => $arrow_type[$arrow]);
                    }
                  } ],
            @arrow_options,
            )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    $row++;
    $arrow_frame->new_label(
            -text    => "Arrowhead  \nCenter Length: ",
            -justify => 'right',
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'se', -pady => 2);
    $arrow_frame->new_scale(
            -orient   => 'horizontal',
            -from     => 6,
            -to       => 100,
            -variable => \$ahd1,
            -width    => 10,
            -length   => 150,
            -sliderlength => 20,
            -takefocus    => 1,
            -command  => sub { $preview_arrow->itemconfigure($pid_arrow,
                                      -arrowshape => [ $ahd1, $ahd2, $ahd3 ]);
                             },
            )->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);

    $row++;
    $arrow_frame->new_label(
            -text    => "Arrowhead  \nSide Length: ",
            -justify => 'right',
            -font    => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'se', -pady => 2);
    $arrow_frame->new_scale(
            -orient   => 'horizontal',
            -from     => 10,
            -to       => 100,
            -variable => \$ahd2,
            -width    => 10,
            -sliderlength => 20,
            -takefocus    => 1,
            -command  => sub { $preview_arrow->itemconfigure($pid_arrow,
                                      -arrowshape => [ $ahd1, $ahd2, $ahd3 ]);
                             },
            )->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);

    $row++;
    $arrow_frame->new_label(
            -text    => "Arrowhead  \nHalf Width: ",
            -justify => 'right',
            -font    => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'se', -pady => 2);
    $arrow_frame->new_scale(
            -orient   => 'horizontal',
            -from     => 3,
            -to       => 40,
            -variable => \$ahd3,
            -width    => 10,
            -sliderlength => 20,
            -takefocus    => 1,
            -command  => sub { $preview_arrow->itemconfigure($pid_arrow,
                                      -arrowshape => [ $ahd1, $ahd2, $ahd3 ]);
                             },
            )->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);

    Tkx::ttk__notebook__enableTraversal($notebook);
    $notebook->select($tabid);
    Tkx::wm_resizable($default_props_menu,0,0);
    &adjust_window_position($default_props_menu);
    $default_props_menu->g_focus;
}


sub set_defaults {
    my ($fam, $siz, $wei, $sla, $und, $ang, $wid, $col, $smo, $fill, $fcol,
        $arr, $ahd1, $ahd2, $ahd3, $action, $X, $Y, $tabid) = @_;

    if ($action eq "Restore") {
        $default_family    = $save_family;
        $default_size      = $save_size;
        $default_weight    = $save_weight;
        $default_slant     = $save_slant;
        $default_underline = $save_underline;
        $default_angle     = $save_angle;
        $default_width     = $save_width;
        $default_color     = $save_color;
        $default_smooth    = $save_smooth;
        $default_fill      = $save_fill;
        $default_fillcolor = $save_fillcolor;
        $default_arrow     = $save_arrow;
        $default_ahd1      = $save_ahd1;
        $default_ahd2      = $save_ahd2;
        $default_ahd3      = $save_ahd3;
    } else {
        $default_family    = $fam;
        $default_size      = $siz;
        $default_weight    = $wei;
        $default_slant     = $sla;
        $default_underline = $und;
        $default_angle     = $ang;
        $default_width     = $wid;
        $default_color     = $col;
        $default_smooth    = $smo;
        $default_fill      = $fill;
        $default_fillcolor = $fcol;
        $default_arrow     = $arr;
        $default_ahd1      = $ahd1;
        $default_ahd2      = $ahd2;
        $default_ahd3      = $ahd3;
    }

    if ($action eq "OK" || $action eq "Restore") {
        $default_props_menu->g_destroy();
        undef $default_props_menu;
    }
    if ($action eq "Restore") {
        &edit_defaults($X, $Y, $tabid);
    }
}


################################################################################
#
# Specialized graphics
#
################################################################################

sub setup_w2_profile {
    my ($canv, $id) = @_;
    my (
        $bth_file, $bth_file_btn, $byear, $byear_cb, $con_file, $conv_add,
        $conv_add_entry, $conv_mult, $conv_mult_entry, $conv_type,
        $conv_type_cb, $conv_type_na_label, $cscheme, $cscheme_cb,
        $custom_frame, $elev_base, $f, $frame, $ftype, $geom, $gtitle, $i,
        $jb, $jd_skip, $jd_skip_active, $jd_skip_explain, $jd_skip_frame,
        $jd_skip_label, $jjw, $jw, $lcon_freq, $meta, $n, $nbr, $ncolors,
        $ncolors_cb, $ncolors_na_label, $new_graph, $nwb, $offset_frame, $ok,
        $ok_btn, $old_units, $oldparm, $oldparm_short, $oldsrc_type, $parm,
        $parm_cb, $parm_chars, $parm_div, $parm_div_cb, $parm_div_label,
        $parm_frame, $parm_short, $parms_ref, $row, $segnum, $segnum_cb,
        $segs_ref, $segwidth, $src_file, $src_file_btn, $src_file_label,
        $src_lines, $src_parm, $src_type, $src_type_cb, $tecplot, $title,
        $tmp_id, $tz_offset, $units, $units_cb, $units_entry, $wb_input_cb,
        $wb_input_label, $wb_txt, $X, $x1, $x2, $xmajor, $xmajor_entry,
        $xmax, $xmax_entry, $xmin, $xmin_entry, $Y, $y1, $y2, $yaxis_type,
        $yaxis_type_cb, $yaxis_units, $yaxis_units_label, $ymajor,
        $ymajor_entry, $ymajor_label, $ymax, $ymax_entry, $ymax_label,
        $ymin, $ymin_entry, $ymin_label, $ymin_units_label, $yr_max, $yr_min,

        @bs, @be, @cmaps, @cplf, @ds, @jbdn, @jd_skip_opts, @ncpl, @nspr,
        @nvpl, @parm_divlist, @parmlist, @segs, @slope, @sprf, @us, @vplf,
       );

    ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $geom = sprintf("+%d+%d", $X+$x1+30, $Y+$y1+50);

    if (defined($w2profile_setup_menu) && Tkx::winfo_exists($w2profile_setup_menu)) {
        if ($w2profile_setup_menu->g_wm_title() eq "W2 Profile Setup") {
            $w2profile_setup_menu->g_destroy();
            undef $w2profile_setup_menu;
        }
    }
    $w2profile_setup_menu = $main->new_toplevel();
    $w2profile_setup_menu->g_wm_transient($main);
    $w2profile_setup_menu->g_wm_title("W2 Profile Setup");
    $w2profile_setup_menu->configure(-cursor => $cursor_norm);
    $w2profile_setup_menu->g_wm_geometry($geom);

#   Try to keep the nascent graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

#   Retrieve parameter values if this graph already exists.
    $new_graph = (defined($props{$id}{oldcoords})) ? 0 : 1;
    if (! $new_graph) {
        &end_select($canv, $id, 1);

        $nwb   = $grid{$id}{nwb};
        $nbr   = $grid{$id}{nbr};
        @bs    = @{ $grid{$id}{bs}    };
        @be    = @{ $grid{$id}{be}    };
        @us    = @{ $grid{$id}{us}    };
        @ds    = @{ $grid{$id}{ds}    };
        @jbdn  = @{ $grid{$id}{jbdn}  };
        @slope = @{ $grid{$id}{slope} };
        @nspr  = @{ $grid{$id}{nspr}  };
        @sprf  = @{ $grid{$id}{sprf}  };
        @ncpl  = @{ $grid{$id}{ncpl}  };
        @cplf  = @{ $grid{$id}{cplf}  };
        @nvpl  = @{ $grid{$id}{nvpl}  };
        @vplf  = @{ $grid{$id}{vplf}  };

        $con_file    = $props{$id}{con_file};
        $src_type    = $props{$id}{src_type};
        $src_file    = $props{$id}{src_file};
        $src_lines   = $props{$id}{src_lines};
        $bth_file    = $props{$id}{bth_file};
        $parm        = $props{$id}{parm};
        $parm_div    = $props{$id}{parm_div};
        $units       = $props{$id}{parm_units};
        $conv_type   = $props{$id}{ctype};
        $segnum      = $props{$id}{seg};
        $byear       = $props{$id}{byear};
        $tz_offset   = $props{$id}{tz_offset};
        $jd_skip     = $props{$id}{jd_skip};

        $yaxis_type  = $gr_props{$id}{ytype};
        $yaxis_units = $gr_props{$id}{yunits};
        $ymin        = $gr_props{$id}{ymin};
        $ymax        = $gr_props{$id}{ymax};
        $ymajor      = $gr_props{$id}{ymajor};
        $gtitle      = $gr_props{$id}{gtitle};
        $ncolors     = $gr_props{$id}{ncolors};
        $elev_base   = &min($ymin, $ymax);

        if ($props{$id}{meta} eq "w2_profile_cmap") {
            $xmin   = $gr_props{$id}{cs_min};
            $xmax   = $gr_props{$id}{cs_max};
            $title  = $gr_props{$id}{keytitle};
        } else {
            $xmin   = $gr_props{$id}{xmin};
            $xmax   = $gr_props{$id}{xmax};
            $xmajor = $gr_props{$id}{xmajor};
            $title  = $gr_props{$id}{xtitle};
        }
        if ($gr_props{$id}{add_cs}) {
            if ($gr_props{$id}{cscheme1} =~ /CoolWarm|Turbo|Viridis/) {
                $cscheme  = $gr_props{$id}{cscheme1};
                $ncolors  = &max(8, &min(100, $ncolors));
            } elsif ($gr_props{$id}{cscheme1} eq "Blue" && $gr_props{$id}{cscheme2} eq "Orange") {
                $cscheme  = "Blue to Orange";
                $ncolors *= 2;
                $ncolors  = &max(16, &min(46, $ncolors));
                foreach $n (reverse @valid_nc) {
                    if ($ncolors >= 2 *$n) {
                        $ncolors = 2 *$n;
                        last;
                    }
                }
            } elsif ($gr_props{$id}{cscheme1} eq "Blue" && $gr_props{$id}{cscheme2} eq "Red") {
                $cscheme  = "Blue to Red";
                $ncolors *= 2;
                $ncolors  = &max(16, &min(46, $ncolors));
                foreach $n (reverse @valid_nc) {
                    if ($ncolors >= 2 *$n) {
                        $ncolors = 2 *$n;
                        last;
                    }
                }
            } else {
                $cscheme = "Blue to Orange";
                $ncolors = 20;
            }
        } else {
            $cscheme = "None";
            $ncolors = 20;
        }
        if ($conv_type =~ /Custom/) {
            ($conv_type, $conv_mult, $conv_add) = split(/,/, $conv_type);
        } else {
            $conv_mult = 1.0;
            $conv_add  = 0.0;
        }

        if ($src_type =~ /Spreadsheet/i) {
            ($ok, undef, $segs_ref, $parms_ref)
                      = &scan_w2_spr_file($w2profile_setup_menu, $src_file, "");
            if ($ok ne "okay") {
                return &pop_up_error($w2profile_setup_menu,
                                     "The specified file is not a W2 Spreadsheet file:\n$src_file");
            }
            @parmlist = @{ $parms_ref };
            @segs     = @{ $segs_ref  };
            $segnum   = $segs[$#segs] if ($segnum eq "" || &list_match($segnum, @segs) == -1);

        } elsif ($src_type =~ /Contour/i) {
            ($tecplot, undef, $jw, $parms_ref, undef, undef)
                  = &scan_w2_cpl_file($w2profile_setup_menu, $src_file, $id, 0, "");
            if ($tecplot == -1) {
                return &pop_up_error($w2profile_setup_menu,
                                     "The specified file is not a W2 Contour file:\n$src_file");
            }
            if ($tecplot == 1 && $jw == 0) {   # Tecplot-type file; waterbody index unknown
                for ($jjw=1; $jjw<=$nwb; $jjw++) {
                    if ($segnum >= $us[$bs[$jjw]] && $segnum <= $ds[$be[$jjw]]) {
                        $jw = $jjw;
                        last;
                    }
                }
            }
            @segs = ();
            for ($jb=$bs[$jw]; $jb<=$be[$jw]; $jb++) {
                push (@segs, ($us[$jb] .. $ds[$jb]));
            }
            $segnum   = $ds[$jbdn[$jw]] if ($segnum eq "" || &list_match($segnum, @segs) == -1);
            @parmlist = @{ $parms_ref };

        } elsif ($src_type =~ /Vector/i) {
            ($ok, $parms_ref, undef, undef, undef)
                      = &scan_w2_vector_file($w2profile_setup_menu, $src_file, $id, 0);
            if ($ok ne "okay") {
                return &pop_up_error($w2profile_setup_menu,
                                     "The specified file is not a W2 Vector (w2l) file:\n$src_file");
            }
            @segs = ();
            for ($jb=1; $jb<=$nbr; $jb++) {
                push (@segs, ($us[$jb] .. $ds[$jb]));
            }
            $segnum   = $ds[$jbdn[1]] if ($segnum eq "" || &list_match($segnum, @segs) == -1);
            @parmlist = @{ $parms_ref };

        } elsif ($src_type =~ /LakeCon/i) {
            ($ftype, $src_parm, $meta, undef) = &scan_w2_rlcon_file($w2profile_setup_menu, $src_file, "");
            if ($ftype ne "lcon1") {
                return &pop_up_error($w2profile_setup_menu,
                                     "The specified file is not an acceptable\n"
                                   . "W2 Lake Contour (format 1) file:\n$src_file");
            }
            ($segnum, $lcon_freq) = split(/_/, $meta);
            @segs     = ($segnum);
            @parmlist = ($src_parm);
        }
        @segs     = sort numerically @segs;
        $segwidth = &max(5, length(&max(@segs)));
        $wb_txt   = "";
        for ($jw=1; $jw<=$nwb; $jw++) {
            for ($jb=$bs[$jw]; $jb<=$be[$jw]; $jb++) {
                if ($segnum >= $us[$jb] && $segnum <= $ds[$jb]) {
                    $wb_txt = " (waterbody $jw, branch $jb)";
                    last;
                }
            }
            last if ($wb_txt ne "");
        }
        $parm_chars = length($parmlist[0]);
        for ($i=1; $i<=$#parmlist; $i++) {
            $parm_chars = &max($parm_chars, length($parmlist[$i]));
        }
        $parm_chars += 2;
        $parm_short = $parm;
        if ($parm ne "Temperature") {
            $parm_short =~ s/\(ms-1\)//i;
            $parm_short =~ s/\(m3s-1\)//i;
            $parm_short =~ s/ [kmu]?g\/L\/day//i;
            $parm_short =~ s/ [kmu]?g\/m2\/day//i;
            $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
            $parm_short =~ s/ [kmu]?g\/L//i;
            $parm_short =~ s/ [kmu]?g\/m3//i;
            $parm_short =~ s/ [kmu]?g\/m\^3//i;
            $parm_short =~ s/, days//i;
            $parm_short =~ s/ days//i;
            $parm_short =~ s/,$//;
        }
        @parm_divlist = ("None");
        for ($i=0; $i<=$#parmlist; $i++) {
            next if ($parmlist[$i] eq "Horizontal Velocity"
                      || $parmlist[$i] eq "Vertical Velocity"
                      || $parmlist[$i] eq "Horizontal Layer Flow"
                      || $parmlist[$i] eq "Density"
                      || $parmlist[$i] eq "Habitat");
            if ($parm ne $parmlist[$i]) {
                push (@parm_divlist, $parmlist[$i]);
            }
        }
        $parm_div = "None" if (&list_match($parm_div, @parm_divlist) == -1);

        $jd_skip_active = 0;
        if ($src_type =~ /Spreadsheet/i) {
            for ($i=1; $i<=$nspr[$jw]; $i++) {
                if ($sprf[$i][$jw] < 1.0) {
                    $jd_skip_active = 1;
                    last;
                }
            }
        } elsif ($src_type =~ /Contour/i) {
            for ($i=1; $i<=$ncpl[$jw]; $i++) {
                if ($cplf[$i][$jw] < 1.0) {
                    $jd_skip_active = 1;
                    last;
                }
            }
        } elsif ($src_type =~ /Vector/i) {
            for ($i=1; $i<=$nvpl[$jw]; $i++) {
                if ($vplf[$i][$jw] < 1.0) {
                    $jd_skip_active = 1;
                    last;
                }
            }
        } elsif ($src_type =~ /LakeCon/i) {
            $jd_skip_active = 1 if ($lcon_freq < 1.0);
        }

#   New graph
    } else {
        $src_file        = $bth_file = $con_file = $src_type = "";
        $src_lines       = 0;
        $tecplot         = 0;
        $jd_skip         = 0;
        $tz_offset       = "+00:00";
        $yaxis_units     = "feet";
        $yaxis_type      = "Elevation";
        $elev_base       = -999;
        $parm            = "Unknown";
        $parm_short      = $parm;
        @parmlist        = ();
        $parmlist[0]     = $parm;
        $parm_chars      = length($parm) +2;
        $parm_div        = "None";
        @parm_divlist    = ();
        $parm_divlist[0] = $parm_div;
        @segs            = ();
        $segnum          = "";
        $segwidth        = 5;
        $wb_txt          = "";
        $units           = "";
        $cscheme         = "Blue to Orange";
        $ncolors         = 20;
        $jd_skip_active  = 0;
        $conv_type       = $conv_types[0];
        $conv_mult       = 1.0;
        $conv_add        = 0.0;

        $nwb = $jw = 1;

        $byear = (localtime(time))[5] +1900;
        $ymin  = $ymax   = $ymajor = "";
        $xmin  = $xmax   = $xmajor = "";
        $title = $gtitle = "";
    }
    $tmp_id        = -1 *$id;
    $grid{$tmp_id} = $grid{$id};   # temporary, in case new control file is read
    $oldsrc_type   = $src_type;
    $oldparm       = $parm;
    $oldparm_short = $parm_short;
    $old_units     = $units;
    $yr_max        = (localtime(time))[5] +1900;
    $yr_min        = ($byear > $yr_max -25) ? $yr_max -25 : $byear -5;

    @jd_skip_opts = ("(keep all)", "(keep every other)", "(keep every 3rd)", "(keep every 4th)",
                     "(keep every 5th)",  "(keep every 6th)",  "(keep every 7th)",  "(keep every 8th)",
                     "(keep every 9th)",  "(keep every 10th)", "(keep every 11th)", "(keep every 12th)",
                     "(keep every 13th)", "(keep every 14th)", "(keep every 15th)", "(keep every 16th)",
                     "(keep every 17th)", "(keep every 18th)", "(keep every 19th)", "(keep every 20th)",
                     "(keep every 21st)", "(keep every 22nd)", "(keep every 23rd)", "(keep every 24th)",
                     "(keep every 25th)", "(keep every 26th)", "(keep every 27th)", "(keep every 28th)",
                     "(keep every 29th)", "(keep every 30th)", "(keep every 31st)", "(keep every 32nd)",
                     "(keep every 33rd)", "(keep every 34th)", "(keep every 35st)", "(keep every 36th)",
                     "(keep every 37th)", "(keep every 38th)", "(keep every 39th)", "(keep every 40th)",
                     "(keep every 41st)", "(keep every 42nd)", "(keep every 43rd)", "(keep every 44th)",
                     "(keep every 45th)", "(keep every 46th)", "(keep every 47th)", "(keep every 48th)",
                     "(keep every 49th)", "(keep every 50th)");
    $jd_skip = 0 if ($jd_skip < 0 || $jd_skip > 49);
    $jd_skip_explain = $jd_skip_opts[$jd_skip];

#   Available initial colormaps
    @cmaps = ("None", "Blue to Orange", "Blue to Red", "CoolWarm", "Turbo", "Viridis");
    shift @cmaps if ($props{$id}{meta} eq "w2_profile_cmap");

    $frame = $w2profile_setup_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -state   => ($new_graph) ? 'disabled' : 'normal',
            -command => sub { my ($confirm_type, %parms);
                              %parms = ();
                              if ($src_type =~ /Spreadsheet/i) {
                                  if ($src_file eq "" || ! -e $src_file) {
                                      return &pop_up_error($w2profile_setup_menu,
                                      "W2 Spreadsheet file not set or does not exist:\n$src_file");
                                  }
                              } elsif ($src_type =~ /Contour/i) {
                                  if ($src_file eq "" || ! -e $src_file) {
                                      return &pop_up_error($w2profile_setup_menu,
                                      "W2 Contour file not set or does not exist:\n$src_file");
                                  }
                              } elsif ($src_type =~ /Vector/i) {
                                  if ($src_file eq "" || ! -e $src_file) {
                                      return &pop_up_error($w2profile_setup_menu,
                                      "W2 Vector (w2l) file not set or does not exist:\n$src_file");
                                  }
                              } elsif ($src_type =~ /LakeCon/i) {
                                  if ($src_file eq "" || ! -e $src_file) {
                                      return &pop_up_error($w2profile_setup_menu,
                                      "W2 Lake Contour file not set or does not exist:\n$src_file");
                                  }
                              }
                              $confirm_type = &confirm_w2_ftype($w2profile_setup_menu, $src_file);
                              if ($src_type =~ /Spreadsheet/i && $confirm_type ne "spr") {
                                  return &pop_up_error($w2profile_setup_menu,
                                      "The W2 source file is not a W2 Spreadsheet file:\n$src_file");
                              } elsif ($src_type =~ /Contour/i && $confirm_type ne "cpl") {
                                  return &pop_up_error($w2profile_setup_menu,
                                      "The W2 source file is not a W2 Contour file:\n$src_file");
                              } elsif ($src_type =~ /Vector/i && $confirm_type ne "w2l") {
                                  return &pop_up_error($w2profile_setup_menu,
                                      "The W2 source file is not a W2 Vector (w2l) file:\n$src_file");
                              } elsif ($src_type =~ /LakeCon/i && $confirm_type ne "lcon1") {
                                  return &pop_up_error($w2profile_setup_menu,
                                      "The W2 source file is not an acceptable\n"
                                    . "W2 Lake Contour (format 1) file:\n$src_file");
                              }
                              if ($bth_file eq "" || ! -e $bth_file) {
                                  return &pop_up_error($w2profile_setup_menu,
                                      "W2 Bathymetry file not set or does not exist:\n$bth_file");
                              }
                              if ($xmin eq "" || $xmax eq "") {
                                  return &pop_up_error($w2profile_setup_menu,
                                  "Please provide both a min and max for your parameter.");
                              }
                              if ($xmin >= $xmax) {
                                  return &pop_up_error($w2profile_setup_menu,
                                  "The minimum data value must be less than the maximum data value.");
                              }
                              if ($yaxis_type eq "Elevation") {
                                  if ($ymin eq "" || $ymax eq "") {
                                      return &pop_up_error($w2profile_setup_menu,
                                      "Please provide both a min and max elevation.");
                                  }
                                  if ($ymin >= $ymax) {
                                      return &pop_up_error($w2profile_setup_menu,
                                      "The minimum elevation must be less than the maximum elevation.");
                                  }
                              } else {
                                  if ($ymax eq "") {
                                      return &pop_up_error($w2profile_setup_menu,
                                      "Please provide a maximum depth.");
                                  }
                              }
                              if ($segnum eq "" || $segnum <= 0) {
                                  return &pop_up_error($w2profile_setup_menu,
                                  "W2 segment number must be numeric and positive.");
                              }
                              if ($conv_type eq "Custom") {
                                  $conv_type = sprintf("Custom,%s,%s", $conv_mult, $conv_add);
                              }
                              $gtitle =~ s/^\s+//;
                              $gtitle =~ s/\s+$//;

#                             Delete reference dataset if different control file, seg, parm, or units
                              if (! $new_graph && defined($props{$id}{ref_file})
                                   && ($con_file  ne $props{$id}{con_file} ||
                                       $segnum    != $props{$id}{seg} ||
                                       $parm      ne $props{$id}{parm} ||
                                       $parm_div  ne $props{$id}{parm_div} ||
                                       $units     ne $props{$id}{parm_units} ||
                                       $conv_type ne $props{$id}{ctype})) {
                                  undef $props{$id}{ref_file};
                                  undef $gr_props{$id}{ref_data};
                              }

#                             Rebuild the dates array if different segment, jd_skip, or byear
                              if (! $new_graph) {
                                  $parms{rebuild} = ($props{$id}{meta} eq "w2_profile" &&
                                                     ($con_file  ne $props{$id}{con_file}  ||
                                                      $src_file  ne $props{$id}{src_file}  ||
                                                      $segnum    != $props{$id}{seg}       ||
                                                      $byear     != $props{$id}{byear}     ||
                                                      $tz_offset ne $props{$id}{tz_offset} ||
                                                      $jd_skip   != $props{$id}{jd_skip})) ? 1 : 0;
                                  $parms{change} = "all";
                              }
                              $parms{xmin}       = $xmin;
                              $parms{xmax}       = $xmax;
                              $parms{xmajor}     = $xmajor;
                              $parms{ymin}       = $ymin;
                              $parms{ymax}       = $ymax;
                              $parms{ymajor}     = $ymajor;
                              $parms{ytype}      = $yaxis_type;
                              $parms{yunits}     = $yaxis_units;
                              $parms{cscheme}    = $cscheme;
                              $parms{ncolors}    = $ncolors;
                              $parms{gtitle}     = $gtitle;
                              $props{$id}{parms} = { %parms };

                              $props{$id}{files}      = 1;
                              $props{$id}{data}       = 0;
                              $props{$id}{con_file}   = $con_file;
                              $props{$id}{bth_file}   = $bth_file;
                              $props{$id}{src_type}   = $src_type;
                              $props{$id}{src_file}   = $src_file;
                              $props{$id}{src_lines}  = $src_lines;
                              $props{$id}{tplot}      = $tecplot;
                              $props{$id}{parm}       = $parm;
                              $props{$id}{parm_div}   = $parm_div;
                              $props{$id}{parm_units} = $units;
                              $props{$id}{ctype}      = $conv_type;
                              $props{$id}{seg}        = $segnum;
                              $props{$id}{byear}      = $byear;
                              $props{$id}{tz_offset}  = $tz_offset;
                              $props{$id}{jd_skip}    = $jd_skip;

                              $grid{$id} = $grid{$tmp_id};
                              delete $grid{$tmp_id};

                              $w2profile_setup_menu->g_bind('<Destroy>', "");
                              $w2profile_setup_menu->g_destroy();
                              undef $w2profile_setup_menu;
                              &reset_bindings;
                              &make_w2_profile($canv, $id, 0);
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $w2profile_setup_menu->g_bind('<Destroy>', "");
                              $w2profile_setup_menu->g_destroy();
                              undef $w2profile_setup_menu;
                              if ($new_graph) {
                                  $canv->delete("graph" . $id);
                                  delete $props{$id};
                              }
                              delete $grid{$tmp_id} if (defined($grid{$tmp_id}));
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Delete graph if this menu is destroyed by other than the Cancel button
    $w2profile_setup_menu->g_bind('<Destroy>' => sub { undef $w2profile_setup_menu;
                                                       if ($new_graph) {
                                                           $canv->delete("graph" . $id);
                                                           delete $props{$id}; 
                                                       }
                                                       delete $grid{$tmp_id} if (defined($grid{$tmp_id}));
                                                       &reset_bindings;
                                                     });

    $f = $w2profile_setup_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "W2 Control File: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$con_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);
    $f->new_button(
            -text    => "Browse",
            -command => sub { my ($file, $segwidth);
                              $file = Tkx::tk___getOpenFile(
                                      -parent           => $w2profile_setup_menu,
                                      -title            => "Select W2 Control File",
                                      -initialdir       => abs_path(),
                                      -filetypes => [ ['All Files',  '*'],
                                                      ['CSV (comma delimited)', '.csv'],
                                                      ['NPT (W2 input file)', '.npt'],
                                                    ],
                                      );
                              if (defined($file) && -e $file) {
                                  $con_file = File::Spec->rel2abs($file);
                                  &read_con($main, $tmp_id, $con_file);

                                  $nbr   = $grid{$tmp_id}{nbr};
                                  $nwb   = $grid{$tmp_id}{nwb};
                                  @bs    = @{ $grid{$tmp_id}{bs}    };
                                  @be    = @{ $grid{$tmp_id}{be}    };
                                  @us    = @{ $grid{$tmp_id}{us}    };
                                  @ds    = @{ $grid{$tmp_id}{ds}    };
                                  @jbdn  = @{ $grid{$tmp_id}{jbdn}  };
                                  @slope = @{ $grid{$tmp_id}{slope} };
                                  @nspr  = @{ $grid{$tmp_id}{nspr}  };
                                  @sprf  = @{ $grid{$tmp_id}{sprf}  };
                                  @ncpl  = @{ $grid{$tmp_id}{ncpl}  };
                                  @cplf  = @{ $grid{$tmp_id}{cplf}  };
                                  @nvpl  = @{ $grid{$tmp_id}{nvpl}  };
                                  @vplf  = @{ $grid{$tmp_id}{vplf}  };
                                  $byear = $grid{$tmp_id}{byear};

                                  @segs = ();
                                  for ($jb=1; $jb<=$nbr; $jb++) {
                                      push (@segs, ($us[$jb] .. $ds[$jb]));
                                  }
                                  $segwidth = &max(5, length(&max(@segs)));
                                  $segnum_cb->configure(-values => [ @segs ],
                                                        -width  => $segwidth,
                                                        -state  => 'readonly');
                                  $segnum = $ds[$jbdn[1]];
                                  $wb_txt = "";
                                  for ($jw=1; $jw<=$nwb; $jw++) {
                                      for ($jb=$bs[$jw]; $jb<=$be[$jw]; $jb++) {
                                          if ($segnum >= $us[$jb] && $segnum <= $ds[$jb]) {
                                              $wb_txt = " (waterbody $jw, branch $jb)";
                                              last;
                                          }
                                      }
                                      last if ($wb_txt ne "");
                                  }
                                  if ($byear <= $yr_min) {
                                      $yr_min = $byear -5;
                                      $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                  }
                                  $byear_cb->configure(-state => 'readonly');
                                  $src_type_cb->configure(-state => 'readonly');
                              } else {
                                  $con_file = $segnum = $wb_txt = "";
                                  @segs = ();
                                  $segnum_cb->configure(-values => [ @segs ],
                                                        -state  => 'disabled');
                                  $src_type_cb->configure(-state => 'disabled');
                                  $byear_cb->configure(-state => 'disabled');
                              }
                              $bth_file = $src_file = $src_type = $oldsrc_type = "";
                              $title    = $gtitle   = $units    = $old_units   = "";
                              $parm            = "Unknown";
                              $oldparm         = $parm;
                              $parm_short      = $parm;
                              $oldparm_short   = $parm;
                              @parmlist        = ();
                              $parmlist[0]     = $parm;
                              $parm_chars      = length($parm) +2;
                              $parm_div        = "None";
                              @parm_divlist    = ();
                              $parm_divlist[0] = $parm_div;
                              $parm_cb->configure(-values => [ @parmlist ],
                                                  -width  => $parm_chars);
                              $parm_div_cb->configure(-values => [ @parm_divlist ],
                                                      -width  => $parm_chars);
                              $units_cb->g_grid_remove();
                              $units_entry->g_grid();
                              $conv_type_na_label->g_grid_remove();
                              $custom_frame->g_grid() if ($conv_type eq "Custom");
                              $conv_type_cb->g_grid();
                              $src_file_label->configure(-text => "W2 Output File: ");
                              $src_file_btn->configure(-state => 'disabled');
                              $bth_file_btn->configure(-state => 'disabled');
                              $jd_skip_label->g_grid_remove();
                              $jd_skip_frame->g_grid_remove();
                              $ok_btn->configure(-state => 'disabled');
                            }
            )->g_grid(-row => $row, -column => 4, -sticky => 'ew', -padx => 2, -pady => 2);

    $row++;
    $f->new_label(
            -text => "W2 Source Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($src_type_cb = $f->new_ttk__combobox(
            -textvariable => \$src_type,
            -values       => [ ("W2 Spreadsheet File", "W2 Contour File",
                                "W2 Vector File", "W2 LakeCon File") ],
            -state        => ($new_graph) ? 'disabled' : 'readonly',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w', -pady => 2);
    $src_type_cb->g_bind("<<ComboboxSelected>>",
                          sub { my ($i);
                                return if ($src_type eq $oldsrc_type);
                                $oldsrc_type     = $src_type;
                                $src_file        = $title = $units = $old_units = "";
                                $parm            = "Unknown";
                                $oldparm         = $parm;
                                $parm_short      = $parm;
                                $oldparm_short   = $parm;
                                @parmlist        = ();
                                $parmlist[0]     = $parm;
                                $parm_chars      = length($parm) +2;
                                $parm_div        = "None";
                                @parm_divlist    = ();
                                $parm_divlist[0] = $parm_div;
                                $parm_cb->configure(-values => [ @parmlist ],
                                                    -width  => $parm_chars);
                                $parm_div_cb->configure(-values => [ @parm_divlist ],
                                                        -width  => $parm_chars);
                                $parm_div_label->g_pack_forget();
                                $parm_div_cb->g_pack_forget();
                                $units_cb->g_grid_remove();
                                $units_entry->g_grid();
                                $conv_type_na_label->g_grid_remove();
                                $custom_frame->g_grid() if ($conv_type eq "Custom");
                                $conv_type_cb->g_grid();
                                $ok_btn->configure(-state => 'disabled');

                                if ($src_type =~ /Spreadsheet|Contour|Vector|LakeCon/i) {
                                    $src_file_label->configure(-text => $src_type . ": ");
                                    $src_file_btn->configure(-state => 'normal');
                                    $bth_file_btn->configure(-state => 'normal');
                                    $jd_skip_active = 0;
                                    if ($src_type =~ /Spreadsheet/i) {
                                        for ($i=1; $i<=$nspr[$jw]; $i++) {
                                            if ($sprf[$i][$jw] < 1.0) {
                                                $jd_skip_active = 1;
                                                last;
                                            }
                                        }
                                    } elsif ($src_type =~ /Contour/i) {
                                        for ($i=1; $i<=$ncpl[$jw]; $i++) {
                                            if ($cplf[$i][$jw] < 1.0) {
                                                $jd_skip_active = 1;
                                                last;
                                            }
                                        }
                                    } elsif ($src_type =~ /Vector/i) {
                                        for ($i=1; $i<=$nvpl[$jw]; $i++) {
                                            if ($vplf[$i][$jw] < 1.0) {
                                                $jd_skip_active = 1;
                                                last;
                                            }
                                        }
                                    } elsif ($src_type =~ /LakeCon/i) {
                                        $jd_skip_active = 1;  # placeholder
                                    }
                                    if ($jd_skip_active) {
                                        $jd_skip = 0 if ($jd_skip < 0 || $jd_skip > 49);
                                        $jd_skip_explain = $jd_skip_opts[$jd_skip];
                                        $jd_skip_label->g_grid();
                                        $jd_skip_frame->g_grid();
                                    } else {
                                        $jd_skip_label->g_grid_remove();
                                        $jd_skip_frame->g_grid_remove();
                                    }
                                    if ($slope[$jb] > 0.0) {
                                        if ($src_type =~ /Spreadsheet/i) {
                                            return &pop_up_info($w2profile_setup_menu,
                                                    "Branch $jb has a nonzero slope.\n"
                                                  . "W2 spreadsheet outputs may not\n"
                                                  . "work well for nonzero branch slopes.\n"
                                                  . "Consider using the W2 Contour File\n"
                                                  . "or W2 Vector File output option.");
                                        } elsif ($src_type =~ /LakeCon/i) {
                                            return &pop_up_info($w2profile_setup_menu,
                                                    "Branch $jb has a nonzero slope.\n"
                                                  . "W2 Lake Contour outputs may not\n"
                                                  . "work well for nonzero branch slopes.\n"
                                                  . "Consider using the W2 Contour File\n"
                                                  . "or W2 Vector File output option.");
                                        }
                                    }
                                } else {
                                    $src_file_label->configure(-text => "W2 Output File: ");
                                    $src_file_btn->configure(-state => 'disabled');
                                    $bth_file_btn->configure(-state => 'disabled');
                                    $jd_skip_label->g_grid_remove();
                                    $jd_skip_frame->g_grid_remove();
                                    $bth_file = "";
                                }
                              });

    $row++;
    ($src_file_label = $f->new_label(
            -text => "W2 Output File: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$src_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);
    ($src_file_btn = $f->new_button(
            -text    => "Browse",
            -state   => ($new_graph) ? 'disabled' : 'normal',
            -command => sub { my ($confirm_type, $file, $i, $ok, $parms_ref,
                                  $pbar, $pbar_img, $pbar_win, $segs_ref, $segwidth);
                              $file = Tkx::tk___getOpenFile(
                                      -parent           => $w2profile_setup_menu,
                                      -title            => "Select $src_type",
                                   #  -initialdir       => abs_path(),
                                      -filetypes => [ ['All Files',  '*'],
                                                      ['CSV (comma delimited)', '.csv'],
                                                    ],
                                      );
                              if (defined($file) && -e $file) {
                                  $src_file        = File::Spec->rel2abs($file);
                                  $title           = $units = $old_units = "";
                                  $parm            = "Unknown";
                                  $oldparm         = $parm;
                                  $parm_short      = $parm;
                                  $oldparm_short   = $parm;
                                  @parmlist        = ();
                                  $parmlist[0]     = $parm;
                                  $parm_chars      = length($parm) +2;
                                  $parm_div        = "None";
                                  @parm_divlist    = ();
                                  $parm_divlist[0] = $parm_div;
                                  $parm_cb->configure(-values => [ @parmlist ],
                                                      -width  => $parm_chars);
                                  $parm_div_cb->configure(-values => [ @parm_divlist ],
                                                          -width  => $parm_chars);
                                  $units_cb->g_grid_remove();
                                  $units_entry->g_grid();
                                  $conv_type_na_label->g_grid_remove();
                                  $custom_frame->g_grid() if ($conv_type eq "Custom");
                                  $conv_type_cb->g_grid();
                                  $wb_input_label->g_grid_remove();
                                  $wb_input_cb->g_grid_remove();

                                  $confirm_type = &confirm_w2_ftype($w2profile_setup_menu, $src_file);
                                  if ($src_type =~ /Spreadsheet/i && $confirm_type ne "spr") {
                                      $src_file = "";
                                      $ok_btn->configure(-state => 'disabled');
                                      return &pop_up_error($w2profile_setup_menu,
                                          "The specified file is not a W2 Spreadsheet file:\n$file");
                                  } elsif ($src_type =~ /Contour/i && $confirm_type ne "cpl") {
                                      $src_file = "";
                                      $ok_btn->configure(-state => 'disabled');
                                      return &pop_up_error($w2profile_setup_menu,
                                          "The specified file is not a W2 Contour file:\n$file");
                                  } elsif ($src_type =~ /Vector/i && $confirm_type ne "w2l") {
                                      $src_file = "";
                                      $ok_btn->configure(-state => 'disabled');
                                      return &pop_up_error($w2profile_setup_menu,
                                          "The specified file is not a W2 Vector (w2l) file:\n$file");
                                  } elsif ($src_type =~ /LakeCon/i && $confirm_type ne "lcon1") {
                                      $src_file = "";
                                      $ok_btn->configure(-state => 'disabled');
                                      return &pop_up_error($w2profile_setup_menu,
                                          "The specified file is not an acceptable\n"
                                        . "W2 Lake Contour (format 1) file:\n$file");
                                  }
                                  if ($src_type =~ /Spreadsheet/i) {
                                      ($pbar_win, $pbar, $pbar_img)
                                          = &create_alt_progress_bar($main, $id,
                                                                     "Scanning W2 spreadsheet file...");
                                      ($ok, $src_lines, $segs_ref, $parms_ref)
                                          = &scan_w2_spr_file($w2profile_setup_menu, $src_file, $pbar_img);
                                      &destroy_progress_bar($main, $pbar_win);

                                      if ($ok ne "okay") {
                                          $src_file = "";
                                          $ok_btn->configure(-state => 'disabled');
                                          return &pop_up_error($w2profile_setup_menu,
                                              "The specified file is not a W2 Spreadsheet file:\n$file");
                                      }
                                      @parmlist = @{ $parms_ref };
                                      @segs     = @{ $segs_ref  };
                                      if ($segnum eq "" || &list_match($segnum, @segs) == -1) {
                                          $segnum = $segs[$#segs];
                                      }

                                  } elsif ($src_type =~ /Contour/i) {
                                      ($pbar_win, $pbar, $pbar_img)
                                          = &create_alt_progress_bar($main, $id,
                                                                     "Scanning W2 contour file...");
                                      ($tecplot, $src_lines, $jw, $parms_ref, undef, undef)
                                          = &scan_w2_cpl_file($w2profile_setup_menu,
                                                              $src_file, $tmp_id, 0, $pbar_img);
                                      &destroy_progress_bar($main, $pbar_win);

                                      if ($tecplot == -1) {
                                          $src_file = "";
                                          $ok_btn->configure(-state => 'disabled');
                                          return &pop_up_error($w2profile_setup_menu,
                                              "The specified file is not a W2 Contour output file:\n$file");
                                      }
                                      @segs = ();
                                      if ($jw == 0) {
                                          for ($jb=1; $jb<=$nbr; $jb++) {
                                              push (@segs, ($us[$jb] .. $ds[$jb]));
                                          }
                                          $jw = 1;
                                          if ($nwb > 1) {
                                              $wb_input_label->g_grid();
                                              $wb_input_cb->g_grid();
                                          }
                                      } else {
                                          for ($jb=$bs[$jw]; $jb<=$be[$jw]; $jb++) {
                                              push (@segs, ($us[$jb] .. $ds[$jb]));
                                          }
                                      }
                                      if ($segnum eq "" || &list_match($segnum, @segs) == -1) {
                                          $segnum = $ds[$jbdn[$jw]];
                                      }
                                      @parmlist = @{ $parms_ref };

                                  } elsif ($src_type =~ /Vector/i) {
                                      $status_line = "Scanning W2 vector file...";  # no progress bar needed
                                      ($ok, $parms_ref, undef, undef, undef)
                                          = &scan_w2_vector_file($w2profile_setup_menu,
                                                                 $src_file, $tmp_id, 0);
                                      $status_line = "";

                                      if ($ok ne "okay") {
                                          $src_file = "";
                                          $ok_btn->configure(-state => 'disabled');
                                          return &pop_up_error($w2profile_setup_menu,
                                              "The specified file is not a W2 Vector (w2l) file:\n$file");
                                      }
                                      @segs = ();
                                      for ($jb=1; $jb<=$nbr; $jb++) {
                                          push (@segs, ($us[$jb] .. $ds[$jb]));
                                      }
                                      if ($segnum eq "" || &list_match($segnum, @segs) == -1) {
                                          $segnum = $ds[$jbdn[1]];
                                      }
                                      @parmlist = @{ $parms_ref };

                                  } elsif ($src_type =~ /LakeCon/i) {
                                      ($pbar_win, $pbar, $pbar_img)
                                          = &create_alt_progress_bar($main, $id,
                                                                     "Scanning W2 Lake Contour file...");
                                      ($ftype, $src_parm, $meta, $src_lines)
                                          = &scan_w2_rlcon_file($w2profile_setup_menu, $src_file, $pbar_img);
                                      &destroy_progress_bar($main, $pbar_win);

                                      if ($ftype ne "lcon1") {
                                          $src_file = "";
                                          $ok_btn->configure(-state => 'disabled');
                                          return &pop_up_error($w2profile_setup_menu,
                                              "The specified file is not an acceptable\n"
                                            . "W2 Lake Contour (format 1) file:\n$file");
                                      }
                                      ($segnum, $lcon_freq) = split(/_/, $meta);
                                      @segs     = ($segnum);
                                      @parmlist = ($src_parm);
                                      $jd_skip_active = ($lcon_freq < 1.0) ? 1 : 0;
                                      if ($jd_skip_active) {
                                          $jd_skip = 0 if ($jd_skip < 0 || $jd_skip > 49);
                                          $jd_skip_explain = $jd_skip_opts[$jd_skip];
                                          $jd_skip_label->g_grid();
                                          $jd_skip_frame->g_grid();
                                      } else {
                                          $jd_skip_label->g_grid_remove();
                                          $jd_skip_frame->g_grid_remove();
                                      }
                                  }
                                  @segs = sort numerically @segs;
                                  $segwidth = &max(5, length(&max(@segs)));
                                  $segnum_cb->configure(-values => [ @segs ],
                                                        -width  => $segwidth,
                                                        -state  => 'readonly');
                                  $wb_txt = "";
                                  for ($jw=1; $jw<=$nwb; $jw++) {
                                      for ($jb=$bs[$jw]; $jb<=$be[$jw]; $jb++) {
                                          if ($segnum >= $us[$jb] && $segnum <= $ds[$jb]) {
                                              $wb_txt = " (waterbody $jw, branch $jb)";
                                              last;
                                          }
                                      }
                                      last if ($wb_txt ne "");
                                  }
                                  $parm_chars = length($parmlist[0]);
                                  for ($i=1; $i<=$#parmlist; $i++) {
                                      $parm_chars = &max($parm_chars, length($parmlist[$i]));
                                  }
                                  $parm_chars += 2;
                                  $parm_cb->configure(-values => [ @parmlist ],
                                                      -width  => $parm_chars);
                                  if (&list_match($parm, @parmlist) == -1) {
                                      $parm = $parmlist[0];
                                      $parm =~ s/^\s+//;
                                      $parm =~ s/\s+$//;
                                  }
                                  $parm_short = $parm;
                                  if ($parm eq "Temperature") {
                                      $units = "Celsius" if ($units !~ /(Celsius|Fahrenheit)/);
                                      $title = "Temperature, in degrees " . $units;
                                      $units_cb->g_grid();
                                      $units_entry->g_grid_remove();
                                      $conv_type_na_label->g_grid();
                                      $custom_frame->g_grid_remove();
                                      $conv_type_cb->g_grid_remove();
                                      $conv_type = "None";
                                  } else {
                                      $units = "";
                                      $parm_short =~ s/\(ms-1\)//i;
                                      $parm_short =~ s/\(m3s-1\)//i;
                                      $parm_short =~ s/ [kmu]?g\/L\/day//i;
                                      $parm_short =~ s/ [kmu]?g\/m2\/day//i;
                                      $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
                                      $parm_short =~ s/ [kmu]?g\/L//i;
                                      $parm_short =~ s/ [kmu]?g\/m3//i;
                                      $parm_short =~ s/ [kmu]?g\/m\^3//i;
                                      $parm_short =~ s/, days//i;
                                      $parm_short =~ s/ days//i;
                                      $parm_short =~ s/,$//;
                                      if ($parm eq "Horizontal Velocity" || $parm eq "Vertical Velocity") {
                                          $units = "m/s";
                                          $title = $parm_short . ", in m/s";
                                      } elsif ($parm eq "Horizontal Layer Flow") {
                                          $units = "m3/s";
                                          $title = $parm_short . ", in m3/s";
                                      } elsif ($parm eq "Density") {
                                          $units = "kg/m3";
                                          $title = $parm_short . ", in kg/m3";
                                      } else {
                                          $title = $parm_short . ", in ";
                                      }
                                      $units_cb->g_grid_remove();
                                      $units_entry->g_grid();
                                      $conv_type_na_label->g_grid_remove();
                                      $custom_frame->g_grid() if ($conv_type eq "Custom");
                                      $conv_type_cb->g_grid();
                                  }
                                  if ($gtitle eq "") {
                                     if ($props{$id}{meta} eq "w2_profile_cmap") {
                                         $gtitle = ucfirst($parm_short) . " Colormap";
                                     } else {
                                         $gtitle = ucfirst($parm_short) . " Profile";
                                     }
                                  } else {
                                      if (index(lc($gtitle), lc($oldparm_short)) > -1) {
                                          $gtitle =~ s/$oldparm_short/$parm_short/i;
                                      }
                                  }
                                  $old_units     = $units;
                                  $oldparm       = $parm;
                                  $oldparm_short = $parm_short;
                                  @parm_divlist  = ("None");
                                  for ($i=0; $i<=$#parmlist; $i++) {
                                      next if ($parmlist[$i] eq "Horizontal Velocity"
                                               || $parmlist[$i] eq "Vertical Velocity"
                                               || $parmlist[$i] eq "Horizontal Layer Flow"
                                               || $parmlist[$i] eq "Density"
                                               || $parmlist[$i] eq "Habitat");
                                      if ($parm ne $parmlist[$i]) {
                                          push (@parm_divlist, $parmlist[$i]);
                                      }
                                  }
                                  $parm_div_cb->configure(-values => [ @parm_divlist ],
                                                          -width  => $parm_chars);
                                  if (&list_match($parm_div, @parm_divlist) == -1) {
                                      $parm_div = "None";
                                  }
                                  if ($parm eq "Temperature" || $parm eq "Horizontal Velocity"
                                        || $parm eq "Vertical Velocity" || $parm eq "Density"
                                        || $parm eq "Horizontal Layer Flow"
                                        || $parm eq "Habitat" || $#parm_divlist == 0) {
                                      $parm_div_label->g_pack_forget();
                                      $parm_div_cb->g_pack_forget();
                                      $parm_div = "None";
                                  } else {
                                      $parm_div_label->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                                      $parm_div_cb->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                                  }
                                  if ($bth_file ne "" && -e $bth_file) {
                                      $ok_btn->configure(-state => 'normal');
                                  }
                              } else {
                                  $ok_btn->configure(-state => 'disabled');
                              }
                            },
            ))->g_grid(-row => $row, -column => 4, -sticky => 'ew', -padx => 2, -pady => 2);

    $row++;
    $f->new_label(
            -text => "W2 Bathymetry File: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$bth_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);
    ($bth_file_btn = $f->new_button(
            -text    => "Browse",
            -state   => ($new_graph) ? 'disabled' : 'normal',
            -command => sub { my ($file);
                              $file = Tkx::tk___getOpenFile(
                                      -parent           => $w2profile_setup_menu,
                                      -title            => "Select W2 Bathymetry File",
                                   #  -initialdir       => abs_path(),
                                      -defaultextension => ".csv",
                                      -filetypes => [ ['CSV (comma delimited)', '.csv'],
                                                      ['NPT (W2 input file)', '.npt'],
                                                      ['All Files',  '*'],
                                                    ],
                                      );
                              if (defined($file) && -e $file) {
                                  $bth_file = File::Spec->rel2abs($file);
                                  if ($src_file ne "" && -e $src_file) {
                                      $ok_btn->configure(-state => 'normal');
                                  }
                              } else {
                                  $ok_btn->configure(-state => 'disabled');
                              }
                            },
            ))->g_grid(-row => $row, -column => 4, -sticky => 'ew', -padx => 2, -pady => 2);

    $row++;
    ($wb_input_label = $f->new_label(
            -text => "Waterbody: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($wb_input_cb = $f->new_ttk__combobox(
            -textvariable => \$jw,
            -values       => [ (1 .. $nwb) ],
            -state        => ($new_graph) ? 'disabled' : 'readonly',
            -width        => $segwidth,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $wb_input_cb->g_bind("<<ComboboxSelected>>",
                          sub { $wb_txt = "";
                                @segs   = ();
                                for ($jb=$bs[$jw]; $jb<=$be[$jw]; $jb++) {
                                    push (@segs, ($us[$jb] .. $ds[$jb]));
                                }
                                @segs = sort numerically @segs;
                                if ($segnum eq "" || &list_match($segnum, @segs) == -1) {
                                    $segnum = $ds[$jbdn[$jw]];
                                }
                                for ($jb=$bs[$jw]; $jb<=$be[$jw]; $jb++) {
                                    if ($segnum >= $us[$jb] && $segnum <= $ds[$jb]) {
                                        $wb_txt = " (waterbody $jw, branch $jb)";
                                        last;
                                    }
                                }
                                $segwidth = &max(5, length(&max(@segs)));
                                $segnum_cb->configure(-values => [ @segs ],
                                                      -width  => $segwidth);
                              });
    $wb_input_label->g_grid_remove();
    $wb_input_cb->g_grid_remove();

    $row++;
    $f->new_label(
            -text => "Segment: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($segnum_cb = $f->new_ttk__combobox(
            -textvariable => \$segnum,
            -values       => [ @segs ],
            -state        => ($new_graph) ? 'disabled' : 'readonly',
            -width        => $segwidth,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $segnum_cb->g_bind("<<ComboboxSelected>>",
                        sub { $wb_txt = "";
                              for ($jw=1; $jw<=$nwb; $jw++) {
                                  for ($jb=$bs[$jw]; $jb<=$be[$jw]; $jb++) {
                                      if ($segnum >= $us[$jb] && $segnum <= $ds[$jb]) {
                                          $wb_txt = " (waterbody $jw, branch $jb)";
                                          last;
                                      }
                                  }
                                  last if ($wb_txt ne "");
                              }
                            });
    $f->new_label(
            -textvariable => \$wb_txt,
            -anchor       => 'w',
            -font         => 'default',
            )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Base Year: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($byear_cb = $f->new_ttk__combobox(
            -textvariable => \$byear,
            -values       => [ reverse($yr_min .. $yr_max) ],
            -state        => ($new_graph) ? 'disabled' : 'readonly',
            -width        => 5,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $byear_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($byear == $yr_min) {
                                $yr_min -= 5;
                                $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                            }
                          });
    $f->new_label(
            -text   => " for JDAY = 1.0",
            -anchor => 'w',
            -font   => 'default',
            )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Time Offset: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($offset_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    $offset_frame->new_ttk__combobox(
            -textvariable => \$tz_offset,
            -values       => [ @tz_offsets ],
            -justify      => 'right',
            -state        => 'readonly',
            -width        => 6,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $offset_frame->new_label(
            -text   => " time zone adjustment ",
            -anchor => 'w',
            -font   => 'default',
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $offset_frame->new_button(
            -text    => "Help",
            -command => sub { &pop_up_info($w2profile_setup_menu,
                                    "The time offset allows the user to add or subtract a time\n"
                                  . "offset if the W2 model was run with a non-local time zone.\n\n"
                                  . "For example, if W2 was run in UTC but the local time zone\n"
                                  . "is PST, an offset of -08:00 would convert the model date/time\n"
                                  . "to a local standard time of PST. This offset does not make\n"
                                  . "any adjustments related to daylight saving time. In general,\n"
                                  . "W2 is best run in the local standard time.\n\n"
                                  . "Leave the time offset at +00:00 for no adjustment.",
                                    "Time Offset Notice");
                            },
            )->g_pack(-side => 'left', -anchor => 'w', -padx => 2);

    $row++;
    $f->new_label(
            -text => "Parameter: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($parm_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    ($parm_cb = $parm_frame->new_ttk__combobox(
            -textvariable => \$parm,
            -values       => [ @parmlist ],
            -state        => 'readonly',
            -width        => $parm_chars,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $parm_cb->g_bind("<<ComboboxSelected>>",
                         sub { my ($i);
                               return if ($parm eq $oldparm);
                               $parm_short = $parm;
                               if ($parm eq "Temperature") {
                                   $units = "Celsius" if ($units !~ /(Celsius|Fahrenheit)/);
                                   $title = "Temperature, in degrees " . $units;
                                   $units_cb->g_grid();
                                   $units_entry->g_grid_remove();
                                   $conv_type_na_label->g_grid();
                                   $custom_frame->g_grid_remove();
                                   $conv_type_cb->g_grid_remove();
                                   $conv_type = "None";
                               } else {
                                   $units = "";
                                   $parm_short =~ s/\(ms-1\)//i;
                                   $parm_short =~ s/\(m3s-1\)//i;
                                   $parm_short =~ s/ [kmu]?g\/L\/day//i;
                                   $parm_short =~ s/ [kmu]?g\/m2\/day//i;
                                   $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
                                   $parm_short =~ s/ [kmu]?g\/L//i;
                                   $parm_short =~ s/ [kmu]?g\/m3//i;
                                   $parm_short =~ s/ [kmu]?g\/m\^3//i;
                                   $parm_short =~ s/, days//i;
                                   $parm_short =~ s/ days//i;
                                   $parm_short =~ s/,$//;
                                   if ($parm eq "Horizontal Velocity" || $parm eq "Vertical Velocity") {
                                       $units = "m/s";
                                       $title = $parm_short . ", in m/s";
                                   } elsif ($parm eq "Horizontal Layer Flow") {
                                       $units = "m3/s";
                                       $title = $parm_short . ", in m3/s";
                                   } elsif ($parm eq "Density") {
                                       $units = "kg/m3";
                                       $title = $parm_short . ", in kg/m3";
                                   } else {
                                       $title = $parm_short . ", in ";
                                   }
                                   $units_cb->g_grid_remove();
                                   $units_entry->g_grid();
                                   $conv_type_na_label->g_grid_remove();
                                   $custom_frame->g_grid() if ($conv_type eq "Custom");
                                   $conv_type_cb->g_grid();
                               }
                               if ($gtitle eq "") {
                                  if ($props{$id}{meta} eq "w2_profile_cmap") {
                                      $gtitle = ucfirst($parm_short) . " Colormap";
                                  } else {
                                      $gtitle = ucfirst($parm_short) . " Profile";
                                  }
                               } else {
                                   if (index(lc($gtitle), lc($oldparm_short)) > -1) {
                                       $gtitle =~ s/$oldparm_short/$parm_short/i;
                                   }
                               }
                               $old_units     = $units;
                               $oldparm       = $parm;
                               $oldparm_short = $parm_short;
                               @parm_divlist  = ("None");
                               for ($i=0; $i<=$#parmlist; $i++) {
                                   next if ($parmlist[$i] eq "Horizontal Velocity"
                                            || $parmlist[$i] eq "Vertical Velocity"
                                            || $parmlist[$i] eq "Horizontal Layer Flow"
                                            || $parmlist[$i] eq "Density"
                                            || $parmlist[$i] eq "Habitat");
                                   if ($parm ne $parmlist[$i]) {
                                       push (@parm_divlist, $parmlist[$i]);
                                   }
                               }
                               $parm_div_cb->configure(-values => [ @parm_divlist ]);
                               if (&list_match($parm_div, @parm_divlist) == -1) {
                                   $parm_div = "None";
                               }
                               if ($parm eq "Temperature" || $parm eq "Horizontal Velocity"
                                       || $parm eq "Vertical Velocity" || $parm eq "Density"
                                       || $parm eq "Horizontal Layer Flow"
                                       || $parm eq "Habitat" || $#parm_divlist == 0) {
                                   $parm_div_label->g_pack_forget();
                                   $parm_div_cb->g_pack_forget();
                                   $parm_div = "None";
                               } else {
                                   $parm_div_label->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                                   $parm_div_cb->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                               }
                             });
    ($parm_div_label = $parm_frame->new_label(
            -text => " divided by ",
            -font => 'default',
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    ($parm_div_cb = $parm_frame->new_ttk__combobox(
            -textvariable => \$parm_div,
            -values       => [ @parm_divlist ],
            -state        => 'readonly',
            -width        => $parm_chars,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Conversion: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($conv_type_na_label = $f->new_label(
            -text => "n/a",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $conv_type_na_label->g_grid_remove();
    ($conv_type_cb = $f->new_ttk__combobox(
            -textvariable => \$conv_type,
            -values       => [ @conv_types ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $conv_type_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($conv_type eq "Custom") {
                                $custom_frame->g_grid();
                            } else {
                                $custom_frame->g_grid_remove();
                            }
                          }
                      );
    $row++;
    ($custom_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    $custom_frame->new_label(
            -text => "Multiply by: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_mult_entry = $custom_frame->new_entry(
            -textvariable => \$conv_mult,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_mult_entry->g_bind("<KeyRelease>",
                              sub { &numeric_entry_only($conv_mult_entry);
                                    my $chars = &max(7, length($conv_mult));
                                    $conv_mult_entry->configure(-width => $chars);
                                  });
    $custom_frame->new_label(
            -text => "  Then add: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_add_entry = $custom_frame->new_entry(
            -textvariable => \$conv_add,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_add_entry->g_bind("<KeyRelease>",
                             sub { &numeric_entry_only($conv_add_entry);
                                   my $chars = &max(7, length($conv_add));
                                   $conv_add_entry->configure(-width => $chars);
                                 });

    $row++;
    $f->new_label(
            -text => "Data Units: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($units_cb = $f->new_ttk__combobox(
            -textvariable => \$units,
            -values       => [ ("Celsius", "Fahrenheit") ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $units_cb->g_bind("<<ComboboxSelected>>",
                       sub { return if ($units eq $old_units);
                             $old_units = $units;
                             if ($units eq "Celsius") {
                                 if ($xmin ne "" && $xmin ne "." && $xmin ne "-") {
                                     $xmin = &floor(($xmin -32) /1.8);
                                 }
                                 if ($xmax ne "" && $xmax ne "." && $xmax ne "-") {
                                     $xmax = &ceil(($xmax  -32) /1.8);
                                 }
                                 if ($props{$id}{meta} eq "w2_profile") {
                                     if ($xmajor ne "" && $xmajor ne "." && $xmajor ne "-") {
                                         $xmajor = &round_to_int($xmajor /1.8);
                                     }
                                 }
                             } elsif ($units eq "Fahrenheit") {
                                 if ($xmin ne "" && $xmin ne "." && $xmin ne "-") {
                                     $xmin = &floor($xmin *1.8 +32);
                                 }
                                 if ($xmax ne "" && $xmax ne "." && $xmax ne "-") {
                                     $xmax = &ceil($xmax  *1.8 +32);
                                 }
                                 if ($props{$id}{meta} eq "w2_profile") {
                                     if ($xmajor ne "" && $xmajor ne "." && $xmajor ne "-") {
                                         $xmajor = &round_to_int($xmajor *1.8);
                                     }
                                 }
                             }
                             $title = "Temperature, in degrees " . $units;
                           });
    $units_cb->g_grid_remove();
    ($units_entry = $f->new_entry(
            -textvariable => \$units,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $units_entry->g_bind("<KeyRelease>",
                         sub { my $chars = &max(7, length($units));
                               $units_entry->configure(-width => $chars);
                               if ($parm eq "Temperature") {
                                   $title = "Temperature, in degrees " . $units;
                               } else {
                                   $title = $parm_short . ", in " . $units;
                               }
                             });

    $row++;
    $f->new_label(
            -text => "Data Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$title,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Data Min: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($xmin_entry = $f->new_entry(
            -textvariable => \$xmin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $xmin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $xmin_entry ]);

    $row++;
    $f->new_label(
            -text => "Data Max: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($xmax_entry = $f->new_entry(
            -textvariable => \$xmax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $xmax_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $xmax_entry ]);

    if ($props{$id}{meta} eq "w2_profile") {
        $row++;
        $f->new_label(
                -text => "Data Major: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($xmajor_entry = $f->new_entry(
                -textvariable => \$xmajor,
                -font         => 'default',
                -width        => 7,
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $xmajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($xmajor_entry, 1);
                                                    $xmajor =~ s/^-//;
                                                  });
    }

    $row++;
    $f->new_label(
            -text => "Y Axis Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($yaxis_type_cb = $f->new_ttk__combobox(
            -textvariable => \$yaxis_type,
            -values       => [ ("Elevation", "Depth") ],
            -state        => 'readonly',
            -width        => 10,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $yaxis_type_cb->g_bind("<<ComboboxSelected>>",
                           sub { if ($yaxis_type eq "Elevation") {
                                     $ymin_label->g_grid();
                                     $ymin_entry->g_grid();
                                     $ymin_units_label->g_grid();
                                     $ymax_label->configure(-text => "Elevation Max: ");
                                     $ymajor_label->configure(-text => "Elevation Major: ");
                                     $yaxis_units_label->configure(-text => "Elevation Units: ");
                                     if ($elev_base != -999 && $ymax ne "") {
                                         $ymin  = $elev_base;
                                         $ymax += $elev_base;
                                     } else {
                                         $ymin = "";
                                     }
                                 } else {
                                     $ymin_label->g_grid_remove();
                                     $ymin_entry->g_grid_remove();
                                     $ymin_units_label->g_grid_remove();
                                     $ymax_label->configure(-text => "Depth Max: ");
                                     $ymajor_label->configure(-text => "Depth Major: ");
                                     $yaxis_units_label->configure(-text => "Depth Units: ");
                                     if ($ymax ne "" && $ymin ne "" && $ymax -$ymin != 0) {
                                         $elev_base = &min($ymin, $ymax);
                                         $ymax      = abs($ymax -$ymin);
                                     } else {
                                         $ymax = "";
                                     }
                                     $ymin = 0;
                                 }
                               }
                          );

    $row++;
    ($ymin_label = $f->new_label(
            -text => "Elevation Min: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ymin_entry = $f->new_entry(
            -textvariable => \$ymin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $ymin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $ymin_entry ]);
    ($ymin_units_label = $f->new_label(
            -textvariable => \$yaxis_units,
            -font         => 'default',
            -anchor       => 'w',
            ))->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    ($ymax_label = $f->new_label(
            -text => "Elevation Max: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ymax_entry = $f->new_entry(
            -textvariable => \$ymax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $ymax_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($ymax_entry);
                                              $ymax =~ s/^-// if ($yaxis_type eq "Depth");
                                            });
    $f->new_label(
            -textvariable => \$yaxis_units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    ($ymajor_label = $f->new_label(
            -text => "Elevation Major: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ymajor_entry = $f->new_entry(
            -textvariable => \$ymajor,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $ymajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($ymajor_entry, 1);
                                                $ymajor =~ s/^-//;
                                              });
    $f->new_label(
            -textvariable => \$yaxis_units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    ($yaxis_units_label = $f->new_label(
            -text => "Elevation Units: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_ttk__combobox(
            -textvariable => \$yaxis_units,
            -values       => [ ("feet", "meters") ],
            -state        => 'readonly',
            -width        => 7,
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Color Scheme: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($cscheme_cb = $f->new_ttk__combobox(
            -textvariable => \$cscheme,
            -values       => [ @cmaps ],
            -state        => 'readonly',
            -width        => 15,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $cscheme_cb->g_bind("<<ComboboxSelected>>",
                           sub { my ($n);
                                 if ($cscheme eq "None") {
                                     $ncolors_cb->g_grid_remove();
                                     $ncolors_na_label->g_grid();
                                 } else {
                                     $ncolors_na_label->g_grid_remove();
                                     $ncolors_cb->g_grid();
                                     if ($cscheme =~ /CoolWarm|Turbo|Viridis/) {
                                         $ncolors_cb->configure(-values => [ (8 .. 100) ]);
                                     } else {
                                         $ncolors_cb->configure(-values =>
                                             [ (16, 18, 20, 22, 24, 30, 34, 38, 42, 46) ]);
                                         if ($ncolors < 16) {
                                             $ncolors = 16;
                                         } elsif ($ncolors > 46) {
                                             $ncolors = 46;
                                         } else {
                                             foreach $n (reverse @valid_nc) {
                                                 if ($ncolors >= 2 *$n) {
                                                     $ncolors = 2 *$n;
                                                     last;
                                                 }
                                             }
                                         }
                                     }
                                 }
                               });

    $row++;
    $f->new_label(
            -text => "Number of Colors: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ncolors_na_label = $f->new_label(
            -text => "n/a",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $ncolors_na_label->g_grid_remove();
    ($ncolors_cb = $f->new_ttk__combobox(
            -textvariable => \$ncolors,
            -values       => [ (16, 18, 20, 22, 24, 30, 34, 38, 42, 46) ],
            -state        => 'readonly',
            -width        => 4,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    ($jd_skip_label = $f->new_label(
            -text => "Skip Dates: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($jd_skip_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    $jd_skip_frame->new_spinbox(
            -textvariable => \$jd_skip,
            -state        => 'readonly',
            -font         => 'default',
            -from         => 0,
            -to           => 49,
            -increment    => 1,
            -width        => 4,
            -command      => sub { $jd_skip_explain = $jd_skip_opts[$jd_skip]; },
            )->g_pack(-side => 'left', -anchor => 'w');
    $jd_skip_frame->new_label(
            -textvariable => \$jd_skip_explain,
            -font         => 'default',
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $jd_skip_label->g_grid_remove();
    $jd_skip_frame->g_grid_remove();

    $row++;
    $f->new_label(
            -text => "Graph Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gtitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);

    if ($parm eq "Temperature" || $parm eq "Horizontal Velocity" || $parm eq "Vertical Velocity"
                               || $parm eq "Horizontal Layer Flow" || $parm eq "Density"
                               || $parm eq "Habitat" || $#parm_divlist == 0 || $src_type =~ /LakeCon/i) {
        $parm_div_label->g_pack_forget();
        $parm_div_cb->g_pack_forget();
    } else {
        $parm_div_label->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        $parm_div_cb->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    }
    if ($conv_type ne "Custom") {
        $custom_frame->g_grid_remove();
    }
    if (! $new_graph) {
        if ($parm eq "Temperature") {
            $units_cb->g_grid();
            $units_entry->g_grid_remove();
            $conv_type_na_label->g_grid();
            $custom_frame->g_grid_remove();
            $conv_type_cb->g_grid_remove();
            $conv_type = "None";
            $parm_div  = "None";
        } else {
            $units_cb->g_grid_remove();
            $units_entry->g_grid();
            $conv_type_na_label->g_grid_remove();
            $custom_frame->g_grid() if ($conv_type eq "Custom");
            $conv_type_cb->g_grid();
        }
        if ($jd_skip_active) {
            $jd_skip = 0 if ($jd_skip < 0 || $jd_skip > 49);
            $jd_skip_explain = $jd_skip_opts[$jd_skip];
            $jd_skip_label->g_grid();
            $jd_skip_frame->g_grid();
        }
    }
    if ($cscheme eq "None") {
        $ncolors_cb->g_grid_remove();
        $ncolors_na_label->g_grid();
    } else {
        $ncolors_na_label->g_grid_remove();
        $ncolors_cb->g_grid();
        if ($cscheme =~ /CoolWarm|Turbo|Viridis/) {
            $ncolors_cb->configure(-values => [ (8 .. 100) ]);
        } else {
            $ncolors_cb->configure(-values => [ (16, 18, 20, 22, 24, 30, 34, 38, 42, 46) ]);
            if ($ncolors < 16) {
                $ncolors = 16;
            } elsif ($ncolors > 46) {
                $ncolors = 46;
            } else {
                foreach $n (reverse @valid_nc) {
                    if ($ncolors >= 2 *$n) {
                        $ncolors = 2 *$n;
                        last;
                    }
                }
            }
        }
    }
    $f->g_grid_columnconfigure(3, -weight => 2);

    Tkx::wm_resizable($w2profile_setup_menu,0,0);
    &adjust_window_position($w2profile_setup_menu);
    $w2profile_setup_menu->g_focus;
}


sub change_w2_profile {
    my ($canv, $id, $X, $Y, $change) = @_;
    my (
        $byear, $byear_cb, $conv_add, $conv_add_entry, $conv_mult,
        $conv_mult_entry, $conv_type, $conv_type_cb, $conv_type_na_label,
        $custom_frame, $f, $frame, $ftype, $geom, $gtitle, $i, $jb,
        $jd_skip, $jd_skip_active, $jd_skip_explain, $jd_skip_frame, $jjw,
        $jw, $lcon_freq, $meta, $nbr, $nwb, $offset_frame, $ok, $ok_btn,
        $old_units, $oldparm, $oldparm_short, $parm, $parm_cb, $parm_chars,
        $parm_div, $parm_div_cb, $parm_div_label, $parm_frame, $parm_short,
        $parms_ref, $row, $segnum, $segnum_cb, $segs_ref, $segwidth,
        $src_file, $src_parm, $src_type, $tecplot, $title, $tz_offset,
        $units, $units_cb, $units_entry, $wb_txt, $xmajor, $xmajor_entry,
        $xmax, $xmax_entry, $xmin, $xmin_entry, $yr_max, $yr_min,

        @be, @bs, @cplf, @ds, @jbdn, @jd_skip_opts, @ncpl, @nspr, @nvpl,
        @parm_divlist, @parmlist, @segs, @sprf, @us, @vplf,
       );

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($w2profile_mod_menu) && Tkx::winfo_exists($w2profile_mod_menu)) {
        if ($w2profile_mod_menu->g_wm_title() eq "Modify W2 Profile") {
            $w2profile_mod_menu->g_destroy();
            undef $w2profile_mod_menu;
        }
    }
    $w2profile_mod_menu = $main->new_toplevel();
    $w2profile_mod_menu->g_wm_transient($main);
    $w2profile_mod_menu->g_wm_title("Modify W2 Profile");
    $w2profile_mod_menu->configure(-cursor => $cursor_norm);
    $w2profile_mod_menu->g_wm_geometry($geom);

#   Try to keep the nascent graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

#   De-select graph if it already exists
    if (defined($props{$id}{oldcoords})) {
        &end_select($canv, $id, 1);
    }

#   Initialize some variables.
    $nwb   = $grid{$id}{nwb};
    $nbr   = $grid{$id}{nbr};
    @bs    = @{ $grid{$id}{bs}   };
    @be    = @{ $grid{$id}{be}   };
    @us    = @{ $grid{$id}{us}   };
    @ds    = @{ $grid{$id}{ds}   };
    @jbdn  = @{ $grid{$id}{jbdn} };
    @nspr  = @{ $grid{$id}{nspr} };
    @sprf  = @{ $grid{$id}{sprf} };
    @ncpl  = @{ $grid{$id}{ncpl} };
    @cplf  = @{ $grid{$id}{cplf} };
    @nvpl  = @{ $grid{$id}{nvpl} };
    @vplf  = @{ $grid{$id}{vplf} };

    $src_type  = $props{$id}{src_type};
    $src_file  = $props{$id}{src_file};
    $segnum    = $props{$id}{seg};
    $parm      = $props{$id}{parm};
    $parm_div  = $props{$id}{parm_div};
    $units     = $props{$id}{parm_units};
    $conv_type = $props{$id}{ctype};
    $byear     = $props{$id}{byear};
    $tz_offset = $props{$id}{tz_offset};
    $jd_skip   = $props{$id}{jd_skip};

    $gtitle    = $gr_props{$id}{gtitle};

    if ($props{$id}{meta} eq "w2_profile_cmap") {
        $xmin   = $gr_props{$id}{cs_min};
        $xmax   = $gr_props{$id}{cs_max};
        $title  = $gr_props{$id}{keytitle};
    } else {
        $xmin   = $gr_props{$id}{xmin};
        $xmax   = $gr_props{$id}{xmax};
        $xmajor = $gr_props{$id}{xmajor};
        $title  = $gr_props{$id}{xtitle};
    }
    if ($conv_type =~ /Custom/) {
        ($conv_type, $conv_mult, $conv_add) = split(/,/, $conv_type);
    } else {
        $conv_mult = 1.0;
        $conv_add  = 0.0;
    }
    $yr_max = (localtime(time))[5] +1900;
    $yr_min = ($byear > $yr_max -25) ? $yr_max -25 : $byear -5;

    if ($src_type =~ /Spreadsheet/i) {
        ($ok, undef, $segs_ref, $parms_ref)
                  = &scan_w2_spr_file($w2profile_mod_menu, $src_file, "");
        if ($ok ne "okay") {
            return &pop_up_error($w2profile_mod_menu,
                                 "The specified file is not a W2 Spreadsheet file:\n$src_file");
        }
        @parmlist = @{ $parms_ref };
        @segs     = @{ $segs_ref  };
        $segnum   = $segs[$#segs] if ($segnum eq "" || &list_match($segnum, @segs) == -1);

    } elsif ($src_type =~ /Contour/i) {
        ($tecplot, undef, $jw, $parms_ref, undef, undef)
              = &scan_w2_cpl_file($w2profile_mod_menu, $src_file, $id, 0, "");
        if ($tecplot == -1) {
            return &pop_up_error($w2profile_mod_menu,
                                 "The specified file is not a W2 Contour file:\n$src_file");
        }
        if ($tecplot == 1 && $jw == 0) {   # Tecplot-type file; waterbody index unknown
            for ($jjw=1; $jjw<=$nwb; $jjw++) {
                if ($segnum >= $us[$bs[$jjw]] && $segnum <= $ds[$be[$jjw]]) {
                    $jw = $jjw;
                    last;
                }
            }
        }
        @segs = ();
        for ($jb=$bs[$jw]; $jb<=$be[$jw]; $jb++) {
            push (@segs, ($us[$jb] .. $ds[$jb]));
        }
        $segnum   = $ds[$jbdn[$jw]] if ($segnum eq "" || &list_match($segnum, @segs) == -1);
        @parmlist = @{ $parms_ref };

    } elsif ($src_type =~ /Vector/i) {
        ($ok, $parms_ref, undef, undef, undef)
                  = &scan_w2_vector_file($w2profile_mod_menu, $src_file, $id, 0);
        if ($ok ne "okay") {
            return &pop_up_error($w2profile_mod_menu,
                                 "The specified file is not a W2 Vector (w2l) file:\n$src_file");
        }
        @segs = ();
        for ($jb=1; $jb<=$nbr; $jb++) {
            push (@segs, ($us[$jb] .. $ds[$jb]));
        }
        $segnum   = $ds[$jbdn[1]] if ($segnum eq "" || &list_match($segnum, @segs) == -1);
        @parmlist = @{ $parms_ref };

    } elsif ($src_type =~ /LakeCon/i) {
        ($ftype, $src_parm, $meta, undef) = &scan_w2_rlcon_file($w2profile_mod_menu, $src_file, "");
        if ($ftype ne "lcon1") {
            return &pop_up_error($w2profile_mod_menu,
                                 "The specified file is not an acceptable\n"
                               . "W2 Lake Contour (format 1) file:\n$src_file");
        }
        ($segnum, $lcon_freq) = split(/_/, $meta);
        @segs     = ($segnum);
        @parmlist = ($src_parm);
    }
    @segs     = sort numerically @segs;
    $segwidth = &max(5, length(&max(@segs)));
    $wb_txt   = "";
    for ($jw=1; $jw<=$nwb; $jw++) {
        for ($jb=$bs[$jw]; $jb<=$be[$jw]; $jb++) {
            if ($segnum >= $us[$jb] && $segnum <= $ds[$jb]) {
                $wb_txt = " (waterbody $jw, branch $jb)";
                last;
            }
        }
        last if ($wb_txt ne "");
    }

    $jd_skip_active = 0;
    @jd_skip_opts = ("(keep all)", "(keep every other)", "(keep every 3rd)", "(keep every 4th)",
                     "(keep every 5th)",  "(keep every 6th)",  "(keep every 7th)",  "(keep every 8th)",
                     "(keep every 9th)",  "(keep every 10th)", "(keep every 11th)", "(keep every 12th)",
                     "(keep every 13th)", "(keep every 14th)", "(keep every 15th)", "(keep every 16th)",
                     "(keep every 17th)", "(keep every 18th)", "(keep every 19th)", "(keep every 20th)",
                     "(keep every 21st)", "(keep every 22nd)", "(keep every 23rd)", "(keep every 24th)",
                     "(keep every 25th)", "(keep every 26th)", "(keep every 27th)", "(keep every 28th)",
                     "(keep every 29th)", "(keep every 30th)", "(keep every 31st)", "(keep every 32nd)",
                     "(keep every 33rd)", "(keep every 34th)", "(keep every 35st)", "(keep every 36th)",
                     "(keep every 37th)", "(keep every 38th)", "(keep every 39th)", "(keep every 40th)",
                     "(keep every 41st)", "(keep every 42nd)", "(keep every 43rd)", "(keep every 44th)",
                     "(keep every 45th)", "(keep every 46th)", "(keep every 47th)", "(keep every 48th)",
                     "(keep every 49th)", "(keep every 50th)");
    if ($src_type =~ /Spreadsheet/i) {
        for ($i=1; $i<=$nspr[$jw]; $i++) {
            if ($sprf[$i][$jw] < 1.0) {
                $jd_skip_active = 1;
                last;
            }
        }
    } elsif ($src_type =~ /Contour/i) {
        for ($i=1; $i<=$ncpl[$jw]; $i++) {
            if ($cplf[$i][$jw] < 1.0) {
                $jd_skip_active = 1;
                last;
            }
        }
    } elsif ($src_type =~ /Vector/i) {
        for ($i=1; $i<=$nvpl[$jw]; $i++) {
            if ($vplf[$i][$jw] < 1.0) {
                $jd_skip_active = 1;
                last;
            }
        }
    } elsif ($src_type =~ /LakeCon/i) {
        $jd_skip_active = 1 if ($lcon_freq < 1.0);
    }
    $jd_skip = 0 if ($jd_skip < 0 || $jd_skip > 49);
    $jd_skip_explain = $jd_skip_opts[$jd_skip];

    $parm_chars = length($parmlist[0]);
    for ($i=1; $i<=$#parmlist; $i++) {
        $parm_chars = &max($parm_chars, length($parmlist[$i]));
    }
    $parm_chars += 2;
    $parm_short = $parm;
    if ($parm ne "Temperature") {
        $parm_short =~ s/\(ms-1\)//i;
        $parm_short =~ s/\(m3s-1\)//i;
        $parm_short =~ s/ [kmu]?g\/L\/day//i;
        $parm_short =~ s/ [kmu]?g\/m2\/day//i;
        $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
        $parm_short =~ s/ [kmu]?g\/L//i;
        $parm_short =~ s/ [kmu]?g\/m3//i;
        $parm_short =~ s/ [kmu]?g\/m\^3//i;
        $parm_short =~ s/, days//i;
        $parm_short =~ s/ days//i;
        $parm_short =~ s/,$//;
    }
    $old_units     = $units;
    $oldparm       = $parm;
    $oldparm_short = $parm_short;
    @parm_divlist  = ("None");
    for ($i=0; $i<=$#parmlist; $i++) {
        next if ($parmlist[$i] eq "Horizontal Velocity"
                  || $parmlist[$i] eq "Vertical Velocity"
                  || $parmlist[$i] eq "Horizontal Layer Flow"
                  || $parmlist[$i] eq "Density"
                  || $parmlist[$i] eq "Habitat");
        if ($parm ne $parmlist[$i]) {
            push (@parm_divlist, $parmlist[$i]);
        }
    }
    $parm_div = "None" if (&list_match($parm_div, @parm_divlist) == -1);

#   Build the menu.
    $frame = $w2profile_mod_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -command => sub { my ($modified, %parms);
                              $modified = 0;
                              %parms = ();
                              if ($change =~ /misc|base/) {
                                  $modified = 1 if ($byear     != $props{$id}{byear} ||
                                                    $tz_offset ne $props{$id}{tz_offset} ||
                                                    $jd_skip   != $props{$id}{jd_skip});
                              }
                              if ($change =~ /seg|misc/) {
                                  if ($segnum eq "" || $segnum <= 0) {
                                      return &pop_up_error($w2profile_mod_menu,
                                              "W2 segment number must be numeric and positive.");
                                  } elsif (&list_match($segnum, @segs) == -1) {
                                      return &pop_up_error($w2profile_mod_menu,
                                              "W2 segment number is inconsistent with source file.");
                                  }
                                  $modified = 1 if ($segnum != $props{$id}{seg});
                              }
                              if ($change =~ /parm|misc/) {
                                  if ($xmin eq "" || $xmax eq "") {
                                      return &pop_up_error($w2profile_mod_menu,
                                      "Please provide both a min and max for your parameter.");
                                  }
                                  if ($xmin >= $xmax) {
                                      return &pop_up_error($w2profile_mod_menu,
                                      "The minimum data value must be less than the maximum data value.");
                                  }
                                  if ($conv_type eq "Custom") {
                                      $conv_type = sprintf("Custom,%s,%s", $conv_mult, $conv_add);
                                  }
                                  $gtitle =~ s/^\s+//;
                                  $gtitle =~ s/\s+$//;
                                  if ($parm ne $props{$id}{parm} || $parm_div ne $props{$id}{parm_div}
                                       || ($parm ne "Temperature" && $units ne $props{$id}{parm_units})
                                       || $conv_type ne $props{$id}{ctype}) {
                                      $modified = 1;
                                  }
                                  if (! $modified && $parm eq "Temperature"
                                                  && $parm eq $props{$id}{parm}
                                                  && $units ne $props{$id}{parm_units}) {
                                      return &pop_up_error($w2profile_mod_menu,
                                                           "To modify just the temperature units,\n"
                                                         . "use the Graph Properties menu.");
                                  }
                                  if (! $modified &&
                                      (($props{$id}{meta} eq "w2_profile_cmap"
                                         && ($xmin != $gr_props{$id}{cs_min}
                                              || $xmax != $gr_props{$id}{cs_max})) ||
                                       ($props{$id}{meta} eq "w2_profile"
                                         && ($xmin != $gr_props{$id}{xmin}
                                              || $xmax != $gr_props{$id}{xmax}
                                              || $xmajor != $gr_props{$id}{xmajor})))) {
                                      return &pop_up_error($w2profile_mod_menu,
                                                           "To modify just the parameter limits,\n"
                                                         . "use the Graph Properties menu.");
                                  }
                                  if (! $modified && $gtitle ne $gr_props{$id}{gtitle}) {
                                      return &pop_up_error($w2profile_mod_menu,
                                                           "To modify just the graph title,\n"
                                                         . "use the Graph Properties menu.");
                                  }
                              }
                              if (! $modified) {
                                  $w2profile_mod_menu->g_bind('<Destroy>', "");
                                  $w2profile_mod_menu->g_destroy();
                                  undef $w2profile_mod_menu;
                                  &reset_bindings;
                                  return;
                              }

#                             Delete reference dataset if different segment, parameter, or units
                              if (defined($props{$id}{ref_file})
                                   && ($segnum    != $props{$id}{seg} ||
                                       $parm      ne $props{$id}{parm} ||
                                       $parm_div  ne $props{$id}{parm_div} ||
                                       $units     ne $props{$id}{parm_units} ||
                                       $conv_type ne $props{$id}{ctype})) {
                                  undef $props{$id}{ref_file};
                                  undef $gr_props{$id}{ref_data};
                              }

#                             Rebuild the dates array if different segment, jd_skip, byear, or tz_offset
                              $parms{rebuild}    = ($props{$id}{meta} eq "w2_profile" &&
                                                    ($segnum    != $props{$id}{seg}       ||
                                                     $byear     != $props{$id}{byear}     ||
                                                     $tz_offset ne $props{$id}{tz_offset} ||
                                                     $jd_skip   != $props{$id}{jd_skip})) ? 1 : 0;
                              $parms{xmin}       = $xmin;
                              $parms{xmax}       = $xmax;
                              $parms{xmajor}     = $xmajor;
                              $parms{gtitle}     = $gtitle;
                              $parms{change}     = $change;
                              $props{$id}{parms} = { %parms };

                              $props{$id}{data}       = 0;
                              $props{$id}{parm}       = $parm;
                              $props{$id}{parm_div}   = $parm_div;
                              $props{$id}{parm_units} = $units;
                              $props{$id}{ctype}      = $conv_type;
                              $props{$id}{seg}        = $segnum;
                              $props{$id}{byear}      = $byear;
                              $props{$id}{tz_offset}  = $tz_offset;
                              $props{$id}{jd_skip}    = $jd_skip;

                              $w2profile_mod_menu->g_bind('<Destroy>', "");
                              $w2profile_mod_menu->g_destroy();
                              undef $w2profile_mod_menu;
                              &reset_bindings;
                              &make_w2_profile($canv, $id, 0);
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $w2profile_mod_menu->g_bind('<Destroy>', "");
                              $w2profile_mod_menu->g_destroy();
                              undef $w2profile_mod_menu;
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Do not delete graph if this menu is destroyed by other than the Cancel button
    $w2profile_mod_menu->g_bind('<Destroy>' => sub { undef $w2profile_mod_menu;
                                                     &reset_bindings;
                                                   });

    $f = $w2profile_mod_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f->g_pack(-side => 'top');

    $row = 0;
    if ($change ne "base") {
        $f->new_label(
                -text => "Segment: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        if ($change =~ /seg|misc/) {
            ($segnum_cb = $f->new_ttk__combobox(
                    -textvariable => \$segnum,
                    -values       => [ @segs ],
                    -width        => 5,
                    ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
            $segnum_cb->g_bind("<<ComboboxSelected>>",
                                sub { $wb_txt = "";
                                      for ($jb=$bs[$jw]; $jb<=$be[$jw]; $jb++) {
                                          if ($segnum >= $us[$jb] && $segnum <= $ds[$jb]) {
                                              $wb_txt = " (waterbody $jw, branch $jb)";
                                              last;
                                          }
                                      }
                                    });
            if ($change eq "seg") {
                $f->new_label(
                        -textvariable => \$wb_txt,
                        -anchor       => 'w',
                        -font         => 'default',
                        )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);
                Tkx::wm_resizable($w2profile_mod_menu,0,0);
                $w2profile_mod_menu->g_focus;
                return;
            } else {
                $f->new_label(
                        -textvariable => \$wb_txt,
                        -anchor       => 'w',
                        -font         => 'default',
                        )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);
            }
        } else {
            $f->new_label(
                    -text => $segnum . $wb_txt,
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
        }
    }

    if ($change =~ /misc|base/) {
        $row++;
        $f->new_label(
                -text => "Base Year: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($byear_cb = $f->new_ttk__combobox(
                -textvariable => \$byear,
                -values       => [ reverse($yr_min .. $yr_max) ],
                -width        => 5,
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $byear_cb->g_bind("<<ComboboxSelected>>",
                          sub { if ($byear == $yr_min) {
                                    $yr_min -= 5;
                                    $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                }
                              });
        $f->new_label(
                -text   => " for JDAY = 1.0",
                -anchor => 'w',
                -font   => 'default',
                )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

        $row++;
        $f->new_label(
                -text => "Time Offset: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($offset_frame = $f->new_frame(
                -borderwidth => 0,
                -relief      => 'flat',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
        $offset_frame->new_ttk__combobox(
                -textvariable => \$tz_offset,
                -values       => [ @tz_offsets ],
                -justify      => 'right',
                -state        => 'readonly',
                -width        => 6,
                )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        $offset_frame->new_label(
                -text   => " time zone adjustment ",
                -anchor => 'w',
                -font   => 'default',
                )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        $offset_frame->new_button(
                -text    => "Help",
                -command => sub { &pop_up_info($w2profile_mod_menu,
                                        "The time offset allows the user to add or subtract a time\n"
                                      . "offset if the W2 model was run with a non-local time zone.\n\n"
                                      . "For example, if W2 was run in UTC but the local time zone\n"
                                      . "is PST, an offset of -08:00 would convert the model date/time\n"
                                      . "to a local standard time of PST. This offset does not make\n"
                                      . "any adjustments related to daylight saving time. In general,\n"
                                      . "W2 is best run in the local standard time.\n\n"
                                      . "Leave the time offset at +00:00 for no adjustment.",
                                        "Time Offset Notice");
                                },
                )->g_pack(-side => 'left', -anchor => 'w', -padx => 2);

        if ($jd_skip_active) {
            $row++;
            $f->new_label(
                    -text => "Skip Dates: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($jd_skip_frame = $f->new_frame(
                    -borderwidth => 0,
                    -relief      => 'flat',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
            $jd_skip_frame->new_spinbox(
                    -textvariable => \$jd_skip,
                    -state        => 'readonly',
                    -font         => 'default',
                    -from         => 0,
                    -to           => 49,
                    -increment    => 1,
                    -width        => 4,
                    -command      => sub { $jd_skip_explain = $jd_skip_opts[$jd_skip]; },
                    )->g_pack(-side => 'left', -anchor => 'w');
            $jd_skip_frame->new_label(
                    -textvariable => \$jd_skip_explain,
                    -font         => 'default',
                    )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        }
        if ($change eq "base") {
            $f->g_grid_columnconfigure(3, -weight => 2);
            Tkx::wm_resizable($w2profile_mod_menu,0,0);
            $w2profile_mod_menu->g_focus;
            return;
        }
    }

    $row++;
    $f->new_label(
            -text => "Parameter: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($parm_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    ($parm_cb = $parm_frame->new_ttk__combobox(
            -textvariable => \$parm,
            -values       => [ @parmlist ],
            -state        => 'readonly',
            -width        => $parm_chars,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $parm_cb->g_bind("<<ComboboxSelected>>",
                      sub { my ($i);
                            return if ($parm eq $oldparm);
                            $parm_short = $parm;
                            if ($parm eq "Temperature") {
                                $units = "Celsius" if ($units !~ /(Celsius|Fahrenheit)/);
                                $title = "Temperature, in degrees " . $units;
                                $units_cb->g_grid();
                                $units_entry->g_grid_remove();
                                $conv_type_na_label->g_grid();
                                $custom_frame->g_grid_remove();
                                $conv_type_cb->g_grid_remove();
                                $conv_type = "None";
                            } else {
                                $units = "";
                                $parm_short =~ s/\(ms-1\)//i;
                                $parm_short =~ s/\(m3s-1\)//i;
                                $parm_short =~ s/ [kmu]?g\/L\/day//i;
                                $parm_short =~ s/ [kmu]?g\/m2\/day//i;
                                $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
                                $parm_short =~ s/ [kmu]?g\/L//i;
                                $parm_short =~ s/ [kmu]?g\/m3//i;
                                $parm_short =~ s/ [kmu]?g\/m\^3//i;
                                $parm_short =~ s/, days//i;
                                $parm_short =~ s/ days//i;
                                $parm_short =~ s/,$//;
                                if ($parm eq "Horizontal Velocity" || $parm eq "Vertical Velocity") {
                                    $units = "m/s";
                                    $title = $parm_short . ", in m/s";
                                } elsif ($parm eq "Horizontal Layer Flow") {
                                    $units = "m3/s";
                                    $title = $parm_short . ", in m3/s";
                                } elsif ($parm eq "Density") {
                                    $units = "kg/m3";
                                    $title = $parm_short . ", in kg/m3";
                                } else {
                                    $title = $parm_short . ", in ";
                                }
                                $units_cb->g_grid_remove();
                                $units_entry->g_grid();
                                $conv_type_na_label->g_grid_remove();
                                $custom_frame->g_grid() if ($conv_type eq "Custom");
                                $conv_type_cb->g_grid();
                            }
                            if ($gtitle eq "") {
                               if ($props{$id}{meta} eq "w2_profile_cmap") {
                                   $gtitle = ucfirst($parm_short) . " Colormap";
                               } else {
                                   $gtitle = ucfirst($parm_short) . " Profile";
                               }
                            } else {
                                if (index(lc($gtitle), lc($oldparm_short)) > -1) {
                                    $gtitle =~ s/$oldparm_short/$parm_short/i;
                                }
                            }
                            $old_units     = $units;
                            $oldparm       = $parm;
                            $oldparm_short = $parm_short;
                            @parm_divlist  = ("None");
                            for ($i=0; $i<=$#parmlist; $i++) {
                                next if ($parmlist[$i] eq "Horizontal Velocity"
                                         || $parmlist[$i] eq "Vertical Velocity"
                                         || $parmlist[$i] eq "Horizontal Layer Flow"
                                         || $parmlist[$i] eq "Density"
                                         || $parmlist[$i] eq "Habitat");
                                if ($parm ne $parmlist[$i]) {
                                    push (@parm_divlist, $parmlist[$i]);
                                }
                            }
                            $parm_div_cb->configure(-values => [ @parm_divlist ]);
                            if (&list_match($parm_div, @parm_divlist) == -1) {
                                $parm_div = "None";
                            }
                            if ($parm eq "Temperature" || $parm eq "Horizontal Velocity"
                                    || $parm eq "Vertical Velocity" || $parm eq "Density"
                                    || $parm eq "Horizontal Layer Flow"
                                    || $parm eq "Habitat" || $#parm_divlist == 0) {
                                $parm_div_label->g_pack_forget();
                                $parm_div_cb->g_pack_forget();
                                $parm_div = "None";
                            } else {
                                $parm_div_label->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                                $parm_div_cb->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                            }
                          });
    ($parm_div_label = $parm_frame->new_label(
            -text => " divided by ",
            -font => 'default',
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    ($parm_div_cb = $parm_frame->new_ttk__combobox(
            -textvariable => \$parm_div,
            -values       => [ @parm_divlist ],
            -state        => 'readonly',
            -width        => $parm_chars,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Conversion: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($conv_type_na_label = $f->new_label(
            -text => "n/a",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $conv_type_na_label->g_grid_remove();
    ($conv_type_cb = $f->new_ttk__combobox(
            -textvariable => \$conv_type,
            -values       => [ @conv_types ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $conv_type_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($conv_type eq "Custom") {
                                $custom_frame->g_grid();
                            } else {
                                $custom_frame->g_grid_remove();
                            }
                          }
                      );
    $row++;
    ($custom_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    $custom_frame->new_label(
            -text => "Multiply by: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_mult_entry = $custom_frame->new_entry(
            -textvariable => \$conv_mult,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_mult_entry->g_bind("<KeyRelease>",
                              sub { &numeric_entry_only($conv_mult_entry);
                                    my $chars = &max(7, length($conv_mult));
                                    $conv_mult_entry->configure(-width => $chars);
                                  });
    $custom_frame->new_label(
            -text => "  Then add: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_add_entry = $custom_frame->new_entry(
            -textvariable => \$conv_add,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_add_entry->g_bind("<KeyRelease>",
                             sub { &numeric_entry_only($conv_add_entry);
                                   my $chars = &max(7, length($conv_add));
                                   $conv_add_entry->configure(-width => $chars);
                                 });

    $row++;
    $f->new_label(
            -text => "Data Units: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($units_cb = $f->new_ttk__combobox(
            -textvariable => \$units,
            -values       => [ ("Celsius", "Fahrenheit") ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $units_cb->g_bind("<<ComboboxSelected>>",
                       sub { return if ($units eq $old_units);
                             $old_units = $units;
                             if ($units eq "Celsius") {
                                 if ($xmin ne "" && $xmin ne "." && $xmin ne "-") {
                                     $xmin = &floor(($xmin -32) /1.8);
                                 }
                                 if ($xmax ne "" && $xmax ne "." && $xmax ne "-") {
                                     $xmax = &ceil(($xmax  -32) /1.8);
                                 }
                                 if ($props{$id}{meta} eq "w2_profile") {
                                     if ($xmajor ne "" && $xmajor ne "." && $xmajor ne "-") {
                                         $xmajor = &round_to_int($xmajor /1.8);
                                     }
                                 }
                             } elsif ($units eq "Fahrenheit") {
                                 if ($xmin ne "" && $xmin ne "." && $xmin ne "-") {
                                     $xmin = &floor($xmin *1.8 +32);
                                 }
                                 if ($xmax ne "" && $xmax ne "." && $xmax ne "-") {
                                     $xmax = &ceil($xmax  *1.8 +32);
                                 }
                                 if ($props{$id}{meta} eq "w2_profile") {
                                     if ($xmajor ne "" && $xmajor ne "." && $xmajor ne "-") {
                                         $xmajor = &round_to_int($xmajor *1.8);
                                     }
                                 }
                             }
                             $title = "Temperature, in degrees " . $units;
                           });
    $units_cb->g_grid_remove();
    ($units_entry = $f->new_entry(
            -textvariable => \$units,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $units_entry->g_bind("<KeyRelease>",
                         sub { my $chars = &max(7, length($units));
                               $units_entry->configure(-width => $chars);
                               if ($parm eq "Temperature") {
                                   $title = "Temperature, in degrees " . $units;
                               } else {
                                   $title = $parm_short . ", in " . $units;
                               }
                             });

    $row++;
    $f->new_label(
            -text => "Data Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$title,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Data Min: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($xmin_entry = $f->new_entry(
            -textvariable => \$xmin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $xmin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $xmin_entry ]);

    $row++;
    $f->new_label(
            -text => "Data Max: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($xmax_entry = $f->new_entry(
            -textvariable => \$xmax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $xmax_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $xmax_entry ]);

    if ($props{$id}{meta} eq "w2_profile") {
        $row++;
        $f->new_label(
                -text => "Data Major: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($xmajor_entry = $f->new_entry(
                -textvariable => \$xmajor,
                -font         => 'default',
                -width        => 7,
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $xmajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($xmajor_entry, 1);
                                                    $xmajor =~ s/^-//;
                                                  });
    }

    $row++;
    $f->new_label(
            -text => "Graph Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gtitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);

    if ($parm eq "Temperature" || $parm eq "Horizontal Velocity" || $parm eq "Vertical Velocity"
                               || $parm eq "Horizontal Layer Flow" || $parm eq "Density"
                               || $parm eq "Habitat" || $#parm_divlist == 0) {
        $parm_div_label->g_pack_forget();
        $parm_div_cb->g_pack_forget();
    } else {
        $parm_div_label->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        $parm_div_cb->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    }
    if ($conv_type ne "Custom") {
        $custom_frame->g_grid_remove();
    }
    if ($parm eq "Temperature") {
        $units_cb->g_grid();
        $units_entry->g_grid_remove();
        $conv_type_na_label->g_grid();
        $custom_frame->g_grid_remove();
        $conv_type_cb->g_grid_remove();
        $conv_type = "None";
        $parm_div  = "None";
    } else {
        $units_cb->g_grid_remove();
        $units_entry->g_grid();
        $conv_type_na_label->g_grid_remove();
        $custom_frame->g_grid() if ($conv_type eq "Custom");
        $conv_type_cb->g_grid();
    }
    $f->g_grid_columnconfigure(3, -weight => 2);

    Tkx::wm_resizable($w2profile_mod_menu,0,0);
    &adjust_window_position($w2profile_mod_menu);
    $w2profile_mod_menu->g_focus;
}


sub make_w2_profile {
    my ($canv, $id, $props_updated) = @_;
    my (
        $add_dateline, $base_jd, $box_id, $change, $cmap_image,
        $confirm_type, $cs_max, $cs_min, $cs_range, $cs_rev, $cscheme1,
        $cscheme2, $data_available, $date_id, $date_label, $datemax,
        $datemin, $dsize, $dt, $dt2, $elev_ref, $geom, $group_tags, $gtag,
        $i, $id2, $ih, $item, $iw, $j, $jd, $jd_max, $jd_min, $jd0, $jd2,
        $jw, $k, $kn_digits, $kt, $kt_ref, $mi, $mismatch, $move_mcursor,
        $mpointerx, $mpointery, $mult, $n, $ncolors, $new_graph, $nlayers,
        $np, $nwb, $parm_ref, $parm_short, $pbar, $pbar_frame, $pbar_window,
        $refresh_menus, $resized, $seg, $surf_elev, $tabid, $tag, $update_cs,
        $X, $x1, $x2, $xmax, $xmin, $xp, $xp1, $xp2, $xrange, $Y, $y1,
        $y2, $ymax, $ymin, $yp, $yp1, $yp2, $yr_max, $yr_min, $yrange, $yval,

        @be, @bs, @colors, @coords, @cpl_files, @ds, @el, @elws, @grp_tags,
        @items, @jdates, @kb, @mydates, @old_coords, @pdata, @scale, @tags,
        @us, @wbs,

        %axis_props, %color_key_props, %data, %elev_data, %kt_data, %limits,
        %parm_data, %parms, %profile,
       );

#   For new plots, pop up a menu for file names and parameters
    if (! defined($props{$id}{files})) {
        return &setup_w2_profile($canv, $id);
    }

#   Make tag and get coordinates of graph frame
    $gtag   = "graph" . $id;
    @coords = @{ $props{$id}{coordlist} };
    ($x1, $y1, $x2, $y2) = @coords;

#   Determine whether group tags are present and save the list
    $group_tags = 0;
    @grp_tags   = ();
    @tags       = Tkx::SplitList($canv->itemcget($id, -tags));
    if (&list_search("group_", @tags) > -1) {
        $group_tags = 1;
        foreach $tag (@tags) {
            push (@grp_tags, $tag) if ($tag =~ /^group_/);
        }
    }

#   Read the data files, if not done already
    if (! defined($props{$id}{data}) || ! $props{$id}{data}) {
        %parms = %{ $props{$id}{parms} };
        $seg   = $props{$id}{seg};

        if (defined($props{$id}{oldcoords})) {
            %profile   = %{ $gr_props{$id} };
            $change    = $parms{change};      # values:  seg, parm, misc, base, all
            $new_graph = 0;
        } else {
            %profile   = ();
            $change    = "";
            $new_graph = 1;
        }

#       Validate the source type
        $confirm_type = &confirm_w2_ftype($main, $props{$id}{src_file});
        if ($props{$id}{src_type} =~ /Spreadsheet/i && $confirm_type ne "spr") {
            return &pop_up_error($main,
                    "The W2 source file is not a W2 Spreadsheet file:\n$props{$id}{src_file}");
        } elsif ($props{$id}{src_type} =~ /Contour/i && $confirm_type ne "cpl") {
            return &pop_up_error($main,
                    "The W2 source file is not a W2 Contour file:\n$props{$id}{src_file}");
        } elsif ($props{$id}{src_type} =~ /Vector/i && $confirm_type ne "w2l") {
            return &pop_up_error($main,
                    "The W2 source file is not a W2 Vector (w2l) file:\n$props{$id}{src_file}");
        } elsif ($props{$id}{src_type} =~ /LakeCon/i && $confirm_type ne "lcon1") {
            return &pop_up_error($main, "The W2 source file is not an acceptable\n"
                                      . "W2 Lake Contour (format 1) file:\n$props{$id}{src_file}");
        }

#       Set some variables and read the bathymetry file.
#       Required for all source file types. Vector (w2l) files don't have a good kb value.
#       It's not necessary to re-read the bth file in certain situations.
        $nwb = $grid{$id}{nwb};
        @bs  = @{ $grid{$id}{bs} };
        @be  = @{ $grid{$id}{be} };
        @us  = @{ $grid{$id}{us} };
        @ds  = @{ $grid{$id}{ds} };
        for ($jw=1; $jw<=$nwb; $jw++) {
            last if ($seg >= $us[$bs[$jw]] && $seg <= $ds[$be[$jw]]);
        }
        if ($new_graph || $change eq "all") {
            &read_bth($main, $id, $jw, $props{$id}{bth_file});
        }

#       Move mouse cursor on first creation, to ensure that it changes to cursor_wait
        if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
            $canv->g_bind("<Motion>", "");
            Tkx::event_generate($main, "<Motion>", -warp => 1, -x => ($x1+$x2)/2, -y => ($y1+$y2)/2);
            $canv->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"), $canv, "menu" ]);
        }

        if ($props{$id}{src_type} =~ /Spreadsheet/i) {
            &get_grid_elevations($main, $id, $jw);
            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $props{$id}{src_lines},
                                                         "Reading W2 spreadsheet file...");
            ($kt_ref, $elev_ref, $parm_ref) = &read_w2_spr_file($main, $id, $props{$id}{src_file},
                                                  $props{$id}{parm}, $props{$id}{parm_div},
                                                  $props{$id}{byear}, $seg, $props{$id}{tz_offset},
                                                  $props{$id}{jd_skip}, $pbar);
            &destroy_progress_bar($main, $pbar_window);

            %kt_data   = %{ $kt_ref   };
            %elev_data = %{ $elev_ref };
            %parm_data = %{ $parm_ref };

        } elsif ($props{$id}{src_type} =~ /Contour/i) {
            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $props{$id}{src_lines},
                                                         "Reading W2 contour file...");
            %data = &read_w2_cpl_file($main, $id, $jw, $props{$id}{src_file}, $props{$id}{tplot},
                                          $seg, $props{$id}{parm}, $props{$id}{parm_div},
                                          $props{$id}{byear}, $props{$id}{tz_offset},
                                          $props{$id}{jd_skip}, $pbar);
            &destroy_progress_bar($main, $pbar_window);

            %kt_data   = ();
            %elev_data = ();
            %parm_data = ();
            @mydates   = keys %data;
            for ($j=0; $j<=$#mydates; $j++) {
                $dt    = $mydates[$j];
                $kt    = $data{$dt}{kt};
                @elws  = @{ $data{$dt}{elws}      };
                @pdata = @{ $data{$dt}{parm_data} };
                if (defined($elws[$seg])) {
                    $elev_data{$dt} = $elws[$seg];
                    for ($k=$kt; $k<=$#pdata; $k++) {
                        $parm_data{$dt}[$k-$kt] = $pdata[$k][$seg];
                    }
                }
                $kt_data{$dt} = $kt;
            }
            undef %data;

        } elsif ($props{$id}{src_type} =~ /Vector/i) {
            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, -s $props{$id}{src_file},
                                                         "Reading W2 vector file...");
            $status_line = "Reading W2 vector file... Date = 1";
            %data = &read_w2_vector_file($main, $id, $props{$id}{src_file}, $seg, $props{$id}{parm},
                                         $props{$id}{parm_div}, $props{$id}{byear}, $props{$id}{tz_offset},
                                         $props{$id}{jd_skip}, $pbar);
            &destroy_progress_bar($main, $pbar_window);

            %kt_data   = ();
            %elev_data = ();
            %parm_data = ();
            @kb        = @{ $grid{$id}{kb} };
            @mydates   = keys %data;
            for ($j=0; $j<=$#mydates; $j++) {
                $dt    = $mydates[$j];
                $kt    = $data{$dt}{kt};
                @pdata = @{ $data{$dt}{parm_data} };
                if (defined($data{$dt}{elws}) && $data{$dt}{elws} != -99) {
                    $elev_data{$dt} = $data{$dt}{elws};
                    for ($k=$kt; $k<=$#pdata; $k++) {
                        $parm_data{$dt}[$k-$kt] = $pdata[$k];
                        last if ($k >= $kb[$seg]);
                    }
                }
                $kt_data{$dt} = $kt;
            }
            undef %data;

        } elsif ($props{$id}{src_type} =~ /LakeCon/i) {
            &get_grid_elevations($main, $id, $jw);
            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $props{$id}{src_lines},
                                                         "Reading W2 Lake Contour file...");
            ($kt_ref, $elev_ref, $parm_ref) = &read_w2_lakecon_file($main, $id, $props{$id}{src_file},
                                                         $seg, $props{$id}{parm}, $props{$id}{byear},
                                                         $props{$id}{tz_offset}, $props{$id}{jd_skip}, $pbar);
            &destroy_progress_bar($main, $pbar_window);

            %kt_data   = %{ $kt_ref   };
            %elev_data = %{ $elev_ref };
            %parm_data = %{ $parm_ref };
        }

        if (&list_match($props{$id}{ctype}, @conv_types) > 0 || $props{$id}{ctype} =~ /^Custom,/) {
            $status_line = "Converting units...";
            Tkx::update_idletasks();
            %parm_data = &convert_timeseries($main, $props{$id}{ctype}, 1, %parm_data);
            $status_line = "";
            Tkx::update_idletasks();
        }

#       Find minimum and maximum elevation and parameter values
        %limits = &find_w2_profile_limits($id, $seg, \%elev_data, \%parm_data);
        $profile{date_min}  = $limits{date_min};
        $profile{date_max}  = $limits{date_max};
        $profile{dpth_min}  = $limits{dpth_min};
        $profile{dpth_max}  = $limits{dpth_max};
        $profile{elev_min}  = $limits{elev_min};
        $profile{elev_max}  = $limits{elev_max};
        $profile{parm_min}  = $limits{parm_min};
        $profile{parm_max}  = $limits{parm_max};
        undef %limits;

        $profile{kt_data}   = { %kt_data   };
        $profile{elev_data} = { %elev_data };
        $profile{parm_data} = { %parm_data };

        if ($new_graph) {
            $profile{yfont}     = $default_family;
            $profile{yl_size}   = &min(11, &max(8, int((abs($x2-$x1)+abs($y2-$y1))/2./41)));
            $profile{yt_size}   = $profile{yl_size} +2;
            $profile{yl_weight} = 'normal';
            $profile{yt_weight} = 'normal';
            $profile{ypr_tics}  = "outside";
            $profile{yop_tics}  = "none";

            $profile{xfont}     = $profile{yfont};
            $profile{xl_size}   = $profile{yl_size};
            $profile{xt_size}   = $profile{yt_size};
            $profile{xl_weight} = $profile{yl_weight};
            $profile{xt_weight} = $profile{yt_weight};
            $profile{xpr_tics}  = "outside";
            $profile{xop_tics}  = "none";

            $profile{gtfont}    = $profile{yfont};
            $profile{gt_size}   = $profile{yt_size};
            $profile{gt_weight} = 'bold';
            if ($props{$id}{meta} eq "w2_profile") {
                $profile{gs_size}   = $profile{gt_size} -1;
                $profile{gs_weight} = $profile{gt_weight};
            } else {
                $profile{dateline}  = 1;
                $profile{datelinec} = "black";
            }

            $profile{keyfont}   = $default_family;
            $profile{kn_size}   = $profile{yl_size};
            $profile{kt_size}   = $profile{yl_size} +2;
            $profile{kt_weight} = 'normal';
            $profile{kn_weight} = 'normal';
            $profile{kn_digits} = 1;

            $profile{cs_rev}    =  0;
            $profile{cs_hide}   =  0;
            $profile{xleg_off}  = 40;
            $profile{yleg_off}  =  0;
            $profile{cs_width}  = 24;
        }
        if ($new_graph || $change eq "all") {
            $profile{ytype}     = $parms{ytype};
            $profile{yunits}    = $parms{yunits};
            $profile{ymin}      = ($parms{ymin} ne "") ? $parms{ymin} : 0;
            $profile{ymax}      = $parms{ymax};
            $profile{ymajor}    = ($parms{ymajor} eq "") ? "auto" : $parms{ymajor};
            $profile{ytitle}    = $parms{ytype} . ", in " . $parms{yunits};

            if ($props{$id}{meta} eq "w2_profile_cmap") {
                $profile{xmajor}  = "auto";
                $profile{datefmt} = "Month";
                $profile{xmin}    = "first";
                $profile{xmax}    = "last";
                $profile{xtype}   = "Date/Time";
                $profile{base_yr} = $props{$id}{byear};
            }
            if ($parms{cscheme} eq "None") {
                $profile{add_cs}    =  0;
                $profile{cscheme1}  = "Blue";
                $profile{cscheme2}  = "Orange";
                $profile{ncolors}   = 20;
                $profile{cs_height} = &max(2, &min(18, int(($y2-$y1+1) /$profile{ncolors})));
            } else {
                $profile{add_cs}    =  1;
                $profile{cs_height} = &max(2, &min(18, int(($y2-$y1+1) /$parms{ncolors})));
                if ($parms{cscheme} eq "Blue to Orange") {
                    $profile{cscheme1} = "Blue";
                    $profile{cscheme2} = "Orange";
                    $profile{ncolors}  = $parms{ncolors} /2;
                } elsif ($parms{cscheme} eq "Blue to Red") {
                    $profile{cscheme1} = "Blue";
                    $profile{cscheme2} = "Red";
                    $profile{ncolors}  = $parms{ncolors} /2;
                } else {
                    $profile{cscheme1} = $parms{cscheme};
                    $profile{cscheme2} = "None";
                    $profile{ncolors}  = $parms{ncolors};
                }
            }
        } elsif ($change =~ /misc|base/) {
            if ($props{$id}{meta} eq "w2_profile_cmap") {
                $profile{base_yr} = $props{$id}{byear};
            }
        }
        if ($change ne "seg") {
            if ($props{$id}{parm} eq "Temperature") {
                $profile{xtitle} = "Temperature, in degrees " . $props{$id}{parm_units};
            } else {
                $parm_short = $props{$id}{parm};
                $parm_short =~ s/\(ms-1\)//i;
                $parm_short =~ s/\(m3s-1\)//i;
                $parm_short =~ s/ [kmu]?g\/L\/day//i;
                $parm_short =~ s/ [kmu]?g\/m2\/day//i;
                $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
                $parm_short =~ s/ [kmu]?g\/L//i;
                $parm_short =~ s/ [kmu]?g\/m3//i;
                $parm_short =~ s/ [kmu]?g\/m\^3//i;
                $parm_short =~ s/, days//i;
                $parm_short =~ s/ days//i;
                $parm_short =~ s/,$//;
                $profile{xtitle} = $parm_short . ", in " . $props{$id}{parm_units};
            }
            $profile{gtitle}   = $parms{gtitle};
            $profile{keytitle} = $profile{xtitle}; 
            $profile{cs_min}   = $parms{xmin};
            $profile{cs_max}   = $parms{xmax};
            $profile{cs_major} = "auto";

            if ($props{$id}{meta} eq "w2_profile") {
                $profile{xmin}   = $parms{xmin};
                $profile{xmax}   = $parms{xmax};
                $profile{xmajor} = ($parms{xmajor} eq "") ? "auto" : $parms{xmajor};
            }
            $profile{cs_link} = 0;
            if ($profile{add_cs} && @animate_ids && $#animate_ids >= 0) {
                $update_cs = 0;
                foreach $item (@animate_ids) {
                    next if ($item == $id);
                    next if ($props{$item}{meta} =~ /time_series|w2_wlevels/);
                    next if ($props{$item}{meta} eq "w2_outflow" && ! $props{$item}{add_parm});
                    if ($gr_props{$item}{cs_link} == 2) {
                        if ($props{$item}{meta} =~ /(w2_profile|w2_slice|w2_outflow)/
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$item}{parm_div}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                            $id2 = $item;
                            last;
                        } elsif ($props{$item}{meta} eq "w2_tdmap"
                             && $props{$item}{map_type}   eq "standard"
                             && $props{$item}{parm_sav}   eq $props{$id}{parm}
                             && $props{$item}{pdiv_sav}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                            $id2 = $item;
                            last;
                        } elsif ($props{$item}{meta} =~ /data_profile/
                             && $props{$item}{prof_type}  eq "standard"
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$id}{parm_div}     eq "None"
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                            $id2 = $item;
                            last;
                        } elsif ($props{$item}{meta} =~ /vert_wd_zone/
                             && $props{$id}{parm}       eq "Temperature"
                             && $props{$id}{parm_div}   eq "None"
                             && $props{$item}{wt_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                            $id2 = $item;
                            last;
                        }
                    }
                }
                if (! $update_cs) {
                    foreach $item (@animate_ids) {
                        next if ($item == $id);
                        next if ($props{$item}{meta} =~ /data_profile|vert_wd_zone|time_series|w2_wlevels/);
                        next if ($props{$item}{meta} eq "w2_outflow" && ! $props{$item}{add_parm});
                        next if ($props{$item}{meta} =~ /w2_slice|w2_tdmap/
                                  && $props{$item}{src_type} ne $props{$id}{src_type});
                        if ($gr_props{$item}{cs_link} == 1) {
                            if ($props{$item}{meta} =~ /w2_profile|w2_outflow/
                                 && $props{$item}{parm}       eq $props{$id}{parm}
                                 && $props{$item}{parm_div}   eq $props{$id}{parm_div}
                                 && $props{$item}{parm_units} eq $props{$id}{parm_units}
                                 && $props{$item}{src_file}   eq $props{$id}{src_file}) {
                                $update_cs = 1;
                                $id2 = $item;
                                last;
                            } elsif (($props{$item}{meta} =~ /w2_slice/
                                      && $props{$item}{parm}       eq $props{$id}{parm}
                                      && $props{$item}{parm_div}   eq $props{$id}{parm_div}
                                      && $props{$item}{parm_units} eq $props{$id}{parm_units})
                                  || ($props{$item}{meta} eq "w2_tdmap"
                                      && $props{$item}{map_type}   eq "standard"
                                      && $props{$item}{parm_sav}   eq $props{$id}{parm}
                                      && $props{$item}{pdiv_sav}   eq $props{$id}{parm_div}
                                      && $props{$item}{parm_units} eq $props{$id}{parm_units})) {
                                if ($props{$item}{src_type} =~ /Contour/i) {
                                    @wbs       = split(/,/, $props{$item}{wb_list});
                                    @cpl_files = @{ $props{$item}{cpl_files} };
                                    for ($n=0; $n<=$#wbs; $n++) {
                                        if ($cpl_files[$n] eq $props{$id}{src_file}) {
                                            $update_cs = 1;
                                            $id2 = $item;
                                            last;
                                        }
                                    }
                                    last if ($update_cs);
                                } elsif ($props{$item}{src_type} =~ /Vector/i) {
                                    if ($props{$item}{w2l_file} eq $props{$id}{src_file}) {
                                        $update_cs = 1;
                                        $id2 = $item;
                                        last;
                                    }
                                }
                            }
                        }
                    }
                }
                if ($update_cs) {
                    $ncolors           = $profile{ncolors};
                    $profile{cs_link}  = $gr_props{$id2}{cs_link};
                    $profile{cscheme1} = $gr_props{$id2}{cscheme1};
                    $profile{cscheme2} = $gr_props{$id2}{cscheme2};
                    $profile{ncolors}  = $gr_props{$id2}{ncolors};
                    $profile{cs_rev}   = $gr_props{$id2}{cs_rev};
                    $profile{cs_min}   = $gr_props{$id2}{cs_min};
                    $profile{cs_max}   = $gr_props{$id2}{cs_max};
                    $profile{cs_major} = $gr_props{$id2}{cs_major};
                    if ($new_graph) {
                        if ($profile{cs_height} *$ncolors > $y2-$y1+1 && $profile{cs_height} > 2) {
                            $profile{cs_height} = &max(2, &min(18, int(($y2-$y1+1) /$profile{ncolors})));
                        }
                    } elsif ($ncolors != $profile{ncolors}) {
                        $profile{cs_height} = &max(2, &min(30,
                                       &round_to_int($profile{cs_height} *$ncolors /$profile{ncolors})));
                    }
                }
            }
        }
        undef $gr_props{$id} if (! $new_graph);
        $profile{redraw}  = 1;
        $gr_props{$id}    = { %profile };
        $props{$id}{data} = 1;
        $props{$id}{gnum} = ++$graph_num if (! defined($props{$id}{oldcoords}));
        $resized          = 0;
        $refresh_menus    = 0;
        undef %profile;

#       Rebuild @dates array (profile, not colormap) under certain conditions.
#       The rebuild option is determined in change_w2_profile or setup_w2_profile.
        if (! $new_graph) {
            &rebuild_datelist if ($parms{rebuild});
            $refresh_menus = 1;
            $canv->delete($gtag . "_xaxis");
            $canv->delete($gtag . "_xaxisTitle");
            $canv->delete($gtag . "_yaxis");
            $canv->delete($gtag . "_yaxisTitle");
            $canv->delete($gtag . "_date");
            $canv->delete($gtag . "_gtitle");
            $canv->delete($gtag . "_colorKey");
            $canv->delete($gtag . "_colorKeyTitle");
            $canv->delete($gtag . "_profile");
            $canv->delete($gtag . "_colorProfile");
            $canv->delete($gtag . "_refData");
            $canv->delete($gtag . "_colorMap");
            $canv->delete($gtag . "_colorMapDateline");
        }
        undef %parms;

#   Or use previously read info.  If resized, delete graph and redraw
    } else {
        @old_coords    = @{ $props{$id}{oldcoords} };
        $refresh_menus = 0;
        $resized       = 0;
        for ($i=0; $i<=$#coords; $i++) {
            if ($coords[$i] != $old_coords[$i]) {
                $resized = 1;
                last;
            }
        }
        return if (! $resized && ! $props_updated);
        $gr_props{$id}{redraw} = 1 if ($resized);

        $seg       = $props{$id}{seg};
        %kt_data   = %{ $gr_props{$id}{kt_data}   };
        %elev_data = %{ $gr_props{$id}{elev_data} };
        %parm_data = %{ $gr_props{$id}{parm_data} };

        $canv->delete($gtag . "_xaxis");
        $canv->delete($gtag . "_xaxisTitle");
        $canv->delete($gtag . "_yaxis");
        $canv->delete($gtag . "_yaxisTitle");
        $canv->delete($gtag . "_date");
        $canv->delete($gtag . "_gtitle");
        $canv->delete($gtag . "_colorKey");
        $canv->delete($gtag . "_colorKeyTitle");
        $canv->delete($gtag . "_colorMapDateline");
        if ($gr_props{$id}{redraw}) {
            $canv->delete($gtag . "_profile");
            $canv->delete($gtag . "_colorProfile");
            $canv->delete($gtag . "_refData");
            $canv->delete($gtag . "_colorMap");
        }
    }
    $props{$id}{oldcoords} = [ @coords ];

#   Plot a white rectangle below the graph frame
    @items     = Tkx::SplitList($canv->find_withtag($gtag . "_main"));
    $new_graph = ($#items >= 0) ? 0 : 1;
    if ($new_graph) {
        $box_id = $canv->create_rectangle($x1, $y1, $x2, $y2,
                             -outline => "",
                             -width   => 0,
                             -fill    => &get_rgb_code("white"),
                             -tags    => $gtag . " " . $gtag . "_main");
        $canv->lower($box_id, $id);
    } else {
        $canv->coords($gtag . "_main", @coords);
        $canv->raise($id, $gtag . "_main");
    }

#   Plot Y axis
    $axis_props{min}     = $gr_props{$id}{ymin};
    $axis_props{max}     = $gr_props{$id}{ymax};
    $axis_props{major}   = $gr_props{$id}{ymajor};
    $axis_props{minor}   = 1;
    $axis_props{pr_tics} = $gr_props{$id}{ypr_tics};
    $axis_props{op_tics} = $gr_props{$id}{yop_tics};
    $axis_props{reverse} = ($gr_props{$id}{ytype} eq "Depth") ? 1 : 0;
    $axis_props{title}   = $gr_props{$id}{ytitle};
    $axis_props{font}    = $gr_props{$id}{yfont};
    $axis_props{size1}   = $gr_props{$id}{yl_size};
    $axis_props{size2}   = $gr_props{$id}{yt_size};
    $axis_props{weight1} = $gr_props{$id}{yl_weight};
    $axis_props{weight2} = $gr_props{$id}{yt_weight};
    $axis_props{side}    = "left";
    $axis_props{tags}    = $gtag . " " . $gtag . "_yaxis";
    $axis_props{coords}  = [$x1, $y2, $x1, $y1];
    $axis_props{op_loc}  = $x2;
    &make_axis($canv, %axis_props);
    undef %axis_props;

#   Elevation or depth limits.  Keep depths and elevations in meters.
    $mult   = ($gr_props{$id}{yunits} eq "feet") ? 3.28084 : 1.0;
    $ymin   = $gr_props{$id}{ymin} /$mult;
    $ymax   = $gr_props{$id}{ymax} /$mult;
    $yrange = $ymax -$ymin;
    @el     = @{ $grid{$id}{el} };
    @kb     = @{ $grid{$id}{kb} };

#   Deal with optional color scheme and create optional color key
    if ($gr_props{$id}{add_cs} || $props{$id}{meta} eq "w2_profile_cmap") {
        $cscheme1  = $gr_props{$id}{cscheme1};
        $cscheme2  = $gr_props{$id}{cscheme2};
        $ncolors   = $gr_props{$id}{ncolors};
        $cs_rev    = $gr_props{$id}{cs_rev};
        $cs_min    = $gr_props{$id}{cs_min};
        $cs_max    = $gr_props{$id}{cs_max};
        $kn_digits = $gr_props{$id}{kn_digits};
        if (&list_match($cscheme1, @color_scheme_names) == -1 ||
           (&list_match($cscheme1, @full_color_schemes) == -1 && &list_match($ncolors, @valid_nc) == -1) ||
           (&list_match($cscheme1, @full_color_schemes) >= 0 && &list_match($ncolors, @valid_nc_alt) == -1) ||
           ($cscheme2 ne "" && $cscheme2 ne "None" && &list_match($cscheme2, @color_scheme_names) == -1)) {
            $cscheme1  = $gr_props{$id}{cscheme1}  = "Blue";
            $cscheme2  = $gr_props{$id}{cscheme2}  = "Orange";
            $ncolors   = $gr_props{$id}{ncolors}   = 11;
            $cs_rev    = $gr_props{$id}{cs_rev}    =  0;
            $cs_min    = $gr_props{$id}{cs_min}    =  0;
            $cs_max    = $gr_props{$id}{cs_max}    = 22;
            $kn_digits = $gr_props{$id}{kn_digits} =  1;
        }
        $cs_range = $cs_max -$cs_min;
        @colors   = &make_color_scheme($ncolors, $cs_rev, $cscheme1, $cscheme2);
        @scale    = ();
        for ($i=0; $i<=$#colors+1; $i++) {
            $j = $#colors +1 -$i;
            $scale[$j] = $cs_min +$cs_range*$j/($#colors+1);
        }
        $gr_props{$id}{colors}    = [ @colors ];
        $gr_props{$id}{scale}     = [ @scale  ];

        $color_key_props{xleg}    = $x2 + $gr_props{$id}{xleg_off};
        $color_key_props{yleg}    = $y1 + $gr_props{$id}{yleg_off};
        $color_key_props{width}   = $gr_props{$id}{cs_width};
        $color_key_props{height}  = $gr_props{$id}{cs_height};
        $color_key_props{colors}  = [ @colors ];
        $color_key_props{scale}   = [ @scale  ];
        $color_key_props{title}   = $gr_props{$id}{keytitle};
        $color_key_props{font}    = $gr_props{$id}{keyfont};
        $color_key_props{size1}   = $gr_props{$id}{kn_size};
        $color_key_props{size2}   = $gr_props{$id}{kt_size};
        $color_key_props{weight1} = $gr_props{$id}{kn_weight};
        $color_key_props{weight2} = $gr_props{$id}{kt_weight};
        $color_key_props{digits}  = $kn_digits;
        $color_key_props{major}   = $gr_props{$id}{cs_major};
        $color_key_props{tags}    = $gtag . " " . $gtag . "_colorKey";
        &make_color_key($canv, %color_key_props);
        undef %color_key_props;

        if ($gr_props{$id}{cs_hide}) {
            $canv->itemconfigure($gtag . "_colorKey", -state => 'hidden');
        }
    }

#   Set the list of dates or merge the dates array if necessary
#   Add the graph to the list of animated graphs, if necessary
    @mydates = sort keys %parm_data;
    if ($props{$id}{meta} eq "w2_profile") {
        if (! @animate_ids || &list_match($id, @animate_ids) == -1) {
            if (@dates && @animate_ids && $#animate_ids >= 0) {
                $mismatch = 0;
                foreach $id2 (@animate_ids) {
#                   next if ($id2 == $id);
                    next if ($props{$id2}{meta} =~ /data_profile_cmap|w2_profile_cmap|w2_tdmap|time_series/);
                    if ($props{$id2}{meta} =~ /w2_slice|w2_wlevels/) {
                        if ($props{$id2}{src_type}     ne $props{$id}{src_type}
                            || $props{$id2}{byear}     != $props{$id}{byear}
                            || $props{$id2}{tz_offset} ne $props{$id}{tz_offset}
                            || $props{$id2}{jd_skip}   != $props{$id}{jd_skip}) {
                            $mismatch = 1;
                            last;
                        } elsif ($props{$id2}{src_type} =~ /Contour/i) {
                            @wbs       = split(/,/, $props{$id2}{wb_list});
                            @cpl_files = @{ $props{$id2}{cpl_files} };
                            $mismatch  = 1;
                            for ($n=0; $n<=$#wbs; $n++) {
                                if ($cpl_files[$n] eq $props{$id}{src_file}) {
                                    $mismatch = 0;
                                    last;
                                }
                            }
                            last if ($mismatch);
                        } elsif ($props{$id2}{src_type} =~ /Vector/i) {
                            if ($props{$id2}{w2l_file} ne $props{$id}{src_file}) {
                                $mismatch = 1;
                                last;
                            }
                        }
                    } elsif ($props{$id2}{meta} =~ /^(data_profile|vert_wd_zone|w2_outflow)$/
                             || $props{$id2}{src_file} ne $props{$id}{src_file}) {
                        $mismatch = 1;
                        last;
                    } elsif ($props{$id2}{src_file} eq $props{$id}{src_file}) {
                        if ($props{$id2}{byear}        != $props{$id}{byear}
                            || $props{$id2}{tz_offset} ne $props{$id}{tz_offset}
                            || $props{$id2}{jd_skip}   != $props{$id}{jd_skip}) {
                            $mismatch = 1;
                            last;
                        }
                    }
                }
                if ($mismatch) {
                    if (defined($animate_tb) && Tkx::winfo_exists($animate_tb)) {
                        if ($animate_tb->g_wm_title() eq "Animation toolbar") {
                            $animate_tb->g_destroy();
                            undef $animate_tb;
                        }
                    }
                    $dt      = $dates[$dti-1];
                    @dates   = &merge_dates(\@dates, \@mydates);
                    $dti_max = $#dates+1;
                    $dti     = 1 + &nearest_dt_index($dt, @dates);
                    $dti++ if ($dti == 0);
                }
            } else {
                @dates   = @mydates;
                $dti_max = $#dates+1;
                $dti     = 1;
                $delay   = 0.5;
            }
            $dti_old = $dti;
            push (@animate_ids, $id);
        }
        $dt = $dates[$dti-1];              # Define current date/time
        if (! defined($parm_data{$dt})) {  # Adjust by up to 10 minutes, if needed
            for ($mi=1; $mi<=10; $mi++) {
                $dt2 = &adjust_dt($dt, $mi);
                if (defined($parm_data{$dt2})) {
                    $dt = $dt2;
                    last;
                }
                $dt2 = &adjust_dt($dt, -1 *$mi);
                if (defined($parm_data{$dt2})) {
                    $dt = $dt2;
                    last;
                }
            }
        }
        $export_menu->entryconfigure(3, -state => 'normal') if ($use_GS);
        $pref_menu->entryconfigure(0,   -state => 'normal');

    } else {
        if (! defined($cmap_datemin)) {
            $cmap_datemin = substr($mydates[0],0,8);
            $cmap_datemax = substr($mydates[$#mydates],0,8);
        } else {
            $datemin      = substr($mydates[0],0,8);
            $datemax      = substr($mydates[$#mydates],0,8);
            $cmap_datemin = $datemin if ($datemin < $cmap_datemin);
            $cmap_datemax = $datemax if ($datemax > $cmap_datemax);
        }
    }

#   Refresh the Graph Properties menu and Object Information box, if present
    if ($refresh_menus) {
        if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
            if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
                $tabid = $grprops_notebook->index('current');
                $geom  = $graph_props_menu->g_wm_geometry();
                (undef, $X, $Y) = split(/\+/, $geom);
                &edit_graph_props($id, $X, $Y, $tabid);
            }
        }
        if (defined($object_infobox) && Tkx::winfo_exists($object_infobox)) {
            if ($object_infobox->g_wm_title() eq "Object Info") {
                $geom = $object_infobox->g_wm_geometry();
                (undef, $X, $Y) = split(/\+/, $geom);
                &show_info($canv, $id, $X, $Y);
            }
        }
    }

#   An animated vertical profile is requested
    if ($props{$id}{meta} eq "w2_profile") {

#       Determine whether data are available on this date
        if (defined($parm_data{$dt}) && defined($elev_data{$dt})) {
            $data_available = 1;
        } else {
            $data_available = $np = 0;
        }

#       Plot the date as a subtitle
        $xp = ($x1+$x2)/2.;
        $yp = ($gr_props{$id}{xop_tics} =~ /outside|cross/) ? $y1-14 : $y1-6;
        $date_label = &get_formatted_date($dt);
        $date_id = $canv->create_text($xp, $yp,
                           -anchor => 's',
                           -text   => $date_label,
                           -fill   => &get_rgb_code("black"),
                           -angle  => 0,
                           -tags   => $gtag . " " . $gtag . "_date",
                           -font   => [-family     => $gr_props{$id}{gtfont},
                                       -size       => $gr_props{$id}{gs_size},
                                       -weight     => $gr_props{$id}{gs_weight},
                                       -slant      => 'roman',
                                       -underline  => 0,
                                       -overstrike => 0,
                                      ]);
        @coords = Tkx::SplitList($canv->bbox($date_id));
        $dsize  = &max(10, abs($coords[3] - $coords[1]));

#       Plot the graph title
        $canv->create_text($xp, $yp-$dsize,
                           -anchor => 's', 
                           -text   => $gr_props{$id}{gtitle},
                           -fill   => &get_rgb_code("black"),
                           -angle  => 0,
                           -tags   => $gtag . " " . $gtag . "_gtitle",
                           -font   => [-family     => $gr_props{$id}{gtfont},
                                       -size       => $gr_props{$id}{gt_size},
                                       -weight     => $gr_props{$id}{gt_weight},
                                       -slant      => 'roman',
                                       -underline  => 0,
                                       -overstrike => 0,
                                      ]);

#       Plot X axis
        $axis_props{min}     = $gr_props{$id}{xmin};
        $axis_props{max}     = $gr_props{$id}{xmax};
        $axis_props{major}   = $gr_props{$id}{xmajor};
        $axis_props{minor}   = 1;
        $axis_props{pr_tics} = $gr_props{$id}{xpr_tics};
        $axis_props{op_tics} = $gr_props{$id}{xop_tics};
        $axis_props{reverse} = 0;
        $axis_props{title}   = $gr_props{$id}{xtitle};
        $axis_props{font}    = $gr_props{$id}{xfont};
        $axis_props{size1}   = $gr_props{$id}{xl_size};
        $axis_props{size2}   = $gr_props{$id}{xt_size};
        $axis_props{weight1} = $gr_props{$id}{xl_weight};
        $axis_props{weight2} = $gr_props{$id}{xt_weight};
        $axis_props{side}    = "bottom";
        $axis_props{tags}    = $gtag . " " . $gtag . "_xaxis";
        $axis_props{coords}  = [$x1, $y2, $x2, $y2];
        $axis_props{op_loc}  = $y1;
        &make_axis($canv, %axis_props);
        undef %axis_props;

#       Don't recompute and redraw unless necessary
        if (! $gr_props{$id}{redraw}) {
            if ($gr_props{$id}{add_cs}) {
                $canv->lower($gtag . "_colorKey",      $id);
                $canv->lower($gtag . "_colorKeyTitle", $id);
                $canv->lower($gtag . "_colorProfile",  $id);
            }
            $canv->lower($gtag . "_date",       $id);
            $canv->lower($gtag . "_gtitle",     $id);
            $canv->lower($gtag . "_xaxisTitle", $id);
            $canv->lower($gtag . "_yaxisTitle", $id);
            $canv->lower($gtag . "_profile",    $id);
            $canv->lower($gtag . "_refData",    $id);
            $canv->lower($gtag . "_xaxis",      $id);
            $canv->lower($gtag . "_yaxis",      $id);
            if ($group_tags) {
                foreach $tag (@grp_tags) {
                    $canv->addtag($tag, withtag => $gtag);
                }
            }
            return;
        }

#       Find the water-surface elevation and number of active layers
        if ($data_available) {
            $nlayers   = $#{ $parm_data{$dt} } +1;
            $surf_elev = $elev_data{$dt};
            $kt        = $kt_data{$dt};
            $kt        = $kb[$seg] if ($kt > $kb[$seg] && $nlayers == 1);
        }

#       Get coordinates for the profile
        $xmin   = $gr_props{$id}{xmin};
        $xmax   = $gr_props{$id}{xmax};
        $xrange = $xmax -$xmin;
        @coords = ();
        if ($data_available) {
            for ($i=0; $i<$nlayers; $i++) {
                if ($props{$id}{parm} eq "Temperature" && $props{$id}{parm_units} eq "Fahrenheit") {
                    $xp = $x1 +($x2-$x1)*(($parm_data{$dt}[$i] *1.8 +32)-$xmin)/$xrange;
                } else {
                    $xp = $x1 +($x2-$x1)*($parm_data{$dt}[$i]-$xmin)/$xrange;
                }
                $xp = &max($x1, &min($x2, $xp));
                if ($i == 0) {
                    $yval = $surf_elev;
                } else {
                    $yval = $el[$kt+$i][$seg];
                }
                if ($gr_props{$id}{ytype} eq "Depth") {
                    $yp1 = $y1 +($y2-$y1)*($surf_elev-$yval)/$ymax;
                } else {
                    $yp1 = $y2 -($y2-$y1)*($yval-$ymin)/$yrange;
                }
                last if ($yp1 >= $y2);
                $yp1 = &max($y1, &min($y2, $yp1));
                if ($gr_props{$id}{ytype} eq "Depth") {
                    $yp2 = $y1 +($y2-$y1)*($surf_elev-$el[$kt+$i+1][$seg])/$ymax;
                } else {
                    $yp2 = $y2 -($y2-$y1)*($el[$kt+$i+1][$seg]-$ymin)/$yrange;
                }
                next if ($yp2 <= $y1);
                $yp2 = &max($y1, &min($y2, $yp2));
                push (@coords, $xp, $yp1, $xp, $yp2);
                last if ($yp2 >= $y2);
            }
            $np = ($#coords +1)/2;
        }

        if ($gr_props{$id}{add_cs} && $np > 1) {

#           Create an image to hold the color profile and recognize its methods
            $iw = $x2 -$x1 +1;
            $ih = $y2 -$y1 +1;
            $cmap_image = Tkx::image_create_photo(-width => $iw, -height => $ih);
            $cmap_image = Tkx::widget->new($cmap_image);
            $xp1 = 0;
            $xp2 = $iw -1;

            if ($gr_props{$id}{ytype} eq "Depth") {
                $yp2 = 0;
            } else {
                $yp2 = &round_to_int($ih-1 -($ih-1)*($surf_elev-$ymin)/$yrange);
                $yp2 = &max(0, &min($ih-1, $yp2));
            }
            for ($i=0; $i<$nlayers; $i++) {
                $yp1 = $yp2;
                if ($gr_props{$id}{ytype} eq "Depth") {
                    $yp2 = &round_to_int(($ih-1)*($surf_elev-$el[$kt+$i+1][$seg])/$ymax);
                } else {
                    $yp2 = &round_to_int($ih-1 -($ih-1)*($el[$kt+$i+1][$seg]-$ymin)/$yrange);
                }
                last if ($yp1 >= $ih-1);
                if ($yp2 < 0) {
                    $yp2 = 0;
                    next;
                }
                $yp2 = &max(0, &min($ih-1, $yp2));
                if ($props{$id}{parm} eq "Temperature" && $props{$id}{parm_units} eq "Fahrenheit") {
                    $j = int(($#colors+1) *(($parm_data{$dt}[$i] *1.8 +32)-$cs_min)/$cs_range);
                } else {
                    $j = int(($#colors+1) *($parm_data{$dt}[$i]-$cs_min)/$cs_range);
                }
                $j = &max(0, &min($#colors, $j));
                $cmap_image->put($colors[$j], -to => $xp1, $yp1, $xp2, $yp2);
                last if ($yp2 >= $ih-1);
            }
            $canv->create_image($x1, $y1, -anchor => 'nw',
                                          -image  => $cmap_image,
                                          -tags   => $gtag . " " . $gtag . "_colorProfile");
            undef $cmap_image;
        }
        undef %kt_data;
        undef %elev_data;
        undef %parm_data;

#       Plot the water surface and its indicator, if plotting elevations
        if ($data_available && $gr_props{$id}{ytype} ne "Depth") {
            $yp = $y2 -($y2-$y1)*($surf_elev-$ymin)/$yrange;
            if ($yp >= $y1 && $yp <= $y2) {
                $canv->create_line($x1, $yp, $x2, $yp,
                                    -fill  => &get_rgb_code("gray60"),
                                    -width => 1,
                                    -arrow => 'none',
                                    -tags  => $gtag . " " . $gtag . "_profile");
                $xp = $x1 + 0.9*($x2-$x1);
                $canv->create_polygon($xp, $yp, $xp-4, $yp-8, $xp+4, $yp-8,
                                    -outline => &get_rgb_code("gray60"),
                                    -width   => 1,
                                    -fill    => &get_rgb_code("white"),
                                    -tags    => $gtag . " " . $gtag . "_profile");
            }
        }

#       Plot the profile
        if ($np > 1) {
            $canv->create_line(@coords, -fill  => &get_rgb_code("black"),
                                        -width => 1,
                                        -arrow => 'none',
                                        -tags  => $gtag . " " . $gtag . "_profile");
        }

#       Plot a no-data message
        if (! $data_available || $np <= 1) {
            $canv->create_text(($x1+$x2)/2., ($y1 +$y2)/2.,
                               -anchor => 'center', 
                               -text   => "No Data",
                               -fill   => &get_rgb_code("gray60"),
                               -angle  => 0,
                               -tags   => $gtag . " " . $gtag . "_profile",
                               -font   => [-family     => $gr_props{$id}{xfont},
                                           -size       => $gr_props{$id}{xl_size},
                                           -weight     => 'normal',
                                           -slant      => 'roman',
                                           -underline  => 0,
                                           -overstrike => 0,
                                          ]);
        }

#       Add any measured profile data
        if (defined($props{$id}{ref_file})) {
            &plot_ref_profile($canv, $id, 0);
        }

#       Place the graphic items in the proper order
        &raise_lower($canv, $id, "tiptop") if ($new_graph);
        if ($gr_props{$id}{add_cs}) {
            $canv->lower($gtag . "_colorKey",      $id);
            $canv->lower($gtag . "_colorKeyTitle", $id);
            $canv->lower($gtag . "_colorProfile",  $id);
        }
        $canv->lower($gtag . "_date",       $id);
        $canv->lower($gtag . "_gtitle",     $id);
        $canv->lower($gtag . "_xaxisTitle", $id);
        $canv->lower($gtag . "_yaxisTitle", $id);
        $canv->lower($gtag . "_profile",    $id);
        $canv->lower($gtag . "_refData",    $id);
        $canv->lower($gtag . "_xaxis",      $id);
        $canv->lower($gtag . "_yaxis",      $id);
        if ($group_tags) {
            foreach $tag (@grp_tags) {
                $canv->addtag($tag, withtag => $gtag);
            }
        }

#       Update any links
        &update_links($canv, $id, $dt);

#   A water-temperature colormap is requested
    } elsif ($props{$id}{meta} eq "w2_profile_cmap") {

#       Keep track of graphs that can be animated
#       Colormaps only get a bit of animation when they have an accompanying profile
#       For first creation, ensure mouse cursor is on canvas so it can be changed
        $move_mcursor = 0;
        if (! @animate_ids || &list_match($id, @animate_ids) == -1) {
            push (@animate_ids, $id);
            $move_mcursor = 1;
        }

        @jdates = &dates2jdates(@mydates);
        if ($gr_props{$id}{xmin} eq "first" && $gr_props{$id}{xmax} eq "last") {
            $jd_min = &floor($jdates[0] +0.0000001);
            $jd_max = &floor($jdates[$#jdates] +1.0000001);
            if ($gr_props{$id}{xtype} eq "Date/Time") {
                $gr_props{$id}{xmin} = &jdate2datelabel($jd_min, "Mon-DD-YYYY");
                $gr_props{$id}{xmax} = &jdate2datelabel($jd_max, "Mon-DD-YYYY");
            }
        } else {
            if (! defined($gr_props{$id}{base_yr})) {
                $gr_props{$id}{base_yr} = substr($mydates[0],0,4);
            }
            if ($gr_props{$id}{xtype} eq "Date/Time") {
                $jd_min = &datelabel2jdate($gr_props{$id}{xmin});
                $jd_max = &datelabel2jdate($gr_props{$id}{xmax});
            } else {
                $base_jd = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
                $jd_min  = $gr_props{$id}{xmin} +$base_jd -1;
                $jd_max  = $gr_props{$id}{xmax} +$base_jd -1;
            }
        }

#       Plot the graph title
        $yp = ($gr_props{$id}{xop_tics} =~ /outside|cross/) ? $y1-18 : $y1-10;
        $canv->create_text(($x1+$x2)/2., $yp,
                           -anchor => 's', 
                           -text   => $gr_props{$id}{gtitle},
                           -fill   => &get_rgb_code("black"),
                           -angle  => 0,
                           -tags   => $gtag . " " . $gtag . "_gtitle",
                           -font   => [-family     => $gr_props{$id}{gtfont},
                                       -size       => $gr_props{$id}{gt_size},
                                       -weight     => $gr_props{$id}{gt_weight},
                                       -slant      => 'roman',
                                       -underline  => 0,
                                       -overstrike => 0,
                                      ]);

#       Plot the X axis -- Date/Time or Julian Date
#       For the date X axis, over-ride any user-supplied axis title
        $axis_props{major}   = $gr_props{$id}{xmajor};
        $axis_props{minor}   = 1;
        $axis_props{pr_tics} = $gr_props{$id}{xpr_tics};
        $axis_props{op_tics} = $gr_props{$id}{xop_tics};
        $axis_props{reverse} = 0;
        $axis_props{font}    = $gr_props{$id}{xfont};
        $axis_props{size1}   = $gr_props{$id}{xl_size};
        $axis_props{size2}   = $gr_props{$id}{xt_size};
        $axis_props{weight1} = $gr_props{$id}{xl_weight};
        $axis_props{weight2} = $gr_props{$id}{xt_weight};
        $axis_props{side}    = "bottom";
        $axis_props{tags}    = $gtag . " " . $gtag . "_xaxis";
        $axis_props{coords}  = [$x1, $y2, $x2, $y2];
        $axis_props{op_loc}  = $y1;
        if ($gr_props{$id}{xtype} eq "Date/Time") {
            $yr_min = substr($gr_props{$id}{xmin},7,4);
            $yr_max = substr($gr_props{$id}{xmax},7,4);
            $yr_max-- if (substr($gr_props{$id}{xmax},0,3) eq "Jan" &&
                          substr($gr_props{$id}{xmax},4,2) eq "01");
            if ($yr_min == $yr_max) {
                $gr_props{$id}{xtitle} = "Date in $yr_min";
            } else {
                $gr_props{$id}{xtitle} = "Date ($yr_min-$yr_max)";
            }
            $axis_props{min}     = $jd_min;
            $axis_props{max}     = $jd_max;
            $axis_props{title}   = $gr_props{$id}{xtitle};
            $axis_props{datefmt} = $gr_props{$id}{datefmt};
            &make_date_axis($canv, %axis_props);
        } else {
            $axis_props{min}     = $gr_props{$id}{xmin};
            $axis_props{max}     = $gr_props{$id}{xmax};
            $axis_props{title}   = $gr_props{$id}{xtitle};
            &make_axis($canv, %axis_props);
        }
        undef %axis_props;

#       Plot the optional dateline
        if ($gr_props{$id}{dateline}) {
            $add_dateline = 0;
            for ($i=0; $i<=$#animate_ids; $i++) {
                $id2 = $animate_ids[$i];
                next if ($id2 == $id);
                next if ($props{$id2}{meta}
                          !~ /^(data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)$/);
                if ($dti != 1) {
                    $add_dateline = 1;
                    last;
                }
            }
            if ($add_dateline) {
                $jd = &date2jdate($dates[$dti-1]);
                if ($jd >= $jd_min && $jd <= $jd_max) {
                    $xp = $x1 + ($x2 -$x1) *($jd -$jd_min)/($jd_max -$jd_min);
                    $canv->create_line($xp, $y1, $xp, $y2,
                                       -fill  => &get_rgb_code($gr_props{$id}{datelinec}),
                                       -width => 1,
                                       -arrow => 'none',
                                       -tags  => $gtag . " " . $gtag . "_colorMapDateline");
                }
            }
        }

#       Don't recompute and redraw unless necessary
        if (! $gr_props{$id}{redraw}) {
            $canv->lower($gtag . "_colorKey",         $id);
            $canv->lower($gtag . "_colorKeyTitle",    $id);
            $canv->lower($gtag . "_gtitle",           $id);
            $canv->lower($gtag . "_xaxisTitle",       $id);
            $canv->lower($gtag . "_yaxisTitle",       $id);
            $canv->lower($gtag . "_colorMap",         $id);
            $canv->lower($gtag . "_colorMapDateline", $id);
            $canv->lower($gtag . "_xaxis",            $id);
            $canv->lower($gtag . "_yaxis",            $id);
            if ($group_tags) {
                foreach $tag (@grp_tags) {
                    $canv->addtag($tag, withtag => $gtag);
                }
            }
            return;
        }

#       Create an image to hold the colormap and recognize its methods
#       This takes time, so don't redraw if it isn't needed
        $iw = $x2 -$x1 +1;
        $ih = $y2 -$y1 +1;
        $cmap_image = Tkx::image_create_photo(-width => $iw, -height => $ih);
        $cmap_image = Tkx::widget->new($cmap_image);

#       Create a progress bar
        $geom = $main->g_wm_geometry();
        (undef, $X, $Y) = split(/\+/, $geom);
        $geom = sprintf("+%d+%d", $X+($x1+$x2)/2-150, $Y+($y1+$y2)/2);

        $pbar_window = $main->new_toplevel();
        $pbar_window->g_wm_transient($main);
        $pbar_window->g_wm_title("Working on colormap...");
        $pbar_window->g_wm_geometry($geom);
        $pbar_window->configure(-cursor => $cursor_wait);
        $pbar_window->g_focus;

        $pbar_frame = $pbar_window->new_frame(
                        -borderwidth => 2,
                        -relief      => 'groove');
        $pbar_frame->g_pack(-anchor => 'nw', -expand => 1, -fill => 'x');
        ($pbar = $pbar_frame->new_ttk__progressbar(
                        -orient  => 'horizontal',
                        -length  => 300,
                        -mode    => 'determinate',
                        -value   => 0,
                        -maximum => $jd_max -$jd_min,
                        ))->g_pack();

#       Move mouse cursor on first creation, to ensure that it changes to cursor_wait
        if ($move_mcursor) {
            if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
                $mpointerx = Tkx::winfo_pointerx($main);
                $mpointery = Tkx::winfo_pointery($main);
                $canv->g_bind("<Motion>", "");
                Tkx::event_generate($main, "<Motion>", -warp => 1, -x => ($x1+$x2)/2, -y => ($y1+$y2)/2);
                $canv->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"), $canv, "menu" ]);
            }
        }

#       Change the mouse cursor to tell the user to be patient
        if ($resized) {
            $canv->configure(-cursor => $cursor_wait);
        } else {
            Tkx::tk_busy_hold($main, -cursor => $cursor_wait);
        }
        if ($move_mcursor) {
            if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
                Tkx::update();
                $canv->g_bind("<Motion>", "");
                Tkx::event_generate("", "<Motion>", -warp => 1, -x => $mpointerx, -y => $mpointery);
                $canv->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"), $canv, "menu" ]);
            }
        }
        $status_line = "Working on colormap.  Please wait...";
        Tkx::update();
        Tkx::wm_resizable($pbar_window,0,0);

#       Create the colormap
        for ($n=0; $n<=$#jdates; $n++) {
            $jd = $jdates[$n];
            next if ($jd < $jd_min);
            last if ($jd > $jd_max);
            if ($n == 0 || $jd == $jd_min) {
                $jd2 = ($jd +$jdates[$n+1])/2.;
                $xp1 = &round_to_int(($iw-1)*($jd -$jd_min)/($jd_max-$jd_min));
                $xp2 = &round_to_int(($iw-1)*($jd2-$jd_min)/($jd_max-$jd_min));
                next if ($xp1 == $xp2);
            } elsif ($n == $#jdates || $jd == $jd_max) {
                $jd0 = ($jd +$jdates[$n-1])/2.;
                $xp1 = &round_to_int(($iw-1)*($jd0-$jd_min)/($jd_max-$jd_min));
                $xp2 = &round_to_int(($iw-1)*($jd -$jd_min)/($jd_max-$jd_min));
                $xp2 = $iw-1 if (abs($jd_max -$jd) <= 1);
            } else {
                $jd0 = ($jd +$jdates[$n-1])/2.;
                $jd2 = ($jd +$jdates[$n+1])/2.;
                $xp1 = &round_to_int(($iw-1)*($jd0-$jd_min)/($jd_max-$jd_min));
                $xp2 = &round_to_int(($iw-1)*($jd2-$jd_min)/($jd_max-$jd_min));
                next if ($xp1 == $xp2);
            }
            $xp1 = &max(0, &min($iw-1, $xp1));
            $xp2 = &max(0, &min($iw-1, $xp2));
            $pbar->configure(-value => $jd -$jd_min);  # update the progress bar
            Tkx::update_idletasks();

            $dt        = $mydates[$n];
            $nlayers   = $#{ $parm_data{$dt} } +1;
            $surf_elev = $elev_data{$dt};
            $kt        = $kt_data{$dt};
            $kt        = $kb[$seg] if ($kt > $kb[$seg] && $nlayers == 1);

            next if ($nlayers < 1);

            if ($gr_props{$id}{ytype} eq "Depth") {
                $yp2 = 0;
            } else {
                $yp2 = &round_to_int($ih-1 -($ih-1)*($surf_elev-$ymin)/$yrange);
                $yp2 = &max(0, &min($ih-1, $yp2));
            }
            for ($i=0; $i<$nlayers; $i++) {
                $yp1 = $yp2;
                if ($gr_props{$id}{ytype} eq "Depth") {
                    $yp2 = &round_to_int(($ih-1)*($surf_elev-$el[$kt+$i+1][$seg])/$ymax);
                } else {
                    $yp2 = &round_to_int($ih-1 -($ih-1)*($el[$kt+$i+1][$seg]-$ymin)/$yrange);
                }
                last if ($yp1 >= $ih-1);
                if ($yp2 < 0) {
                    $yp2 = 0;
                    next;
                }
                $yp2 = &max(0, &min($ih-1, $yp2));
                if ($props{$id}{parm} eq "Temperature" && $props{$id}{parm_units} eq "Fahrenheit") {
                    $j = int(($#colors+1) *(($parm_data{$dt}[$i] *1.8 +32)-$cs_min)/$cs_range);
                } else {
                    $j = int(($#colors+1) *($parm_data{$dt}[$i]-$cs_min)/$cs_range);
                }
                $j = &max(0, &min($#colors, $j));
                $cmap_image->put($colors[$j], -to => $xp1, $yp1, $xp2, $yp2);
                last if ($yp2 >= $ih-1);
            }
        }
        $canv->create_image($x1, $y1, -anchor => 'nw',
                                      -image  => $cmap_image,
                                      -tags   => $gtag . " " . $gtag . "_colorMap");
        undef $cmap_image;
        undef %kt_data;
        undef %elev_data;
        undef %parm_data;

#       Place the graphic items in the proper order
        &raise_lower($canv, $id, "tiptop") if ($new_graph);
        $canv->lower($gtag . "_colorKey",         $id);
        $canv->lower($gtag . "_colorKeyTitle",    $id);
        $canv->lower($gtag . "_gtitle",           $id);
        $canv->lower($gtag . "_xaxisTitle",       $id);
        $canv->lower($gtag . "_yaxisTitle",       $id);
        $canv->lower($gtag . "_colorMap",         $id);
        $canv->lower($gtag . "_colorMapDateline", $id);
        $canv->lower($gtag . "_xaxis",            $id);
        $canv->lower($gtag . "_yaxis",            $id);
        if ($group_tags) {
            foreach $tag (@grp_tags) {
                $canv->addtag($tag, withtag => $gtag);
            }
        }

#       Restore mouse cursor and remove the progress bar
        $canv->configure(-cursor => $cursor_norm);
        $pbar_window->g_destroy();
        $status_line = "";
        if (! $resized) {
            Tkx::tk_busy_forget($main);
        }
    }
}


sub setup_w2_slice_or_tdmap_or_wlevels {
    my ($canv, $id) = @_;
    my (
        $br_frame, $br_list, $br_start, $br_start_cb, $con_file, $f,
        $frame, $geom, $nbr, $nwb, $ok_btn, $old_br_start, $row, $seg_end,
        $seg_end_cb, $seg_list, $seg_start, $seg_start_cb, $wb_list, $X,
        $x1, $x2, $Y, $y1, $y2,

        @be, @br_cbtn, @br_plot, @bs, @ds, @idn, @us,
       );

    ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $geom = sprintf("+%d+%d", $X+$x1+30, $Y+$y1+50);

    if (defined($w2slice_setup_menu) && Tkx::winfo_exists($w2slice_setup_menu)) {
        if ($w2slice_setup_menu->g_wm_title() eq "W2 Longitudinal Slice Setup"
             || $w2slice_setup_menu->g_wm_title() eq "W2 Time/Distance Map Setup"
             || $w2slice_setup_menu->g_wm_title() eq "W2 Water Levels Graph Setup") {
            $w2slice_setup_menu->g_destroy();
            undef $w2slice_setup_menu;
        }
    }
    $w2slice_setup_menu = $main->new_toplevel();
    $w2slice_setup_menu->g_wm_transient($main);
    $w2slice_setup_menu->configure(-cursor => $cursor_norm);
    $w2slice_setup_menu->g_wm_geometry($geom);
    if ($props{$id}{meta} eq "w2_slice") {
        $w2slice_setup_menu->g_wm_title("W2 Longitudinal Slice Setup");
    } elsif ($props{$id}{meta} eq "w2_tdmap") {
        $w2slice_setup_menu->g_wm_title("W2 Time/Distance Map Setup");
    } elsif ($props{$id}{meta} eq "w2_wlevels") {
        $w2slice_setup_menu->g_wm_title("W2 Water Levels Graph Setup");
    }

#   Try to keep the nascent graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

    $con_file   = "";
    @br_cbtn    = ();
    @br_plot    = ();
    $br_plot[0] = 0;

    $seg_list  = $br_list = $wb_list = "";
    $seg_start = $seg_end = "";
    $br_start  = $old_br_start = "";

    @bs = @be = @us = @ds = @idn = ();

#   Set up the menu
    $frame = $w2slice_setup_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -state   => 'disabled',
            -command => sub { my ($jw, @wbs);
                              if ($con_file eq "" || ! -e $con_file) {
                                  return &pop_up_error($w2slice_setup_menu,
                                  "W2 Control file not set or does not exist:\n$con_file");
                              }
                              if (&sum(@br_plot) < 1) {
                                  return &pop_up_error($w2slice_setup_menu,
                                  "At least one branch must be selected for plotting.");
                              }
                              if ($seg_list eq "" || $wb_list eq "") {
                                  return &pop_up_error($w2slice_setup_menu,
                                  "You must choose a set of segments to plot. Try again.");
                              }
                              @wbs = split(/,/, $wb_list);
                              $wb_list = "";
                              foreach $jw (sort numerically @wbs) {
                                  $wb_list .= "," if ($wb_list ne "");
                                  $wb_list .= $jw;
                              }
                              $props{$id}{con_file} = $con_file;
                              $props{$id}{seg_list} = $seg_list;
                              $props{$id}{wb_list}  = $wb_list;
                              $props{$id}{br_list}  = $br_list;

                              $geom = $w2slice_setup_menu->g_wm_geometry();
                              (undef, $X, $Y) = split(/\+/, $geom);

                              $w2slice_setup_menu->g_bind('<Destroy>', "");
                              $w2slice_setup_menu->g_destroy();
                              undef $w2slice_setup_menu;

                              if ($props{$id}{meta} eq "w2_slice") {
                                  &setup_w2_slice_part2($canv, $id, $X, $Y);
                              } elsif ($props{$id}{meta} eq "w2_tdmap") {
                                  &setup_w2_tdmap_part2($canv, $id, $X, $Y);
                              } elsif ($props{$id}{meta} eq "w2_wlevels") {
                                  &setup_w2_wlevels_part2($canv, $id, $X, $Y);
                              }
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $w2slice_setup_menu->g_bind('<Destroy>', "");
                              $w2slice_setup_menu->g_destroy();
                              undef $w2slice_setup_menu;
                              $canv->delete("graph" . $id);
                              delete $props{$id};
                              delete $grid{$id} if (defined($grid{$id}));
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Delete graph if this menu is destroyed by other than the Cancel button
    $w2slice_setup_menu->g_bind('<Destroy>' => sub { undef $w2slice_setup_menu;
                                                     $canv->delete("graph" . $id);
                                                     delete $props{$id}; 
                                                     delete $grid{$id} if (defined($grid{$id}));
                                                     &reset_bindings;
                                                   });

    ($f = $w2slice_setup_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "W2 Control File: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$con_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);
    $f->new_button(
            -text    => "Browse",
            -command => sub { my ($col, $file, $font, $jb, $jw, $n, $padx, $row, $seg, $status, $txt,
                                  @seg_ds, @seglist,
                                 );
                              $file = Tkx::tk___getOpenFile(
                                      -parent           => $w2slice_setup_menu,
                                      -title            => "Select W2 Control File",
                                      -initialdir       => abs_path(),
                                      -filetypes => [ ['All Files', '*'],
                                                      ['CSV (comma delimited)', '.csv'],
                                                      ['NPT (W2 input file)', '.npt'],
                                                    ],
                                      );
                              if (defined($file) && -e $file) {
                                  $con_file = File::Spec->rel2abs($file);
                                  &read_con($main, $id, $con_file);

                                  $nbr = $grid{$id}{nbr};
                                  $nwb = $grid{$id}{nwb};
                                  @bs  = @{ $grid{$id}{bs}  };
                                  @be  = @{ $grid{$id}{be}  };
                                  @us  = @{ $grid{$id}{us}  };
                                  @ds  = @{ $grid{$id}{ds}  };
                                  @idn = @{ $grid{$id}{idn} };

                                  $br_start_cb->configure(-values => [ (1 .. $nbr) ],
                                                          -state  => 'readonly');
                                  if (&list_match($br_start, (1 .. $nbr)) == -1) {
                                      $br_start = 1;
                                  }
                                  $old_br_start = $br_start;
                                  for ($jw=1; $jw<=$nwb; $jw++) {
                                      last if ($br_start >= $bs[$jw] && $br_start <= $be[$jw]);
                                  }
                                  @seglist = ($us[$br_start] .. $ds[$br_start]);
                                  $seg_start_cb->configure(-values => [ @seglist ],
                                                           -state  => 'readonly');
                                  if ($seg_start eq ""
                                        || &list_match($seg_start, @seglist) == -1) {
                                      $seg_start = $seglist[0];
                                  }
                                  if ($seg_end eq ""
                                        || &list_match($seg_end, @seglist) == -1
                                        || $seg_end < $seg_start) {
                                      $seg_end = $seglist[$#seglist];
                                  }
                                  @seglist = ($seg_start .. $ds[$br_start]);
                                  $seg_end_cb->configure(-values => [ @seglist ],
                                                         -state  => 'readonly');
                                  $br_list  = $br_start;
                                  $wb_list  = $jw;
                                  $seg_list = $seg_start . "-" . $seg_end;

                                  for ($n=0; $n<=$#br_cbtn; $n++) {
                                      $br_cbtn[$n]->g_pack_forget();
                                  }
                                  @br_cbtn = @seg_ds = @br_plot = ();
                                  @seg_ds  = split(/,/, $idn[$br_start]);
                                  for ($jb=1; $jb<=$nbr; $jb++) {
                                      $n   = $jb -1;
                                      if ($nbr > 6) {
                                          $row  = int($n /2 +0.001);
                                          $col  = $n -2*$row;
                                          $padx = ($col == 1) ? 3 : 0;
                                      } else {
                                          $row = $n;
                                          $col = $padx = 0;
                                      }
                                      if ($jb == $br_start) {
                                          $br_plot[$n] = 1;
                                          $font   = 'bo';
                                          $status = 'normal';
                                      } else {
                                          $br_plot[$n] = 0;
                                          $font   = 'default';
                                          $status = 'disabled';
                                          foreach $seg (@seg_ds) {
                                              if ($seg >= $us[$jb] && $seg <= $ds[$jb]) {
                                                  $status = 'normal';
                                                  last;
                                              }
                                          }
                                      }
                                      $txt = "Branch " . $jb . ", Segments " . $us[$jb] . "-" . $ds[$jb];
                                      ($br_cbtn[$n] = $br_frame->new_checkbutton(
                                          -onvalue  => 1,
                                          -offvalue => 0,
                                          -text     => $txt,
                                          -font     => $font,
                                          -state    => $status,
                                          -variable => \$br_plot[$n],
                                          -command  =>
                                           [ sub { my ($n) = @_;
                                                   my ($br_pos, $j, $jb, $jw, $nn, $seg,
                                                       @brs, @seg_ds, @seglist, @wb_tmp,
                                                      );
                                                   $jb = $n +1;
                                                   if ($br_plot[$n]) {
                                                       $br_cbtn[$n]->configure(-font => 'bo');
                                                       $br_list .= "," if ($br_list ne "");
                                                       $br_list .= $jb;
                                                       if ($br_start eq "") {
                                                           $br_start = $jb;
                                                           for ($nn=0; $nn<=$#br_cbtn; $nn++) {
                                                               next if ($nn == $jb-1);
                                                               $br_cbtn[$nn]->configure(-state => 'disabled');
                                                           }
                                                           @seglist = ($us[$jb] .. $ds[$jb]);
                                                           $seg_start_cb->configure(-values => [ @seglist ],
                                                                                    -state  => 'readonly');
                                                           $seg_end_cb->configure(-state => 'readonly');
                                                           if ($seg_start eq ""
                                                                 || &list_match($seg_start, @seglist) == -1) {
                                                               $seg_start = $seglist[0];
                                                           }
                                                       }
                                                   } else {
                                                       @brs = split(/,/, $br_list);
                                                       $br_list = "";
                                                       $br_pos = &list_match($jb, @brs);
                                                       for ($j=0; $j<=$#brs; $j++) {
                                                           if ($j < $br_pos) {
                                                               $br_list .= "," if ($br_list ne "");
                                                               $br_list .= $brs[$j];
                                                               next;
                                                           }
                                                           $nn = $brs[$j] -1;
                                                           $br_plot[$nn] = 0;
                                                           $br_cbtn[$nn]->configure(-font  => 'default',
                                                                                    -state => 'disabled');
                                                       }
                                                       @seg_ds = split(/,/, $idn[$brs[$#brs]]);
                                                       foreach $seg (@seg_ds) {
                                                           for ($jb=1; $jb<=$nbr; $jb++) {
                                                               next if ($seg < $us[$jb] || $seg > $ds[$jb]);
                                                               $nn = $jb -1;
                                                               $br_cbtn[$nn]->configure(-state => 'disabled');
                                                           }
                                                       }
                                                   }
                                                   @brs = split(/,/, $br_list);
                                                   if ($#brs >= 0) {
                                                       @seg_ds = split(/,/, $idn[$brs[$#brs]]);
                                                       foreach $seg (@seg_ds) {
                                                           for ($jb=1; $jb<=$nbr; $jb++) {
                                                               next if ($seg < $us[$jb] || $seg > $ds[$jb]);
                                                               $nn = $jb -1;
                                                               $br_cbtn[$nn]->configure(-state => 'normal');
                                                           }
                                                       }
                                                   } else {
                                                       $br_start = $seg_start = $seg_end = "";
                                                       $br_start_cb->configure(-values => [(1 .. $nbr)]);
                                                       $seg_start_cb->configure(-values => [(2)],
                                                                                -state  => 'disabled');
                                                       $seg_end_cb->configure(-values => [(2)],
                                                                              -state  => 'disabled');
                                                       for ($nn=0; $nn<=$#br_cbtn; $nn++) {
                                                           $br_cbtn[$nn]->configure(-state => 'normal');
                                                       }
                                                   }
                                                   $seg_list = $wb_list = "";
                                                   for ($j=0; $j<=$#brs; $j++) {
                                                       $jb = $brs[$j];
                                                       for ($jw=1; $jw<=$nwb; $jw++) {
                                                           last if ($jb >= $bs[$jw] && $jb <= $be[$jw]);
                                                       }
                                                       if ($wb_list ne "") {
                                                           @wb_tmp = split(/,/, $wb_list);
                                                           if (&list_match($jw, @wb_tmp) == -1) {
                                                               $wb_list .= "," . $jw;
                                                           }
                                                       } else {
                                                           $wb_list .= $jw;
                                                       }
                                                       if ($jb == $br_start) {
                                                           $seg_list = $seg_start . "-" . $ds[$jb];
                                                       } else {
                                                           @seg_ds = split(/,/, $idn[$brs[$j-1]]);
                                                           foreach $seg (@seg_ds) {
                                                               if ($seg >= $us[$jb] && $seg <= $ds[$jb]) {
                                                                   $seg_list .= "," . $seg . "-" . $ds[$jb];
                                                                   last;
                                                               }
                                                           }
                                                       }
                                                       if ($j == $#brs) {
                                                           if ($seg_list =~ /,/) {
                                                               ($seg = $seg_list) =~ s/^.*,(\d+)-\d+$/$1/;
                                                           } else {
                                                               $seg = $seg_start;
                                                           }
                                                           @seglist = ($seg .. $ds[$jb]);
                                                           $seg_end_cb->configure(-values => [ @seglist ]);
                                                           if (&list_match($seg_end, @seglist) == -1) {
                                                               $seg_end = $seglist[$#seglist];
                                                           }
                                                       }
                                                   }
                                                   if (&sum(@br_plot) == 0) {
                                                       $ok_btn->configure(-state => 'disabled');
                                                   } else {
                                                       $ok_btn->configure(-state => 'normal');
                                                   }
                                                 }, $n],
                                           ))->g_grid(-row => $row, -column => $col,
                                                      -sticky => 'w', -ipadx => $padx, -pady => 1);
                                  }
                                  $ok_btn->configure(-state => 'normal');
                              } else {
                                  $ok_btn->configure(-state => 'disabled');
                              }
                            },
            )->g_grid(-row => $row, -column => 4, -sticky => 'ew', -padx => 2, -pady => 2);

    $row++;
    $f->new_label(
            -text => "Start Branch: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($br_start_cb = $f->new_ttk__combobox(
            -textvariable => \$br_start,
            -values       => [ (1) ],
            -state        => 'disabled',
            -width        => 5,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w');
    $br_start_cb->g_bind("<<ComboboxSelected>>",
                          sub { my ($font, $jb, $jw, $n, $seg, $status,
                                    @seg_ds, @seglist,
                                   );
                                return if ($br_start == $old_br_start);
                                for ($jw=1; $jw<=$nwb; $jw++) {
                                    last if ($br_start >= $bs[$jw] && $br_start <= $be[$jw]);
                                }
                                @seglist = ($us[$br_start] .. $ds[$br_start]);
                                $seg_start_cb->configure(-values => [ @seglist ],
                                                         -state  => 'readonly');
                                if ($seg_start eq ""
                                      || &list_match($seg_start, @seglist) == -1) {
                                    $seg_start = $seglist[0];
                                }
                                @seglist = ($seg_start .. $ds[$br_start]);
                                if ($seg_end eq ""
                                      || &list_match($seg_end, @seglist) == -1
                                      || $seg_end < $seg_start) {
                                    $seg_end = $seglist[$#seglist];
                                }
                                $seg_end_cb->configure(-values => [ @seglist ],
                                                       -state  => 'readonly');
                                $br_list  = $br_start;
                                $wb_list  = $jw;
                                $seg_list = $seg_start . "-" . $seg_end;

                                @seg_ds = split(/,/, $idn[$br_start]);
                                for ($jb=1; $jb<=$nbr; $jb++) {
                                    $n = $jb -1;
                                    if ($jb == $br_start) {
                                        $br_plot[$n] = 1;
                                        $font   = 'bo';
                                        $status = 'normal';
                                    } else {
                                        $br_plot[$n] = 0;
                                        $font   = 'default';
                                        $status = 'disabled';
                                        foreach $seg (@seg_ds) {
                                            if ($seg >= $us[$jb] && $seg <= $ds[$jb]) {
                                                $status = 'normal';
                                                last;
                                            }
                                        }
                                    }
                                    $br_cbtn[$n]->configure(-font  => $font,
                                                            -state => $status);
                                }
                                if (&sum(@br_plot) == 0) {
                                    $ok_btn->configure(-state => 'disabled');
                                } else {
                                    $ok_btn->configure(-state => 'normal');
                                }
                                $old_br_start = $br_start;
                              });

    $row++;
    $f->new_label(
            -text => "First Segment: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($seg_start_cb = $f->new_ttk__combobox(
            -textvariable => \$seg_start,
            -values       => [ (2) ],
            -state        => 'disabled',
            -width        => 5,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    $seg_start_cb->g_bind("<<ComboboxSelected>>",
                           sub { my ($jb, @seglist);
                                 for ($jb=1; $jb<=$nbr; $jb++) {
                                     last if ($seg_start >= $us[$jb] && $seg_start <= $ds[$jb]);
                                 }
                                 if ($seg_list =~ /,/) {
                                     $seg_list =~ s/^\d+-/${seg_start}-/;
                                 } else {
                                     @seglist = ($seg_start .. $ds[$jb]);
                                     $seg_end_cb->configure(-values => [ @seglist ]);
                                     if ($seg_end eq "" || $seg_end < $seg_start) {
                                         $seg_end = $ds[$jb];
                                     }
                                     $seg_list = $seg_start . "-" . $seg_end;
                                 }
                               });

    $row++;
    $f->new_label(
            -text    => "Include Next  \nDS Branch? ",
            -justify => 'right',
            -font    => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'ne', -pady => 2);
    ($br_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    ($br_cbtn[0] = $br_frame->new_checkbutton(
            -onvalue  => 1,
            -offvalue => 0,
            -text     => "Branch 1",
            -font     => 'default',
            -state    => 'disabled',
            -variable => \$br_plot[0],
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Last Segment: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($seg_end_cb = $f->new_ttk__combobox(
            -textvariable => \$seg_end,
            -values       => [ (2) ],
            -state        => 'disabled',
            -width        => 5,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    $seg_end_cb->g_bind("<<ComboboxSelected>>", sub { $seg_list =~ s/-\d+$/-${seg_end}/; });

    $row++;
    $f->new_label(
            -text => "Segments: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$seg_list,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');

    $row++;
    $f->new_label(
            -text => "Branches: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$br_list,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');

    $row++;
    $f->new_label(
            -text => "Waterbodies: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$wb_list,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');

    $f->g_grid_columnconfigure(3, -weight => 2, -minsize => 70);

    Tkx::wm_resizable($w2slice_setup_menu,0,0);
    &adjust_window_position($w2slice_setup_menu);
    $w2slice_setup_menu->g_focus;
}


sub setup_w2_slice_part2 {
    my ($canv, $id, $X, $Y) = @_;
    my (
        $fr, $frame, $frame2, $geom, $jw, $n, $ok_btn, $oldsrc_type, $row,
        $sc_canv, $sc_fr, $src_type, $src_type_cb, $txt, $vscroll, $w2l_btn,
        $w2l_file, $w2l_first_jd, $w2l_label1, $w2l_label2, $w2l_last_jd,

        @bth_files, @cbtn, @clab1, @clab2, @cpl_fdates, @cpl_files,
        @cpl_ldates, @cpl_lines, @f, @parmlist, @tecplot, @w2l_parms, @wbs,
       );

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($w2slice_setup_menu) && Tkx::winfo_exists($w2slice_setup_menu)) {
        if ($w2slice_setup_menu->g_wm_title() eq "W2 Longitudinal Slice Setup") {
            $w2slice_setup_menu->g_destroy();
            undef $w2slice_setup_menu;
        }
    }
    $w2slice_setup_menu = $main->new_toplevel();
    $w2slice_setup_menu->g_wm_transient($main);
    $w2slice_setup_menu->g_wm_title("W2 Longitudinal Slice Setup");
    $w2slice_setup_menu->configure(-cursor => $cursor_norm);
    $w2slice_setup_menu->g_wm_geometry($geom);

#   Try to keep the nascent graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

    @wbs          = split(/,/, $props{$id}{wb_list});
    @cpl_files    = @cpl_lines = @cpl_fdates = @cpl_ldates = ();
    @bth_files    = @parmlist  = @tecplot    = @w2l_parms = ();
    $src_type     = "W2 Contour File";
    $oldsrc_type  = $src_type;
    $w2l_file     = "";
    $w2l_first_jd = $w2l_last_jd = 0;
    for ($n=0; $n<=$#wbs; $n++) {
        $cpl_files[$n] = "          ";
        $bth_files[$n] = "";
    }

#   Set up the menu
    $frame = $w2slice_setup_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -state   => 'disabled',
            -command => sub { my ($first_jd, $i, $j, $jw1, $jw2, $last_jd, $mismatch, $n, $parm,
                                  @cpld, @cplf, @ncpl, @parm_tmp, @plist, %parms);
                              if ($src_type =~ /Contour/i) {
                                  for ($n=0; $n<=$#wbs; $n++) {
                                      if ($cpl_files[$n] eq "" || $cpl_files[$n] eq "          "
                                                               || ! -e $cpl_files[$n]) {
                                          return &pop_up_error($w2slice_setup_menu,
                                          "W2 Contour file not set or does not exist:\n$cpl_files[$n]");
                                      }
                                  }

#                                 Ensure contour dates and frequencies are identical for all waterbodies
                                  $first_jd = $cpl_fdates[0];
                                  $last_jd  = $cpl_ldates[0];
                                  if ($#wbs > 0) {
                                      @ncpl = @{ $grid{$id}{ncpl} };
                                      @cpld = @{ $grid{$id}{cpld} };
                                      @cplf = @{ $grid{$id}{cplf} };
                                      $mismatch = 0;
                                      for ($j=0; $j<=$#wbs; $j++) {
                                          $jw1 = $wbs[$j];
                                          for ($n=$j+1; $n<=$#wbs; $n++) {
                                              $jw2 = $wbs[$n];
                                              if ($ncpl[$jw1] != $ncpl[$jw2]) {
                                                  $mismatch = 1;
                                                  last;
                                              }
                                              for ($i=1; $i<=$ncpl[$jw1]; $i++) {
                                                  if ($cpld[$i][$jw1] != $cpld[$i][$jw2] ||
                                                      $cplf[$i][$jw1] != $cplf[$i][$jw2]) {
                                                      $mismatch = 1;
                                                      last;
                                                  }
                                              }
                                              last if ($mismatch);
                                          }
                                          last if ($mismatch);
                                      }
                                      if ($mismatch) {
                                          return &pop_up_error($w2slice_setup_menu,
                                              "The contour plot output dates and frequencies for\n"
                                            . "the chosen waterbodies do not match. Please try again.");
                                      }
                                      $mismatch = 0;
                                      for ($j=0; $j<=$#wbs; $j++) {
                                          for ($n=$j+1; $n<=$#wbs; $n++) {
                                              if (abs($cpl_fdates[$j] -$cpl_fdates[$n]) > 0.0007 ||
                                                  abs($cpl_ldates[$j] -$cpl_ldates[$n]) > 0.0007) {
                                                  $mismatch = 1;
                                                  last;
                                              }
                                          }
                                          last if ($mismatch);
                                      }
                                      if ($mismatch) {
                                          return &pop_up_error($w2slice_setup_menu,
                                              "The contour plot output start and end dates for the\n"
                                            . "chosen waterbodies do not match. Please try again.");
                                      }
                                  }

#                                 Only keep parameters common to all contour output files
                                  @plist = @{ $parmlist[0] };
                                  for ($n=1; $n<=$#wbs; $n++) {
                                      @parm_tmp = ();
                                      foreach $parm ( @{ $parmlist[$n] } ) {
                                          if (&list_match($parm, @plist) >= 0) {
                                              push (@parm_tmp, $parm);
                                          }
                                      }
                                      @plist = @parm_tmp;
                                  }
                                  if ($#plist < 0) {
                                      return &pop_up_error($w2slice_setup_menu,
                                        "No parameters are common to all of the W2 Contour files.");
                                  }
                                  %parms                 = ();
                                  $parms{first_jd}       = $first_jd;
                                  $parms{last_jd}        = $last_jd;
                                  $parms{parms}          = [ @plist     ];
                                  $props{$id}{tecplot}   = [ @tecplot   ];
                                  $props{$id}{cpl_lines} = [ @cpl_lines ];
                                  $props{$id}{cpl_files} = [ @cpl_files ];

                              } elsif ($src_type =~ /Vector/i) {
                                  if ($w2l_file eq "" || ! -e $w2l_file) {
                                      return &pop_up_error($w2slice_setup_menu,
                                      "W2 Vector file not set or does not exist:\n$w2l_file");
                                  }
                                  %parms                = ();
                                  $parms{parms}         = [ @w2l_parms ];
                                  $parms{first_jd}      = $w2l_first_jd;
                                  $parms{last_jd}       = $w2l_last_jd;
                                  $props{$id}{w2l_file} = $w2l_file;
                              }

                              for ($n=0; $n<=$#wbs; $n++) {
                                  if ($bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                      return &pop_up_error($w2slice_setup_menu,
                                      "W2 Bathymetry file not set or does not exist:\n$bth_files[$n]");
                                  }
                              }
                              $props{$id}{files}     = 1;
                              $props{$id}{parms}     = { %parms };
                              $props{$id}{src_type}  = $src_type;
                              $props{$id}{bth_files} = [ @bth_files ];

                              $geom = $w2slice_setup_menu->g_wm_geometry();
                              (undef, $X, $Y) = split(/\+/, $geom);

                              $w2slice_setup_menu->g_bind('<Destroy>', "");
                              $w2slice_setup_menu->g_destroy();
                              undef $w2slice_setup_menu;

                              &setup_w2_slice_part3($canv, $id, $X, $Y);
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);

    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $w2slice_setup_menu->g_bind('<Destroy>', "");
                              $w2slice_setup_menu->g_destroy();
                              undef $w2slice_setup_menu;
                              $canv->delete("graph" . $id);
                              delete $props{$id};
                              delete $grid{$id};
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Delete graph if this menu is destroyed by other than the Cancel button
    $w2slice_setup_menu->g_bind('<Destroy>' => sub { undef $w2slice_setup_menu;
                                                     $canv->delete("graph" . $id);
                                                     delete $props{$id}; 
                                                     delete $grid{$id};
                                                     &reset_bindings;
                                                   });

#   Need a scrollable container, and a canvas is about the only container that works.
#   Create a parent frame (sc_fr) for the canvas (sc_canv) and scrollbar (vscroll).
#   Then put a frame inside the canvas (fr) as a widget window to hold other menu items.
    ($sc_fr = $w2slice_setup_menu->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_pack(-side => 'top', -expand => 1, -fill => 'both');
    ($vscroll = $sc_fr->new_scrollbar(
            -orient => 'vertical',
            -width  => 15,
            ))->g_grid(-row => 0, -column => 1, -sticky => 'nse');
    ($sc_canv = $sc_fr->new_tk__canvas(
            -highlightthickness => 0,
            -yscrollcommand => [$vscroll, 'set'],
            ))->g_grid(-row => 0, -column => 0, -sticky => 'nsew');
    $vscroll->configure(-command => [$sc_canv, 'yview']);

    $fr = $sc_canv->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );

#   Source type
    $row = 0;
    $fr->new_label(
            -text => "W2 Source Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($src_type_cb = $fr->new_ttk__combobox(
            -textvariable => \$src_type,
            -values       => [ ("W2 Contour File", "W2 Vector File") ],
            -width        => 16,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $src_type_cb->g_bind("<<ComboboxSelected>>",
                          sub { my ($n, $status);
                                return if ($src_type eq $oldsrc_type);
                                $oldsrc_type = $src_type;
                                $status      = 'normal';
                                if ($src_type =~ /Contour/i) {
                                    $w2l_label1->g_grid_remove();
                                    $w2l_label2->g_grid_remove();
                                    $w2l_btn->g_grid_remove();
                                    for ($n=0; $n<=$#wbs; $n++) {
                                        $clab1[$n]->g_grid();
                                        $clab2[$n]->g_grid();
                                        $cbtn[$n]->g_grid();
                                    }
                                    $frame2->g_grid() if ($#wbs > 0);
                                    for ($n=0; $n<=$#wbs; $n++) {
                                        if ($cpl_files[$n] eq "          " ||
                                            $cpl_files[$n] eq "" || ! -e $cpl_files[$n] ||
                                            $bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                            $status = 'disabled';
                                            last;
                                        }
                                    }
                                } else {
                                    $frame2->g_grid_remove() if ($#wbs > 0);
                                    for ($n=0; $n<=$#wbs; $n++) {
                                        $clab1[$n]->g_grid_remove();
                                        $clab2[$n]->g_grid_remove();
                                        $cbtn[$n]->g_grid_remove();
                                    }
                                    $w2l_label1->g_grid();
                                    $w2l_label2->g_grid();
                                    $w2l_btn->g_grid();
                                    if ($w2l_file eq "" || ! -e $w2l_file) {
                                        $status = 'disabled';
                                    } else {
                                        for ($n=0; $n<=$#wbs; $n++) {
                                            if ($bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                                $status = 'disabled';
                                                last;
                                            }
                                        }
                                    }
                                }
                                $ok_btn->configure(-state => $status);
                                &update_scrollable_menu($w2slice_setup_menu, $sc_fr, $sc_canv,
                                                        'scrollable', $vscroll);
                              });

#   Input fields for W2 Vector file
    $row++;
    ($w2l_label1 = $fr->new_label(
            -text => "W2 Vector File: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($w2l_label2 = $fr->new_label(
            -textvariable => \$w2l_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
    ($w2l_btn = $fr->new_button(
            -text    => "Browse",
            -command =>
               sub { my ($file, $first_jd, $last_jd, $n, $ok, $parms_ref, $status);
                     $file = Tkx::tk___getOpenFile(
                             -parent    => $w2slice_setup_menu,
                             -title     => "Select W2 Vector Output File",
                             -filetypes => [ ['All Files', '*'],
                                             ['W2L (W2 Vector)', '.w2l'],
                                           ],
                             );
                     if (defined($file) && -e $file) {
                         $w2l_file = File::Spec->rel2abs($file);
                         $status_line = "Scanning W2 vector file...";  # no progress bar needed
                         &update_scrollable_menu($w2slice_setup_menu,
                                                 $sc_fr, $sc_canv, 'scrollable', $vscroll);
                         Tkx::update_idletasks();
                         ($ok, $parms_ref, undef, $first_jd, $last_jd)
                             = &scan_w2_vector_file($w2slice_setup_menu, $w2l_file, $id, 1);
                         $status_line = "";
                         if ($ok ne "okay") {
                             $w2l_file = "";
                             $ok_btn->configure(-state => 'disabled');
                             &update_scrollable_menu($w2slice_setup_menu,
                                                     $sc_fr, $sc_canv, 'scrollable', $vscroll);
                             return &pop_up_error($w2slice_setup_menu,
                                              "The specified file is not a W2 Vector (w2l) file:\n$file");
                         }
                         @w2l_parms    = @{ $parms_ref };
                         $w2l_first_jd = $first_jd;
                         $w2l_last_jd  = $last_jd;
                         $status = 'normal';
                         for ($n=0; $n<=$#wbs; $n++) {
                             if ($bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                 $status = 'disabled';
                                 last;
                             }
                         }
                         $ok_btn->configure(-state => $status);
                     } else {
                         $ok_btn->configure(-state => 'disabled');
                     }
                     &update_scrollable_menu($w2slice_setup_menu, $sc_fr, $sc_canv, 'scrollable', $vscroll);
                   },
            ))->g_grid(-row => $row, -column => 2, -sticky => 'ew', -padx => 2, -pady => 2);

    $fr->g_grid_columnconfigure(1, -weight => 2);
    $w2l_label1->g_grid_remove();
    $w2l_label2->g_grid_remove();
    $w2l_btn->g_grid_remove();

#   Loop over the required waterbodies
    for ($n=0; $n<=$#wbs; $n++) {
        $jw = $wbs[$n];

        $row++;
        ($f[$n] = $fr->new_labelframe(
                    -borderwidth => 1,
                    -relief      => 'groove',
                    -text        => "Waterbody $jw",
                ))->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew', -pady => 2);

        ($clab1[$n] = $f[$n]->new_label(
                -text => "W2 Contour File: ",
                -font => 'default',
                ))->g_grid(-row => 0, -column => 0, -sticky => 'e', -pady => 2);
        ($clab2[$n] = $f[$n]->new_label(
                -textvariable => \$cpl_files[$n],
                -anchor       => 'w',
                -font         => 'default',
                -background   => 'white',
                -relief       => 'sunken',
                -borderwidth  => 1,
                ))->g_grid(-row => 0, -column => 1, -sticky => 'ew', -pady => 2);
        ($cbtn[$n] = $f[$n]->new_button(
                -text    => "Browse",
                -command =>
                 [ sub { my ($n) = @_;
                         my ($file, $first_jd, $jw_src, $last_jd, $nlines, $parms_ref,
                             $pbar, $pbar_img, $pbar_win, $status, $tecplot,
                            );
                         $file = Tkx::tk___getOpenFile(
                                 -parent    => $w2slice_setup_menu,
                                 -title     => "Select W2 Contour Output File",
                                 -filetypes => [ ['All Files', '*'],
                                                 ['CSV (comma delimited)', '.csv'],
                                                 ['OPT (W2 output files)', '.opt'],
                                               ],
                                 );
                         if (defined($file) && -e $file) {
                             $cpl_files[$n] = File::Spec->rel2abs($file);
                             &update_scrollable_menu($w2slice_setup_menu, $sc_fr, $sc_canv,
                                                     'scrollable', $vscroll);
                             ($pbar_win, $pbar, $pbar_img)
                                 = &create_alt_progress_bar($main, $id,
                                                            "Scanning W2 contour file...");
                             ($tecplot, $nlines, $jw_src, $parms_ref, $first_jd, $last_jd)
                                 = &scan_w2_cpl_file($w2slice_setup_menu, $cpl_files[$n], $id, 1, $pbar_img);
                             &destroy_progress_bar($main, $pbar_win);

                             if ($tecplot == -1) {
                                 $cpl_files[$n] = "          ";
                                 $ok_btn->configure(-state => 'disabled');
                                 &update_scrollable_menu($w2slice_setup_menu, $sc_fr, $sc_canv,
                                                         'scrollable', $vscroll);
                                 return &pop_up_error($w2slice_setup_menu,
                                     "Specified file is not a W2 Contour output file:\n$file");
                             }
                             if ($tecplot == 0 && $jw_src != $wbs[$n]) {
                                 $cpl_files[$n] = "          ";
                                 $ok_btn->configure(-state => 'disabled');
                                 &update_scrollable_menu($w2slice_setup_menu, $sc_fr, $sc_canv,
                                                         'scrollable', $vscroll);
                                 return &pop_up_error($w2slice_setup_menu,
                                         "The specified W2 Contour output file does not\n"
                                       . "appear to be from the correct waterbody:\n"
                                       . "(" . $jw_src . " rather than " . $wbs[$n] . "):\n$file");
                             }
                             $tecplot[$n]    = $tecplot;
                             $cpl_lines[$n]  = $nlines;
                             $cpl_fdates[$n] = $first_jd;
                             $cpl_ldates[$n] = $last_jd;
                             $parmlist[$n]   = [ @{ $parms_ref } ];

                             $status = 'normal';
                             for ($n=0; $n<=$#wbs; $n++) {
                                 if ($cpl_files[$n] eq "          " ||
                                     $cpl_files[$n] eq "" || ! -e $cpl_files[$n] ||
                                     $bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                     $status = 'disabled';
                                     last;
                                 }
                             }
                             $ok_btn->configure(-state => $status);
                         } else {
                             $ok_btn->configure(-state => 'disabled');
                         }
                         &update_scrollable_menu($w2slice_setup_menu, $sc_fr, $sc_canv,
                                                 'scrollable', $vscroll);
                       }, $n ],
                ))->g_grid(-row => 0, -column => 2, -sticky => 'ew', -padx => 2, -pady => 2);

        $f[$n]->new_label(
                -text => "W2 Bathymetry File: ",
                -font => 'default',
                )->g_grid(-row => 1, -column => 0, -sticky => 'e', -pady => 2);
        $f[$n]->new_label(
                -textvariable => \$bth_files[$n],
                -anchor       => 'w',
                -font         => 'default',
                -background   => 'white',
                -relief       => 'sunken',
                -borderwidth  => 1,
                )->g_grid(-row => 1, -column => 1, -sticky => 'ew', -pady => 2);
        $f[$n]->new_button(
                -text    => "Browse",
                -command =>
                 [ sub { my ($n) = @_;
                         my ($file, $status);
                         $file = Tkx::tk___getOpenFile(
                                 -parent           => $w2slice_setup_menu,
                                 -title            => "Select W2 Bathymetry File",
                                 -defaultextension => ".csv",
                                 -filetypes => [ ['CSV (comma delimited)', '.csv'],
                                                 ['NPT (W2 input files)', '.npt'],
                                                 ['All Files', '*'],
                                               ],
                                 );
                         if (defined($file) && -e $file) {
                             $bth_files[$n] = File::Spec->rel2abs($file);
                             $status = 'normal';
                             for ($n=0; $n<=$#wbs; $n++) {
                                 if ($src_type =~ /Contour/i) {
                                     if ($cpl_files[$n] eq "          " ||
                                         $cpl_files[$n] eq "" || ! -e $cpl_files[$n] ||
                                         $bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                         $status = 'disabled';
                                         last;
                                     }
                                 } else {
                                     if ($w2l_file      eq "" || ! -e $w2l_file ||
                                         $bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                         $status = 'disabled';
                                         last;
                                     }
                                 }
                             }
                             $ok_btn->configure(-state => $status);
                         } else {
                             $ok_btn->configure(-state => 'disabled');
                         }
                         &update_scrollable_menu($w2slice_setup_menu, $sc_fr, $sc_canv,
                                                 'scrollable', $vscroll);
                       }, $n ],
                )->g_grid(-row => 1, -column => 2, -sticky => 'ew', -padx => 2, -pady => 2);

        $f[$n]->g_grid_columnconfigure(1, -weight => 2);
    }

    if ($#wbs > 0) {
        $row++;
        ($frame2 = $fr->new_frame(
                    -borderwidth => 1,
                    -relief      => 'groove',
                ))->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew');

        $txt = "Note that this program works best when the contour output files from\n"
             . "each waterbody are assigned the same output dates and output frequencies.\n"
             . "In addition, each is required to include data for the parameter being plotted.";
        $frame2->new_label(
                -text    => $txt,
                -font    => 'default',
                -justify => 'left',
                )->g_pack(-side => 'left', -anchor => 'n', -expand => 1, -fill => 'x', -pady => 2);
    }

    $sc_canv->create_window(0, 0,
            -anchor => 'nw',
            -window => $fr,
            -tags   => 'scrollable',
            );
    &update_scrollable_menu($w2slice_setup_menu, $sc_fr, $sc_canv, 'scrollable', $vscroll);
    $sc_fr->g_grid_columnconfigure(0, -weight => 1);

    Tkx::wm_resizable($w2slice_setup_menu,0,0);
    &adjust_window_position($w2slice_setup_menu);
    $w2slice_setup_menu->g_focus;
}


sub setup_w2_slice_part3 {
    my ($canv, $id, $X, $Y) = @_;
    my (
        $bdate, $bdate_frame, $bdate_label, $bday, $bday_cb, $begin_jd,
        $bm, $bmon, $bmon_cb, $byear, $byear_cb, $byr, $byr_cb,
        $conv_add, $conv_add_entry, $conv_mult, $conv_mult_entry,
        $conv_type, $conv_type_cb, $conv_type_na_label, $cscheme,
        $cscheme_cb, $custom_frame, $data_frame, $data_range, $edate,
        $edate_frame, $edate_label, $eday, $eday_cb, $elev_base, $em,
        $emon, $emon_cb, $eyr, $eyr_cb, $f, $first_jd, $frame, $geom,
        $gtitle, $i, $jd_skip, $jd_skip_active, $jd_skip_explain, $jd1,
        $jd2, $jw, $last_jd, $limit_dates, $n, $ncolors, $ncolors_cb,
        $offset_frame, $ok_btn, $old_units, $oldparm, $oldparm_short, $parm,
        $parm_cb, $parm_chars, $parm_div, $parm_div_cb, $parm_div_label,
        $parm_frame, $parm_short, $pmax, $pmax_entry, $pmin, $pmin_entry,
        $row, $src_type, $title, $tz_offset, $tzoff_cb, $units, $units_cb,
        $units_entry, $xaxis_flip, $xaxis_frame, $xaxis_units, $yaxis_type,
        $yaxis_type_cb, $yaxis_units, $yaxis_units_label, $ymajor,
        $ymajor_entry, $ymajor_label, $ymax, $ymax_entry, $ymax_label,
        $ymin, $ymin_entry, $ymin_label, $ymin_units_label, $yr_max, $yr_min,

        @cmaps, @cplf, @jd_skip_opts, @ncpl, @nvpl, @parm_divlist, @parmlist,
        @vplf, @wbs,

        %parms,
       );

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($w2slice_setup_menu) && Tkx::winfo_exists($w2slice_setup_menu)) {
        if ($w2slice_setup_menu->g_wm_title() eq "W2 Longitudinal Slice Setup") {
            $w2slice_setup_menu->g_destroy();
            undef $w2slice_setup_menu;
        }
    }
    $w2slice_setup_menu = $main->new_toplevel();
    $w2slice_setup_menu->g_wm_transient($main);
    $w2slice_setup_menu->g_wm_title("W2 Longitudinal Slice Setup");
    $w2slice_setup_menu->configure(-cursor => $cursor_norm);
    $w2slice_setup_menu->g_wm_geometry($geom);

#   Try to keep the nascent graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

    $src_type = $props{$id}{src_type};
    %parms    = %{ $props{$id}{parms} };
    @parmlist = @{ $parms{parms}      };
    $first_jd = $parms{first_jd};
    $last_jd  = $parms{last_jd};
    undef %parms;

    $parm         = $parmlist[0];
    $parm_chars   = length($parm) +2;
    for ($i=1; $i<=$#parmlist; $i++) {
        $parm_chars = length($parmlist[$i]) +2 if (length($parmlist[$i]) +2 > $parm_chars);
    }
    $parm_div     = "None";
    @parm_divlist = ("None");
    for ($i=0; $i<=$#parmlist; $i++) {
        next if ($parmlist[$i] eq "Horizontal Velocity"
                    || $parmlist[$i] eq "Vertical Velocity"
                    || $parmlist[$i] eq "Density"
                    || $parmlist[$i] eq "Habitat");
        if ($parm ne $parmlist[$i]) {
            push (@parm_divlist, $parmlist[$i]);
        }
    }
    $yaxis_units  = "feet";
    $yaxis_type   = "Elevation";
    $xaxis_units  = "miles";
    $xaxis_flip   = 0;
    $elev_base    = -999;
    $cscheme      = "Blue to Orange";
    $ncolors      = 20;
    $byear        = $grid{$id}{byear};
    $tz_offset    = "+00:00";
    $limit_dates  = 0;

    $begin_jd = &date2jdate(sprintf("%04d%02d%02d", $byear, 1, 1));
    $jd1      = int($first_jd +0.000001) +$begin_jd -1;
    $jd2      = int($last_jd  +0.000001) +$begin_jd;
    $jd2-- if ($last_jd == int($last_jd));

    ($byr, $bm, $bday) = split(/-/, &jdate2datelabel($jd1, "YYYY-MM-DD"));
    ($eyr, $em, $eday) = split(/-/, &jdate2datelabel($jd2, "YYYY-MM-DD"));
    $bday += 0;
    $eday += 0;
    $bm--;
    $em--;
    $bmon   = $mon_names[$bm];
    $emon   = $mon_names[$em];
    $bdate  = sprintf("%s-%02d-%04d", $bmon, $bday, $byr);
    $edate  = sprintf("%s-%02d-%04d", $emon, $eday, $eyr);

    $yr_max = (localtime(time))[5] +1900;
    $yr_min = $yr_max -25;
    $yr_min = $byear -5 if ($byear <= $yr_min);
    $yr_min = $byr      if ($byr   <  $yr_min);
    $yr_max = $byear +5 if ($byear >= $yr_max);
    $yr_max = $eyr      if ($eyr   >  $yr_max);
    $ymin   = $ymax = $ymajor = "";
    $pmin   = $pmax = "";

    $parm_short = $parm;
    if ($parm eq "Temperature") {
        $title = "Temperature, in degrees Celsius";
        $units = "Celsius";
    } else {
        $units = "";
        $parm_short =~ s/\(ms-1\)//i;
        $parm_short =~ s/\(m3s-1\)//i;
        $parm_short =~ s/ [kmu]?g\/L\/day//i;
        $parm_short =~ s/ [kmu]?g\/m2\/day//i;
        $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
        $parm_short =~ s/ [kmu]?g\/L//i;
        $parm_short =~ s/ [kmu]?g\/m3//i;
        $parm_short =~ s/ [kmu]?g\/m\^3//i;
        $parm_short =~ s/, days//i;
        $parm_short =~ s/ days//i;
        $parm_short =~ s/,$//;
        if ($parm eq "Horizontal Velocity" || $parm eq "Vertical Velocity") {
            $units = "m/s";
            $title = $parm_short . ", in m/s";
        } elsif ($parm eq "Density") {
            $units = "kg/m3";
            $title = $parm_short . ", in kg/m3";
        } else {
            $title = $parm_short . ", in ";
        }
    }
    $gtitle        = "Longitudinal Slice of $parm_short";
    $oldparm       = $parm;
    $oldparm_short = $parm_short;
    $old_units     = $units;

#   Available initial colormaps
    @cmaps = ("Blue to Orange", "Blue to Red", "CoolWarm", "Turbo", "Viridis");

#   Conversion types and factors (@conv_types is global)
    $conv_type = $conv_types[0];
    $conv_mult = 1.0;
    $conv_add  = 0.0;

#   Skip some dates?
    $jd_skip_active = $jd_skip = 0;
    if ($src_type =~ /Contour/i) {
        @ncpl = @{ $grid{$id}{ncpl} };
        @cplf = @{ $grid{$id}{cplf} };
        @wbs  = split(/,/, $props{$id}{wb_list});
        foreach $jw (@wbs) {
            for ($i=1; $i<=$ncpl[$jw]; $i++) {
                if ($cplf[$i][$jw] < 1.0) {
                    $jd_skip_active = 1;
                    last;
                }
            }
            last if ($jd_skip_active);
        }
        undef @ncpl;
        undef @cplf;
        undef @wbs;
    } elsif ($src_type =~ /Vector/i) {
        @nvpl = @{ $grid{$id}{nvpl} };
        @vplf = @{ $grid{$id}{vplf} };
        @wbs  = split(/,/, $props{$id}{wb_list});
        foreach $jw (@wbs) {
            for ($i=1; $i<=$nvpl[$jw]; $i++) {
                if ($vplf[$i][$jw] < 1.0) {
                    $jd_skip_active = 1;
                    last;
                }
            }
            last if ($jd_skip_active);
        }
        undef @nvpl;
        undef @vplf;
        undef @wbs;
    }
    @jd_skip_opts = ("(keep all)", "(keep every other)", "(keep every 3rd)", "(keep every 4th)",
                     "(keep every 5th)",  "(keep every 6th)",  "(keep every 7th)",  "(keep every 8th)",
                     "(keep every 9th)",  "(keep every 10th)", "(keep every 11th)", "(keep every 12th)",
                     "(keep every 13th)", "(keep every 14th)", "(keep every 15th)", "(keep every 16th)",
                     "(keep every 17th)", "(keep every 18th)", "(keep every 19th)", "(keep every 20th)",
                     "(keep every 21st)", "(keep every 22nd)", "(keep every 23rd)", "(keep every 24th)",
                     "(keep every 25th)", "(keep every 26th)", "(keep every 27th)", "(keep every 28th)",
                     "(keep every 29th)", "(keep every 30th)", "(keep every 31st)", "(keep every 32nd)",
                     "(keep every 33rd)", "(keep every 34th)", "(keep every 35st)", "(keep every 36th)",
                     "(keep every 37th)", "(keep every 38th)", "(keep every 39th)", "(keep every 40th)",
                     "(keep every 41st)", "(keep every 42nd)", "(keep every 43rd)", "(keep every 44th)",
                     "(keep every 45th)", "(keep every 46th)", "(keep every 47th)", "(keep every 48th)",
                     "(keep every 49th)", "(keep every 50th)");
    $jd_skip_explain = $jd_skip_opts[$jd_skip];

#   Set up the menu
    $frame = $w2slice_setup_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -command => sub { my ($m, %parms);
                              if ($pmin eq "" || $pmax eq "") {
                                  return &pop_up_error($w2slice_setup_menu,
                                  "Please provide both a min and max for your parameter.");
                              }
                              if ($pmin >= $pmax) {
                                  return &pop_up_error($w2slice_setup_menu,
                                  "The minimum data value must be less than the maximum data value.");
                              }
                              if ($yaxis_type eq "Elevation") {
                                  if ($ymin eq "" || $ymax eq "") {
                                      return &pop_up_error($w2slice_setup_menu,
                                      "Please provide both a min and max elevation.");
                                  }
                                  if ($ymin >= $ymax) {
                                      return &pop_up_error($w2slice_setup_menu,
                                      "The minimum elevation must be less than the maximum elevation.");
                                  }
                              } else {
                                  if ($ymax eq "") {
                                      return &pop_up_error($w2slice_setup_menu,
                                      "Please provide a maximum depth.");
                                  }
                              }
                              if ($limit_dates) {
                                  $m   = &list_match($bmon, @mon_names);
                                  $jd1 = &date2jdate(sprintf("%04d%02d%02d", $byr, $m+1, $bday));
                                  $m   = &list_match($emon, @mon_names);
                                  $jd2 = &date2jdate(sprintf("%04d%02d%02d", $eyr, $m+1, $eday));
                                  if ($jd1 > $jd2) {
                                      return &pop_up_error($w2slice_setup_menu,
                                      "The start date is after the end date.\nPlease adjust and try again.");
                                  }
                              }
                              if ($conv_type eq "Custom") {
                                  $conv_type = sprintf("Custom,%s,%s", $conv_mult, $conv_add);
                              }
                              $gtitle =~ s/^\s+//;
                              $gtitle =~ s/\s+$//;

                              %parms             = ();
                              $parms{pmin}       = $pmin;
                              $parms{pmax}       = $pmax;
                              $parms{xunits}     = $xaxis_units;
                              $parms{xflip}      = $xaxis_flip;
                              $parms{ymin}       = $ymin;
                              $parms{ymax}       = $ymax;
                              $parms{ymajor}     = $ymajor;
                              $parms{ytype}      = $yaxis_type;
                              $parms{yunits}     = $yaxis_units;
                              $parms{cscheme}    = $cscheme;
                              $parms{ncolors}    = $ncolors;
                              $parms{gtitle}     = $gtitle;
                              $props{$id}{parms} = { %parms };

                              $props{$id}{parm}       = $parm;
                              $props{$id}{parm_div}   = $parm_div;
                              $props{$id}{parm_units} = $units;
                              $props{$id}{ctype}      = $conv_type;
                              $props{$id}{byear}      = $byear;
                              $props{$id}{tz_offset}  = $tz_offset;
                              $props{$id}{jd_skip}    = $jd_skip;
                              $props{$id}{dt_limits}  = $limit_dates;
                              if ($limit_dates) {
                                  $props{$id}{dt_begin} = sprintf("%s-%02d-%04d", $bmon, $bday, $byr);
                                  $props{$id}{dt_end}   = sprintf("%s-%02d-%04d", $emon, $eday, $eyr);
                              }

                              $w2slice_setup_menu->g_bind('<Destroy>', "");
                              $w2slice_setup_menu->g_destroy();
                              undef $w2slice_setup_menu;
                              &reset_bindings;

                              &make_w2_slice($canv, $id, 0);
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);

    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $w2slice_setup_menu->g_bind('<Destroy>', "");
                              $w2slice_setup_menu->g_destroy();
                              undef $w2slice_setup_menu;
                              $canv->delete("graph" . $id);
                              delete $props{$id};
                              delete $grid{$id};
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Delete graph if this menu is destroyed by other than the Cancel button
    $w2slice_setup_menu->g_bind('<Destroy>' => sub { undef $w2slice_setup_menu;
                                                     $canv->delete("graph" . $id);
                                                     delete $props{$id}; 
                                                     delete $grid{$id};
                                                     &reset_bindings;
                                                   });

    ($f = $w2slice_setup_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "Parameter: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($parm_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    ($parm_cb = $parm_frame->new_ttk__combobox(
            -textvariable => \$parm,
            -values       => [ @parmlist ],
            -state        => 'readonly',
            -width        => $parm_chars,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $parm_cb->g_bind("<<ComboboxSelected>>",
                         sub { my ($i);
                               return if ($parm eq $oldparm);
                               $parm_short = $parm;
                               if ($parm eq "Temperature") {
                                   $units = "Celsius" if ($units !~ /(Celsius|Fahrenheit)/);
                                   $title = "Temperature, in degrees " . $units;
                                   $units_cb->g_grid();
                                   $units_entry->g_grid_remove();
                                   $conv_type_na_label->g_grid();
                                   $custom_frame->g_grid_remove();
                                   $conv_type_cb->g_grid_remove();
                                   $conv_type = "None";
                               } else {
                                   $units = "";
                                   $parm_short =~ s/\(ms-1\)//i;
                                   $parm_short =~ s/\(m3s-1\)//i;
                                   $parm_short =~ s/ [kmu]?g\/L\/day//i;
                                   $parm_short =~ s/ [kmu]?g\/m2\/day//i;
                                   $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
                                   $parm_short =~ s/ [kmu]?g\/L//i;
                                   $parm_short =~ s/ [kmu]?g\/m3//i;
                                   $parm_short =~ s/ [kmu]?g\/m\^3//i;
                                   $parm_short =~ s/, days//i;
                                   $parm_short =~ s/ days//i;
                                   $parm_short =~ s/,$//;
                                   if ($parm eq "Horizontal Velocity" || $parm eq "Vertical Velocity") {
                                       $units = "m/s";
                                       $title = $parm_short . ", in m/s";
                                   } elsif ($parm eq "Density") {
                                       $units = "kg/m3";
                                       $title = $parm_short . ", in kg/m3";
                                   } else {
                                       $title = $parm_short . ", in ";
                                   }
                                   $units_cb->g_grid_remove();
                                   $units_entry->g_grid();
                                   $conv_type_na_label->g_grid_remove();
                                   $custom_frame->g_grid() if ($conv_type eq "Custom");
                                   $conv_type_cb->g_grid();
                               }
                               if ($gtitle eq "") {
                                   $gtitle = "Longitudinal Slice of $parm_short";
                               } else {
                                   if (index(lc($gtitle), lc($oldparm_short)) > -1) {
                                       $gtitle =~ s/$oldparm_short/$parm_short/i;
                                   }
                               }
                               $old_units     = $units;
                               $oldparm       = $parm;
                               $oldparm_short = $parm_short;
                               @parm_divlist = ("None");
                               for ($i=0; $i<=$#parmlist; $i++) {
                                   next if ($parmlist[$i] eq "Horizontal Velocity"
                                               || $parmlist[$i] eq "Vertical Velocity"
                                               || $parmlist[$i] eq "Density"
                                               || $parmlist[$i] eq "Habitat");
                                   if ($parm ne $parmlist[$i]) {
                                       push (@parm_divlist, $parmlist[$i]);
                                   }
                               }
                               $parm_div_cb->configure(-values => [ @parm_divlist ]);
                               if (&list_match($parm_div, @parm_divlist) == -1) {
                                   $parm_div = "None";
                               }
                               if ($parm eq "Temperature" || $parm eq "Horizontal Velocity"
                                     || $parm eq "Vertical Velocity" || $parm eq "Density"
                                     || $parm eq "Habitat" || $#parm_divlist == 0) {
                                   $parm_div_label->g_pack_forget();
                                   $parm_div_cb->g_pack_forget();
                                   $parm_div = "None";
                               } else {
                                   $parm_div_label->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                                   $parm_div_cb->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                               }
                             });
    ($parm_div_label = $parm_frame->new_label(
            -text => " divided by ",
            -font => 'default',
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    ($parm_div_cb = $parm_frame->new_ttk__combobox(
            -textvariable => \$parm_div,
            -values       => [ @parm_divlist ],
            -state        => 'readonly',
            -width        => $parm_chars,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Conversion: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($conv_type_na_label = $f->new_label(
            -text => "n/a",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $conv_type_na_label->g_grid_remove();
    ($conv_type_cb = $f->new_ttk__combobox(
            -textvariable => \$conv_type,
            -values       => [ @conv_types ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $conv_type_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($conv_type eq "Custom") {
                                $custom_frame->g_grid();
                            } else {
                                $custom_frame->g_grid_remove();
                            }
                          }
                      );
    $row++;
    ($custom_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $custom_frame->new_label(
            -text => "Multiply by: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_mult_entry = $custom_frame->new_entry(
            -textvariable => \$conv_mult,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_mult_entry->g_bind("<KeyRelease>",
                              sub { &numeric_entry_only($conv_mult_entry);
                                    my $chars = &max(7, length($conv_mult));
                                    $conv_mult_entry->configure(-width => $chars);
                                  });
    $custom_frame->new_label(
            -text => "  Then add: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_add_entry = $custom_frame->new_entry(
            -textvariable => \$conv_add,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_add_entry->g_bind("<KeyRelease>",
                             sub { &numeric_entry_only($conv_add_entry);
                                   my $chars = &max(7, length($conv_add));
                                   $conv_add_entry->configure(-width => $chars);
                                 });

    $row++;
    $f->new_label(
            -text => "Data Units: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($units_cb = $f->new_ttk__combobox(
            -textvariable => \$units,
            -values       => [ ("Celsius", "Fahrenheit") ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $units_cb->g_bind("<<ComboboxSelected>>",
                       sub { return if ($units eq $old_units);
                             $old_units = $units;
                             $pmin = 0 if ($pmin eq "-");
                             $pmax = 0 if ($pmax eq "-");
                             if ($units eq "Celsius") {
                                 $pmin = &floor(($pmin -32) /1.8) if ($pmin ne "");
                                 $pmax = &ceil(($pmax  -32) /1.8) if ($pmax ne "");
                             } elsif ($units eq "Fahrenheit") {
                                 $pmin = &floor($pmin *1.8 +32) if ($pmin ne "");
                                 $pmax = &ceil($pmax  *1.8 +32) if ($pmax ne "");
                             }
                             $title = "Temperature, in degrees " . $units;
                           });
    $units_cb->g_grid_remove();
    ($units_entry = $f->new_entry(
            -textvariable => \$units,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $units_entry->g_bind("<KeyRelease>",
                         sub { my $chars = &max(7, length($units));
                               $units_entry->configure(-width => $chars);
                               if ($parm eq "Temperature") {
                                   $title = "Temperature, in degrees " . $units;
                               } else {
                                   $title = $parm_short . ", in " . $units;
                               }
                             });

    $row++;
    $f->new_label(
            -text => "Data Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$title,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Data Min: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmin_entry = $f->new_entry(
            -textvariable => \$pmin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $pmin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmin_entry ]);

    $row++;
    $f->new_label(
            -text => "Data Max: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmax_entry = $f->new_entry(
            -textvariable => \$pmax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $pmax_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmax_entry ]);

    $row++;
    $f->new_label(
            -text => "Y Axis Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($yaxis_type_cb = $f->new_ttk__combobox(
            -textvariable => \$yaxis_type,
            -values       => [ ("Elevation", "Depth") ],
            -state        => 'readonly',
            -width        => 10,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $yaxis_type_cb->g_bind("<<ComboboxSelected>>",
                           sub { if ($yaxis_type eq "Elevation") {
                                     $ymin_label->g_grid();
                                     $ymin_entry->g_grid();
                                     $ymin_units_label->g_grid();
                                     $ymax_label->configure(-text => "Elevation Max: ");
                                     $ymajor_label->configure(-text => "Elevation Major: ");
                                     $yaxis_units_label->configure(-text => "Elevation Units: ");
                                     if ($elev_base != -999 && $ymax ne "") {
                                         $ymin  = $elev_base;
                                         $ymax += $elev_base;
                                     } else {
                                         $ymin = "";
                                     }
                                 } else {
                                     $ymin_label->g_grid_remove();
                                     $ymin_entry->g_grid_remove();
                                     $ymin_units_label->g_grid_remove();
                                     $ymax_label->configure(-text => "Depth Max: ");
                                     $ymajor_label->configure(-text => "Depth Major: ");
                                     $yaxis_units_label->configure(-text => "Depth Units: ");
                                     if ($ymax ne "" && $ymin ne "" && $ymax -$ymin != 0) {
                                         $elev_base = &min($ymin, $ymax);
                                         $ymax      = abs($ymax -$ymin);
                                     } else {
                                         $ymax = "";
                                     }
                                     $ymin = 0;
                                 }
                               }
                          );

    $row++;
    ($ymin_label = $f->new_label(
            -text => "Elevation Min: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ymin_entry = $f->new_entry(
            -textvariable => \$ymin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $ymin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $ymin_entry ]);
    ($ymin_units_label = $f->new_label(
            -textvariable => \$yaxis_units,
            -font         => 'default',
            -anchor       => 'w',
            ))->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

    $row++;
    ($ymax_label = $f->new_label(
            -text => "Elevation Max: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ymax_entry = $f->new_entry(
            -textvariable => \$ymax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $ymax_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($ymax_entry);
                                              $ymax =~ s/^-// if ($yaxis_type eq "Depth");
                                            });
    $f->new_label(
            -textvariable => \$yaxis_units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

    $row++;
    ($ymajor_label = $f->new_label(
            -text => "Elevation Major: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ymajor_entry = $f->new_entry(
            -textvariable => \$ymajor,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $ymajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($ymajor_entry, 1);
                                                $ymajor =~ s/^-//;
                                              });
    $f->new_label(
            -textvariable => \$yaxis_units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

    $row++;
    ($yaxis_units_label = $f->new_label(
            -text => "Elevation Units: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_ttk__combobox(
            -textvariable => \$yaxis_units,
            -values       => [ ("feet", "meters") ],
            -state        => 'readonly',
            -width        => 7,
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "X Axis Units: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($xaxis_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $xaxis_frame->new_ttk__combobox(
            -textvariable => \$xaxis_units,
            -values       => [ ("miles", "kilometers") ],
            -state        => 'readonly',
            -width        => 10,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $xaxis_frame->new_checkbutton(
            -onvalue  => 1,
            -offvalue => 0,
            -text     => "Flip Axis",
            -font     => 'default',
            -variable => \$xaxis_flip,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Color Scheme: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($cscheme_cb = $f->new_ttk__combobox(
            -textvariable => \$cscheme,
            -values       => [ @cmaps ],
            -state        => 'readonly',
            -width        => 15,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $cscheme_cb->g_bind("<<ComboboxSelected>>",
                           sub { my ($n);
                                 if ($cscheme =~ /CoolWarm|Turbo|Viridis/) {
                                     $ncolors_cb->configure(-values => [ (8 .. 100) ]);
                                 } else {
                                     $ncolors_cb->configure(-values =>
                                         [ (16, 18, 20, 22, 24, 30, 34, 38, 42, 46) ]);
                                     if ($ncolors < 16) {
                                         $ncolors = 16;
                                     } elsif ($ncolors > 46) {
                                         $ncolors = 46;
                                     } else {
                                         foreach $n (reverse @valid_nc) {
                                             if ($ncolors >= 2 *$n) {
                                                 $ncolors = 2 *$n;
                                                 last;
                                             }
                                         }
                                     }
                                 }
                               });

    $row++;
    $f->new_label(
            -text => "Number of Colors: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ncolors_cb = $f->new_ttk__combobox(
            -textvariable => \$ncolors,
            -values       => [ (16, 18, 20, 22, 24, 30, 34, 38, 42, 46) ],
            -state        => 'readonly',
            -width        => 4,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Base Year: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($byear_cb = $f->new_ttk__combobox(
            -textvariable => \$byear,
            -values       => [ reverse($yr_min .. $yr_max) ],
            -state        => 'readonly',
            -width        => 5,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $byear_cb->g_bind("<<ComboboxSelected>>",
                      sub { my ($hr, $jd_offset, $m, $mi);
                            ($hr, $mi) = split(/:/, $tz_offset);
                            $hr += 0;
                            $mi += 0;
                            $mi *= -1 if ($hr < 0);
                            $jd_offset = $hr/24. +$mi/1440.;
                            $begin_jd  = &date2jdate(sprintf("%04d%02d%02d", $byear, 1, 1));
                            $jd1       = int($first_jd +$jd_offset +0.000001) +$begin_jd -1;
                            $jd2       = int($last_jd  +$jd_offset +0.000001) +$begin_jd;
                            $jd2-- if ($last_jd +$jd_offset == int($last_jd +$jd_offset));

                            ($byr, $m, $bday) = split(/-/, &jdate2datelabel($jd1, "YYYY-MM-DD"));
                            $bday += 0;
                            $bmon  = $mon_names[$m-1];
                            $bdate = sprintf("%s-%02d-%04d", $bmon, $bday, $byr);
                            &set_leap_year($byr);
                            $bday_cb->configure(-values => [ 1 .. $days_in_month[$m-1] ]);

                            ($eyr, $m, $eday) = split(/-/, &jdate2datelabel($jd2, "YYYY-MM-DD"));
                            $eday += 0;
                            $emon  = $mon_names[$m-1];
                            $edate = sprintf("%s-%02d-%04d", $emon, $eday, $eyr);
                            &set_leap_year($eyr);
                            $eday_cb->configure(-values => [ 1 .. $days_in_month[$m-1] ]);
                            $data_range->configure(-text => $bdate . " to " . $edate);

                            if ($byear == $yr_min || $byear == $yr_max || $byr < $yr_min || $eyr > $yr_max) {
                                $yr_min -= 5    if ($byear == $yr_min);
                                $yr_max += 5    if ($byear == $yr_max);
                                $yr_min  = $byr if ($byr < $yr_min);
                                $yr_max  = $eyr if ($eyr > $yr_max);
                                $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                $byr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                $eyr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                            }
                          }
                     );
    $f->new_label(
            -text   => " for JDAY = 1.0",
            -anchor => 'w',
            -font   => 'default',
            )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Time Offset: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($offset_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    ($tzoff_cb = $offset_frame->new_ttk__combobox(
            -textvariable => \$tz_offset,
            -values       => [ @tz_offsets ],
            -justify      => 'right',
            -state        => 'readonly',
            -width        => 6,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $tzoff_cb->g_bind("<<ComboboxSelected>>",
                      sub { my ($hr, $jd_offset, $m, $mi);
                            ($hr, $mi) = split(/:/, $tz_offset);
                            $hr += 0;
                            $mi += 0;
                            $mi *= -1 if ($hr < 0);
                            $jd_offset = $hr/24. +$mi/1440.;
                            $begin_jd  = &date2jdate(sprintf("%04d%02d%02d", $byear, 1, 1));
                            $jd1       = int($first_jd +$jd_offset +0.000001) +$begin_jd -1;
                            $jd2       = int($last_jd  +$jd_offset +0.000001) +$begin_jd;
                            $jd2-- if ($last_jd +$jd_offset == int($last_jd +$jd_offset));

                            ($byr, $m, $bday) = split(/-/, &jdate2datelabel($jd1, "YYYY-MM-DD"));
                            $bday += 0;
                            $bmon  = $mon_names[$m-1];
                            $bdate = sprintf("%s-%02d-%04d", $bmon, $bday, $byr);
                            &set_leap_year($byr);
                            $bday_cb->configure(-values => [ 1 .. $days_in_month[$m-1] ]);

                            ($eyr, $m, $eday) = split(/-/, &jdate2datelabel($jd2, "YYYY-MM-DD"));
                            $eday += 0;
                            $emon  = $mon_names[$m-1];
                            $edate = sprintf("%s-%02d-%04d", $emon, $eday, $eyr);
                            &set_leap_year($eyr);
                            $eday_cb->configure(-values => [ 1 .. $days_in_month[$m-1] ]);
                            $data_range->configure(-text => $bdate . " to " . $edate);

                            if ($byr < $yr_min || $eyr > $yr_max) {
                                $yr_min = $byr if ($byr < $yr_min);
                                $yr_max = $eyr if ($eyr > $yr_max);
                                $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                $byr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                $eyr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                            }
                          }
                     );
    $offset_frame->new_label(
            -text   => " time zone adjustment ",
            -anchor => 'w',
            -font   => 'default',
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $offset_frame->new_button(
            -text    => "Help",
            -command => sub { &pop_up_info($w2slice_setup_menu,
                                    "The time offset allows the user to add or subtract a time\n"
                                  . "offset if the W2 model was run with a non-local time zone.\n\n"
                                  . "For example, if W2 was run in UTC but the local time zone\n"
                                  . "is PST, an offset of -08:00 would convert the model date/time\n"
                                  . "to a local standard time of PST. This offset does not make\n"
                                  . "any adjustments related to daylight saving time. In general,\n"
                                  . "W2 is best run in the local standard time.\n\n"
                                  . "Leave the time offset at +00:00 for no adjustment.",
                                    "Time Offset Notice");
                            },
            )->g_pack(-side => 'left', -anchor => 'w', -padx => 2);

    if ($jd_skip_active) {
        $row++;
        $f->new_label(
                -text => "Skip Dates: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $f->new_spinbox(
                -textvariable => \$jd_skip,
                -state        => 'readonly',
                -font         => 'default',
                -from         => 0,
                -to           => 49,
                -increment    => 1,
                -width        => 4,
                -command      => sub { $jd_skip_explain = $jd_skip_opts[$jd_skip]; },
                )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $f->new_label(
                -textvariable => \$jd_skip_explain,
                -font         => 'default',
                )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);
    }

    $row++;
    $f->new_label(
            -text => "Graph Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gtitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Available Data: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($data_range = $f->new_label(
            -text => $bdate . " to " . $edate,
            -font => 'default',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Date Limits: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($data_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $data_frame->new_checkbutton(
            -onvalue  => 1,
            -offvalue => 0,
            -text     => "Restrict date range ",
            -font     => 'default',
            -variable => \$limit_dates,
            -command  => sub { if ($limit_dates) {
                                   $bdate_label->g_grid();
                                   $bdate_frame->g_grid();
                                   $edate_label->g_grid();
                                   $edate_frame->g_grid();
                               } else {
                                   $bdate_label->g_grid_remove();
                                   $bdate_frame->g_grid_remove();
                                   $edate_label->g_grid_remove();
                                   $edate_frame->g_grid_remove();
                               }
                             },
            )->g_pack(-side => 'left', -anchor => 'w');
    $data_frame->new_button(
            -text    => "Help",
            -command => sub { &pop_up_info($w2slice_setup_menu,
                                    "W2Anim may run out of memory if too many large slice images\n"
                                  . "have to be generated to produce an animation. The user can\n"
                                  . "limit the date range of a W2 longitudinal slice animation by\n"
                                  . "choosing a shorter range of dates from the W2 output. The\n"
                                  . "start and end dates are for midnight at the start of those days.\n\n"
                                  . "In most instances, such a restriction is unnecessary.",
                                    "Date Range Restriction Notice");
                            },
            )->g_pack(-side => 'left', -anchor => 'w', -padx => 2);

    $row++;
    ($bdate_label = $f->new_label(
            -text => "Start Date: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($bdate_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    ($bmon_cb = $bdate_frame->new_ttk__combobox(
            -textvariable => \$bmon,
            -values       => [ @mon_names ],
            -state        => 'readonly',
            -width        => 4,
            ))->g_pack(-side => 'left');
    $bmon_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($byr);
                          $bm = &list_match($bmon, @mon_names);
                          $bday_cb->configure(-values => [ 1 .. $days_in_month[$bm] ]);
                          $bday = $days_in_month[$bm] if ($bday > $days_in_month[$bm]);
                        }
                    );
    $bdate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($bday_cb = $bdate_frame->new_ttk__combobox(
            -textvariable => \$bday,
            -values       => [ 1 .. $days_in_month[$bm] ],
            -state        => 'readonly',
            -width        => 3,
            ))->g_pack(-side => 'left');
    $bdate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($byr_cb = $bdate_frame->new_ttk__combobox(
            -textvariable => \$byr,
            -values       => [ reverse($yr_min .. $yr_max) ],
            -state        => 'readonly',
            -width        => 5,
            ))->g_pack(-side => 'left');
    $byr_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($byr);
                          $bm = &list_match($bmon, @mon_names);
                          if ($bm == 1) {
                              $bday_cb->configure(-values => [ 1 .. $days_in_month[$bm] ]);
                              $bday = $days_in_month[$bm] if ($bday > $days_in_month[$bm]);
                          }
                          if ($byr == $yr_min || $byr == $yr_max) {
                              $yr_min -= 5 if ($byr == $yr_min);
                              $yr_max += 5 if ($byr == $yr_max);
                              $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                              $byr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                              $eyr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                          }
                        }
                    );

    $row++;
    ($edate_label = $f->new_label(
            -text => "End Date: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($edate_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    ($emon_cb = $edate_frame->new_ttk__combobox(
            -textvariable => \$emon,
            -values       => [ @mon_names ],
            -state        => 'readonly',
            -width        => 4,
            ))->g_pack(-side => 'left');
    $emon_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($eyr);
                          $em = &list_match($emon, @mon_names);
                          $eday_cb->configure(-values => [ 1 .. $days_in_month[$em] ]);
                          $eday = $days_in_month[$em] if ($eday > $days_in_month[$em]);
                        }
                    );
    $edate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($eday_cb = $edate_frame->new_ttk__combobox(
            -textvariable => \$eday,
            -values       => [ 1 .. $days_in_month[$em] ],
            -state        => 'readonly',
            -width        => 3,
            ))->g_pack(-side => 'left');
    $edate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($eyr_cb = $edate_frame->new_ttk__combobox(
            -textvariable => \$eyr,
            -values       => [ reverse($yr_min .. $yr_max) ],
            -state        => 'readonly',
            -width        => 5,
            ))->g_pack(-side => 'left');
    $eyr_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($eyr);
                          $em = &list_match($emon, @mon_names);
                          if ($em == 1) {
                              $eday_cb->configure(-values => [ 1 .. $days_in_month[$em] ]);
                              $eday = $days_in_month[$em] if ($eday > $days_in_month[$em]);
                          }
                          if ($eyr == $yr_min || $eyr == $yr_max) {
                              $yr_min -= 5 if ($eyr == $yr_min);
                              $yr_max += 5 if ($eyr == $yr_max);
                              $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                              $byr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                              $eyr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                          }
                        }
                    );

    if ($parm eq "Temperature" || $parm eq "Horizontal Velocity" || $parm eq "Density" || $parm eq "Habitat"
                               || $parm eq "Vertical Velocity" || $#parm_divlist == 0) {
        $parm_div_label->g_pack_forget();
        $parm_div_cb->g_pack_forget();
    } else {
        $parm_div_label->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        $parm_div_cb->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    }
    if ($conv_type ne "Custom") {
        $custom_frame->g_grid_remove();
    }
    if ($parm eq "Temperature") {
        $units_cb->g_grid();
        $units_entry->g_grid_remove();
        $conv_type_na_label->g_grid();
        $custom_frame->g_grid_remove();
        $conv_type_cb->g_grid_remove();
        $conv_type = "None";
        $parm_div  = "None";
    } else {
        $units_cb->g_grid_remove();
        $units_entry->g_grid();
        $conv_type_na_label->g_grid_remove();
        $custom_frame->g_grid() if ($conv_type eq "Custom");
        $conv_type_cb->g_grid();
    }
    if ($cscheme =~ /CoolWarm|Turbo|Viridis/) {
        $ncolors_cb->configure(-values => [ (8 .. 100) ]);
    } else {
        $ncolors_cb->configure(-values => [ (16, 18, 20, 22, 24, 30, 34, 38, 42, 46) ]);
        if ($ncolors < 16) {
            $ncolors = 16;
        } elsif ($ncolors > 46) {
            $ncolors = 46;
        } else {
            foreach $n (reverse @valid_nc) {
                if ($ncolors >= 2 *$n) {
                    $ncolors = 2 *$n;
                    last;
                }
            }
        }
    }
    $bdate_label->g_grid_remove();
    $bdate_frame->g_grid_remove();
    $edate_label->g_grid_remove();
    $edate_frame->g_grid_remove();
    $f->g_grid_columnconfigure(2, -weight => 2);

    Tkx::wm_resizable($w2slice_setup_menu,0,0);
    &adjust_window_position($w2slice_setup_menu);
    $w2slice_setup_menu->g_focus;
}


sub change_w2_slice {
    my ($canv, $id, $X, $Y, $change) = @_;
    my (
        $bdate, $bdate_frame, $bdate_label, $bday, $bday_cb, $begin_jd,
        $bm, $bmon, $bmon_cb, $byear, $byear_cb, $byr, $byr_cb, $conv_add,
        $conv_add_entry, $conv_mult, $conv_mult_entry, $conv_type,
        $conv_type_cb, $conv_type_na_label, $custom_frame, $data_frame,
        $data_range, $dt_limits, $edate, $edate_frame, $edate_label, $eday,
        $eday_cb, $em, $emon, $emon_cb, $eyr, $eyr_cb, $f, $first_jd,
        $frame, $get_dates, $geom, $gtitle, $hr, $i, $jd_offset, $jd_skip,
        $jd_skip_active, $jd_skip_explain, $jd_skip_frame, $jd1, $jd2,
        $jw, $last_jd, $mi, $n, $offset_frame, $ok, $ok_btn, $old_units,
        $oldparm, $oldparm_short, $p, $parm, $parm_cb, $parm_chars,
        $parm_div, $parm_div_cb, $parm_div_label, $parm_frame, $parm_short,
        $parms_ref, $pbar, $pbar_img, $pbar_win, $pmajor, $pmajor_entry,
        $pmax, $pmax_entry, $pmin, $pmin_entry, $row, $src_type, $tecplot,
        $title, $tz_offset, $tzoff_cb, $units, $units_cb, $units_entry,
        $yr_max, $yr_min,

        @cpl_files, @cplf, @jd_skip_opts, @ncpl, @nvpl, @parm_divlist,
        @parm_tmp, @parmlist, @parms, @vplf, @wbs,
       );

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($w2slice_mod_menu) && Tkx::winfo_exists($w2slice_mod_menu)) {
        if ($w2slice_mod_menu->g_wm_title() eq "Modify W2 Longitudinal Slice") {
            $w2slice_mod_menu->g_destroy();
            undef $w2slice_mod_menu;
        }
    }
    if (defined($scale_output_menu) && Tkx::winfo_exists($scale_output_menu)) {
        if ($scale_output_menu->g_wm_title() eq "Select and Scale Output") {
            $scale_output_menu->g_destroy();
            undef $scale_output_menu;
        }
    }

#   Try to keep the graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

#   De-select graph if it already exists
    if (defined($props{$id}{oldcoords})) {
        &end_select($canv, $id, 1);
    }

#   Initialize some variables.
    @ncpl      = @{ $grid{$id}{ncpl} };
    @cplf      = @{ $grid{$id}{cplf} };
    @nvpl      = @{ $grid{$id}{nvpl} };
    @vplf      = @{ $grid{$id}{vplf} };

    $src_type  = $props{$id}{src_type};
    $parm      = $props{$id}{parm};
    $parm_div  = $props{$id}{parm_div};
    $units     = $props{$id}{parm_units};
    $conv_type = $props{$id}{ctype};
    $byear     = $props{$id}{byear};
    $tz_offset = $props{$id}{tz_offset};
    $jd_skip   = $props{$id}{jd_skip};
    $dt_limits = $props{$id}{dt_limits};
    $get_dates = (defined($props{$id}{start_dt})) ? 0 : 1;
    @wbs       = split(/,/, $props{$id}{wb_list});

    $pmin      = $gr_props{$id}{cs_min};
    $pmax      = $gr_props{$id}{cs_max};
    $pmajor    = $gr_props{$id}{cs_major};
    $title     = $gr_props{$id}{keytitle};
    $gtitle    = $gr_props{$id}{gtitle};

    if ($conv_type =~ /Custom/) {
        ($conv_type, $conv_mult, $conv_add) = split(/,/, $conv_type);
    } else {
        $conv_mult = 1.0;
        $conv_add  = 0.0;
    }

    if ($src_type =~ /Contour/i) {
        @cpl_files = @{ $props{$id}{cpl_files} };
        if ($get_dates) {
            ($pbar_win, $pbar, $pbar_img)
                = &create_alt_progress_bar($main, $id, "Scanning W2 contour files...");
        }
        for ($n=0; $n<=$#wbs; $n++) {
            ($tecplot, undef, $jw, $parms_ref, $jd1, $jd2)
                  = &scan_w2_cpl_file($main, $cpl_files[$n], $id, $get_dates, $pbar_img);
            if ($tecplot == -1) {
                &destroy_progress_bar($main, $pbar_win) if ($get_dates);
                return &pop_up_error($main, "The source file is not a W2 Contour file:\n$cpl_files[$n]");
            }
            @parms = @{ $parms_ref };
            if ($n == 0) {
                @parmlist = @parms;
                $first_jd = $jd1;
                $last_jd  = $jd2;
            } else {                # only keep parameters common to all cpl files
                @parm_tmp = ();
                foreach $p ( @parms ) {
                    if (&list_match($p, @parmlist) >= 0) {
                        push (@parm_tmp, $p);
                    }
                }
                @parmlist = @parm_tmp;
                $first_jd = $jd1 if ($jd1 < $first_jd);
                $last_jd  = $jd2 if ($jd2 > $last_jd);
            }
        }
        &destroy_progress_bar($main, $pbar_win) if ($get_dates);

    } elsif ($src_type =~ /Vector/i) {
        $status_line = "Scanning W2 vector file...";
        Tkx::update_idletasks();
        ($ok, $parms_ref, undef, $first_jd, $last_jd)
                  = &scan_w2_vector_file($main, $props{$id}{w2l_file}, $id, $get_dates);
        if ($ok ne "okay") {
            return &pop_up_error($main, "The source file is not a W2 Vector (w2l) file:\n"
                                      . $props{$id}{w2l_file});
        }
        @parmlist = @{ $parms_ref };
        $status_line = "";
        Tkx::update_idletasks();
    }

#   Begin to build the menu
    $w2slice_mod_menu = $main->new_toplevel();
    $w2slice_mod_menu->g_wm_transient($main);
    $w2slice_mod_menu->g_wm_title("Modify W2 Longitudinal Slice");
    $w2slice_mod_menu->configure(-cursor => $cursor_norm);
    $w2slice_mod_menu->g_wm_geometry($geom);

    ($hr, $mi) = split(/:/, $tz_offset);
    $hr += 0;
    $mi += 0;
    $mi *= -1 if ($hr < 0);
    $jd_offset = $hr/24. +$mi/1440.;
    $begin_jd  = &date2jdate(sprintf("%04d%02d%02d", $byear, 1, 1));

    if (! $get_dates) {
        $first_jd = &date2jdate($props{$id}{start_dt}) -$jd_offset -$begin_jd +1;
        $last_jd  = &date2jdate($props{$id}{end_dt})   -$jd_offset -$begin_jd +1;
    } else {
        $props{$id}{start_dt} = &jdate2date($first_jd +$jd_offset +$begin_jd -1);
        $props{$id}{end_dt}   = &jdate2date($last_jd  +$jd_offset +$begin_jd -1);
    }
    $jd1 = int($first_jd +$jd_offset +0.000001) +$begin_jd -1;
    $jd2 = int($last_jd  +$jd_offset +0.000001) +$begin_jd;
    $jd2-- if ($last_jd +$jd_offset == int($last_jd +$jd_offset));
    ($byr, $bm, $bday) = split(/-/, &jdate2datelabel($jd1, "YYYY-MM-DD"));
    ($eyr, $em, $eday) = split(/-/, &jdate2datelabel($jd2, "YYYY-MM-DD"));
    $bdate = sprintf("%s-%02d-%04d", $mon_names[$bm-1], $bday, $byr);
    $edate = sprintf("%s-%02d-%04d", $mon_names[$em-1], $eday, $eyr);

    $yr_max = (localtime(time))[5] +1900;
    $yr_min = ($byear > $yr_max -25) ? $yr_max -25 : $byear -5;
    $yr_min = $byr      if ($byr   <  $yr_min);
    $yr_max = $byear +5 if ($byear >= $yr_max);
    $yr_max = $eyr      if ($eyr   >  $yr_max);

    if ($dt_limits) {
        ($bm, $bday, $byr) = &parse_date($props{$id}{dt_begin}, 1);
        ($em, $eday, $eyr) = &parse_date($props{$id}{dt_end},   1);
    }
    $bday += 0;
    $eday += 0;
    $bm--;
    $em--;
    $bmon   = $mon_names[$bm];
    $emon   = $mon_names[$em];
    $yr_min = $byr if ($byr < $yr_min);
    $yr_max = $eyr if ($eyr > $yr_max);

    $jd_skip_active = 0;
    @jd_skip_opts = ("(keep all)", "(keep every other)", "(keep every 3rd)", "(keep every 4th)",
                     "(keep every 5th)",  "(keep every 6th)",  "(keep every 7th)",  "(keep every 8th)",
                     "(keep every 9th)",  "(keep every 10th)", "(keep every 11th)", "(keep every 12th)",
                     "(keep every 13th)", "(keep every 14th)", "(keep every 15th)", "(keep every 16th)",
                     "(keep every 17th)", "(keep every 18th)", "(keep every 19th)", "(keep every 20th)",
                     "(keep every 21st)", "(keep every 22nd)", "(keep every 23rd)", "(keep every 24th)",
                     "(keep every 25th)", "(keep every 26th)", "(keep every 27th)", "(keep every 28th)",
                     "(keep every 29th)", "(keep every 30th)", "(keep every 31st)", "(keep every 32nd)",
                     "(keep every 33rd)", "(keep every 34th)", "(keep every 35st)", "(keep every 36th)",
                     "(keep every 37th)", "(keep every 38th)", "(keep every 39th)", "(keep every 40th)",
                     "(keep every 41st)", "(keep every 42nd)", "(keep every 43rd)", "(keep every 44th)",
                     "(keep every 45th)", "(keep every 46th)", "(keep every 47th)", "(keep every 48th)",
                     "(keep every 49th)", "(keep every 50th)");
    for ($n=0; $n<=$#wbs; $n++) {
        $jw = $wbs[$n];
        if ($src_type =~ /Contour/i) {
            for ($i=1; $i<=$ncpl[$jw]; $i++) {
                if ($cplf[$i][$jw] < 1.0) {
                    $jd_skip_active = 1;
                    last;
                }
            }
        } elsif ($src_type =~ /Vector/i) {
            for ($i=1; $i<=$nvpl[$jw]; $i++) {
                if ($vplf[$i][$jw] < 1.0) {
                    $jd_skip_active = 1;
                    last;
                }
            }
        }
    }
    $jd_skip = 0 if ($jd_skip < 0 || $jd_skip > 49);
    $jd_skip_explain = $jd_skip_opts[$jd_skip];

    $parm_chars = length($parmlist[0]);
    for ($i=1; $i<=$#parmlist; $i++) {
        $parm_chars = &max($parm_chars, length($parmlist[$i]));
    }
    $parm_chars += 2;
    $parm_short = $parm;
    if ($parm ne "Temperature") {
        $parm_short =~ s/\(ms-1\)//i;
        $parm_short =~ s/\(m3s-1\)//i;
        $parm_short =~ s/ [kmu]?g\/L\/day//i;
        $parm_short =~ s/ [kmu]?g\/m2\/day//i;
        $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
        $parm_short =~ s/ [kmu]?g\/L//i;
        $parm_short =~ s/ [kmu]?g\/m3//i;
        $parm_short =~ s/ [kmu]?g\/m\^3//i;
        $parm_short =~ s/, days//i;
        $parm_short =~ s/ days//i;
        $parm_short =~ s/,$//;
    }
    $old_units     = $units;
    $oldparm       = $parm;
    $oldparm_short = $parm_short;
    @parm_divlist  = ("None");
    for ($i=0; $i<=$#parmlist; $i++) {
        next if ($parmlist[$i] eq "Horizontal Velocity"
                  || $parmlist[$i] eq "Vertical Velocity"
                  || $parmlist[$i] eq "Density"
                  || $parmlist[$i] eq "Habitat");
        if ($parm ne $parmlist[$i]) {
            push (@parm_divlist, $parmlist[$i]);
        }
    }
    $parm_div = "None" if (&list_match($parm_div, @parm_divlist) == -1);

#   Build the menu.
    $frame = $w2slice_mod_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -command => sub { my ($dt_begin, $dt_end, $m, $modified, $result, %parms);
                              $modified = 0;
                              %parms = ();
                              if ($change eq "misc") {
                                  $dt_begin = sprintf("%s-%02d-%04d", $bmon, $bday, $byr);
                                  $dt_end   = sprintf("%s-%02d-%04d", $emon, $eday, $eyr);
                                  $modified = 1 if ($byear     != $props{$id}{byear}     ||
                                                    $tz_offset ne $props{$id}{tz_offset} ||
                                                    $dt_limits != $props{$id}{dt_limits} ||
                                                    $jd_skip   != $props{$id}{jd_skip}   ||
                                                    ($dt_limits &&
                                                     ($dt_begin ne $props{$id}{dt_begin} ||
                                                      $dt_end   ne $props{$id}{dt_end})));
                                  if ($dt_limits) {
                                      $m = &list_match($bmon, @mon_names);
                                      $jd1 = &date2jdate(sprintf("%04d%02d%02d", $byr, $m+1, $bday));
                                      $m = &list_match($emon, @mon_names);
                                      $jd2 = &date2jdate(sprintf("%04d%02d%02d", $eyr, $m+1, $eday));
                                      if ($jd1 > $jd2) {
                                          return &pop_up_error($w2slice_mod_menu,
                                                  "The start date is after the end date.\n"
                                                . "Please adjust and try again.");
                                      }
                                  }
                              }
                              if ($change =~ /parm|misc/) {
                                  if ($pmin eq "" || $pmax eq "") {
                                      return &pop_up_error($w2slice_mod_menu,
                                      "Please provide both a min and max for your parameter.");
                                  }
                                  if ($pmajor eq "") {
                                      return &pop_up_error($w2slice_mod_menu,
                                      "Please provide a major increment for your parameter.");
                                  }
                                  if ($pmin >= $pmax) {
                                      return &pop_up_error($w2slice_mod_menu,
                                      "The minimum data value must be less than the maximum data value.");
                                  }
                                  if ($conv_type eq "Custom") {
                                      $conv_type = sprintf("Custom,%s,%s", $conv_mult, $conv_add);
                                  }
                                  $gtitle =~ s/^\s+//;
                                  $gtitle =~ s/\s+$//;
                                  if ($parm ne $props{$id}{parm} || $parm_div ne $props{$id}{parm_div}
                                       || ($parm ne "Temperature" && $units ne $props{$id}{parm_units})
                                       || $conv_type ne $props{$id}{ctype}) {
                                      $modified = 1;
                                  }
                                  if (! $modified && $parm eq "Temperature"
                                                  && $parm eq $props{$id}{parm}
                                                  && $units ne $props{$id}{parm_units}) {
                                      return &pop_up_error($w2slice_mod_menu,
                                                           "To modify just the temperature units,\n"
                                                         . "use the Graph Properties menu.");
                                  }
                                  if (! $modified && ($pmin != $gr_props{$id}{cs_min} ||
                                                      $pmax != $gr_props{$id}{cs_max})) {
                                      return &pop_up_error($w2slice_mod_menu,
                                                           "To modify just the parameter limits,\n"
                                                         . "use the Graph Properties menu.");
                                  }
                                  if (! $modified && $pmajor != $gr_props{$id}{cs_major}) {
                                      return &pop_up_error($w2slice_mod_menu,
                                                           "To modify just the parameter increment,\n"
                                                         . "use the Graph Properties menu.");
                                  }
                                  if (! $modified && $gtitle ne $gr_props{$id}{gtitle}) {
                                      return &pop_up_error($w2slice_mod_menu,
                                                           "To modify just the graph title,\n"
                                                         . "use the Graph Properties menu.");
                                  }
                              }
                              if (! $modified) {
                                  $result = &pop_up_question($w2slice_mod_menu,
                                                         "No changes were made. Try again?");
                                  return if (lc($result) eq "yes");
                                  $w2slice_mod_menu->g_bind('<Destroy>', "");
                                  $w2slice_mod_menu->g_destroy();
                                  undef $w2slice_mod_menu;
                                  &reset_bindings;
                                  return;
                              }

#                             Rebuild the dates array if different jd_skip, byear, tz_offset, or dt_limit
                              $parms{rebuild}    = ($byear     != $props{$id}{byear}     ||
                                                    $tz_offset ne $props{$id}{tz_offset} ||
                                                    $dt_limits != $props{$id}{dt_limits} ||
                                                    $jd_skip   != $props{$id}{jd_skip}   ||
                                                    ($dt_limits && $change eq "misc" &&
                                                     ($dt_begin ne $props{$id}{dt_begin} ||
                                                      $dt_end   ne $props{$id}{dt_end}))) ? 1 : 0;
                              $parms{pmin}       = $pmin;
                              $parms{pmax}       = $pmax;
                              $parms{pmajor}     = $pmajor;
                              $parms{gtitle}     = $gtitle;
                              $parms{change}     = $change;
                              $props{$id}{parms} = { %parms };

                              $props{$id}{data}       = 0;
                              $props{$id}{parm}       = $parm;
                              $props{$id}{parm_div}   = $parm_div;
                              $props{$id}{parm_units} = $units;
                              $props{$id}{ctype}      = $conv_type;
                              $props{$id}{byear}      = $byear;
                              $props{$id}{tz_offset}  = $tz_offset;
                              $props{$id}{jd_skip}    = $jd_skip;
                              $props{$id}{dt_limits}  = $dt_limits;
                              if ($dt_limits) {
                                  $props{$id}{dt_begin} = $dt_begin;
                                  $props{$id}{dt_end}   = $dt_end;
                              }

                              $w2slice_mod_menu->g_bind('<Destroy>', "");
                              $w2slice_mod_menu->g_destroy();
                              undef $w2slice_mod_menu;
                              &reset_bindings;
                              &make_w2_slice($canv, $id, 0);
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $w2slice_mod_menu->g_bind('<Destroy>', "");
                              $w2slice_mod_menu->g_destroy();
                              undef $w2slice_mod_menu;
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Do not delete graph if this menu is destroyed by other than the Cancel button
    $w2slice_mod_menu->g_bind('<Destroy>' => sub { undef $w2slice_mod_menu;
                                                   &reset_bindings;
                                                 });

    $f = $w2slice_mod_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "Parameter: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($parm_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    ($parm_cb = $parm_frame->new_ttk__combobox(
            -textvariable => \$parm,
            -values       => [ @parmlist ],
            -state        => 'readonly',
            -width        => $parm_chars,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $parm_cb->g_bind("<<ComboboxSelected>>",
                         sub { my ($i);
                               return if ($parm eq $oldparm);
                               $parm_short = $parm;
                               if ($parm eq "Temperature") {
                                   $units = "Celsius" if ($units !~ /(Celsius|Fahrenheit)/);
                                   $title = "Temperature, in degrees " . $units;
                                   $units_cb->g_grid();
                                   $units_entry->g_grid_remove();
                                   $conv_type_na_label->g_grid();
                                   $custom_frame->g_grid_remove();
                                   $conv_type_cb->g_grid_remove();
                                   $conv_type = "None";
                               } else {
                                   $units = "";
                                   $parm_short =~ s/\(ms-1\)//i;
                                   $parm_short =~ s/\(m3s-1\)//i;
                                   $parm_short =~ s/ [kmu]?g\/L\/day//i;
                                   $parm_short =~ s/ [kmu]?g\/m2\/day//i;
                                   $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
                                   $parm_short =~ s/ [kmu]?g\/L//i;
                                   $parm_short =~ s/ [kmu]?g\/m3//i;
                                   $parm_short =~ s/ [kmu]?g\/m\^3//i;
                                   $parm_short =~ s/, days//i;
                                   $parm_short =~ s/ days//i;
                                   $parm_short =~ s/,$//;
                                   if ($parm eq "Horizontal Velocity" || $parm eq "Vertical Velocity") {
                                       $units = "m/s";
                                       $title = $parm_short . ", in m/s";
                                   } elsif ($parm eq "Density") {
                                       $units = "kg/m3";
                                       $title = $parm_short . ", in kg/m3";
                                   } else {
                                       $title = $parm_short . ", in ";
                                   }
                                   $units_cb->g_grid_remove();
                                   $units_entry->g_grid();
                                   $conv_type_na_label->g_grid_remove();
                                   $custom_frame->g_grid() if ($conv_type eq "Custom");
                                   $conv_type_cb->g_grid();
                               }
                               if ($gtitle eq "") {
                                   $gtitle = "Longitudinal Slice of " . ucfirst($parm_short);
                               } else {
                                   if (index(lc($gtitle), lc($oldparm_short)) > -1) {
                                       $gtitle =~ s/$oldparm_short/$parm_short/i;
                                   }
                               }
                               $old_units     = $units;
                               $oldparm       = $parm;
                               $oldparm_short = $parm_short;
                               @parm_divlist  = ("None");
                               for ($i=0; $i<=$#parmlist; $i++) {
                                   next if ($parmlist[$i] eq "Horizontal Velocity"
                                            || $parmlist[$i] eq "Vertical Velocity"
                                            || $parmlist[$i] eq "Density"
                                            || $parmlist[$i] eq "Habitat");
                                   if ($parm ne $parmlist[$i]) {
                                       push (@parm_divlist, $parmlist[$i]);
                                   }
                               }
                               $parm_div_cb->configure(-values => [ @parm_divlist ]);
                               if (&list_match($parm_div, @parm_divlist) == -1) {
                                   $parm_div = "None";
                               }
                               if ($parm eq "Temperature" || $parm eq "Horizontal Velocity"
                                       || $parm eq "Vertical Velocity" || $parm eq "Density"
                                       || $parm eq "Habitat" || $#parm_divlist == 0) {
                                   $parm_div_label->g_pack_forget();
                                   $parm_div_cb->g_pack_forget();
                                   $parm_div = "None";
                               } else {
                                   $parm_div_label->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                                   $parm_div_cb->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                               }
                             });
    ($parm_div_label = $parm_frame->new_label(
            -text => " divided by ",
            -font => 'default',
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    ($parm_div_cb = $parm_frame->new_ttk__combobox(
            -textvariable => \$parm_div,
            -values       => [ @parm_divlist ],
            -state        => 'readonly',
            -width        => $parm_chars,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Conversion: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($conv_type_na_label = $f->new_label(
            -text => "n/a",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $conv_type_na_label->g_grid_remove();
    ($conv_type_cb = $f->new_ttk__combobox(
            -textvariable => \$conv_type,
            -values       => [ @conv_types ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $conv_type_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($conv_type eq "Custom") {
                                $custom_frame->g_grid();
                            } else {
                                $custom_frame->g_grid_remove();
                            }
                          }
                      );
    $row++;
    ($custom_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $custom_frame->new_label(
            -text => "Multiply by: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_mult_entry = $custom_frame->new_entry(
            -textvariable => \$conv_mult,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_mult_entry->g_bind("<KeyRelease>",
                              sub { &numeric_entry_only($conv_mult_entry);
                                    my $chars = &max(7, length($conv_mult));
                                    $conv_mult_entry->configure(-width => $chars);
                                  });
    $custom_frame->new_label(
            -text => "  Then add: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_add_entry = $custom_frame->new_entry(
            -textvariable => \$conv_add,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_add_entry->g_bind("<KeyRelease>",
                             sub { &numeric_entry_only($conv_add_entry);
                                   my $chars = &max(7, length($conv_add));
                                   $conv_add_entry->configure(-width => $chars);
                                 });

    $row++;
    $f->new_label(
            -text => "Data Units: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($units_cb = $f->new_ttk__combobox(
            -textvariable => \$units,
            -values       => [ ("Celsius", "Fahrenheit") ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $units_cb->g_bind("<<ComboboxSelected>>",
                       sub { return if ($units eq $old_units);
                             $old_units = $units;
                             if ($units eq "Celsius") {
                                 if ($pmin ne "" && $pmin ne "." && $pmin ne "-") {
                                     $pmin = &floor(($pmin -32) /1.8);
                                 }
                                 if ($pmax ne "" && $pmax ne "." && $pmax ne "-") {
                                     $pmax = &ceil(($pmax  -32) /1.8);
                                 }
                                 if ($pmajor ne "" && $pmajor ne ".") {
                                     $pmajor = &round_to_int($pmajor /1.8);
                                 }
                             } elsif ($units eq "Fahrenheit") {
                                 if ($pmin ne "" && $pmin ne "." && $pmin ne "-") {
                                     $pmin = &floor($pmin *1.8 +32);
                                 }
                                 if ($pmax ne "" && $pmax ne "." && $pmax ne "-") {
                                     $pmax = &ceil($pmax  *1.8 +32);
                                 }
                                 if ($pmajor ne "" && $pmajor ne ".") {
                                     $pmajor = &round_to_int($pmajor *1.8);
                                 }
                             }
                             $title = "Temperature, in degrees " . $units;
                           });
    $units_cb->g_grid_remove();
    ($units_entry = $f->new_entry(
            -textvariable => \$units,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $units_entry->g_bind("<KeyRelease>",
                         sub { my $chars = &max(7, length($units));
                               $units_entry->configure(-width => $chars);
                               if ($parm eq "Temperature") {
                                   $title = "Temperature, in degrees " . $units;
                               } else {
                                   $title = $parm_short . ", in " . $units;
                               }
                             });

    $row++;
    $f->new_label(
            -text => "Data Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$title,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Data Min: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmin_entry = $f->new_entry(
            -textvariable => \$pmin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmin_entry ]);

    $row++;
    $f->new_label(
            -text => "Data Max: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmax_entry = $f->new_entry(
            -textvariable => \$pmax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmax_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmax_entry ]);

    $row++;
    $f->new_label(
            -text => "Data Major: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmajor_entry = $f->new_entry(
            -textvariable => \$pmajor,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($pmajor_entry, 1);
                                                $pmajor =~ s/^-//;
                                              });

    $row++;
    $f->new_label(
            -text => "Graph Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gtitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);

    if ($change eq "misc") {
        $row++;
        $f->new_label(
                -text => "Base Year: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($byear_cb = $f->new_ttk__combobox(
                -textvariable => \$byear,
                -values       => [ reverse($yr_min .. $yr_max) ],
                -width        => 5,
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $byear_cb->g_bind("<<ComboboxSelected>>",
                          sub { my ($m);
                                ($hr, $mi) = split(/:/, $tz_offset);
                                $hr += 0;
                                $mi += 0;
                                $mi *= -1 if ($hr < 0);
                                $jd_offset = $hr/24. +$mi/1440.;
                                $begin_jd  = &date2jdate(sprintf("%04d%02d%02d", $byear, 1, 1));
                                $jd1       = int($first_jd +$jd_offset +0.000001) +$begin_jd -1;
                                $jd2       = int($last_jd  +$jd_offset +0.000001) +$begin_jd;
                                $jd2-- if ($last_jd +$jd_offset == int($last_jd +$jd_offset));

                                ($byr, $m, $bday) = split(/-/, &jdate2datelabel($jd1, "YYYY-MM-DD"));
                                $bday += 0;
                                $bmon  = $mon_names[$m-1];
                                $bdate = sprintf("%s-%02d-%04d", $bmon, $bday, $byr);
                                &set_leap_year($byr);
                                $bday_cb->configure(-values => [ 1 .. $days_in_month[$m-1] ]);

                                ($eyr, $m, $eday) = split(/-/, &jdate2datelabel($jd2, "YYYY-MM-DD"));
                                $eday += 0;
                                $emon  = $mon_names[$m-1];
                                $edate = sprintf("%s-%02d-%04d", $emon, $eday, $eyr);
                                &set_leap_year($eyr);
                                $eday_cb->configure(-values => [ 1 .. $days_in_month[$m-1] ]);
                                $data_range->configure(-text => $bdate . " to " . $edate);

                                if ($byear == $yr_min || $byear == $yr_max
                                                      || $byr < $yr_min || $eyr > $yr_max) {
                                    $yr_min -= 5    if ($byear == $yr_min);
                                    $yr_max += 5    if ($byear == $yr_max);
                                    $yr_min  = $byr if ($byr < $yr_min);
                                    $yr_max  = $eyr if ($eyr > $yr_max);
                                    $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                    $byr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                    $eyr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                }
                              }
                         );
        $f->new_label(
                -text   => " for JDAY = 1.0",
                -anchor => 'w',
                -font   => 'default',
                )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

        $row++;
        $f->new_label(
                -text => "Time Offset: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($offset_frame = $f->new_frame(
                -borderwidth => 0,
                -relief      => 'flat',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
        ($tzoff_cb = $offset_frame->new_ttk__combobox(
                -textvariable => \$tz_offset,
                -values       => [ @tz_offsets ],
                -justify      => 'right',
                -state        => 'readonly',
                -width        => 6,
                ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        $tzoff_cb->g_bind("<<ComboboxSelected>>",
                          sub { my ($m);
                                ($hr, $mi) = split(/:/, $tz_offset);
                                $hr += 0;
                                $mi += 0;
                                $mi *= -1 if ($hr < 0);
                                $jd_offset = $hr/24. +$mi/1440.;
                                $begin_jd  = &date2jdate(sprintf("%04d%02d%02d", $byear, 1, 1));
                                $jd1       = int($first_jd +$jd_offset +0.000001) +$begin_jd -1;
                                $jd2       = int($last_jd  +$jd_offset +0.000001) +$begin_jd;
                                $jd2-- if ($last_jd +$jd_offset == int($last_jd +$jd_offset));

                                ($byr, $m, $bday) = split(/-/, &jdate2datelabel($jd1, "YYYY-MM-DD"));
                                $bday += 0;
                                $bmon  = $mon_names[$m-1];
                                $bdate = sprintf("%s-%02d-%04d", $bmon, $bday, $byr);
                                &set_leap_year($byr);
                                $bday_cb->configure(-values => [ 1 .. $days_in_month[$m-1] ]);

                                ($eyr, $m, $eday) = split(/-/, &jdate2datelabel($jd2, "YYYY-MM-DD"));
                                $eday += 0;
                                $emon  = $mon_names[$m-1];
                                $edate = sprintf("%s-%02d-%04d", $emon, $eday, $eyr);
                                &set_leap_year($eyr);
                                $eday_cb->configure(-values => [ 1 .. $days_in_month[$m-1] ]);
                                $data_range->configure(-text => $bdate . " to " . $edate);

                                if ($byr < $yr_min || $eyr > $yr_max) {
                                    $yr_min = $byr if ($byr < $yr_min);
                                    $yr_max = $eyr if ($eyr > $yr_max);
                                    $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                    $byr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                    $eyr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                }
                              }
                         );
        $offset_frame->new_label(
                -text   => " time zone adjustment ",
                -anchor => 'w',
                -font   => 'default',
                )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        $offset_frame->new_button(
                -text    => "Help",
                -command => sub { &pop_up_info($w2slice_mod_menu,
                                        "The time offset allows the user to add or subtract a time\n"
                                      . "offset if the W2 model was run with a non-local time zone.\n\n"
                                      . "For example, if W2 was run in UTC but the local time zone\n"
                                      . "is PST, an offset of -08:00 would convert the model date/time\n"
                                      . "to a local standard time of PST. This offset does not make\n"
                                      . "any adjustments related to daylight saving time. In general,\n"
                                      . "W2 is best run in the local standard time.\n\n"
                                      . "Leave the time offset at +00:00 for no adjustment.",
                                        "Time Offset Notice");
                                },
                )->g_pack(-side => 'left', -anchor => 'w', -padx => 2);

        if ($jd_skip_active) {
            $row++;
            $f->new_label(
                    -text => "Skip Dates: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($jd_skip_frame = $f->new_frame(
                    -borderwidth => 0,
                    -relief      => 'flat',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
            $jd_skip_frame->new_spinbox(
                    -textvariable => \$jd_skip,
                    -state        => 'readonly',
                    -font         => 'default',
                    -from         => 0,
                    -to           => 49,
                    -increment    => 1,
                    -width        => 4,
                    -command      => sub { $jd_skip_explain = $jd_skip_opts[$jd_skip]; },
                    )->g_pack(-side => 'left', -anchor => 'w');
            $jd_skip_frame->new_label(
                    -textvariable => \$jd_skip_explain,
                    -font         => 'default',
                    )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        }

        $row++;
        $f->new_label(
                -text => "Available Data: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($data_range = $f->new_label(
                -text => $bdate . " to " . $edate,
                -font => 'default',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

        $row++;
        $f->new_label(
                -text => "Date Limits: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($data_frame = $f->new_frame(
                -borderwidth => 0,
                -relief      => 'flat',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
        $data_frame->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "Restrict date range ",
                -font     => 'default',
                -variable => \$dt_limits,
                -command  => sub { if ($dt_limits) {
                                       $bdate_label->g_grid();
                                       $bdate_frame->g_grid();
                                       $edate_label->g_grid();
                                       $edate_frame->g_grid();
                                   } else {
                                       $bdate_label->g_grid_remove();
                                       $bdate_frame->g_grid_remove();
                                       $edate_label->g_grid_remove();
                                       $edate_frame->g_grid_remove();
                                   }
                                 },
                )->g_pack(-side => 'left', -anchor => 'w');
        $data_frame->new_button(
                -text    => "Help",
                -command => sub { &pop_up_info($w2slice_mod_menu,
                                        "W2Anim may run out of memory if too many large slice images\n"
                                      . "have to be generated to produce an animation. The user can\n"
                                      . "limit the date range of a W2 longitudinal slice animation by\n"
                                      . "choosing a shorter range of dates from the W2 output. The\n"
                                      . "start and end dates are for midnight at the start of those days.\n\n"
                                      . "In most instances, such a restriction is unnecessary.",
                                        "Date Range Restriction Notice");
                                },
                )->g_pack(-side => 'left', -anchor => 'w', -padx => 2);

        $row++;
        ($bdate_label = $f->new_label(
                -text => "Start Date: ",
                -font => 'default',
                ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($bdate_frame = $f->new_frame(
                -borderwidth => 0,
                -relief      => 'flat',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
        ($bmon_cb = $bdate_frame->new_ttk__combobox(
                -textvariable => \$bmon,
                -values       => [ @mon_names ],
                -state        => 'readonly',
                -width        => 4,
                ))->g_pack(-side => 'left');
        $bmon_cb->g_bind("<<ComboboxSelected>>",
                        sub { &set_leap_year($byr);
                              $bm = &list_match($bmon, @mon_names);
                              $bday_cb->configure(-values => [ 1 .. $days_in_month[$bm] ]);
                              $bday = $days_in_month[$bm] if ($bday > $days_in_month[$bm]);
                            }
                        );
        $bdate_frame->new_label(
                -text => "-",
                -font => 'default',
                )->g_pack(-side => 'left');
        ($bday_cb = $bdate_frame->new_ttk__combobox(
                -textvariable => \$bday,
                -values       => [ 1 .. $days_in_month[$bm] ],
                -state        => 'readonly',
                -width        => 3,
                ))->g_pack(-side => 'left');
        $bdate_frame->new_label(
                -text => "-",
                -font => 'default',
                )->g_pack(-side => 'left');
        ($byr_cb = $bdate_frame->new_ttk__combobox(
                -textvariable => \$byr,
                -values       => [ reverse($yr_min .. $yr_max) ],
                -state        => 'readonly',
                -width        => 5,
                ))->g_pack(-side => 'left');
        $byr_cb->g_bind("<<ComboboxSelected>>",
                        sub { &set_leap_year($byr);
                              $bm = &list_match($bmon, @mon_names);
                              if ($bm == 1) {
                                  $bday_cb->configure(-values => [ 1 .. $days_in_month[$bm] ]);
                                  $bday = $days_in_month[$bm] if ($bday > $days_in_month[$bm]);
                              }
                              if ($byr == $yr_min || $byr == $yr_max) {
                                  $yr_min -= 5 if ($byr == $yr_min);
                                  $yr_max += 5 if ($byr == $yr_max);
                                  $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                  $byr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                  $eyr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                              }
                            }
                        );

        $row++;
        ($edate_label = $f->new_label(
                -text => "End Date: ",
                -font => 'default',
                ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($edate_frame = $f->new_frame(
                -borderwidth => 0,
                -relief      => 'flat',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
        ($emon_cb = $edate_frame->new_ttk__combobox(
                -textvariable => \$emon,
                -values       => [ @mon_names ],
                -state        => 'readonly',
                -width        => 4,
                ))->g_pack(-side => 'left');
        $emon_cb->g_bind("<<ComboboxSelected>>",
                        sub { &set_leap_year($eyr);
                              $em = &list_match($emon, @mon_names);
                              $eday_cb->configure(-values => [ 1 .. $days_in_month[$em] ]);
                              $eday = $days_in_month[$em] if ($eday > $days_in_month[$em]);
                            }
                        );
        $edate_frame->new_label(
                -text => "-",
                -font => 'default',
                )->g_pack(-side => 'left');
        ($eday_cb = $edate_frame->new_ttk__combobox(
                -textvariable => \$eday,
                -values       => [ 1 .. $days_in_month[$em] ],
                -state        => 'readonly',
                -width        => 3,
                ))->g_pack(-side => 'left');
        $edate_frame->new_label(
                -text => "-",
                -font => 'default',
                )->g_pack(-side => 'left');
        ($eyr_cb = $edate_frame->new_ttk__combobox(
                -textvariable => \$eyr,
                -values       => [ reverse($yr_min .. $yr_max) ],
                -state        => 'readonly',
                -width        => 5,
                ))->g_pack(-side => 'left');
        $eyr_cb->g_bind("<<ComboboxSelected>>",
                        sub { &set_leap_year($eyr);
                              $em = &list_match($emon, @mon_names);
                              if ($em == 1) {
                                  $eday_cb->configure(-values => [ 1 .. $days_in_month[$em] ]);
                                  $eday = $days_in_month[$em] if ($eday > $days_in_month[$em]);
                              }
                              if ($eyr == $yr_min || $eyr == $yr_max) {
                                  $yr_min -= 5 if ($eyr == $yr_min);
                                  $yr_max += 5 if ($eyr == $yr_max);
                                  $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                  $byr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                  $eyr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                              }
                            }
                        );

        if (! $dt_limits) {
            $bdate_label->g_grid_remove();
            $bdate_frame->g_grid_remove();
            $edate_label->g_grid_remove();
            $edate_frame->g_grid_remove();
        }
    }

    if ($parm eq "Temperature" || $parm eq "Horizontal Velocity" || $parm eq "Density" || $parm eq "Habitat"
                               || $parm eq "Vertical Velocity" || $#parm_divlist == 0) {
        $parm_div_label->g_pack_forget();
        $parm_div_cb->g_pack_forget();
    } else {
        $parm_div_label->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        $parm_div_cb->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    }
    if ($conv_type ne "Custom") {
        $custom_frame->g_grid_remove();
    }
    if ($parm eq "Temperature") {
        $units_cb->g_grid();
        $units_entry->g_grid_remove();
        $conv_type_na_label->g_grid();
        $custom_frame->g_grid_remove();
        $conv_type_cb->g_grid_remove();
        $conv_type = "None";
        $parm_div  = "None";
    } else {
        $units_cb->g_grid_remove();
        $units_entry->g_grid();
        $conv_type_na_label->g_grid_remove();
        $custom_frame->g_grid() if ($conv_type eq "Custom");
        $conv_type_cb->g_grid();
    }
    $f->g_grid_columnconfigure(2, -weight => 2);

    Tkx::wm_resizable($w2slice_mod_menu,0,0);
    &adjust_window_position($w2slice_mod_menu);
    $w2slice_mod_menu->g_focus;
}


sub make_w2_slice {
    my ($canv, $id, $props_updated) = @_;
    my (
        $box_id, $change, $cs_max, $cs_min, $cs_range, $cs_rev, $cscheme1,
        $cscheme2, $cshade, $cvert, $day, $date_id, $date_label, $dsize,
        $dsum, $dt, $dt_begin, $dt_end, $dy, $dy_full, $geom, $group_tags,
        $gtag, $i, $id2, $ih, $img, $img_data, $indx, $item, $iw, $j,
        $jb, $jw, $k, $kalt, $kmx, $kn_digits, $kt, $last_jb, $last_jw,
        $last_seg, $mismatch, $mon, $move_mcursor, $mult, $mydt, $n,
        $nbr, $ncolors, $new_graph, $ns, $nsegs, $nwb, $parm_short,
        $pbar, $pbar1, $pbar2, $pbar_frame, $pbar_window, $refresh_menus,
        $resized, $seg_dn, $seg_list, $seg_up, $src_type, $stop_processing,
        $surf_elev, $tabid, $tag, $update_cs, $X, $x1, $x2, $xbase, $xd1,
        $xd2, $xdistance, $xmax, $xmin, $xmult, $xp, $xp1, $xp2, $xrange,
        $Y, $y1, $y2, $yexag, $ymax, $ymin, $yp, $yp_start, $yp1, $yp1r,
        $yp2, $yp2r, $yr, $yrange,

        @be, @bs, @bth_files, @cdata, @colors, @coords, @cpl_files, @cpl_lines,
        @cus, @dlx, @ds, @el, @elws, @grp_tags, @img_keys, @items, @kb,
        @ktwb, @mydates, @old_coords, @pdata, @scale, @seg_limits, @seg_wb,
        @seglist, @slice_data, @slope, @tags, @tecplot, @us, @wbs, @xdist,

        %axis_props, %color_key_props, %limits, %parms, %profile, %sdata,
        %slice_img,
       );

#   For new plots, pop up a menu for file names and parameters
    if (! defined($props{$id}{files})) {
        return &setup_w2_slice_or_tdmap_or_wlevels($canv, $id);
    }

#   Make tag and get coordinates of graph frame
    $gtag   = "graph" . $id;
    @coords = @{ $props{$id}{coordlist} };
    ($x1, $y1, $x2, $y2) = @coords;

#   Determine whether group tags are present and save the list
    $group_tags = 0;
    @grp_tags   = ();
    @tags       = Tkx::SplitList($canv->itemcget($id, -tags));
    if (&list_search("group_", @tags) > -1) {
        $group_tags = 1;
        foreach $tag (@tags) {
            push (@grp_tags, $tag) if ($tag =~ /^group_/);
        }
    }

#   Read the data files, if not done already
    if (! defined($props{$id}{data}) || ! $props{$id}{data}) {
        %parms    = %{ $props{$id}{parms} };
        @wbs      = split(/,/, $props{$id}{wb_list});
        $src_type = $props{$id}{src_type};

        if (defined($props{$id}{oldcoords})) {
            %profile   = %{ $gr_props{$id} };
            $change    = $parms{change};      # values:  parm, misc
            $new_graph = 0;
        } else {
            %profile   = ();
            $change    = "";
            $new_graph = 1;
        }

        $dt_begin = $dt_end = -999;
        if ($props{$id}{dt_limits}) {
            ($mon, $day, $yr) = &parse_date($props{$id}{dt_begin}, 1);
            $dt_begin = sprintf("%04d%02d%02d0000", $yr, $mon, $day);
            ($mon, $day, $yr) = &parse_date($props{$id}{dt_end}, 1);
            $dt_end   = sprintf("%04d%02d%02d0000", $yr, $mon, $day);
        }

#       Read bathymetry files, as necessary
#       Required for all source file types. Vector (w2l) files don't have a good kb value.
        if ($new_graph) {
            $status_line = "Reading bathymetry files...";
            Tkx::update_idletasks();
            @bth_files = @{ $props{$id}{bth_files} };
            for ($n=0; $n<=$#wbs; $n++) {
                &read_bth($main, $id, $wbs[$n], $bth_files[$n]);
            }
            $status_line = "";
            Tkx::update_idletasks();
        }

#       Move mouse cursor on first creation, to ensure that it changes to cursor_wait
        if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
            $canv->g_bind("<Motion>", "");
            Tkx::event_generate($main, "<Motion>", -warp => 1, -x => ($x1+$x2)/2, -y => ($y1+$y2)/2);
            $canv->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"), $canv, "menu" ]);
        }

#       Read contour files or vector file
        if ($src_type =~ /Contour/i) {
            @tecplot   = @{ $props{$id}{tecplot}   };
            @cpl_lines = @{ $props{$id}{cpl_lines} };
            @cpl_files = @{ $props{$id}{cpl_files} };
            for ($n=0; $n<=$#wbs; $n++) {
                $jw = $wbs[$n];
                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $cpl_lines[$n],
                                                             "Reading W2 contour file...");
                %sdata = &read_w2_cpl_file($main, $id, $jw, $cpl_files[$n], $tecplot[$n], 0,
                                           $props{$id}{parm},  $props{$id}{parm_div}, $props{$id}{byear},
                                           $props{$id}{tz_offset}, $props{$id}{jd_skip}, $pbar,
                                           $dt_begin, $dt_end);
                &destroy_progress_bar($main, $pbar_window);

#               Data conversion
                if (&list_match($props{$id}{ctype}, @conv_types) > 0 || $props{$id}{ctype} =~ /^Custom,/) {
                    $status_line = "Converting units...";
                    Tkx::update_idletasks();
                    %sdata = &convert_slice_data($main, $props{$id}{ctype}, $id, $jw, %sdata);
                    $status_line = "";
                    Tkx::update_idletasks();
                }
                $slice_data[$n] = { %sdata };
            }

        } elsif ($src_type =~ /Vector/i) {
            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, -s $props{$id}{w2l_file},
                                                         "Reading W2 vector file...");
            $status_line = "Reading W2 vector file... Date = 1";
            %sdata = &read_w2_vector_file($main, $id, $props{$id}{w2l_file}, 0,
                                          $props{$id}{parm}, $props{$id}{parm_div}, $props{$id}{byear},
                                          $props{$id}{tz_offset}, $props{$id}{jd_skip}, $pbar,
                                          $dt_begin, $dt_end);
            &destroy_progress_bar($main, $pbar_window);

#           Data conversion
            if (&list_match($props{$id}{ctype}, @conv_types) > 0 || $props{$id}{ctype} =~ /^Custom,/) {
                $status_line = "Converting units...";
                Tkx::update_idletasks();
                %sdata = &convert_slice_data($main, $props{$id}{ctype}, $id, 'all', %sdata);
                $status_line = "";
                Tkx::update_idletasks();
            }
            $slice_data[0] = { %sdata };
        }
        $profile{slice_data} = [ @slice_data ];

#       Find minimum and maximum elevation and parameter values
        %limits = &find_w2_slice_limits($id, %profile);
        $profile{date_min} = $limits{date_min};
        $profile{date_max} = $limits{date_max};
        $profile{dpth_min} = $limits{dpth_min};
        $profile{dpth_max} = $limits{dpth_max};
        $profile{elev_min} = $limits{elev_min};
        $profile{elev_max} = $limits{elev_max};
        $profile{parm_min} = $limits{parm_min};
        $profile{parm_max} = $limits{parm_max};
        undef %limits;

        if ($new_graph) {
            $profile{yfont}     = $default_family;
            $profile{yl_size}   = &min(11, &max(8, int((abs($x2-$x1)+abs($y2-$y1))/2./41)));
            $profile{yt_size}   = $profile{yl_size} +2;
            $profile{yl_weight} = 'normal';
            $profile{yt_weight} = 'normal';
            $profile{ytype}     = $parms{ytype};
            $profile{yunits}    = $parms{yunits};
            $profile{ymin}      = ($parms{ymin} ne "") ? $parms{ymin} : 0;
            $profile{ymax}      = $parms{ymax};
            $profile{ymajor}    = ($parms{ymajor} eq "") ? "auto" : $parms{ymajor};
            $profile{ypr_tics}  = "outside";
            $profile{yop_tics}  = "none";
            $profile{ytitle}    = $parms{ytype} . ", in " . $parms{yunits};

            $profile{xfont}     = $profile{yfont};
            $profile{xl_size}   = $profile{yl_size};
            $profile{xt_size}   = $profile{yt_size};
            $profile{xl_weight} = $profile{yl_weight};
            $profile{xt_weight} = $profile{yt_weight};
            $profile{xunits}    = $parms{xunits};
            $profile{xflip}     = $parms{xflip};
            $profile{xflip_img} = 0;
            $profile{xbase}     = 0;
            $profile{xmin}      = 0;
            $profile{xfirst}    = 0;
            $profile{xmax}      = 0;
            $profile{x_km}      = 0;
            $profile{xmajor}    = "auto";
            $profile{xpr_tics}  = "outside";
            $profile{xop_tics}  = "none";
            $profile{xmax_auto} = 1;
            if ($parms{xunits} eq "kilometers") {
                $profile{xtitle} = "River Kilometer";
            } else {
                $profile{xtitle} = "River Mile";
            }

            $profile{stype}     = "none";
            $profile{sfont}     = $default_family;
            $profile{st_size}   = $profile{xt_size};
            $profile{sl_size}   = $profile{xl_size};
            $profile{st_weight} = $profile{xt_weight};
            $profile{sl_weight} = $profile{xl_weight};
            $profile{smajor}    = "auto";
            $profile{spr_tics}  = "outside";
            $profile{sop_tics}  = "none";
            $profile{stic_loc}  = "upstream edge";
            $profile{sgrid}     = 0;
            $profile{sgrid_col} = '#C0C0C0';
            $profile{bgrid}     = 0;
            $profile{bgrid_col} = '#FF8040';
            $profile{stitle}    = "Segment Number";

            $profile{gtfont}    = $profile{yfont};
            $profile{gt_size}   = $profile{yt_size};
            $profile{gt_weight} = 'bold';
            $profile{gs_size}   = $profile{gt_size} -1;
            $profile{gs_weight} = $profile{gt_weight};

            $profile{keyfont}   = $default_family;
            $profile{kn_size}   = $profile{yl_size};
            $profile{kt_size}   = $profile{yl_size} +2;
            $profile{kt_weight} = 'normal';
            $profile{kn_weight} = 'normal';
            $profile{kn_digits} = 1;

            $profile{add_cs}    = 1;
            $profile{cs_height} = &max(2, &min(18, int(($y2-$y1+1) /$parms{ncolors})));
            if ($parms{cscheme} eq "Blue to Orange") {
                $profile{cscheme1} = "Blue";
                $profile{cscheme2} = "Orange";
                $profile{ncolors}  = $parms{ncolors} /2;
            } elsif ($parms{cscheme} eq "Blue to Red") {
                $profile{cscheme1} = "Blue";
                $profile{cscheme2} = "Red";
                $profile{ncolors}  = $parms{ncolors} /2;
            } else {
                $profile{cscheme1} = $parms{cscheme};
                $profile{cscheme2} = "None";
                $profile{ncolors}  = $parms{ncolors};
            }
            $profile{cs_rev}   =  0;
            $profile{cs_hide}  =  0;
            $profile{xleg_off} = 40;
            $profile{yleg_off} =  0;
            $profile{cs_width} = 24;
            $profile{cs_link}  =  0;
            $profile{cs_major} = "auto";
        }

        if ($props{$id}{parm} eq "Temperature") {
            $profile{keytitle} = "Temperature, in degrees " . $props{$id}{parm_units};
        } else {
            $parm_short = $props{$id}{parm};
            $parm_short =~ s/\(ms-1\)//i;
            $parm_short =~ s/\(m3s-1\)//i;
            $parm_short =~ s/ [kmu]?g\/L\/day//i;
            $parm_short =~ s/ [kmu]?g\/m2\/day//i;
            $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
            $parm_short =~ s/ [kmu]?g\/L//i;
            $parm_short =~ s/ [kmu]?g\/m3//i;
            $parm_short =~ s/ [kmu]?g\/m\^3//i;
            $parm_short =~ s/, days//i;
            $parm_short =~ s/ days//i;
            $parm_short =~ s/,$//;
            $profile{keytitle} = $parm_short . ", in " . $props{$id}{parm_units};
        }
        $profile{gtitle}   = $parms{gtitle};
        $profile{cs_min}   = $parms{pmin};
        $profile{cs_max}   = $parms{pmax};
        $profile{cs_major} = $parms{pmajor} if (! $new_graph);

        if (@animate_ids && $#animate_ids >= 0) {
            $update_cs = 0;
            foreach $item (@animate_ids) {
                next if ($item == $id);
                next if ($props{$item}{meta} =~ /time_series|w2_wlevels/);
                next if ($props{$item}{meta} eq "w2_outflow" && ! $props{$item}{add_parm});
                if ($gr_props{$item}{cs_link} == 2) {
                    if ($props{$item}{meta} =~ /(w2_slice|w2_profile|w2_outflow)/
                         && $props{$item}{parm}       eq $props{$id}{parm}
                         && $props{$item}{parm_div}   eq $props{$id}{parm_div}
                         && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                        $update_cs = 1;
                        $id2 = $item;
                        last;
                    } elsif ($props{$item}{meta} eq "w2_tdmap"
                         && $props{$item}{map_type}   eq "standard"
                         && $props{$item}{parm_sav}   eq $props{$id}{parm}
                         && $props{$item}{pdiv_sav}   eq $props{$id}{parm_div}
                         && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                        $update_cs = 1;
                        $id2 = $item;
                        last;
                    } elsif ($props{$item}{meta} =~ /data_profile/
                         && $props{$item}{prof_type}  eq "standard"
                         && $props{$item}{parm}       eq $props{$id}{parm}
                         && $props{$id}{parm_div}     eq "None"
                         && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                        $update_cs = 1;
                        $id2 = $item;
                        last;
                    } elsif ($props{$item}{meta} =~ /vert_wd_zone/
                         && $props{$id}{parm}       eq "Temperature"
                         && $props{$id}{parm_div}   eq "None"
                         && $props{$item}{wt_units} eq $props{$id}{parm_units}) {
                        $update_cs = 1;
                        $id2 = $item;
                        last;
                    }
                }
            }
            if (! $update_cs) {
                foreach $item (@animate_ids) {
                    next if ($item == $id);
                    next if ($props{$item}{meta} =~ /data_profile|vert_wd_zone|time_series|w2_wlevels/);
                    next if ($props{$item}{meta} eq "w2_outflow" && ! $props{$item}{add_parm});
                    next if ($props{$item}{meta} =~ /w2_profile|w2_outflow|w2_tdmap/
                             && $props{$item}{src_type} ne $src_type);
                    if ($gr_props{$item}{cs_link} == 1) {
                        if ($props{$item}{meta} =~ /w2_slice/
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$item}{parm_div}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}
                             && $props{$item}{con_file}   eq $props{$id}{con_file}
                             && $props{$item}{src_type}   eq $props{$id}{src_type}) {
                            $update_cs = 1;
                            $id2 = $item;
                            last;
                        } elsif ($props{$item}{meta} eq "w2_tdmap"
                             && $props{$item}{map_type}   eq "standard"
                             && $props{$item}{parm_sav}   eq $props{$id}{parm}
                             && $props{$item}{pdiv_sav}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}
                             && $props{$item}{con_file}   eq $props{$id}{con_file}
                             && $props{$item}{src_type}   eq $props{$id}{src_type}) {
                            $update_cs = 1;
                            $id2 = $item;
                            last;
                        } elsif ($props{$item}{meta} =~ /w2_profile|w2_outflow/
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$item}{parm_div}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            if ($src_type =~ /Contour/i) {
                                for ($n=0; $n<=$#wbs; $n++) {
                                    if ($cpl_files[$n] eq $props{$item}{src_file}) {
                                        $update_cs = 1;
                                        $id2 = $item;
                                        last;
                                    }
                                }
                                last if ($update_cs);
                            } elsif ($src_type =~ /Vector/i) {
                                if ($props{$id}{w2l_file} eq $props{$item}{src_file}) {
                                    $update_cs = 1;
                                    $id2 = $item;
                                    last;
                                }
                            }
                        }
                    }
                }
            }
            if ($update_cs) {
                $ncolors           = $profile{ncolors};
                $profile{cs_link}  = $gr_props{$id2}{cs_link};
                $profile{cscheme1} = $gr_props{$id2}{cscheme1};
                $profile{cscheme2} = $gr_props{$id2}{cscheme2};
                $profile{ncolors}  = $gr_props{$id2}{ncolors};
                $profile{cs_rev}   = $gr_props{$id2}{cs_rev};
                $profile{cs_min}   = $gr_props{$id2}{cs_min};
                $profile{cs_max}   = $gr_props{$id2}{cs_max};
                $profile{cs_major} = $gr_props{$id2}{cs_major};
                if ($new_graph) {
                    if ($profile{cs_height} *$ncolors > $y2-$y1+1 && $profile{cs_height} > 2) {
                        $profile{cs_height} = &max(2, &min(18, int(($y2-$y1+1) /$profile{ncolors})));
                    }
                } elsif ($ncolors != $profile{ncolors}) {
                    $profile{cs_height} = &max(2, &min(30,
                                   &round_to_int($profile{cs_height} *$ncolors /$profile{ncolors})));
                }
            }
        }
        if (! $new_graph) {
            undef $gr_props{$id};
            if (defined($profile{slice_img})) {
                undef $profile{slice_img};
            }
        }
        $profile{redraw}  = 1;
        $gr_props{$id}    = { %profile };
        $props{$id}{data} = 1;
        $props{$id}{gnum} = ++$graph_num if (! defined($props{$id}{oldcoords}));
        $resized          = 0;
        $refresh_menus    = 0;
        undef %profile;

#       Rebuild the dates array if different jd_skip or byear.
#       The rebuild option is determined in change_w2_slice.
        if (! $new_graph) {
            &rebuild_datelist if ($parms{rebuild});
            $refresh_menus = 1;
            $canv->delete($gtag . "_xaxis");
            $canv->delete($gtag . "_xaxisTitle");
            $canv->delete($gtag . "_yaxis");
            $canv->delete($gtag . "_yaxisTitle");
            $canv->delete($gtag . "_saxis");
            $canv->delete($gtag . "_saxisTitle");
            $canv->delete($gtag . "_sgrid");
            $canv->delete($gtag . "_date");
            $canv->delete($gtag . "_gtitle");
            $canv->delete($gtag . "_colorKey");
            $canv->delete($gtag . "_colorKeyTitle");
            $canv->delete($gtag . "_noData");
            $canv->delete($gtag . "_colorMap");
        }
        undef %parms;

#   Or use previously read info.  If resized, delete graph and redraw
    } else {
        @old_coords    = @{ $props{$id}{oldcoords} };
        $refresh_menus = 0;
        $resized       = 0;
        for ($i=0; $i<=$#coords; $i++) {
            if ($coords[$i] != $old_coords[$i]) {
                $resized = 1;
                last;
            }
        }
        return if (! $resized && ! $props_updated);
        $gr_props{$id}{redraw} = 1 if ($resized);

        @slice_data = @{ $gr_props{$id}{slice_data} };
        @wbs        = split(/,/, $props{$id}{wb_list});
        $src_type   = $props{$id}{src_type};

        $canv->delete($gtag . "_xaxis");
        $canv->delete($gtag . "_xaxisTitle");
        $canv->delete($gtag . "_yaxis");
        $canv->delete($gtag . "_yaxisTitle");
        $canv->delete($gtag . "_saxis");
        $canv->delete($gtag . "_saxisTitle");
        $canv->delete($gtag . "_sgrid");
        $canv->delete($gtag . "_date");
        $canv->delete($gtag . "_gtitle");
        $canv->delete($gtag . "_colorKey");
        $canv->delete($gtag . "_colorKeyTitle");
        if ($gr_props{$id}{redraw}) {
            $canv->delete($gtag . "_noData");
            $canv->delete($gtag . "_colorMap");
        }
    }
    $props{$id}{oldcoords} = [ @coords ];

#   Check the dates from each waterbody's dataset, if using contour files
    if ($#wbs > 0 && $src_type =~ /Contour/i) {
        %sdata   = %{ $slice_data[0] };
        @mydates = keys %sdata;
        $dsum    = &sum(@mydates);
        for ($n=1; $n<=$#wbs; $n++) {
            %sdata   = %{ $slice_data[$n] };
            @mydates = keys %sdata;
            if ($dsum != &sum(@mydates)) {
                &pop_up_info($main, "Contour file dates for waterbody " . $wbs[$n] . "\n"
                                  . "do not match those for waterbody " . $wbs[0] . "\n"
                                  . "This could lead to visualization problems.");
            }
        }
    }

#   Set the list of dates or merge the dates array if necessary
#   Add the graph to the list of animated graphs, if necessary
#   For first creation, ensure mouse cursor is on canvas so it can be changed
    %sdata   = %{ $slice_data[0] };
    @mydates = sort keys %sdata;
    if (! $props{$id}{dt_limits} && $props{$id}{jd_skip} == 0) {
        $props{$id}{start_dt} = $mydates[0];
        $props{$id}{end_dt}   = $mydates[$#mydates];
    }
    $move_mcursor = 0;
    if (! @animate_ids || &list_match($id, @animate_ids) == -1) {
        $move_mcursor = 1;
        if (@dates && @animate_ids && $#animate_ids >= 0) {
            $mismatch = 0;
            foreach $id2 (@animate_ids) {
#               next if ($id2 == $id);
                next if ($props{$id2}{meta} =~ /data_profile_cmap|w2_profile_cmap|w2_tdmap|time_series/);
                if ($props{$id2}{meta} eq "w2_profile") {
                    if ($props{$id2}{src_type}      ne $src_type
                         || $props{$id2}{byear}     != $props{$id}{byear}
                         || $props{$id2}{tz_offset} ne $props{$id}{tz_offset}
                         || $props{$id2}{jd_skip}   != $props{$id}{jd_skip}) {
                        $mismatch = 1;
                        last;
                    }
                    if ($src_type =~ /Contour/i) {
                        @cpl_files = @{ $props{$id}{cpl_files} };
                        $mismatch  = 1;
                        for ($n=0; $n<=$#wbs; $n++) {
                            if ($cpl_files[$n] eq $props{$id2}{src_file}) {
                                $mismatch = 0;
                                last;
                            }
                        }
                        last if ($mismatch);
                    } elsif ($src_type =~ /Vector/i) {
                        if ($props{$id}{w2l_file} ne $props{$id2}{src_file}) {
                            $mismatch = 1;
                            last;
                        }
                    }
                } elsif ($props{$id2}{meta} =~ /w2_slice|w2_wlevels/) {
                    if ($props{$id2}{con_file}     ne $props{$id}{con_file}
                        || $props{$id2}{src_type}  ne $src_type
                        || $props{$id2}{byear}     != $props{$id}{byear}
                        || $props{$id2}{tz_offset} ne $props{$id}{tz_offset} 
                        || $props{$id2}{jd_skip}   != $props{$id}{jd_skip}) {
                        $mismatch = 1;
                        last;
                    }
                    if ($props{$id2}{meta} eq "w2_slice") {
                        if ($props{$id2}{dt_limits}) {
                            if (! $props{$id}{dt_limits}
                                   || $props{$id2}{dt_begin} ne $props{$id}{dt_begin}
                                   || $props{$id2}{dt_end}   ne $props{$id}{dt_end}) {
                                $mismatch = 1;
                                last;
                            }
                        }
                    }
                } elsif ($props{$id2}{meta} =~ /^(data_profile|vert_wd_zone|w2_outflow)$/) {
                    $mismatch = 1;
                    last;
                }
            }
            if ($mismatch) {
                if (defined($animate_tb) && Tkx::winfo_exists($animate_tb)) {
                    if ($animate_tb->g_wm_title() eq "Animation toolbar") {
                        $animate_tb->g_destroy();
                        undef $animate_tb;
                    }
                }
                $dt    = $dates[$dti-1];
                @dates = &merge_dates(\@dates, \@mydates);
                $dti   = 1 + &nearest_dt_index($dt, @dates);
                $dti++ if ($dti == 0);
            }
        } else {
            @dates = @mydates;
            $dti   = 1;
            $delay = 0.5;
        }
        if ($global_dt_limits) {     # Truncate date range if global limits
            $dt    = $dates[$dti-1];
            @dates = &truncate_dates($global_dt_begin, $global_dt_end, @dates);
            $dti   = 1 + &nearest_dt_index($dt, @dates);
            $dti++ if ($dti == 0);
        }
        $dti_max = $#dates+1;
        $dti_old = $dti;
        push (@animate_ids, $id);
    }
    $dt = $dates[$dti-1];
    $export_menu->entryconfigure(3, -state => 'normal') if ($use_GS);
    $pref_menu->entryconfigure(0,   -state => 'normal');

#   Plot a white rectangle below the graph frame
    @items     = Tkx::SplitList($canv->find_withtag($gtag . "_main"));
    $new_graph = ($#items >= 0) ? 0 : 1;
    if ($new_graph) {
        $box_id = $canv->create_rectangle($x1, $y1, $x2, $y2,
                             -outline => "",
                             -width   => 0,
                             -fill    => &get_rgb_code("white"),
                             -tags    => $gtag . " " . $gtag . "_main");
        $canv->lower($box_id, $id);
    } else {
        $canv->coords($gtag . "_main", @coords);
        $canv->raise($id, $gtag . "_main");
    }

#   Plot Y axis
    $axis_props{min}     = $gr_props{$id}{ymin};
    $axis_props{max}     = $gr_props{$id}{ymax};
    $axis_props{major}   = $gr_props{$id}{ymajor};
    $axis_props{pr_tics} = $gr_props{$id}{ypr_tics};
    $axis_props{op_tics} = $gr_props{$id}{yop_tics};
    $axis_props{minor}   = 1;
    $axis_props{reverse} = ($gr_props{$id}{ytype} eq "Depth") ? 1 : 0;
    $axis_props{title}   = $gr_props{$id}{ytitle};
    $axis_props{font}    = $gr_props{$id}{yfont};
    $axis_props{size1}   = $gr_props{$id}{yl_size};
    $axis_props{size2}   = $gr_props{$id}{yt_size};
    $axis_props{weight1} = $gr_props{$id}{yl_weight};
    $axis_props{weight2} = $gr_props{$id}{yt_weight};
    $axis_props{side}    = "left";
    $axis_props{tags}    = $gtag . " " . $gtag . "_yaxis";
    $axis_props{coords}  = [$x1, $y2, $x1, $y1];
    $axis_props{op_loc}  = $x2;
    &make_axis($canv, %axis_props);
    undef %axis_props;

#   Deal with the color scheme and create the color key
    $cscheme1  = $gr_props{$id}{cscheme1};
    $cscheme2  = $gr_props{$id}{cscheme2};
    $ncolors   = $gr_props{$id}{ncolors};
    $cs_rev    = $gr_props{$id}{cs_rev};
    $cs_min    = $gr_props{$id}{cs_min};
    $cs_max    = $gr_props{$id}{cs_max};
    $kn_digits = $gr_props{$id}{kn_digits};
    if (&list_match($cscheme1, @color_scheme_names) == -1 ||
       (&list_match($cscheme1, @full_color_schemes) == -1 && &list_match($ncolors, @valid_nc) == -1) ||
       (&list_match($cscheme1, @full_color_schemes) >= 0 && &list_match($ncolors, @valid_nc_alt) == -1) ||
       ($cscheme2 ne "" && $cscheme2 ne "None" && &list_match($cscheme2, @color_scheme_names) == -1)) {
        $cscheme1  = $gr_props{$id}{cscheme1}  = "Blue";
        $cscheme2  = $gr_props{$id}{cscheme2}  = "Orange";
        $ncolors   = $gr_props{$id}{ncolors}   = 11;
        $cs_rev    = $gr_props{$id}{cs_rev}    =  0;
        $cs_min    = $gr_props{$id}{cs_min}    =  0;
        $cs_max    = $gr_props{$id}{cs_max}    = 22;
        $kn_digits = $gr_props{$id}{kn_digits} =  1;
    }
    $cs_range = $cs_max -$cs_min;
    @colors   = &make_color_scheme($ncolors, $cs_rev, $cscheme1, $cscheme2);
    @scale    = ();
    for ($i=0; $i<=$#colors+1; $i++) {
        $j = $#colors +1 -$i;
        $scale[$j] = $cs_min +$cs_range*$j/($#colors+1);
    }
    $gr_props{$id}{colors}    = [ @colors ];
    $gr_props{$id}{scale}     = [ @scale  ];

    $color_key_props{xleg}    = $x2 + $gr_props{$id}{xleg_off};
    $color_key_props{yleg}    = $y1 + $gr_props{$id}{yleg_off};
    $color_key_props{width}   = $gr_props{$id}{cs_width};
    $color_key_props{height}  = $gr_props{$id}{cs_height};
    $color_key_props{colors}  = [ @colors ];
    $color_key_props{scale}   = [ @scale  ];
    $color_key_props{title}   = $gr_props{$id}{keytitle};
    $color_key_props{font}    = $gr_props{$id}{keyfont};
    $color_key_props{size1}   = $gr_props{$id}{kn_size};
    $color_key_props{size2}   = $gr_props{$id}{kt_size};
    $color_key_props{weight1} = $gr_props{$id}{kn_weight};
    $color_key_props{weight2} = $gr_props{$id}{kt_weight};
    $color_key_props{digits}  = $kn_digits;
    $color_key_props{major}   = $gr_props{$id}{cs_major};
    $color_key_props{tags}    = $gtag . " " . $gtag . "_colorKey";
    &make_color_key($canv, %color_key_props);
    undef %color_key_props;

    if ($gr_props{$id}{cs_hide}) {
        $canv->itemconfigure($gtag . "_colorKey", -state => 'hidden');
    }

#   Plot the date as a subtitle
    $xp = ($x1+$x2)/2.;
    if (($gr_props{$id}{stype} ne "none"    && $gr_props{$id}{sop_tics} =~ /outside|cross/) ||
        ($gr_props{$id}{stype} ne "replace" && $gr_props{$id}{xop_tics} =~ /outside|cross/)) {
        $yp = $y1-14;
    } else {
        $yp = $y1-6;
    }
    $date_label = &get_formatted_date($dt);
    $date_id = $canv->create_text($xp, $yp,
                       -anchor => 's',
                       -text   => $date_label,
                       -fill   => &get_rgb_code("black"),
                       -angle  => 0,
                       -tags   => $gtag . " " . $gtag . "_date",
                       -font   => [-family     => $gr_props{$id}{gtfont},
                                   -size       => $gr_props{$id}{gs_size},
                                   -weight     => $gr_props{$id}{gs_weight},
                                   -slant      => 'roman',
                                   -underline  => 0,
                                   -overstrike => 0,
                                  ]);
    @coords = Tkx::SplitList($canv->bbox($date_id));
    $dsize  = &max(10, abs($coords[3] - $coords[1]));

#   Plot the graph title
    $canv->create_text($xp, $yp-$dsize,
                       -anchor => 's', 
                       -text   => $gr_props{$id}{gtitle},
                       -fill   => &get_rgb_code("black"),
                       -angle  => 0,
                       -tags   => $gtag . " " . $gtag . "_gtitle",
                       -font   => [-family     => $gr_props{$id}{gtfont},
                                   -size       => $gr_props{$id}{gt_size},
                                   -weight     => $gr_props{$id}{gt_weight},
                                   -slant      => 'roman',
                                   -underline  => 0,
                                   -overstrike => 0,
                                  ]);

#   Initialize some arrays. Get segment list and downstream distance.
    $nwb   = $grid{$id}{nwb};
    $nbr   = $grid{$id}{nbr};
    $kmx   = $grid{$id}{kmx};
    @bs    = @{ $grid{$id}{bs}    };
    @be    = @{ $grid{$id}{be}    };
    @us    = @{ $grid{$id}{us}    };
    @ds    = @{ $grid{$id}{ds}    };
    @dlx   = @{ $grid{$id}{dlx}   };
    @kb    = @{ $grid{$id}{kb}    };
    @el    = @{ $grid{$id}{el}    };
    @slope = @{ $grid{$id}{slope} };

    if (defined($gr_props{$id}{xdist}) && defined($gr_props{$id}{seglist})) {
        @seglist = @{ $gr_props{$id}{seglist} };
        @seg_wb  = @{ $gr_props{$id}{seg_wb}  };
        @xdist   = @{ $gr_props{$id}{xdist}   };  # saved in units of kilometers
    } else {
        $seg_list   = $props{$id}{seg_list};
        @seg_limits = reverse split(/,|-/, $seg_list);  # reverse the order: ds to us
        @seglist    = ();
        @seg_wb     = ();
        $xdistance  = $last_seg = $last_jb = 0;
        for ($j=0; $j<=$#seg_limits; $j+=2) {
            $seg_dn = $seg_limits[$j];
            $seg_up = $seg_limits[$j+1];
            for ($jb=1; $jb<=$nbr; $jb++) {
                last if ($seg_dn >= $us[$jb] && $seg_dn <= $ds[$jb]);
            }
            for ($jw=1; $jw<=$nwb; $jw++) {
                last if ($jb >= $bs[$jw] && $jb <= $be[$jw]);
            }
            if ($j > 1 && $last_seg != $us[$last_jb]) {
                $xdistance       -= $dlx[$last_seg] /2. *0.001;   # km
                $xdist[$last_seg] = $xdistance;
            }
            for ($i=$seg_dn; $i>=$seg_up; $i--) {
                $xdistance += $dlx[$i] *0.001;    # km
                $xdist[$i]  = $xdistance;
                $seg_wb[$i] = $jw;
                push (@seglist, $i);
            }
            $last_seg = $seg_up;
            $last_jb  = $jb;
        }
        $gr_props{$id}{seglist} = [ @seglist ];
        $gr_props{$id}{seg_wb}  = [ @seg_wb  ];
        $gr_props{$id}{xdist}   = [ @xdist   ];
    }
    $xmult = ($gr_props{$id}{xunits} eq "miles") ? 3280.84/5280. : 1.0;
    $xmin  = $gr_props{$id}{xmin};
    $xbase = $gr_props{$id}{xbase};
    if ($gr_props{$id}{xmax_auto}) {
        $xdistance = &round_to_int(1000.*$xdist[$seglist[$#seglist]] *$xmult)/1000.;
        $gr_props{$id}{xmax} = $xmax = $xbase +$xdistance;
    } else {
        $xmax = $gr_props{$id}{xmax};
    }
    $gr_props{$id}{x_km} = $xdist[$seglist[$#seglist]];

#   Update the Y axis exaggeration factor, using meters for Y units
    $mult  = ($gr_props{$id}{yunits} eq "feet") ? 3.28084 : 1.0;
    $ymin  = $gr_props{$id}{ymin} /$mult;
    $ymax  = $gr_props{$id}{ymax} /$mult;
    $yexag = abs( (($xmax -$xmin) /$xmult  /($x2-$x1))
                 /(($ymax -$ymin) /1000.   /($y2-$y1)));
    $props{$id}{yexag_fac} = sprintf("%.4f", $yexag);

#   Plot X axis
    if ($gr_props{$id}{stype} ne "replace") {
        $axis_props{min}     = $xmin;
        $axis_props{max}     = $xmax;
        $axis_props{first}   = $gr_props{$id}{xfirst};
        $axis_props{major}   = $gr_props{$id}{xmajor};
        $axis_props{pr_tics} = $gr_props{$id}{xpr_tics};
        $axis_props{op_tics} = $gr_props{$id}{xop_tics};
        $axis_props{minor}   = 1;
        $axis_props{reverse} = 0;
        $axis_props{title}   = $gr_props{$id}{xtitle};
        $axis_props{font}    = $gr_props{$id}{xfont};
        $axis_props{size1}   = $gr_props{$id}{xl_size};
        $axis_props{size2}   = $gr_props{$id}{xt_size};
        $axis_props{weight1} = $gr_props{$id}{xl_weight};
        $axis_props{weight2} = $gr_props{$id}{xt_weight};
        $axis_props{side}    = "bottom";
        $axis_props{tags}    = $gtag . " " . $gtag . "_xaxis";
        $axis_props{coords}  = ($gr_props{$id}{xflip}) ? [$x2, $y2, $x1, $y2] : [$x1, $y2, $x2, $y2];
        $axis_props{op_loc}  = $y1;
        &make_axis($canv, %axis_props);
        undef %axis_props;
    }
    if ($gr_props{$id}{stype} ne "none") {
        $axis_props{base}     = $xbase /$xmult;           # convert to km
        $axis_props{min}      = $xmin  /$xmult;           # convert to km
        $axis_props{max}      = $xmax  /$xmult;           # convert to km
        $axis_props{dist}     = $gr_props{$id}{xdist};    # distance array in km
        $axis_props{seglist}  = $gr_props{$id}{seglist};  # list of segments, from ds to us
        $axis_props{type}     = $gr_props{$id}{stype};
        $axis_props{major}    = $gr_props{$id}{smajor};
        $axis_props{pr_tics}  = $gr_props{$id}{spr_tics};
        $axis_props{op_tics}  = $gr_props{$id}{sop_tics};
        $axis_props{title}    = $gr_props{$id}{stitle};
        $axis_props{font}     = $gr_props{$id}{sfont};
        $axis_props{size1}    = $gr_props{$id}{sl_size};
        $axis_props{size2}    = $gr_props{$id}{st_size};
        $axis_props{weight1}  = $gr_props{$id}{sl_weight};
        $axis_props{weight2}  = $gr_props{$id}{st_weight};
        $axis_props{tic_loc}  = $gr_props{$id}{stic_loc};
        $axis_props{grid}     = $gr_props{$id}{sgrid};
        $axis_props{gridcol}  = $gr_props{$id}{sgrid_col};
        $axis_props{bgrid}    = $gr_props{$id}{bgrid};
        $axis_props{bgridcol} = $gr_props{$id}{bgrid_col};
        $axis_props{grcoord}  = [$y1, $y2];
        $axis_props{side}     = "bottom";
        $axis_props{tags}     = $gtag . " " . $gtag . "_saxis";
        $axis_props{coords}   = ($gr_props{$id}{xflip}) ? [$x2, $y2, $x1, $y2] : [$x1, $y2, $x2, $y2];
        $axis_props{op_loc}   = $y1;
        &make_seg_axis($canv, %axis_props);
        undef %axis_props;
    }

#   Refresh the Graph Properties menu and Object Information box, if present
    if ($refresh_menus) {
        if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
            if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
                $tabid = $grprops_notebook->index('current');
                $geom  = $graph_props_menu->g_wm_geometry();
                (undef, $X, $Y) = split(/\+/, $geom);
                &edit_graph_props($id, $X, $Y, $tabid);
            }
        }
        if (defined($object_infobox) && Tkx::winfo_exists($object_infobox)) {
            if ($object_infobox->g_wm_title() eq "Object Info") {
                $geom = $object_infobox->g_wm_geometry();
                (undef, $X, $Y) = split(/\+/, $geom);
                &show_info($canv, $id, $X, $Y);
            }
        }
    }

#   Check for a full complement of images; otherwise, regenerate all.
    if (! $gr_props{$id}{redraw}) {
        %slice_img = %{ $gr_props{$id}{slice_img} };
        @img_keys  = keys %slice_img;
        if ($#mydates != $#img_keys) {
            $gr_props{$id}{redraw} = 1;
            $canv->delete($gtag . "_noData");
            $canv->delete($gtag . "_colorMap");
        }
    }
    $gr_props{$id}{xflip_img} = 0 if ($gr_props{$id}{redraw});

#   Don't recompute and redraw unless necessary
    if (! $gr_props{$id}{redraw}) {
        $canv->lower($gtag . "_colorKey",      $id);
        $canv->lower($gtag . "_colorKeyTitle", $id);
        $canv->lower($gtag . "_date",          $id);
        $canv->lower($gtag . "_gtitle",        $id);
        $canv->lower($gtag . "_xaxisTitle",    $id);
        $canv->lower($gtag . "_saxisTitle",    $id);
        $canv->lower($gtag . "_yaxisTitle",    $id);
        $canv->lower($gtag . "_sgrid",         $id);
        $canv->lower($gtag . "_noData",        $id);
        $canv->lower($gtag . "_colorMap",      $id);
        $canv->lower($gtag . "_xaxis",         $id);
        $canv->lower($gtag . "_saxis",         $id);
        $canv->lower($gtag . "_yaxis",         $id);
        if ($group_tags) {
            foreach $tag (@grp_tags) {
                $canv->addtag($tag, withtag => $gtag);
            }
        }
        if ($gr_props{$id}{xflip_img}) {         # Flip existing images
            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $#mydates,
                                        "Flipping slice images...");
            $status_line = "Flipping slice images:  Date = 1";
            $img = Imager->new;
            for ($indx=0; $indx<=$#mydates; $indx++) {
                $mydt = $mydates[$indx];
                &update_progress_bar($pbar, $indx, $mydt);
                $img_data = $slice_img{$mydt}->data(-format => 'png');
                $img->read(data => $img_data);
                $img->flip(dir => "h");
                $img->write(data => \$img_data, type => 'png');
                $slice_img{$mydt}->put($img_data, -format => 'png');
            }
            if (&list_match($dt, @mydates) == -1 || ! defined($slice_img{$dt})) {
                $dt  = $mydates[0];
                $dti = 1 + &nearest_dt_index($dt, @dates);
                $dti++ if ($dti == 0);
                $dti_old = $dti;
            }
            $canv->itemconfigure($gtag . "_colorMap", -image => $slice_img{$dt});
            &destroy_progress_bar($main, $pbar_window);
            $status_line = "Flipping slice images:  Done";
            Tkx::update_idletasks();
            $gr_props{$id}{xflip_img} = 0;
            $gr_props{$id}{slice_img} = { %slice_img };
        }
        undef %slice_img;
        return;
    }

#   Create a progress bar
    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $geom = sprintf("+%d+%d", $X+($x1+$x2)/2-150, $Y+($y1+$y2)/2);

    $pbar_window = $main->new_toplevel();
    $pbar_window->g_wm_transient($main);
    $pbar_window->g_wm_title("Creating colormap slices...");
    $pbar_window->g_wm_geometry($geom);
    $pbar_window->configure(-cursor => $cursor_wait);
    $pbar_window->g_focus;
    $pbar_window->g_bind('<Destroy>' => sub { $stop_processing = 1;
                                              $pbar_window->g_grab_release();
                                              $pbar_window->g_bind('<Destroy>' => "");
                                              Tkx::update_idletasks();
                                            });

    ($pbar_frame = $pbar_window->new_frame(
                    -borderwidth => 2,
                    -relief      => 'groove',
                    ))->g_pack(-anchor => 'nw', -expand => 1, -fill => 'x');
    ($pbar1 = $pbar_frame->new_ttk__progressbar(
                    -orient  => 'horizontal',
                    -length  => 300,
                    -mode    => 'determinate',
                    -value   => 0,
                    -maximum => $#mydates,
                    ))->g_grid(-row => 0, -column => 0);
    ($pbar2 = $pbar_frame->new_ttk__progressbar(
                    -orient  => 'horizontal',
                    -length  => 300,
                    -mode    => 'determinate',
                    -value   => 0,
                    -maximum => $#seglist,
                    ))->g_grid(-row => 1, -column => 0);
    $pbar_frame->new_button(
                    -text    => "Cancel",
                    -font    => 'default',
                    -cursor  => $cursor_select,
                    -command => sub { $stop_processing = 1; },
                    )->g_grid(-row => 1, -column => 1);

#   Move mouse cursor on first creation, to ensure that it changes to cursor_wait
    if ($move_mcursor) {
        if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
            $canv->g_bind("<Motion>", "");
            Tkx::event_generate($main, "<Motion>", -warp => 1, -x => ($x1+$x2)/2, -y => ($y1+$y2)/2);
            $canv->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"), $canv, "menu" ]);
        }
    }

#   Prepare the application to appear busy.
    $status_line = "Creating colormap slices:  Date = 1";
    $canv->configure(-cursor => $cursor_wait);
    $main->configure(-cursor => $cursor_wait);
    $pbar_window->g_focus;
    $pbar_window->g_grab_set();
    Tkx::update();
    Tkx::wm_resizable($pbar_window,0,0);

#   Create a placeholder image
    $iw = $x2 -$x1 +1;
    $ih = $y2 -$y1 +1;
    undef %slice_img;
    %slice_img = ();
    $img = Tkx::image_create_photo(-width => $iw, -height => $ih);
    $img = Tkx::widget->new($img);
    $canv->create_image($x1, $y1, -anchor => 'nw',
                                  -image  => $img,
                                  -tags   => $gtag . " " . $gtag . "_colorMap");

#   Loop over the dates
    $xrange = $xmax -$xmin;   # user units (miles or kilometers)
    $yrange = $ymax -$ymin;   # meters
    $stop_processing = 0;
    for ($indx=0; $indx<=$#mydates; $indx++) {
        $mydt = $mydates[$indx];
        if ($src_type =~ /Vector/i) {
            @ktwb  = @{ $sdata{$mydt}{kt}        };
            @cus   = @{ $sdata{$mydt}{cus}       };
            @elws  = @{ $sdata{$mydt}{elws}      };
            @pdata = @{ $sdata{$mydt}{parm_data} };
        }

#       Reset the progress bars
        $nsegs = 0;
        $pbar1->configure(-value => $indx);
        $pbar2->configure(-value => $nsegs);
        $status_line =~ s/  Date = \d+$/  Date = $mydt/;
        Tkx::update();
        last if ($stop_processing);

#       Create an image to hold the colormap and recognize its methods
        $slice_img{$mydt} = Tkx::image_create_photo(-width => $iw, -height => $ih);
        $slice_img{$mydt} = Tkx::widget->new($slice_img{$mydt});

#       Loop over the segment list
        $last_jw = 0;
        for ($ns=0; $ns<=$#seglist; $ns++) {
            $nsegs++;
            $i  = $seglist[$ns];
            $jw = $seg_wb[$i];
            if ($src_type =~ /Contour/i) {
                if ($ns == 0 || $jw != $last_jw) {
                    $n     = &list_match($jw, @wbs);
                    %sdata = %{ $slice_data[$n] };
                    if (defined($sdata{$mydt})) {
                        $kt    = $sdata{$mydt}{kt};
                        @cus   = @{ $sdata{$mydt}{cus}       };
                        @elws  = @{ $sdata{$mydt}{elws}      };
                        @pdata = @{ $sdata{$mydt}{parm_data} };
                    }
                    $last_jw = $jw;
                }
            } elsif ($src_type =~ /Vector/i) {
                $kt = $ktwb[$jw];
            }
            $pbar2->configure(-value => $nsegs);
            Tkx::update_idletasks();
            next if (! defined($sdata{$mydt}));

#           Check for segment upstream of current upstream segment
            for ($jb=$bs[$jw]; $jb<=$be[$jw]; $jb++) {
                last if ($i >= $us[$jb] && $i <= $ds[$jb]);
            }
            next if (! defined($cus[$jb]) || $i < $cus[$jb]);

#           X limits
            $xd1 = ($ns == 0) ? 0 : $xdist[$seglist[$ns-1]] *$xmult;
            $xd2 = $xdist[$i] *$xmult;
            if ($gr_props{$id}{xflip}) {
                $xp1 = &round_to_int(($iw-1)*(1.-($xd1 +$xbase -$xmin)/$xrange));
                $xp2 = &round_to_int(($iw-1)*(1.-($xd2 +$xbase -$xmin)/$xrange));
                next if ($xp2 > $iw-1);
                last if ($xp1 < 0);
            } else {
                $xp1 = &round_to_int(($iw-1)*($xd1 +$xbase -$xmin)/$xrange);
                $xp2 = &round_to_int(($iw-1)*($xd2 +$xbase -$xmin)/$xrange);
                next if ($xp2 < 0);
                last if ($xp1 > $iw-1);
            }
            $xp1 = &max(0, &min($iw-1, $xp1));
            $xp2 = &max(0, &min($iw-1, $xp2));
            next if ($xp1 == $xp2 && $ns < $#seglist);

#           Cycle through the layers and add to the color map
            $surf_elev = $elws[$i];
            if ($gr_props{$id}{ytype} eq "Depth" || $slope[$jb] == 0.0) {
                if ($gr_props{$id}{ytype} eq "Depth") {
                    $yp2 = 0;
                } else {
                    $yp2 = &round_to_int(($ih-1)*(1.-($surf_elev-$ymin)/$yrange));
                    $yp2 = &max(0, &min($ih-1, $yp2));
                }
                for ($k=$kt; $k<$kmx; $k++) {
                    $yp1  = $yp2;
                    $kalt = ($k > $kb[$i]) ? $kb[$i] : $k;
                    if ($gr_props{$id}{ytype} eq "Depth") {
                        $yp2 = &round_to_int(($ih-1)*($surf_elev-$el[$kalt+1][$i])/$ymax);
                    } else {
                        $yp2 = &round_to_int(($ih-1)*(1.-($el[$kalt+1][$i]-$ymin)/$yrange));
                    }
                    last if ($yp1 >= $ih-1);
                    if ($yp2 < 0) {
                        $yp2 = 0;
                        next;
                    }
                    $yp2 = &max(0, &min($ih-1, $yp2));
                    next if ($yp1 == $yp2 && $k < $kb[$i]);
                    if (defined($pdata[$k][$i])) {
                        if ($props{$id}{parm} eq "Temperature" && $props{$id}{parm_units} eq "Fahrenheit") {
                            $j = int(($#colors+1) *(($pdata[$k][$i] *1.8 +32)-$cs_min)/$cs_range);
                        } else {
                            $j = int(($#colors+1) *($pdata[$k][$i]-$cs_min)/$cs_range);
                        }
                        $j = &max(0, &min($#colors, $j));
                        $cshade = $colors[$j];

                      # Consider special cases. Single rows or columns won't plot with 4-arg -to option.
                        if ($xp1 != $xp2 && $yp1 != $yp2) {
                            $slice_img{$mydt}->put($cshade, -to => $xp1, $yp1, $xp2, $yp2);
                        } elsif ($xp1 != $xp2) {
                            @cdata    = ();
                            $cdata[0] = $cshade;
                            if ($xp2 > $xp1) {
                                for ($xp=$xp1+1; $xp<=$xp2; $xp++) {
                                    $cdata[0] .= " " . $cshade;
                                }
                                $slice_img{$mydt}->put([ @cdata ], -to => $xp1, $yp1);  # horizontal line
                            } else {
                                for ($xp=$xp2+1; $xp<=$xp1; $xp++) {
                                    $cdata[0] .= " " . $cshade;
                                }
                                $slice_img{$mydt}->put([ @cdata ], -to => $xp2, $yp1);  # horizontal line
                            }
                        } elsif ($yp1 != $yp2) {
                            $cvert = $cshade;
                            for ($yp=$yp1+1; $yp<=$yp2; $yp++) {
                                $cvert .= " " . $cshade;
                            }
                            $slice_img{$mydt}->put($cvert, -to => $xp1, $yp1);      # vertical line
                        } else {
                            $slice_img{$mydt}->put($cshade, -to => $xp1, $yp1);     # single point
                        }
                    }
                    last if ($yp2 >= $ih-1);
                    last if ($k >= $kb[$i]);   # ensures once-through, for kt > kb[i]
                }

            } else {
                $yp2 = ($ih-1)*(1.-($surf_elev-$ymin)/$yrange);
                if ($ns < $#seglist && $i != $us[$jb] && $seglist[$ns+1] != $i-1) {
                    $dy_full = ($ih-1)*$slope[$jb]*0.5*$dlx[$i]/$yrange;
                } else {
                    $dy_full = ($ih-1)*$slope[$jb]*$dlx[$i]/$yrange;
                }
                for ($k=$kt; $k<$kmx; $k++) {
                    $yp1  = $yp2;
                    $kalt = ($k > $kb[$i]) ? $kb[$i] : $k;
                    $yp2  = ($ih-1)*(1.-($el[$kalt+1][$i]-$ymin)/$yrange);
                    last if (&round_to_int($yp1) >= $ih-1);
                    if (&round_to_int($yp2) < 0) {
                        $yp2 = 0;
                        next;
                    }
                    if (defined($pdata[$k][$i])) {
                        if ($props{$id}{parm} eq "Temperature" && $props{$id}{parm_units} eq "Fahrenheit") {
                            $j = int(($#colors+1) *(($pdata[$k][$i] *1.8 +32)-$cs_min)/$cs_range);
                        } else {
                            $j = int(($#colors+1) *($pdata[$k][$i]-$cs_min)/$cs_range);
                        }
                        $j = &max(0, &min($#colors, $j));
                        $cshade = $colors[$j];

                      # Plot without slope if slope is insignificant
                        if (&round_to_int($yp1+0.5*$dy_full) == &round_to_int($yp1-0.5*$dy_full) &&
                            &round_to_int($yp2+0.5*$dy_full) == &round_to_int($yp2-0.5*$dy_full)) {
                            $yp1r = &max(0, &min($ih-1, &round_to_int($yp1)));
                            $yp2r = &max(0, &min($ih-1, &round_to_int($yp2)));

                          # Consider special cases. Single rows or columns won't plot with 4-arg -to option.
                            if ($xp1 != $xp2 && $yp1r != $yp2r) {
                                $slice_img{$mydt}->put($cshade, -to => $xp1, $yp1r, $xp2, $yp2r);
                            } elsif ($xp1 != $xp2) {
                                @cdata    = ();
                                $cdata[0] = $cshade;
                                if ($xp2 > $xp1) {
                                    for ($xp=$xp1+1; $xp<=$xp2; $xp++) {
                                        $cdata[0] .= " " . $cshade;
                                    }
                                    $slice_img{$mydt}->put([ @cdata ], -to => $xp1, $yp1r); # horizontal line
                                } else {
                                    for ($xp=$xp2+1; $xp<=$xp1; $xp++) {
                                        $cdata[0] .= " " . $cshade;
                                    }
                                    $slice_img{$mydt}->put([ @cdata ], -to => $xp2, $yp1r); # horizontal line
                                }
                            } elsif ($yp1r != $yp2r) {
                                $cvert = $cshade;
                                for ($yp=$yp1r+1; $yp<=$yp2r; $yp++) {
                                    $cvert .= " " . $cshade;
                                }
                                $slice_img{$mydt}->put($cvert, -to => $xp1, $yp1r);     # vertical line
                            } else {
                                $slice_img{$mydt}->put($cshade, -to => $xp1, $yp1r);    # single point
                            }

                      # Slope is noticeable.
                      # Single columns won't plot with 4-arg -to option. Plot as vertical lines for each x.
                        } else {
                            if ($gr_props{$id}{xflip}) {
                                for ($xp=$xp2; $xp<=$xp1; $xp++) {
                                    $dy    = $dy_full*(($xp-$xp2)/($xp1-$xp2) -0.5);
                                    $yp1r  = &max(0, &min($ih-1, &round_to_int($yp1+$dy)));
                                    $yp2r  = &max(0, &min($ih-1, &round_to_int($yp2+$dy)));
                                    $cvert = "";
                                    for ($yp=$yp1r; $yp<=$yp2r; $yp++) {
                                        next if ($yp < 0 || $yp > $ih-1);
                                        if ($cvert eq "") {
                                            $yp_start = $yp;
                                            $cvert    = $cshade;
                                        } else {
                                            $cvert .= " " . $cshade;
                                        }
                                    }
                                    if ($cvert ne "") {
                                        $slice_img{$mydt}->put($cvert, -to => $xp, $yp_start);
                                    }
                                }
                            } else {
                                for ($xp=$xp1; $xp<=$xp2; $xp++) {
                                    $dy    = $dy_full*(($xp-$xp1)/($xp2-$xp1) -0.5);
                                    $yp1r  = &max(0, &min($ih-1, &round_to_int($yp1-$dy)));
                                    $yp2r  = &max(0, &min($ih-1, &round_to_int($yp2-$dy)));
                                    $cvert = "";
                                    for ($yp=$yp1r; $yp<=$yp2r; $yp++) {
                                        next if ($yp < 0 || $yp > $ih-1);
                                        if ($cvert eq "") {
                                            $yp_start = $yp;
                                            $cvert    = $cshade;
                                        } else {
                                            $cvert .= " " . $cshade;
                                        }
                                    }
                                    if ($cvert ne "") {
                                        $slice_img{$mydt}->put($cvert, -to => $xp, $yp_start);
                                    }
                                }
                            }
                        }
                    }
                    last if (&round_to_int($yp2) >= $ih-1);
                    last if ($k >= $kb[$i]);   # ensures once-through, for kt > kb[i]
                }
            }
        }
        $canv->itemconfigure($date_id, -text => &get_formatted_date($mydt));
        $canv->itemconfigure($gtag . "_colorMap", -image => $slice_img{$mydt});
    }
    if ($indx > 0 || $stop_processing) {
        if (&list_match($dt, @mydates) == -1 || ! defined($slice_img{$dt})) {
            $dt  = $mydates[0];
            $dti = 1 + &nearest_dt_index($dt, @dates);
            $dti++ if ($dti == 0);
            $dti_old = $dti;
            &update_animate(&get_formatted_date($dates[$dti-1]));
          # $canv->delete($gtag . "_noData");
        }
        $canv->itemconfigure($date_id, -text => &get_formatted_date($dt));
        $canv->itemconfigure($gtag . "_colorMap", -image => $slice_img{$dt});
    }

#   Place the graphic items in the proper order
    &raise_lower($canv, $id, "tiptop") if ($new_graph);
    $canv->lower($gtag . "_colorKey",      $id);
    $canv->lower($gtag . "_colorKeyTitle", $id);
    $canv->lower($gtag . "_date",          $id);
    $canv->lower($gtag . "_gtitle",        $id);
    $canv->lower($gtag . "_xaxisTitle",    $id);
    $canv->lower($gtag . "_saxisTitle",    $id);
    $canv->lower($gtag . "_yaxisTitle",    $id);
    $canv->lower($gtag . "_sgrid",         $id);
    $canv->lower($gtag . "_noData",        $id);
    $canv->lower($gtag . "_colorMap",      $id);
    $canv->lower($gtag . "_xaxis",         $id);
    $canv->lower($gtag . "_saxis",         $id);
    $canv->lower($gtag . "_yaxis",         $id);
    if ($group_tags) {
        foreach $tag (@grp_tags) {
            $canv->addtag($tag, withtag => $gtag);
        }
    }

#   Update any links
#xxx &update_links($canv, $id, $dt);

#   Remove progress bar and unset the busy status.
    if (defined($pbar_window) && Tkx::winfo_exists($pbar_window)) {
        $pbar_window->g_grab_release();
        $pbar_window->g_bind('<Destroy>' => "");
        $pbar_window->g_destroy();
    }
    $canv->configure(-cursor => $cursor_norm);
    $main->configure(-cursor => $cursor_norm);
    if ($stop_processing) {
        $status_line =~ s/  Date = \d+$/  Processing stopped./;
    } else {
        $status_line =~ s/  Date = \d+$/  Processing completed./;
    }
    $gr_props{$id}{slice_img} = { %slice_img };
    undef %slice_img;
}


sub setup_w2_tdmap_part2 {
    my ($canv, $id, $X, $Y) = @_;
    my (
        $flowtemp_file, $fr, $frame, $frame2, $geom, $jw, $n, $nbr,
        $ok_btn, $oldsrc_type, $row, $sc_canv, $sc_fr, $src_btn, $src_file,
        $src_label1, $src_label2, $src_lines, $src_text, $src_type,
        $src_type_cb, $surftemp_file, $txt, $voltemp_file, $vscroll,
        $w2l_file,

        @brs, @bth_files, @cbtn, @clab1, @clab2, @cpl_files, @cpl_lines,
        @ds, @f, @frv, @frv_label, @parmlist, @rbtn, @riv_files, @riv_freq,
        @riv_lines, @frv_on, @riv_parm, @src_parms, @tecplot, @td_filetypes,
        @us, @wbs,
       );

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($w2tdmap_setup_menu) && Tkx::winfo_exists($w2tdmap_setup_menu)) {
        if ($w2tdmap_setup_menu->g_wm_title() eq "W2 Time/Distance Map Setup") {
            $w2tdmap_setup_menu->g_destroy();
            undef $w2tdmap_setup_menu;
        }
    }
    $w2tdmap_setup_menu = $main->new_toplevel();
    $w2tdmap_setup_menu->g_wm_transient($main);
    $w2tdmap_setup_menu->g_wm_title("W2 Time/Distance Map Setup");
    $w2tdmap_setup_menu->configure(-cursor => $cursor_norm);
    $w2tdmap_setup_menu->g_wm_geometry($geom);

#   Try to keep the nascent graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

    @wbs = split(/,/, $props{$id}{wb_list});
    @brs = sort numerically split(/,/, $props{$id}{br_list});
    @us  = @{ $grid{$id}{us} };
    @ds  = @{ $grid{$id}{ds} };
    $nbr = $grid{$id}{nbr};

    @cpl_files    = @cpl_lines = @tecplot = @bth_files = @riv_files = @riv_lines = @riv_freq = ();
    @parmlist     = @src_parms = ();
    $src_type     = "W2 Contour File";
    $src_text     = $src_type . ": ";
    $src_file     = "";
    $src_lines    = 0;
    $oldsrc_type  = $src_type;
    $w2l_file     = $surftemp_file = $voltemp_file = $flowtemp_file = "";
    @td_filetypes = ("W2 Contour File",  "W2 Vector File", "W2 RiverCon File",
                     "W2 SurfTemp File", "W2 VolTemp File", "W2 FlowTemp File");
    for ($n=0; $n<=$#wbs; $n++) {
        $cpl_files[$n] = "          ";
        $bth_files[$n] = "";
    }
    for ($n=0; $n<=$#brs; $n++) {
        $riv_files[$n] = "          ";
    }

#   Set up the menu
    $frame = $w2tdmap_setup_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -state   => 'disabled',
            -command => sub { my ($br_list, $i, $j, $jw1, $jw2, $label, $mismatch, $n, $parm, $rfreq,
                                  @cpld, @cplf, @ncpl, @parm_tmp, @plist, @tmp_files, @tmp_lines, @vals,
                                  %parms);
                              if ($src_type =~ /Contour/i) {
                                  for ($n=0; $n<=$#wbs; $n++) {
                                      if ($cpl_files[$n] eq "" || $cpl_files[$n] eq "          "
                                                               || ! -e $cpl_files[$n]) {
                                          return &pop_up_error($w2tdmap_setup_menu,
                                          "W2 Contour file not set or does not exist:\n$cpl_files[$n]");
                                      }
                                  }

#                                 Ensure contour dates and frequencies are identical for all waterbodies
                                  if ($#wbs > 0) {
                                      @ncpl = @{ $grid{$id}{ncpl} };
                                      @cpld = @{ $grid{$id}{cpld} };
                                      @cplf = @{ $grid{$id}{cplf} };
                                      $mismatch = 0;
                                      for ($j=0; $j<=$#wbs; $j++) {
                                          $jw1 = $wbs[$j];
                                          for ($n=$j+1; $n<=$#wbs; $n++) {
                                              $jw2 = $wbs[$n];
                                              if ($ncpl[$jw1] != $ncpl[$jw2]) {
                                                  $mismatch = 1;
                                                  last;
                                              }
                                              for ($i=1; $i<=$ncpl[$jw1]; $i++) {
                                                  if ($cpld[$i][$jw1] != $cpld[$i][$jw2] ||
                                                      $cplf[$i][$jw1] != $cplf[$i][$jw2]) {
                                                      $mismatch = 1;
                                                      last;
                                                  }
                                              }
                                              last if ($mismatch);
                                          }
                                          last if ($mismatch);
                                      }
                                      if ($mismatch) {
                                          return &pop_up_error($w2tdmap_setup_menu,
                                              "The contour plot output dates and frequencies for\n"
                                            . "the chosen waterbodies do not match. Please try again.");
                                      }
                                  }

#                                 Only keep parameters common to all contour output files
                                  @plist = @{ $parmlist[0] };
                                  for ($n=1; $n<=$#wbs; $n++) {
                                      @parm_tmp = ();
                                      foreach $parm ( @{ $parmlist[$n] } ) {
                                          if (&list_match($parm, @plist) >= 0) {
                                              push (@parm_tmp, $parm);
                                          }
                                      }
                                      @plist = @parm_tmp;
                                  }
                                  if ($#plist < 0) {
                                      return &pop_up_error($w2tdmap_setup_menu,
                                        "No parameters are common to all of the W2 Contour files.");
                                  }
                                  %parms                 = ();
                                  $parms{parms}          = [ @plist     ];
                                  $props{$id}{tecplot}   = [ @tecplot   ];
                                  $props{$id}{cpl_lines} = [ @cpl_lines ];
                                  $props{$id}{cpl_files} = [ @cpl_files ];

                              } elsif ($src_type =~ /RiverCon/i) {
                                  for ($n=0; $n<=$#riv_files; $n++) {
                                      next if (! $frv_on[$n]);
                                      if ($riv_files[$n] eq "" || $riv_files[$n] eq "          "
                                                               || ! -e $riv_files[$n]) {
                                          return &pop_up_error($w2tdmap_setup_menu,
                                          "W2 River Contour file not set or does not exist:\n$riv_files[$n]");
                                      }
                                  }
                                  if ($#brs > 0) {
                                      $parm = "";
                                      for ($n=0; $n<=$#brs; $n++) {
                                          next if (! $frv_on[$n]);
                                          if ($parm eq "") {
                                              $parm = $riv_parm[$n];
                                              next;
                                          }
                                          if ($riv_parm[$n] ne $parm) {
                                              return &pop_up_error($w2tdmap_setup_menu,
                                                "The W2 RiverCon files do not contain the same parameter.");
                                          }
                                      }
                                      $rfreq = -99;
                                      for ($n=0; $n<=$#brs; $n++) {
                                          next if (! $frv_on[$n]);
                                          if ($rfreq == -99) {
                                              $rfreq = $riv_freq[$n];
                                              next;
                                          }
                                          if ($rfreq != $riv_freq[$n]) {
                                              return &pop_up_error($w2tdmap_setup_menu,
                                                  "The W2 RiverCon output frequencies for the\n"
                                                . "chosen branches do not match. Please try again.");
                                          }
                                      }
                                  } else {
                                      $parm  = $riv_parm[0];
                                      $rfreq = $riv_freq[0];
                                  }
                                  @tmp_files = @riv_files;
                                  @tmp_lines = @riv_lines;
                                  @riv_files = @riv_lines = ();
                                  $br_list   = "";
                                  for ($n=0; $n<=$#brs; $n++) {
                                      next if (! $frv_on[$n]);
                                      push (@riv_files, $tmp_files[$n]);
                                      push (@riv_lines, $tmp_lines[$n]);
                                      $label = $frv_label[$n];
                                      if ($label =~ /,/) {
                                          $label =~ s/Branch //;
                                          @vals  = split(/,/, $label);
                                          @vals  = sort numerically @vals;
                                          $br_list .= $vals[0] . ",";
                                      } else {
                                          $br_list .= $brs[$n] . ",";
                                      }
                                  }
                                  $br_list =~ s/,$//;
                                  %parms                 = ();
                                  $parms{riv_freq}       = $rfreq;
                                  $parms{parms}          = [ ($parm)    ];
                                  $props{$id}{riv_lines} = [ @riv_lines ];
                                  $props{$id}{riv_files} = [ @riv_files ];
                                  $props{$id}{br_list}   = $br_list;

                              } else {
                                  if ($src_file eq "" || ! -e $src_file) {
                                      return &pop_up_error($w2tdmap_setup_menu,
                                          $src_type . " not set or does not exist:\n$src_file");
                                  }
                                  if ($src_type =~ /SurfTemp|VolTemp|FlowTemp/i) {
                                      $props{$id}{src_file}  = $src_file;
                                      $props{$id}{src_lines} = $src_lines;
                                  } else {
                                      $props{$id}{w2l_file}  = $src_file;
                                  }
                                  %parms        = ();
                                  $parms{parms} = [ @src_parms ];
                              }

                              for ($n=0; $n<=$#wbs; $n++) {
                                  if ($bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                      return &pop_up_error($w2tdmap_setup_menu,
                                      "W2 Bathymetry file not set or does not exist:\n$bth_files[$n]");
                                  }
                              }
                              $props{$id}{files}     = 1;
                              $props{$id}{parms}     = { %parms };
                              $props{$id}{src_type}  = $src_type;
                              $props{$id}{bth_files} = [ @bth_files ];

                              $geom = $w2tdmap_setup_menu->g_wm_geometry();
                              (undef, $X, $Y) = split(/\+/, $geom);

                              $w2tdmap_setup_menu->g_bind('<Destroy>', "");
                              $w2tdmap_setup_menu->g_destroy();
                              undef $w2tdmap_setup_menu;

                              &setup_w2_tdmap_part3($canv, $id, $X, $Y);
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);

    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $w2tdmap_setup_menu->g_bind('<Destroy>', "");
                              $w2tdmap_setup_menu->g_destroy();
                              undef $w2tdmap_setup_menu;
                              $canv->delete("graph" . $id);
                              delete $props{$id};
                              delete $grid{$id};
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Delete graph if this menu is destroyed by other than the Cancel button
    $w2tdmap_setup_menu->g_bind('<Destroy>' => sub { undef $w2tdmap_setup_menu;
                                                     $canv->delete("graph" . $id);
                                                     delete $props{$id}; 
                                                     delete $grid{$id};
                                                     &reset_bindings;
                                                   });

#   Need a scrollable container, and a canvas is about the only container that works.
#   Create a parent frame (sc_fr) for the canvas (sc_canv) and scrollbar (vscroll).
#   Then put a frame inside the canvas (fr) as a widget window to hold other menu items.
    ($sc_fr = $w2tdmap_setup_menu->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_pack(-side => 'top', -expand => 1, -fill => 'both');
    ($vscroll = $sc_fr->new_scrollbar(
            -orient => 'vertical',
            -width  => 15,
            ))->g_grid(-row => 0, -column => 1, -sticky => 'nse');
    ($sc_canv = $sc_fr->new_tk__canvas(
            -highlightthickness => 0,
            -yscrollcommand => [$vscroll, 'set'],
            ))->g_grid(-row => 0, -column => 0, -sticky => 'nsew');
    $vscroll->configure(-command => [$sc_canv, 'yview']);

    $fr = $sc_canv->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );

#   Source type
    $row = 0;
    $fr->new_label(
            -text => "W2 Source Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($src_type_cb = $fr->new_ttk__combobox(
            -textvariable => \$src_type,
            -values       => [ @td_filetypes ],
            -width        => 17,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $src_type_cb->g_bind("<<ComboboxSelected>>",
                          sub { my ($n, $ok, $status);
                                return if ($src_type eq $oldsrc_type);
                                if ($src_type =~ /Contour/i) {
                                    $src_label1->g_grid_remove();
                                    $src_label2->g_grid_remove();
                                    $src_btn->g_grid_remove();
                                    for ($n=0; $n<=$#wbs; $n++) {
                                        $clab1[$n]->g_grid();
                                        $clab2[$n]->g_grid();
                                        $cbtn[$n]->g_grid();
                                    }
                                    for ($n=0; $n<=$#brs; $n++) {
                                        $frv[$n]->g_grid_remove();
                                    }
                                    $frame2->g_grid() if ($#wbs > 0);
                                    $ok = 1;
                                    for ($n=0; $n<=$#wbs; $n++) {
                                        if ($cpl_files[$n] eq "          " ||
                                            $cpl_files[$n] eq "" || ! -e $cpl_files[$n]) {
                                            $ok = 0;
                                            last;
                                        }
                                    }
                                } elsif ($src_type =~ /RiverCon/i) {
                                    $src_label1->g_grid_remove();
                                    $src_label2->g_grid_remove();
                                    $src_btn->g_grid_remove();
                                    for ($n=0; $n<=$#wbs; $n++) {
                                        $clab1[$n]->g_grid_remove();
                                        $clab2[$n]->g_grid_remove();
                                        $cbtn[$n]->g_grid_remove();
                                    }
                                    for ($n=0; $n<=$#brs; $n++) {
                                        $frv[$n]->g_grid() if ($frv_on[$n]);
                                    }
                                    $frame2->g_grid_remove() if ($#wbs > 0 && $oldsrc_type =~ /Contour/i);
                                    $ok = 1;
                                    for ($n=0; $n<=$#brs; $n++) {
                                        next if (! $frv_on[$n]);
                                        if ($riv_files[$n] eq "          " ||
                                            $riv_files[$n] eq "" || ! -e $riv_files[$n]) {
                                            $ok = 0;
                                            last;
                                        }
                                    }
                                } else {
                                    for ($n=0; $n<=$#wbs; $n++) {
                                        $clab1[$n]->g_grid_remove();
                                        $clab2[$n]->g_grid_remove();
                                        $cbtn[$n]->g_grid_remove();
                                    }
                                    for ($n=0; $n<=$#brs; $n++) {
                                        $frv[$n]->g_grid_remove();
                                    }
                                    $frame2->g_grid_remove() if ($#wbs > 0 && $oldsrc_type =~ /Contour/i);
                                    $src_label1->g_grid();
                                    $src_label2->g_grid();
                                    $src_btn->g_grid();
                                    if ($src_type =~ /SurfTemp/) {
                                        $src_file = $surftemp_file;
                                    } elsif ($src_type =~ /VolTemp/) {
                                        $src_file = $voltemp_file;
                                    } elsif ($src_type =~ /FlowTemp/) {
                                        $src_file = $flowtemp_file;
                                    } elsif ($src_type =~ /Vector/i) {
                                        $src_file = $w2l_file;
                                    }
                                    $ok = ($src_file eq "" || ! -e $src_file) ? 0 : 1;
                                }
                                $oldsrc_type = $src_type;
                                $src_text    = $src_type . ": ";
                                for ($n=0; $n<=$#wbs; $n++) {
                                    if ($bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                        $ok = 0;
                                        last;
                                    }
                                }
                                $status = ($ok) ? 'normal' : 'disabled';
                                $ok_btn->configure(-state => $status);
                                &update_scrollable_menu($w2tdmap_setup_menu, $sc_fr, $sc_canv,
                                                        'scrollable', $vscroll);
                              });
    $fr->new_label(
            -text => "            ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 2, -sticky => 'ew', -pady => 2);

#   Input fields for W2 Vector, SurfTemp, VolTemp, or FlowTemp file
    $row++;
    ($src_label1 = $fr->new_label(
            -textvariable => \$src_text,
            -font         => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($src_label2 = $fr->new_label(
            -textvariable => \$src_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
    ($src_btn = $fr->new_button(
            -text    => "Browse",
            -command =>
               sub { my ($file, $ftype, $n, $ok, $parms_ref, $status);
                     if ($src_type =~ /Vector/i) {
                         $file = Tkx::tk___getOpenFile(
                                 -parent    => $w2tdmap_setup_menu,
                                 -title     => "Select W2 Vector File",
                                 -filetypes => [ ['W2L (W2 Vector)', '.w2l'],
                                                 ['All Files', '*'],
                                               ],
                                 );
                         if (defined($file) && -e $file) {
                             $src_file = File::Spec->rel2abs($file);
                             $status_line = "Scanning W2 vector file...";  # no progress bar needed
                             &update_scrollable_menu($w2tdmap_setup_menu,
                                                     $sc_fr, $sc_canv, 'scrollable', $vscroll);
                             Tkx::update_idletasks();
                             ($ok, $parms_ref, undef, undef, undef)
                                 = &scan_w2_vector_file($w2tdmap_setup_menu, $src_file, $id, 0);
                             $status_line = "";
                             if ($ok ne "okay") {
                                 $src_file = $w2l_file = "";
                                 $ok_btn->configure(-state => 'disabled');
                                 &update_scrollable_menu($w2tdmap_setup_menu,
                                                         $sc_fr, $sc_canv, 'scrollable', $vscroll);
                                 return &pop_up_error($w2tdmap_setup_menu,
                                              "The specified file is not a W2 Vector (w2l) file:\n$file");
                             }
                             @src_parms = @{ $parms_ref };
                             $w2l_file  = $src_file;
                             $status    = 'normal';
                             for ($n=0; $n<=$#wbs; $n++) {
                                 if ($bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                     $status = 'disabled';
                                     last;
                                 }
                             }
                             $ok_btn->configure(-state => $status);
                         } else {
                             $ok_btn->configure(-state => 'disabled');
                         }
                     } else {
                         $file = Tkx::tk___getOpenFile(
                                 -parent    => $w2tdmap_setup_menu,
                                 -title     => "Select " . $src_type,
                                 -filetypes => [ ['All Files', '*'],
                                                 ['Custom W2 *Temp Files', '*Temp.dat'],
                                                 ['Custom W2 *Temp2 Files', '*Temp2.dat'],
                                               ],
                                 );
                         if (defined($file) && -e $file) {
                             $src_file = File::Spec->rel2abs($file);
                             $status_line = "Scanning " . $src_type . "...";
                             &update_scrollable_menu($w2tdmap_setup_menu,
                                                     $sc_fr, $sc_canv, 'scrollable', $vscroll);
                             Tkx::update_idletasks();
                             ($ftype, $src_lines, @src_parms)
                                 = &determine_ts_type($w2tdmap_setup_menu, $src_file, 1);
                             $status_line = "";
                             if ($ftype !~ /^W2 .*aily .*Temp2?\.dat format$/
                                   || ($src_type =~ /SurfTemp/ && $ftype !~ /SurfTemp/)
                                   || ($src_type =~ /VolTemp/  && $ftype !~ /VolTemp/)
                                   || ($src_type =~ /FlowTemp/ && $ftype !~ /FlowTemp/)) {
                                 $src_file  = "";
                                 $src_lines = 0;
                                 if ($src_type =~ /SurfTemp/) {
                                     $surftemp_file = "";
                                 } elsif ($src_type =~ /VolTemp/) {
                                     $voltemp_file  = "";
                                 } elsif ($src_type =~ /FlowTemp/) {
                                     $flowtemp_file = "";
                                 }
                                 $ok_btn->configure(-state => 'disabled');
                                 &update_scrollable_menu($w2tdmap_setup_menu,
                                                         $sc_fr, $sc_canv, 'scrollable', $vscroll);
                                 return &pop_up_error($w2tdmap_setup_menu,
                                              "The specified file is not a " . $src_type . ":\n$file");
                             }
                             if ($src_type =~ /SurfTemp/) {
                                 $surftemp_file = $src_file;
                             } elsif ($src_type =~ /VolTemp/) {
                                 $voltemp_file = $src_file;
                             } elsif ($src_type =~ /FlowTemp/) {
                                 $flowtemp_file = $src_file;
                             }
                             $status = 'normal';
                             for ($n=0; $n<=$#wbs; $n++) {
                                 if ($bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                     $status = 'disabled';
                                     last;
                                 }
                             }
                             $ok_btn->configure(-state => $status);
                         } else {
                             $ok_btn->configure(-state => 'disabled');
                         }
                     }
                     &update_scrollable_menu($w2tdmap_setup_menu, $sc_fr, $sc_canv, 'scrollable', $vscroll);
                   },
            ))->g_grid(-row => 1, -column => 2, -sticky => 'ew', -padx => 2, -pady => 2);

    $fr->g_grid_columnconfigure(1, -weight => 2);
    $src_label1->g_grid_remove();
    $src_label2->g_grid_remove();
    $src_btn->g_grid_remove();

#   Loop over the required branches for River Contour file inputs
    for ($n=0; $n<=$#brs; $n++) {
        $frv_on[$n]    = 1;
        $frv_label[$n] = "Branch " . $brs[$n];

        $row++;
        ($frv[$n] = $fr->new_labelframe(
                -borderwidth => 1,
                -relief      => 'groove',
                -text        => $frv_label[$n],
                ))->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew', -pady => 2);

        $frv[$n]->new_label(
                -text => "W2 RiverCon File: ",
                -font => 'default',
                )->g_grid(-row => 0, -column => 0, -sticky => 'e', -pady => 2);
        $frv[$n]->new_label(
                -textvariable => \$riv_files[$n],
                -anchor       => 'w',
                -font         => 'default',
                -background   => 'white',
                -relief       => 'sunken',
                -borderwidth  => 1,
                )->g_grid(-row => 0, -column => 1, -sticky => 'ew', -pady => 2);
        ($rbtn[$n] = $frv[$n]->new_button(
                -text    => "Browse",
                -command =>
                 [ sub { my ($n) = @_;
                         my (
                             $file, $ftype, $j, $jb1, $jb2, $meta, $nlines, $nn,
                             $nsegs, $parm, $pbar, $pbar_img, $pbar_win, $status, $txt,
                            );

                         $file = Tkx::tk___getOpenFile(
                                 -parent    => $w2tdmap_setup_menu,
                                 -title     => "Select W2 RiverCon Output File",
                                 -filetypes => [ ['W2 RiverCon files', 'RiverContour_*.csv'],
                                                 ['All Files', '*'],
                                               ],
                                 );
                         if (defined($file) && -e $file) {
                             $riv_files[$n] = File::Spec->rel2abs($file);
                             &update_scrollable_menu($w2tdmap_setup_menu, $sc_fr, $sc_canv,
                                                     'scrollable', $vscroll);
                             ($pbar_win, $pbar, $pbar_img)
                                 = &create_alt_progress_bar($main, $id,
                                                            "Scanning W2 River Contour file...");
                             ($ftype, $parm, $meta, $nlines)
                                 = &scan_w2_rlcon_file($w2tdmap_setup_menu, $riv_files[$n], $pbar_img);
                             &destroy_progress_bar($main, $pbar_win);

                             if ($ftype !~ /rcon/) {
                                 $riv_files[$n] = "          ";
                                 while ($frv_label[$n] =~ /,\d+$/) {
                                     $frv_label[$n] =~ s/,(\d+)//;
                                     $nn = &list_match($1, @brs);
                                     $frv_on[$nn]    = 1;
                                     $frv_label[$nn] = "Branch " . $brs[$nn];
                                     $frv[$nn]->configure(-text => $frv_label[$nn]);
                                     $frv[$nn]->g_grid();
                                 }
                                 $frv[$n]->configure(-text => $frv_label[$n]);
                                 $ok_btn->configure(-state => 'disabled');
                                 &update_scrollable_menu($w2tdmap_setup_menu, $sc_fr, $sc_canv,
                                                         'scrollable', $vscroll);
                                 return &pop_up_error($w2tdmap_setup_menu,
                                         "Specified file is not a W2 River Contour output file:\n$file");
                             }
                             ($jb1, $nsegs, $riv_freq[$n]) = split(/_/, $meta);
                             $jb2 = $jb1;
                             for ($j=$jb1; $j<=$nbr; $j++) {
                                 last if ($nsegs <= $ds[$j] -$us[$j] +1);
                                 $jb2++;
                                 $nsegs -= $ds[$j] -$us[$j] +1;
                             }
                             if ($brs[$n] < $jb1 || $brs[$n] > $jb2) {
                                 $riv_files[$n] = "          ";
                                 while ($frv_label[$n] =~ /,\d+$/) {
                                     $frv_label[$n] =~ s/,(\d+)//;
                                     $nn = &list_match($1, @brs);
                                     $frv_on[$nn]    = 1;
                                     $frv_label[$nn] = "Branch " . $brs[$nn];
                                     $frv[$nn]->configure(-text => $frv_label[$nn]);
                                     $frv[$nn]->g_grid();
                                 }
                                 $frv[$n]->configure(-text => $frv_label[$n]);
                                 $ok_btn->configure(-state => 'disabled');
                                 &update_scrollable_menu($w2tdmap_setup_menu, $sc_fr, $sc_canv,
                                                         'scrollable', $vscroll);
                                 $txt = ($jb2 == $jb1) ? $jb1 : $jb1 . "-" . $jb2;
                                 return &pop_up_error($w2tdmap_setup_menu,
                                           "The specified W2 River Contour file\n"
                                         . "does not include the correct branch:\n"
                                         . "(" . $txt . " rather than " . $brs[$n] . "):\n$file");
                             }
                             $frv_label[$n] = "Branch " . $brs[$n];
                             if ($jb2 > $jb1) {
                                 for ($j=$jb1; $j<=$jb2; $j++) {
                                     $nn = &list_match($j, @brs);
                                     if ($nn >= 0 && $brs[$nn] != $brs[$n]) {
                                         $frv_label[$n] .= "," . $brs[$nn];
                                         $frv_on[$nn]    = 0;
                                         $frv_label[$nn] = "Branch " . $brs[$nn];
                                         $frv[$nn]->configure(-text => $frv_label[$nn]);
                                         $frv[$nn]->g_grid_remove();
                                     }
                                 }
                                 $frv[$n]->configure(-text => $frv_label[$n]);
                             }
                             $riv_lines[$n] = $nlines;
                             $riv_parm[$n]  = $parm;

                             $status = 'normal';
                             for ($j=0; $j<=$#brs; $j++) {
                                 next if (! $frv_on[$j]);
                                 if ($riv_files[$j] eq "          " ||
                                     $riv_files[$j] eq "" || ! -e $riv_files[$j]) {
                                     $status = 'disabled';
                                     last;
                                 }
                             }
                             for ($j=0; $j<=$#wbs; $j++) {
                                 if ($bth_files[$j] eq "" || ! -e $bth_files[$j]) {
                                     $status = 'disabled';
                                     last;
                                 }
                             }
                             $ok_btn->configure(-state => $status);
                         } else {
                             $ok_btn->configure(-state => 'disabled');
                         }
                         &update_scrollable_menu($w2tdmap_setup_menu, $sc_fr, $sc_canv,
                                                 'scrollable', $vscroll);
                       }, $n ],
                ))->g_grid(-row => 0, -column => 2, -sticky => 'ew', -padx => 2, -pady => 2);

        $frv[$n]->g_grid_columnconfigure(1, -weight => 2);
        $frv[$n]->g_grid_remove();
    }

#   Loop over the required waterbodies for contour file and bathymetry file inputs
    for ($n=0; $n<=$#wbs; $n++) {
        $jw = $wbs[$n];

        $row++;
        ($f[$n] = $fr->new_labelframe(
                -borderwidth => 1,
                -relief      => 'groove',
                -text        => "Waterbody $jw",
                ))->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew', -pady => 2);

        ($clab1[$n] = $f[$n]->new_label(
                -text => "W2 Contour File: ",
                -font => 'default',
                ))->g_grid(-row => 0, -column => 0, -sticky => 'e', -pady => 2);
        ($clab2[$n] = $f[$n]->new_label(
                -textvariable => \$cpl_files[$n],
                -anchor       => 'w',
                -font         => 'default',
                -background   => 'white',
                -relief       => 'sunken',
                -borderwidth  => 1,
                ))->g_grid(-row => 0, -column => 1, -sticky => 'ew', -pady => 2);
        ($cbtn[$n] = $f[$n]->new_button(
                -text    => "Browse",
                -command =>
                 [ sub { my ($n) = @_;
                         my ($file, $i, $jw_src, $nlines, $parms_ref, $pbar, $pbar_img, $pbar_win,
                             $status, $tecplot, $txt,
                            );
                         $file = Tkx::tk___getOpenFile(
                                 -parent    => $w2tdmap_setup_menu,
                                 -title     => "Select W2 Contour Output File",
                                 -filetypes => [ ['All Files', '*'],
                                                 ['CSV (comma delimited)', '.csv'],
                                                 ['OPT (W2 output files)', '.opt'],
                                               ],
                                 );
                         if (defined($file) && -e $file) {
                             $cpl_files[$n] = File::Spec->rel2abs($file);
                             &update_scrollable_menu($w2tdmap_setup_menu, $sc_fr, $sc_canv,
                                                     'scrollable', $vscroll);
                             ($pbar_win, $pbar, $pbar_img)
                                 = &create_alt_progress_bar($main, $id, "Scanning W2 contour file...");
                             ($tecplot, $nlines, $jw_src, $parms_ref, undef, undef)
                                 = &scan_w2_cpl_file($w2tdmap_setup_menu, $cpl_files[$n], $id, 0, $pbar_img);
                             &destroy_progress_bar($main, $pbar_win);

                             if ($tecplot == -1) {
                                 $cpl_files[$n] = "          ";
                                 $ok_btn->configure(-state => 'disabled');
                                 &update_scrollable_menu($w2tdmap_setup_menu, $sc_fr, $sc_canv,
                                                         'scrollable', $vscroll);
                                 return &pop_up_error($w2tdmap_setup_menu,
                                     "Specified file is not a W2 Contour output file:\n$file");
                             }
                             if ($tecplot == 0 && $jw_src != $wbs[$n]) {
                                 $cpl_files[$n] = "          ";
                                 $ok_btn->configure(-state => 'disabled');
                                 &update_scrollable_menu($w2tdmap_setup_menu, $sc_fr, $sc_canv,
                                                         'scrollable', $vscroll);
                                 return &pop_up_error($w2tdmap_setup_menu,
                                         "The specified W2 Contour output file does not\n"
                                       . "appear to be from the correct waterbody:\n"
                                       . "(" . $jw_src . " rather than " . $wbs[$n] . "):\n$file");
                             }
                             $tecplot[$n]   = $tecplot;
                             $cpl_lines[$n] = $nlines;
                             $parmlist[$n]  = [ @{ $parms_ref } ];

                             $status = 'normal';
                             for ($i=0; $i<=$#wbs; $i++) {
                                 if ($cpl_files[$i] eq "          " ||
                                     $cpl_files[$i] eq "" || ! -e $cpl_files[$i] ||
                                     $bth_files[$i] eq "" || ! -e $bth_files[$i]) {
                                     $status = 'disabled';
                                     last;
                                 }
                             }
                             $ok_btn->configure(-state => $status);
                         } else {
                             $ok_btn->configure(-state => 'disabled');
                         }
                         &update_scrollable_menu($w2tdmap_setup_menu, $sc_fr, $sc_canv,
                                                 'scrollable', $vscroll);
                       }, $n ],
                ))->g_grid(-row => 0, -column => 2, -sticky => 'ew', -padx => 2, -pady => 2);

        $f[$n]->new_label(
                -text => "W2 Bathymetry File: ",
                -font => 'default',
                )->g_grid(-row => 1, -column => 0, -sticky => 'e', -pady => 2);
        $f[$n]->new_label(
                -textvariable => \$bth_files[$n],
                -anchor       => 'w',
                -font         => 'default',
                -background   => 'white',
                -relief       => 'sunken',
                -borderwidth  => 1,
                )->g_grid(-row => 1, -column => 1, -sticky => 'ew', -pady => 2);
        $f[$n]->new_button(
                -text    => "Browse",
                -command =>
                 [ sub { my ($n) = @_;
                         my ($file, $status);
                         $file = Tkx::tk___getOpenFile(
                                 -parent           => $w2tdmap_setup_menu,
                                 -title            => "Select W2 Bathymetry File",
                                 -defaultextension => ".csv",
                                 -filetypes => [ ['CSV (comma delimited)', '.csv'],
                                                 ['NPT (W2 input files)', '.npt'],
                                                 ['All Files', '*'],
                                               ],
                                 );
                         if (defined($file) && -e $file) {
                             $bth_files[$n] = File::Spec->rel2abs($file);
                             $status = 'normal';
                             if ($src_type =~ /Contour/i) {
                                 for ($n=0; $n<=$#wbs; $n++) {
                                     if ($cpl_files[$n] eq "          " ||
                                         $cpl_files[$n] eq "" || ! -e $cpl_files[$n]) {
                                         $status = 'disabled';
                                         last;
                                     }
                                 }
                             } elsif ($src_type =~ /RiverCon/i) {
                                 for ($n=0; $n<=$#brs; $n++) {
                                     next if (! $frv_on[$n]);
                                     if ($riv_files[$n] eq "          " ||
                                         $riv_files[$n] eq "" || ! -e $riv_files[$n]) {
                                         $status = 'disabled';
                                         last;
                                     }
                                 }
                             } else {
                                 $status = 'disabled' if ($src_file eq "" || ! -e $src_file);
                             }
                             if ($status eq 'normal') {
                                 for ($n=0; $n<=$#wbs; $n++) {
                                     if ($bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                         $status = 'disabled';
                                         last;
                                     }
                                 }
                             }
                             $ok_btn->configure(-state => $status);
                         } else {
                             $ok_btn->configure(-state => 'disabled');
                         }
                         &update_scrollable_menu($w2tdmap_setup_menu, $sc_fr, $sc_canv,
                                                 'scrollable', $vscroll);
                       }, $n ],
                )->g_grid(-row => 1, -column => 2, -sticky => 'ew', -padx => 2, -pady => 2);

        $f[$n]->g_grid_columnconfigure(1, -weight => 2);
    }

    if ($#wbs > 0) {
        $row++;
        ($frame2 = $fr->new_frame(
                    -borderwidth => 1,
                    -relief      => 'groove',
                ))->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew');

        $txt = "Note that this program works best when the contour output files from\n"
             . "each waterbody are assigned the same output dates and output frequencies.\n"
             . "In addition, each is required to include data for the parameter being plotted.";
        $frame2->new_label(
                -text    => $txt,
                -font    => 'default',
                -justify => 'left',
                )->g_pack(-side => 'left', -anchor => 'n', -expand => 1, -fill => 'x', -pady => 2);
    }

    $sc_canv->create_window(0, 0,
            -anchor => 'nw',
            -window => $fr,
            -tags   => 'scrollable',
            );
    $sc_fr->g_grid_columnconfigure(0, -weight => 1);
    &update_scrollable_menu($w2tdmap_setup_menu, $sc_fr, $sc_canv, 'scrollable', $vscroll);

    Tkx::wm_resizable($w2tdmap_setup_menu,0,0);
    &adjust_window_position($w2tdmap_setup_menu);
    $w2tdmap_setup_menu->g_focus;
}


sub setup_w2_tdmap_part3 {
    my ($canv, $id, $X, $Y) = @_;
    my (
        $axis_opt, $byear, $byear_cb, $conv_add, $conv_add_entry, $conv_mult,
        $conv_mult_entry, $conv_type, $conv_type_cb, $conv_type_na_label,
        $cscheme, $cscheme_cb, $custom_frame, $date_flip, $date_frame,
        $date_type, $dbase, $dbase_entry, $dfirst, $dfirst_entry,
        $dist_flip, $dist_frame, $dist_units, $dmajor, $dmajor_entry,
        $dmin, $dmin_entry, $f, $ftype, $frame, $geom, $gstitle, $gtitle,
        $i, $jd_skip, $jd_skip_active, $jd_skip_explain, $jw, $n,
        $ncolors, $ncolors_cb, $ntsr, $offset_frame, $ok_btn, $old_units,
        $oldparm, $oldparm_short, $parm, $parm_cb, $parm_chars, $parm_div,
        $parm_div_cb, $parm_div_label, $parm_frame, $parm_short, $pmax,
        $pmax_entry, $pmin, $pmin_entry, $profile_stat, $riv_freq, $row,
        $src_type, $title, $tz_offset, $units, $units_cb, $units_entry,
        $yr_max, $yr_min,

        @axis_opts, @cmaps, @cplf, @jd_skip_opts, @ncpl, @nvpl,
        @parm_divlist, @parmlist, @tsrf, @vplf, @wbs,

        %parms,
       );

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($w2tdmap_setup_menu) && Tkx::winfo_exists($w2tdmap_setup_menu)) {
        if ($w2tdmap_setup_menu->g_wm_title() eq "W2 Time/Distance Map Setup") {
            $w2tdmap_setup_menu->g_destroy();
            undef $w2tdmap_setup_menu;
        }
    }
    $w2tdmap_setup_menu = $main->new_toplevel();
    $w2tdmap_setup_menu->g_wm_transient($main);
    $w2tdmap_setup_menu->g_wm_title("W2 Time/Distance Map Setup");
    $w2tdmap_setup_menu->configure(-cursor => $cursor_norm);
    $w2tdmap_setup_menu->g_wm_geometry($geom);

#   Try to keep the nascent graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

    $src_type = $props{$id}{src_type};
    %parms    = %{ $props{$id}{parms} };
    @parmlist = @{ $parms{parms}      };
    $riv_freq = $parms{riv_freq} if ($src_type =~ /RiverCon/i);
    undef %parms;

    $parm         = $parmlist[0];
    $parm_chars   = length($parm) +2;
    for ($i=1; $i<=$#parmlist; $i++) {
        $parm_chars = length($parmlist[$i]) +2 if (length($parmlist[$i]) +2 > $parm_chars);
    }
    $parm_div     = "None";
    @parm_divlist = ("None");
    for ($i=0; $i<=$#parmlist; $i++) {
        next if ($parmlist[$i] eq "Horizontal Velocity"
                  || $parmlist[$i] eq "Vertical Velocity"
                  || $parmlist[$i] eq "Density"
                  || $parmlist[$i] eq "Habitat");
        if ($parm ne $parmlist[$i]) {
            push (@parm_divlist, $parmlist[$i]);
        }
    }
    $axis_opt     = "Time on X, Distance on Y";
    @axis_opts    = ("Time on X, Distance on Y", "Time on Y, Distance on X");
    $dist_units   = "miles";
    $dist_flip    = 0;
    $date_type    = "Date/Time";
    $date_flip    = 0;
    $cscheme      = "Blue to Orange";
    $ncolors      = 20;
    $byear        = $grid{$id}{byear};
    $tz_offset    = "+00:00";
    $profile_stat = "Volume-weighted";

    $yr_max = (localtime(time))[5] +1900;
    $yr_min = $yr_max -25;
    $yr_min = $byear -5 if ($byear <= $yr_min);
    $dbase  = $dmin = $dfirst = 0;
    $dmajor = $pmin = $pmax   = "";

    $parm_short = $parm;
    if ($parm eq "Temperature" || $parm =~ /^(Tmax|Tmean|Tmin|TEMP)$/) {
        $units = "Celsius";
        if ($parm eq "Temperature" || $parm eq "TEMP") {
            $title = "Temperature, in degrees Celsius";
        } elsif ($parm eq "Tmax") {
            $title = "Max Temperature, in degrees Celsius";
        } elsif ($parm eq "Tmean") {
            $title = "Mean Temperature, in degrees Celsius";
        } elsif ($parm eq "Tmin") {
            $title = "Min Temperature, in degrees Celsius";
        }
    } else {
        $units = "";
        $parm_short =~ s/\(ms-1\)//i;
        $parm_short =~ s/\(m3s-1\)//i;
        $parm_short =~ s/ [kmu]?g\/L\/day//i;
        $parm_short =~ s/ [kmu]?g\/m2\/day//i;
        $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
        $parm_short =~ s/ [kmu]?g\/L//i;
        $parm_short =~ s/ [kmu]?g\/m3//i;
        $parm_short =~ s/ [kmu]?g\/m\^3//i;
        $parm_short =~ s/, days//i;
        $parm_short =~ s/ days//i;
        $parm_short =~ s/,$//;
        if ($parm eq "Horizontal Velocity" || $parm eq "Vertical Velocity") {
            $units = "m/s";
            $title = $parm_short . ", in m/s";
        } elsif ($parm eq "Density") {
            $units = "kg/m3";
            $title = $parm_short . ", in kg/m3";
        } else {
            $title = $parm_short . ", in ";
        }
    }
    $gtitle        = "Time/Distance Map of $parm_short";
    $gstitle       = "";
    $oldparm       = $parm;
    $oldparm_short = $parm_short;
    $old_units     = $units;

#   Available initial colormaps
    @cmaps = ("Blue to Orange", "Blue to Red", "CoolWarm", "Turbo", "Viridis");

#   Conversion types and factors (@conv_types is global)
    $conv_type = $conv_types[0];
    $conv_mult = 1.0;
    $conv_add  = 0.0;

#   Skip some dates?
    $jd_skip_active = $jd_skip = 0;
    if ($src_type =~ /RiverCon/i) {
        $jd_skip_active = 1 if ($riv_freq < 1.0);
    } elsif ($src_type =~ /Contour/i) {
        @ncpl = @{ $grid{$id}{ncpl} };
        @cplf = @{ $grid{$id}{cplf} };
        @wbs  = split(/,/, $props{$id}{wb_list});
        foreach $jw (@wbs) {
            for ($i=1; $i<=$ncpl[$jw]; $i++) {
                if ($cplf[$i][$jw] < 1.0) {
                    $jd_skip_active = 1;
                    last;
                }
            }
            last if ($jd_skip_active);
        }
        undef @ncpl;
        undef @cplf;
        undef @wbs;
    } elsif ($src_type =~ /Vector/i) {
        @nvpl = @{ $grid{$id}{nvpl} };
        @vplf = @{ $grid{$id}{vplf} };
        @wbs  = split(/,/, $props{$id}{wb_list});
        foreach $jw (@wbs) {
            for ($i=1; $i<=$nvpl[$jw]; $i++) {
                if ($vplf[$i][$jw] < 1.0) {
                    $jd_skip_active = 1;
                    last;
                }
            }
            last if ($jd_skip_active);
        }
        undef @nvpl;
        undef @vplf;
        undef @wbs;
    } elsif ($src_type =~ /SurfTemp|VolTemp|FlowTemp/i) {
        ($ftype, undef, undef) = &determine_ts_type($w2tdmap_setup_menu, $props{$id}{src_file}, 1);
        if ($ftype =~ /^W2 .*daily .*Temp2\.dat format$/i) {
            $ntsr = $grid{$id}{ntsr};
            @tsrf = @{ $grid{$id}{tsrf} };
            for ($i=1; $i<=$ntsr; $i++) {
                if ($tsrf[$i] < 1.0) {
                    $jd_skip_active = 1;
                    last;
                }
            }
            undef @tsrf;
        }
    }
    @jd_skip_opts = ("(keep all)", "(keep every other)", "(keep every 3rd)", "(keep every 4th)",
                     "(keep every 5th)",  "(keep every 6th)",  "(keep every 7th)",  "(keep every 8th)",
                     "(keep every 9th)",  "(keep every 10th)", "(keep every 11th)", "(keep every 12th)",
                     "(keep every 13th)", "(keep every 14th)", "(keep every 15th)", "(keep every 16th)",
                     "(keep every 17th)", "(keep every 18th)", "(keep every 19th)", "(keep every 20th)",
                     "(keep every 21st)", "(keep every 22nd)", "(keep every 23rd)", "(keep every 24th)",
                     "(keep every 25th)", "(keep every 26th)", "(keep every 27th)", "(keep every 28th)",
                     "(keep every 29th)", "(keep every 30th)", "(keep every 31st)", "(keep every 32nd)",
                     "(keep every 33rd)", "(keep every 34th)", "(keep every 35st)", "(keep every 36th)",
                     "(keep every 37th)", "(keep every 38th)", "(keep every 39th)", "(keep every 40th)",
                     "(keep every 41st)", "(keep every 42nd)", "(keep every 43rd)", "(keep every 44th)",
                     "(keep every 45th)", "(keep every 46th)", "(keep every 47th)", "(keep every 48th)",
                     "(keep every 49th)", "(keep every 50th)");
    $jd_skip_explain = $jd_skip_opts[$jd_skip];

#   Set up the menu
    $frame = $w2tdmap_setup_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -command => sub { my (%parms);
                              if ($pmin eq "" || $pmax eq "") {
                                  return &pop_up_error($w2tdmap_setup_menu,
                                  "Please provide both a min and max for your parameter.");
                              }
                              if ($pmin >= $pmax) {
                                  return &pop_up_error($w2tdmap_setup_menu,
                                  "The minimum data value must be less than the maximum data value.");
                              }
                              if ($dfirst ne "" && (($dmin ne "" && $dfirst < $dmin)
                                                 || ($dmin eq "" && $dfirst < 0))) {
                                  return &pop_up_error($w2tdmap_setup_menu,
                                  "The first distance label should not be less than the minimum distance.");
                              }
                              if ($conv_type eq "Custom") {
                                  $conv_type = sprintf("Custom,%s,%s", $conv_mult, $conv_add);
                              }
                              $gtitle  =~ s/^\s+//;
                              $gtitle  =~ s/\s+$//;
                              $gstitle =~ s/^\s+//;
                              $gstitle =~ s/\s+$//;

                              %parms             = ();
                              $parms{pmin}       = $pmin;
                              $parms{pmax}       = $pmax;
                              $parms{date_axis}  = ($axis_opt =~ /Time on X/) ? "X" : "Y";
                              $parms{date_type}  = $date_type;
                              $parms{date_flip}  = $date_flip;
                              $parms{dist_units} = $dist_units;
                              $parms{dist_flip}  = $dist_flip;
                              $parms{dist_base}  = $dbase;
                              $parms{dist_min}   = $dmin;
                              $parms{dist_first} = $dfirst;
                              $parms{dist_major} = $dmajor;
                              $parms{cscheme}    = $cscheme;
                              $parms{ncolors}    = $ncolors;
                              $parms{gtitle}     = $gtitle;
                              $parms{gstitle}    = $gstitle;
                              $props{$id}{parms} = { %parms };

                              $props{$id}{parm}       = $parm;
                              $props{$id}{parm_sav}   = $parm;
                              $props{$id}{parm_div}   = $parm_div;
                              $props{$id}{pdiv_sav}   = $parm_div;
                              $props{$id}{parm_units} = $units;
                              $props{$id}{ctype}      = $conv_type;
                              $props{$id}{byear}      = $byear;
                              $props{$id}{tz_offset}  = $tz_offset;
                              $props{$id}{prof_stat}  = $profile_stat;
                              $props{$id}{jd_skip}    = $jd_skip;
                              $props{$id}{map_type}   = "standard";

                              $w2tdmap_setup_menu->g_bind('<Destroy>', "");
                              $w2tdmap_setup_menu->g_destroy();
                              undef $w2tdmap_setup_menu;
                              &reset_bindings;

                              &make_w2_tdmap($canv, $id, 0);
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);

    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $w2tdmap_setup_menu->g_bind('<Destroy>', "");
                              $w2tdmap_setup_menu->g_destroy();
                              undef $w2tdmap_setup_menu;
                              $canv->delete("graph" . $id);
                              delete $props{$id};
                              delete $grid{$id};
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Delete graph if this menu is destroyed by other than the Cancel button
    $w2tdmap_setup_menu->g_bind('<Destroy>' => sub { undef $w2tdmap_setup_menu;
                                                     $canv->delete("graph" . $id);
                                                     delete $props{$id}; 
                                                     delete $grid{$id};
                                                     &reset_bindings;
                                                   });

    ($f = $w2tdmap_setup_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "Parameter: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    if ($src_type =~ /RiverCon/i) {
        $f->new_label(
                -text => $parm,
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    } else {
        ($parm_frame = $f->new_frame(
                -borderwidth => 0,
                -relief      => 'flat',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
        ($parm_cb = $parm_frame->new_ttk__combobox(
                -textvariable => \$parm,
                -values       => [ @parmlist ],
                -state        => 'readonly',
                -width        => $parm_chars,
                ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        $parm_cb->g_bind("<<ComboboxSelected>>",
                             sub { my ($i);
                                   return if ($parm eq $oldparm);
                                   $parm_short = $parm;
                                   if ($parm eq "Temperature" || $parm =~ /^(Tmax|Tmean|Tmin|TEMP)$/) {
                                       $units = "Celsius" if ($units !~ /(Celsius|Fahrenheit)/);
                                       if ($parm eq "Temperature" || $parm eq "TEMP") {
                                           $title = "Temperature, in degrees " . $units;
                                       } elsif ($parm eq "Tmax") {
                                           $title = "Max Temperature, in degrees " . $units;
                                       } elsif ($parm eq "Tmean") {
                                           $title = "Mean Temperature, in degrees " . $units;
                                       } elsif ($parm eq "Tmin") {
                                           $title = "Min Temperature, in degrees " . $units;
                                       }
                                       $units_cb->g_grid();
                                       $units_entry->g_grid_remove();
                                       $conv_type_na_label->g_grid();
                                       $custom_frame->g_grid_remove();
                                       $conv_type_cb->g_grid_remove();
                                       $conv_type = "None";
                                   } else {
                                       $units = "";
                                       $parm_short =~ s/\(ms-1\)//i;
                                       $parm_short =~ s/\(m3s-1\)//i;
                                       $parm_short =~ s/ [kmu]?g\/L\/day//i;
                                       $parm_short =~ s/ [kmu]?g\/m2\/day//i;
                                       $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
                                       $parm_short =~ s/ [kmu]?g\/L//i;
                                       $parm_short =~ s/ [kmu]?g\/m3//i;
                                       $parm_short =~ s/ [kmu]?g\/m\^3//i;
                                       $parm_short =~ s/, days//i;
                                       $parm_short =~ s/ days//i;
                                       $parm_short =~ s/,$//;
                                       if ($parm eq "Horizontal Velocity" || $parm eq "Vertical Velocity") {
                                           $units = "m/s";
                                           $title = $parm_short . ", in m/s";
                                       } elsif ($parm eq "Density") {
                                           $units = "kg/m3";
                                           $title = $parm_short . ", in kg/m3";
                                       } else {
                                           $title = $parm_short . ", in ";
                                       }
                                       $units_cb->g_grid_remove();
                                       $units_entry->g_grid();
                                       $conv_type_na_label->g_grid_remove();
                                       $custom_frame->g_grid() if ($conv_type eq "Custom");
                                       $conv_type_cb->g_grid();
                                   }
                                   if ($gtitle eq "") {
                                       $gtitle = "Time/Distance Map of $parm_short";
                                   } else {
                                       if (index(lc($gtitle), lc($oldparm_short)) > -1) {
                                           $gtitle =~ s/$oldparm_short/$parm_short/i;
                                       }
                                   }
                                   $old_units     = $units;
                                   $oldparm       = $parm;
                                   $oldparm_short = $parm_short;
                                   @parm_divlist = ("None");
                                   for ($i=0; $i<=$#parmlist; $i++) {
                                       next if ($parmlist[$i] eq "Horizontal Velocity"
                                                   || $parmlist[$i] eq "Vertical Velocity"
                                                   || $parmlist[$i] eq "Density"
                                                   || $parmlist[$i] eq "Habitat");
                                       if ($parm ne $parmlist[$i]) {
                                           push (@parm_divlist, $parmlist[$i]);
                                       }
                                   }
                                   $parm_div_cb->configure(-values => [ @parm_divlist ]);
                                   if (&list_match($parm_div, @parm_divlist) == -1) {
                                       $parm_div = "None";
                                   }
                                   if ($parm =~ /^(Temperature|TEMP)$/ || $parm eq "Horizontal Velocity"
                                                || $parm eq "Vertical Velocity" || $parm eq "Density"
                                                || $parm eq "Habitat" || $#parm_divlist == 0) {
                                       $parm_div_label->g_pack_forget();
                                       $parm_div_cb->g_pack_forget();
                                       $parm_div = "None";
                                   } else {
                                       $parm_div_label->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                                       $parm_div_cb->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                                   }
                                 });
        ($parm_div_label = $parm_frame->new_label(
                -text => " divided by ",
                -font => 'default',
                ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        ($parm_div_cb = $parm_frame->new_ttk__combobox(
                -textvariable => \$parm_div,
                -values       => [ @parm_divlist ],
                -state        => 'readonly',
                -width        => $parm_chars,
                ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    }

    $row++;
    $f->new_label(
            -text => "Profile Stat: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    if ($src_type =~ /Contour|Vector/i) {
        $f->new_ttk__combobox(
                -textvariable => \$profile_stat,
                -values       => [ ("Surface value", "Volume-weighted") ],
                -state        => 'readonly',
                -width        => 16,
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    } else {
        if ($src_type =~ /SurfTemp|RiverCon/) {
            $profile_stat = "Surface value";
        } elsif ($src_type =~ /VolTemp/) {
            $profile_stat = "Volume-weighted";
        } elsif ($src_type =~ /FlowTemp/) {
            $profile_stat = "Flow-weighted";
        }
        $f->new_label(
                -text => $profile_stat,
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    }

    $row++;
    $f->new_label(
            -text => "Conversion: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($conv_type_na_label = $f->new_label(
            -text => "n/a",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $conv_type_na_label->g_grid_remove();
    ($conv_type_cb = $f->new_ttk__combobox(
            -textvariable => \$conv_type,
            -values       => [ @conv_types ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $conv_type_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($conv_type eq "Custom") {
                                $custom_frame->g_grid();
                            } else {
                                $custom_frame->g_grid_remove();
                            }
                          }
                      );
    $row++;
    ($custom_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $custom_frame->new_label(
            -text => "Multiply by: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_mult_entry = $custom_frame->new_entry(
            -textvariable => \$conv_mult,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_mult_entry->g_bind("<KeyRelease>",
                              sub { &numeric_entry_only($conv_mult_entry);
                                    my $chars = &max(7, length($conv_mult));
                                    $conv_mult_entry->configure(-width => $chars);
                                  });
    $custom_frame->new_label(
            -text => "  Then add: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_add_entry = $custom_frame->new_entry(
            -textvariable => \$conv_add,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_add_entry->g_bind("<KeyRelease>",
                             sub { &numeric_entry_only($conv_add_entry);
                                   my $chars = &max(7, length($conv_add));
                                   $conv_add_entry->configure(-width => $chars);
                                 });

    $row++;
    $f->new_label(
            -text => "Data Units: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($units_cb = $f->new_ttk__combobox(
            -textvariable => \$units,
            -values       => [ ("Celsius", "Fahrenheit") ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $units_cb->g_bind("<<ComboboxSelected>>",
                       sub { return if ($units eq $old_units);
                             $old_units = $units;
                             $pmin = 0 if ($pmin eq "-");
                             $pmax = 0 if ($pmax eq "-");
                             if ($units eq "Celsius") {
                                 $pmin = &floor(($pmin -32) /1.8) if ($pmin ne "");
                                 $pmax = &ceil(($pmax  -32) /1.8) if ($pmax ne "");
                             } elsif ($units eq "Fahrenheit") {
                                 $pmin = &floor($pmin *1.8 +32) if ($pmin ne "");
                                 $pmax = &ceil($pmax  *1.8 +32) if ($pmax ne "");
                             }
                             $title = "Temperature, in degrees " . $units;
                           });
    $units_cb->g_grid_remove();
    ($units_entry = $f->new_entry(
            -textvariable => \$units,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $units_entry->g_bind("<KeyRelease>",
                         sub { my $chars = &max(7, length($units));
                               $units_entry->configure(-width => $chars);
                               if ($parm eq "Temperature") {
                                   $title = "Temperature, in degrees " . $units;
                               } else {
                                   $title = $parm_short . ", in " . $units;
                               }
                             });

    $row++;
    $f->new_label(
            -text => "Data Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$title,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Data Min: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmin_entry = $f->new_entry(
            -textvariable => \$pmin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $pmin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmin_entry ]);

    $row++;
    $f->new_label(
            -text => "Data Max: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmax_entry = $f->new_entry(
            -textvariable => \$pmax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $pmax_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmax_entry ]);

    $row++;
    $f->new_label(
            -text => "Axis Orientation: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_ttk__combobox(
            -textvariable => \$axis_opt,
            -values       => [ @axis_opts ],
            -state        => 'readonly',
            -width        => 25,
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Date Axis Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($date_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $date_frame->new_ttk__combobox(
            -textvariable => \$date_type,
            -values       => [ ("Date/Time", "Julian Date") ],
            -state        => 'readonly',
            -width        => 12,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $date_frame->new_checkbutton(
            -onvalue  => 1,
            -offvalue => 0,
            -text     => "Flip Axis",
            -font     => 'default',
            -variable => \$date_flip,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Distance Base: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($dbase_entry = $f->new_entry(
            -textvariable => \$dbase,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $dbase_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $dbase_entry ]);
    $f->new_label(
            -textvariable => \$dist_units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Distance Min: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($dmin_entry = $f->new_entry(
            -textvariable => \$dmin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $dmin_entry->g_bind("<KeyRelease>",
                         sub { &numeric_entry_only($dmin_entry);
                               if ($dmin ne "" && $dmin ne "." && $dmin ne "-") {
                                   if ($dfirst ne "" && $dfirst ne "."
                                                     && $dfirst ne "-" && $dfirst < $dmin) {
                                       if (&ceil($dmin) != $dmin) {
                                           $dfirst = &ceil($dmin);
                                       } else {
                                           $dfirst = $dmin;
                                       }
                                   }
                               }
                             });
    $f->new_label(
            -textvariable => \$dist_units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "First Distance Label: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($dfirst_entry = $f->new_entry(
            -textvariable => \$dfirst,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $dfirst_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $dfirst_entry ]);
    $f->new_label(
            -textvariable => \$dist_units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Distance Major: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($dmajor_entry = $f->new_entry(
            -textvariable => \$dmajor,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $dmajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($dmajor_entry, 1);
                                                $dmajor =~ s/^-//;
                                              });
    $f->new_label(
            -textvariable => \$dist_units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Distance Units: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($dist_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $dist_frame->new_ttk__combobox(
            -textvariable => \$dist_units,
            -values       => [ ("miles", "kilometers") ],
            -state        => 'readonly',
            -width        => 10,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $dist_frame->new_checkbutton(
            -onvalue  => 1,
            -offvalue => 0,
            -text     => "Flip Axis",
            -font     => 'default',
            -variable => \$dist_flip,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Color Scheme: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($cscheme_cb = $f->new_ttk__combobox(
            -textvariable => \$cscheme,
            -values       => [ @cmaps ],
            -state        => 'readonly',
            -width        => 15,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $cscheme_cb->g_bind("<<ComboboxSelected>>",
                           sub { my ($n);
                                 if ($cscheme =~ /CoolWarm|Turbo|Viridis/) {
                                     $ncolors_cb->configure(-values => [ (8 .. 100) ]);
                                 } else {
                                     $ncolors_cb->configure(-values =>
                                         [ (16, 18, 20, 22, 24, 30, 34, 38, 42, 46) ]);
                                     if ($ncolors < 16) {
                                         $ncolors = 16;
                                     } elsif ($ncolors > 46) {
                                         $ncolors = 46;
                                     } else {
                                         foreach $n (reverse @valid_nc) {
                                             if ($ncolors >= 2 *$n) {
                                                 $ncolors = 2 *$n;
                                                 last;
                                             }
                                         }
                                     }
                                 }
                               });

    $row++;
    $f->new_label(
            -text => "Number of Colors: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ncolors_cb = $f->new_ttk__combobox(
            -textvariable => \$ncolors,
            -values       => [ (16, 18, 20, 22, 24, 30, 34, 38, 42, 46) ],
            -state        => 'readonly',
            -width        => 4,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Base Year: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($byear_cb = $f->new_ttk__combobox(
            -textvariable => \$byear,
            -values       => [ reverse($yr_min .. $yr_max) ],
            -state        => 'readonly',
            -width        => 5,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $byear_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($byear == $yr_min) {
                                $yr_min -= 5;
                                $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                            }
                          }
                     );
    $f->new_label(
            -text   => " for JDAY = 1.0",
            -anchor => 'w',
            -font   => 'default',
            )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Time Offset: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($offset_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    $offset_frame->new_ttk__combobox(
            -textvariable => \$tz_offset,
            -values       => [ @tz_offsets ],
            -justify      => 'right',
            -state        => 'readonly',
            -width        => 6,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $offset_frame->new_label(
            -text   => " time zone adjustment ",
            -anchor => 'w',
            -font   => 'default',
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $offset_frame->new_button(
            -text    => "Help",
            -command => sub { &pop_up_info($w2tdmap_setup_menu,
                                    "The time offset allows the user to add or subtract a time\n"
                                  . "offset if the W2 model was run with a non-local time zone.\n\n"
                                  . "For example, if W2 was run in UTC but the local time zone\n"
                                  . "is PST, an offset of -08:00 would convert the model date/time\n"
                                  . "to a local standard time of PST. This offset does not make\n"
                                  . "any adjustments related to daylight saving time. In general,\n"
                                  . "W2 is best run in the local standard time.\n\n"
                                  . "Leave the time offset at +00:00 for no adjustment.",
                                    "Time Offset Notice");
                            },
            )->g_pack(-side => 'left', -anchor => 'w', -padx => 2);

    if ($jd_skip_active) {
        $row++;
        $f->new_label(
                -text => "Skip Dates: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $f->new_spinbox(
                -textvariable => \$jd_skip,
                -state        => 'readonly',
                -font         => 'default',
                -from         => 0,
                -to           => 49,
                -increment    => 1,
                -width        => 4,
                -command      => sub { $jd_skip_explain = $jd_skip_opts[$jd_skip]; },
                )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $f->new_label(
                -textvariable => \$jd_skip_explain,
                -font         => 'default',
                )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);
    }

    $row++;
    $f->new_label(
            -text => "Graph Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gtitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Graph Subtitle: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gstitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);

    if ($src_type !~ /RiverCon/i) {
        if ($parm =~ /^(Temperature|TEMP)$/ || $parm eq "Horizontal Velocity" || $parm eq "Density"
                     || $parm eq "Habitat" || $#parm_divlist == 0 || $parm eq "Vertical Velocity") {
            $parm_div_label->g_pack_forget();
            $parm_div_cb->g_pack_forget();
            $parm_div = "None";
        } else {
            $parm_div_label->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
            $parm_div_cb->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        }
    }
    if ($conv_type ne "Custom") {
        $custom_frame->g_grid_remove();
    }
    if ($parm eq "Temperature" || $parm =~ /^(Tmax|Tmean|Tmin|TEMP)$/) {
        $units_cb->g_grid();
        $units_entry->g_grid_remove();
        $conv_type_na_label->g_grid();
        $custom_frame->g_grid_remove();
        $conv_type_cb->g_grid_remove();
        $conv_type = "None";
        $parm_div  = "None";
    } else {
        $units_cb->g_grid_remove();
        $units_entry->g_grid();
        $conv_type_na_label->g_grid_remove();
        $custom_frame->g_grid() if ($conv_type eq "Custom");
        $conv_type_cb->g_grid();
    }
    if ($cscheme =~ /CoolWarm|Turbo|Viridis/) {
        $ncolors_cb->configure(-values => [ (8 .. 100) ]);
    } else {
        $ncolors_cb->configure(-values => [ (16, 18, 20, 22, 24, 30, 34, 38, 42, 46) ]);
        if ($ncolors < 16) {
            $ncolors = 16;
        } elsif ($ncolors > 46) {
            $ncolors = 46;
        } else {
            foreach $n (reverse @valid_nc) {
                if ($ncolors >= 2 *$n) {
                    $ncolors = 2 *$n;
                    last;
                }
            }
        }
    }
    $f->g_grid_columnconfigure(2, -weight => 2);

    Tkx::wm_resizable($w2tdmap_setup_menu,0,0);
    &adjust_window_position($w2tdmap_setup_menu);
    $w2tdmap_setup_menu->g_focus;
}


sub setup_w2_tdmap_parmdiff {
    my ($canv, $id, $X, $Y) = @_;
    my (
        $conv_add, $conv_add_entry, $conv_mult, $conv_mult_entry, $conv_type,
        $conv_type_cb, $conv_type_na_label, $custom_frame, $f, $frame, $geom,
        $gstitle, $gtitle, $i, $jw, $n, $ok, $ok_btn, $old_units, $oldparm,
        $oldparm_short, $p, $parm, $parm_cb, $parm_chars, $parm_div,
        $parm_div_cb, $parm_div_label, $parm_frame, $parm_short, $parm1,
        $parm1_txt, $parms_ref, $pmax, $pmax_entry, $pmin, $pmin_entry,
        $row, $src_type, $tecplot, $title, $units, $units_cb, $units_entry,

        @cpl_files, @parm_divlist, @parm_tmp, @parmlist, @parms_list, @wbs,
       );

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($w2tdmap_diff_menu) && Tkx::winfo_exists($w2tdmap_diff_menu)) {
        if ($w2tdmap_diff_menu->g_wm_title() eq "W2 Time/Distance Difference Setup") {
            $w2tdmap_diff_menu->g_destroy();
            undef $w2tdmap_diff_menu;
        }
    }
    $w2tdmap_diff_menu = $main->new_toplevel();
    $w2tdmap_diff_menu->g_wm_transient($main);
    $w2tdmap_diff_menu->g_wm_title("W2 Time/Distance Difference Setup");
    $w2tdmap_diff_menu->configure(-cursor => $cursor_norm);
    $w2tdmap_diff_menu->g_wm_geometry($geom);

#   Try to keep the graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");
    &end_select($canv, $id, 1);

#   Initialize some variables.
    $src_type  = $props{$id}{src_type};
    $pmin      = $gr_props{$id}{cs_min};
    $pmax      = $gr_props{$id}{cs_max};
    $gstitle   = $gr_props{$id}{gstitle};
    $conv_type = $conv_types[0];
    $conv_mult = 1.0;
    $conv_add  = 0.0;

    $parm1 = $props{$id}{parm_sav};
    if ($parm1 =~ /^(Temperature|TEMP|Tmin|Tmean|Tmax)$/) {
        if ($parm1 eq "TEMP") {
            $parm1 = "Temperature";
        } elsif ($parm1 eq "Tmax") {
            $parm1 = "Max Temperature";
        } elsif ($parm1 eq "Tmean") {
            $parm1 = "Mean Temperature";
        } elsif ($parm1 eq "Tmin") {
            $parm1 = "Min Temperature";
        }
    } else {
        $parm1 =~ s/\(ms-1\)//i;
        $parm1 =~ s/\(m3s-1\)//i;
        $parm1 =~ s/ [kmu]?g\/L\/day//i;
        $parm1 =~ s/ [kmu]?g\/m2\/day//i;
        $parm1 =~ s/ [kmu]?g\/m\^2\/day//i;
        $parm1 =~ s/ [kmu]?g\/L//i;
        $parm1 =~ s/ [kmu]?g\/m3//i;
        $parm1 =~ s/ [kmu]?g\/m\^3//i;
        $parm1 =~ s/, days//i;
        $parm1 =~ s/ days//i;
        $parm1 =~ s/,$//;
    }
    if ($props{$id}{pdiv_sav} ne "None") {
        $parm1_txt = $props{$id}{parm_sav} . " / " . $props{$id}{pdiv_sav};
    } else {
        $parm1_txt = $props{$id}{parm_sav};
    }
    if ($props{$id}{parm_units} =~ /^(Celsius|Fahrenheit)$/) {
        $parm1_txt .= ", in degrees " . $props{$id}{parm_units};
    } else {
        $parm1_txt .= ", in " . $props{$id}{parm_units};
    }

    if ($src_type =~ /Contour/i) {
        @cpl_files = @{ $props{$id}{cpl_files} };
        @wbs       = split(/,/, $props{$id}{wb_list});
        for ($n=0; $n<=$#wbs; $n++) {
            ($tecplot, undef, $jw, $parms_ref, undef, undef)
                  = &scan_w2_cpl_file($w2tdmap_diff_menu, $cpl_files[$n], $id, 0, "");
            if ($tecplot == -1) {
                return &pop_up_error($w2tdmap_diff_menu,
                                     "The source file is not a W2 Contour file:\n$cpl_files[$n]");
            }
            @parms_list = @{ $parms_ref };
            if ($n == 0) {
                @parmlist = @parms_list;
            } else {                # only keep parameters common to all cpl files
                @parm_tmp = ();
                foreach $p ( @parms_list ) {
                    if (&list_match($p, @parmlist) >= 0) {
                        push (@parm_tmp, $p);
                    }
                }
                @parmlist = @parm_tmp;
            }
        }
    } elsif ($src_type =~ /Vector/i) {
        ($ok, $parms_ref, undef, undef, undef)
                  = &scan_w2_vector_file($w2tdmap_diff_menu, $props{$id}{w2l_file}, $id, 0);
        if ($ok ne "okay") {
            return &pop_up_error($w2tdmap_diff_menu,
                                 "The source file is not a W2 Vector (w2l) file:\n$props{$id}{w2l_file}");
        }
        @parmlist = @{ $parms_ref };
    } elsif ($src_type =~ /SurfTemp|VolTemp|FlowTemp/i) {
        (undef, undef, @parmlist) = &determine_ts_type($w2tdmap_diff_menu, $props{$id}{src_file}, 1);
    }

#   Remove current parameter from working list
    @parms_list = @parmlist;
    @parm_tmp   = ();
    foreach $p ( @parmlist ) {
        push (@parm_tmp, $p) if ($p ne $props{$id}{parm_sav});
    }
    @parmlist = @parm_tmp;
    $parm     = $parmlist[0];
    $parm_div = "None";
    $units    = "";

    $parm_chars = length($parm);
    for ($i=1; $i<=$#parmlist; $i++) {
        $parm_chars = &max($parm_chars, length($parmlist[$i]));
    }
    $parm_chars += 2;
    $parm_short = $parm;
    if ($parm !~ /^(Temperature|TEMP|Tmin|Tmean|Tmax)$/) {
        $parm_short =~ s/\(ms-1\)//i;
        $parm_short =~ s/\(m3s-1\)//i;
        $parm_short =~ s/ [kmu]?g\/L\/day//i;
        $parm_short =~ s/ [kmu]?g\/m2\/day//i;
        $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
        $parm_short =~ s/ [kmu]?g\/L//i;
        $parm_short =~ s/ [kmu]?g\/m3//i;
        $parm_short =~ s/ [kmu]?g\/m\^3//i;
        $parm_short =~ s/, days//i;
        $parm_short =~ s/ days//i;
        $parm_short =~ s/,$//;
    }
    $gtitle        = "Time/Distance Diff Map of $parm1 minus $parm_short";
    $old_units     = $units;
    $oldparm       = $parm;
    $oldparm_short = $parm_short;
    @parm_divlist  = ("None");
    for ($i=0; $i<=$#parms_list; $i++) {
        next if ($parms_list[$i] eq "Horizontal Velocity"
                  || $parms_list[$i] eq "Vertical Velocity"
                  || $parms_list[$i] eq "Density"
                  || $parms_list[$i] eq "Habitat");
        if ($parm ne $parms_list[$i]) {
            push (@parm_divlist, $parms_list[$i]);
        }
    }

    if ($parm =~ /^(Temperature|Tmax|Tmean|Tmin|TEMP)$/) {
        if ($parm eq "Temperature" || $parm eq "TEMP") {
            $title = $parm1 . " minus Temperature, in ";
        } elsif ($parm eq "Tmax") {
            $title = $parm1 . " minus Max Temperature, in ";
        } elsif ($parm eq "Tmean") {
            $title = $parm1 . " minus Mean Temperature, in ";
        } elsif ($parm eq "Tmin") {
            $title = $parm1 . " minus Min Temperature, in ";
        }
        if ($parm1 =~ /Temperature/) {
            $units     = "Celsius" if ($units !~ /(Celsius|Fahrenheit)/);
            $title    .= "degrees " . $units;
            $old_units = $units;
        }
    } elsif (($parm  eq "Horizontal Velocity" || $parm  eq "Vertical Velocity") &&
             ($parm1 eq "Horizontal Velocity" || $parm1 eq "Vertical Velocity")) {
        $units     = "m/s";
        $title     = $parm1 . " minus " . $parm_short . ", in m/s";
        $old_units = $units;
    } elsif ($parm eq "Density" && $parm1 eq "Density") {
        $units     = "kg/m3";
        $title     = $parm1 . " minus " . $parm_short . ", in kg/m3";
        $old_units = $units;
    } else {
        $title = $parm1 . " minus " . $parm_short . ", in ";
    }

#   Build the menu.
    $frame = $w2tdmap_diff_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -command => sub { my (%parms);
                              %parms = ();
                              if ($pmin eq "" || $pmax eq "") {
                                  return &pop_up_error($w2tdmap_diff_menu,
                                  "Please provide both a min and max for your data.");
                              }
                              if ($pmin >= $pmax) {
                                  return &pop_up_error($w2tdmap_diff_menu,
                                  "The minimum data value must be less than the maximum data value.");
                              }
                              if ($conv_type eq "Custom") {
                                  $conv_type = sprintf("Custom,%s,%s", $conv_mult, $conv_add);
                              }
                              $title   =~ s/^\s+//;
                              $title   =~ s/\s+$//;
                              $gtitle  =~ s/^\s+//;
                              $gtitle  =~ s/\s+$//;
                              $gstitle =~ s/^\s+//;
                              $gstitle =~ s/\s+$//;

                              $parms{pmin}       = $pmin;
                              $parms{pmax}       = $pmax;
                              $parms{title}      = $title;
                              $parms{gtitle}     = $gtitle;
                              $parms{gstitle}    = $gstitle;
                              $parms{change}     = "";
                              $props{$id}{parms} = { %parms };

                              if ($src_type =~ /Contour/i) {
                                  $props{$id}{tecplot2}   = $props{$id}{tecplot};
                                  $props{$id}{cpl_lines2} = $props{$id}{cpl_lines};
                                  $props{$id}{cpl_files2} = $props{$id}{cpl_files};
                              } elsif ($src_type =~ /Contour/i) {
                                  $props{$id}{w2l_file2}  = $props{$id}{w2l_file};
                              } elsif ($src_type =~ /SurfTemp|VolTemp|FlowTemp/i) {
                                  $props{$id}{src_file2}  = $props{$id}{src_file};
                                  $props{$id}{src_lines2} = $props{$id}{src_lines};
                              }
                              $props{$id}{map_type}   = "parmdiff";
                              $props{$id}{src_type2}  = $props{$id}{src_type};
                              $props{$id}{parm2}      = $parm;
                              $props{$id}{parm2_sav}  = $parm;
                              $props{$id}{parm2_div}  = $parm_div;
                              $props{$id}{pdiv2_sav}  = $parm_div;
                              $props{$id}{ctype2}     = $conv_type;
                              $props{$id}{parm_units} = $units;
                              $props{$id}{data2}      = 0;

                              $w2tdmap_diff_menu->g_bind('<Destroy>', "");
                              $w2tdmap_diff_menu->g_destroy();
                              undef $w2tdmap_diff_menu;
                              &reset_bindings;

                              &make_w2_tdmap($canv, $id, 0);
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $w2tdmap_diff_menu->g_bind('<Destroy>', "");
                              $w2tdmap_diff_menu->g_destroy();
                              undef $w2tdmap_diff_menu;
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Do not delete graph if this menu is destroyed by other than the Cancel button
    $w2tdmap_diff_menu->g_bind('<Destroy>' => sub { undef $w2tdmap_diff_menu;
                                                    &reset_bindings;
                                                  });

    $f = $w2tdmap_diff_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "Parameter 2 will be subtracted from Parameter 1.",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew');
    $row++;
    $f->new_ttk__separator(
            -orient => 'horizontal',
            )->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew');
    $row++;
    $f->new_label(
            -text => "Parameter 1: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $f->new_label(
            -text => $parm1_txt,
            -font => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $row++;
    $f->new_label(
            -text => "Profile Stat: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $f->new_label(
            -text => $props{$id}{prof_stat},
            -font => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');

    $row++;
    $f->new_label(
            -text => "Parameter 2: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($parm_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    ($parm_cb = $parm_frame->new_ttk__combobox(
            -textvariable => \$parm,
            -values       => [ @parmlist ],
            -state        => 'readonly',
            -width        => $parm_chars,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $parm_cb->g_bind("<<ComboboxSelected>>",
                      sub { my ($i);
                            return if ($parm eq $oldparm);
                            $parm_short = $parm;
                            if ($parm =~ /^(Temperature|Tmax|Tmean|Tmin|TEMP)$/) {
                                if ($parm eq "Temperature" || $parm eq "TEMP") {
                                    $title = $parm1 . " minus Temperature, in ";
                                } elsif ($parm eq "Tmax") {
                                    $title = $parm1 . " minus Max Temperature, in ";
                                } elsif ($parm eq "Tmean") {
                                    $title = $parm1 . " minus Mean Temperature, in ";
                                } elsif ($parm eq "Tmin") {
                                    $title = $parm1 . " minus Min Temperature, in ";
                                }
                                if ($parm1 =~ /Temperature/) {
                                    $units  = "Celsius" if ($units !~ /(Celsius|Fahrenheit)/);
                                    $title .= "degrees " . $units;
                                    $units_cb->g_grid();
                                    $units_entry->g_grid_remove();
                                    $conv_type_na_label->g_grid();
                                    $custom_frame->g_grid_remove();
                                    $conv_type_cb->g_grid_remove();
                                    $conv_type = "None";
                                } else {
                                    $units_cb->g_grid_remove();
                                    $units_entry->g_grid();
                                    $conv_type_na_label->g_grid_remove();
                                    $custom_frame->g_grid() if ($conv_type eq "Custom");
                                    $conv_type_cb->g_grid();
                                }
                            } else {
                                $units = "";
                                $parm_short =~ s/\(ms-1\)//i;
                                $parm_short =~ s/\(m3s-1\)//i;
                                $parm_short =~ s/ [kmu]?g\/L\/day//i;
                                $parm_short =~ s/ [kmu]?g\/m2\/day//i;
                                $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
                                $parm_short =~ s/ [kmu]?g\/L//i;
                                $parm_short =~ s/ [kmu]?g\/m3//i;
                                $parm_short =~ s/ [kmu]?g\/m\^3//i;
                                $parm_short =~ s/, days//i;
                                $parm_short =~ s/ days//i;
                                $parm_short =~ s/,$//;
                                if (($parm  eq "Horizontal Velocity" || $parm  eq "Vertical Velocity") &&
                                    ($parm1 eq "Horizontal Velocity" || $parm1 eq "Vertical Velocity")) {
                                    $units = "m/s";
                                    $title = $parm1 . " minus " . $parm_short . ", in m/s";
                                } elsif ($parm eq "Density" && $parm1 eq "Density") {
                                    $units = "kg/m3";
                                    $title = $parm1 . " minus " . $parm_short . ", in kg/m3";
                                } else {
                                    $title = $parm1 . " minus " . $parm_short . ", in ";
                                }
                                $units_cb->g_grid_remove();
                                $units_entry->g_grid();
                                $conv_type_na_label->g_grid_remove();
                                $custom_frame->g_grid() if ($conv_type eq "Custom");
                                $conv_type_cb->g_grid();
                            }
                            if ($gtitle eq "") {
                                $gtitle = "Time/Distance Diff Map of $parm1 minus $parm_short";
                            } else {
                                if (index(lc($gtitle), lc($oldparm_short)) > -1) {
                                    $gtitle =~ s/$oldparm_short/$parm_short/i;
                                }
                            }
                            $old_units     = $units;
                            $oldparm       = $parm;
                            $oldparm_short = $parm_short;
                            @parm_divlist  = ("None");
                            for ($i=0; $i<=$#parms_list; $i++) {
                                next if ($parms_list[$i] eq "Horizontal Velocity"
                                         || $parms_list[$i] eq "Vertical Velocity"
                                         || $parms_list[$i] eq "Density"
                                         || $parms_list[$i] eq "Habitat");
                                if ($parm ne $parms_list[$i]) {
                                    push (@parm_divlist, $parms_list[$i]);
                                }
                            }
                            $parm_div_cb->configure(-values => [ @parm_divlist ]);
                            if (&list_match($parm_div, @parm_divlist) == -1) {
                                $parm_div = "None";
                            }
                            if ($parm =~ /^(Temperature|TEMP)$/ || $parm eq "Horizontal Velocity"
                                    || $parm eq "Vertical Velocity" || $parm eq "Density"
                                    || $parm eq "Habitat" || $#parm_divlist == 0) {
                                $parm_div_label->g_pack_forget();
                                $parm_div_cb->g_pack_forget();
                                $parm_div = "None";
                            } else {
                                $parm_div_label->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                                $parm_div_cb->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                            }
                          });
    ($parm_div_label = $parm_frame->new_label(
            -text => " divided by ",
            -font => 'default',
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    ($parm_div_cb = $parm_frame->new_ttk__combobox(
            -textvariable => \$parm_div,
            -values       => [ @parm_divlist ],
            -state        => 'readonly',
            -width        => $parm_chars,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Conversion: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($conv_type_na_label = $f->new_label(
            -text => "n/a",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $conv_type_na_label->g_grid_remove();
    ($conv_type_cb = $f->new_ttk__combobox(
            -textvariable => \$conv_type,
            -values       => [ @conv_types ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $conv_type_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($conv_type eq "Custom") {
                                $custom_frame->g_grid();
                            } else {
                                $custom_frame->g_grid_remove();
                            }
                          }
                      );
    $row++;
    ($custom_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $custom_frame->new_label(
            -text => "Multiply by: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_mult_entry = $custom_frame->new_entry(
            -textvariable => \$conv_mult,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_mult_entry->g_bind("<KeyRelease>",
                              sub { &numeric_entry_only($conv_mult_entry);
                                    my $chars = &max(7, length($conv_mult));
                                    $conv_mult_entry->configure(-width => $chars);
                                  });
    $custom_frame->new_label(
            -text => "  Then add: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_add_entry = $custom_frame->new_entry(
            -textvariable => \$conv_add,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_add_entry->g_bind("<KeyRelease>",
                             sub { &numeric_entry_only($conv_add_entry);
                                   my $chars = &max(7, length($conv_add));
                                   $conv_add_entry->configure(-width => $chars);
                                 });

    $row++;
    $f->new_label(
            -text => "Data Units: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($units_cb = $f->new_ttk__combobox(
            -textvariable => \$units,
            -values       => [ ("Celsius", "Fahrenheit") ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $units_cb->g_bind("<<ComboboxSelected>>",
                       sub { return if ($units eq $old_units);
                             $old_units = $units;
                             if ($units eq "Celsius") {
                                 if ($pmin ne "" && $pmin ne "." && $pmin ne "-") {
                                     $pmin = &floor(($pmin -32) /1.8);
                                 }
                                 if ($pmax ne "" && $pmax ne "." && $pmax ne "-") {
                                     $pmax = &ceil(($pmax  -32) /1.8);
                                 }
                             } elsif ($units eq "Fahrenheit") {
                                 if ($pmin ne "" && $pmin ne "." && $pmin ne "-") {
                                     $pmin = &floor($pmin *1.8 +32);
                                 }
                                 if ($pmax ne "" && $pmax ne "." && $pmax ne "-") {
                                     $pmax = &ceil($pmax  *1.8 +32);
                                 }
                             }
                             if ($parm eq "Temperature" || $parm eq "TEMP") {
                                 $title = $parm1 . " minus Temperature, in degrees " . $units;
                             } elsif ($parm eq "Tmax") {
                                 $title = $parm1 . " minus Max Temperature, in degrees " . $units;
                             } elsif ($parm eq "Tmean") {
                                 $title = $parm1 . " minus Mean Temperature, in degrees " . $units;
                             } elsif ($parm eq "Tmin") {
                                 $title = $parm1 . " minus Min Temperature, in degrees " . $units;
                             }
                           });
    $units_cb->g_grid_remove();
    ($units_entry = $f->new_entry(
            -textvariable => \$units,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $units_entry->g_bind("<KeyRelease>",
                         sub { my $chars = &max(7, length($units) +1);
                               $units_entry->configure(-width => $chars);
                               if ($parm =~ /^(Temperature|Tmax|Tmean|Tmin|TEMP)$/) {
                                   if ($parm eq "Temperature" || $parm eq "TEMP") {
                                       $title = $parm1 . " minus Temperature, in ";
                                   } elsif ($parm eq "Tmax") {
                                       $title = $parm1 . " minus Max Temperature, in ";
                                   } elsif ($parm eq "Tmean") {
                                       $title = $parm1 . " minus Mean Temperature, in ";
                                   } elsif ($parm eq "Tmin") {
                                       $title = $parm1 . " minus Min Temperature, in ";
                                   }
                               } else {
                                   $title = $parm1 . " minus " . $parm_short . ", in ";
                               }
                               $title .= $units;
                             });

    $row++;
    $f->new_label(
            -text => "Color Key Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$title,
            -font         => 'default',
            -width        => 40,
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Data Min: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmin_entry = $f->new_entry(
            -textvariable => \$pmin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmin_entry ]);

    $row++;
    $f->new_label(
            -text => "Data Max: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmax_entry = $f->new_entry(
            -textvariable => \$pmax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmax_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmax_entry ]);

    $row++;
    $f->new_label(
            -text => "Graph Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gtitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Graph Subtitle: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gstitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);

    if ($parm =~ /^(Temperature|TEMP)$/ || $parm eq "Horizontal Velocity" || $parm eq "Density"
                                        || $parm eq "Vertical Velocity" || $parm eq "Habitat"
                                        || $#parm_divlist == 0) {
        $parm_div_label->g_pack_forget();
        $parm_div_cb->g_pack_forget();
        $parm_div = "None";
    } else {
        $parm_div_label->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        $parm_div_cb->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    }
    if ($conv_type ne "Custom") {
        $custom_frame->g_grid_remove();
    }
    if ($parm =~ /^(Temperature|Tmax|Tmean|Tmin|TEMP)$/) {
        $units_cb->g_grid();
        $units_entry->g_grid_remove();
        $conv_type_na_label->g_grid();
        $custom_frame->g_grid_remove();
        $conv_type_cb->g_grid_remove();
        $conv_type = "None";
    } else {
        $units_cb->g_grid_remove();
        $units_entry->g_grid();
        $conv_type_na_label->g_grid_remove();
        $custom_frame->g_grid() if ($conv_type eq "Custom");
        $conv_type_cb->g_grid();
    }
    $f->g_grid_columnconfigure(2, -weight => 2);

    Tkx::wm_resizable($w2tdmap_diff_menu,0,0);
    &adjust_window_position($w2tdmap_diff_menu);
    $w2tdmap_diff_menu->g_focus;
}


sub setup_w2_tdmap_filediff {
    my ($canv, $id, $X, $Y) = @_;
    my (
        $add, $ctype, $ctype_txt, $f, $flowtemp_file, $frame, $geom,
        $gstitle, $gtitle, $i, $jb, $jw, $mult, $n, $nbr, $ok_btn,
        $oldsrc_type, $parm, $parm_div, $parm_txt, $pmax, $pmax_entry,
        $pmin, $pmin_entry, $row, $src_btn, $src_file, $src_label1,
        $src_label2, $src_lines, $src_text, $src_type, $src_type_cb,
        $surftemp_file, $title, $tol, $tol_frame, $txt, $voltemp_file,
        $w2l_file, $xtra_label,

        @brs, @cpl_files, @cpl_lines, @ds, @fr, @frv, @frv_label, @frv_on,
        @rbtn, @riv_files, @riv_freq, @riv_lines, @seg_limits, @td_filetypes,
        @tecplot, @us, @wbs,
       );

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($w2tdmap_diff_menu) && Tkx::winfo_exists($w2tdmap_diff_menu)) {
        if ($w2tdmap_diff_menu->g_wm_title() eq "W2 Time/Distance Difference Setup") {
            $w2tdmap_diff_menu->g_destroy();
            undef $w2tdmap_diff_menu;
        }
    }
    $w2tdmap_diff_menu = $main->new_toplevel();
    $w2tdmap_diff_menu->g_wm_transient($main);
    $w2tdmap_diff_menu->g_wm_title("W2 Time/Distance Difference Setup");
    $w2tdmap_diff_menu->configure(-cursor => $cursor_norm);
    $w2tdmap_diff_menu->g_wm_geometry($geom);

#   Try to keep the graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");
    &end_select($canv, $id, 1);

#   Initialize some variables.
    $parm       = $props{$id}{parm_sav};
    $parm_div   = $props{$id}{pdiv_sav};
    $ctype      = $props{$id}{ctype};
    $src_type   = $props{$id}{src_type};
    $pmin       = $gr_props{$id}{cs_min};
    $pmax       = $gr_props{$id}{cs_max};
    $gstitle    = $gr_props{$id}{gstitle};
    @wbs        = split(/,/, $props{$id}{wb_list});

    @us         = @{ $grid{$id}{us} };
    @ds         = @{ $grid{$id}{ds} };
    $nbr        = $grid{$id}{nbr};
    @seg_limits = split(/,|-/, $props{$id}{seg_list});
    @brs        = ();
    for ($i=0; $i<=$#seg_limits; $i+=2) {
        for ($jb=1; $jb<=$nbr; $jb++) {
            last if ($seg_limits[$i] >= $us[$jb] && $seg_limits[$i] <= $ds[$jb]);
        }
        push (@brs, $jb);
    }
    @brs = sort numerically @brs;

    $tol         = 10;
    @cpl_files   = @cpl_lines = @tecplot = @riv_files = @riv_lines = ();
    $src_text    = $src_type . ": ";
    $src_file    = "";
    $src_lines   = 0;
    $oldsrc_type = $src_type;
    $w2l_file    = $surftemp_file = $voltemp_file = $flowtemp_file = "";

    if ($props{$id}{prof_stat} eq "Surface value") {
        @td_filetypes = ("W2 Contour File", "W2 Vector File", "W2 RiverCon File", "W2 SurfTemp File");
    } elsif ($props{$id}{prof_stat} eq "Volume-weighted") {
        @td_filetypes = ("W2 Contour File", "W2 Vector File", "W2 VolTemp File");
    } elsif ($props{$id}{prof_stat} eq "Flow-weighted") {
        @td_filetypes = ("W2 FlowTemp File");
        $src_type = "W2 FlowTemp File";
    }
    for ($n=0; $n<=$#wbs; $n++) {
        $cpl_files[$n] = "          ";
        $cpl_lines[$n] = 0;
    }
    $ctype_txt = $ctype;
    if ($ctype =~ /^Custom/i) {
        (undef, $mult, $add) = split(/,/, $ctype);
        $ctype_txt = "Custom (mult by $mult, add $add)";
    }

    if ($parm !~ /^(Temperature|TEMP|Tmin|Tmean|Tmax)$/) {
        $parm =~ s/\(ms-1\)//i;
        $parm =~ s/\(m3s-1\)//i;
        $parm =~ s/ [kmu]?g\/L\/day//i;
        $parm =~ s/ [kmu]?g\/m2\/day//i;
        $parm =~ s/ [kmu]?g\/m\^2\/day//i;
        $parm =~ s/ [kmu]?g\/L//i;
        $parm =~ s/ [kmu]?g\/m3//i;
        $parm =~ s/ [kmu]?g\/m\^3//i;
        $parm =~ s/, days//i;
        $parm =~ s/ days//i;
        $parm =~ s/,$//;
    }
    if ($parm_div ne "None" && $parm_div !~ /^(Temperature|TEMP|Tmin|Tmean|Tmax)$/) {
        $parm_div =~ s/\(ms-1\)//i;
        $parm_div =~ s/\(m3s-1\)//i;
        $parm_div =~ s/ [kmu]?g\/L\/day//i;
        $parm_div =~ s/ [kmu]?g\/m2\/day//i;
        $parm_div =~ s/ [kmu]?g\/m\^2\/day//i;
        $parm_div =~ s/ [kmu]?g\/L//i;
        $parm_div =~ s/ [kmu]?g\/m3//i;
        $parm_div =~ s/ [kmu]?g\/m\^3//i;
        $parm_div =~ s/, days//i;
        $parm_div =~ s/ days//i;
        $parm_div =~ s/,$//;
    }
    if ($props{$id}{pdiv_sav} ne "None") {
        $parm_txt = $parm . " / " . $parm_div;
    } else {
        $parm_txt = $parm;
    }
    if ($props{$id}{parm_units} =~ /^(Celsius|Fahrenheit)$/) {
        $parm_txt .= ", in degrees " . $props{$id}{parm_units};
    } else {
        $parm_txt .= ", in " . $props{$id}{parm_units};
    }
    if ($parm =~ /^(Temperature|TEMP|Tmin|Tmean|Tmax)$/) {
        if ($parm eq "TEMP") {
            $parm = "Temperature";
        } elsif ($parm eq "Tmin") {
            $parm = "Min Temperature";
        } elsif ($parm eq "Tmean") {
            $parm = "Mean Temperature";
        } elsif ($parm eq "Tmax") {
            $parm = "Max Temperature";
        }
    }
    if ($parm_div =~ /^(Temperature|TEMP|Tmin|Tmean|Tmax)$/) {
        if ($parm_div eq "TEMP") {
            $parm_div = "Temperature";
        } elsif ($parm_div eq "Tmin") {
            $parm_div = "Min Temperature";
        } elsif ($parm_div eq "Tmean") {
            $parm_div = "Mean Temperature";
        } elsif ($parm_div eq "Tmax") {
            $parm_div = "Max Temperature";
        }
    }
    if ($props{$id}{pdiv_sav} ne "None") {
        $gtitle = "Time/Distance Diff Map of $parm / $parm_div";
        $title  = "$parm / $parm_div Difference, in ";
    } else {
        $gtitle = "Time/Distance Diff Map of $parm";
        $title  = "$parm Difference, in ";
    }
    if ($props{$id}{parm_units} =~ /^(Celsius|Fahrenheit)$/) {
        $title .= "degrees " . $props{$id}{parm_units};
    } else {
        $title .= $props{$id}{parm_units};
    }

#   Build the menu.
    $frame = $w2tdmap_diff_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -command => sub { my ($br_list, $label, $n, $rfreq, @tmp_files, @tmp_lines, @vals, %parms);
                              %parms = ();
                              if ($pmin eq "" || $pmax eq "") {
                                  return &pop_up_error($w2tdmap_diff_menu,
                                  "Please provide both a min and max for your data.");
                              }
                              if ($pmin >= $pmax) {
                                  return &pop_up_error($w2tdmap_diff_menu,
                                  "The minimum data value must be less than the maximum data value.");
                              }
                              if ($src_type =~ /Contour/i) {
                                  for ($n=0; $n<=$#wbs; $n++) {
                                      if ($cpl_files[$n] eq "" || $cpl_files[$n] eq "          "
                                                               || ! -e $cpl_files[$n]) {
                                          return &pop_up_error($w2tdmap_diff_menu,
                                          "W2 Contour file not set or does not exist:\n$cpl_files[$n]");
                                      }
                                  }
                                  $props{$id}{tecplot2}   = [ @tecplot   ];
                                  $props{$id}{cpl_lines2} = [ @cpl_lines ];
                                  $props{$id}{cpl_files2} = [ @cpl_files ];

                              } elsif ($src_type =~ /RiverCon/i) {
                                  for ($n=0; $n<=$#riv_files; $n++) {
                                      next if (! $frv_on[$n]);
                                      if ($riv_files[$n] eq "" || $riv_files[$n] eq "          "
                                                               || ! -e $riv_files[$n]) {
                                          return &pop_up_error($w2tdmap_diff_menu,
                                          "W2 River Contour file not set or does not exist:\n$riv_files[$n]");
                                      }
                                  }
                                  if ($#brs > 0) {
                                      $rfreq = -99;
                                      for ($n=0; $n<=$#brs; $n++) {
                                          next if (! $frv_on[$n]);
                                          if ($rfreq == -99) {
                                              $rfreq = $riv_freq[$n];
                                              next;
                                          }
                                          if ($rfreq != $riv_freq[$n]) {
                                              return &pop_up_error($w2tdmap_diff_menu,
                                                  "The W2 RiverCon output frequencies for the\n"
                                                . "chosen branches do not match. Please try again.");
                                          }
                                      }
                                  }
                                  @tmp_files = @riv_files;
                                  @tmp_lines = @riv_lines;
                                  @riv_files = @riv_lines = ();
                                  $br_list   = "";
                                  for ($n=0; $n<=$#brs; $n++) {
                                      next if (! $frv_on[$n]);
                                      push (@riv_files, $tmp_files[$n]);
                                      push (@riv_lines, $tmp_lines[$n]);
                                      $label = $frv_label[$n];
                                      if ($label =~ /,/) {
                                          $label =~ s/Branch //;
                                          @vals  = split(/,/, $label);
                                          @vals  = sort numerically @vals;
                                          $br_list .= $vals[0] . ",";
                                      } else {
                                          $br_list .= $brs[$n] . ",";
                                      }
                                  }
                                  $br_list =~ s/,$//;
                                  $props{$id}{br_list2}   = $br_list;
                                  $props{$id}{riv_lines2} = [ @riv_lines ];
                                  $props{$id}{riv_files2} = [ @riv_files ];

                              } else {
                                  if ($src_file eq "" || ! -e $src_file) {
                                      return &pop_up_error($w2tdmap_diff_menu,
                                          $src_type . " not set or does not exist:\n$src_file");
                                  }
                                  if ($src_type =~ /SurfTemp|VolTemp|FlowTemp/i) {
                                      $props{$id}{src_file2}  = $src_file;
                                      $props{$id}{src_lines2} = $src_lines;
                                  } else {
                                      $props{$id}{w2l_file2}  = $src_file;
                                  }
                              }
                              $title   =~ s/^\s+//;
                              $title   =~ s/\s+$//;
                              $gtitle  =~ s/^\s+//;
                              $gtitle  =~ s/\s+$//;
                              $gstitle =~ s/^\s+//;
                              $gstitle =~ s/\s+$//;

                              $parms{pmin}       = $pmin;
                              $parms{pmax}       = $pmax;
                              $parms{title}      = $title;
                              $parms{gtitle}     = $gtitle;
                              $parms{gstitle}    = $gstitle;
                              $parms{change}     = "";
                              $props{$id}{parms} = { %parms };

                              $props{$id}{map_type}  = "filediff";
                              $props{$id}{src_type2} = $src_type;
                              $props{$id}{match_tol} = $tol;
                              $props{$id}{parm2}     = $props{$id}{parm_sav};
                              $props{$id}{parm2_sav} = $props{$id}{parm_sav};
                              $props{$id}{parm2_div} = $props{$id}{pdiv_sav};
                              $props{$id}{pdiv2_sav} = $props{$id}{pdiv_sav};
                              $props{$id}{ctype2}    = $props{$id}{ctype};
                              $props{$id}{data2}     = 0;

                              $w2tdmap_diff_menu->g_bind('<Destroy>', "");
                              $w2tdmap_diff_menu->g_destroy();
                              undef $w2tdmap_diff_menu;
                              &reset_bindings;

                              &make_w2_tdmap($canv, $id, 0);
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $w2tdmap_diff_menu->g_bind('<Destroy>', "");
                              $w2tdmap_diff_menu->g_destroy();
                              undef $w2tdmap_diff_menu;
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Do not delete graph if this menu is destroyed by other than the Cancel button
    $w2tdmap_diff_menu->g_bind('<Destroy>' => sub { undef $w2tdmap_diff_menu;
                                                    &reset_bindings;
                                                  });

    $f = $w2tdmap_diff_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "Difference requires a 2nd model run with an identical grid.",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew');
    $row++;
    $f->new_ttk__separator(
            -orient => 'horizontal',
            )->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew');
    $row++;
    $f->new_label(
            -text => "Parameter: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $f->new_label(
            -text => $parm_txt,
            -font => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $row++;
    $f->new_label(
            -text => "Conversion: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -text => $ctype_txt,
            -font => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $row++;
    $f->new_label(
            -text => "Profile Stat: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $f->new_label(
            -text => $props{$id}{prof_stat},
            -font => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');

    $row++;
    $f->new_label(
            -text   => "W2 Source Type: ",
            -font   => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    if ($#td_filetypes == 0) {
        $f->new_label(
                -text => $src_type,
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    } else {
        ($src_type_cb = $f->new_ttk__combobox(
                -textvariable => \$src_type,
                -values       => [ @td_filetypes ],
                -width        => 17,
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $src_type_cb->g_bind("<<ComboboxSelected>>",
                              sub { my ($n, $nb, $ok, $status);
                                    return if ($src_type eq $oldsrc_type);
                                    if ($src_type =~ /Contour/i) {
                                        $src_label1->g_grid_remove();
                                        $src_label2->g_grid_remove();
                                        $src_btn->g_grid_remove();
                                        for ($n=0; $n<=$#brs; $n++) {
                                            $frv[$n]->g_grid_remove();
                                        }
                                        for ($n=0; $n<=$#wbs; $n++) {
                                            $fr[$n]->g_grid();
                                        }
                                        $xtra_label->g_grid() if ($#wbs > 0);
                                        $ok = 1;
                                        for ($n=0; $n<=$#wbs; $n++) {
                                            if ($cpl_files[$n] eq "          " ||
                                                $cpl_files[$n] eq "" || ! -e $cpl_files[$n]) {
                                                $ok = 0;
                                                last;
                                            }
                                        }
                                    } elsif ($src_type =~ /RiverCon/i) {
                                        $src_label1->g_grid_remove();
                                        $src_label2->g_grid_remove();
                                        $src_btn->g_grid_remove();
                                        for ($n=0; $n<=$#wbs; $n++) {
                                            $fr[$n]->g_grid_remove();
                                        }
                                        $nb = 0;
                                        for ($n=0; $n<=$#brs; $n++) {
                                            if ($frv_on[$n]) {
                                                $frv[$n]->g_grid();
                                                $nb++;
                                            }
                                        }
                                        $xtra_label->g_grid() if ($nb > 1);
                                        $ok = 1;
                                        for ($n=0; $n<=$#brs; $n++) {
                                            next if (! $frv_on[$n]);
                                            if ($riv_files[$n] eq "          " ||
                                                $riv_files[$n] eq "" || ! -e $riv_files[$n]) {
                                                $ok = 0;
                                                last;
                                            }
                                        }
                                    } else {
                                        $xtra_label->g_grid_remove();
                                        for ($n=0; $n<=$#wbs; $n++) {
                                            $fr[$n]->g_grid_remove();
                                        }
                                        for ($n=0; $n<=$#brs; $n++) {
                                            $frv[$n]->g_grid_remove();
                                        }
                                        $src_label1->g_grid();
                                        $src_label2->g_grid();
                                        $src_btn->g_grid();
                                        if ($src_type =~ /SurfTemp/) {
                                            $src_file = $surftemp_file;
                                        } elsif ($src_type =~ /VolTemp/) {
                                            $src_file = $voltemp_file;
                                        } elsif ($src_type =~ /FlowTemp/) {
                                            $src_file = $flowtemp_file;
                                        } elsif ($src_type =~ /Vector/i) {
                                            $src_file = $w2l_file;
                                        }
                                        $ok = 1;
                                        $ok = 0 if ($src_file eq "" || ! -e $src_file);
                                    }
                                    $oldsrc_type = $src_type;
                                    $src_text    = $src_type . ": ";
                                    $status      = ($ok) ? 'normal' : 'disabled';
                                    $ok_btn->configure(-state => $status);
                                  });
    }

#   Input fields for W2 Vector, SurfTemp, VolTemp, or FlowTemp file
    $row++;
    ($src_label1 = $f->new_label(
            -textvariable => \$src_text,
            -font         => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($src_label2 = $f->new_label(
            -textvariable => \$src_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
    ($src_btn = $f->new_button(
            -text    => "Browse",
            -command =>
               sub { my ($file, $ftype, $ok, $parm_mismatch, $parms_ref, $pdiv_mismatch, $status,
                         @src_parms);
                     $status = 'disabled';
                     if ($src_type =~ /Vector/i) {
                         $file = Tkx::tk___getOpenFile(
                                 -parent    => $w2tdmap_diff_menu,
                                 -title     => "Select W2 Vector File",
                                 -filetypes => [ ['W2L (W2 Vector)', '.w2l'],
                                                 ['All Files', '*'],
                                               ],
                                 );
                         if (defined($file) && -e $file) {
                             $src_file = File::Spec->rel2abs($file);
                             $status_line = "Scanning W2 vector file...";  # no progress bar needed
                             Tkx::update_idletasks();
                             ($ok, $parms_ref, undef, undef, undef)
                                 = &scan_w2_vector_file($w2tdmap_diff_menu, $src_file, $id, 0);
                             $status_line = "";
                             if ($ok ne "okay") {
                                 $src_file = $w2l_file = "";
                                 $ok_btn->configure(-state => 'disabled');
                                 return &pop_up_error($w2tdmap_diff_menu,
                                              "The specified file is not a W2 Vector (w2l) file:\n$file");
                             }
                             @src_parms = @{ $parms_ref };
                             $w2l_file  = $src_file;
                             $status    = 'normal';
                         }
                     } else {
                         $file = Tkx::tk___getOpenFile(
                                 -parent    => $w2tdmap_diff_menu,
                                 -title     => "Select " . $src_type,
                                 -filetypes => [ ['All Files', '*'],
                                                 ['Custom W2 *Temp Files', '*Temp.dat'],
                                                 ['Custom W2 *Temp2 Files', '*Temp2.dat'],
                                               ],
                                 );
                         if (defined($file) && -e $file) {
                             $src_file = File::Spec->rel2abs($file);
                             $status_line = "Scanning " . $src_type . "...";
                             Tkx::update_idletasks();
                             ($ftype, $src_lines, @src_parms)
                                 = &determine_ts_type($w2tdmap_diff_menu, $src_file, 1);
                             $status_line = "";
                             if ($ftype !~ /^W2 .*aily .*Temp2?\.dat format$/
                                   || ($src_type =~ /SurfTemp/ && $ftype !~ /SurfTemp/)
                                   || ($src_type =~ /VolTemp/  && $ftype !~ /VolTemp/)
                                   || ($src_type =~ /FlowTemp/ && $ftype !~ /FlowTemp/)) {
                                 $src_file  = "";
                                 $src_lines = 0;
                                 if ($src_type =~ /SurfTemp/) {
                                     $surftemp_file = "";
                                 } elsif ($src_type =~ /VolTemp/) {
                                     $voltemp_file  = "";
                                 } elsif ($src_type =~ /FlowTemp/) {
                                     $flowtemp_file = "";
                                 }
                                 $ok_btn->configure(-state => 'disabled');
                                 return &pop_up_error($w2tdmap_diff_menu,
                                              "The specified file is not a " . $src_type . ":\n$file");
                             }
                             if ($src_type =~ /SurfTemp/) {
                                 $surftemp_file = $src_file;
                             } elsif ($src_type =~ /VolTemp/) {
                                 $voltemp_file = $src_file;
                             } elsif ($src_type =~ /FlowTemp/) {
                                 $flowtemp_file = $src_file;
                             }
                             $status = 'normal';
                         }
                     }
                     $parm_mismatch = 0;
                     if ($props{$id}{parm_sav} =~ /^(Temperature|TEMP|Tmean)$/i) {
                         $parm_mismatch = 1 if (&list_match("Temperature", @src_parms) == -1 &&
                                                &list_match("TEMP",        @src_parms) == -1 &&
                                                &list_match("Tmean",       @src_parms) == -1);
                     } elsif ($props{$id}{parm_sav} =~ /^(Dissolved ?Oxygen|DO)$/i) {
                         $parm_mismatch = 1 if (&list_match("Dissolved Oxygen", @src_parms) == -1 &&
                                                &list_match("DissolvedOxygen",  @src_parms) == -1 &&
                                                &list_match("DO",               @src_parms) == -1);
                     } elsif (&list_match($props{$id}{parm_sav}, @src_parms) == -1) {
                         $parm_mismatch = 1;
                     }
                     $pdiv_mismatch = 0;
                     if ($props{$id}{pdiv_sav} ne "None") {
                         if ($props{$id}{pdiv_sav} =~ /^(Temperature|TEMP|Tmean)$/i) {
                             $pdiv_mismatch = 1 if (&list_match("Temperature", @src_parms) == -1 &&
                                                    &list_match("TEMP",        @src_parms) == -1 &&
                                                    &list_match("Tmean",       @src_parms) == -1);
                         } elsif ($props{$id}{pdiv_sav} =~ /^(Dissolved ?Oxygen|DO)$/i) {
                             $pdiv_mismatch = 1 if (&list_match("Dissolved Oxygen", @src_parms) == -1 &&
                                                    &list_match("DissolvedOxygen",  @src_parms) == -1 &&
                                                    &list_match("DO",               @src_parms) == -1);
                         } elsif (&list_match($props{$id}{pdiv_sav}, @src_parms) == -1) {
                             $pdiv_mismatch = 1;
                         }
                     }
                     if ($parm_mismatch || $pdiv_mismatch) {
                         $src_file  = "";
                         $src_lines = 0;
                         if ($src_type =~ /Vector/i) {
                             $w2l_file = "";
                         } elsif ($src_type =~ /SurfTemp/) {
                             $surftemp_file = "";
                         } elsif ($src_type =~ /VolTemp/) {
                             $voltemp_file  = "";
                         } elsif ($src_type =~ /FlowTemp/) {
                             $flowtemp_file = "";
                         }
                         $ok_btn->configure(-state => 'disabled');
                         if ($parm_mismatch) {
                             return &pop_up_error($w2tdmap_diff_menu,
                                                  "The specified file does not contain\n"
                                                . "the parameter of interest ("
                                                . $props{$id}{parm_sav} . "):\n$file");
                         } else {
                             return &pop_up_error($w2tdmap_diff_menu,
                                                  "The specified file does not contain\n"
                                                . "the parameter divisor of interest ("
                                                . $props{$id}{pdiv_sav} . "):\n$file");
                         }
                     }
                     $ok_btn->configure(-state => $status);
                   },
            ))->g_grid(-row => $row, -column => 2, -sticky => 'ew', -padx => 2, -pady => 2);

#   Loop over the required branches for River Contour file inputs
    for ($n=0; $n<=$#brs; $n++) {
        $riv_files[$n] = "          ";
        $frv_on[$n]    = 1;
        $frv_label[$n] = "Branch " . $brs[$n];

        $row++;
        ($frv[$n] = $f->new_labelframe(
                -borderwidth => 1,
                -relief      => 'groove',
                -text        => $frv_label[$n],
                ))->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew', -pady => 2);

        $frv[$n]->new_label(
                -text => "W2 RiverCon File: ",
                -font => 'default',
                )->g_grid(-row => 0, -column => 0, -sticky => 'e', -pady => 2);
        $frv[$n]->new_label(
                -textvariable => \$riv_files[$n],
                -anchor       => 'w',
                -font         => 'default',
                -background   => 'white',
                -relief       => 'sunken',
                -borderwidth  => 1,
                )->g_grid(-row => 0, -column => 1, -sticky => 'ew', -pady => 2);
        ($rbtn[$n] = $frv[$n]->new_button(
                -text    => "Browse",
                -command =>
                 [ sub { my ($n) = @_;
                         my (
                             $file, $ftype, $j, $jb1, $jb2, $meta, $mismatch, $nlines,
                             $nn, $nsegs, $ok, $parm, $pbar, $pbar_img,
                             $pbar_win, $status, $txt,
                            );

                         $file = Tkx::tk___getOpenFile(
                                 -parent    => $w2tdmap_diff_menu,
                                 -title     => "Select W2 RiverCon Output File",
                                 -filetypes => [ ['W2 RiverCon files', 'RiverContour_*.csv'],
                                                 ['All Files', '*'],
                                               ],
                                 );
                         if (defined($file) && -e $file) {
                             $riv_files[$n] = File::Spec->rel2abs($file);
                             ($pbar_win, $pbar, $pbar_img)
                                 = &create_alt_progress_bar($main, $id,
                                                            "Scanning W2 River Contour file...");
                             ($ftype, $parm, $meta, $nlines)
                                 = &scan_w2_rlcon_file($w2tdmap_diff_menu, $riv_files[$n], $pbar_img);
                             &destroy_progress_bar($main, $pbar_win);

                             $mismatch = 0;
                             if ($parm eq "Temperature") {
                                 $mismatch = 1 if ($props{$id}{parm_sav} !~ /^(Temperature|TEMP|Tmean)$/i);
                             } elsif ($parm eq "Dissolved Oxygen") {
                                 $mismatch = 1 if ($props{$id}{parm_sav} !~ /^(Dissolved ?Oxygen|DO)$/i);
                             }
                             if ($ftype !~ /rcon/ || $mismatch) {
                                 $riv_files[$n] = "          ";
                                 while ($frv_label[$n] =~ /,\d+$/) {
                                     $frv_label[$n] =~ s/,(\d+)//;
                                     $nn = &list_match($1, @brs);
                                     $frv_on[$nn]    = 1;
                                     $frv_label[$nn] = "Branch " . $brs[$nn];
                                     $frv[$nn]->configure(-text => $frv_label[$nn]);
                                     $frv[$nn]->g_grid();
                                 }
                                 $frv[$n]->configure(-text => $frv_label[$n]);
                                 $ok_btn->configure(-state => 'disabled');
                                 if ($ftype !~ /rcon/) {
                                     return &pop_up_error($w2tdmap_diff_menu,
                                             "Specified file is not a W2 River Contour output file:\n$file");
                                 } elsif ($mismatch) {
                                     return &pop_up_error($w2tdmap_diff_menu,
                                                          "The specified file does not contain\n"
                                                        . "the parameter of interest ("
                                                        . $props{$id}{parm_sav} . "):\n$file");
                                 }
                             }
                             ($jb1, $nsegs, $riv_freq[$n]) = split(/_/, $meta);
                             $jb2 = $jb1;
                             for ($j=$jb1; $j<=$nbr; $j++) {
                                 last if ($nsegs <= $ds[$j] -$us[$j] +1);
                                 $jb2++;
                                 $nsegs -= $ds[$j] -$us[$j] +1;
                             }
                             if ($brs[$n] < $jb1 || $brs[$n] > $jb2) {
                                 $riv_files[$n] = "          ";
                                 while ($frv_label[$n] =~ /,\d+$/) {
                                     $frv_label[$n] =~ s/,(\d+)//;
                                     $nn = &list_match($1, @brs);
                                     $frv_on[$nn]    = 1;
                                     $frv_label[$nn] = "Branch " . $brs[$nn];
                                     $frv[$nn]->configure(-text => $frv_label[$nn]);
                                     $frv[$nn]->g_grid();
                                 }
                                 $frv[$n]->configure(-text => $frv_label[$n]);
                                 $ok_btn->configure(-state => 'disabled');
                                 $txt = ($jb2 == $jb1) ? $jb1 : $jb1 . "-" . $jb2;
                                 return &pop_up_error($w2tdmap_diff_menu,
                                           "The specified W2 River Contour file\n"
                                         . "does not include the correct branch:\n"
                                         . "(" . $txt . " rather than " . $brs[$n] . "):\n$file");
                             }
                             $frv_label[$n] = "Branch " . $brs[$n];
                             if ($jb2 > $jb1) {
                                 for ($j=$jb1; $j<=$jb2; $j++) {
                                     $nn = &list_match($j, @brs);
                                     if ($nn >= 0 && $brs[$nn] != $brs[$n]) {
                                         $frv_label[$n] .= "," . $brs[$nn];
                                         $frv_on[$nn]    = 0;
                                         $frv_label[$nn] = "Branch " . $brs[$nn];
                                         $frv[$nn]->configure(-text => $frv_label[$nn]);
                                         $frv[$nn]->g_grid_remove();
                                     }
                                 }
                                 $frv[$n]->configure(-text => $frv_label[$n]);
                             }
                             $riv_lines[$n] = $nlines;

                             $ok = 1;
                             for ($j=0; $j<=$#brs; $j++) {
                                 next if (! $frv_on[$j]);
                                 if ($riv_files[$j] eq "          " ||
                                     $riv_files[$j] eq "" || ! -e $riv_files[$j]) {
                                     $ok = 0;
                                     last;
                                 }
                             }
                             $status = ($ok) ? 'normal' : 'disabled';
                             $ok_btn->configure(-state => $status);
                         } else {
                             $ok_btn->configure(-state => 'disabled');
                         }
                       }, $n ],
                ))->g_grid(-row => 0, -column => 2, -sticky => 'ew', -padx => 2, -pady => 2);

        $frv[$n]->g_grid_columnconfigure(1, -weight => 2);
    }

#   Loop over the required waterbodies and set up inputs for contour files
    for ($n=0; $n<=$#wbs; $n++) {
        $jw = $wbs[$n];
        $cpl_files[$n] = "          ";

        $row++;
        ($fr[$n] = $f->new_labelframe(
                -borderwidth => 1,
                -relief      => 'groove',
                -text        => "Waterbody $jw",
                ))->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew', -pady => 2);

        $fr[$n]->new_label(
                -text => "W2 Contour File: ",
                -font => 'default',
                )->g_grid(-row => 0, -column => 0, -sticky => 'e', -pady => 2);
        $fr[$n]->new_label(
                -textvariable => \$cpl_files[$n],
                -anchor       => 'w',
                -font         => 'default',
                -background   => 'white',
                -relief       => 'sunken',
                -borderwidth  => 1,
                )->g_grid(-row => 0, -column => 1, -sticky => 'ew', -pady => 2);
        $fr[$n]->new_button(
                -text    => "Browse",
                -command =>
                 [ sub { my ($n) = @_;
                         my ($file, $i, $jw_src, $nlines, $ok, $parm_mismatch, $parms_ref, $pbar,
                             $pbar_img, $pbar_win, $pdiv_mismatch, $status, $tecplot, @parms,
                            );
                         $file = Tkx::tk___getOpenFile(
                                 -parent    => $w2tdmap_diff_menu,
                                 -title     => "Select W2 Contour Output File",
                                 -filetypes => [ ['All Files', '*'],
                                                 ['CSV (comma delimited)', '.csv'],
                                                 ['OPT (W2 output files)', '.opt'],
                                               ],
                                 );
                         if (defined($file) && -e $file) {
                             $cpl_files[$n] = File::Spec->rel2abs($file);
                             ($pbar_win, $pbar, $pbar_img)
                                 = &create_alt_progress_bar($main, $id, "Scanning W2 contour file...");
                             ($tecplot, $nlines, $jw_src, $parms_ref, undef, undef)
                                 = &scan_w2_cpl_file($w2tdmap_diff_menu, $cpl_files[$n], $id, 0, $pbar_img);
                             &destroy_progress_bar($main, $pbar_win);

                             if ($tecplot == -1) {
                                 $cpl_files[$n] = "          ";
                                 $ok_btn->configure(-state => 'disabled');
                                 return &pop_up_error($w2tdmap_diff_menu,
                                     "Specified file is not a W2 Contour output file:\n$file");
                             }
                             if ($tecplot == 0 && $jw_src != $wbs[$n]) {
                                 $cpl_files[$n] = "          ";
                                 $ok_btn->configure(-state => 'disabled');
                                 return &pop_up_error($w2tdmap_diff_menu,
                                         "The specified W2 Contour output file does not\n"
                                       . "appear to be from the correct waterbody:\n"
                                       . "(" . $jw_src . " rather than " . $wbs[$n] . "):\n$file");
                             }
                             @parms = @{ $parms_ref };

                             $parm_mismatch = 0;
                             if ($props{$id}{parm_sav} =~ /^(Temperature|TEMP|Tmean)$/i) {
                                 $parm_mismatch = 1 if (&list_match("Temperature", @parms) == -1 &&
                                                        &list_match("TEMP",        @parms) == -1 &&
                                                        &list_match("Tmean",       @parms) == -1);
                             } elsif ($props{$id}{parm_sav} =~ /^(Dissolved ?Oxygen|DO)$/i) {
                                 $parm_mismatch = 1 if (&list_match("Dissolved Oxygen", @parms) == -1 &&
                                                        &list_match("DissolvedOxygen",  @parms) == -1 &&
                                                        &list_match("DO",               @parms) == -1);
                             } elsif (&list_match($props{$id}{parm_sav}, @parms) == -1) {
                                 $parm_mismatch = 1;
                             }
                             $pdiv_mismatch = 0;
                             if ($props{$id}{pdiv_sav} ne "None") {
                                 if ($props{$id}{pdiv_sav} =~ /^(Temperature|TEMP|Tmean)$/i) {
                                     $pdiv_mismatch = 1 if (&list_match("Temperature", @parms) == -1 &&
                                                            &list_match("TEMP",        @parms) == -1 &&
                                                            &list_match("Tmean",       @parms) == -1);
                                 } elsif ($props{$id}{pdiv_sav} =~ /^(Dissolved ?Oxygen|DO)$/i) {
                                     $pdiv_mismatch = 1 if (&list_match("Dissolved Oxygen", @parms) == -1 &&
                                                            &list_match("DissolvedOxygen",  @parms) == -1 &&
                                                            &list_match("DO",               @parms) == -1);
                                 } elsif (&list_match($props{$id}{pdiv_sav}, @parms) == -1) {
                                     $pdiv_mismatch = 1;
                                 }
                             }
                             if ($parm_mismatch || $pdiv_mismatch) {
                                 $cpl_files[$n] = "          ";
                                 $cpl_lines[$n] = 0;
                                 $ok_btn->configure(-state => 'disabled');
                                 if ($parm_mismatch) {
                                     return &pop_up_error($w2tdmap_diff_menu,
                                                          "The specified file does not contain\n"
                                                        . "the parameter of interest ("
                                                        . $props{$id}{parm_sav} . "):\n$file");
                                 } else {
                                     return &pop_up_error($w2tdmap_diff_menu,
                                                          "The specified file does not contain\n"
                                                        . "the parameter divisor of interest ("
                                                        . $props{$id}{pdiv_sav} . "):\n$file");
                                 }
                             }
                             $tecplot[$n]   = $tecplot;
                             $cpl_lines[$n] = $nlines;

                             $ok = 1;
                             for ($i=0; $i<=$#wbs; $i++) {
                                 if ($cpl_files[$i] eq "          " ||
                                     $cpl_files[$i] eq "" || ! -e $cpl_files[$i]) {
                                     $ok = 0;
                                     last;
                                 }
                             }
                             $status = ($ok) ? 'normal' : 'disabled';
                             $ok_btn->configure(-state => $status);
                         } else {
                             $ok_btn->configure(-state => 'disabled');
                         }
                       }, $n ],
                )->g_grid(-row => 0, -column => 2, -sticky => 'ew', -padx => 2, -pady => 2);

        $fr[$n]->g_grid_columnconfigure(1, -weight => 2);
    }

    $row++;
    $f->new_label(
            -text => "Match Tolerance: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($tol_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $tol_frame->new_spinbox(
            -textvariable => \$tol,
            -state        => 'readonly',
            -font         => 'default',
            -from         => 0,
            -to           => 60,
            -increment    => 1,
            -width        => 3,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $tol_frame->new_label(
            -text => " minutes",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');

    $row++;
    $f->new_label(
            -text => "Color Key Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$title,
            -font         => 'default',
            -width        => 40,
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Data Min: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmin_entry = $f->new_entry(
            -textvariable => \$pmin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmin_entry ]);

    $row++;
    $f->new_label(
            -text => "Data Max: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmax_entry = $f->new_entry(
            -textvariable => \$pmax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmax_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmax_entry ]);

    $row++;
    $f->new_label(
            -text => "Graph Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gtitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Graph Subtitle: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gstitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);

    $row++;
    $txt = "Note that this program works best when each of the W2 output files\n"
         . "has the same output dates and output frequencies. In addition,\n"
         . "each is required to include data for the parameter being plotted.";
    ($xtra_label = $f->new_label(
            -text    => $txt,
            -font    => 'default',
            -justify => 'left',
            ))->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew', -pady => 2);
    $xtra_label->g_grid_remove();

    if ($src_type =~ /Contour/i) {
        $src_label1->g_grid_remove();
        $src_label2->g_grid_remove();
        $src_btn->g_grid_remove();
        for ($n=0; $n<=$#brs; $n++) {
            $frv[$n]->g_grid_remove();
        }
        $xtra_label->g_grid() if ($#wbs > 0);
    } elsif ($src_type =~ /RiverCon/i) {
        $src_label1->g_grid_remove();
        $src_label2->g_grid_remove();
        $src_btn->g_grid_remove();
        for ($n=0; $n<=$#wbs; $n++) {
            $fr[$n]->g_grid_remove();
        }
        $xtra_label->g_grid() if ($#brs > 1);
    } else {
        for ($n=0; $n<=$#wbs; $n++) {
            $fr[$n]->g_grid_remove();
        }
        for ($n=0; $n<=$#brs; $n++) {
            $frv[$n]->g_grid_remove();
        }
    }
    $f->g_grid_columnconfigure(1, -weight => 2);

    Tkx::wm_resizable($w2tdmap_diff_menu,0,0);
    &adjust_window_position($w2tdmap_diff_menu);
    $w2tdmap_diff_menu->g_focus;
}


sub undo_w2_tdmap_diffs {
    my ($canv, $id, $X, $Y) = @_;
    my (
        $f, $frame, $geom, $gstitle, $gtitle, $ok_btn, $parm_txt, $pmax,
        $pmax_entry, $pmin, $pmin_entry, $row, $title,
       );

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($w2tdmap_undo_menu) && Tkx::winfo_exists($w2tdmap_undo_menu)) {
        if ($w2tdmap_undo_menu->g_wm_title() eq "W2 Time/Distance Map - Undo Difference") {
            $w2tdmap_undo_menu->g_destroy();
            undef $w2tdmap_undo_menu;
        }
    }
    $w2tdmap_undo_menu = $main->new_toplevel();
    $w2tdmap_undo_menu->g_wm_transient($main);
    $w2tdmap_undo_menu->g_wm_title("W2 Time/Distance Map - Undo Difference");
    $w2tdmap_undo_menu->configure(-cursor => $cursor_norm);
    $w2tdmap_undo_menu->g_wm_geometry($geom);

#   Try to keep the graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");
    &end_select($canv, $id, 1);

#   Initialize some variables.
    $pmin    = $gr_props{$id}{cs_min};
    $pmax    = $gr_props{$id}{cs_max};
    $title   = $gr_props{$id}{keytitle};
    $gtitle  = $gr_props{$id}{gtitle};
    $gstitle = $gr_props{$id}{gstitle};
    $gtitle =~ s/Diff Map/Map/;
    $gtitle =~ s/minus .*$//;
    $gtitle =~ s/  / /;
    $title  =~ s/minus \w+//;
    $title  =~ s/  / /;
    $title  =~ s/Temperature Temperature/Temperature/;

    if ($props{$id}{pdiv_sav} ne "None") {
        $parm_txt = $props{$id}{parm_sav} . " / " . $props{$id}{pdiv_sav};
    } else {
        $parm_txt = $props{$id}{parm_sav};
    }
    if ($props{$id}{parm_units} =~ /^(Celsius|Fahrenheit)$/) {
        $parm_txt .= ", in degrees " . $props{$id}{parm_units};
    } else {
        $parm_txt .= ", in " . $props{$id}{parm_units};
    }

#   Build the menu.
    $frame = $w2tdmap_undo_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -command => sub { my (%parms);
                              %parms = ();
                              if ($pmin eq "" || $pmax eq "") {
                                  return &pop_up_error($w2tdmap_undo_menu,
                                  "Please provide both a min and max for your data.");
                              }
                              if ($pmin >= $pmax) {
                                  return &pop_up_error($w2tdmap_undo_menu,
                                  "The minimum data value must be less than the maximum data value.");
                              }
                              $title   =~ s/^\s+//;
                              $title   =~ s/\s+$//;
                              $gtitle  =~ s/^\s+//;
                              $gtitle  =~ s/\s+$//;
                              $gstitle =~ s/^\s+//;
                              $gstitle =~ s/\s+$//;

                              $parms{pmin}          = $pmin;
                              $parms{pmax}          = $pmax;
                              $parms{title}         = $title;
                              $parms{gtitle}        = $gtitle;
                              $parms{gstitle}       = $gstitle;
                              $parms{change}        = "";
                              $props{$id}{parms}    = { %parms };
                              $props{$id}{map_type} = "standard";
                              $props{$id}{data}     = 0;

                              $w2tdmap_undo_menu->g_bind('<Destroy>', "");
                              $w2tdmap_undo_menu->g_destroy();
                              undef $w2tdmap_undo_menu;
                              &reset_bindings;

                              &make_w2_tdmap($canv, $id, 0);
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $w2tdmap_undo_menu->g_bind('<Destroy>', "");
                              $w2tdmap_undo_menu->g_destroy();
                              undef $w2tdmap_undo_menu;
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Do not delete graph if this menu is destroyed by other than the Cancel button
    $w2tdmap_undo_menu->g_bind('<Destroy>' => sub { undef $w2tdmap_undo_menu;
                                                    &reset_bindings;
                                                  });

    $f = $w2tdmap_undo_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "Removing Parameter 2 and Parameter Difference.",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -columnspan => 2, -sticky => 'ew');
    $row++;
    $f->new_ttk__separator(
            -orient => 'horizontal',
            )->g_grid(-row => $row, -column => 0, -columnspan => 2, -sticky => 'ew');
    $row++;
    $f->new_label(
            -text => "Parameter: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $f->new_label(
            -text => $parm_txt,
            -font => 'default',
            )->g_grid(-row => $row, -column => 1, -sticky => 'w');
    $row++;
    $f->new_label(
            -text => "Profile Stat: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $f->new_label(
            -text => $props{$id}{prof_stat},
            -font => 'default',
            )->g_grid(-row => $row, -column => 1, -sticky => 'w');

    $row++;
    $f->new_label(
            -text => "Data Min: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmin_entry = $f->new_entry(
            -textvariable => \$pmin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmin_entry ]);

    $row++;
    $f->new_label(
            -text => "Data Max: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmax_entry = $f->new_entry(
            -textvariable => \$pmax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmax_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmax_entry ]);

    $row++;
    $f->new_label(
            -text => "Color Key Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$title,
            -font         => 'default',
            -width        => 45,
            )->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Graph Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gtitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Graph Subtitle: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gstitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);

    $f->g_grid_columnconfigure(1, -weight => 2);

    Tkx::wm_resizable($w2tdmap_undo_menu,0,0);
    &adjust_window_position($w2tdmap_undo_menu);
    $w2tdmap_undo_menu->g_focus;
}


sub reverse_w2_tdmap_diffs {
    my ($canv, $id, $X, $Y) = @_;
    my (
        $f, $frame, $geom, $gstitle, $gtitle, $ok_btn, $parm_txt, $parm2_txt,
        $pmax, $pmax_entry, $pmin, $pmin_entry, $row, $title, $txt,
       );

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($w2tdmap_rev_menu) && Tkx::winfo_exists($w2tdmap_rev_menu)) {
        if ($w2tdmap_rev_menu->g_wm_title() eq "W2 Time/Distance Map - Reverse Difference") {
            $w2tdmap_rev_menu->g_destroy();
            undef $w2tdmap_rev_menu;
        }
    }
    $w2tdmap_rev_menu = $main->new_toplevel();
    $w2tdmap_rev_menu->g_wm_transient($main);
    $w2tdmap_rev_menu->g_wm_title("W2 Time/Distance Map - Reverse Difference");
    $w2tdmap_rev_menu->configure(-cursor => $cursor_norm);
    $w2tdmap_rev_menu->g_wm_geometry($geom);

#   Try to keep the graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");
    &end_select($canv, $id, 1);

#   Initialize some variables.
    $pmin    = $gr_props{$id}{cs_max} * -1.0;
    $pmax    = $gr_props{$id}{cs_min} * -1.0;
    $title   = $gr_props{$id}{keytitle};
    $gtitle  = $gr_props{$id}{gtitle};
    $gstitle = $gr_props{$id}{gstitle};
    if ($title =~ /\w+ minus \w+/) {
        $title =~ s/(\w+) minus (\w+)/$2 minus $1/;
    }
    if ($gtitle =~ /\w+ minus \w+/) {
        $gtitle =~ s/(\w+) minus (\w+)/$2 minus $1/;
    }
    if ($gstitle =~ /\w+ minus \w+/) {
        $gstitle =~ s/(\w+) minus (\w+)/$2 minus $1/;
    }

    if ($props{$id}{pdiv_sav} ne "None") {
        $parm_txt = $props{$id}{parm_sav} . " / " . $props{$id}{pdiv_sav};
    } else {
        $parm_txt = $props{$id}{parm_sav};
    }
    if ($props{$id}{map_type} eq "parmdiff") {
        if ($props{$id}{pdiv2_sav} ne "None") {
            $parm2_txt = $props{$id}{parm2_sav} . " / " . $props{$id}{pdiv2_sav};
        } else {
            $parm2_txt = $props{$id}{parm2_sav};
        }
        if ($props{$id}{swap_order}) {
            $parm_txt = $parm_txt . " minus " . $parm2_txt;
        } else {
            $parm_txt = $parm2_txt . " minus " . $parm_txt;
        }
    }

#   Build the menu.
    $frame = $w2tdmap_rev_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -command => sub { my ( %parms);
                              %parms = ();
                              if ($pmin eq "" || $pmax eq "") {
                                  return &pop_up_error($w2tdmap_rev_menu,
                                  "Please provide both a min and max for your data.");
                              }
                              if ($pmin >= $pmax) {
                                  return &pop_up_error($w2tdmap_rev_menu,
                                  "The minimum data value must be less than the maximum data value.");
                              }
                              $title   =~ s/^\s+//;
                              $title   =~ s/\s+$//;
                              $gtitle  =~ s/^\s+//;
                              $gtitle  =~ s/\s+$//;
                              $gstitle =~ s/^\s+//;
                              $gstitle =~ s/\s+$//;

                              $parms{pmin}            = $pmin;
                              $parms{pmax}            = $pmax;
                              $parms{title}           = $title;
                              $parms{gtitle}          = $gtitle;
                              $parms{gstitle}         = $gstitle;
                              $parms{change}          = "";
                              $props{$id}{parms}      = { %parms };
                              $props{$id}{data}       = 0;
                              $props{$id}{data2}      = 0;
                              $props{$id}{swap_order} = ($props{$id}{swap_order}) ? 0 : 1;

                              $w2tdmap_rev_menu->g_bind('<Destroy>', "");
                              $w2tdmap_rev_menu->g_destroy();
                              undef $w2tdmap_rev_menu;
                              &reset_bindings;

                              &make_w2_tdmap($canv, $id, 0);
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $w2tdmap_rev_menu->g_bind('<Destroy>', "");
                              $w2tdmap_rev_menu->g_destroy();
                              undef $w2tdmap_rev_menu;
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Do not delete graph if this menu is destroyed by other than the Cancel button
    $w2tdmap_rev_menu->g_bind('<Destroy>' => sub { undef $w2tdmap_rev_menu;
                                                   &reset_bindings;
                                                 });

    $f = $w2tdmap_rev_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "Swapping the Parameter Difference Order.",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -columnspan => 2, -sticky => 'ew');
    $row++;
    $f->new_ttk__separator(
            -orient => 'horizontal',
            )->g_grid(-row => $row, -column => 0, -columnspan => 2, -sticky => 'ew');
    $row++;
    if ($props{$id}{map_type} eq "parmdiff") {
        $txt = "Difference: ";
    } else {
        $txt = "Parameter: ";
    }
    $f->new_label(
            -text => $txt,
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $f->new_label(
            -text => $parm_txt,
            -font => 'default',
            )->g_grid(-row => $row, -column => 1, -sticky => 'w');
    $row++;
    $f->new_label(
            -text => "Units: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $f->new_label(
            -text => $props{$id}{parm_units},
            -font => 'default',
            )->g_grid(-row => $row, -column => 1, -sticky => 'w');
    $row++;
    $f->new_label(
            -text => "Profile Stat: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $f->new_label(
            -text => $props{$id}{prof_stat},
            -font => 'default',
            )->g_grid(-row => $row, -column => 1, -sticky => 'w');

    $row++;
    $f->new_label(
            -text => "Data Min: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmin_entry = $f->new_entry(
            -textvariable => \$pmin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmin_entry ]);

    $row++;
    $f->new_label(
            -text => "Data Max: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmax_entry = $f->new_entry(
            -textvariable => \$pmax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmax_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmax_entry ]);

    $row++;
    $f->new_label(
            -text => "Color Key Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$title,
            -font         => 'default',
            -width        => 45,
            )->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Graph Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gtitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Graph Subtitle: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gstitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);

    $f->g_grid_columnconfigure(1, -weight => 2);

    Tkx::wm_resizable($w2tdmap_rev_menu,0,0);
    &adjust_window_position($w2tdmap_rev_menu);
    $w2tdmap_rev_menu->g_focus;
}


sub change_w2_tdmap {
    my ($canv, $id, $X, $Y, $change) = @_;
    my (
        $byear, $byear_cb, $conv_add, $conv_add_entry, $conv_mult,
        $conv_mult_entry, $conv_type, $conv_type_cb, $conv_type_na_label,
        $custom_frame, $f, $frame, $ftype, $geom, $gstitle, $gtitle, $i,
        $jd_skip, $jd_skip_active, $jd_skip_explain, $jd_skip_frame, $jw,
        $n, $ntsr, $offset_frame, $ok, $ok_btn, $old_units, $oldparm,
        $oldparm_short, $p, $parm, $parm_cb, $parm_chars, $parm_div,
        $parm_div_cb, $parm_div_label, $parm_frame, $parm_short, $parm2,
        $parms_ref, $pmax, $pmax_entry, $pmin, $pmin_entry, $prof_stat,
        $row, $src_type, $tecplot, $title, $tz_offset, $units, $units_cb,
        $units_entry, $yr_max, $yr_min,

        @cpl_files, @cplf, @jd_skip_opts, @ncpl, @nvpl, @parm_divlist,
        @parm_tmp, @parmlist, @parmlist4div, @parms, @tsrf, @vplf, @wbs,
       );

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($w2tdmap_mod_menu) && Tkx::winfo_exists($w2tdmap_mod_menu)) {
        if ($w2tdmap_mod_menu->g_wm_title() eq "Modify W2 Time/Distance Map") {
            $w2tdmap_mod_menu->g_destroy();
            undef $w2tdmap_mod_menu;
        }
    }
    $w2tdmap_mod_menu = $main->new_toplevel();
    $w2tdmap_mod_menu->g_wm_transient($main);
    $w2tdmap_mod_menu->g_wm_title("Modify W2 Time/Distance Map");
    $w2tdmap_mod_menu->configure(-cursor => $cursor_norm);
    $w2tdmap_mod_menu->g_wm_geometry($geom);

#   Try to keep the graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

#   De-select graph if it already exists
    if (defined($props{$id}{oldcoords})) {
        &end_select($canv, $id, 1);
    }

#   Initialize some variables.
    @ncpl      = @{ $grid{$id}{ncpl} };
    @cplf      = @{ $grid{$id}{cplf} };
    @nvpl      = @{ $grid{$id}{nvpl} };
    @vplf      = @{ $grid{$id}{vplf} };
    $ntsr      = $grid{$id}{ntsr};
    @tsrf      = @{ $grid{$id}{tsrf} };

    $src_type  = $props{$id}{src_type};
    $parm      = $props{$id}{parm_sav};
    $parm_div  = $props{$id}{pdiv_sav};
    $prof_stat = $props{$id}{prof_stat};
    $units     = $props{$id}{parm_units};
    $conv_type = $props{$id}{ctype};
    $byear     = $props{$id}{byear};
    $tz_offset = $props{$id}{tz_offset};
    $jd_skip   = $props{$id}{jd_skip};
    @wbs       = split(/,/, $props{$id}{wb_list});

    $pmin      = $gr_props{$id}{cs_min};
    $pmax      = $gr_props{$id}{cs_max};
    $title     = $gr_props{$id}{keytitle};
    $gtitle    = $gr_props{$id}{gtitle};
    $gstitle   = $gr_props{$id}{gstitle};

    if ($conv_type =~ /^Custom/i) {
        ($conv_type, $conv_mult, $conv_add) = split(/,/, $conv_type);
    } else {
        $conv_mult = 1.0;
        $conv_add  = 0.0;
    }
    $yr_max = (localtime(time))[5] +1900;
    $yr_min = ($byear > $yr_max -25) ? $yr_max -25 : $byear -5;

    if ($src_type =~ /Contour/i) {
        @cpl_files = @{ $props{$id}{cpl_files} };
        for ($n=0; $n<=$#wbs; $n++) {
            ($tecplot, undef, undef, $parms_ref, undef, undef)
                  = &scan_w2_cpl_file($w2tdmap_mod_menu, $cpl_files[$n], $id, 0, "");
            if ($tecplot == -1) {
                return &pop_up_error($w2tdmap_mod_menu,
                                     "The source file is not a W2 Contour file:\n$cpl_files[$n]");
            }
            @parms = @{ $parms_ref };
            if ($n == 0) {
                @parmlist = @parms;
            } else {                # only keep parameters common to all cpl files
                @parm_tmp = ();
                foreach $p ( @parms ) {
                    if (&list_match($p, @parmlist) >= 0) {
                        push (@parm_tmp, $p);
                    }
                }
                @parmlist = @parm_tmp;
            }
        }
    } elsif ($src_type =~ /Vector/i) {
        ($ok, $parms_ref, undef, undef, undef)
                  = &scan_w2_vector_file($w2tdmap_mod_menu, $props{$id}{w2l_file}, $id, 0);
        if ($ok ne "okay") {
            return &pop_up_error($w2tdmap_mod_menu,
                                 "The source file is not a W2 Vector (w2l) file:\n$props{$id}{w2l_file}");
        }
        @parmlist = @{ $parms_ref };
    } elsif ($src_type =~ /SurfTemp|VolTemp|FlowTemp/i) {
        ($ftype, undef, @parmlist) = &determine_ts_type($w2tdmap_mod_menu, $props{$id}{src_file}, 1);
    }
    @parmlist4div = @parmlist;
    if ($props{$id}{map_type} eq "parmdiff") {
        @parm_tmp = @parmlist;
        @parmlist = ();
        for ($i=0; $i<=$#parm_tmp; $i++) {
            if ($parm_tmp[$i] ne $props{$id}{parm2_sav}) {
                push (@parmlist, $parm_tmp[$i]);
            }
        }
        if ($#parmlist <= 0) {
            $w2tdmap_mod_menu->g_destroy();
            undef $w2tdmap_mod_menu;
            &reset_bindings;
            return &pop_up_error($main, "Insufficient parameters to modify parameter difference. Aborting.");
        }
        $parm2 = $props{$id}{parm2_sav};
        if ($parm2 =~ /^(Temperature|TEMP|Tmin|Tmean|Tmax)$/) {
            if ($parm2 eq "TEMP") {
                $parm2 = "Temperature";
            } elsif ($parm2 eq "Tmax") {
                $parm2 = "Max Temperature";
            } elsif ($parm2 eq "Tmean") {
                $parm2 = "Mean Temperature";
            } elsif ($parm2 eq "Tmin") {
                $parm2 = "Min Temperature";
            }
        } else {
            $parm2 =~ s/\(ms-1\)//i;
            $parm2 =~ s/\(m3s-1\)//i;
            $parm2 =~ s/ [kmu]?g\/L\/day//i;
            $parm2 =~ s/ [kmu]?g\/m2\/day//i;
            $parm2 =~ s/ [kmu]?g\/m\^2\/day//i;
            $parm2 =~ s/ [kmu]?g\/L//i;
            $parm2 =~ s/ [kmu]?g\/m3//i;
            $parm2 =~ s/ [kmu]?g\/m\^3//i;
            $parm2 =~ s/, days//i;
            $parm2 =~ s/ days//i;
            $parm2 =~ s/,$//;
        }
    }

    $jd_skip_active = 0;
    @jd_skip_opts = ("(keep all)", "(keep every other)", "(keep every 3rd)", "(keep every 4th)",
                     "(keep every 5th)",  "(keep every 6th)",  "(keep every 7th)",  "(keep every 8th)",
                     "(keep every 9th)",  "(keep every 10th)", "(keep every 11th)", "(keep every 12th)",
                     "(keep every 13th)", "(keep every 14th)", "(keep every 15th)", "(keep every 16th)",
                     "(keep every 17th)", "(keep every 18th)", "(keep every 19th)", "(keep every 20th)",
                     "(keep every 21st)", "(keep every 22nd)", "(keep every 23rd)", "(keep every 24th)",
                     "(keep every 25th)", "(keep every 26th)", "(keep every 27th)", "(keep every 28th)",
                     "(keep every 29th)", "(keep every 30th)", "(keep every 31st)", "(keep every 32nd)",
                     "(keep every 33rd)", "(keep every 34th)", "(keep every 35st)", "(keep every 36th)",
                     "(keep every 37th)", "(keep every 38th)", "(keep every 39th)", "(keep every 40th)",
                     "(keep every 41st)", "(keep every 42nd)", "(keep every 43rd)", "(keep every 44th)",
                     "(keep every 45th)", "(keep every 46th)", "(keep every 47th)", "(keep every 48th)",
                     "(keep every 49th)", "(keep every 50th)");
    if ($src_type =~ /Contour|Vector/i) {
        for ($n=0; $n<=$#wbs; $n++) {
            $jw = $wbs[$n];
            if ($src_type =~ /Contour/i) {
                for ($i=1; $i<=$ncpl[$jw]; $i++) {
                    if ($cplf[$i][$jw] < 1.0) {
                        $jd_skip_active = 1;
                        last;
                    }
                }
            } elsif ($src_type =~ /Vector/i) {
                for ($i=1; $i<=$nvpl[$jw]; $i++) {
                    if ($vplf[$i][$jw] < 1.0) {
                        $jd_skip_active = 1;
                        last;
                    }
                }
            }
            last if ($jd_skip_active);
        }
    } elsif ($src_type =~ /SurfTemp|VolTemp|FlowTemp/i) {
        if ($ftype =~ /^W2 .*daily .*Temp2\.dat format$/i) {
            for ($i=1; $i<=$ntsr; $i++) {
                if ($tsrf[$i] < 1.0) {
                    $jd_skip_active = 1;
                    last;
                }
            }
        }
    }
    $jd_skip = 0 if ($jd_skip < 0 || $jd_skip > 49);
    $jd_skip_explain = $jd_skip_opts[$jd_skip];
    undef @ncpl;
    undef @cplf;
    undef @nvpl;
    undef @vplf;
    undef @wbs;
    undef @tsrf;

    $parm_chars = length($parmlist[0]);
    for ($i=1; $i<=$#parmlist; $i++) {
        $parm_chars = &max($parm_chars, length($parmlist[$i]));
    }
    $parm_chars += 2;
    $parm_short = $parm;
    if ($props{$id}{parm} ne "Temperature") {
        $parm_short =~ s/\(ms-1\)//i;
        $parm_short =~ s/\(m3s-1\)//i;
        $parm_short =~ s/ [kmu]?g\/L\/day//i;
        $parm_short =~ s/ [kmu]?g\/m2\/day//i;
        $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
        $parm_short =~ s/ [kmu]?g\/L//i;
        $parm_short =~ s/ [kmu]?g\/m3//i;
        $parm_short =~ s/ [kmu]?g\/m\^3//i;
        $parm_short =~ s/, days//i;
        $parm_short =~ s/ days//i;
        $parm_short =~ s/,$//;
    }
    $old_units     = $units;
    $oldparm       = $parm;
    $oldparm_short = $parm_short;
    @parm_divlist  = ("None");
    for ($i=0; $i<=$#parmlist4div; $i++) {
        next if ($parmlist4div[$i] eq "Horizontal Velocity"
                  || $parmlist4div[$i] eq "Vertical Velocity"
                  || $parmlist4div[$i] eq "Density"
                  || $parmlist4div[$i] eq "Habitat");
        if ($parm ne $parmlist4div[$i]) {
            push (@parm_divlist, $parmlist4div[$i]);
        }
    }
    $parm_div = "None" if (&list_match($parm_div, @parm_divlist) == -1);

#   Build the menu.
    $frame = $w2tdmap_mod_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -command => sub { my ($modified, @cpl_files2, @parmlist2, @parms2, %parms);
                              $modified = 0;
                              %parms = ();
                              if ($change eq "misc") {
                                  $modified = 1 if ($byear     != $props{$id}{byear} ||
                                                    $tz_offset ne $props{$id}{tz_offset} ||
                                                    $jd_skip   != $props{$id}{jd_skip});
                              }
                              if ($change =~ /parm|misc/) {
                                  if ($pmin eq "" || $pmax eq "") {
                                      return &pop_up_error($w2tdmap_mod_menu,
                                      "Please provide both a min and max for your parameter.");
                                  }
                                  if ($pmin >= $pmax) {
                                      return &pop_up_error($w2tdmap_mod_menu,
                                      "The minimum data value must be less than the maximum data value.");
                                  }
                                  if ($conv_type eq "Custom") {
                                      $conv_type = sprintf("Custom,%s,%s", $conv_mult, $conv_add);
                                  }
                                  $gtitle  =~ s/^\s+//;
                                  $gtitle  =~ s/\s+$//;
                                  $gstitle =~ s/^\s+//;
                                  $gstitle =~ s/\s+$//;
                                  if ($parm ne $props{$id}{parm_sav} || $parm_div ne $props{$id}{pdiv_sav}
                                       || ($parm !~ /^(Temperature|Tmax|Tmean|Tmin|TEMP)$/
                                             && $units ne $props{$id}{parm_units})
                                       || $prof_stat ne $props{$id}{prof_stat}
                                       || $conv_type ne $props{$id}{ctype}) {
                                      $modified = 1;
                                  }
                                  if (! $modified) {
                                      if ($parm =~ /^(Temperature|Tmax|Tmean|Tmin|TEMP)$/
                                                  && $parm eq $props{$id}{parm_sav}
                                                  && $units ne $props{$id}{parm_units}) {
                                          return &pop_up_error($w2tdmap_mod_menu,
                                                               "To modify just the temperature units,\n"
                                                             . "use the Graph Properties menu.");
                                      } elsif ($pmin != $gr_props{$id}{cs_min}
                                                  || $pmax != $gr_props{$id}{cs_max}) {
                                          return &pop_up_error($w2tdmap_mod_menu,
                                                               "To modify just the parameter limits,\n"
                                                             . "use the Graph Properties menu.");
                                      } elsif ($gtitle ne $gr_props{$id}{gtitle}
                                                  || $gstitle ne $gr_props{$id}{gstitle}) {
                                          return &pop_up_error($w2tdmap_mod_menu,
                                                               "To modify just the graph titles,\n"
                                                             . "use the Graph Properties menu.");
                                      }
                                  }
                              }
                              if (! $modified) {
                                  $w2tdmap_mod_menu->g_bind('<Destroy>', "");
                                  $w2tdmap_mod_menu->g_destroy();
                                  undef $w2tdmap_mod_menu;
                                  &reset_bindings;
                                  return;
                              }

#                             Check consistency of parameters if this is a difference plot
                              if ($props{$id}{map_type} eq "filediff") {     # same parameter
                                  if ($props{$id}{src_type2} =~ /Contour/i) {
                                      @cpl_files2 = @{ $props{$id}{cpl_files2} };
                                      for ($n=0; $n<=$#wbs; $n++) {
                                          (undef, undef, undef, $parms_ref, undef, undef)
                                                = &scan_w2_cpl_file($w2tdmap_mod_menu,
                                                                    $cpl_files2[$n], $id, 0, "");
                                          @parms2 = @{ $parms_ref };
                                          if ($n == 0) {
                                              @parmlist2 = @parms2;
                                          } else {
                                              @parm_tmp = ();
                                              foreach $p ( @parms2 ) {
                                                  if (&list_match($p, @parmlist2) >= 0) {
                                                      push (@parm_tmp, $p);
                                                  }
                                              }
                                              @parmlist2 = @parm_tmp;
                                          }
                                      }
                                  } elsif ($props{$id}{src_type2} =~ /Vector/i) {
                                      (undef, $parms_ref, undef, undef, undef)
                                            = &scan_w2_vector_file($w2tdmap_mod_menu,
                                                                   $props{$id}{w2l_file2}, $id, 0);
                                      @parmlist2 = @{ $parms_ref };
                                  } elsif ($props{$id}{src_type2} =~ /SurfTemp|VolTemp|FlowTemp/i) {
                                      (undef, undef, @parmlist2)
                                            = &determine_ts_type($w2tdmap_mod_menu,
                                                                 $props{$id}{src_file2}, 1);
                                  }
                                  if (&list_match($parm, @parmlist2) == -1) {
                                      return &pop_up_error($w2tdmap_mod_menu,
                                                           "The chosen parameter (" . $parm . ")\n"
                                                         . "is not present in the source file\n"
                                                         . "for the parameter difference.");
                                  }
                                  if ($parm_div ne "None") {
                                      if (&list_match($parm_div, @parmlist2) == -1) {
                                          return &pop_up_error($w2tdmap_mod_menu,
                                                               "The chosen parameter divisor ("
                                                             . $parm_div . ")\n"
                                                             . "is not present in the source file\n"
                                                             . "for the parameter difference.");
                                      }
                                  }
                              }

#                             Reset the min/max dates if different jd_skip or byear
                              $parms{rebuild}    = ($byear     != $props{$id}{byear} ||
                                                    $tz_offset ne $props{$id}{tz_offset} ||
                                                    $jd_skip   != $props{$id}{jd_skip}) ? 1 : 0;
                              $parms{pmin}       = $pmin;
                              $parms{pmax}       = $pmax;
                              $parms{gtitle}     = $gtitle;
                              $parms{gstitle}    = $gstitle;
                              $parms{change}     = $change;
                              $props{$id}{parms} = { %parms };

                              $props{$id}{data}       = 0;
                              $props{$id}{parm}       = $parm;
                              $props{$id}{parm_sav}   = $parm;
                              $props{$id}{parm_div}   = $parm_div;
                              $props{$id}{pdiv_sav}   = $parm_div;
                              $props{$id}{prof_stat}  = $prof_stat;
                              $props{$id}{parm_units} = $units;
                              $props{$id}{ctype}      = $conv_type;
                              $props{$id}{byear}      = $byear;
                              $props{$id}{tz_offset}  = $tz_offset;
                              $props{$id}{jd_skip}    = $jd_skip;

                              if ($props{$id}{map_type} eq "filediff") {
                                  $props{$id}{parm2}     = $parm;
                                  $props{$id}{parm2_sav} = $parm;
                                  $props{$id}{parm2_div} = $parm_div;
                                  $props{$id}{pdiv2_sav} = $parm_div;
                                  $props{$id}{ctype2}    = $conv_type;
                              }
                              if ($props{$id}{map_type} =~ /^(parmdiff|filediff)$/) {
                                  $props{$id}{data2} = 0;
                              }

                              $w2tdmap_mod_menu->g_bind('<Destroy>', "");
                              $w2tdmap_mod_menu->g_destroy();
                              undef $w2tdmap_mod_menu;
                              &reset_bindings;
                              &make_w2_tdmap($canv, $id, 0);
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $w2tdmap_mod_menu->g_bind('<Destroy>', "");
                              $w2tdmap_mod_menu->g_destroy();
                              undef $w2tdmap_mod_menu;
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Do not delete graph if this menu is destroyed by other than the Cancel button
    $w2tdmap_mod_menu->g_bind('<Destroy>' => sub { undef $w2tdmap_mod_menu;
                                                   &reset_bindings;
                                                 });

    $f = $w2tdmap_mod_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "Parameter: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($parm_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    ($parm_cb = $parm_frame->new_ttk__combobox(
            -textvariable => \$parm,
            -values       => [ @parmlist ],
            -state        => 'readonly',
            -width        => $parm_chars,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $parm_cb->g_bind("<<ComboboxSelected>>",
                         sub { my ($i);
                               return if ($parm eq $oldparm);
                               $parm_short = $parm;
                               if ($parm eq "Temperature" || $parm =~ /^(Tmax|Tmean|Tmin|TEMP)$/) {
                                   $units = "Celsius" if ($units !~ /(Celsius|Fahrenheit)/);
                                   if ($parm eq "Temperature" || $parm eq "TEMP") {
                                       $title = "Temperature";
                                   } elsif ($parm eq "Tmax") {
                                       $title = "Max Temperature";
                                   } elsif ($parm eq "Tmean") {
                                       $title = "Mean Temperature";
                                   } elsif ($parm eq "Tmin") {
                                       $title = "Min Temperature";
                                   }
                                   if ($props{$id}{map_type} eq "parmdiff") {
                                       $title .= " minus " . $parm2;
                                   }
                                   $title .= ", in degrees " . $units;
                                   $units_cb->g_grid();
                                   $units_entry->g_grid_remove();
                                   $conv_type_na_label->g_grid();
                                   $custom_frame->g_grid_remove();
                                   $conv_type_cb->g_grid_remove();
                                   $conv_type = "None";
                               } else {
                                   $units = "";
                                   $parm_short =~ s/\(ms-1\)//i;
                                   $parm_short =~ s/\(m3s-1\)//i;
                                   $parm_short =~ s/ [kmu]?g\/L\/day//i;
                                   $parm_short =~ s/ [kmu]?g\/m2\/day//i;
                                   $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
                                   $parm_short =~ s/ [kmu]?g\/L//i;
                                   $parm_short =~ s/ [kmu]?g\/m3//i;
                                   $parm_short =~ s/ [kmu]?g\/m\^3//i;
                                   $parm_short =~ s/, days//i;
                                   $parm_short =~ s/ days//i;
                                   $parm_short =~ s/,$//;
                                   $title = $parm_short;
                                   if ($props{$id}{map_type} eq "parmdiff") {
                                       $title .= " minus " . $parm2;
                                   }
                                   if ($parm eq "Horizontal Velocity" || $parm eq "Vertical Velocity") {
                                       $units  = "m/s";
                                       $title .= ", in m/s";
                                   } elsif ($parm eq "Density") {
                                       $units  = "kg/m3";
                                       $title .= ", in kg/m3";
                                   } else {
                                       $title .= ", in ";
                                   }
                                   $units_cb->g_grid_remove();
                                   $units_entry->g_grid();
                                   $conv_type_na_label->g_grid_remove();
                                   $custom_frame->g_grid() if ($conv_type eq "Custom");
                                   $conv_type_cb->g_grid();
                               }
                               if ($gtitle eq "") {
                                   if ($props{$id}{map_type} eq "parmdiff") {
                                       $gtitle = "Time/Distance Diff Map of $parm_short minus " . $parm2;
                                   } elsif ($props{$id}{map_type} eq "filediff") {
                                       $gtitle = "Time/Distance Diff Map of $parm_short";
                                   } else {
                                       $gtitle = "Time/Distance Map of $parm_short";
                                   }
                               } else {
                                   if (index(lc($gtitle), lc($oldparm_short)) > -1) {
                                       $gtitle =~ s/$oldparm_short/$parm_short/i;
                                   }
                               }
                               $old_units     = $units;
                               $oldparm       = $parm;
                               $oldparm_short = $parm_short;
                               @parm_divlist  = ("None");
                               for ($i=0; $i<=$#parmlist4div; $i++) {
                                   next if ($parmlist4div[$i] eq "Horizontal Velocity"
                                            || $parmlist4div[$i] eq "Vertical Velocity"
                                            || $parmlist4div[$i] eq "Density"
                                            || $parmlist4div[$i] eq "Habitat");
                                   if ($parm ne $parmlist4div[$i]) {
                                       push (@parm_divlist, $parmlist4div[$i]);
                                   }
                               }
                               $parm_div_cb->configure(-values => [ @parm_divlist ]);
                               if (&list_match($parm_div, @parm_divlist) == -1) {
                                   $parm_div = "None";
                               }
                               if ($parm =~ /^(Temperature|TEMP)$/ || $parm eq "Horizontal Velocity"
                                       || $parm eq "Vertical Velocity" || $parm eq "Density"
                                       || $parm eq "Habitat" || $#parm_divlist == 0) {
                                   $parm_div_label->g_pack_forget();
                                   $parm_div_cb->g_pack_forget();
                                   $parm_div = "None";
                               } else {
                                   $parm_div_label->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                                   $parm_div_cb->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                               }
                             });
    ($parm_div_label = $parm_frame->new_label(
            -text => " divided by ",
            -font => 'default',
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    ($parm_div_cb = $parm_frame->new_ttk__combobox(
            -textvariable => \$parm_div,
            -values       => [ @parm_divlist ],
            -state        => 'readonly',
            -width        => $parm_chars,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Profile Stat: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    if ($src_type =~ /Contour|Vector/i) {
        $f->new_ttk__combobox(
                -textvariable => \$prof_stat,
                -values       => [ ("Surface value", "Volume-weighted") ],
                -state        => 'readonly',
                -width        => 16,
                )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    } else {
        $f->new_label(
                -text => $prof_stat,
                -font => 'default',
                )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    }

    $row++;
    $f->new_label(
            -text => "Conversion: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($conv_type_na_label = $f->new_label(
            -text => "n/a",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $conv_type_na_label->g_grid_remove();
    ($conv_type_cb = $f->new_ttk__combobox(
            -textvariable => \$conv_type,
            -values       => [ @conv_types ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $conv_type_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($conv_type eq "Custom") {
                                $custom_frame->g_grid();
                            } else {
                                $custom_frame->g_grid_remove();
                            }
                          }
                      );
    $row++;
    ($custom_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    $custom_frame->new_label(
            -text => "Multiply by: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_mult_entry = $custom_frame->new_entry(
            -textvariable => \$conv_mult,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_mult_entry->g_bind("<KeyRelease>",
                              sub { &numeric_entry_only($conv_mult_entry);
                                    my $chars = &max(7, length($conv_mult));
                                    $conv_mult_entry->configure(-width => $chars);
                                  });
    $custom_frame->new_label(
            -text => "  Then add: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_add_entry = $custom_frame->new_entry(
            -textvariable => \$conv_add,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_add_entry->g_bind("<KeyRelease>",
                             sub { &numeric_entry_only($conv_add_entry);
                                   my $chars = &max(7, length($conv_add));
                                   $conv_add_entry->configure(-width => $chars);
                                 });

    $row++;
    $f->new_label(
            -text => "Data Units: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($units_cb = $f->new_ttk__combobox(
            -textvariable => \$units,
            -values       => [ ("Celsius", "Fahrenheit") ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $units_cb->g_bind("<<ComboboxSelected>>",
                       sub { return if ($units eq $old_units);
                             $old_units = $units;
                             if ($units eq "Celsius") {
                                 if ($pmin ne "" && $pmin ne "." && $pmin ne "-") {
                                     $pmin = &floor(($pmin -32) /1.8);
                                 }
                                 if ($pmax ne "" && $pmax ne "." && $pmax ne "-") {
                                     $pmax = &ceil(($pmax  -32) /1.8);
                                 }
                             } elsif ($units eq "Fahrenheit") {
                                 if ($pmin ne "" && $pmin ne "." && $pmin ne "-") {
                                     $pmin = &floor($pmin *1.8 +32);
                                 }
                                 if ($pmax ne "" && $pmax ne "." && $pmax ne "-") {
                                     $pmax = &ceil($pmax  *1.8 +32);
                                 }
                             }
                             $title = "Temperature, in degrees " . $units;
                           });
    $units_cb->g_grid_remove();
    ($units_entry = $f->new_entry(
            -textvariable => \$units,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $units_entry->g_bind("<KeyRelease>",
                         sub { my $chars = &max(7, length($units));
                               $units_entry->configure(-width => $chars);
                               if ($parm eq "Temperature") {
                                   $title = "Temperature, in degrees " . $units;
                               } else {
                                   $title = $parm_short . ", in " . $units;
                               }
                             });

    $row++;
    $f->new_label(
            -text => "Data Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$title,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Data Min: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmin_entry = $f->new_entry(
            -textvariable => \$pmin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmin_entry ]);

    $row++;
    $f->new_label(
            -text => "Data Max: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmax_entry = $f->new_entry(
            -textvariable => \$pmax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmax_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmax_entry ]);

    $row++;
    $f->new_label(
            -text => "Graph Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gtitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Graph Subtitle: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gstitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);

    if ($change eq "misc") {
        $row++;
        $f->new_label(
                -text => "Base Year: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($byear_cb = $f->new_ttk__combobox(
                -textvariable => \$byear,
                -values       => [ reverse($yr_min .. $yr_max) ],
                -width        => 5,
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $byear_cb->g_bind("<<ComboboxSelected>>",
                          sub { if ($byear == $yr_min) {
                                    $yr_min -= 5;
                                    $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                }
                              });
        $f->new_label(
                -text   => " for JDAY = 1.0",
                -anchor => 'w',
                -font   => 'default',
                )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

        $row++;
        $f->new_label(
                -text => "Time Offset: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($offset_frame = $f->new_frame(
                -borderwidth => 0,
                -relief      => 'flat',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
        $offset_frame->new_ttk__combobox(
                -textvariable => \$tz_offset,
                -values       => [ @tz_offsets ],
                -justify      => 'right',
                -state        => 'readonly',
                -width        => 6,
                )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        $offset_frame->new_label(
                -text   => " time zone adjustment ",
                -anchor => 'w',
                -font   => 'default',
                )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        $offset_frame->new_button(
                -text    => "Help",
                -command => sub { &pop_up_info($w2tdmap_mod_menu,
                                        "The time offset allows the user to add or subtract a time\n"
                                      . "offset if the W2 model was run with a non-local time zone.\n\n"
                                      . "For example, if W2 was run in UTC but the local time zone\n"
                                      . "is PST, an offset of -08:00 would convert the model date/time\n"
                                      . "to a local standard time of PST. This offset does not make\n"
                                      . "any adjustments related to daylight saving time. In general,\n"
                                      . "W2 is best run in the local standard time.\n\n"
                                      . "Leave the time offset at +00:00 for no adjustment.",
                                        "Time Offset Notice");
                                },
                )->g_pack(-side => 'left', -anchor => 'w', -padx => 2);

        if ($jd_skip_active) {
            $row++;
            $f->new_label(
                    -text => "Skip Dates: ",
                    -font => 'default',
                    )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
            ($jd_skip_frame = $f->new_frame(
                    -borderwidth => 0,
                    -relief      => 'flat',
                    ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
            $jd_skip_frame->new_spinbox(
                    -textvariable => \$jd_skip,
                    -state        => 'readonly',
                    -font         => 'default',
                    -from         => 0,
                    -to           => 49,
                    -increment    => 1,
                    -width        => 4,
                    -command      => sub { $jd_skip_explain = $jd_skip_opts[$jd_skip]; },
                    )->g_pack(-side => 'left', -anchor => 'w');
            $jd_skip_frame->new_label(
                    -textvariable => \$jd_skip_explain,
                    -font         => 'default',
                    )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        }
    }

    if ($parm =~ /^(Temperature|TEMP)$/ || $parm eq "Horizontal Velocity" || $parm eq "Density"
                                        || $parm eq "Vertical Velocity" || $parm eq "Habitat"
                                        || $#parm_divlist == 0) {
        $parm_div_label->g_pack_forget();
        $parm_div_cb->g_pack_forget();
        $parm_div = "None";
    } else {
        $parm_div_label->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        $parm_div_cb->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    }
    if ($conv_type ne "Custom") {
        $custom_frame->g_grid_remove();
    }
    if ($parm =~ /^(Temperature|Tmax|Tmean|Tmin|TEMP)$/) {
        $units_cb->g_grid();
        $units_entry->g_grid_remove();
        $conv_type_na_label->g_grid();
        $custom_frame->g_grid_remove();
        $conv_type_cb->g_grid_remove();
        $conv_type = "None";
    } else {
        $units_cb->g_grid_remove();
        $units_entry->g_grid();
        $conv_type_na_label->g_grid_remove();
        $custom_frame->g_grid() if ($conv_type eq "Custom");
        $conv_type_cb->g_grid();
    }
    $f->g_grid_columnconfigure(3, -weight => 2);

    Tkx::wm_resizable($w2tdmap_mod_menu,0,0);
    &adjust_window_position($w2tdmap_mod_menu);
    $w2tdmap_mod_menu->g_focus;
}


sub make_w2_tdmap {
    my ($canv, $id, $props_updated) = @_;
    my (
        $add, $base_jd, $box_id, $change, $cmap_image, $cs_max, $cs_min,
        $cs_range, $cs_rev, $cscheme1, $cscheme2, $cshade, $cvert, $d1,
        $d2, $datemax, $datemin, $dbase, $dflip, $distance, $dmax, $dmin,
        $dp, $dp1, $dp2, $dpix, $drange, $dsize, $dsum, $dt, $dt_adj,
        $dt2, $flip_dir, $geom, $group_tags, $gtag, $i, $id2, $ih, $img,
        $img_data, $item, $iw, $j, $jb, $jd, $jd_max, $jd_min, $jd0, $jd2,
        $jw, $kn_digits, $last_jb, $last_seg, $mi, $mpointerx, $mpointery,
        $mult, $n, $nbr, $ncolors, $new_graph, $ns, $nwb, $parm_short, $pbar,
        $pbar_frame, $pbar_window, $refresh_menus, $resized, $seg, $seg_dn,
        $seg_list, $seg_up, $src_type, $src_type2, $stitle_id, $tabid,
        $tag, $td_img, $tflip, $time_on_x, $tp, $tp1, $tp2, $tpix, $trange,
        $update_cs, $X, $x1, $x2, $Y, $y1, $y2, $yp, $yr_max, $yr_min,

        @be, @brs, @bth_files, @bs, @cdata, @colors, @coords, @cpl_files,
        @cpl_lines, @dlx, @dist, @ds, @jdates, @grp_tags, @items, @mydates,
        @old_coords, @riv_files, @riv_lines, @scale, @seg_limits, @seg_wb,
        @seglist, @tags, @tecplot, @us, @wbs,

        %axis_props, %color_key_props, %limits, %parms, %profile, %sdata,
        %td_data, %tmp_data,
       );

#   For new plots, pop up a menu for file names and parameters
    if (! defined($props{$id}{files})) {
        return &setup_w2_slice_or_tdmap_or_wlevels($canv, $id);
    }

#   Make tag and get coordinates of graph frame
    $gtag   = "graph" . $id;
    @coords = @{ $props{$id}{coordlist} };
    ($x1, $y1, $x2, $y2) = @coords;

#   Determine whether group tags are present and save the list
    $group_tags = 0;
    @grp_tags   = ();
    @tags       = Tkx::SplitList($canv->itemcget($id, -tags));
    if (&list_search("group_", @tags) > -1) {
        $group_tags = 1;
        foreach $tag (@tags) {
            push (@grp_tags, $tag) if ($tag =~ /^group_/);
        }
    }

#   Define the swap-order flag, if not set
    $props{$id}{swap_order} = 0 if (! defined($props{$id}{swap_order}));

#   Read the data files, if not done already
    if (! defined($props{$id}{data}) || ! $props{$id}{data}
           || ($props{$id}{map_type} ne "standard"
                && (! defined($props{$id}{data2}) || ! $props{$id}{data2}))) {
        %parms    = %{ $props{$id}{parms} };
        @wbs      = split(/,/, $props{$id}{wb_list});
        $src_type = $props{$id}{src_type};

        if (defined($props{$id}{oldcoords})) {
            %profile   = %{ $gr_props{$id} };
            $change    = $parms{change};      # values:  parm, misc
            $new_graph = 0;
        } else {
            %profile   = ();
            $change    = "";
            $new_graph = 1;
        }

#       Move mouse cursor on first creation, to ensure that it changes to cursor_wait
        if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
            $canv->g_bind("<Motion>", "");
            Tkx::event_generate($main, "<Motion>", -warp => 1, -x => ($x1+$x2)/2, -y => ($y1+$y2)/2);
            $canv->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"), $canv, "menu" ]);
        }

#       Read bathymetry and source data files, as necessary
#       Required for all source file types. Vector (w2l) files don't have a good kb value.
        if (! defined($props{$id}{data}) || ! $props{$id}{data}) {
            if ($new_graph) {
                $status_line = "Reading bathymetry files...";
                Tkx::update_idletasks();
                @bth_files = @{ $props{$id}{bth_files} };
                for ($n=0; $n<=$#wbs; $n++) {
                    &read_bth($main, $id, $wbs[$n], $bth_files[$n]);
                }
                $status_line = "";
                Tkx::update_idletasks();
            }

            if ($src_type =~ /Contour/i) {
                @tecplot   = @{ $props{$id}{tecplot}   };
                @cpl_lines = @{ $props{$id}{cpl_lines} };
                @cpl_files = @{ $props{$id}{cpl_files} };
                for ($n=0; $n<=$#wbs; $n++) {
                    $jw = $wbs[$n];
                    ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $cpl_lines[$n],
                                                                 "Reading W2 contour file...");
                    %sdata = &read_w2_cpl_file($main, $id, $jw, $cpl_files[$n], $tecplot[$n], 0,
                                               $props{$id}{parm_sav}, $props{$id}{pdiv_sav},
                                               $props{$id}{byear}, $props{$id}{tz_offset},
                                               $props{$id}{jd_skip}, $pbar);
                    &destroy_progress_bar($main, $pbar_window);

#                   Reformat data hash and compute profile stat
                    ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, 10,
                                                                 "Computing profile stats...");
                    %tmp_data = &compute_pstat_from_slice($main, $id, $props{$id}{prof_stat},
                                                          $jw, $pbar, %sdata);
                    &destroy_progress_bar($main, $pbar_window);

#                   Consolidate data from different waterbodies
                    if ($#wbs == 0 || $n == 0) {
                        %td_data = %tmp_data;
                        @mydates = keys %td_data;
                        $dsum    = &sum(@mydates);
                    } else {
                        @mydates = keys %tmp_data;
                        if ($dsum != &sum(@mydates)) {
                            &pop_up_info($main, "Contour file dates for waterbody " . $wbs[$n] . "\n"
                                              . "do not match those for waterbody " . $wbs[0] . "\n"
                                              . "This could lead to visualization problems.");
                        }
                        foreach $dt (@mydates) {                             # each date/time
                            foreach $seg (keys %{ $tmp_data{$dt} }) {        # each segment
                                $td_data{$dt}{$seg} = $tmp_data{$dt}{$seg};
                            }
                        }
                    }
                    undef %sdata;
                    undef %tmp_data;
                }

            } elsif ($src_type =~ /Vector/i) {
                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, -s $props{$id}{w2l_file},
                                                             "Reading W2 vector file...");
                $status_line = "Reading W2 vector file... Date = 1";
                %sdata = &read_w2_vector_file($main, $id, $props{$id}{w2l_file}, 0,
                                              $props{$id}{parm_sav}, $props{$id}{pdiv_sav},
                                              $props{$id}{byear}, $props{$id}{tz_offset},
                                              $props{$id}{jd_skip}, $pbar);
                &destroy_progress_bar($main, $pbar_window);

#               Reformat data hash and compute profile stat
                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, 10,
                                                             "Computing profile stats...");
                %td_data = &compute_pstat_from_slice($main, $id, $props{$id}{prof_stat},
                                                     "all", $pbar, %sdata);
                &destroy_progress_bar($main, $pbar_window);
                undef %sdata;

            } elsif ($src_type =~ /RiverCon/i) {
                @riv_lines = @{ $props{$id}{riv_lines} };
                @riv_files = @{ $props{$id}{riv_files} };
                @brs       = split(/,/, $props{$id}{br_list});
                for ($n=0; $n<=$#brs; $n++) {
                    ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $riv_lines[$n],
                                                                 "Reading W2 RiverCon file...");
                    %tmp_data = &read_w2_rivcon_file($main, $id, $riv_files[$n], $props{$id}{parm_sav},
                                                     $brs[$n], $props{$id}{byear}, $props{$id}{tz_offset},
                                                     $props{$id}{jd_skip}, $pbar);
                    &destroy_progress_bar($main, $pbar_window);

#                   Consolidate data from different branches
                    if ($#brs == 0 || $n == 0) {
                        %td_data = %tmp_data;
                        @mydates = keys %td_data;
                        $dsum    = &sum(@mydates);
                    } else {
                        @mydates = keys %tmp_data;
                        if ($dsum != &sum(@mydates)) {
                            &pop_up_info($main, "RiverCon file dates for branch " . $brs[$n] . "\n"
                                              . "do not match those for branch " . $brs[0] . "\n"
                                              . "This could lead to visualization problems.");
                        }
                        foreach $dt (@mydates) {                             # each date/time
                            foreach $seg (keys %{ $tmp_data{$dt} }) {        # each segment
                                $td_data{$dt}{$seg} = $tmp_data{$dt}{$seg};
                            }
                        }
                    }
                    undef %tmp_data;
                }

            } elsif ($src_type =~ /SurfTemp|VolTemp|FlowTemp/i) {
                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $props{$id}{src_lines},
                                                             "Reading " . $src_type . "...");
                %td_data = &read_w2_flowtemp_alt($main, $props{$id}{src_file}, $props{$id}{parm_sav},
                                                 $props{$id}{pdiv_sav}, $props{$id}{byear},
                                                 $props{$id}{tz_offset}, $props{$id}{jd_skip}, $pbar);
                &destroy_progress_bar($main, $pbar_window);
            }

#           Data conversion
            if (&list_match($props{$id}{ctype}, @conv_types) > 0 || $props{$id}{ctype} =~ /^Custom,/) {
                $status_line = "Converting units...";
                Tkx::update_idletasks();
                %td_data = &convert_tdmap_data($main, $props{$id}{ctype}, %td_data);
                $status_line = "";
                Tkx::update_idletasks();
            }
            $profile{td_data} = { %td_data };
        }

        if ($props{$id}{map_type} =~ /^(parmdiff|filediff)$/
              && (! defined($props{$id}{data2}) || ! $props{$id}{data2})) {

            $src_type2 = $props{$id}{src_type2};
            if ($src_type2 =~ /Contour/i) {
                @tecplot   = @{ $props{$id}{tecplot2}   };
                @cpl_lines = @{ $props{$id}{cpl_lines2} };
                @cpl_files = @{ $props{$id}{cpl_files2} };
                for ($n=0; $n<=$#wbs; $n++) {
                    $jw = $wbs[$n];
                    ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $cpl_lines[$n],
                                                                 "Reading W2 contour file...");
                    %sdata = &read_w2_cpl_file($main, $id, $jw, $cpl_files[$n], $tecplot[$n], 0,
                                               $props{$id}{parm2_sav}, $props{$id}{pdiv2_sav},
                                               $props{$id}{byear}, $props{$id}{tz_offset},
                                               $props{$id}{jd_skip}, $pbar);
                    &destroy_progress_bar($main, $pbar_window);

#                   Reformat data hash and compute profile stat
                    ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, 10,
                                                                 "Computing profile stats...");
                    %tmp_data = &compute_pstat_from_slice($main, $id, $props{$id}{prof_stat},
                                                          $jw, $pbar, %sdata);
                    &destroy_progress_bar($main, $pbar_window);

#                   Consolidate data from different waterbodies
                    if ($#wbs == 0 || $n == 0) {
                        %td_data = %tmp_data;
                        @mydates = keys %td_data;
                        $dsum    = &sum(@mydates);
                    } else {
                        @mydates = keys %tmp_data;
                        if ($dsum != &sum(@mydates)) {
                            &pop_up_info($main, "Contour file dates for waterbody " . $wbs[$n] . "\n"
                                              . "do not match those for waterbody " . $wbs[0] . "\n"
                                              . "This could lead to visualization problems.");
                        }
                        foreach $dt (@mydates) {                             # each date/time
                            foreach $seg (keys %{ $tmp_data{$dt} }) {        # each segment
                                $td_data{$dt}{$seg} = $tmp_data{$dt}{$seg};
                            }
                        }
                    }
                    undef %sdata;
                    undef %tmp_data;
                }

            } elsif ($src_type2 =~ /Vector/i) {
                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, -s $props{$id}{w2l_file2},
                                                             "Reading W2 vector file...");
                $status_line = "Reading W2 vector file... Date = 1";
                %sdata = &read_w2_vector_file($main, $id, $props{$id}{w2l_file2}, 0,
                                              $props{$id}{parm2_sav}, $props{$id}{pdiv2_sav},
                                              $props{$id}{byear}, $props{$id}{tz_offset},
                                              $props{$id}{jd_skip}, $pbar);
                &destroy_progress_bar($main, $pbar_window);

#               Reformat data hash and compute profile stat
                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, 10,
                                                             "Computing profile stats...");
                %td_data = &compute_pstat_from_slice($main, $id, $props{$id}{prof_stat},
                                                     "all", $pbar, %sdata);
                &destroy_progress_bar($main, $pbar_window);
                undef %sdata;

            } elsif ($src_type2 =~ /RiverCon/i) {
                @riv_lines = @{ $props{$id}{riv_lines2} };
                @riv_files = @{ $props{$id}{riv_files2} };
                @brs       = split(/,/, $props{$id}{br_list2});
                for ($n=0; $n<=$#brs; $n++) {
                    ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $riv_lines[$n],
                                                                 "Reading W2 RiverCon file...");
                    %tmp_data = &read_w2_rivcon_file($main, $id, $riv_files[$n], $props{$id}{parm2_sav},
                                                     $brs[$n], $props{$id}{byear}, $props{$id}{tz_offset},
                                                     $props{$id}{jd_skip}, $pbar);
                    &destroy_progress_bar($main, $pbar_window);

#                   Consolidate data from different branches
                    if ($#brs == 0 || $n == 0) {
                        %td_data = %tmp_data;
                        @mydates = keys %td_data;
                        $dsum    = &sum(@mydates);
                    } else {
                        @mydates = keys %tmp_data;
                        if ($dsum != &sum(@mydates)) {
                            &pop_up_info($main, "RiverCon file dates for branch " . $brs[$n] . "\n"
                                              . "do not match those for branch " . $brs[0] . "\n"
                                              . "This could lead to visualization problems.");
                        }
                        foreach $dt (@mydates) {                             # each date/time
                            foreach $seg (keys %{ $tmp_data{$dt} }) {        # each segment
                                $td_data{$dt}{$seg} = $tmp_data{$dt}{$seg};
                            }
                        }
                    }
                    undef %tmp_data;
                }

            } elsif ($src_type2 =~ /SurfTemp|VolTemp|FlowTemp/i) {
                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $props{$id}{src_lines2},
                                                             "Reading " . $src_type2 . "...");
                %td_data = &read_w2_flowtemp_alt($main, $props{$id}{src_file2}, $props{$id}{parm2_sav},
                                                 $props{$id}{pdiv2_sav}, $props{$id}{byear},
                                                 $props{$id}{tz_offset}, $props{$id}{jd_skip}, $pbar);
                &destroy_progress_bar($main, $pbar_window);
            }

#           Data conversion
            if (&list_match($props{$id}{ctype2}, @conv_types) > 0 || $props{$id}{ctype2} =~ /^Custom,/) {
                $status_line = "Converting units...";
                Tkx::update_idletasks();
                %td_data = &convert_tdmap_data($main, $props{$id}{ctype2}, %td_data);
                $status_line = "";
                Tkx::update_idletasks();
            }

#           Compute differences
            %tmp_data = %{ $profile{td_data} };                     # data for parameter 1
            if ($props{$id}{map_type} eq "parmdiff") {
                foreach $dt (keys %tmp_data) {                      # each date/time
                    foreach $seg (keys %{ $tmp_data{$dt} }) {       # each segment
                        if (! defined($td_data{$dt}{$seg}) || $td_data{$dt}{$seg}  == -99
                                                           || $tmp_data{$dt}{$seg} == -99) {
                            $tmp_data{$dt}{$seg} = -99;
                        } else {
                            $tmp_data{$dt}{$seg} -= $td_data{$dt}{$seg};
                        }
                    }
                }
            } elsif ($props{$id}{map_type} eq "filediff") {
                foreach $dt (keys %tmp_data) {                      # each date/time
                    $dt2 = $dt;
                    if (! defined($td_data{$dt2}) && $props{$id}{match_tol} > 0) {
                        for ($mi=1; $mi<=$props{$id}{match_tol}; $mi++) {
                            $dt_adj = &adjust_dt($dt2, $mi);
                            if (defined($td_data{$dt_adj})) {
                                $dt2 = $dt_adj;
                                last;
                            }
                            $dt_adj = &adjust_dt($dt2, -1 *$mi);
                            if (defined($td_data{$dt_adj})) {
                                $dt2 = $dt_adj;
                                last;
                            }
                        }
                    }
                    foreach $seg (keys %{ $tmp_data{$dt} }) {       # each segment
                        if (! defined($td_data{$dt2}{$seg}) || $td_data{$dt2}{$seg} == -99
                                                            || $tmp_data{$dt}{$seg} == -99) {
                            $tmp_data{$dt}{$seg} = -99;
                        } else {
                            $tmp_data{$dt}{$seg} -= $td_data{$dt2}{$seg};
                        }
                    }
                }
            }
            if ($props{$id}{swap_order}) {                          # swap order of difference
                foreach $dt (keys %tmp_data) {                      # each date/time
                    foreach $seg (keys %{ $tmp_data{$dt} }) {       # each segment
                        if ($tmp_data{$dt}{$seg} != -99) {
                            $tmp_data{$dt}{$seg} *= -1.0;
                        }
                    }
                }
            }
            %td_data           = %tmp_data;
            $profile{td_data}  = { %td_data };
            $props{$id}{data2} = 1;
            undef %tmp_data;
        }

#       Find minimum and maximum elevation and parameter values
        %limits = &find_w2_tdmap_limits($id, %td_data);
        $profile{date_min} = $limits{date_min};
        $profile{date_max} = $limits{date_max};
        $profile{parm_min} = $limits{parm_min};
        $profile{parm_max} = $limits{parm_max};
        undef %limits;

        if ($new_graph) {                              # not x or y.  d: distance, t: date/time
            $profile{dfont}     = $default_family;
            $profile{dl_size}   = &min(11, &max(8, int((abs($x2-$x1)+abs($y2-$y1))/2./41)));
            $profile{dt_size}   = $profile{dl_size} +2;
            $profile{dl_weight} = 'normal';
            $profile{dt_weight} = 'normal';

            $profile{tfont}     = $profile{dfont};
            $profile{tl_size}   = $profile{dl_size};
            $profile{tt_size}   = $profile{dt_size};
            $profile{tl_weight} = $profile{dl_weight};
            $profile{tt_weight} = $profile{dt_weight};

            $profile{date_axis} = $parms{date_axis};
            $profile{ttype}     = $parms{date_type};
            $profile{tflip}     = $parms{date_flip};
            $profile{tmin}      = "first";
            $profile{tmax}      = "last";
            $profile{tmajor}    = "auto";
            $profile{tpr_tics}  = "outside";
            $profile{top_tics}  = "none";
            $profile{datefmt}   = "Month";
            $profile{tflip_img} = 0;                   # flag set later

            $profile{dunits}    = $parms{dist_units};  # d: distance, t: time
            $profile{dflip}     = $parms{dist_flip};
            $profile{dbase}     = ($parms{dist_base}  ne "") ? $parms{dist_base}  : 0;
            $profile{dmin}      = ($parms{dist_min}   ne "") ? $parms{dist_min}   : 0;
            $profile{dfirst}    = ($parms{dist_first} ne "") ? $parms{dist_first} : $profile{$dmin};
            $profile{dmajor}    = ($parms{dist_major} eq "") ? "auto" : $parms{dist_major};
            $profile{dpr_tics}  = "outside";
            $profile{dop_tics}  = "none";
            $profile{dtitle}    = ($parms{dist_units} eq "kilometers") ? "River Kilometer" : "River Mile";
            $profile{dmax_auto} = 1;
            $profile{dflip_img} = 0;                   # flag set later
            $profile{dmax}      = 0;                   # calculated later
            $profile{d_km}      = 0;                   # calculated later

            $profile{gtfont}    = $profile{dfont};
            $profile{gt_size}   = $profile{dt_size};
            $profile{gt_weight} = 'bold';
            $profile{gs_size}   = $profile{gt_size} -1;
            $profile{gs_weight} = $profile{gt_weight};

            $profile{keyfont}   = $default_family;
            $profile{kn_size}   = $profile{dl_size};
            $profile{kt_size}   = $profile{dl_size} +2;
            $profile{kt_weight} = 'normal';
            $profile{kn_weight} = 'normal';
            $profile{kn_digits} = 1;

            $profile{add_cs}    = 1;
            $profile{cs_height} = &max(2, &min(18, int(($y2-$y1+1) /$parms{ncolors})));
            if ($parms{cscheme} eq "Blue to Orange") {
                $profile{cscheme1} = "Blue";
                $profile{cscheme2} = "Orange";
                $profile{ncolors}  = $parms{ncolors} /2;
            } elsif ($parms{cscheme} eq "Blue to Red") {
                $profile{cscheme1} = "Blue";
                $profile{cscheme2} = "Red";
                $profile{ncolors}  = $parms{ncolors} /2;
            } else {
                $profile{cscheme1} = $parms{cscheme};
                $profile{cscheme2} = "None";
                $profile{ncolors}  = $parms{ncolors};
            }
            $profile{cs_rev}     =  0;
            $profile{cs_hide}    =  0;
            $profile{xleg_off}   = 40;
            $profile{yleg_off}   =  0;
            $profile{cs_width}   = 24;
            $profile{cs_link}    =  0;
            $profile{cs_major}   = "auto";
            $profile{hide_title} =  0;
            $profile{hide_taxis} =  0;
            $profile{hide_daxis} =  0;
        }

        if (defined($parms{title}) && $parms{title} ne "") {
            $profile{keytitle} = $parms{title};
            if ($props{$id}{parm_sav} =~ /^(Temperature|TEMP|Tmin|Tmean|Tmax)$/) {
                $props{$id}{parm} = "Temperature";
            }
        } elsif ($props{$id}{parm_sav} =~ /^(Temperature|TEMP|Tmin|Tmean|Tmax)$/) {
            if ($props{$id}{parm_sav} eq "Temperature" || $props{$id}{parm_sav} eq "TEMP") {
                $profile{keytitle} = "Temperature, in degrees " . $props{$id}{parm_units};
            } elsif ($props{$id}{parm_sav} eq "Tmax") {
                $profile{keytitle} = "Max Temperature, in degrees " . $props{$id}{parm_units};
            } elsif ($props{$id}{parm_sav} eq "Tmean") {
                $profile{keytitle} = "Mean Temperature, in degrees " . $props{$id}{parm_units};
            } elsif ($props{$id}{parm_sav} eq "Tmin") {
                $profile{keytitle} = "Min Temperature, in degrees " . $props{$id}{parm_units};
            }
            $props{$id}{parm} = "Temperature";
        } else {
            $parm_short = $props{$id}{parm};
            $parm_short =~ s/\(ms-1\)//i;
            $parm_short =~ s/\(m3s-1\)//i;
            $parm_short =~ s/ [kmu]?g\/L\/day//i;
            $parm_short =~ s/ [kmu]?g\/m2\/day//i;
            $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
            $parm_short =~ s/ [kmu]?g\/L//i;
            $parm_short =~ s/ [kmu]?g\/m3//i;
            $parm_short =~ s/ [kmu]?g\/m\^3//i;
            $parm_short =~ s/, days//i;
            $parm_short =~ s/ days//i;
            $parm_short =~ s/,$//;
            $profile{keytitle} = $parm_short . ", in " . $props{$id}{parm_units};
        }
        if ($props{$id}{pdiv_sav} =~ /^(Temperature|TEMP|Tmin|Tmean|Tmax)$/) {
            $props{$id}{parm_div} = "Temperature";
        }
        if ($props{$id}{map_type} =~ /^(parmdiff|filediff)$/) {
            if ($props{$id}{pdiv2_sav} =~ /^(Temperature|TEMP|Tmin|Tmean|Tmax)$/) {
                $props{$id}{parm2_div} = "Temperature";
            }
        }
        $profile{gtitle}  = $parms{gtitle};
        $profile{gstitle} = $parms{gstitle};
        $profile{cs_min}  = $parms{pmin};
        $profile{cs_max}  = $parms{pmax};
        $profile{base_yr} = $props{$id}{byear};

        if (@animate_ids && $#animate_ids >= 0) {
            $update_cs = 0;
            foreach $item (@animate_ids) {
                next if ($item == $id);
                next if ($props{$item}{meta} =~ /time_series|w2_wlevels/);
                next if ($props{$item}{meta} eq "w2_outflow" && ! $props{$item}{add_parm});
                if ($gr_props{$item}{cs_link} == 2) {
                    if ($props{$item}{meta} =~ /(w2_slice|w2_profile|w2_outflow)/
                         && $props{$id}{map_type}     eq "standard"
                         && $props{$item}{parm}       eq $props{$id}{parm_sav}
                         && $props{$item}{parm_div}   eq $props{$id}{pdiv_sav}
                         && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                        $update_cs = 1;
                        $id2 = $item;
                        last;
                    } elsif ($props{$item}{meta} eq "w2_tdmap"
                         && $props{$item}{map_type}   eq $props{$id}{map_type}
                         && $props{$item}{parm_sav}   eq $props{$id}{parm_sav}
                         && $props{$item}{pdiv_sav}   eq $props{$id}{pdiv_sav}
                         && $props{$item}{parm_units} eq $props{$id}{parm_units}
                         && ($props{$id}{map_type} eq "standard"
                            || ($props{$item}{parm2_sav} eq $props{$id}{parm2_sav}
                             && $props{$item}{pdiv2_sav} eq $props{$id}{pdiv2_sav}))) {
                        $update_cs = 1;
                        $id2 = $item;
                        last;
                    } elsif ($props{$item}{meta} =~ /data_profile/
                         && $props{$id}{map_type}     eq "standard"
                         && $props{$item}{prof_type}  eq "standard"
                         && $props{$item}{parm}       eq $props{$id}{parm_sav}
                         && $props{$id}{pdiv_sav}     eq "None"
                         && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                        $update_cs = 1;
                        $id2 = $item;
                        last;
                    } elsif ($props{$item}{meta} =~ /vert_wd_zone/
                         && $props{$id}{map_type}   eq "standard"
                         && $props{$id}{parm_sav}   eq "Temperature"
                         && $props{$id}{pdiv_sav}   eq "None"
                         && $props{$item}{wt_units} eq $props{$id}{parm_units}) {
                        $update_cs = 1;
                        $id2 = $item;
                        last;
                    }
                }
            }
            if (! $update_cs) {
                foreach $item (@animate_ids) {
                    next if ($item == $id);
                    next if ($props{$item}{meta} =~ /data_profile|vert_wd_zone|time_series|w2_wlevels/);
                    next if ($props{$item}{meta} eq "w2_outflow" && ! $props{$item}{add_parm});
                    next if ($props{$item}{meta} =~ /w2_tdmap|w2_slice|w2_profile|w2_outflow/
                             && $props{$item}{src_type} ne $src_type);
                    if ($gr_props{$item}{cs_link} == 1) {
                        if ($props{$item}{meta} =~ /w2_slice/
                             && $props{$id}{map_type}     eq "standard"
                             && $props{$item}{parm}       eq $props{$id}{parm_sav}
                             && $props{$item}{parm_div}   eq $props{$id}{pdiv_sav}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}
                             && $props{$item}{con_file}   eq $props{$id}{con_file}) {
                            $update_cs = 1;
                            $id2 = $item;
                            last;
                        } elsif ($props{$item}{meta} eq "w2_tdmap"
                             && $props{$item}{map_type}   eq $props{$id}{map_type}
                             && $props{$item}{parm_sav}   eq $props{$id}{parm_sav}
                             && $props{$item}{pdiv_sav}   eq $props{$id}{pdiv_sav}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}
                             && $props{$item}{con_file}   eq $props{$id}{con_file}
                             && ($props{$id}{map_type} eq "standard"
                                || ($props{$item}{parm2_sav} eq $props{$id}{parm2_sav}
                                 && $props{$item}{pdiv2_sav} eq $props{$id}{pdiv2_sav}
                                 && $props{$item}{src_type2} eq $props{$id}{src_type2}))) {
                            $update_cs = 1;
                            $id2 = $item;
                            last;
                        } elsif ($props{$item}{meta} =~ /w2_profile|w2_outflow/
                             && $props{$id}{map_type}     eq "standard"
                             && $props{$item}{parm}       eq $props{$id}{parm_sav}
                             && $props{$item}{parm_div}   eq $props{$id}{pdiv_sav}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            if ($src_type =~ /Contour/i) {
                                for ($n=0; $n<=$#wbs; $n++) {
                                    if ($cpl_files[$n] eq $props{$item}{src_file}) {
                                        $update_cs = 1;
                                        $id2 = $item;
                                        last;
                                    }
                                }
                                last if ($update_cs);
                            } elsif ($src_type =~ /Vector/i) {
                                if ($props{$id}{w2l_file} eq $props{$item}{src_file}) {
                                    $update_cs = 1;
                                    $id2 = $item;
                                    last;
                                }
                            }
                        }
                    }
                }
            }
            if ($update_cs) {
                $ncolors           = $profile{ncolors};
                $profile{cs_link}  = $gr_props{$id2}{cs_link};
                $profile{cscheme1} = $gr_props{$id2}{cscheme1};
                $profile{cscheme2} = $gr_props{$id2}{cscheme2};
                $profile{ncolors}  = $gr_props{$id2}{ncolors};
                $profile{cs_rev}   = $gr_props{$id2}{cs_rev};
                $profile{cs_min}   = $gr_props{$id2}{cs_min};
                $profile{cs_max}   = $gr_props{$id2}{cs_max};
                $profile{cs_major} = $gr_props{$id2}{cs_major};
                if ($new_graph) {
                    if ($profile{cs_height} *$ncolors > $y2-$y1+1 && $profile{cs_height} > 2) {
                        $profile{cs_height} = &max(2, &min(18, int(($y2-$y1+1) /$profile{ncolors})));
                    }
                } elsif ($ncolors != $profile{ncolors}) {
                    $profile{cs_height} = &max(2, &min(30,
                                   &round_to_int($profile{cs_height} *$ncolors /$profile{ncolors})));
                }
            }
        }
        undef $gr_props{$id} if (! $new_graph);
        $profile{redraw}  = 1;
        $gr_props{$id}    = { %profile };
        $props{$id}{data} = 1;
        $props{$id}{gnum} = ++$graph_num if (! defined($props{$id}{oldcoords}));
        $resized          = 0;
        $refresh_menus    = 0;
        undef %profile;

#       Reset the min/max dates if different jd_skip or byear.
#       The rebuild option is determined in change_w2_tdmap.
        if (! $new_graph) {
            if ($parms{rebuild}) {
                @mydates      = sort keys %td_data;
                $datemin      = substr($mydates[0],0,8);
                $datemax      = substr($mydates[$#mydates],0,8);
                $cmap_datemin = $datemin if ($datemin < $cmap_datemin);
                $cmap_datemax = $datemax if ($datemax > $cmap_datemax);
            }
            $refresh_menus = 1;
            $canv->delete($gtag . "_xaxis");
            $canv->delete($gtag . "_xaxisTitle");
            $canv->delete($gtag . "_yaxis");
            $canv->delete($gtag . "_yaxisTitle");
            $canv->delete($gtag . "_gtitle");
            $canv->delete($gtag . "_colorKey");
            $canv->delete($gtag . "_colorKeyTitle");
            $canv->delete($gtag . "_colorMap");
        }
        undef %parms;

#   Or use previously read info.  If resized, delete graph and redraw
    } else {
        @old_coords    = @{ $props{$id}{oldcoords} };
        $refresh_menus = 0;
        $resized       = 0;
        for ($i=0; $i<=$#coords; $i++) {
            if ($coords[$i] != $old_coords[$i]) {
                $resized = 1;
                last;
            }
        }
        return if (! $resized && ! $props_updated);
        $gr_props{$id}{redraw} = 1 if ($resized || $props_updated == 2);

        %td_data  = %{ $gr_props{$id}{td_data} };
        @wbs      = split(/,/, $props{$id}{wb_list});
        $src_type = $props{$id}{src_type};

        $canv->delete($gtag . "_xaxis");
        $canv->delete($gtag . "_xaxisTitle");
        $canv->delete($gtag . "_yaxis");
        $canv->delete($gtag . "_yaxisTitle");
        $canv->delete($gtag . "_gtitle");
        $canv->delete($gtag . "_colorKey");
        $canv->delete($gtag . "_colorKeyTitle");
        $canv->delete($gtag . "_colorMap") if ($gr_props{$id}{redraw});
    }
    $props{$id}{oldcoords} = [ @coords ];

#   Plot a white rectangle below the graph frame
    @items     = Tkx::SplitList($canv->find_withtag($gtag . "_main"));
    $new_graph = ($#items >= 0) ? 0 : 1;
    if ($new_graph) {
        $box_id = $canv->create_rectangle($x1, $y1, $x2, $y2,
                             -outline => "",
                             -width   => 0,
                             -fill    => &get_rgb_code("white"),
                             -tags    => $gtag . " " . $gtag . "_main");
        $canv->lower($box_id, $id);
    } else {
        $canv->coords($gtag . "_main", @coords);
        $canv->raise($id, $gtag . "_main");
    }

#   Plot the graph subtitle, if present
    if ($gr_props{$id}{date_axis} eq "X") {
        $yp = (! $gr_props{$id}{hide_taxis} &&
                 $gr_props{$id}{top_tics} =~ /outside|cross/) ? $y1-14 : $y1-6;
    } else {
        $yp = (! $gr_props{$id}{hide_daxis} &&
                 $gr_props{$id}{dop_tics} =~ /outside|cross/) ? $y1-14 : $y1-6;
    }
    if ($gr_props{$id}{gstitle} ne "") {
        $stitle_id = $canv->create_text(($x1+$x2)/2., $yp,
                           -anchor => 's',
                           -text   => $gr_props{$id}{gstitle},
                           -fill   => &get_rgb_code("black"),
                           -angle  => 0,
                           -tags   => $gtag . " " . $gtag . "_gtitle",
                           -font   => [-family     => $gr_props{$id}{gtfont},
                                       -size       => $gr_props{$id}{gs_size},
                                       -weight     => $gr_props{$id}{gs_weight},
                                       -slant      => 'roman',
                                       -underline  => 0,
                                       -overstrike => 0,
                                      ]);
        @coords = Tkx::SplitList($canv->bbox($stitle_id));
        $dsize  = &max(10, abs($coords[3] - $coords[1]));
    } else {
        $dsize = 0;
    }

#   Plot the graph title
    $canv->create_text(($x1+$x2)/2., $yp-$dsize,
                       -anchor => 's',
                       -text   => $gr_props{$id}{gtitle},
                       -fill   => &get_rgb_code("black"),
                       -angle  => 0,
                       -tags   => $gtag . " " . $gtag . "_gtitle",
                       -font   => [-family     => $gr_props{$id}{gtfont},
                                   -size       => $gr_props{$id}{gt_size},
                                   -weight     => $gr_props{$id}{gt_weight},
                                   -slant      => 'roman',
                                   -underline  => 0,
                                   -overstrike => 0,
                                  ]);
    if ($gr_props{$id}{hide_title}) {
        $canv->itemconfigure($gtag . "_gtitle", -state => 'hidden');
    }

#   Deal with the color scheme and create the color key
    $cscheme1  = $gr_props{$id}{cscheme1};
    $cscheme2  = $gr_props{$id}{cscheme2};
    $ncolors   = $gr_props{$id}{ncolors};
    $cs_rev    = $gr_props{$id}{cs_rev};
    $cs_min    = $gr_props{$id}{cs_min};
    $cs_max    = $gr_props{$id}{cs_max};
    $kn_digits = $gr_props{$id}{kn_digits};
    if (&list_match($cscheme1, @color_scheme_names) == -1 ||
       (&list_match($cscheme1, @full_color_schemes) == -1 && &list_match($ncolors, @valid_nc) == -1) ||
       (&list_match($cscheme1, @full_color_schemes) >= 0 && &list_match($ncolors, @valid_nc_alt) == -1) ||
       ($cscheme2 ne "" && $cscheme2 ne "None" && &list_match($cscheme2, @color_scheme_names) == -1)) {
        $cscheme1  = $gr_props{$id}{cscheme1}  = "Blue";
        $cscheme2  = $gr_props{$id}{cscheme2}  = "Orange";
        $ncolors   = $gr_props{$id}{ncolors}   = 11;
        $cs_rev    = $gr_props{$id}{cs_rev}    =  0;
        $cs_min    = $gr_props{$id}{cs_min}    =  0;
        $cs_max    = $gr_props{$id}{cs_max}    = 22;
        $kn_digits = $gr_props{$id}{kn_digits} =  1;
    }
    $cs_range = $cs_max -$cs_min;
    @colors   = &make_color_scheme($ncolors, $cs_rev, $cscheme1, $cscheme2);
    @scale    = ();
    for ($i=0; $i<=$#colors+1; $i++) {
        $j = $#colors +1 -$i;
        $scale[$j] = $cs_min +$cs_range*$j/($#colors+1);
    }
    $gr_props{$id}{colors}    = [ @colors ];
    $gr_props{$id}{scale}     = [ @scale  ];

    $color_key_props{xleg}    = $x2 + $gr_props{$id}{xleg_off};
    $color_key_props{yleg}    = $y1 + $gr_props{$id}{yleg_off};
    $color_key_props{width}   = $gr_props{$id}{cs_width};
    $color_key_props{height}  = $gr_props{$id}{cs_height};
    $color_key_props{colors}  = [ @colors ];
    $color_key_props{scale}   = [ @scale  ];
    $color_key_props{title}   = $gr_props{$id}{keytitle};
    $color_key_props{font}    = $gr_props{$id}{keyfont};
    $color_key_props{size1}   = $gr_props{$id}{kn_size};
    $color_key_props{size2}   = $gr_props{$id}{kt_size};
    $color_key_props{weight1} = $gr_props{$id}{kn_weight};
    $color_key_props{weight2} = $gr_props{$id}{kt_weight};
    $color_key_props{digits}  = $kn_digits;
    $color_key_props{major}   = $gr_props{$id}{cs_major};
    $color_key_props{tags}    = $gtag . " " . $gtag . "_colorKey";
    &make_color_key($canv, %color_key_props);
    undef %color_key_props;

    if ($gr_props{$id}{cs_hide}) {
        $canv->itemconfigure($gtag . "_colorKey", -state => 'hidden');
    }

#   The Time/Distance colormap is not animated.
#   Add id to animate_ids array, but no need to reconcile with @dates array.
#   Might need to update the cmap date min/max.
    @mydates = sort keys %td_data;
    if (! defined($cmap_datemin)) {
        $cmap_datemin = substr($mydates[0],0,8);
        $cmap_datemax = substr($mydates[$#mydates],0,8);
    } elsif ($new_graph) {
        $datemin      = substr($mydates[0],0,8);
        $datemax      = substr($mydates[$#mydates],0,8);
        $cmap_datemin = $datemin if ($datemin < $cmap_datemin);
        $cmap_datemax = $datemax if ($datemax > $cmap_datemax);
    }
    if (! @animate_ids || &list_match($id, @animate_ids) == -1) {
        push (@animate_ids, $id);
    }

#   Determine limits of date/time axis
    @jdates = &dates2jdates(@mydates);
    if ($gr_props{$id}{tmin} eq "first" && $gr_props{$id}{tmax} eq "last") {
        $jd_min = &floor($jdates[0] +0.0000001);
        $jd_max = &floor($jdates[$#jdates] +1.0000001);
        if ($gr_props{$id}{ttype} eq "Date/Time") {
            $gr_props{$id}{tmin} = &jdate2datelabel($jd_min, "Mon-DD-YYYY");
            $gr_props{$id}{tmax} = &jdate2datelabel($jd_max, "Mon-DD-YYYY");
        }
    } else {
        if (! defined($gr_props{$id}{base_yr})) {
            $gr_props{$id}{base_yr} = substr($mydates[0],0,4);
        }
        if ($gr_props{$id}{ttype} eq "Date/Time") {
            $jd_min = &datelabel2jdate($gr_props{$id}{tmin});
            $jd_max = &datelabel2jdate($gr_props{$id}{tmax});
        } else {
            $base_jd = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
            $jd_min  = $gr_props{$id}{tmin} +$base_jd -1;
            $jd_max  = $gr_props{$id}{tmax} +$base_jd -1;
        }
    }

#   Plot the date axis -- Date/Time or Julian Date
#   For the date axis, over-ride any user-supplied axis title
    $axis_props{major}   = $gr_props{$id}{tmajor};
    $axis_props{pr_tics} = $gr_props{$id}{tpr_tics};
    $axis_props{op_tics} = $gr_props{$id}{top_tics};
    $axis_props{minor}   = 1;
    $axis_props{reverse} = 0;
    $axis_props{font}    = $gr_props{$id}{tfont};
    $axis_props{size1}   = $gr_props{$id}{tl_size};
    $axis_props{size2}   = $gr_props{$id}{tt_size};
    $axis_props{weight1} = $gr_props{$id}{tl_weight};
    $axis_props{weight2} = $gr_props{$id}{tt_weight};
    if ($gr_props{$id}{date_axis} eq "X") {
        $axis_props{side}   = "bottom";
        $axis_props{tags}   = $gtag . " " . $gtag . "_xaxis";
        $axis_props{coords} = ($gr_props{$id}{tflip}) ? [$x2, $y2, $x1, $y2] : [$x1, $y2, $x2, $y2];
        $axis_props{op_loc} = $y1;
    } else {
        $axis_props{side}   = "left";
        $axis_props{tags}   = $gtag . " " . $gtag . "_yaxis";
        $axis_props{coords} = ($gr_props{$id}{tflip}) ? [$x1, $y2, $x1, $y1] : [$x1, $y1, $x1, $y2];
        $axis_props{op_loc} = $x2;
    }
    if ($gr_props{$id}{ttype} eq "Date/Time") {
        $yr_min = substr($gr_props{$id}{tmin},7,4);
        $yr_max = substr($gr_props{$id}{tmax},7,4);
        $yr_max-- if (substr($gr_props{$id}{tmax},0,3) eq "Jan" &&
                      substr($gr_props{$id}{tmax},4,2) eq "01");
        if ($yr_min == $yr_max) {
            $gr_props{$id}{ttitle} = "Date in $yr_min";
        } else {
            $gr_props{$id}{ttitle} = "Date ($yr_min-$yr_max)";
        }
        $axis_props{min}     = $jd_min;
        $axis_props{max}     = $jd_max;
        $axis_props{title}   = $gr_props{$id}{ttitle};
        $axis_props{datefmt} = $gr_props{$id}{datefmt};
        &make_date_axis($canv, %axis_props);
    } else {
        $axis_props{min}     = $gr_props{$id}{tmin};
        $axis_props{max}     = $gr_props{$id}{tmax};
        $axis_props{title}   = $gr_props{$id}{ttitle};
        &make_axis($canv, %axis_props);
    }
    undef %axis_props;
    if ($gr_props{$id}{hide_taxis}) {
        if ($gr_props{$id}{date_axis} eq "X") {
            $canv->itemconfigure($gtag . "_xaxis",      -state => 'hidden');
            $canv->itemconfigure($gtag . "_xaxisTitle", -state => 'hidden');
        } else {
            $canv->itemconfigure($gtag . "_yaxis",      -state => 'hidden');
            $canv->itemconfigure($gtag . "_yaxisTitle", -state => 'hidden');
        }
    }

#   Initialize some arrays. Get segment list and downstream distance.
    $nwb = $grid{$id}{nwb};
    $nbr = $grid{$id}{nbr};
    @bs  = @{ $grid{$id}{bs}  };
    @be  = @{ $grid{$id}{be}  };
    @us  = @{ $grid{$id}{us}  };
    @ds  = @{ $grid{$id}{ds}  };
    @dlx = @{ $grid{$id}{dlx} };

    if (defined($gr_props{$id}{dist}) && defined($gr_props{$id}{seglist})) {
        @seglist = @{ $gr_props{$id}{seglist} };
        @seg_wb  = @{ $gr_props{$id}{seg_wb}  };
        @dist    = @{ $gr_props{$id}{dist}    };  # saved in units of kilometers
    } else {
        $seg_list   = $props{$id}{seg_list};
        @seg_limits = reverse split(/,|-/, $seg_list);  # reverse the order: ds to us
        @seglist    = ();
        @seg_wb     = ();
        $distance   = $last_seg = $last_jb = 0;
        for ($j=0; $j<=$#seg_limits; $j+=2) {
            $seg_dn = $seg_limits[$j];
            $seg_up = $seg_limits[$j+1];
            for ($jb=1; $jb<=$nbr; $jb++) {
                last if ($seg_dn >= $us[$jb] && $seg_dn <= $ds[$jb]);
            }
            for ($jw=1; $jw<=$nwb; $jw++) {
                last if ($jb >= $bs[$jw] && $jb <= $be[$jw]);
            }
            if ($j > 1 && $last_seg != $us[$last_jb]) {
                $distance       -= $dlx[$last_seg] /2. *0.001;   # km
                $dist[$last_seg] = $distance;
            }
            for ($i=$seg_dn; $i>=$seg_up; $i--) {
                $distance  += $dlx[$i] *0.001;    # km
                $dist[$i]   = $distance;
                $seg_wb[$i] = $jw;
                push (@seglist, $i);
            }
            $last_seg = $seg_up;
            $last_jb  = $jb;
        }
        $gr_props{$id}{seglist} = [ @seglist ];
        $gr_props{$id}{seg_wb}  = [ @seg_wb  ];
        $gr_props{$id}{dist}    = [ @dist    ];
    }
    $mult  = ($gr_props{$id}{dunits} eq "miles") ? 3280.84/5280. : 1.0;
    $dmin  = $gr_props{$id}{dmin};
    $dbase = $gr_props{$id}{dbase};
    if ($gr_props{$id}{dmax_auto}) {
        $distance = &round_to_int(1000.*$dist[$seglist[$#seglist]] *$mult)/1000.;
        $gr_props{$id}{dmax} = $dmax = $dbase +$distance;
    } else {
        $dmax = $gr_props{$id}{dmax};
    }
    $gr_props{$id}{d_km} = $dist[$seglist[$#seglist]];

#   Plot distance axis
    $axis_props{min}     = $dmin;
    $axis_props{max}     = $dmax;
    $axis_props{first}   = $gr_props{$id}{dfirst};
    $axis_props{major}   = $gr_props{$id}{dmajor};
    $axis_props{pr_tics} = $gr_props{$id}{dpr_tics};
    $axis_props{op_tics} = $gr_props{$id}{dop_tics};
    $axis_props{minor}   = 1;
    $axis_props{reverse} = 0;
    $axis_props{title}   = $gr_props{$id}{dtitle};
    $axis_props{font}    = $gr_props{$id}{dfont};
    $axis_props{size1}   = $gr_props{$id}{dl_size};
    $axis_props{size2}   = $gr_props{$id}{dt_size};
    $axis_props{weight1} = $gr_props{$id}{dl_weight};
    $axis_props{weight2} = $gr_props{$id}{dt_weight};
    if ($gr_props{$id}{date_axis} eq "Y") {
        $axis_props{side}   = "bottom";
        $axis_props{tags}   = $gtag . " " . $gtag . "_xaxis";
        $axis_props{coords} = ($gr_props{$id}{dflip}) ? [$x1, $y2, $x2, $y2] : [$x2, $y2, $x1, $y2];
        $axis_props{op_loc} = $y1;
    } else {
        $axis_props{side}   = "left";
        $axis_props{tags}   = $gtag . " " . $gtag . "_yaxis";
        $axis_props{coords} = ($gr_props{$id}{dflip}) ? [$x1, $y1, $x1, $y2] : [$x1, $y2, $x1, $y1];
        $axis_props{op_loc} = $x2;
    }
    &make_axis($canv, %axis_props);
    undef %axis_props;
    if ($gr_props{$id}{hide_daxis}) {
        if ($gr_props{$id}{date_axis} eq "X") {
            $canv->itemconfigure($gtag . "_yaxis",      -state => 'hidden');
            $canv->itemconfigure($gtag . "_yaxisTitle", -state => 'hidden');
        } else {
            $canv->itemconfigure($gtag . "_xaxis",      -state => 'hidden');
            $canv->itemconfigure($gtag . "_xaxisTitle", -state => 'hidden');
        }
    }

#   Refresh the Graph Properties menu and Object Information box, if present
    if ($refresh_menus) {
        if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
            if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
                $tabid = $grprops_notebook->index('current');
                $geom  = $graph_props_menu->g_wm_geometry();
                (undef, $X, $Y) = split(/\+/, $geom);
                &edit_graph_props($id, $X, $Y, $tabid);
            }
        }
        if (defined($object_infobox) && Tkx::winfo_exists($object_infobox)) {
            if ($object_infobox->g_wm_title() eq "Object Info") {
                $geom = $object_infobox->g_wm_geometry();
                (undef, $X, $Y) = split(/\+/, $geom);
                &show_info($canv, $id, $X, $Y);
            }
        }
    }

#   Don't recompute and redraw unless necessary
    if ($gr_props{$id}{redraw}) {
        $gr_props{$id}{dflip_img} = 0;
        $gr_props{$id}{tflip_img} = 0;
    }
    if (! $gr_props{$id}{redraw}) {
        $canv->lower($gtag . "_colorKey",      $id);
        $canv->lower($gtag . "_colorKeyTitle", $id);
        $canv->lower($gtag . "_gtitle",        $id);
        $canv->lower($gtag . "_xaxisTitle",    $id);
        $canv->lower($gtag . "_yaxisTitle",    $id);
        $canv->lower($gtag . "_colorMap",      $id);
        $canv->lower($gtag . "_xaxis",         $id);
        $canv->lower($gtag . "_yaxis",         $id);
        if ($group_tags) {
            foreach $tag (@grp_tags) {
                $canv->addtag($tag, withtag => $gtag);
            }
        }
        if ($gr_props{$id}{dflip_img} || $gr_props{$id}{tflip_img}) {         # Flip existing image
            $status_line = "Flipping time/distance map...";
            Tkx::update_idletasks();

            $td_img   = $gr_props{$id}{td_img};
            $img      = Imager->new;
            $img_data = $td_img->data(-format => 'png');
            $img->read(data => $img_data);
            if ($gr_props{$id}{tflip_img} && $gr_props{$id}{dflip_img}) {
                $flip_dir = "vh";
            } elsif ($gr_props{$id}{tflip_img}) {
                $flip_dir = ($gr_props{$id}{date_axis} eq "X") ? "h" : "v";
            } else {
                $flip_dir = ($gr_props{$id}{date_axis} eq "Y") ? "h" : "v";
            }
            $img->flip(dir => $flip_dir);
            $img->write(data => \$img_data, type => 'png');
            $td_img->put($img_data, -format => 'png');

            $canv->itemconfigure($gtag . "_colorMap", -image => $td_img);
            $status_line = "Flipping time/distance map:  Done";
            Tkx::update_idletasks();
            $gr_props{$id}{dflip_img} = 0;
            $gr_props{$id}{tflip_img} = 0;
            $gr_props{$id}{td_img}    = $td_img;
        }
        return;
    }

#   Create an image to hold the colormap and recognize its methods
    $iw = $x2 -$x1 +1;
    $ih = $y2 -$y1 +1;
    $cmap_image = Tkx::image_create_photo(-width => $iw, -height => $ih);
    $cmap_image = Tkx::widget->new($cmap_image);

#   Create a progress bar
    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $geom = sprintf("+%d+%d", $X+($x1+$x2)/2-150, $Y+($y1+$y2)/2);

    $pbar_window = $main->new_toplevel();
    $pbar_window->g_wm_transient($main);
    $pbar_window->g_wm_title("Working on colormap...");
    $pbar_window->g_wm_geometry($geom);
    $pbar_window->configure(-cursor => $cursor_wait);
    $pbar_window->g_focus;

    $pbar_frame = $pbar_window->new_frame(
                    -borderwidth => 2,
                    -relief      => 'groove');
    $pbar_frame->g_pack(-anchor => 'nw', -expand => 1, -fill => 'x');
    ($pbar = $pbar_frame->new_ttk__progressbar(
                    -orient  => 'horizontal',
                    -length  => 300,
                    -mode    => 'determinate',
                    -value   => 0,
                    -maximum => $jd_max -$jd_min,
                    ))->g_pack();

#   Move mouse cursor on first creation, to ensure that it changes to cursor_wait
    if ($new_graph) {
        if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
            $mpointerx = Tkx::winfo_pointerx($main);
            $mpointery = Tkx::winfo_pointery($main);
            $canv->g_bind("<Motion>", "");
            Tkx::event_generate($main, "<Motion>", -warp => 1, -x => ($x1+$x2)/2, -y => ($y1+$y2)/2);
            $canv->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"), $canv, "menu" ]);
        }
    }

#   Change the mouse cursor to tell the user to be patient
    if ($resized) {
        $canv->configure(-cursor => $cursor_wait);
    } else {
        Tkx::tk_busy_hold($main, -cursor => $cursor_wait);
    }
    if ($new_graph) {
        if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
            Tkx::update();
            $canv->g_bind("<Motion>", "");
            Tkx::event_generate("", "<Motion>", -warp => 1, -x => $mpointerx, -y => $mpointery);
            $canv->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"), $canv, "menu" ]);
        }
    }
    $status_line = "Working on colormap.  Please wait...";
    Tkx::update();
    Tkx::wm_resizable($pbar_window,0,0);

#   Create the time/distance colormap
    if ($gr_props{$id}{date_axis} eq "X") {
        $time_on_x = 1;
        $tpix = $iw;
        $dpix = $ih;
    } else {
        $time_on_x = 0;
        $tpix = $ih;
        $dpix = $iw;
    }
    $tflip  = $gr_props{$id}{tflip};
    $dflip  = $gr_props{$id}{dflip};
    $trange = $jd_max -$jd_min;
    $drange = $dmax -$dmin;
    for ($n=0; $n<=$#jdates; $n++) {
        $jd = $jdates[$n];
        next if ($jd < $jd_min);
        last if ($jd > $jd_max);
        if ($n == 0 || $jd == $jd_min) {
            $jd2 = ($jd +$jdates[$n+1])/2.;
            if ($tflip) {
                $tp1 = &round_to_int(($tpix-1)*(1.0-($jd -$jd_min)/$trange));
                $tp2 = &round_to_int(($tpix-1)*(1.0-($jd2-$jd_min)/$trange));
            } else {
                $tp1 = &round_to_int(($tpix-1)*($jd -$jd_min)/$trange);
                $tp2 = &round_to_int(($tpix-1)*($jd2-$jd_min)/$trange);
            }
            next if ($tp1 == $tp2);
        } elsif ($n == $#jdates || $jd == $jd_max) {
            $jd0 = ($jd +$jdates[$n-1])/2.;
            if ($tflip) {
                $tp1 = &round_to_int(($tpix-1)*(1.0-($jd0-$jd_min)/$trange));
                $tp2 = &round_to_int(($tpix-1)*(1.0-($jd -$jd_min)/$trange));
                $tp2 = 0 if (abs($jd_max -$jd) <= 1);
            } else {
                $tp1 = &round_to_int(($tpix-1)*($jd0-$jd_min)/$trange);
                $tp2 = &round_to_int(($tpix-1)*($jd -$jd_min)/$trange);
                $tp2 = $tpix-1 if (abs($jd_max -$jd) <= 1);
            }
        } else {
            $jd0 = ($jd +$jdates[$n-1])/2.;
            $jd2 = ($jd +$jdates[$n+1])/2.;
            if ($tflip) {
                $tp1 = &round_to_int(($tpix-1)*(1.0-($jd0-$jd_min)/$trange));
                $tp2 = &round_to_int(($tpix-1)*(1.0-($jd2-$jd_min)/$trange));
            } else {
                $tp1 = &round_to_int(($tpix-1)*($jd0-$jd_min)/$trange);
                $tp2 = &round_to_int(($tpix-1)*($jd2-$jd_min)/$trange);
            }
            next if ($tp1 == $tp2);
        }
        $tp1 = &max(0, &min($tpix-1, $tp1));
        $tp2 = &max(0, &min($tpix-1, $tp2));
        $pbar->configure(-value => $jd -$jd_min);  # update the progress bar
        Tkx::update_idletasks();

        $dt = $mydates[$n];
        for ($ns=0; $ns<=$#seglist; $ns++) {
            $seg = $seglist[$ns];
            next if (! defined($td_data{$dt}{$seg}) || $td_data{$dt}{$seg} == -99);

#           Distance limits
            $d1 = ($ns == 0) ? 0 : $dist[$seglist[$ns-1]] *$mult;
            $d2 = $dist[$seg] *$mult;
            if ($dflip) {
                $dp1 = &round_to_int(($dpix-1)*($d1 +$dbase -$dmin)/$drange);
                $dp2 = &round_to_int(($dpix-1)*($d2 +$dbase -$dmin)/$drange);
                next if ($dp2 <= 0);
                last if ($dp1 > $dpix-1);
            } else {
                $dp1 = &round_to_int(($dpix-1)*(1.-($d1 +$dbase -$dmin)/$drange));
                $dp2 = &round_to_int(($dpix-1)*(1.-($d2 +$dbase -$dmin)/$drange));
                next if ($dp2 > $dpix-1);
                last if ($dp1 <= 0);
            }
            $dp1 = &max(0, &min($dpix-1, $dp1));
            $dp2 = &max(0, &min($dpix-1, $dp2));
            next if ($dp1 == $dp2 && $ns < $#seglist);

            if ($props{$id}{parm} eq "Temperature" && $props{$id}{parm_units} eq "Fahrenheit") {
                $add = ($props{$id}{map_type} eq "standard") ? 32 : 0;
                $j   = int(($#colors+1) *(($td_data{$dt}{$seg} *1.8 +$add)-$cs_min)/$cs_range);
            } else {
                $j = int(($#colors+1) *($td_data{$dt}{$seg}-$cs_min)/$cs_range);
            }
            $j = &max(0, &min($#colors, $j));
            $cshade = $colors[$j];

          # Consider special cases. Single rows or columns won't plot with 4-arg -to option.
            if ($time_on_x) {
                if ($tp1 != $tp2 && $dp1 != $dp2) {
                    $cmap_image->put($cshade, -to => $tp1, $dp1, $tp2, $dp2);
                } elsif ($tp1 != $tp2) {
                    @cdata    = ();
                    $cdata[0] = $cshade;
                    if ($tp2 > $tp1) {
                        for ($tp=$tp1+1; $tp<=$tp2; $tp++) {
                            $cdata[0] .= " " . $cshade;
                        }
                        $cmap_image->put([ @cdata ], -to => $tp1, $dp1);  # horizontal line
                    } else {
                        for ($tp=$tp2+1; $tp<=$tp1; $tp++) {
                            $cdata[0] .= " " . $cshade;
                        }
                        $cmap_image->put([ @cdata ], -to => $tp2, $dp1);  # horizontal line
                    }
                } elsif ($dp1 != $dp2) {
                    $cvert = $cshade;
                    if ($dp2 > $dp1) {
                        for ($dp=$dp1+1; $dp<=$dp2; $dp++) {
                            $cvert .= " " . $cshade;
                        }
                        $cmap_image->put($cvert, -to => $tp1, $dp1);      # vertical line
                    } else {
                        for ($dp=$dp2+1; $dp<=$dp1; $dp++) {
                            $cvert .= " " . $cshade;
                        }
                        $cmap_image->put($cvert, -to => $tp1, $dp2);      # vertical line
                    }
                } else {
                    $cmap_image->put($cshade, -to => $tp1, $dp1);         # single point
                }
            } else {
                if ($tp1 != $tp2 && $dp1 != $dp2) {
                    $cmap_image->put($cshade, -to => $dp1, $tp1, $dp2, $tp2);
                } elsif ($dp1 != $dp2) {
                    @cdata    = ();
                    $cdata[0] = $cshade;
                    if ($dp2 > $dp1) {
                        for ($dp=$dp1+1; $dp<=$dp2; $dp++) {
                            $cdata[0] .= " " . $cshade;
                        }
                        $cmap_image->put([ @cdata ], -to => $dp1, $tp1);  # horizontal line
                    } else {
                        for ($dp=$dp2+1; $dp<=$dp1; $dp++) {
                            $cdata[0] .= " " . $cshade;
                        }
                        $cmap_image->put([ @cdata ], -to => $dp2, $tp1);  # horizontal line
                    }
                } elsif ($tp1 != $tp2) {
                    $cvert = $cshade;
                    if ($tp2 > $tp1) {
                        for ($tp=$tp1+1; $tp<=$tp2; $tp++) {
                            $cvert .= " " . $cshade;
                        }
                        $cmap_image->put($cvert, -to => $dp1, $tp1);      # vertical line
                    } else {
                        for ($tp=$tp2+1; $tp<=$tp1; $tp++) {
                            $cvert .= " " . $cshade;
                        }
                        $cmap_image->put($cvert, -to => $dp1, $tp2);      # vertical line
                    }
                } else {
                    $cmap_image->put($cshade, -to => $dp1, $tp1);         # single point
                }
            }
            last if ($dp2 >= $dpix-1);
        }
    }
    $canv->create_image($x1, $y1, -anchor => 'nw',
                                  -image  => $cmap_image,
                                  -tags   => $gtag . " " . $gtag . "_colorMap");
    $gr_props{$id}{td_img} = $cmap_image;
    undef $cmap_image;

#   Place the graphic items in the proper order
    &raise_lower($canv, $id, "tiptop") if ($new_graph);
    $canv->lower($gtag . "_colorKey",      $id);
    $canv->lower($gtag . "_colorKeyTitle", $id);
    $canv->lower($gtag . "_gtitle",        $id);
    $canv->lower($gtag . "_xaxisTitle",    $id);
    $canv->lower($gtag . "_yaxisTitle",    $id);
    $canv->lower($gtag . "_colorMap",      $id);
    $canv->lower($gtag . "_xaxis",         $id);
    $canv->lower($gtag . "_yaxis",         $id);
    if ($group_tags) {
        foreach $tag (@grp_tags) {
            $canv->addtag($tag, withtag => $gtag);
        }
    }

#   Restore mouse cursor and remove the progress bar
    $canv->configure(-cursor => $cursor_norm);
    $pbar_window->g_destroy();
    $status_line = "";
    if (! $resized) {
        Tkx::tk_busy_forget($main);
    }
}


sub swap_w2_tdmap_axes {
    my ($canv, $id) = @_;
    my ($geom, $tabid, $X, $Y);

#   The axes could be swapped by re-plotting the axes and re-scaling/rotating
#   the existing colormap, but I'm afraid that the image will degrade. So,
#   it's better to just remake the plot.

#   De-select graph
    &end_select($canv, $id, 1);

#   Swap axes
    $gr_props{$id}{date_axis} = ($gr_props{$id}{date_axis} eq "X") ? "Y" : "X";

#   Remake the graph and force a redraw
    &make_w2_tdmap($canv, $id, 2);

#   Refresh the Graph Properties menu, if present
    if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
        if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
            $tabid = $grprops_notebook->index('current');
            $geom  = $graph_props_menu->g_wm_geometry();
            (undef, $X, $Y) = split(/\+/, $geom);
            &edit_graph_props($id, $X, $Y, $tabid);
        }
    }
}


sub setup_data_profile {
    my ($canv, $id) = @_;
    my (
        $cscheme, $cscheme_cb, $display_units, $elev_base, $f, $frame, $geom,
        $gtitle, $n, $ncolors, $ncolors_cb, $ncolors_na_label, $ok_btn,
        $old_parm_units, $parm, $parm_txt, $parm_units, $parm_units_cb,
        $parm_units_label, $pmajor, $pmajor_entry, $pmajor_label, $pmax,
        $pmax_entry, $pmax_label, $pmin, $pmin_entry, $pmin_label,
        $row, $src_file, $X, $x1, $x2, $Y, $y1, $y2, $yaxis_type,
        $yaxis_type_cb, $yaxis_units, $yaxis_units_label, $ymajor,
        $ymajor_entry, $ymajor_label, $ymax, $ymax_entry, $ymax_label,
        $ymin, $ymin_entry, $ymin_label, $ymin_units_label,

        @cmaps,
       );

    ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $geom = sprintf("+%d+%d", $X+$x1+30, $Y+$y1+50);

    if (defined($profile_setup_menu) && Tkx::winfo_exists($profile_setup_menu)) {
        if ($profile_setup_menu->g_wm_title() eq "Profile Setup") {
            $profile_setup_menu->g_destroy();
            undef $profile_setup_menu;
        }
    }
    $profile_setup_menu = $main->new_toplevel();
    $profile_setup_menu->g_wm_transient($main);
    $profile_setup_menu->g_wm_title("Profile Setup");
    $profile_setup_menu->configure(-cursor => $cursor_norm);
    $profile_setup_menu->g_wm_geometry($geom);

#   Try to keep the nascent graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

    $src_file    = $gtitle = "";
    $parm        = $parm_units = $old_parm_units = $display_units = $parm_txt = "";
    $pmin        = $pmax = $pmajor = "";
    $ymin        = $ymax = $ymajor = "";
    $yaxis_type  = "Elevation";
    $yaxis_units = "feet";
    $cscheme     = "Blue to Orange";
    $ncolors     = 20;
    $elev_base   = -999;

#   Available initial colormaps
    @cmaps = ("None", "Blue to Orange", "Blue to Red", "CoolWarm", "Turbo", "Viridis");
    shift @cmaps if ($props{$id}{meta} eq "data_profile_cmap");

    $frame = $profile_setup_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -state   => 'disabled',
            -command => sub { my (%parms);
                              if ($src_file eq "" || ! -e $src_file) {
                                  return &pop_up_error($profile_setup_menu,
                                  "Data profile file not set or does not exist:\n$src_file");
                              }
                              if ($pmin eq "" || $pmax eq "") {
                                  return &pop_up_error($profile_setup_menu,
                                      "Please provide both a minimum and\n"
                                    . "and maximum parameter value.");
                              }
                              if ($pmin >= $pmax) {
                                  return &pop_up_error($profile_setup_menu,
                                      "The minimum parameter value must be less\n"
                                    . "than the maximum parameter value.");
                              }
                              if ($yaxis_type eq "Elevation") {
                                  if ($ymin eq "" || $ymax eq "") {
                                      return &pop_up_error($profile_setup_menu,
                                      "Please provide both a minimum and maximum elevation.");
                                  }
                                  if ($ymin >= $ymax) {
                                      return &pop_up_error($profile_setup_menu,
                                      "The minimum elevation must be less than the maximum elevation.");
                                  }
                              } else {
                                  if ($ymax eq "") {
                                      return &pop_up_error($profile_setup_menu,
                                      "Please provide a maximum depth.");
                                  }
                              }
                              $gtitle =~ s/^\s+//;
                              $gtitle =~ s/\s+$//;

                              %parms             = ();
                              $parms{pmin}       = $pmin;
                              $parms{pmax}       = $pmax;
                              $parms{pmajor}     = $pmajor;
                              $parms{ymin}       = $ymin;
                              $parms{ymax}       = $ymax;
                              $parms{ymajor}     = $ymajor;
                              $parms{ytype}      = $yaxis_type;
                              $parms{yunits}     = $yaxis_units;
                              $parms{cscheme}    = $cscheme;
                              $parms{ncolors}    = $ncolors;
                              $parms{gtitle}     = $gtitle;
                              $props{$id}{parms} = { %parms };

                              $props{$id}{files}      = 1;
                              $props{$id}{src_file}   = $src_file;
                              $props{$id}{parm}       = $parm;
                              $props{$id}{parm_units} = $parm_units;
                              $props{$id}{prof_type}  = "standard";     # standard or difference

                              $profile_setup_menu->g_bind('<Destroy>', "");
                              $profile_setup_menu->g_destroy();
                              undef $profile_setup_menu;
                              &reset_bindings;

                              &make_data_profile($canv, $id, 0);
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $profile_setup_menu->g_bind('<Destroy>', "");
                              $profile_setup_menu->g_destroy();
                              undef $profile_setup_menu;
                              $canv->delete("graph" . $id);
                              delete $props{$id};
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Delete graph if this menu is destroyed by other than the Cancel button
    $profile_setup_menu->g_bind('<Destroy>' => sub { undef $profile_setup_menu;
                                                     $canv->delete("graph" . $id);
                                                     delete $props{$id}; 
                                                     &reset_bindings;
                                                   });

    $f = $profile_setup_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "Profile Data File: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$src_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);
    $f->new_button(
            -text    => "Browse",
            -command => sub { my ($file, $status, %meta);
                              $file = Tkx::tk___getOpenFile(
                                      -parent           => $profile_setup_menu,
                                      -title            => "Select Profile Data File",
                                      -initialdir       => abs_path(),
                                      -defaultextension => ".csv",
                                      -filetypes => [ ['CSV (comma delimited)', '.csv'],
                                                      ['All Files', '*'],
                                                    ],
                                      );
                              if (defined($file) && -e $file && -r $file && ! -z $file) {
                                  $src_file = File::Spec->rel2abs($file);
                                  ($status, %meta) = &scan_profile($profile_setup_menu, $src_file);
                                  if ($status ne "okay") {
                                      $src_file = "";
                                      $ok_btn->configure(-state => 'disabled');
                                      return &pop_up_error($profile_setup_menu,
                                            "Specified file is not a profile data file "
                                          . "or is incomplete:\n$file");
                                  }
                                  if (defined($meta{parm})) {
                                      $parm = $meta{parm};
                                      if (defined($meta{parm_units})) {
                                          $parm_units = $meta{parm_units};
                                          if ($parm_units =~ /^(Celsius|Fahrenheit)$/) {
                                              $display_units = "\N{U+00B0}" . substr($parm_units,0,1);
                                          } else {
                                              $display_units = $parm_units;
                                          }
                                      }
                                      if ($parm =~ /Temperature/i) {
                                          $parm_txt = "Temperature, in degrees " . ucfirst($parm_units);
                                          $pmin_label->configure(-text => "Temperature Min: ");
                                          $pmax_label->configure(-text => "Temperature Max: ");
                                          $parm_units_label->g_grid();
                                          $parm_units_cb->g_grid();
                                          if ($props{$id}{meta} eq "data_profile") {
                                              $pmajor_label->configure(-text => "Temperature Major: ");
                                              $gtitle = "Temperature Profile";
                                          } else {
                                              $gtitle = "Temperature Colormap";
                                          }
                                      } else {
                                          $parm_txt = $parm . ", in " . $parm_units;
                                          $pmin_label->configure(-text => "Parameter Min: ");
                                          $pmax_label->configure(-text => "Parameter Max: ");
                                          $parm_units_label->g_grid_remove();
                                          $parm_units_cb->g_grid_remove();
                                          if ($props{$id}{meta} eq "data_profile") {
                                              $pmajor_label->configure(-text => "Parameter Major: ");
                                              $gtitle = $parm . " Profile";
                                          } else {
                                              $gtitle = $parm . " Colormap";
                                          }
                                      }
                                  }
                                  if (defined($meta{parm_min}) && defined($meta{parm_max})
                                       && $meta{parm_min} ne "" && $meta{parm_max} ne ""
                                       && $meta{parm_max} > $meta{parm_min}) {
                                      $pmin = $meta{parm_min};
                                      $pmax = $meta{parm_max};
                                  }
                                  if (defined($meta{parm_major}) && $meta{parm_major} ne "") {
                                      $pmajor = abs($meta{parm_major});
                                  }
                                  if (defined($meta{ymin}) && defined($meta{ymax})
                                       && $meta{ymin} ne "" && $meta{ymax} ne ""
                                       && $meta{ymax} > $meta{ymin}) {
                                      $ymin = $meta{ymin};
                                      $ymax = $meta{ymax};
                                      $elev_base = &min($ymin, $ymax);
                                  } elsif (defined($meta{ymax}) && $meta{ymax} ne "") {
                                      $ymax = $meta{ymax};
                                      $ymin = "";
                                  }
                                  if (defined($meta{ymajor}) && $meta{ymajor} ne "") {
                                      $ymajor = abs($meta{ymajor});
                                  }
                                  if (defined($meta{ytype})
                                       && $meta{ytype} =~ /^(Elevation|Depth)$/) {
                                      $yaxis_type = $meta{ytype};
                                      if ($yaxis_type eq "Elevation") {
                                          $ymin_label->g_grid();
                                          $ymin_entry->g_grid();
                                          $ymin_units_label->g_grid();
                                          $ymax_label->configure(-text => "Elevation Max: ");
                                          $ymajor_label->configure(-text => "Elevation Major: ");
                                          $yaxis_units_label->configure(-text => "Elevation Units: ");
                                      } else {
                                          $ymin_label->g_grid_remove();
                                          $ymin_entry->g_grid_remove();
                                          $ymin_units_label->g_grid_remove();
                                          $ymax_label->configure(-text => "Depth Max: ");
                                          $ymajor_label->configure(-text => "Depth Major: ");
                                          $yaxis_units_label->configure(-text => "Depth Units: ");
                                      }
                                  }
                                  if (defined($meta{yunits})
                                       && $meta{yunits} =~ /^(feet|meters)$/) {
                                      $yaxis_units = $meta{yunits};
                                  }
                                  $ok_btn->configure(-state => 'normal');
                              } else {
                                  $ok_btn->configure(-state => 'disabled');
                              }
                            },
            )->g_grid(-row => $row, -column => 4, -sticky => 'ew', -padx => 2, -pady => 2);

    $row++;
    $f->new_label(
            -text => "Parameter: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$parm_txt,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Y Axis Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($yaxis_type_cb = $f->new_ttk__combobox(
            -textvariable => \$yaxis_type,
            -values       => [ ("Elevation", "Depth") ],
            -state        => 'readonly',
            -width        => 10,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $yaxis_type_cb->g_bind("<<ComboboxSelected>>",
                           sub { if ($yaxis_type eq "Elevation") {
                                     $ymin_label->g_grid();
                                     $ymin_entry->g_grid();
                                     $ymin_units_label->g_grid();
                                     $ymax_label->configure(-text => "Elevation Max: ");
                                     $ymajor_label->configure(-text => "Elevation Major: ");
                                     $yaxis_units_label->configure(-text => "Elevation Units: ");
                                     if ($elev_base != -999 && $ymax ne "") {
                                         $ymin  = $elev_base;
                                         $ymax += $elev_base;
                                     } else {
                                         $ymin = "";
                                     }
                                 } else {
                                     $ymin_label->g_grid_remove();
                                     $ymin_entry->g_grid_remove();
                                     $ymin_units_label->g_grid_remove();
                                     $ymax_label->configure(-text => "Depth Max: ");
                                     $ymajor_label->configure(-text => "Depth Major: ");
                                     $yaxis_units_label->configure(-text => "Depth Units: ");
                                     if ($ymax ne "" && $ymin ne "" && $ymax -$ymin != 0) {
                                         $elev_base = &min($ymin, $ymax);
                                         $ymax      = abs($ymax -$ymin);
                                     } else {
                                         $ymax = "";
                                     }
                                     $ymin = 0;
                                 }
                               }
                          );

    $row++;
    ($ymin_label = $f->new_label(
            -text => "Elevation Min: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ymin_entry = $f->new_entry(
            -textvariable => \$ymin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $ymin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $ymin_entry ]);
    ($ymin_units_label = $f->new_label(
            -textvariable => \$yaxis_units,
            -font         => 'default',
            -anchor       => 'w',
            ))->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    ($ymax_label = $f->new_label(
            -text => "Elevation Max: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ymax_entry = $f->new_entry(
            -textvariable => \$ymax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $ymax_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($ymax_entry);
                                              $ymax =~ s/^-// if ($yaxis_type eq "Depth");
                                            });
    $f->new_label(
            -textvariable => \$yaxis_units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    ($ymajor_label = $f->new_label(
            -text => "Elevation Major: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ymajor_entry = $f->new_entry(
            -textvariable => \$ymajor,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $ymajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($ymajor_entry, 1);
                                                $ymajor =~ s/^-//;
                                              });
    $f->new_label(
            -textvariable => \$yaxis_units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    ($yaxis_units_label = $f->new_label(
            -text => "Elevation Units: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_ttk__combobox(
            -textvariable => \$yaxis_units,
            -values       => [ ("feet", "meters") ],
            -state        => 'readonly',
            -width        => 7,
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    ($pmin_label = $f->new_label(
            -text => "Parameter Min: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmin_entry = $f->new_entry(
            -textvariable => \$pmin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmin_entry ]);
    $f->new_label(
            -textvariable => \$display_units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    ($pmax_label = $f->new_label(
            -text => "Parameter Max: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmax_entry = $f->new_entry(
            -textvariable => \$pmax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmax_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmax_entry ]);
    $f->new_label(
            -textvariable => \$display_units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    if ($props{$id}{meta} eq "data_profile") {
        $row++;
        ($pmajor_label = $f->new_label(
                -text => "Parameter Major: ",
                -font => 'default',
                ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($pmajor_entry = $f->new_entry(
                -textvariable => \$pmajor,
                -font         => 'default',
                -width        => 7,
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $pmajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($pmajor_entry, 1);
                                                    $pmajor =~ s/^-//;
                                                  });
        $f->new_label(
                -textvariable => \$display_units,
                -font         => 'default',
                -anchor       => 'w',
                )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);
    }

    $row++;
    ($parm_units_label = $f->new_label(
            -text => "Temperature Units: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($parm_units_cb = $f->new_ttk__combobox(
            -textvariable => \$parm_units,
            -values       => [ ("Celsius", "Fahrenheit") ],
            -state        => 'readonly',
            -width        => 12,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $parm_units_cb->g_bind("<<ComboboxSelected>>",
                          sub { $display_units = "\N{U+00B0}" . substr($parm_units,0,1);
                                $pmin = 0 if ($pmin eq "-");
                                $pmax = 0 if ($pmax eq "-");
                                if ($parm_units eq "Celsius" && $old_parm_units eq "Fahrenheit") {
                                    $pmin   = &floor(($pmin -32) /1.8)    if ($pmin   ne "");
                                    $pmax   = &ceil(($pmax -32) /1.8)     if ($pmax   ne "");
                                    $pmajor = &round_to_int($pmajor /1.8) if ($pmajor ne "");
                                } elsif ($parm_units eq "Fahrenheit" && $old_parm_units eq "Celsius") {
                                    $pmin   = &floor($pmin *1.8 +32)      if ($pmin   ne "");
                                    $pmax   = &ceil($pmax *1.8 +32)       if ($pmax   ne "");
                                    $pmajor = &round_to_int($pmajor *1.8) if ($pmajor ne "");
                                }
                                $old_parm_units = $parm_units;
                              });

    $row++;
    $f->new_label(
            -text => "Color Scheme: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($cscheme_cb = $f->new_ttk__combobox(
            -textvariable => \$cscheme,
            -values       => [ @cmaps ],
            -state        => 'readonly',
            -width        => 15,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $cscheme_cb->g_bind("<<ComboboxSelected>>",
                           sub { my ($n);
                                 if ($cscheme eq "None") {
                                     $ncolors_cb->g_grid_remove();
                                     $ncolors_na_label->g_grid();
                                 } else {
                                     $ncolors_na_label->g_grid_remove();
                                     $ncolors_cb->g_grid();
                                     if ($cscheme =~ /CoolWarm|Turbo|Viridis/) {
                                         $ncolors_cb->configure(-values => [ (8 .. 100) ]);
                                     } else {
                                         $ncolors_cb->configure(-values =>
                                             [ (16, 18, 20, 22, 24, 30, 34, 38, 42, 46) ]);
                                         if ($ncolors < 16) {
                                             $ncolors = 16;
                                         } elsif ($ncolors > 46) {
                                             $ncolors = 46;
                                         } else {
                                             foreach $n (reverse @valid_nc) {
                                                 if ($ncolors >= 2 *$n) {
                                                     $ncolors = 2 *$n;
                                                     last;
                                                 }
                                             }
                                         }
                                     }
                                 }
                               });

    $row++;
    $f->new_label(
            -text => "Number of Colors: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ncolors_na_label = $f->new_label(
            -text => "n/a",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $ncolors_na_label->g_grid_remove();
    ($ncolors_cb = $f->new_ttk__combobox(
            -textvariable => \$ncolors,
            -values       => [ (16, 18, 20, 22, 24, 30, 34, 38, 42, 46) ],
            -state        => 'readonly',
            -width        => 4,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Graph Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gtitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);

    if ($cscheme eq "None") {
        $ncolors_cb->g_grid_remove();
        $ncolors_na_label->g_grid();
    } else {
        $ncolors_na_label->g_grid_remove();
        $ncolors_cb->g_grid();
        if ($cscheme =~ /CoolWarm|Turbo|Viridis/) {
            $ncolors_cb->configure(-values => [ (8 .. 100) ]);
        } else {
            $ncolors_cb->configure(-values => [ (16, 18, 20, 22, 24, 30, 34, 38, 42, 46) ]);
            if ($ncolors < 16) {
                $ncolors = 16;
            } elsif ($ncolors > 46) {
                $ncolors = 46;
            } else {
                foreach $n (reverse @valid_nc) {
                    if ($ncolors >= 2 *$n) {
                        $ncolors = 2 *$n;
                        last;
                    }
                }
            }
        }
    }
    $parm_units_label->g_grid_remove();
    $parm_units_cb->g_grid_remove();

    $f->g_grid_columnconfigure(3, -weight => 2);

    Tkx::wm_resizable($profile_setup_menu,0,0);
    &adjust_window_position($profile_setup_menu);
    $profile_setup_menu->g_focus;
}


sub make_data_profile {
    my ($canv, $id, $props_updated) = @_;
    my (
        $add_dateline, $anc, $base_jd, $bot, $box_id, $cmap_image, $cs_max,
        $cs_min, $cs_range, $cs_rev, $cscheme1, $cscheme2, $data_available,
        $date_id, $date_label, $datemax, $datemin, $diff, $dsize, $dt, $dt2,
        $dy, $el_limit, $el1, $el2, $el3, $elev, $first, $geom, $got_depth,
        $group_tags, $gtag, $gtitle, $i, $id2, $ih, $item, $iw, $j, $jd,
        $jd_max, $jd_min, $jd0, $jd2, $kn_digits, $lastpt, $mi, $mismatch,
        $move_mcursor, $mult, $n, $ncolors, $new_graph, $np, $old_elev,
        $pbar, $pbar_frame, $pbar_window, $pt1_in, $pt2_in, $pval, $pval1,
        $pval2, $pval3, $resized, $surf_elev, $tag, $title_size, $top,
        $update_cs, $X, $x1, $x2, $xmax, $xmin, $xp, $xp1, $xp2, $xrange, $Y,
        $y1, $y2, $ymax, $ymin, $yp, $yp1, $yp2, $yr_max, $yr_min, $yrange,

        @colors, @coords, @depths, @elevations, @estimated, @grp_tags,
        @items, @jdates, @mydates, @old_coords, @pdata, @pt_color,
        @pt_elevations, @scale, @tags, @valid_elevs, @valid_pdata,

        %axis_props, %color_key_props, %limits, %parm_data, %parms,
        %profile, %wsurf,
       );

#   For new plots, pop up a menu for file names and parameters
    if (! defined($props{$id}{files})) {
        return &setup_data_profile($canv, $id);
    }

#   Make tag and get coordinates of graph frame
    $gtag   = "graph" . $id;
    @coords = @{ $props{$id}{coordlist} };
    ($x1, $y1, $x2, $y2) = @coords;

#   Determine whether group tags are present and save the list
    $group_tags = 0;
    @grp_tags   = ();
    @tags       = Tkx::SplitList($canv->itemcget($id, -tags));
    if (&list_search("group_", @tags) > -1) {
        $group_tags = 1;
        foreach $tag (@tags) {
            push (@grp_tags, $tag) if ($tag =~ /^group_/);
        }
    }

#   Read the file
    if (! defined($props{$id}{data})) {
        %parms              = %{ $props{$id}{parms} };
        %profile            = &read_profile($main, $props{$id}{src_file});

#       Find minimum and maximum elevation and parameter values
        %limits             = &find_data_limits($id, %profile);
        $profile{date_min}  = $limits{date_min};
        $profile{date_max}  = $limits{date_max};
        $profile{dpth_min}  = $limits{dpth_min};
        $profile{dpth_max}  = $limits{dpth_max};
        $profile{elev_min}  = $limits{elev_min};
        $profile{elev_max}  = $limits{elev_max};
        $profile{parm_min}  = $limits{parm_min};
        $profile{parm_max}  = $limits{parm_max};
        undef %limits;

        $profile{yfont}     = $default_family;
        $profile{yl_size}   = &min(11, &max(8, int((abs($x2-$x1)+abs($y2-$y1))/2./41)));
        $profile{yt_size}   = $profile{yl_size} +2;
        $profile{yl_weight} = 'normal';
        $profile{yt_weight} = 'normal';
        $profile{ytype}     = $parms{ytype};
        $profile{yunits}    = $parms{yunits};
        $profile{ymin}      = ($parms{ymin} ne "") ? $parms{ymin} : 0;
        $profile{ymax}      = $parms{ymax};
        $profile{ymajor}    = ($parms{ymajor} eq "") ? "auto" : $parms{ymajor};
        $profile{ypr_tics}  = "outside";
        $profile{yop_tics}  = "none";
        $profile{ytitle}    = $parms{ytype} . ", in " . $parms{yunits};

        $profile{xfont}     = $profile{yfont};
        $profile{xl_size}   = $profile{yl_size};
        $profile{xt_size}   = $profile{yt_size};
        $profile{xl_weight} = $profile{yl_weight};
        $profile{xt_weight} = $profile{yt_weight};
        $profile{xpr_tics}  = "outside";
        $profile{xop_tics}  = "none";

        $profile{gtfont}    = $profile{yfont};
        $profile{gt_size}   = $profile{yt_size};
        $profile{gt_weight} = 'bold';
        $profile{gtitle}    = $parms{gtitle};

        $profile{keyfont}   = $default_family;
        $profile{kn_size}   = $profile{yl_size};
        $profile{kt_size}   = $profile{yl_size} +2;
        $profile{kt_weight} = 'normal';
        $profile{kn_weight} = 'normal';
        $profile{kn_digits} = 1;
        if ($props{$id}{parm} =~ /Temperature/i) {
            $profile{keytitle} = "Water temperature, in degrees " . $props{$id}{parm_units};
        } else {
            $profile{keytitle} = $props{$id}{parm} . ", in " . $props{$id}{parm_units};
        }

        if ($parms{cscheme} eq "None") {
            $profile{add_cs}    =  0;
            $profile{cscheme1}  = "Blue";
            $profile{cscheme2}  = "Orange";
            $profile{ncolors}   = 20;
            $profile{cs_height} = &max(2, &min(18, int(($y2-$y1+1) /$profile{ncolors})));
        } else {
            $profile{add_cs}    =  1;
            $profile{cs_height} = &max(2, &min(18, int(($y2-$y1+1) /$parms{ncolors})));
            if ($parms{cscheme} eq "Blue to Orange") {
                $profile{cscheme1} = "Blue";
                $profile{cscheme2} = "Orange";
                $profile{ncolors}  = $parms{ncolors} /2;
            } elsif ($parms{cscheme} eq "Blue to Red") {
                $profile{cscheme1} = "Blue";
                $profile{cscheme2} = "Red";
                $profile{ncolors}  = $parms{ncolors} /2;
            } else {
                $profile{cscheme1} = $parms{cscheme};
                $profile{cscheme2} = "None";
                $profile{ncolors}  = $parms{ncolors};
            }
        }
        $profile{cs_min}   = $parms{pmin};
        $profile{cs_max}   = $parms{pmax};
        $profile{cs_rev}   =  0;
        $profile{cs_hide}  =  0;
        $profile{xleg_off} = 40;
        $profile{yleg_off} =  0;
        $profile{cs_width} = 24;
        $profile{cs_major} = "auto";

        if ($props{$id}{meta} eq "data_profile_cmap") {
            $profile{xmajor}    = "auto";
            $profile{datefmt}   = "Month";
            $profile{xmin}      = "first";
            $profile{xmax}      = "last";
            $profile{xtype}     = "Date/Time";
            $profile{dateline}  = 1;
            $profile{datelinec} = "black";
        } else {
            $profile{xmin}      = $parms{pmin};
            $profile{xmax}      = $parms{pmax};
            $profile{xmajor}    = ($parms{pmajor} eq "") ? "auto" : $parms{pmajor};
            $profile{xtitle}    = $profile{keytitle};
            $profile{gs_size}   = $profile{gt_size} -1;
            $profile{gs_weight} = $profile{gt_weight};
        }
        $profile{cs_link} = 0;
        if ($profile{add_cs} && @animate_ids && $#animate_ids >= 0) {
            $update_cs = 0;
            foreach $item (@animate_ids) {
                next if ($props{$item}{meta} =~ /time_series|w2_wlevels/);
                next if ($props{$item}{meta} eq "w2_outflow" && ! $props{$item}{add_parm});
                if ($gr_props{$item}{cs_link} == 2) {
                    if ($props{$item}{meta} =~ /data_profile/
                         && $props{$item}{prof_type}  eq "standard"
                         && $props{$item}{parm}       eq $props{$id}{parm}
                         && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                        $update_cs = 1;
                        $id2 = $item;
                        last;
                    } elsif ($props{$item}{meta} =~ /(w2_profile|w2_slice|w2_outflow)/
                         && $props{$item}{parm}       eq $props{$id}{parm}
                         && $props{$item}{parm_div}   eq "None"
                         && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                        $update_cs = 1;
                        $id2 = $item;
                        last;
                    } elsif ($props{$item}{meta} eq "w2_tdmap"
                         && $props{$item}{map_type}   eq "standard"
                         && $props{$item}{parm_sav}   eq $props{$id}{parm}
                         && $props{$item}{pdiv_sav}   eq "None"
                         && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                        $update_cs = 1;
                        $id2 = $item;
                        last;
                    } elsif ($props{$item}{meta} =~ /vert_wd_zone/
                         && $props{$id}{parm}       eq "Temperature"
                         && $props{$item}{wt_units} eq $props{$id}{parm_units}) {
                        $update_cs = 1;
                        $id2 = $item;
                        last;
                    }
                }
            }
            if (! $update_cs) {
                foreach $item (@animate_ids) {
                    next if ($props{$item}{meta}
                               =~ /w2_profile|w2_slice|w2_tdmap|w2_outflow|time_series|w2_wlevels/);
                    if ($gr_props{$item}{cs_link} == 1) {
                        if ($props{$item}{meta} =~ /data_profile/
                             && $props{$item}{prof_type}  eq "standard"
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}
                             && $props{$item}{src_file}   eq $props{$id}{src_file}) {
                            $update_cs = 1;
                            $id2 = $item;
                            last;
                        } elsif ($props{$item}{meta} =~ /vert_wd_zone/
                             && $props{$id}{parm}       eq "Temperature"
                             && $props{$item}{wt_units} eq $props{$id}{parm_units}
                             && $props{$item}{wt_file}  eq $props{$id}{src_file}) {
                            $update_cs = 1;
                            $id2 = $item;
                            last;
                        }
                    }
                }
            }
            if ($update_cs) {
                $ncolors           = $profile{ncolors};
                $profile{cs_link}  = $gr_props{$id2}{cs_link};
                $profile{cscheme1} = $gr_props{$id2}{cscheme1};
                $profile{cscheme2} = $gr_props{$id2}{cscheme2};
                $profile{ncolors}  = $gr_props{$id2}{ncolors};
                $profile{cs_rev}   = $gr_props{$id2}{cs_rev};
                $profile{cs_min}   = $gr_props{$id2}{cs_min};
                $profile{cs_max}   = $gr_props{$id2}{cs_max};
                $profile{cs_major} = $gr_props{$id2}{cs_major};
                if ($profile{cs_height} *$ncolors > $y2-$y1+1 && $profile{cs_height} > 2) {
                    $profile{cs_height} = &max(2, &min(18, int(($y2-$y1+1) /$profile{ncolors})));
                }
            }
        }
        $profile{redraw}  = 1;
        $gr_props{$id}    = { %profile };
        $props{$id}{data} = 1;
        $props{$id}{gnum} = ++$graph_num;
        $resized = 0;
        undef %profile;

#   Or use previously read info.  If resized, delete graph and redraw
    } else {
        @old_coords = @{ $props{$id}{oldcoords} };
        $resized = 0;
        for ($i=0; $i<=$#coords; $i++) {
            if ($coords[$i] != $old_coords[$i]) {
                $resized = 1;
                last;
            }
        }
        return if (! $resized && ! $props_updated);
        $gr_props{$id}{redraw} = 1 if ($resized);

        $canv->delete($gtag . "_xaxis");
        $canv->delete($gtag . "_xaxisTitle");
        $canv->delete($gtag . "_yaxis");
        $canv->delete($gtag . "_yaxisTitle");
        $canv->delete($gtag . "_date");
        $canv->delete($gtag . "_gtitle");
        $canv->delete($gtag . "_colorKey");
        $canv->delete($gtag . "_colorKeyTitle");
        $canv->delete($gtag . "_colorMapDateline");
        if ($gr_props{$id}{redraw}) {
            $canv->delete($gtag . "_profile");
            $canv->delete($gtag . "_colorProfile");
            $canv->delete($gtag . "_colorMap");
        }
    }
    $props{$id}{oldcoords} = [ @coords ];

#   Plot a white rectangle below the graph frame
    @items     = Tkx::SplitList($canv->find_withtag($gtag . "_main"));
    $new_graph = ($#items >= 0) ? 0 : 1;
    if ($new_graph) {
        $box_id = $canv->create_rectangle($x1, $y1, $x2, $y2,
                             -outline => "",
                             -width   => 0,
                             -fill    => &get_rgb_code("white"),
                             -tags    => $gtag . " " . $gtag . "_main");
        $canv->lower($box_id, $id);
    } else {
        $canv->coords($gtag . "_main", @coords);
        $canv->raise($id, $gtag . "_main");
    }

#   Plot Y axis
    $axis_props{min}     = $gr_props{$id}{ymin};
    $axis_props{max}     = $gr_props{$id}{ymax};
    $axis_props{major}   = $gr_props{$id}{ymajor};
    $axis_props{pr_tics} = $gr_props{$id}{ypr_tics};
    $axis_props{op_tics} = $gr_props{$id}{yop_tics};
    $axis_props{minor}   = 1;
    $axis_props{reverse} = ($gr_props{$id}{ytype} eq "Depth") ? 1 : 0;
    $axis_props{title}   = $gr_props{$id}{ytitle};
    $axis_props{font}    = $gr_props{$id}{yfont};
    $axis_props{size1}   = $gr_props{$id}{yl_size};
    $axis_props{size2}   = $gr_props{$id}{yt_size};
    $axis_props{weight1} = $gr_props{$id}{yl_weight};
    $axis_props{weight2} = $gr_props{$id}{yt_weight};
    $axis_props{side}    = "left";
    $axis_props{tags}    = $gtag . " " . $gtag . "_yaxis";
    $axis_props{coords}  = [$x1, $y2, $x1, $y1];
    $axis_props{op_loc}  = $x2;
    &make_axis($canv, %axis_props);
    undef %axis_props;

    $mult   = ($gr_props{$id}{yunits} eq "feet") ? 3.28084 : 1.0;
    $ymin   = $gr_props{$id}{ymin} /$mult;
    $ymax   = $gr_props{$id}{ymax} /$mult;
    $yrange = $ymax -$ymin;

#   Deal with optional color scheme and create optional color key
    if ($gr_props{$id}{add_cs} || $props{$id}{meta} eq "data_profile_cmap") {
        $cscheme1  = $gr_props{$id}{cscheme1};
        $cscheme2  = $gr_props{$id}{cscheme2};
        $ncolors   = $gr_props{$id}{ncolors};
        $cs_rev    = $gr_props{$id}{cs_rev};
        $cs_min    = $gr_props{$id}{cs_min};
        $cs_max    = $gr_props{$id}{cs_max};
        $kn_digits = $gr_props{$id}{kn_digits};
        if (&list_match($cscheme1, @color_scheme_names) == -1 ||
           (&list_match($cscheme1, @full_color_schemes) == -1 && &list_match($ncolors, @valid_nc) == -1) ||
           (&list_match($cscheme1, @full_color_schemes) >= 0 && &list_match($ncolors, @valid_nc_alt) == -1) ||
           ($cscheme2 ne "" && $cscheme2 ne "None" && &list_match($cscheme2, @color_scheme_names) == -1)) {
            $cscheme1  = $gr_props{$id}{cscheme1}  = "Blue";
            $cscheme2  = $gr_props{$id}{cscheme2}  = "Orange";
            $ncolors   = $gr_props{$id}{ncolors}   = 11;
            $cs_rev    = $gr_props{$id}{cs_rev}    =  0;
            $cs_min    = $gr_props{$id}{cs_min}    =  0;
            $cs_max    = $gr_props{$id}{cs_max}    = 22;
            $kn_digits = $gr_props{$id}{kn_digits} =  1;
        }
        $cs_range = $cs_max -$cs_min;
        @colors   = &make_color_scheme($ncolors, $cs_rev, $cscheme1, $cscheme2);
        @scale    = ();
        for ($i=0; $i<=$#colors+1; $i++) {
            $j = $#colors +1 -$i;
            $scale[$j] = $cs_min +$cs_range*$j/($#colors+1);
        }
        $gr_props{$id}{colors}    = [ @colors ];
        $gr_props{$id}{scale}     = [ @scale  ];

        $color_key_props{xleg}    = $x2 + $gr_props{$id}{xleg_off};
        $color_key_props{yleg}    = $y1 + $gr_props{$id}{yleg_off};
        $color_key_props{width}   = $gr_props{$id}{cs_width};
        $color_key_props{height}  = $gr_props{$id}{cs_height};
        $color_key_props{colors}  = [ @colors ];
        $color_key_props{scale}   = [ @scale  ];
        $color_key_props{title}   = $gr_props{$id}{keytitle};
        $color_key_props{font}    = $gr_props{$id}{keyfont};
        $color_key_props{size1}   = $gr_props{$id}{kn_size};
        $color_key_props{size2}   = $gr_props{$id}{kt_size};
        $color_key_props{weight1} = $gr_props{$id}{kn_weight};
        $color_key_props{weight2} = $gr_props{$id}{kt_weight};
        $color_key_props{digits}  = $kn_digits;
        $color_key_props{major}   = $gr_props{$id}{cs_major};
        $color_key_props{tags}    = $gtag . " " . $gtag . "_colorKey";
        &make_color_key($canv, %color_key_props);
        undef %color_key_props;

        if ($gr_props{$id}{cs_hide}) {
            $canv->itemconfigure($gtag . "_colorKey", -state => 'hidden');
        }
    }

#   Set some variables and populate some arrays and hashes
    $got_depth = ($gr_props{$id}{elv_dep} eq "elevation") ? 0 : 1;
    if ($got_depth) {
        @depths     = @{ $gr_props{$id}{depths} };
    } else {
        @elevations = @{ $gr_props{$id}{elevations} };
    }
    %parm_data = %{ $gr_props{$id}{pdata} };
    %wsurf     = %{ $gr_props{$id}{ws_elev} };
    @estimated = @{ $gr_props{$id}{estimated} };

#   Set the list of dates or merge the dates array if necessary
#   Add the graph to the list of animated graphs, if necessary
    @mydates = sort keys %parm_data;
    if ($props{$id}{meta} eq "data_profile") {
        if (! @animate_ids || &list_match($id, @animate_ids) == -1) {
            if (@dates && @animate_ids && $#animate_ids >= 0) {
                $mismatch = 0;
                foreach $id2 (@animate_ids) {
#                   next if ($id2 == $id);
                    next if ($props{$id2}{meta} =~ /data_profile_cmap|w2_profile_cmap|w2_tdmap|time_series/);
                    if ($props{$id2}{meta} =~ /^(w2_profile|w2_slice|w2_outflow|w2_wlevels)$/
                        || ($props{$id2}{meta} eq "data_profile"
                            && $props{$id2}{src_file} ne $props{$id}{src_file})
                        || ($props{$id2}{meta} eq "vert_wd_zone" 
                            && $props{$id2}{wt_file} ne $props{$id}{src_file})) {
                        $mismatch = 1;
                        last;
                    }
                }
                if ($mismatch) {
                    if (defined($animate_tb) && Tkx::winfo_exists($animate_tb)) {
                        if ($animate_tb->g_wm_title() eq "Animation toolbar") {
                            $animate_tb->g_destroy();
                            undef $animate_tb;
                        }
                    }
                    $dt      = $dates[$dti-1];
                    @dates   = &merge_dates(\@dates, \@mydates);
                    $dti_max = $#dates+1;
                    $dti     = 1 + &nearest_dt_index($dt, @dates);
                    $dti++ if ($dti == 0);
                }
            } else {
                @dates   = @mydates;
                $dti_max = $#dates+1;
                $dti     = 1;
                $delay   = 0.5;
            }
            $dti_old = $dti;
            push (@animate_ids, $id);
        }
        $dt = $dates[$dti-1];
        $export_menu->entryconfigure(3, -state => 'normal') if ($use_GS);
        $pref_menu->entryconfigure(0,   -state => 'normal');

    } else {
        if (! defined($cmap_datemin)) {
            $cmap_datemin = substr($mydates[0],0,8);
            $cmap_datemax = substr($mydates[$#mydates],0,8);
        } else {
            $datemin      = substr($mydates[0],0,8);
            $datemax      = substr($mydates[$#mydates],0,8);
            $cmap_datemin = $datemin if ($datemin < $cmap_datemin);
            $cmap_datemax = $datemax if ($datemax > $cmap_datemax);
        }
    }

#   A vertical profile plot is requested
    if ($props{$id}{meta} eq "data_profile") {

#       Adjust the date slightly, or to a daily value, if necessary
        if (length($dt) == 12) {
            if ($gr_props{$id}{daily}) {
                $dt = substr($dt,0,8);
            } elsif (! defined($parm_data{$dt})) {
                for ($mi=1; $mi<=10; $mi++) {
                    $dt2 = &adjust_dt($dt, $mi);
                    if (defined($parm_data{$dt2})) {
                        $dt = $dt2;
                        last;
                    }
                    $dt2 = &adjust_dt($dt, -1 *$mi);
                    if (defined($parm_data{$dt2})) {
                        $dt = $dt2;
                        last;
                    }
                }
            }
        }

#       Determine whether data are available on this date
        if (defined($wsurf{$dt}) && defined($parm_data{$dt})) {
            $data_available = 1;
        } else {
            $data_available = $np = 0;
        }

#       Plot the date as a subtitle
        $xp = ($x1+$x2)/2.;
        $yp = ($gr_props{$id}{xop_tics} =~ /outside|cross/) ? $y1-14 : $y1-6;
        $date_label = &get_formatted_date($dt);
        $date_id = $canv->create_text($xp, $yp,
                           -anchor => 's',
                           -text   => $date_label,
                           -fill   => &get_rgb_code("black"),
                           -angle  => 0,
                           -tags   => $gtag . " " . $gtag . "_date",
                           -font   => [-family     => $gr_props{$id}{gtfont},
                                       -size       => $gr_props{$id}{gs_size},
                                       -weight     => $gr_props{$id}{gs_weight},
                                       -slant      => 'roman',
                                       -underline  => 0,
                                       -overstrike => 0,
                                      ]);
        @coords = Tkx::SplitList($canv->bbox($date_id));
        $dsize  = &max(10, abs($coords[3] - $coords[1]));

#       Plot the graph title
        $canv->create_text($xp, $yp-$dsize,
                           -anchor => 's', 
                           -text   => $gr_props{$id}{gtitle},
                           -fill   => &get_rgb_code("black"),
                           -angle  => 0,
                           -tags   => $gtag . " " . $gtag . "_gtitle",
                           -font   => [-family     => $gr_props{$id}{gtfont},
                                       -size       => $gr_props{$id}{gt_size},
                                       -weight     => $gr_props{$id}{gt_weight},
                                       -slant      => 'roman',
                                       -underline  => 0,
                                       -overstrike => 0,
                                      ]);

#       Plot X axis
        $axis_props{min}     = $gr_props{$id}{xmin};
        $axis_props{max}     = $gr_props{$id}{xmax};
        $axis_props{major}   = $gr_props{$id}{xmajor};
        $axis_props{pr_tics} = $gr_props{$id}{xpr_tics};
        $axis_props{op_tics} = $gr_props{$id}{xop_tics};
        $axis_props{minor}   = 1;
        $axis_props{reverse} = 0;
        $axis_props{title}   = $gr_props{$id}{xtitle};
        $axis_props{font}    = $gr_props{$id}{xfont};
        $axis_props{size1}   = $gr_props{$id}{xl_size};
        $axis_props{size2}   = $gr_props{$id}{xt_size};
        $axis_props{weight1} = $gr_props{$id}{xl_weight};
        $axis_props{weight2} = $gr_props{$id}{xt_weight};
        $axis_props{side}    = "bottom";
        $axis_props{tags}    = $gtag . " " . $gtag . "_xaxis";
        $axis_props{coords}  = [$x1, $y2, $x2, $y2];
        $axis_props{op_loc}  = $y1;
        &make_axis($canv, %axis_props);
        undef %axis_props;

#       Don't recompute and redraw unless necessary
        if (! $gr_props{$id}{redraw}) {
            if ($gr_props{$id}{add_cs}) {
                $canv->lower($gtag . "_colorKey",      $id);
                $canv->lower($gtag . "_colorKeyTitle", $id);
                $canv->lower($gtag . "_colorProfile",  $id);
            }
            $canv->lower($gtag . "_date",       $id);
            $canv->lower($gtag . "_gtitle",     $id);
            $canv->lower($gtag . "_xaxisTitle", $id);
            $canv->lower($gtag . "_yaxisTitle", $id);
            $canv->lower($gtag . "_profile",    $id);
            $canv->lower($gtag . "_xaxis",      $id);
            $canv->lower($gtag . "_yaxis",      $id);
            if ($group_tags) {
                foreach $tag (@grp_tags) {
                    $canv->addtag($tag, withtag => $gtag);
                }
            }
            return;
        }

#       Populate the pt_elevations array.  Keep depths and elevations in meters.
        if ($data_available) {
            $surf_elev = ($wsurf{$dt} ne "na") ? $wsurf{$dt} : 0.0;
            $lastpt    = ($got_depth) ? $#depths : $#elevations;
            @pt_elevations = ();
            for ($i=0; $i<=$lastpt; $i++) {
                if ($got_depth) {
                    push (@pt_elevations, $surf_elev - $depths[$i]);
                } else {
                    push (@pt_elevations, $elevations[$i]);
                }
            }
        }

#       Analyze the vertical profile
        $xmin        = $gr_props{$id}{xmin};
        $xmax        = $gr_props{$id}{xmax};
        $xrange      = $xmax -$xmin;
        @coords      = ();
        @pt_color    = ();
        @valid_pdata = ();
        @valid_elevs = ();
        if ($data_available) {
            @pdata = @{ $parm_data{$dt} };
            if ($props{$id}{parm_units} eq "Fahrenheit") {
                $diff = ($props{$id}{prof_type} eq "difference") ? 0 : 32;
                for ($i=0; $i<=$lastpt; $i++) {
                    next if ($pdata[$i] eq "na");
                    $pdata[$i] = $pdata[$i] *1.8 +$diff;
                }
            }
            for ($i=0; $i<=$lastpt; $i++) {
                next if ($pdata[$i] eq "na");
                next if ($pt_elevations[$i] > $surf_elev +0.1/3.28084);
                next if ($gr_props{$id}{ytype} ne "Depth" && $wsurf{$dt} eq "na");
                $xp = $x1 +($x2-$x1)*($pdata[$i]-$xmin)/$xrange;
                if ($gr_props{$id}{ytype} eq "Depth") {
                    $yp = $y1 +($y2-$y1)*($surf_elev-$pt_elevations[$i])/$ymax;
                } else {
                    $yp = $y2 -($y2-$y1)*($pt_elevations[$i]-$ymin)/$yrange;
                }
                push (@coords, $xp, $yp);
                push (@valid_pdata, $pdata[$i]);
                push (@valid_elevs, $pt_elevations[$i]);
                if ($estimated[$i]) {
                    push (@pt_color, "DarkGray");
                } else {
                    push (@pt_color, "black");
                }
            }
            $np = ($#coords +1)/2;
        }

        if ($gr_props{$id}{add_cs} && $np > 1) {

#           Create an image to hold the color profile and recognize its methods
            $iw = $x2 -$x1 +1;
            $ih = $y2 -$y1 +1;
            $cmap_image = Tkx::image_create_photo(-width => $iw, -height => $ih);
            $cmap_image = Tkx::widget->new($cmap_image);
            $xp1 = 0;
            $xp2 = $iw -1;

            $old_elev = $surf_elev;
            if ($gr_props{$id}{ytype} eq "Depth") {
                $yp2 = 0;
                $el_limit = $surf_elev -$ymax;
            } else {
                $yp2 = &round_to_int($ih-1 -($ih-1)*($old_elev-$ymin)/$yrange);
                $yp2 = &max(0, &min($ih-1, $yp2));
                $el_limit = $ymin;
            }
            $dy = &max(1.0/3.28084, $yrange/($ih-1));
            for ($elev=$surf_elev-$dy; $elev>$el_limit-$dy; $elev-=$dy) {
                $yp1 = $yp2;
                if ($gr_props{$id}{ytype} eq "Depth") {
                    $yp2 = &round_to_int(($ih-1)*($surf_elev-$elev)/$ymax);
                } else {
                    $yp2 = &round_to_int($ih-1 -($ih-1)*($elev-$ymin)/$yrange);
                }
                last if ($yp1 >= $ih-1);
                if ($yp2 < 0) {
                    $old_elev = $elev;
                    $yp2 = 0;
                    next;
                }
                $yp2 = &max(0, &min($ih-1, $yp2));

#               Elevation range of interest is deeper than deepest measurement
                if ($old_elev <= $valid_elevs[$np-1]) {
                    $pval = $valid_pdata[$np-1];
                } else {
                    $first = 1;
                    for ($i=0; $i<$np; $i++) {
                        next if ($valid_elevs[$i] > $surf_elev +0.1/3.28084);
                        $el1   = $valid_elevs[$i];
                        $el2   = $valid_elevs[$i+1] if ($i < $np-1);
                        $el3   = $valid_elevs[$i-1] if ($i > 0 && ! $first);
                        $pval1 = $valid_pdata[$i];
                        $pval2 = $valid_pdata[$i+1] if ($i < $np-1);
                        $pval3 = $valid_pdata[$i-1] if ($i > 0 && ! $first);

#                       Elevation is shallower than first measurement
                        if ($first && $el1 <= $elev) {
                            $pval = $pval1;
                            last;

#                       Measurement is in the elevation range of interest
                        } elsif ($el1 < $old_elev && $el1 >= $elev) {

#                           Shallowest measurement in elevation range of interest
                            if ($first) {
                                $bot  = $pval1 + ($pval2-$pval1)*($el1-$elev)/($el1-$el2);
                                $pval = ($pval1*($old_elev-$el1)
                                        +(($pval1+$bot)/2.)*($el1-$elev))/($old_elev-$elev);
                                last;

#                           Deepest measurement in elevation range of interest
                            } elsif ($i == $np-1) {
                                $top  = $pval3 + ($pval1-$pval3)*($el3-$old_elev)/($el3-$el1);
                                $pval = ((($top+$pval1)/2.)*($old_elev-$el1)
                                        +$pval1*($el1-$elev))/($old_elev-$elev);
                                last;

#                           Not shallowest, not deepest, in range of interest
                            } else {
                                $top  = $pval3 + ($pval1-$pval3)*($el3-$old_elev)/($el3-$el1);
                                $bot  = $pval1 + ($pval2-$pval1)*($el1-$elev)/($el1-$el2);
                                $pval = ((($top+$pval1)/2.)*($old_elev-$el1)
                                        +(($pval1+$bot)/2.)*($el1-$elev))/($old_elev-$elev);
                                last;
                            }

#                       One measurement above and one below the elevation range of interest
                        } elsif ($el1 >= $old_elev && $el2 <= $elev) {
                            $top  = $pval1 + ($pval2-$pval1)*($el1-$old_elev)/($el1-$el2);
                            $bot  = $pval1 + ($pval2-$pval1)*($el1-$elev)/($el1-$el2);
                            $pval = ($top+$bot)/2.;
                            last;
                        }
                        $first = 0;
                    }
                }
                $j = int(($#colors+1) *($pval-$cs_min)/$cs_range);
                $j = &max(0, &min($#colors, $j));
                $cmap_image->put($colors[$j], -to => $xp1, $yp1, $xp2, $yp2);
                $old_elev = $elev;
                last if ($yp2 >= $ih-1);
            }
            $canv->create_image($x1, $y1, -anchor => 'nw',
                                          -image  => $cmap_image,
                                          -tags   => $gtag . " " . $gtag . "_colorProfile");
            undef $cmap_image;
        }

#       Plot the water surface and its indicator, if plotting elevations
        if ($data_available && $gr_props{$id}{ytype} ne "Depth" && $wsurf{$dt} ne "na") {
            $yp = $y2 -($y2-$y1)*($surf_elev-$ymin)/$yrange;
            if ($yp >= $y1 && $yp <= $y2) {
                $canv->create_line($x1, $yp, $x2, $yp,
                                    -fill  => &get_rgb_code("gray60"),
                                    -width => 1,
                                    -arrow => 'none',
                                    -tags  => $gtag . " " . $gtag . "_profile");
                $xp = $x1 + 0.9*($x2-$x1);
                $canv->create_polygon($xp, $yp, $xp-4, $yp-8, $xp+4, $yp-8,
                                    -outline => &get_rgb_code("gray60"),
                                    -width   => 1,
                                    -fill    => &get_rgb_code("white"),
                                    -tags    => $gtag . " " . $gtag . "_profile");
            }
        }

#       Plot the vertical profile
        if ($np > 1) {
            for ($i=1; $i<$np; $i++) {
                $xp1 = $coords[2*$i-2];
                $yp1 = $coords[2*$i-1];
                $xp2 = $coords[2*$i];
                $yp2 = $coords[2*$i+1];
                $pt1_in = ($xp1 >= $x1 && $xp1 <= $x2 &&
                           $yp1 >= $y1 && $yp1 <= $y2) ? 1 : 0;
                $pt2_in = ($xp2 >= $x1 && $xp2 <= $x2 &&
                           $yp2 >= $y1 && $yp2 <= $y2) ? 1 : 0;
                next if (! $pt1_in && ! $pt2_in);
                if (! $pt1_in) {
                    if ($xp1 < $x1) {
                        $yp = $yp1 +($yp2-$yp1) *($x1-$xp1) /($xp2-$xp1);
                        $xp = $x1;
                    } elsif ($xp1 > $x2) {
                        $yp = $yp1 +($yp2-$yp1) *($x2-$xp1) /($xp2-$xp1);
                        $xp = $x2;
                    } else {
                        $xp = $xp1 +($xp2-$xp1) *($y1-$yp1) /($yp2-$yp1);
                        $yp = $y1;
                    }
                    if ($yp < $y1) {
                        $xp = $xp1 +($xp2-$xp1) *($y1-$yp1) /($yp2-$yp1);
                        $yp = $y1;
                    }
                    $xp1 = $xp;
                    $yp1 = $yp;
                } elsif (! $pt2_in) {
                    if ($xp2 < $x1) {
                        $yp = $yp1 +($yp2-$yp1) *($x1-$xp1) /($xp2-$xp1);
                        $xp = $x1;
                    } elsif ($xp2 > $x2) {
                        $yp = $yp1 +($yp2-$yp1) *($x2-$xp1) /($xp2-$xp1);
                        $xp = $x2;
                    } else {
                        $xp = $xp1 +($xp2-$xp1) *($y2-$yp1) /($yp2-$yp1);
                        $yp = $y2;
                    }
                    if ($yp > $y2) {
                        $xp = $xp1 +($xp2-$xp1) *($y2-$yp1) /($yp2-$yp1);
                        $yp = $y2;
                    }
                    $xp2 = $xp;
                    $yp2 = $yp;
                }
                $canv->create_line($xp1, $yp1, $xp2, $yp2,
                                        -fill  => &get_rgb_code($pt_color[$i]),
                                        -width => 1,
                                        -arrow => 'none',
                                        -tags  => $gtag . " " . $gtag . "_profile");
            }
        }

#       Plot a no-data message
        if (! $data_available || $np <= 1) {
            if ($data_available && $gr_props{$id}{ytype} ne "Depth" && $wsurf{$dt} ne "na") {
                $yp  = $y2 -($y2-$y1)*($surf_elev-$ymin)/$yrange +5;
                $anc = 'n';
                if ($yp < $y1 || $yp > $y2) {
                    $yp  = ($y1 +$y2)/2.;
                    $anc = 'center';
                }
            } else {
                $yp  = ($y1 +$y2)/2.;
                $anc = 'center';
            }
            $canv->create_text(($x1+$x2)/2, $yp,
                               -anchor => $anc, 
                               -text   => "No Data",
                               -fill   => &get_rgb_code("gray60"),
                               -angle  => 0,
                               -tags   => $gtag . " " . $gtag . "_profile",
                               -font   => [-family     => $gr_props{$id}{xfont},
                                           -size       => $gr_props{$id}{xl_size},
                                           -weight     => 'normal',
                                           -slant      => 'roman',
                                           -underline  => 0,
                                           -overstrike => 0,
                                          ]);
        }
        undef %wsurf;
        undef %parm_data;

#       Plot the measured points
        for ($i=0; $i<$np; $i++) {
            $xp = $coords[2*$i];
            $yp = $coords[2*$i+1];
            if ($xp >= $x1 && $xp <= $x2 && $yp >= $y1 && $yp <= $y2) {
                if ($gr_props{$id}{add_cs}) {
                    $pval = $valid_pdata[$i];
                    $j    = int(($#colors+1) *($pval-$cs_min)/$cs_range);
                    $j    = &max(0, &min($#colors, $j));
                    $canv->create_oval($xp-3, $yp-3, $xp+3, $yp+3,
                                        -outline => &get_rgb_code($pt_color[$i]),
                                        -width   => 1,
                                        -fill    => $colors[$j],
                                        -tags    => $gtag . " " . $gtag . "_profile");
                } else {
                    $canv->create_oval($xp-3, $yp-3, $xp+3, $yp+3,
                                        -outline => &get_rgb_code($pt_color[$i]),
                                        -width   => 1,
                                        -fill    => &get_rgb_code("white"),
                                        -tags    => $gtag . " " . $gtag . "_profile");
                }
            }
        }

#       Place the graphic items in the proper order
        &raise_lower($canv, $id, "tiptop") if ($new_graph);
        if ($gr_props{$id}{add_cs}) {
            $canv->lower($gtag . "_colorKey",      $id);
            $canv->lower($gtag . "_colorKeyTitle", $id);
            $canv->lower($gtag . "_colorProfile",  $id);
        }
        $canv->lower($gtag . "_date",       $id);
        $canv->lower($gtag . "_gtitle",     $id);
        $canv->lower($gtag . "_xaxisTitle", $id);
        $canv->lower($gtag . "_yaxisTitle", $id);
        $canv->lower($gtag . "_profile",    $id);
        $canv->lower($gtag . "_xaxis",      $id);
        $canv->lower($gtag . "_yaxis",      $id);
        if ($group_tags) {
            foreach $tag (@grp_tags) {
                $canv->addtag($tag, withtag => $gtag);
            }
        }

#       Update any links
        &update_links($canv, $id, $dt);

#   A vertical profile colormap is requested
    } elsif ($props{$id}{meta} eq "data_profile_cmap") {

#       Keep track of graphs that can be animated
#       Colormaps only get a bit of animation when they have an accompanying profile
#       For first creation, ensure mouse cursor is on canvas so it can be changed
        $move_mcursor = 0;
        if (&list_match($id, @animate_ids) == -1) {
            push (@animate_ids, $id);
            $move_mcursor = 1;
        }

        @jdates = &dates2jdates(@mydates);
        if ($gr_props{$id}{xmin} eq "first" && $gr_props{$id}{xmax} eq "last") {
            $jd_min = &floor($jdates[0] +0.0000001);
            $jd_max = &floor($jdates[$#jdates] +1.0000001);
            if ($gr_props{$id}{xtype} eq "Date/Time") {
                $gr_props{$id}{xmin}    = &jdate2datelabel($jd_min, "Mon-DD-YYYY");
                $gr_props{$id}{xmax}    = &jdate2datelabel($jd_max, "Mon-DD-YYYY");
                $gr_props{$id}{base_yr} = substr($mydates[0],0,4);
            }
        } else {
            if (! defined($gr_props{$id}{base_yr})) {
                $gr_props{$id}{base_yr} = substr($mydates[0],0,4);
            }
            if ($gr_props{$id}{xtype} eq "Date/Time") {
                $jd_min = &datelabel2jdate($gr_props{$id}{xmin});
                $jd_max = &datelabel2jdate($gr_props{$id}{xmax});
            } else {
                $base_jd = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
                $jd_min  = $gr_props{$id}{xmin} +$base_jd -1;
                $jd_max  = $gr_props{$id}{xmax} +$base_jd -1;
            }
        }

#       Plot the graph title
        $yp = ($gr_props{$id}{xop_tics} =~ /outside|cross/) ? $y1-18 : $y1-10;
        $canv->create_text(($x1+$x2)/2., $yp,
                           -anchor => 's', 
                           -text   => $gr_props{$id}{gtitle},
                           -fill   => &get_rgb_code("black"),
                           -angle  => 0,
                           -tags   => $gtag . " " . $gtag . "_gtitle",
                           -font   => [-family     => $gr_props{$id}{gtfont},
                                       -size       => $gr_props{$id}{gt_size},
                                       -weight     => $gr_props{$id}{gt_weight},
                                       -slant      => 'roman',
                                       -underline  => 0,
                                       -overstrike => 0,
                                      ]);

#       Plot the X axis -- Date/Time or Julian Date
#       For the date X axis, over-ride any user-supplied axis title
        $axis_props{major}   = $gr_props{$id}{xmajor};
        $axis_props{pr_tics} = $gr_props{$id}{xpr_tics};
        $axis_props{op_tics} = $gr_props{$id}{xop_tics};
        $axis_props{minor}   = 1;
        $axis_props{reverse} = 0;
        $axis_props{font}    = $gr_props{$id}{xfont};
        $axis_props{size1}   = $gr_props{$id}{xl_size};
        $axis_props{size2}   = $gr_props{$id}{xt_size};
        $axis_props{weight1} = $gr_props{$id}{xl_weight};
        $axis_props{weight2} = $gr_props{$id}{xt_weight};
        $axis_props{side}    = "bottom";
        $axis_props{tags}    = $gtag . " " . $gtag . "_xaxis";
        $axis_props{coords}  = [$x1, $y2, $x2, $y2];
        $axis_props{op_loc}  = $y1;
        if ($gr_props{$id}{xtype} eq "Date/Time") {
            $yr_min = substr($gr_props{$id}{xmin},7,4);
            $yr_max = substr($gr_props{$id}{xmax},7,4);
            $yr_max-- if (substr($gr_props{$id}{xmax},0,3) eq "Jan" &&
                          substr($gr_props{$id}{xmax},4,2) eq "01");
            if ($yr_min == $yr_max) {
                $gr_props{$id}{xtitle} = "Date in $yr_min";
            } else {
                $gr_props{$id}{xtitle} = "Date ($yr_min-$yr_max)";
            }
            $axis_props{min}     = $jd_min;
            $axis_props{max}     = $jd_max;
            $axis_props{title}   = $gr_props{$id}{xtitle};
            $axis_props{datefmt} = $gr_props{$id}{datefmt};
            &make_date_axis($canv, %axis_props);
        } else {
            $axis_props{min}     = $gr_props{$id}{xmin};
            $axis_props{max}     = $gr_props{$id}{xmax};
            $axis_props{title}   = $gr_props{$id}{xtitle};
            &make_axis($canv, %axis_props);
        }
        undef %axis_props;

#       Plot the optional dateline
        if ($gr_props{$id}{dateline}) {
            $add_dateline = 0;
            for ($i=0; $i<=$#animate_ids; $i++) {
                $id2 = $animate_ids[$i];
                next if ($id2 == $id);
                next if ($props{$id2}{meta}
                           !~ /^(data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)$/);
                if ($dti != 1) {
                    $add_dateline = 1;
                    last;
                }
            }
            if ($add_dateline) {
                $jd = &date2jdate($dates[$dti-1]);
                if ($jd >= $jd_min && $jd <= $jd_max) {
                    $xp = $x1 + ($x2 -$x1) *($jd -$jd_min)/($jd_max -$jd_min);
                    $canv->create_line($xp, $y1, $xp, $y2,
                                       -fill  => &get_rgb_code($gr_props{$id}{datelinec}),
                                       -width => 1,
                                       -arrow => 'none',
                                       -tags  => $gtag . " " . $gtag . "_colorMapDateline");
                }
            }
        }

#       Don't recompute and redraw unless necessary
        if (! $gr_props{$id}{redraw}) {
            $canv->lower($gtag . "_colorKey",         $id);
            $canv->lower($gtag . "_colorKeyTitle",    $id);
            $canv->lower($gtag . "_gtitle",           $id);
            $canv->lower($gtag . "_xaxisTitle",       $id);
            $canv->lower($gtag . "_yaxisTitle",       $id);
            $canv->lower($gtag . "_colorMap",         $id);
            $canv->lower($gtag . "_colorMapDateline", $id);
            $canv->lower($gtag . "_xaxis",            $id);
            $canv->lower($gtag . "_yaxis",            $id);
            if ($group_tags) {
                foreach $tag (@grp_tags) {
                    $canv->addtag($tag, withtag => $gtag);
                }
            }
            return;
        }

#       Create an image to hold the colormap and recognize its methods
#       This takes time, so don't redraw if it isn't needed
        $iw = $x2 -$x1 +1;
        $ih = $y2 -$y1 +1;
        $cmap_image = Tkx::image_create_photo(-width => $iw, -height => $ih);
        $cmap_image = Tkx::widget->new($cmap_image);

#       Create a progress bar
        $geom = $main->g_wm_geometry();
        (undef, $X, $Y) = split(/\+/, $geom);
        $geom = sprintf("+%d+%d", $X+($x1+$x2)/2-150, $Y+($y1+$y2)/2);

        $pbar_window = $main->new_toplevel();
        $pbar_window->g_wm_transient($main);
        $pbar_window->g_wm_title("Working on colormap...");
        $pbar_window->g_wm_geometry($geom);
        $pbar_window->configure(-cursor => $cursor_wait);
        $pbar_window->g_focus;

        $pbar_frame = $pbar_window->new_frame(
                        -borderwidth => 2,
                        -relief      => 'groove');
        $pbar_frame->g_pack(-anchor => 'nw', -expand => 1, -fill => 'x');
        ($pbar = $pbar_frame->new_ttk__progressbar(
                        -orient  => 'horizontal',
                        -length  => 300,
                        -mode    => 'determinate',
                        -value   => 0,
                        -maximum => $jd_max -$jd_min,
                        ))->g_pack();

#       Move mouse cursor on first creation, to ensure that it changes to cursor_wait
        if ($move_mcursor) {
            if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
                $canv->g_bind("<Motion>", "");
                Tkx::event_generate($main, "<Motion>", -warp => 1, -x => ($x1+$x2)/2, -y => ($y1+$y2)/2);
                $canv->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"), $canv, "menu" ]);
            }
        }

#       Change the mouse cursor to tell the user to be patient
        if ($resized) {
            $canv->configure(-cursor => $cursor_wait);
        } else {
            Tkx::tk_busy_hold($main, -cursor => $cursor_wait);
        }
        $status_line = "Working on colormap.  Please wait...";
        Tkx::update();
        Tkx::wm_resizable($pbar_window,0,0);

#       Set elevations, if constant
        if (! $got_depth) {
            $lastpt = $#elevations;
            @pt_elevations = ();
            for ($i=0; $i<=$lastpt; $i++) {
                push (@pt_elevations, $elevations[$i]);
            }
        }

#       Create the colormap
        for ($n=0; $n<=$#jdates; $n++) {
            $jd = $jdates[$n];
            next if ($jd < $jd_min);
            last if ($jd > $jd_max);
            if ($n == 0 || $jd == $jd_min) {
                $jd2 = ($jd +$jdates[$n+1])/2.;
                $xp1 = &round_to_int(($iw-1)*($jd -$jd_min)/($jd_max-$jd_min));
                $xp2 = &round_to_int(($iw-1)*($jd2-$jd_min)/($jd_max-$jd_min));
                next if ($xp1 == $xp2);
            } elsif ($n == $#jdates || $jd == $jd_max) {
                $jd0 = ($jd +$jdates[$n-1])/2.;
                $xp1 = &round_to_int(($iw-1)*($jd0-$jd_min)/($jd_max-$jd_min));
                $xp2 = &round_to_int(($iw-1)*($jd -$jd_min)/($jd_max-$jd_min));
                $xp2 = $iw-1 if (abs($jd_max -$jd) <= 1);
            } else {
                $jd0 = ($jd +$jdates[$n-1])/2.;
                $jd2 = ($jd +$jdates[$n+1])/2.;
                $xp1 = &round_to_int(($iw-1)*($jd0-$jd_min)/($jd_max-$jd_min));
                $xp2 = &round_to_int(($iw-1)*($jd2-$jd_min)/($jd_max-$jd_min));
                next if ($xp1 == $xp2);
            }
            $xp1 = &max(0, &min($iw-1, $xp1));
            $xp2 = &max(0, &min($iw-1, $xp2));
            $pbar->configure(-value => $jd -$jd_min);  # update the progress bar
            Tkx::update_idletasks();

            $dt        = $mydates[$n];
            $surf_elev = ($wsurf{$dt} ne "na") ? $wsurf{$dt} : 0.0;
            $old_elev  = $surf_elev;
            if ($got_depth) {
                $lastpt = $#depths;
                @pt_elevations = ();
                for ($i=0; $i<=$lastpt; $i++) {
                    push (@pt_elevations, $surf_elev -$depths[$i]);
                }
            }
            $np = 0;
            @valid_pdata = ();
            @valid_elevs = ();
            for ($i=0; $i<=$lastpt; $i++) {
                next if ($parm_data{$dt}[$i] eq "na");
                next if ($pt_elevations[$i] > $surf_elev +0.1/3.28084);
                next if ($gr_props{$id}{ytype} ne "Depth" && $wsurf{$dt} eq "na");
                push (@valid_pdata, $parm_data{$dt}[$i]);
                push (@valid_elevs, $pt_elevations[$i]);
                $np++;
            }
            next if ($np < 2);

#           Convert temperature units, if needed
            if ($props{$id}{parm_units} eq "Fahrenheit") {
                $diff = ($props{$id}{prof_type} eq "difference") ? 0 : 32;
                for ($i=0; $i<=$#valid_pdata; $i++) {
                    $valid_pdata[$i] = $valid_pdata[$i] *1.8 +$diff;
                }
            }

            if ($gr_props{$id}{ytype} eq "Depth") {
                $yp2 = 0;
                $el_limit = $surf_elev -$ymax;
            } else {
                $yp2 = &round_to_int($ih-1 -($ih-1)*($old_elev-$ymin)/$yrange);
                $yp2 = &max(0, &min($ih-1, $yp2));
                $el_limit = $ymin;
            }
            $dy = &max(1.0/3.28084, $yrange/($ih-1));
            for ($elev=$surf_elev-$dy; $elev>$el_limit-$dy; $elev-=$dy) {
                $yp1 = $yp2;
                if ($gr_props{$id}{ytype} eq "Depth") {
                    $yp2 = &round_to_int(($ih-1)*($surf_elev-$elev)/$ymax);
                } else {
                    $yp2 = &round_to_int($ih-1 -($ih-1)*($elev-$ymin)/$yrange);
                }
                last if ($yp1 >= $ih-1);
                if ($yp2 < 0) {
                    $old_elev = $elev;
                    $yp2 = 0;
                    next;
                }
                $yp2 = &max(0, &min($ih-1, $yp2));

#               Elevation range of interest is deeper than deepest measurement
                if ($old_elev <= $valid_elevs[$np-1]) {
                    $pval = $valid_pdata[$np-1];
                } else {
                    $first = 1;
                    for ($i=0; $i<$np; $i++) {
                        next if ($valid_elevs[$i] > $surf_elev +0.1/3.28084);
                        $el1   = $valid_elevs[$i];
                        $el2   = $valid_elevs[$i+1] if ($i < $np-1);
                        $el3   = $valid_elevs[$i-1] if ($i > 0 && ! $first);
                        $pval1 = $valid_pdata[$i];
                        $pval2 = $valid_pdata[$i+1] if ($i < $np-1);
                        $pval3 = $valid_pdata[$i-1] if ($i > 0 && ! $first);

#                       Elevation is shallower than first measurement
                        if ($first && $el1 <= $elev) {
                            $pval = $pval1;
                            last;

#                       Measurement is in the elevation range of interest
                        } elsif ($el1 < $old_elev && $el1 >= $elev) {

#                           Shallowest measurement in elevation range of interest
                            if ($first) {
                                $bot  = $pval1 + ($pval2-$pval1)*($el1-$elev)/($el1-$el2);
                                $pval = ($pval1*($old_elev-$el1)
                                        +(($pval1+$bot)/2.)*($el1-$elev))/($old_elev-$elev);
                                last;

#                           Deepest measurement in elevation range of interest
                            } elsif ($i == $np-1) {
                                $top  = $pval3 + ($pval1-$pval3)*($el3-$old_elev)/($el3-$el1);
                                $pval = ((($top+$pval1)/2.)*($old_elev-$el1)
                                        +$pval1*($el1-$elev))/($old_elev-$elev);
                                last;

#                           Not shallowest, not deepest, in range of interest
                            } else {
                                $top  = $pval3 + ($pval1-$pval3)*($el3-$old_elev)/($el3-$el1);
                                $bot  = $pval1 + ($pval2-$pval1)*($el1-$elev)/($el1-$el2);
                                $pval = ((($top+$pval1)/2.)*($old_elev-$el1)
                                        +(($pval1+$bot)/2.)*($el1-$elev))/($old_elev-$elev);
                                last;
                            }

#                       One measurement above and one below the elevation range of interest
                        } elsif ($el1 >= $old_elev && $el2 <= $elev) {
                            $top  = $pval1 + ($pval2-$pval1)*($el1-$old_elev)/($el1-$el2);
                            $bot  = $pval1 + ($pval2-$pval1)*($el1-$elev)/($el1-$el2);
                            $pval = ($top+$bot)/2.;
                            last;
                        }
                        $first = 0;
                    }
                }
                $j = int(($#colors+1) *($pval-$cs_min)/$cs_range);
                $j = &max(0, &min($#colors, $j));
                $cmap_image->put($colors[$j], -to => $xp1, $yp1, $xp2, $yp2);
                $old_elev = $elev;
                last if ($yp2 >= $ih-1);
            }
        }
        $canv->create_image($x1, $y1, -anchor => 'nw',
                                      -image  => $cmap_image,
                                      -tags   => $gtag . " " . $gtag . "_colorMap");
        undef $cmap_image;
        undef %wsurf;
        undef %parm_data;

#       Place the graphic items in the proper order
        &raise_lower($canv, $id, "tiptop") if ($new_graph);
        $canv->lower($gtag . "_colorKey",         $id);
        $canv->lower($gtag . "_colorKeyTitle",    $id);
        $canv->lower($gtag . "_gtitle",           $id);
        $canv->lower($gtag . "_xaxisTitle",       $id);
        $canv->lower($gtag . "_yaxisTitle",       $id);
        $canv->lower($gtag . "_colorMap",         $id);
        $canv->lower($gtag . "_colorMapDateline", $id);
        $canv->lower($gtag . "_xaxis",            $id);
        $canv->lower($gtag . "_yaxis",            $id);
        if ($group_tags) {
            foreach $tag (@grp_tags) {
                $canv->addtag($tag, withtag => $gtag);
            }
        }

#       Restore mouse cursor and remove the progress bar
        $canv->configure(-cursor => $cursor_norm);
        $pbar_window->g_destroy();
        $status_line = "";
        if (! $resized) {
            Tkx::tk_busy_forget($main);
        }
    }
}


sub setup_wd_zone {
    my ($canv, $id) = @_;
    my (
        $bth_file, $cscheme, $cscheme_cb, $elbot, $elbot_frame, $elbot_entry,
        $elbot_units, $elev_base, $f, $flow_file, $frame, $geom, $gtitle,
        $gtitle_char, $lbc_btn, $lbc_file, $lbc_label1, $lbc_label2, $n,
        $ncolors, $ncolors_cb, $ncolors_na_label, $ok_btn, $qaxis_units,
        $qmajor, $qmajor_entry, $qmax, $qmax_entry, $row, $seg, $seg_entry,
        $wd_alg, $wd_cb, $wt_degunits, $wt_file, $wt_max, $wt_max_entry,
        $wt_max_label, $wt_max_units_label, $wt_min, $wt_min_entry,
        $wt_min_label, $wt_min_units_label, $wt_oldunits, $wt_units,
        $wt_units_cb, $wt_units_label, $X, $x1, $x2, $Y, $y1, $y2,
        $yaxis_type, $yaxis_type_cb, $yaxis_units, $yaxis_units_label,
        $ymajor, $ymajor_entry, $ymajor_label, $ymax, $ymax_entry,
        $ymax_label, $ymin, $ymin_entry, $ymin_label, $ymin_units_label,

        @cmaps,
       );

    ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $geom = sprintf("+%d+%d", $X+$x1+30, $Y+$y1+50);

    if (defined($wdzone_setup_menu) && Tkx::winfo_exists($wdzone_setup_menu)) {
        if ($wdzone_setup_menu->g_wm_title() eq "Withdrawal Zone Setup") {
            $wdzone_setup_menu->g_destroy();
            undef $wdzone_setup_menu;
        }
    }
    $wdzone_setup_menu = $main->new_toplevel();
    $wdzone_setup_menu->g_wm_transient($main);
    $wdzone_setup_menu->g_wm_title("Withdrawal Zone Setup");
    $wdzone_setup_menu->configure(-cursor => $cursor_norm);
    $wdzone_setup_menu->g_wm_geometry($geom);

#   Try to keep the nascent graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

    $wt_file = $bth_file = $flow_file = $lbc_file = "";
    $ymin    = $ymax     = $ymajor    = $seg      = "";
    $qmax    = $qmajor   = "";

    $yaxis_type  = "Elevation";
    $yaxis_units = "feet";
    $wt_min      =  4;
    $wt_max      = 24;
    $wt_units    = "Celsius";
    $wt_oldunits = "Celsius";
    $wt_degunits = "\N{U+00B0}" . substr($wt_units,0,1);
    $qaxis_units = "cfs/ft";
    $cscheme     = "Blue to Orange";
    $ncolors     = 20;
    $elev_base   = -999;
    $elbot       = 0;
    $wd_alg      = "W2 original";
    $elbot_units = "meters";
    $gtitle      = "Release Rate Distribution";
    $gtitle_char = length($gtitle);

#   Available initial colormaps
    @cmaps = ("None", "Blue to Orange", "Blue to Red", "CoolWarm", "Turbo", "Viridis");

    $frame = $wdzone_setup_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -state   => 'disabled',
            -command => sub { my (%parms);
                              if ($wt_file eq "" || ! -e $wt_file) {
                                  return &pop_up_error($wdzone_setup_menu,
                                  "WT Profile file not set or does not exist:\n$wt_file");
                              }
                              if ($flow_file eq "" || ! -e $flow_file) {
                                  return &pop_up_error($wdzone_setup_menu,
                                  "Outlet flow file not set or does not exist:\n$flow_file");
                              }
                              if ($bth_file eq "" || ! -e $bth_file) {
                                  return &pop_up_error($wdzone_setup_menu,
                                  "Bathymetry file not set or does not exist:\n$bth_file");
                              }
                              if ($wd_alg eq "Libby Dam" && ($lbc_file eq "" || ! -e $lbc_file)) {
                                  return &pop_up_error($wdzone_setup_menu,
                                  "Libby bulkhead configuration file not set or does not exist:\n$lbc_file");
                              }
                              if ($wt_min eq "" || $wt_max eq "") {
                                  return &pop_up_error($wdzone_setup_menu,
                                  "Please provide both a min and max water temperature.");
                              }
                              if ($wt_min >= $wt_max) {
                                  return &pop_up_error($wdzone_setup_menu,
                                  "The minimum WT must be less than the maximum WT.");
                              }
                              if ($yaxis_type eq "Elevation") {
                                  if ($ymin eq "" || $ymax eq "") {
                                      return &pop_up_error($wdzone_setup_menu,
                                      "Please provide both a min and max elevation.");
                                  }
                                  if ($ymin >= $ymax) {
                                      return &pop_up_error($wdzone_setup_menu,
                                      "The minimum elevation must be less than the maximum elevation.");
                                  }
                              } else {
                                  if ($ymax eq "") {
                                      return &pop_up_error($wdzone_setup_menu,
                                      "Please provide a maximum depth.");
                                  }
                              }
                              if ($qmax eq "" || $qmax <= 0) {
                                  return &pop_up_error($wdzone_setup_menu,
                                  "Please provide a maximum release rate that is greater than zero.");
                              }
                              if ($seg eq "" || $seg <= 0) {
                                  return &pop_up_error($wdzone_setup_menu,
                                  "Segment number must be numeric and positive.");
                              }
                              if ($elbot eq "") {
                                  return &pop_up_error($wdzone_setup_menu,
                                  "Elevation of top of bottom layer must be numeric.");
                              }
                              if ($elbot_units eq "feet") {
                                  $elbot /= 3.28084;
                              }
                              $gtitle =~ s/^\s+//;
                              $gtitle =~ s/\s+$//;

                              %parms             = ();
                              $parms{wt_min}     = $wt_min;
                              $parms{wt_max}     = $wt_max;
                              $parms{ymin}       = $ymin;
                              $parms{ymax}       = $ymax;
                              $parms{ymajor}     = $ymajor;
                              $parms{ytype}      = $yaxis_type;
                              $parms{yunits}     = $yaxis_units;
                              $parms{qmax}       = $qmax;
                              $parms{qmajor}     = $qmajor;
                              $parms{qunits}     = $qaxis_units;
                              $parms{cscheme}    = $cscheme;
                              $parms{ncolors}    = $ncolors;
                              $parms{gtitle}     = $gtitle;
                              $props{$id}{parms} = { %parms };

                              $props{$id}{files}     = 1;
                              $props{$id}{wd_alg}    = $wd_alg;
                              $props{$id}{wt_file}   = $wt_file;
                              $props{$id}{flow_file} = $flow_file;
                              $props{$id}{bth_file}  = $bth_file;
                              $props{$id}{lbc_file}  = $lbc_file;
                              $props{$id}{seg}       = $seg;
                              $props{$id}{elbot}     = $elbot;
                              $props{$id}{wt_units}  = $wt_units;

                              $wdzone_setup_menu->g_bind('<Destroy>', "");
                              $wdzone_setup_menu->g_destroy();
                              undef $wdzone_setup_menu;
                              &reset_bindings;
                              &make_wd_zone($canv, $id, 0);
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $wdzone_setup_menu->g_bind('<Destroy>', "");
                              $wdzone_setup_menu->g_destroy();
                              undef $wdzone_setup_menu;
                              $canv->delete("graph" . $id);
                              delete $props{$id};
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Delete graph if this menu is destroyed by other than the Cancel button
    $wdzone_setup_menu->g_bind('<Destroy>' => sub { undef $wdzone_setup_menu;
                                                    $canv->delete("graph" . $id);
                                                    delete $props{$id}; 
                                                    &reset_bindings;
                                                  });

    $f = $wdzone_setup_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "Withdrawal Algorithm: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($wd_cb = $f->new_ttk__combobox(
            -textvariable => \$wd_alg,
            -values       => [ ("W2 original", "Libby Dam") ],
            -state        => 'readonly',
            -width        => 12,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w', -pady => 2);
    $wd_cb->g_bind("<<ComboboxSelected>>",
                    sub { if ($wd_alg eq "Libby Dam") {
                              $lbc_label1->g_grid();
                              $lbc_label2->g_grid();
                              $lbc_btn->g_grid();
                          } else {
                              $lbc_label1->g_grid_remove();
                              $lbc_label2->g_grid_remove();
                              $lbc_btn->g_grid_remove();
                          }
                        }
                    );

    $row++;
    $f->new_label(
            -text => "WT Profile File: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$wt_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);
    $f->new_button(
            -text    => "Browse",
            -command => sub { my ($file, $status, %meta);
                              $file = Tkx::tk___getOpenFile(
                                      -parent           => $wdzone_setup_menu,
                                      -title            => "Select WT Profile File",
                                      -initialdir       => abs_path(),
                                      -defaultextension => ".csv",
                                      -filetypes => [ ['CSV (comma delimited)', '.csv'],
                                                      ['All Files',  '*'],
                                                    ],
                                      );
                              if (defined($file) && -e $file && -r $file && ! -z $file) {
                                  $wt_file = File::Spec->rel2abs($file);
                                  ($status, %meta) = &scan_profile($wdzone_setup_menu, $wt_file);
                                  if ($status ne "okay") {
                                      $wt_file = "";
                                      $ok_btn->configure(-state => 'disabled');
                                      return &pop_up_error($wdzone_setup_menu,
                                            "Specified file is not a WT Profile file "
                                          . "or is incomplete:\n$file");
                                  }
                                  if (defined($meta{parm_min}) && defined($meta{parm_max})
                                       && $meta{parm_min} ne "" && $meta{parm_max} ne ""
                                       && $meta{parm_max} > $meta{parm_min}) {
                                      $wt_min = $meta{parm_min};
                                      $wt_max = $meta{parm_max};
                                  }
                                  if (defined($meta{parm_units})
                                       && $meta{parm_units} =~ /^(Celsius|Fahrenheit)$/) {
                                      $wt_units    = $meta{parm_units};
                                      $wt_oldunits = $wt_units;
                                  }
                                  if (defined($meta{ymin}) && defined($meta{ymax})
                                       && $meta{ymin} ne "" && $meta{ymax} ne ""
                                       && $meta{ymax} > $meta{ymin}) {
                                      $ymin = $meta{ymin};
                                      $ymax = $meta{ymax};
                                      $elev_base = &min($ymin, $ymax);
                                  } elsif (defined($meta{ymax}) && $meta{ymax} ne "") {
                                      $ymax = $meta{ymax};
                                      $ymin = "";
                                  }
                                  if (defined($meta{ymajor}) && $meta{ymajor} ne "") {
                                      $ymajor = abs($meta{ymajor});
                                  }
                                  if (defined($meta{ytype})
                                       && $meta{ytype} =~ /^(Elevation|Depth)$/) {
                                      $yaxis_type = $meta{ytype};
                                      if ($yaxis_type eq "Elevation") {
                                          $ymin_label->g_grid();
                                          $ymin_entry->g_grid();
                                          $ymin_units_label->g_grid();
                                          $ymax_label->configure(-text => "Elevation Max: ");
                                          $ymajor_label->configure(-text => "Elevation Major: ");
                                          $yaxis_units_label->configure(-text => "Elevation Units: ");
                                      } else {
                                          $ymin_label->g_grid_remove();
                                          $ymin_entry->g_grid_remove();
                                          $ymin_units_label->g_grid_remove();
                                          $ymax_label->configure(-text => "Depth Max: ");
                                          $ymajor_label->configure(-text => "Depth Major: ");
                                          $yaxis_units_label->configure(-text => "Depth Units: ");
                                      }
                                  }
                                  if (defined($meta{yunits})
                                       && $meta{yunits} =~ /^(feet|meters)$/) {
                                      $yaxis_units = $meta{yunits};
                                  }
                                  if (defined($bth_file)  && -e $bth_file  &&
                                      defined($flow_file) && -e $flow_file &&
                                      ($wd_alg ne "Libby Dam" ||
                                       (defined($lbc_file) && -e $lbc_file))) {
                                      $ok_btn->configure(-state => 'normal');
                                  }
                              } else {
                                  $ok_btn->configure(-state => 'disabled');
                              }
                            },
            )->g_grid(-row => $row, -column => 4, -sticky => 'ew', -padx => 2, -pady => 2);

    $row++;
    $f->new_label(
            -text => "Outlet Flow File: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$flow_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);
    $f->new_button(
            -text    => "Browse",
            -command => sub { my ($file, $status, %meta);
                              $file = Tkx::tk___getOpenFile(
                                      -parent           => $wdzone_setup_menu,
                                      -title            => "Select Outlet Flow File",
                                      -initialdir       => abs_path(),
                                      -defaultextension => ".csv",
                                      -filetypes => [ ['CSV (comma delimited)', '.csv'],
                                                      ['All Files',  '*'],
                                                    ],
                                      );
                              if (defined($file) && -e $file) {
                                  $flow_file = File::Spec->rel2abs($file);
                                  ($status, %meta) = &scan_release_rates($wdzone_setup_menu, $flow_file);
                                  if ($status ne "okay") {
                                      $flow_file = "";
                                      $ok_btn->configure(-state => 'disabled');
                                      return &pop_up_error($wdzone_setup_menu,
                                            "Specified file is not an outlet flow file "
                                          . "or is incomplete:\n$file");
                                  }
                                  if (defined($meta{qmax}) && $meta{qmax} ne "" && $meta{qmax} > 0.0) {
                                      $qmax = $meta{qmax};
                                  }
                                  if (defined($meta{qmajor}) && $meta{qmajor} ne "") {
                                      $qmajor = abs($meta{qmajor});
                                  }
                                  if (defined($meta{qunits})
                                       && $meta{qunits} =~ /^(cfs\/ft|cms\/m|ft\/s|m\/s)$/) {
                                      $qaxis_units = $meta{qunits};
                                  }
                                  if (defined($bth_file) && -e $bth_file &&
                                      defined($wt_file)  && -e $wt_file  &&
                                      ($wd_alg ne "Libby Dam" ||
                                       (defined($lbc_file) && -e $lbc_file))) {
                                      $ok_btn->configure(-state => 'normal');
                                  }
                              } else {
                                  $ok_btn->configure(-state => 'disabled');
                              }
                            },
            )->g_grid(-row => $row, -column => 4, -sticky => 'ew', -padx => 2, -pady => 2);

    $row++;
    $f->new_label(
            -text => "W2 Bathymetry File: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$bth_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);
    $f->new_button(
            -text    => "Browse",
            -command => sub { my ($file);
                              $file = Tkx::tk___getOpenFile(
                                      -parent           => $wdzone_setup_menu,
                                      -title            => "Select W2 Bathymetry File",
                                      -initialdir       => abs_path(),
                                      -defaultextension => ".csv",
                                      -filetypes => [ ['CSV (comma delimited)', '.csv'],
                                                      ['NPT (W2 input file)', '.npt'],
                                                      ['All Files',  '*'],
                                                    ],
                                      );
                              if (defined($file) && -e $file) {
                                  $bth_file = File::Spec->rel2abs($file);
                                  if (defined($flow_file) && -e $flow_file &&
                                      defined($wt_file)   && -e $wt_file   &&
                                      ($wd_alg ne "Libby Dam" ||
                                       (defined($lbc_file) && -e $lbc_file))) {
                                      $ok_btn->configure(-state => 'normal');
                                  }
                              } else {
                                  $ok_btn->configure(-state => 'disabled');
                              }
                            },
            )->g_grid(-row => $row, -column => 4, -sticky => 'ew', -padx => 2, -pady => 2);

    $row++;
    ($lbc_label1 = $f->new_label(
            -text    => "Libby Bulkhead  \nConfiguration File: ",
            -justify => 'right',
            -font    => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($lbc_label2 = $f->new_label(
            -textvariable => \$lbc_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);
    ($lbc_btn = $f->new_button(
            -text    => "Browse",
            -command => sub { my ($file);
                              $file = Tkx::tk___getOpenFile(
                                      -parent           => $wdzone_setup_menu,
                                      -title            => "Select Bulkhead Configuration File",
                                      -initialdir       => abs_path(),
                                      -defaultextension => ".csv",
                                      -filetypes => [ ['CSV (comma delimited)', '.csv'],
                                                      ['All Files',  '*'],
                                                    ],
                                      );
                              if (defined($file) && -e $file) {
                                  $lbc_file = File::Spec->rel2abs($file);
                                  if (defined($flow_file) && -e $flow_file &&
                                      defined($wt_file)   && -e $wt_file   &&
                                      defined($bth_file)  && -e $bth_file) {
                                      $ok_btn->configure(-state => 'normal');
                                  }
                              } else {
                                  $ok_btn->configure(-state => 'disabled');
                              }
                            },
            ))->g_grid(-row => $row, -column => 4, -sticky => 'ew', -padx => 2, -pady => 2);

    $row++;
    $f->new_label(
            -text => "Segment Number: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($seg_entry = $f->new_entry(
            -textvariable => \$seg,
            -font         => 'default',
            -width        => 5,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w', -pady => 2);
    $seg_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($seg_entry);
                                             $seg =~ s/^-//;
                                             $seg = int($seg) if ($seg ne "");
                                             my $segwidth = &max(5, length($seg));
                                             $seg_entry->configure(-width => $segwidth);
                                           });

    $row++;
    $f->new_label(
            -text    => "Top Elevation  \nof Bottom Layer: ",
            -justify => 'right',
            -font    => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($elbot_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    ($elbot_entry = $elbot_frame->new_entry(
            -textvariable => \$elbot,
            -font         => 'default',
            -width        => 5,
            ))->g_pack(-side => 'left', -pady => 2);
    $elbot_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($elbot_entry);
                                               my $elbot_width = &max(5, length($elbot));
                                               $elbot_entry->configure(-width => $elbot_width);
                                             });
    $elbot_frame->new_ttk__combobox(
            -textvariable => \$elbot_units,
            -values       => [ ("feet", "meters") ],
            -state        => 'readonly',
            -width        => 7,
            )->g_pack(-side => 'left', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Y Axis Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($yaxis_type_cb = $f->new_ttk__combobox(
            -textvariable => \$yaxis_type,
            -values       => [ ("Elevation", "Depth") ],
            -state        => 'readonly',
            -width        => 10,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $yaxis_type_cb->g_bind("<<ComboboxSelected>>",
                           sub { if ($yaxis_type eq "Elevation") {
                                     $ymin_label->g_grid();
                                     $ymin_entry->g_grid();
                                     $ymin_units_label->g_grid();
                                     $ymax_label->configure(-text => "Elevation Max: ");
                                     $ymajor_label->configure(-text => "Elevation Major: ");
                                     $yaxis_units_label->configure(-text => "Elevation Units: ");
                                     if ($elev_base != -999 && $ymax ne "") {
                                         $ymin  = $elev_base;
                                         $ymax += $elev_base;
                                     } else {
                                         $ymin = "";
                                     }
                                 } else {
                                     $ymin_label->g_grid_remove();
                                     $ymin_entry->g_grid_remove();
                                     $ymin_units_label->g_grid_remove();
                                     $ymax_label->configure(-text => "Depth Max: ");
                                     $ymajor_label->configure(-text => "Depth Major: ");
                                     $yaxis_units_label->configure(-text => "Depth Units: ");
                                     if ($ymax ne "" && $ymin ne "" && $ymax -$ymin != 0) {
                                         $elev_base = &min($ymin, $ymax);
                                         $ymax      = abs($ymax -$ymin);
                                     } else {
                                         $ymax = "";
                                     }
                                     $ymin = 0;
                                 }
                               }
                          );

    $row++;
    ($ymin_label = $f->new_label(
            -text => "Elevation Min: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ymin_entry = $f->new_entry(
            -textvariable => \$ymin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $ymin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $ymin_entry ]);
    ($ymin_units_label = $f->new_label(
            -textvariable => \$yaxis_units,
            -font         => 'default',
            -anchor       => 'w',
            ))->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    ($ymax_label = $f->new_label(
            -text => "Elevation Max: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ymax_entry = $f->new_entry(
            -textvariable => \$ymax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $ymax_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($ymax_entry);
                                              $ymax =~ s/^-// if ($yaxis_type eq "Depth");
                                            });
    $f->new_label(
            -textvariable => \$yaxis_units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    ($ymajor_label = $f->new_label(
            -text => "Elevation Major: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ymajor_entry = $f->new_entry(
            -textvariable => \$ymajor,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $ymajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($ymajor_entry, 1);
                                                $ymajor =~ s/^-//;
                                              });
    $f->new_label(
            -textvariable => \$yaxis_units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    ($yaxis_units_label = $f->new_label(
            -text => "Elevation Units: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_ttk__combobox(
            -textvariable => \$yaxis_units,
            -values       => [ ("feet", "meters") ],
            -state        => 'readonly',
            -width        => 7,
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Release Rate Max: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($qmax_entry = $f->new_entry(
            -textvariable => \$qmax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $qmax_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($qmax_entry);
                                              $qmax =~ s/^-//;
                                            });
    $f->new_label(
            -textvariable => \$qaxis_units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Release Rate Major: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($qmajor_entry = $f->new_entry(
            -textvariable => \$qmajor,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $qmajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($qmajor_entry, 1);
                                                $qmajor =~ s/^-//;
                                              });
    $f->new_label(
            -textvariable => \$qaxis_units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Release Rate Units: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_ttk__combobox(
            -textvariable => \$qaxis_units,
            -values       => [ ("cfs/ft", "cms/m", "ft/s", "m/s") ],
            -state        => 'readonly',
            -width        => 7,
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "WT Color Scheme: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($cscheme_cb = $f->new_ttk__combobox(
            -textvariable => \$cscheme,
            -values       => [ @cmaps ],
            -state        => 'readonly',
            -width        => 15,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $cscheme_cb->g_bind("<<ComboboxSelected>>",
                           sub { my ($n);
                                 if ($cscheme eq "None") {
                                     $ncolors_cb->g_grid_remove();
                                     $ncolors_na_label->g_grid();
                                     $wt_min_label->g_grid_remove();
                                     $wt_min_entry->g_grid_remove();
                                     $wt_min_units_label->g_grid_remove();
                                     $wt_max_label->g_grid_remove();
                                     $wt_max_entry->g_grid_remove();
                                     $wt_max_units_label->g_grid_remove();
                                     $wt_units_label->g_grid_remove();
                                     $wt_units_cb->g_grid_remove();
                                 } else {
                                     $ncolors_na_label->g_grid_remove();
                                     $ncolors_cb->g_grid();
                                     if ($cscheme =~ /CoolWarm|Turbo|Viridis/) {
                                         $ncolors_cb->configure(-values => [ (8 .. 100) ]);
                                     } else {
                                         $ncolors_cb->configure(-values =>
                                             [ (16, 18, 20, 22, 24, 30, 34, 38, 42, 46) ]);
                                         if ($ncolors < 16) {
                                             $ncolors = 16;
                                         } elsif ($ncolors > 46) {
                                             $ncolors = 46;
                                         } else {
                                             foreach $n (reverse @valid_nc) {
                                                 if ($ncolors >= 2 *$n) {
                                                     $ncolors = 2 *$n;
                                                     last;
                                                 }
                                             }
                                         }
                                     }
                                     $wt_min_label->g_grid();
                                     $wt_min_entry->g_grid();
                                     $wt_min_units_label->g_grid();
                                     $wt_max_label->g_grid();
                                     $wt_max_entry->g_grid();
                                     $wt_max_units_label->g_grid();
                                     $wt_units_label->g_grid();
                                     $wt_units_cb->g_grid();
                                 }
                               });

    $row++;
    $f->new_label(
            -text => "Number of Colors: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ncolors_na_label = $f->new_label(
            -text => "n/a",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $ncolors_na_label->g_grid_remove();
    ($ncolors_cb = $f->new_ttk__combobox(
            -textvariable => \$ncolors,
            -values       => [ (16, 18, 20, 22, 24, 30, 34, 38, 42, 46) ],
            -state        => 'readonly',
            -width        => 4,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    ($wt_min_label = $f->new_label(
            -text => "Temperature Min: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($wt_min_entry = $f->new_entry(
            -textvariable => \$wt_min,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $wt_min_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $wt_min_entry ]);
    ($wt_min_units_label = $f->new_label(
            -textvariable => \$wt_degunits,
            -font         => 'default',
            -anchor       => 'w',
            ))->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    ($wt_max_label = $f->new_label(
            -text => "Temperature Max: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($wt_max_entry = $f->new_entry(
            -textvariable => \$wt_max,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $wt_max_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $wt_max_entry ]);
    ($wt_max_units_label = $f->new_label(
            -textvariable => \$wt_degunits,
            -font         => 'default',
            -anchor       => 'w',
            ))->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    ($wt_units_label = $f->new_label(
            -text => "Temperature Units: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($wt_units_cb = $f->new_ttk__combobox(
            -textvariable => \$wt_units,
            -values       => [ ("Celsius", "Fahrenheit") ],
            -state        => 'readonly',
            -width        => 12,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $wt_units_cb->g_bind("<<ComboboxSelected>>",
                          sub { $wt_degunits = "\N{U+00B0}" . substr($wt_units,0,1);
                                $wt_min = 0 if ($wt_min eq "-");
                                $wt_max = 0 if ($wt_max eq "-");
                                if ($wt_units eq "Celsius" && $wt_oldunits eq "Fahrenheit") {
                                    $wt_min = &floor(($wt_min -32) /1.8) if ($wt_min ne "");
                                    $wt_max = &ceil(($wt_max -32) /1.8)  if ($wt_max ne "");
                                } elsif ($wt_units eq "Fahrenheit" && $wt_oldunits eq "Celsius") {
                                    $wt_min = &floor($wt_min *1.8 +32) if ($wt_min ne "");
                                    $wt_max = &ceil($wt_max *1.8 +32)  if ($wt_max ne "");
                                }
                                $wt_oldunits = $wt_units;
                              });

    $row++;
    $f->new_label(
            -text => "Graph Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gtitle,
            -font         => 'default',
            -width        => $gtitle_char,
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);

    if ($wd_alg ne "Libby Dam") {
        $lbc_label1->g_grid_remove();
        $lbc_label2->g_grid_remove();
        $lbc_btn->g_grid_remove();
    }
    if ($cscheme eq "None") {
        $ncolors_cb->g_grid_remove();
        $ncolors_na_label->g_grid();
    } else {
        $ncolors_na_label->g_grid_remove();
        $ncolors_cb->g_grid();
        if ($cscheme =~ /CoolWarm|Turbo|Viridis/) {
            $ncolors_cb->configure(-values => [ (8 .. 100) ]);
        } else {
            $ncolors_cb->configure(-values => [ (16, 18, 20, 22, 24, 30, 34, 38, 42, 46) ]);
            if ($ncolors < 16) {
                $ncolors = 16;
            } elsif ($ncolors > 46) {
                $ncolors = 46;
            } else {
                foreach $n (reverse @valid_nc) {
                    if ($ncolors >= 2 *$n) {
                        $ncolors = 2 *$n;
                        last;
                    }
                }
            }
        }
    }
    $f->g_grid_columnconfigure(3, -weight => 2);

    Tkx::wm_resizable($wdzone_setup_menu,0,0);
    &adjust_window_position($wdzone_setup_menu);
    $wdzone_setup_menu->g_focus;
}


sub make_wd_zone {
    my ($canv, $id, $props_updated) = @_;
    my (
        $anc, $b_ref, $bot, $box_id, $cmap_image, $cs_max, $cs_min,
        $cs_range, $cs_rev, $cscheme1, $cscheme2, $data_available, $date_id,
        $date_label, $do_calcs, $dsize, $dt, $dt2, $el1, $el2, $el3, $first,
        $flow_data, $got_depth, $group_tags, $gtag, $h_ref, $height, $i,
        $id2, $ih, $item, $iw, $j, $k, $kb, $kmx, $kn_digits, $last_xp,
        $lastpt, $mi, $mismatch, $msg, $mult, $n, $ncolors, $new_graph,
        $nout, $np, $nww, $qmult, $qsum, $resized, $surf_elev, $tag, $top,
        $tout, $tsum, $update_cs, $wt1, $wt2, $wt3, $x1, $x2, $xp, $y1,
        $y2, $ymax, $ymin, $yp, $yp1, $yp2, $yrange,

        @b, @colors, @coords, @depths, @el, @elevations, @estr, @grp_tags,
        @h, @items, @kbsw, @ktsw, @lw, @mydates, @names, @noutlets,
        @nslots, @old_coords, @pt_elevations, @qout, @qstr, @qtot, @rho,
        @scale, @sw_alg, @t, @tags, @tstr, @valid_elevs, @valid_temps,
        @vtot, @ww_names,

        %axis_props, %bh_config, %bh_parms, %color_key_props, %ds_parms,
        %limits, %parms, %profile, %qdata, %qtot_data, %rel_data, %tdata,
        %temps, %vtot_data, %wsurf,
       );

#   For new plots, pop up a menu for file names and parameters
    if (! defined($props{$id}{files})) {
        return &setup_wd_zone($canv, $id);
    }

#   Make tag and get coordinates of graph frame
    $gtag   = "graph" . $id;
    @coords = @{ $props{$id}{coordlist} };
    ($x1, $y1, $x2, $y2) = @coords;

#   Determine whether group tags are present and save the list
    $group_tags = 0;
    @grp_tags   = ();
    @tags       = Tkx::SplitList($canv->itemcget($id, -tags));
    if (&list_search("group_", @tags) > -1) {
        $group_tags = 1;
        foreach $tag (@tags) {
            push (@grp_tags, $tag) if ($tag =~ /^group_/);
        }
    }

#   Read the data files, if not done already
    if (! defined($props{$id}{data})) {
        %parms    = %{ $props{$id}{parms} };
        %profile  = &read_profile($main, $props{$id}{wt_file});
        %rel_data = &read_release_rates($main, $props{$id}{flow_file});
        if ($profile{daily} != $rel_data{daily}) {
            $canv->delete($gtag);
            delete $props{$id};
            return &pop_up_error($main, "The input temperature and release-rate data\n"
                                      . "are not on the same time scale.  One is daily\n"
                                      . "and the other is subdaily.  Please start over.");
        }
        ($kmx, $kb, $h_ref, $b_ref) = &read_bth_slice($main, $props{$id}{seg}, $props{$id}{bth_file});
        @h  = @{ $h_ref };
        @b  = @{ $b_ref };
        @el = ();
        $el[$kmx] = $props{$id}{elbot};
        for ($k=$kmx-1; $k>=1; $k--) {
            $el[$k] = $el[$k+1] +$h[$k];
        }
        $profile{kmx} = $kmx;
        $profile{kb}  = $kb;
        $profile{b}   = [ @b  ];
        $profile{el}  = [ @el ];

        @ktsw = @{ $rel_data{ktsw} };
        @kbsw = @{ $rel_data{kbsw} };
        for ($n=0; $n<$rel_data{nout}; $n++) {
            $ktsw[$n] = $kb       if ($ktsw[$n] > $kb);                    # already >= 2
            $kbsw[$n] = $kb       if ($kbsw[$n] > $kb || $kbsw[$n] == 0);  # 0 if not in input file
            $kbsw[$n] = $ktsw[$n] if ($kbsw[$n] < $ktsw[$n]);
        }
        $profile{ktsw}   = [ @ktsw ];
        $profile{kbsw}   = [ @kbsw ];
        $profile{nout}   = $rel_data{nout};
        $profile{sw_alg} = $rel_data{sw_alg};
        $profile{names}  = $rel_data{names};
        $profile{estr}   = $rel_data{estr};
        $profile{lw}     = $rel_data{lw};
        $profile{qdata}  = $rel_data{qdata};

        %limits            = &find_data_limits($id, %profile);
        $profile{date_min} = $limits{date_min};
        $profile{date_max} = $limits{date_max};
        $profile{dpth_min} = $limits{dpth_min};
        $profile{dpth_max} = $limits{dpth_max};
        $profile{elev_min} = $limits{elev_min};
        $profile{elev_max} = $limits{elev_max};
        $profile{parm_min} = $limits{parm_min};
        $profile{parm_max} = $limits{parm_max};
        $profile{flow_min} = $limits{flow_min};
        $profile{flow_max} = $limits{flow_max};
        undef %limits;

        if ($props{$id}{wd_alg} eq "Libby Dam") {
            %bh_config          = &read_libby_config($main, $props{$id}{lbc_file});
            $profile{num_ww}    = $bh_config{num_ww};
            $profile{ww_names}  = $bh_config{ww_names};
            $profile{num_outs}  = $bh_config{num_outs};
            $profile{num_slots} = $bh_config{num_slots};
            $profile{num_rows}  = $bh_config{num_rows};
            $profile{bh_width}  = $bh_config{bh_width};
            $profile{bh_height} = $bh_config{bh_height};
            $profile{base_elev} = $bh_config{base_elev};
            $profile{hlc_base}  = $bh_config{hlc_base};
            $profile{hlc_inc}   = $bh_config{hlc_inc};
            $profile{bh_miss}   = $bh_config{bh_miss};

            @sw_alg = @{ $rel_data{sw_alg} };
            $nww = -1;
            for ($n=0; $n<=$#sw_alg; $n++) {
                $nww++ if ($sw_alg[$n] eq "LibbyDam");
            }
            if ($nww +1 != $bh_config{num_ww}) {
                return &pop_up_error($main,
                                  "Libby bulkhead configuration file is inconsistent with\n"
                                . "outflow release file in terms of the number of outlets\n"
                                . "using Libby-Dam-like wet-well selective withdrawal:\n"
                                . "  $props{$id}{lbc_file}\n  $props{$id}{flow_file}");
            }
            undef %bh_config;
        }

        $profile{yfont}     = $default_family;
        $profile{yl_size}   = &min(11, &max(8, int((abs($x2-$x1)+abs($y2-$y1))/2./41)));
        $profile{yt_size}   = $profile{yl_size} +2;
        $profile{yl_weight} = 'normal';
        $profile{yt_weight} = 'normal';
        $profile{ytype}     = $parms{ytype};
        $profile{yunits}    = $parms{yunits};
        $profile{ymin}      = $parms{ymin};
        $profile{ymax}      = $parms{ymax};
        $profile{ymajor}    = ($parms{ymajor} eq "") ? "auto" : $parms{ymajor};
        $profile{ypr_tics}  = "outside";
        $profile{yop_tics}  = "none";
        $profile{ytitle}    = $parms{ytype} . ", in " . $parms{yunits};

        $profile{xfont}     = $profile{yfont};
        $profile{xl_size}   = $profile{yl_size};
        $profile{xt_size}   = $profile{yt_size};
        $profile{xl_weight} = $profile{yl_weight};
        $profile{xt_weight} = $profile{yt_weight};
        $profile{xmin}      = 0;
        $profile{xmax}      = $parms{qmax};
        $profile{xmajor}    = $parms{qmajor};
        $profile{xpr_tics}  = "outside";
        $profile{xop_tics}  = "none";
        $profile{qunits}    = $parms{qunits};
        if ($parms{qunits} eq "cfs/ft") {
            $profile{xtitle} = "Release Rate, in cfs/(vert. ft)";
        } elsif ($parms{qunits} eq "cms/m") {
            $profile{xtitle} = "Release Rate, in cms/(vert. m)";
        } elsif ($parms{qunits} eq "ft/s") {
            $profile{xtitle} = "Velocity, in ft/s";
        } else {
            $profile{xtitle} = "Velocity, in m/s";
        }

        $profile{gtfont}    = $profile{yfont};
        $profile{gt_size}   = $profile{yt_size};
        $profile{gs_size}   = $profile{gt_size} -1;
        $profile{gt_weight} = 'bold';
        $profile{gs_weight} = $profile{gt_weight};
        $profile{gtitle}    = $parms{gtitle};

        $profile{keyfont}   = $default_family;
        $profile{keytitle}  = "Water temperature, in degrees " . $props{$id}{wt_units};
        $profile{kn_size}   = $profile{yl_size};
        $profile{kt_size}   = $profile{yl_size} +2;
        $profile{kt_weight} = 'normal';
        $profile{kn_weight} = 'normal';
        $profile{kn_digits} = 1;

        if ($props{$id}{wd_alg} eq "Libby Dam") {
            $profile{bh_show}   = ($parms{ytype} eq "Depth") ? 0 : 1;
            $profile{bh_docked} = 1;
            $profile{bh_xpos}   = -99;
            $profile{bh_ypos}   = -99;
            $profile{bh_bcellh} = -99;
            $profile{bh_font}   = $profile{yfont};
            $profile{bh_size}   = $profile{yl_size};
            $profile{bh_weight} = 'normal';
            $profile{bh_tcolor} = "black";
            $profile{bh_bwidth} = 1;
            $profile{bh_bcolor} = "black";
            $profile{bh_bcellw} = 18;
        }

        if ($parms{cscheme} eq "None") {
            $profile{add_cs}    =  0;
            $profile{cscheme1}  = "Blue";
            $profile{cscheme2}  = "Orange";
            $profile{ncolors}   = 20;
            $profile{cs_height} = &max(2, &min(18, int(($y2-$y1+1) /$profile{ncolors})));
        } else {
            $profile{add_cs}    =  1;
            $profile{cs_height} = &max(2, &min(18, int(($y2-$y1+1) /$parms{ncolors})));
            if ($parms{cscheme} eq "Blue to Orange") {
                $profile{cscheme1} = "Blue";
                $profile{cscheme2} = "Orange";
                $profile{ncolors}  = $parms{ncolors} /2;
            } elsif ($parms{cscheme} eq "Blue to Red") {
                $profile{cscheme1} = "Blue";
                $profile{cscheme2} = "Red";
                $profile{ncolors}  = $parms{ncolors} /2;
            } else {
                $profile{cscheme1} = $parms{cscheme};
                $profile{cscheme2} = "None";
                $profile{ncolors}  = $parms{ncolors};
            }
        }
        $profile{cs_min}   = $parms{wt_min};
        $profile{cs_max}   = $parms{wt_max};
        $profile{cs_rev}   =  0;
        $profile{cs_hide}  =  0;
        $profile{xleg_off} = 40;
        $profile{yleg_off} =  0;
        $profile{cs_width} = 24;
        $profile{cs_major} = "auto";

        $profile{cs_link} = 0;
        if ($profile{add_cs} && @animate_ids && $#animate_ids >= 0) {
            $update_cs = 0;
            foreach $item (@animate_ids) {
                next if ($props{$item}{meta} =~ /time_series|w2_wlevels/);
                next if ($props{$item}{meta} eq "w2_outflow" && ! $props{$item}{add_parm});
                if ($gr_props{$item}{cs_link} == 2) {
                    if ($props{$item}{meta} =~ /data_profile/
                         && $props{$item}{prof_type}  eq "standard"
                         && $props{$item}{parm}       eq "Temperature"
                         && $props{$item}{parm_units} eq $props{$id}{wt_units}) {
                        $update_cs = 1;
                        $id2 = $item;
                        last;
                    } elsif ($props{$item}{meta} =~ /w2_profile|w2_slice|w2_outflow/
                         && $props{$item}{parm}       eq "Temperature"
                         && $props{$item}{parm_div}   eq "None"
                         && $props{$item}{parm_units} eq $props{$id}{wt_units}) {
                        $update_cs = 1;
                        $id2 = $item;
                        last;
                    } elsif ($props{$item}{meta} eq "w2_tdmap"
                         && $props{$item}{map_type}   eq "standard"
                         && $props{$item}{parm_sav}   eq "Temperature"
                         && $props{$item}{pdiv_sav}   eq "None"
                         && $props{$item}{parm_units} eq $props{$id}{wt_units}) {
                        $update_cs = 1;
                        $id2 = $item;
                        last;
                    } elsif ($props{$item}{meta} =~ /vert_wd_zone/
                         && $props{$item}{wt_units} eq $props{$id}{wt_units}) {
                        $update_cs = 1;
                        $id2 = $item;
                        last;
                    }
                }
            }
            if (! $update_cs) {
                foreach $item (@animate_ids) {
                    next if ($props{$item}{meta}
                               =~ /w2_profile|w2_slice|w2_tdmap|w2_outflow|time_series|w2_wlevels/);
                    if ($gr_props{$item}{cs_link} == 1) {
                        if ($props{$item}{meta} =~ /vert_wd_zone/
                             && $props{$item}{wt_units} eq $props{$id}{wt_units}
                             && $props{$item}{wt_file}  eq $props{$id}{wt_file}) {
                            $update_cs = 1;
                            $id2 = $item;
                            last;
                        } elsif ($props{$item}{meta} =~ /data_profile/
                             && $props{$item}{prof_type}  eq "standard"
                             && $props{$item}{parm}       eq "Temperature"
                             && $props{$item}{parm_units} eq $props{$id}{wt_units}
                             && $props{$item}{src_file}   eq $props{$id}{wt_file}) {
                            $update_cs = 1;
                            $id2 = $item;
                            last;
                        }
                    }
                }
            }
            if ($update_cs) {
                $ncolors           = $profile{ncolors};
                $profile{cs_link}  = $gr_props{$id2}{cs_link};
                $profile{cscheme1} = $gr_props{$id2}{cscheme1};
                $profile{cscheme2} = $gr_props{$id2}{cscheme2};
                $profile{ncolors}  = $gr_props{$id2}{ncolors};
                $profile{cs_rev}   = $gr_props{$id2}{cs_rev};
                $profile{cs_min}   = $gr_props{$id2}{cs_min};
                $profile{cs_max}   = $gr_props{$id2}{cs_max};
                $profile{cs_major} = $gr_props{$id2}{cs_major};
                if ($profile{cs_height} *$ncolors > $y2-$y1+1 && $profile{cs_height} > 2) {
                    $profile{cs_height} = &max(2, &min(18, int(($y2-$y1+1) /$profile{ncolors})));
                }
            }
        }
        $profile{redraw}  = 1;
        $gr_props{$id}    = { %profile };
        $props{$id}{data} = 1;
        $props{$id}{gnum} = ++$graph_num;
        $resized = 0;
        undef %profile;

#   Or use previously read info.  If resized, delete graph and redraw
    } else {
        @old_coords = @{ $props{$id}{oldcoords} };
        $resized = 0;
        for ($i=0; $i<=$#coords; $i++) {
            if ($coords[$i] != $old_coords[$i]) {
                $resized = 1;
                last;
            }
        }
        return if (! $resized && ! $props_updated);
        $gr_props{$id}{redraw} = 1 if ($resized);

        $canv->delete($gtag . "_xaxis");
        $canv->delete($gtag . "_xaxisTitle");
        $canv->delete($gtag . "_yaxis");
        $canv->delete($gtag . "_yaxisTitle");
        $canv->delete($gtag . "_date");
        $canv->delete($gtag . "_gtitle");
        $canv->delete($gtag . "_colorKey");
        $canv->delete($gtag . "_colorKeyTitle");
        $canv->delete($gtag . "_openBH");
        if ($gr_props{$id}{redraw}) {
            $canv->delete($gtag . "_profile");
            $canv->delete($gtag . "_colorProfile");
        }
    }
    $props{$id}{oldcoords} = [ @coords ];

#   Set the list of dates or merge the dates array if necessary
#   Add the graph to the list of animated graphs, if necessary
    %wsurf = %{ $gr_props{$id}{ws_elev} };
    %temps = %{ $gr_props{$id}{pdata}   };
    if (! @animate_ids || &list_match($id, @animate_ids) == -1) {
        @mydates = sort keys %temps;
        if (@dates && @animate_ids && $#animate_ids >= 0) {
            $mismatch = 0;
            foreach $id2 (@animate_ids) {
#               next if ($id2 == $id);
                next if ($props{$id2}{meta} =~ /data_profile_cmap|w2_profile_cmap|w2_tdmap|time_series/);
                if ($props{$id2}{meta} =~ /^(w2_profile|w2_slice|w2_outflow|w2_wlevels)$/
                     || ($props{$id2}{meta} eq "vert_wd_zone"
                         && $props{$id2}{wt_file} ne $props{$id}{wt_file})
                     || ($props{$id2}{meta} eq "data_profile"
                         && $props{$id2}{src_file} ne $props{$id}{wt_file})) {
                    $mismatch = 1;
                    last;
                }
            }
            if ($mismatch) {
                if (defined($animate_tb) && Tkx::winfo_exists($animate_tb)) {
                    if ($animate_tb->g_wm_title() eq "Animation toolbar") {
                        $animate_tb->g_destroy();
                        undef $animate_tb;
                    }
                }
                $dt      = $dates[$dti-1];
                @dates   = &merge_dates(\@dates, \@mydates);
                $dti_max = $#dates+1;
                $dti     = 1 + &nearest_dt_index($dt, @dates);
                $dti++ if ($dti == 0);
            }
        } else {
            @dates   = @mydates;
            $dti_max = $#dates+1;
            $dti     = 1;
            $delay   = 0.5;
        }
        $dti_old = $dti;
        push (@animate_ids, $id);
    }
    $dt = $dates[$dti-1];
    $export_menu->entryconfigure(3, -state => 'normal') if ($use_GS);
    $pref_menu->entryconfigure(0,   -state => 'normal');

#   Adjust the date slightly, or to a daily value, if necessary
    if (length($dt) == 12) {
        if ($gr_props{$id}{daily}) {
            $dt = substr($dt,0,8);
        } elsif (! defined($temps{$dt})) {
            for ($mi=1; $mi<=10; $mi++) {
                $dt2 = &adjust_dt($dt, $mi);
                if (defined($temps{$dt2})) {
                    $dt = $dt2;
                    last;
                }
                $dt2 = &adjust_dt($dt, -1 *$mi);
                if (defined($temps{$dt2})) {
                    $dt = $dt2;
                    last;
                }
            }
        }
    }

#   Plot a white rectangle below the graph frame
    @items     = Tkx::SplitList($canv->find_withtag($gtag . "_main"));
    $new_graph = ($#items >= 0) ? 0 : 1;
    if ($new_graph) {
        $box_id = $canv->create_rectangle($x1, $y1, $x2, $y2,
                             -outline => "",
                             -width   => 0,
                             -fill    => &get_rgb_code("white"),
                             -tags    => $gtag . " " . $gtag . "_main");
        $canv->lower($box_id, $id);
    } else {
        $canv->coords($gtag . "_main", @coords);
        $canv->raise($id, $gtag . "_main");
    }

#   Plot the date as a subtitle
    $xp = ($x1+$x2)/2.;
    $yp = ($gr_props{$id}{xop_tics} =~ /outside|cross/) ? $y1-14 : $y1-6;
    $date_label = &get_formatted_date($dt);
    $date_id = $canv->create_text($xp, $yp,
                       -anchor => 's',
                       -text   => $date_label,
                       -fill   => &get_rgb_code("black"),
                       -angle  => 0,
                       -tags   => $gtag . " " . $gtag . "_date",
                       -font   => [-family     => $gr_props{$id}{gtfont},
                                   -size       => $gr_props{$id}{gs_size},
                                   -weight     => $gr_props{$id}{gs_weight},
                                   -slant      => 'roman',
                                   -underline  => 0,
                                   -overstrike => 0,
                                  ]);
    @coords = Tkx::SplitList($canv->bbox($date_id));
    $dsize  = &max(10, abs($coords[3] - $coords[1]));

#   Plot the graph title
    $canv->create_text($xp, $yp-$dsize,
                       -anchor => 's', 
                       -text   => $gr_props{$id}{gtitle},
                       -fill   => &get_rgb_code("black"),
                       -angle  => 0,
                       -tags   => $gtag . " " . $gtag . "_gtitle",
                       -font   => [-family     => $gr_props{$id}{gtfont},
                                   -size       => $gr_props{$id}{gt_size},
                                   -weight     => $gr_props{$id}{gt_weight},
                                   -slant      => 'roman',
                                   -underline  => 0,
                                   -overstrike => 0,
                                  ]);

#   Plot the Y axis
    $axis_props{min}     = $gr_props{$id}{ymin};
    $axis_props{max}     = $gr_props{$id}{ymax};
    $axis_props{major}   = $gr_props{$id}{ymajor};
    $axis_props{pr_tics} = $gr_props{$id}{ypr_tics};
    $axis_props{op_tics} = $gr_props{$id}{yop_tics};
    $axis_props{minor}   = 1;
    $axis_props{reverse} = ($gr_props{$id}{ytype} eq "Depth") ? 1 : 0;
    $axis_props{title}   = $gr_props{$id}{ytitle};
    $axis_props{font}    = $gr_props{$id}{yfont};
    $axis_props{size1}   = $gr_props{$id}{yl_size};
    $axis_props{size2}   = $gr_props{$id}{yt_size};
    $axis_props{weight1} = $gr_props{$id}{yl_weight};
    $axis_props{weight2} = $gr_props{$id}{yt_weight};
    $axis_props{side}    = "left";
    $axis_props{tags}    = $gtag . " " . $gtag . "_yaxis";
    $axis_props{coords}  = [$x1, $y2, $x1, $y1];
    $axis_props{op_loc}  = $x2;
    &make_axis($canv, %axis_props);
    undef %axis_props;

#   Plot the X axis
    $axis_props{min}     = $gr_props{$id}{xmin};
    $axis_props{max}     = $gr_props{$id}{xmax};
    $axis_props{major}   = $gr_props{$id}{xmajor};
    $axis_props{pr_tics} = $gr_props{$id}{xpr_tics};
    $axis_props{op_tics} = $gr_props{$id}{xop_tics};
    $axis_props{minor}   = 1;
    $axis_props{reverse} = 0;
    $axis_props{title}   = $gr_props{$id}{xtitle};
    $axis_props{font}    = $gr_props{$id}{xfont};
    $axis_props{size1}   = $gr_props{$id}{xl_size};
    $axis_props{size2}   = $gr_props{$id}{xt_size};
    $axis_props{weight1} = $gr_props{$id}{xl_weight};
    $axis_props{weight2} = $gr_props{$id}{xt_weight};
    $axis_props{side}    = "bottom";
    $axis_props{tags}    = $gtag . " " . $gtag . "_xaxis";
    $axis_props{coords}  = [$x1, $y2, $x2, $y2];
    $axis_props{op_loc}  = $y1;
    &make_axis($canv, %axis_props);
    undef %axis_props;

#   Deal with optional color scheme and create optional color key
    if ($gr_props{$id}{add_cs}) {
        $cscheme1  = $gr_props{$id}{cscheme1};
        $cscheme2  = $gr_props{$id}{cscheme2};
        $ncolors   = $gr_props{$id}{ncolors};
        $cs_rev    = $gr_props{$id}{cs_rev};
        $cs_min    = $gr_props{$id}{cs_min};
        $cs_max    = $gr_props{$id}{cs_max};
        $kn_digits = $gr_props{$id}{kn_digits};
        if (&list_match($cscheme1, @color_scheme_names) == -1 ||
           (&list_match($cscheme1, @full_color_schemes) == -1 && &list_match($ncolors, @valid_nc) == -1) ||
           (&list_match($cscheme1, @full_color_schemes) >= 0 && &list_match($ncolors, @valid_nc_alt) == -1) ||
           ($cscheme2 ne "" && $cscheme2 ne "None" && &list_match($cscheme2, @color_scheme_names) == -1)) {
            $cscheme1  = $gr_props{$id}{cscheme1}  = "Blue";
            $cscheme2  = $gr_props{$id}{cscheme2}  = "Orange";
            $ncolors   = $gr_props{$id}{ncolors}   = 11;
            $cs_rev    = $gr_props{$id}{cs_rev}    =  0;
            $cs_min    = $gr_props{$id}{cs_min}    =  0;
            $cs_max    = $gr_props{$id}{cs_max}    = 22;
            $kn_digits = $gr_props{$id}{kn_digits} =  1;
        }
        $cs_range = $cs_max -$cs_min;
        @colors   = &make_color_scheme($ncolors, $cs_rev, $cscheme1, $cscheme2);
        @scale    = ();
        for ($i=0; $i<=$#colors+1; $i++) {
            $j = $#colors +1 -$i;
            $scale[$j] = $cs_min +$cs_range*$j/($#colors+1);
        }
        $gr_props{$id}{colors}    = [ @colors ];
        $gr_props{$id}{scale}     = [ @scale  ];

        $color_key_props{xleg}    = $x2 + $gr_props{$id}{xleg_off};
        $color_key_props{yleg}    = $y1 + $gr_props{$id}{yleg_off};
        $color_key_props{width}   = $gr_props{$id}{cs_width};
        $color_key_props{height}  = $gr_props{$id}{cs_height};
        $color_key_props{colors}  = [ @colors ];
        $color_key_props{scale}   = [ @scale  ];
        $color_key_props{title}   = $gr_props{$id}{keytitle};
        $color_key_props{font}    = $gr_props{$id}{keyfont};
        $color_key_props{size1}   = $gr_props{$id}{kn_size};
        $color_key_props{size2}   = $gr_props{$id}{kt_size};
        $color_key_props{weight1} = $gr_props{$id}{kn_weight};
        $color_key_props{weight2} = $gr_props{$id}{kt_weight};
        $color_key_props{digits}  = $kn_digits;
        $color_key_props{major}   = $gr_props{$id}{cs_major};
        $color_key_props{tags}    = $gtag . " " . $gtag . "_colorKey";
        &make_color_key($canv, %color_key_props);
        undef %color_key_props;

        if ($gr_props{$id}{cs_hide}) {
            $canv->itemconfigure($gtag . "_colorKey", -state => 'hidden');
        }
    }

#   Plot the number of bulkhead openings, if asked
    if ($props{$id}{wd_alg} eq "Libby Dam" && $gr_props{$id}{bh_show}) {
        $bh_parms{ymin}      = $gr_props{$id}{ymin};
        $bh_parms{ymax}      = $gr_props{$id}{ymax};
        $bh_parms{ytype}     = $gr_props{$id}{ytype};
        $bh_parms{yunits}    = $gr_props{$id}{yunits};
        $bh_parms{num_ww}    = $gr_props{$id}{num_ww};
        $bh_parms{ww_names}  = $gr_props{$id}{ww_names};
        $bh_parms{num_rows}  = $gr_props{$id}{num_rows};
        $bh_parms{bh_height} = $gr_props{$id}{bh_height};  # meters
        $bh_parms{base_elev} = $gr_props{$id}{base_elev};  # meters
        $bh_parms{surf_elev} = $wsurf{$dt};                # meters
        $bh_parms{bh_miss}   = $gr_props{$id}{bh_miss};
        $bh_parms{bh_font}   = $gr_props{$id}{bh_font};
        $bh_parms{bh_size}   = $gr_props{$id}{bh_size};
        $bh_parms{bh_weight} = $gr_props{$id}{bh_weight};
        $bh_parms{bh_tcolor} = $gr_props{$id}{bh_tcolor};
        $bh_parms{bh_bwidth} = $gr_props{$id}{bh_bwidth};
        $bh_parms{bh_bcolor} = $gr_props{$id}{bh_bcolor};
        $bh_parms{bh_bcellw} = $gr_props{$id}{bh_bcellw};
        $bh_parms{bh_docked} = $gr_props{$id}{bh_docked};
        $bh_parms{bh_xpos}   = $gr_props{$id}{bh_xpos};
        $bh_parms{bh_ypos}   = $gr_props{$id}{bh_ypos};
        $bh_parms{bh_bcellh} = $gr_props{$id}{bh_bcellh};

        &make_bulkhead_graphic($canv, $id, $dt, %bh_parms);
        undef %bh_parms;
    }

#   Don't recompute and redraw unless necessary
    if (! $gr_props{$id}{redraw}) {
        if ($gr_props{$id}{add_cs}) {
            $canv->lower($gtag . "_colorKey",      $id);
            $canv->lower($gtag . "_colorKeyTitle", $id);
            $canv->lower($gtag . "_colorProfile",  $id);
        }
        $canv->lower($gtag . "_date",       $id);
        $canv->lower($gtag . "_gtitle",     $id);
        $canv->lower($gtag . "_xaxisTitle", $id);
        $canv->lower($gtag . "_yaxisTitle", $id);
        $canv->lower($gtag . "_profile",    $id);
        $canv->lower($gtag . "_xaxis",      $id);
        $canv->lower($gtag . "_yaxis",      $id);
        if ($props{$id}{wd_alg} eq "Libby Dam" && $gr_props{$id}{bh_show}) {
            $canv->lower($gtag . "_openBH", $id);
        }
        if ($group_tags) {
            foreach $tag (@grp_tags) {
                $canv->addtag($tag, withtag => $gtag);
            }
        }
        return;
    }

#   Set some variables and populate some arrays and hashes
    $got_depth = ($gr_props{$id}{elv_dep} eq "elevation") ? 0 : 1;
    if ($got_depth) {
        @depths     = @{ $gr_props{$id}{depths} };
    } else {
        @elevations = @{ $gr_props{$id}{elevations} };
    }

#   Determine whether data are available on this date
    if (defined($wsurf{$dt}) && defined($temps{$dt})) {
        $data_available = $flow_data = 1;
    } else {
        $data_available = $flow_data = $np = 0;
    }

#   Populate the pt_elevations array.  Keep elevations and depths in meters.
    if ($data_available) {
        $surf_elev = ($wsurf{$dt} ne "na") ? $wsurf{$dt} : 0.0;
        $lastpt    = ($got_depth) ? $#depths : $#elevations;
        @pt_elevations = ();
        for ($i=0; $i<=$lastpt; $i++) {
            if ($got_depth) {
                push (@pt_elevations, $surf_elev - $depths[$i]);
            } else {
                push (@pt_elevations, $elevations[$i]);
            }
        }
        $mult   = ($gr_props{$id}{yunits} eq "feet") ? 3.28084 : 1.0;
        $ymin   = $gr_props{$id}{ymin} /$mult;
        $ymax   = $gr_props{$id}{ymax} /$mult;
        $yrange = $ymax -$ymin;
    }

#   Interpolate the WT profile to the model layers.  Keep temperature in Celsius for now.
    if ($data_available) {
        $kb = $gr_props{$id}{kb};
        @el = @{ $gr_props{$id}{el} };
        @t  = ();
        $np = 0;
        @valid_temps = ();
        @valid_elevs = ();
        for ($i=0; $i<=$lastpt; $i++) {
            next if ($temps{$dt}[$i] eq "na");
            next if ($pt_elevations[$i] > $surf_elev +0.1/3.28084);
            next if ($gr_props{$id}{ytype} ne "Depth" && $wsurf{$dt} eq "na");
            push (@valid_temps, $temps{$dt}[$i]);
            push (@valid_elevs, $pt_elevations[$i]);
            $np++;
        }
    }
    undef %temps;

    if ($np > 0) {
        for ($k=2; $k<=$kb; $k++) {
            if ($el[$k+1] >= $surf_elev) {
                $t[$k] = -999.;
                next;
            }

#           Elevation range of interest is deeper than deepest measurement
            if ($el[$k] <= $valid_elevs[$np-1]) {
                $t[$k] = $valid_temps[$np-1];

            } else {
                if ($el[$k] > $surf_elev) {
                    $height = $surf_elev -$el[$k+1];
                } else {
                    $height = $el[$k] -$el[$k+1];
                }
                $first = 1;
                for ($i=0; $i<$np; $i++) {
                    next if ($valid_elevs[$i] > $surf_elev +0.1/3.28084);
                    $el1 = $valid_elevs[$i];
                    $el2 = $valid_elevs[$i+1] if ($i < $np-1);
                    $el3 = $valid_elevs[$i-1] if ($i > 0 && ! $first);
                    $wt1 = $valid_temps[$i];
                    $wt2 = $valid_temps[$i+1] if ($i < $np-1);
                    $wt3 = $valid_temps[$i-1] if ($i > 0 && ! $first);

#                   Elevation is shallower than first measurement
                    if ($first && $el1 <= $el[$k+1]) {
                        $t[$k] = $wt1;
                        last;

#                   Measurement is in the elevation range of interest
                    } elsif ($el1 < $el[$k] && $el1 >= $el[$k+1]) {

#                       Shallowest measurement in elevation range of interest
                        if ($first) {
                            $bot   = $wt1 + ($wt2-$wt1)*($el1-$el[$k+1])/($el1-$el2);
                            $t[$k] = ($wt1*(&min($el[$k], $surf_elev)-$el1)
                                    +(($wt1+$bot)/2.)*($el1-$el[$k+1]))/$height;
                            last;

#                       Deepest measurement in elevation range of interest
                        } elsif ($i == $np-1) {
                            $top   = $wt3 + ($wt1-$wt3)*($el3-$el[$k])/($el3-$el1);
                            $t[$k] = ((($top+$wt1)/2.)*($el[$k]-$el1)
                                    +$wt1*($el1-$el[$k+1]))/$height;
                            last;

#                       Not shallowest, not deepest, in range of interest
                        } else {
                            $top   = $wt3 + ($wt1-$wt3)*($el3-$el[$k])/($el3-$el1);
                            $bot   = $wt1 + ($wt2-$wt1)*($el1-$el[$k+1])/($el1-$el2);
                            $t[$k] = ((($top+$wt1)/2.)*($el[$k]-$el1)
                                    +(($wt1+$bot)/2.)*($el1-$el[$k+1]))/$height;
                            last;
                        }

#                   One measurement above and one below the elevation range of interest
                    } elsif ($el1 >= $el[$k] && $el2 <= $el[$k+1]) {
                        $top   = $wt1 + ($wt2-$wt1)*($el1-$el[$k])  /($el1-$el2);
                        $bot   = $wt1 + ($wt2-$wt1)*($el1-$el[$k+1])/($el1-$el2);
                        $t[$k] = ($top+$bot)/2.;
                        last;
                    }
                    $first = 0;
                }
            }
        }

#       Determine whether flow data are available
#       and whether computations have already been completed for this date
        %qdata     = %{ $gr_props{$id}{qdata} };
        $flow_data = (defined($qdata{$dt})) ? 1 : 0;
        $do_calcs  = 0;
        if ($flow_data) {
            $do_calcs = 1;
            if (defined($gr_props{$id}{qtot_data})) {
                %tdata     = %{ $gr_props{$id}{tdata}     };
                %qtot_data = %{ $gr_props{$id}{qtot_data} };
                %vtot_data = %{ $gr_props{$id}{vtot_data} };
                if (defined($qtot_data{$dt})) {
                    $do_calcs = 0;                 # computations already done for this date
                    @qtot = @{ $qtot_data{$dt} };  # layer outflows in cms/m
                    @vtot = @{ $vtot_data{$dt} };  # layer velocities in m/s
                }
            } else {
                %tdata = %qtot_data = %vtot_data = ();
            }
        }

#       Do the outflow computations if not already completed
        if ($flow_data && $do_calcs) {
            @qstr = @{ $qdata{$dt} };
            @tstr = ();

#           Set parameters for computing vertical withdrawal zone
            @qtot = @vtot = ();
            for ($k=2; $k<=$kb; $k++) {
                $qtot[$k] = $vtot[$k] = 0;
            }
            $qsum   = 0;
            $tsum   = 0;
            $nout   = $gr_props{$id}{nout};
            @sw_alg = @{ $gr_props{$id}{sw_alg} };
            @names  = @{ $gr_props{$id}{names}  };
            @estr   = @{ $gr_props{$id}{estr}   };
            @lw     = @{ $gr_props{$id}{lw}     };
            @ktsw   = @{ $gr_props{$id}{ktsw}   };
            @kbsw   = @{ $gr_props{$id}{kbsw}   };
            @b      = @{ $gr_props{$id}{b}      };

#           Compute water densities
            @rho = ();
            for ($k=2; $k<=$kb; $k++) {
                next if ($t[$k] == -999.);
                $rho[$k] = ((((6.536332E-9*$t[$k]-1.120083E-6)*$t[$k]+1.001685E-4)*$t[$k]
                              -9.09529E-3)*$t[$k]+6.793952E-2)*$t[$k]+999.842594;
            }

#           Collect data needed for selective withdrawal routines
            $ds_parms{kb}   = $kb;
            $ds_parms{kmx}  = $gr_props{$id}{kmx};
            $ds_parms{wsel} = $surf_elev;      # meters
            $ds_parms{b}    = [ @b   ];        # meters
            $ds_parms{el}   = [ @el  ];        # meters
            $ds_parms{wt}   = [ @t   ];        # deg C
            $ds_parms{rho}  = [ @rho ];        # kg/cu.m.

            if ($props{$id}{wd_alg} eq "Libby Dam") {
                $ds_parms{num_rows}  = $gr_props{$id}{num_rows};
                $ds_parms{bh_width}  = $gr_props{$id}{bh_width};      # meters
                $ds_parms{bh_height} = $gr_props{$id}{bh_height};     # meters
                $ds_parms{base_elev} = $gr_props{$id}{base_elev};     # meters
                $ds_parms{hlc_base}  = $gr_props{$id}{hlc_base};
                $ds_parms{hlc_inc}   = $gr_props{$id}{hlc_inc};
                $ds_parms{bh_miss}   = $gr_props{$id}{bh_miss};
                @nslots              = @{ $gr_props{$id}{num_slots} };
                @ww_names            = @{ $gr_props{$id}{ww_names}  };
                @noutlets            = @{ $gr_props{$id}{num_outs}  };
            }

#           Loop over the outlets
            for ($n=0; $n<$nout; $n++) {
                if ($qstr[$n] == 0.) {
                    $tstr[$n] = -99.;
                    next;
                }
                $ds_parms{qstr} = $qstr[$n];         # cms
                $ds_parms{ktsw} = $ktsw[$n];
                $ds_parms{kbsw} = $kbsw[$n];

#               Compute flows to a discrete outlet using original W2 algorithm
                if ($sw_alg[$n] eq "W2orig") {
                    $ds_parms{estr} = $estr[$n];     # meters
                    $ds_parms{wstr} = $lw[$n];       # meters
                    ($tout, @qout)  = &downstream_withdrawal(%ds_parms);

#               Compute flows over/through bulkhead stacks to a wet well
#               using the new Libby Dam algorithm
                } elsif ($sw_alg[$n] eq "LibbyDam") {

#                   The wet well number is found by matching outlet names
                    $nww = &list_match($names[$n], @ww_names);
                    if ($nww == -1 || $nww > $gr_props{$id}{num_ww} -1) {
                        return &pop_up_error($main,
                                  "Failed to match the name of the wet well to\n"
                                . "one of the named outlets in the release rate file:\n"
                                . "  $props{$id}{lbc_file}\n  $props{$id}{flow_file}");
                    }
                    $ds_parms{nslots}   = $nslots[$nww];
                    $ds_parms{noutlets} = $noutlets[$nww];

                    ($tout, @qout) = &libby_calcs($nww, $dt, %ds_parms);
                }

                $qsum += $qstr[$n];          # Note: qstr[] and qout[] in cms
                $tsum += $qstr[$n] *$tout;   # and tout is in deg Celsius
                for ($k=2; $k<=$kb; $k++) {
                    $qtot[$k] += $qout[$k];
                }
                $tstr[$n] = $tout;
            }
            undef %ds_parms;

            $tstr[$nout] = ($qsum > 0) ? $tsum /$qsum : -99.;
            $tdata{$dt}  = [ @tstr ];
            $gr_props{$id}{tdata} = { %tdata };    # in deg Celsius

#           Adjust flow per unit height (cms/m) and compute velocity (m/s)
            for ($k=2; $k<=$kb; $k++) {
                next if ($el[$k+1] >= $surf_elev);
                $height    = &min($surf_elev, $el[$k]) -$el[$k+1];
                $vtot[$k]  = $qtot[$k] /($height *$b[$k]);
                $qtot[$k] /= $height;
            }
            $qtot_data{$dt} = [ @qtot ];
            $vtot_data{$dt} = [ @vtot ];
            $gr_props{$id}{qtot_data} = { %qtot_data };  # layer outflows in cms/m
            $gr_props{$id}{vtot_data} = { %vtot_data };  # layer velocities in m/s
        }
        undef %qdata;
    }

#   Plot the water surface and its indicator, if plotting elevations
    if ($data_available && $gr_props{$id}{ytype} ne "Depth" && $wsurf{$dt} ne "na") {
        $yp = $y2 -($y2-$y1)*($surf_elev-$ymin)/$yrange;
        if ($yp >= $y1 && $yp <= $y2) {
            $canv->create_line($x1, $yp, $x2, $yp,
                                -fill  => &get_rgb_code("gray60"),
                                -width => 1,
                                -arrow => 'none',
                                -tags  => $gtag . " " . $gtag . "_profile");
            $xp = $x1 + 0.9*($x2-$x1);
            $canv->create_polygon($xp, $yp, $xp-4, $yp-8, $xp+4, $yp-8,
                                -outline => &get_rgb_code("gray60"),
                                -width   => 1,
                                -fill    => &get_rgb_code("white"),
                                -tags    => $gtag . " " . $gtag . "_profile");
        }
    }

#   Plot a no-data message
    if ($np == 0 || ! $flow_data) {
        if ($data_available && $gr_props{$id}{ytype} ne "Depth" && $wsurf{$dt} ne "na") {
            $yp  = $y2 -($y2-$y1)*($surf_elev-$ymin)/$yrange +5;
            $anc = 'n';
            if ($yp < $y1 || $yp > $y2) {
                $yp  = ($y1 +$y2)/2.;
                $anc = 'center';
            }
        } else {
            $yp  = ($y1 +$y2)/2.;
            $anc = 'center';
        }
        $msg = ($np == 0) ? "No Data" : "No Outlet Flow Data";
        $canv->create_text(($x1+$x2)/2, $yp,
                            -anchor => $anc, 
                            -text   => $msg,
                            -fill   => &get_rgb_code("gray60"),
                            -angle  => 0,
                            -tags   => $gtag . " " . $gtag . "_profile",
                            -font   => [-family     => $gr_props{$id}{xfont},
                                        -size       => $gr_props{$id}{xl_size},
                                        -weight     => 'normal',
                                        -slant      => 'roman',
                                        -underline  => 0,
                                        -overstrike => 0,
                                       ]);
    }
    undef %wsurf;

#   Draw the layer-specific flow graph
    if ($np > 0 && $flow_data) {

#       Create an image to hold the color profile and recognize its methods
        if ($gr_props{$id}{add_cs}) {
            $iw = $x2 -$x1 +1;
            $ih = $y2 -$y1 +1;
            $cmap_image = Tkx::image_create_photo(-width => $iw, -height => $ih);
            $cmap_image = Tkx::widget->new($cmap_image);
        }

        if ($gr_props{$id}{qunits} eq "cfs/ft") {      # outflow per unit height
            $qmult = 10.763911;
        } elsif ($gr_props{$id}{qunits} eq "cms/m") {  # outflow per unit height
            $qmult = 1.0;
        } else {                                       # swap for velocity data
            @qtot  = @vtot;
            $qmult = ($gr_props{$id}{qunits} eq "ft/s") ? 3.28084 : 1.0;
        }
        @coords  = ();
        $last_xp = $x1;
        for ($k=2; $k<=$kb; $k++) {
            next if ($el[$k+1] >= $surf_elev);
            if ($gr_props{$id}{ytype} eq "Depth") {
                last if ($surf_elev -$el[$k] > $ymax);
            } else {
                next if ($el[$k+1] > $ymax);
                last if ($el[$k]   < $ymin);
            }
            if ($gr_props{$id}{add_cs}) {
                $xp = &round_to_int(&min($iw-1, ($iw-1)*$qtot[$k]*$qmult/$gr_props{$id}{xmax}));
                if ($xp > 0) {
                    if ($gr_props{$id}{ytype} eq "Depth") {
                        $yp1 = &round_to_int(($ih-1)*(&max(0.0, $surf_elev-$el[$k]))/$ymax);
                        $yp2 = &round_to_int(($ih-1)*($surf_elev-$el[$k+1])/$ymax);
                    } else {
                        $yp1 = &round_to_int($ih-1 -($ih-1)*(&min($surf_elev, $el[$k])-$ymin) /$yrange);
                        $yp2 = &round_to_int($ih-1 -($ih-1)*($el[$k+1]-$ymin)/$yrange);
                    }
                    $yp1 = &max(0, &min($ih-1, $yp1));
                    $yp2 = &max(0, &min($ih-1, $yp2));
                    if ($props{$id}{wt_units} eq "Fahrenheit") {
                        $j = int(($#colors+1) *(($t[$k] *1.8 +32)-$cs_min)/$cs_range);
                    } else {
                        $j = int(($#colors+1) *($t[$k]-$cs_min)/$cs_range);
                    }
                    $j = &max(0, &min($#colors, $j));
                    $cmap_image->put($colors[$j], -to => 0, $yp1, $xp, $yp2);
                }
            }
            $xp = &min($x2, $x1 +($x2-$x1)*$qtot[$k]*$qmult/$gr_props{$id}{xmax});
            if ($gr_props{$id}{ytype} eq "Depth") {
                $yp1 = $y1 +($y2-$y1)*(&max(0.0, $surf_elev-$el[$k]))/$ymax;
                $yp2 = $y1 +($y2-$y1)*($surf_elev-$el[$k+1])/$ymax;
            } else {
                $yp1 = $y2 -($y2-$y1)*(&min($surf_elev, $el[$k])-$ymin)/$yrange;
                $yp2 = $y2 -($y2-$y1)*($el[$k+1]-$ymin)/$yrange;
            }
            $yp1 = &max($y1, &min($y2, $yp1));
            $yp2 = &max($y1, &min($y2, $yp2));
            if ($xp == $last_xp) {
                push (@coords, $xp, $yp1) if ($#coords < 0);
                push (@coords, $xp, $yp2);
            } else {
                push (@coords, $last_xp, $yp1, $xp, $yp1, $xp, $yp2);
            }
            if ($k == $kb && $xp != $x1) {
                push (@coords, $x1, $yp2);
            }
            $last_xp = $xp;
            last if ($yp2 == $y2);
        }
        if ($gr_props{$id}{add_cs}) {
            $canv->create_image($x1, $y1, -anchor => 'nw',
                                          -image  => $cmap_image,
                                          -tags   => $gtag . " " . $gtag . "_colorProfile");
            undef $cmap_image;
        }

#       Plot the flow graph
        if ($#coords >= 3) {
            $canv->create_line(@coords, -fill  => &get_rgb_code("black"),
                                        -width => 1,
                                        -arrow => 'none',
                                        -tags  => $gtag . " " . $gtag . "_profile");
        }
    }

#   Place the graphic items in the proper order
    &raise_lower($canv, $id, "tiptop") if ($new_graph);
    if ($gr_props{$id}{add_cs}) {
        $canv->lower($gtag . "_colorKey",      $id);
        $canv->lower($gtag . "_colorKeyTitle", $id);
        $canv->lower($gtag . "_colorProfile",  $id);
    }
    $canv->lower($gtag . "_date",       $id);
    $canv->lower($gtag . "_gtitle",     $id);
    $canv->lower($gtag . "_xaxisTitle", $id);
    $canv->lower($gtag . "_yaxisTitle", $id);
    $canv->lower($gtag . "_profile",    $id);
    $canv->lower($gtag . "_xaxis",      $id);
    $canv->lower($gtag . "_yaxis",      $id);
    if ($props{$id}{wd_alg} eq "Libby Dam" && $gr_props{$id}{bh_show}) {
        $canv->lower($gtag . "_openBH", $id);
    }
    if ($group_tags) {
        foreach $tag (@grp_tags) {
            $canv->addtag($tag, withtag => $gtag);
        }
    }

#   Update any links
    &update_links($canv, $id, $dt);
}


sub generate_outflow_temps {
    my ($id, $ts_id) = @_;
    my (
        $bot, $dd, $dt, $el1, $el2, $el3, $first, $geom, $got_depth, $height,
        $i, $k, $kb, $lastpt, $n, $nout, $np, $nww, $pbar, $pbar_frame,
        $pbar_txt, $pbar_window, $qsum, $surf_elev, $top, $tout, $tsum,
        $wt1, $wt2, $wt3, $X, $x1, $x2, $Y, $y1, $y2,

        @b, @depths, @el, @elevations, @estr, @kbsw, @ktsw, @lw, @mydates,
        @names, @noutlets, @nslots, @pt_elevations, @qout, @qstr, @qtot,
        @rho, @sw_alg, @t, @tstr, @valid_elevs, @valid_temps, @vtot,
        @ww_names,

        %ds_parms, %qdata, %qtot_data, %tdata, %temps, %vtot_data, %wsurf,
       );

    $pbar_txt = "Computing outlet temperatures.";
    if (! defined($ts_id) || $ts_id == 0) {
        $ts_id = $id;
        $pbar_txt = "Computing layer outflows.";
    }

#   Set some variables and populate some arrays and hashes
    $got_depth = ($gr_props{$id}{elv_dep} eq "elevation") ? 0 : 1;
    if ($got_depth) {
        @depths     = @{ $gr_props{$id}{depths} };
    } else {
        @elevations = @{ $gr_props{$id}{elevations} };
    }
    if (defined($gr_props{$id}{qtot_data})) {
        %tdata     = %{ $gr_props{$id}{tdata}     };
        %qtot_data = %{ $gr_props{$id}{qtot_data} };
        %vtot_data = %{ $gr_props{$id}{vtot_data} };
    } else {
        %tdata = %qtot_data = %vtot_data = ();
    }
    $nout   = $gr_props{$id}{nout};
    $kb     = $gr_props{$id}{kb};
    @sw_alg = @{ $gr_props{$id}{sw_alg}  };
    @names  = @{ $gr_props{$id}{names}   };
    @estr   = @{ $gr_props{$id}{estr}    };
    @lw     = @{ $gr_props{$id}{lw}      };
    @ktsw   = @{ $gr_props{$id}{ktsw}    };
    @kbsw   = @{ $gr_props{$id}{kbsw}    };
    @b      = @{ $gr_props{$id}{b}       };
    @el     = @{ $gr_props{$id}{el}      };
    %qdata  = %{ $gr_props{$id}{qdata}   };
    %wsurf  = %{ $gr_props{$id}{ws_elev} };
    %temps  = %{ $gr_props{$id}{pdata}   };

#   Dates for computations
    @mydates = sort keys %temps;

#   Collect data needed for selective withdrawal routines
    %ds_parms       = ();
    $ds_parms{kb}   = $kb;
    $ds_parms{kmx}  = $gr_props{$id}{kmx};
    $ds_parms{b}    = [ @b  ];                                # meters
    $ds_parms{el}   = [ @el ];                                # meters
    if ($props{$id}{wd_alg} eq "Libby Dam") {
        $ds_parms{num_rows}  = $gr_props{$id}{num_rows};
        $ds_parms{bh_width}  = $gr_props{$id}{bh_width};      # meters
        $ds_parms{bh_height} = $gr_props{$id}{bh_height};     # meters
        $ds_parms{base_elev} = $gr_props{$id}{base_elev};     # meters
        $ds_parms{hlc_base}  = $gr_props{$id}{hlc_base};
        $ds_parms{hlc_inc}   = $gr_props{$id}{hlc_inc};
        $ds_parms{bh_miss}   = $gr_props{$id}{bh_miss};
        @nslots              = @{ $gr_props{$id}{num_slots} };
        @ww_names            = @{ $gr_props{$id}{ww_names}  };
        @noutlets            = @{ $gr_props{$id}{num_outs}  };
    }

#   Create a progress bar
    ($x1, $y1, $x2, $y2) = @{ $props{$ts_id}{coordlist} };
    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $geom = sprintf("+%d+%d", $X+($x1+$x2)/2-150, $Y+($y1+$y2)/2);

    $pbar_window = $main->new_toplevel();
    $pbar_window->g_wm_transient($main);
    $pbar_window->g_wm_title($pbar_txt . "..");
    $pbar_window->g_wm_geometry($geom);
    $pbar_window->configure(-cursor => $cursor_wait);

    $pbar_frame = $pbar_window->new_frame(
                        -borderwidth => 2,
                        -relief      => 'groove');
    $pbar_frame->g_pack(-anchor => 'nw', -expand => 1, -fill => 'x');
    ($pbar = $pbar_frame->new_ttk__progressbar(
                        -orient  => 'horizontal',
                        -length  => 300,
                        -mode    => 'determinate',
                        -value   => 0,
                        -maximum => $#mydates,
                        ))->g_pack();

#   Move mouse cursor to ensure that it changes to cursor_wait
    if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
        $canvas->g_bind("<Motion>", "");
        Tkx::event_generate($main, "<Motion>", -warp => 1, -x => ($x1+$x2)/2, -y => ($y1+$y2)/2);
        $canvas->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"), $canvas, "menu" ]);
    }

#   Change the mouse cursor to alert the user to be patient
    $status_line = $pbar_txt . "  Please wait...";
    $canvas->configure(-cursor => $cursor_wait);
    $pbar_window->g_focus;
    Tkx::tk_busy_hold($main, -cursor => $cursor_wait);
    Tkx::update();
    Tkx::wm_resizable($pbar_window,0,0);

#   Loop over the dates for this graph
    for ($dd=0; $dd<=$#mydates; $dd++) {
        $dt = $mydates[$dd];
        $pbar->configure(-value => $dd);  # update the progress bar
        Tkx::update_idletasks();
        next if (! defined($wsurf{$dt}) || ! defined($temps{$dt}) || ! defined($qdata{$dt}));
        next if ($wsurf{$dt} eq "na");
        next if (defined($tdata{$dt}));

#       Initialize the temperature array for each outlet
        @tstr = ();
        for ($n=0; $n<=$nout; $n++) {
            $tstr[$n] = -99.;
        }

#       Populate the pt_elevations array.  Keep elevations and depths in meters.
        $surf_elev = $wsurf{$dt};
        $lastpt    = ($got_depth) ? $#depths : $#elevations;
        @pt_elevations = ();
        for ($i=0; $i<=$lastpt; $i++) {
            if ($got_depth) {
                push (@pt_elevations, $surf_elev - $depths[$i]);
            } else {
                push (@pt_elevations, $elevations[$i]);
            }
        }

#       Test for sufficient temperature data to proceed
        $np = 0;
        @valid_temps = ();
        @valid_elevs = ();
        for ($i=0; $i<=$lastpt; $i++) {
            next if ($temps{$dt}[$i] eq "na");
            next if ($pt_elevations[$i] > $surf_elev +0.1/3.28084);
            push (@valid_temps, $temps{$dt}[$i]);
            push (@valid_elevs, $pt_elevations[$i]);
            $np++;
        }
        if ($np == 0) {
            $tdata{$dt} = [ @tstr ];
            next;
        }

#       Interpolate the WT profile to the model layers
        @t = ();
        for ($k=2; $k<=$kb; $k++) {
            if ($el[$k+1] >= $surf_elev) {
                $t[$k] = -999.;
                next;
            }

#           Elevation range of interest is deeper than deepest measurement
            if ($el[$k] <= $valid_elevs[$np-1]) {
                $t[$k] = $valid_temps[$np-1];

            } else {
                if ($el[$k] > $surf_elev) {
                    $height = $surf_elev -$el[$k+1];
                } else {
                    $height = $el[$k] -$el[$k+1];
                }
                $first = 1;
                for ($i=0; $i<=$lastpt; $i++) {
                    next if ($valid_elevs[$i] > $surf_elev +0.1/3.28084);
                    $el1 = $valid_elevs[$i];
                    $el2 = $valid_elevs[$i+1] if ($i < $np-1);
                    $el3 = $valid_elevs[$i-1] if ($i > 0 && ! $first);
                    $wt1 = $valid_temps[$i];
                    $wt2 = $valid_temps[$i+1] if ($i < $np-1);
                    $wt3 = $valid_temps[$i-1] if ($i > 0 && ! $first);

#                   Elevation is shallower than first measurement
                    if ($first && $el1 <= $el[$k+1]) {
                        $t[$k] = $wt1;
                        last;

#                   Measurement is in the elevation range of interest
                    } elsif ($el1 < $el[$k] && $el1 >= $el[$k+1]) {

#                       Shallowest measurement in elevation range of interest
                        if ($first) {
                            $bot   = $wt1 + ($wt2-$wt1)*($el1-$el[$k+1])/($el1-$el2);
                            $t[$k] = ($wt1*(&min($el[$k], $surf_elev)-$el1)
                                    +(($wt1+$bot)/2.)*($el1-$el[$k+1]))/$height;
                            last;

#                       Deepest measurement in elevation range of interest
                        } elsif ($i == $np-1) {
                            $top   = $wt3 + ($wt1-$wt3)*($el3-$el[$k])/($el3-$el1);
                            $t[$k] = ((($top+$wt1)/2.)*($el[$k]-$el1)
                                    +$wt1*($el1-$el[$k+1]))/$height;
                            last;

#                       Not shallowest, not deepest, in range of interest
                        } else {
                            $top   = $wt3 + ($wt1-$wt3)*($el3-$el[$k])/($el3-$el1);
                            $bot   = $wt1 + ($wt2-$wt1)*($el1-$el[$k+1])/($el1-$el2);
                            $t[$k] = ((($top+$wt1)/2.)*($el[$k]-$el1)
                                    +(($wt1+$bot)/2.)*($el1-$el[$k+1]))/$height;
                            last;
                        }

#                   One measurement above and one below the elevation range of interest
                    } elsif ($el1 >= $el[$k] && $el2 <= $el[$k+1]) {
                        $top   = $wt1 + ($wt2-$wt1)*($el1-$el[$k])  /($el1-$el2);
                        $bot   = $wt1 + ($wt2-$wt1)*($el1-$el[$k+1])/($el1-$el2);
                        $t[$k] = ($top+$bot)/2.;
                        last;
                    }
                    $first = 0;
                }
            }
        }

#       Compute water densities
        @rho = ();
        for ($k=2; $k<=$kb; $k++) {
            next if ($t[$k] == -999.);
            $rho[$k] = ((((6.536332E-9*$t[$k]-1.120083E-6)*$t[$k]+1.001685E-4)*$t[$k]
                          -9.09529E-3)*$t[$k]+6.793952E-2)*$t[$k]+999.842594;
        }

#       Collect data needed for selective withdrawal routines
        $ds_parms{wsel} = $surf_elev;    # meters
        $ds_parms{wt}   = [ @t   ];      # deg C
        $ds_parms{rho}  = [ @rho ];      # kg/cu.m.

#       Compute outflow temperatures for each outlet
        $qsum = 0;
        $tsum = 0;
        @qstr = @{ $qdata{$dt} };
        @qtot = @vtot = ();
        for ($k=2; $k<=$kb; $k++) {
            $qtot[$k] = $vtot[$k] = 0;
        }

#       Loop over the outlets
        for ($n=0; $n<$nout; $n++) {
            next if ($qstr[$n] == 0.);
            $ds_parms{qstr} = $qstr[$n];         # cms
            $ds_parms{ktsw} = $ktsw[$n];
            $ds_parms{kbsw} = $kbsw[$n];

#           Compute flows to a discrete outlet using original W2 algorithm
            if ($sw_alg[$n] eq "W2orig") {
                $ds_parms{estr} = $estr[$n];     # meters
                $ds_parms{wstr} = $lw[$n];       # meters
                ($tout, @qout)  = &downstream_withdrawal(%ds_parms);

#           Compute flows over/through bulkhead stacks to a wet well
#           using the new Libby Dam algorithm
            } elsif ($sw_alg[$n] eq "LibbyDam") {

#               The wet well number is found by matching outlet names
                $nww = &list_match($names[$n], @ww_names);
                if ($nww == -1 || $nww > $gr_props{$id}{num_ww} -1) {
                    return &pop_up_error($main,
                              "Failed to match the name of the wet well to\n"
                            . "one of the named outlets in the release rate file:\n"
                            . "  $props{$id}{lbc_file}\n  $props{$id}{flow_file}");
                }
                $ds_parms{nslots}   = $nslots[$nww];
                $ds_parms{noutlets} = $noutlets[$nww];

                ($tout, @qout) = &libby_calcs($nww, $dt, %ds_parms);
            }

            $qsum += $qstr[$n];          # Note: qstr[] and qout[] in cms
            $tsum += $qstr[$n] *$tout;   # and tout is in deg Celsius
            for ($k=2; $k<=$kb; $k++) {
                $qtot[$k] += $qout[$k];
            }
            $tstr[$n] = $tout;
        }
        $tstr[$nout] = ($qsum > 0) ? $tsum /$qsum : -99.;
        $tdata{$dt}  = [ @tstr ];

#       Adjust flow per unit height (cms/m) and compute velocity (m/s)
        for ($k=2; $k<=$kb; $k++) {
            next if ($el[$k+1] >= $surf_elev);
            $height    = &min($surf_elev, $el[$k]) -$el[$k+1];
            $vtot[$k]  = $qtot[$k] /($height *$b[$k]);
            $qtot[$k] /= $height;
        }
        $qtot_data{$dt} = [ @qtot ];
        $vtot_data{$dt} = [ @vtot ];
    }
    undef %ds_parms;
    undef %qdata;
    undef %temps;
    undef %wsurf;

#   Restore mouse cursor and remove the progress bar
    $canvas->configure(-cursor => $cursor_norm);
    $pbar_window->g_destroy();
    $status_line = "";
    Tkx::tk_busy_forget($main);

#   Save results
    $gr_props{$id}{tdata}     = { %tdata     };  # outlet temps in deg C
    $gr_props{$id}{qtot_data} = { %qtot_data };  # layer outflows in cms/m
    $gr_props{$id}{vtot_data} = { %vtot_data };  # layer velocities in m/s
}


sub make_bulkhead_graphic {
    my ($canv, $id, $dt, %parms) = @_;
    my (
        $base_elev, $bh_bcellh, $bh_bcellw, $bh_bcolor, $bh_bwidth,
        $bh_docked, $bh_font, $bh_height, $bh_size, $bh_tcolor, $bh_weight,
        $bh_xpos, $bh_ypos, $bhd, $bhd_tmp, $bhdt, $dt_tmp, $first, $gtag,
        $last_bhd, $mult, $n, $nr, $nrows, $num_ww, $surf_elev, $tags,
        $x1, $x2, $xp, $y1, $y2, $ymax, $ymin, $yp, $yp1, $yp2, $ytype,

        @nopen_bh, @ww_names,

        %bh_miss,
       );

    $mult      = ($parms{yunits} eq "feet") ? 3.28084 : 1.0;
    $ytype     = $parms{ytype};
    $ymin      = $parms{ymin} /$mult;   # do calcs in meters
    $ymax      = $parms{ymax} /$mult;
    $num_ww    = $parms{num_ww};
    $nrows     = $parms{num_rows};
    $bh_height = $parms{bh_height};
    $base_elev = $parms{base_elev};
    $surf_elev = $parms{surf_elev};
    $bh_font   = $parms{bh_font};
    $bh_size   = $parms{bh_size};
    $bh_weight = $parms{bh_weight};
    $bh_tcolor = $parms{bh_tcolor};
    $bh_bwidth = $parms{bh_bwidth};
    $bh_bcolor = $parms{bh_bcolor};
    $bh_bcellw = $parms{bh_bcellw};
    $bh_docked = $parms{bh_docked};
    $bh_xpos   = $parms{bh_xpos};
    $bh_ypos   = $parms{bh_ypos};
    $bh_bcellh = $parms{bh_bcellh};

    @ww_names = @{ $parms{ww_names} };
    %bh_miss  = %{ $parms{bh_miss}  };

    $dt_tmp = (length($dt) == 8) ? $dt . "0000" : $dt;
    $first  = 1;
    foreach $bhd (sort keys %bh_miss) {
        $bhdt    = $bhd;
        $bhd_tmp = (length($bhd) == 8) ? $bhd . "0000" : $bhd;
        if ($bhd_tmp > $dt_tmp) {
            $bhdt = ($first) ? $bhd : $last_bhd;
            last;
        }
        $last_bhd = $bhd;
        $first = 0;
    }
    @nopen_bh = @{ $bh_miss{$bhdt} };

    $gtag = "graph" . $id;
    if ($bh_docked) {
        $tags = $gtag . " " . $gtag . "_openBH";
    } else {
        $tags = $gtag . "_openBH";
    }
    ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
    if ($ytype eq "Depth") {
        if (defined($surf_elev) && $surf_elev ne "na") {
            $yp1 = $y1 +($y2 -$y1) *($surf_elev -($base_elev +$nrows *$bh_height)) /$ymax;
            $yp2 = $y1 +($y2 -$y1) *($surf_elev -$base_elev) /$ymax;
        } else {
            return;
        }
    } else {
        $yp1 = $y1 +($y2 -$y1) *($ymax -($base_elev +$nrows *$bh_height)) /($ymax -$ymin);
        $yp2 = $y1 +($y2 -$y1) *($ymax -$base_elev) /($ymax -$ymin);
    }
    if ($bh_docked || $bh_xpos == -99 || $bh_ypos == -99 || $bh_bcellh == -99) {
        $bh_xpos   = $gr_props{$id}{bh_xpos}   = $x2 -$num_ww *$bh_bcellw;
        $bh_ypos   = $gr_props{$id}{bh_ypos}   = $yp2;
        $bh_bcellh = $gr_props{$id}{bh_bcellh} = ($yp2 -$yp1)/$nrows;
    }
    $canv->create_rectangle($bh_xpos, $bh_ypos, $bh_xpos +$num_ww *$bh_bcellw, $bh_ypos -$nrows *$bh_bcellh,
                            -outline => &get_rgb_code($bh_bcolor),
                            -width   => $bh_bwidth,
                            -fill    => "",
                            -tags    => $tags);
    for ($n=1; $n<$num_ww; $n++) {
        $xp = $bh_xpos +$n *$bh_bcellw;
        $canv->create_line($xp, $bh_ypos, $xp, $bh_ypos -$nrows *$bh_bcellh,
                            -fill  => &get_rgb_code($bh_bcolor),
                            -width => $bh_bwidth,
                            -arrow => 'none',
                            -tags  => $tags);
    }
    for ($nr=1; $nr<$nrows; $nr++) {
        $yp = $bh_ypos -$nr *$bh_bcellh;
        $canv->create_line($bh_xpos, $yp, $bh_xpos +$num_ww *$bh_bcellw, $yp,
                            -fill  => &get_rgb_code($bh_bcolor),
                            -width => $bh_bwidth,
                            -arrow => 'none',
                            -tags  => $tags);
    }
    for ($n=0; $n<$num_ww; $n++) {
        $xp = $bh_xpos +($n +0.5) *$bh_bcellw;
        for ($nr=0; $nr<$nrows; $nr++) {
            $yp = $bh_ypos -($nr +0.5) *$bh_bcellh;
            $canv->create_text($xp, $yp,
                               -anchor => 'center',
                               -text   => $nopen_bh[$n][$nr],
                               -fill   => &get_rgb_code($bh_tcolor),
                               -angle  => 0,
                               -tags   => $tags,
                               -font   => [-family     => $bh_font,
                                           -size       => $bh_size,
                                           -weight     => $bh_weight,
                                           -slant      => 'roman',
                                           -underline  => 0,
                                           -overstrike => 0,
                                          ]);
        }
    }
}


sub setup_w2_outflow {
    my ($canv, $id) = @_;
    my (
        $bth_file, $bth_file_btn, $byear, $byear_cb, $con_file, $elev_base,
        $f, $frame, $geom, $gr_type, $gtitle, $jd_skip, $jd_skip_active,
        $jd_skip_explain, $jd_skip_frame, $jd_skip_label, $nwb,
        $offset_frame, $ok_btn, $qaxis_units, $qaxis_units_cb, $qla_file,
        $qla_file_btn, $qla_lines, $row, $segnum, $segnum_txt, $title,
        $tz_offset, $wdof_msg, $X, $x1, $x2, $xmajor, $xmajor_entry,
        $xmax, $xmax_entry, $Y, $y1, $y2, $yaxis_type, $yaxis_type_cb,
        $yaxis_units, $yaxis_units_label, $ymajor, $ymajor_entry,
        $ymajor_label, $ymax, $ymax_entry, $ymax_label, $ymin, $ymin_entry,
        $ymin_label, $ymin_units_label, $yr_max, $yr_min,

        @be, @bs, @ds, @jd_skip_opts, @us,
       );

    ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $X += $x1 +30;
    $Y += $y1 +50;
    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($w2outflow_setup_menu) && Tkx::winfo_exists($w2outflow_setup_menu)) {
        if ($w2outflow_setup_menu->g_wm_title() eq "W2 Layer Outflows Setup") {
            $w2outflow_setup_menu->g_destroy();
            undef $w2outflow_setup_menu;
        }
    }
    $w2outflow_setup_menu = $main->new_toplevel();
    $w2outflow_setup_menu->g_wm_transient($main);
    $w2outflow_setup_menu->g_wm_title("W2 Layer Outflows Setup");
    $w2outflow_setup_menu->configure(-cursor => $cursor_norm);
    $w2outflow_setup_menu->g_wm_geometry($geom);

#   Try to keep the nascent graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

    $con_file    = $qla_file = $bth_file = "";
    $qla_lines   = 0;
    $yaxis_units = "feet";
    $yaxis_type  = "Elevation";
    $elev_base   = -999;
    $segnum      = "";
    $segnum_txt  = "";
    $qaxis_units = "cfs/ft";
    $wdof_msg    = "";
    $gr_type     = "Release Rates Only";
    $tz_offset   = "+00:00";

    $yr_max = (localtime(time))[5] +1900;
    $yr_min = $yr_max -25;
    $byear  = $yr_max;
    $ymin   = $ymax   = $ymajor = "";
    $xmax   = $xmajor = "";
    $title  = "Release Rate, in cfs/(vert. ft)";
    $gtitle = "Modeled Withdrawal Zone";

    $jd_skip_active = $jd_skip = 0;
    @jd_skip_opts = ("(keep all)", "(keep every other)", "(keep every 3rd)", "(keep every 4th)",
                     "(keep every 5th)",  "(keep every 6th)",  "(keep every 7th)",  "(keep every 8th)",
                     "(keep every 9th)",  "(keep every 10th)", "(keep every 11th)", "(keep every 12th)",
                     "(keep every 13th)", "(keep every 14th)", "(keep every 15th)", "(keep every 16th)",
                     "(keep every 17th)", "(keep every 18th)", "(keep every 19th)", "(keep every 20th)",
                     "(keep every 21st)", "(keep every 22nd)", "(keep every 23rd)", "(keep every 24th)",
                     "(keep every 25th)", "(keep every 26th)", "(keep every 27th)", "(keep every 28th)",
                     "(keep every 29th)", "(keep every 30th)", "(keep every 31st)", "(keep every 32nd)",
                     "(keep every 33rd)", "(keep every 34th)", "(keep every 35st)", "(keep every 36th)",
                     "(keep every 37th)", "(keep every 38th)", "(keep every 39th)", "(keep every 40th)",
                     "(keep every 41st)", "(keep every 42nd)", "(keep every 43rd)", "(keep every 44th)",
                     "(keep every 45th)", "(keep every 46th)", "(keep every 47th)", "(keep every 48th)",
                     "(keep every 49th)", "(keep every 50th)");
    $jd_skip_explain = $jd_skip_opts[$jd_skip];

#   Begin the menu
    $frame = $w2outflow_setup_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -state   => 'disabled',
            -command => sub { my ($add_parm, %parms);
                              if ($con_file eq "" || ! -e $con_file) {
                                  return &pop_up_error($w2outflow_setup_menu,
                                  "W2 Control file not set or does not exist:\n$con_file");
                              }
                              if ($qla_file eq "" || ! -e $qla_file) {
                                  return &pop_up_error($w2outflow_setup_menu,
                                  "W2 Layer Outflow file not set or does not exist:\n$qla_file");
                              }
                              if ($bth_file eq "" || ! -e $bth_file) {
                                  return &pop_up_error($w2outflow_setup_menu,
                                  "W2 Bathymetry file not set or does not exist:\n$bth_file");
                              }
                              if ($xmax eq "") {
                                  return &pop_up_error($w2outflow_setup_menu,
                                  "Please provide a maximum layer outflow rate.");
                              }
                              if ($yaxis_type eq "Elevation") {
                                  if ($ymin eq "" || $ymax eq "") {
                                      return &pop_up_error($w2outflow_setup_menu,
                                      "Please provide both a min and max elevation.");
                                  }
                                  if ($ymin >= $ymax) {
                                      return &pop_up_error($w2outflow_setup_menu,
                                      "The minimum elevation must be less than the maximum elevation.");
                                  }
                              } else {
                                  if ($ymax eq "") {
                                      return &pop_up_error($w2outflow_setup_menu,
                                      "Please provide a maximum depth.");
                                  }
                              }
                              if ($segnum eq "" || $segnum <= 0) {
                                  return &pop_up_error($w2outflow_setup_menu,
                                  "W2 segment number must be numeric and positive.");
                              }
                              $gtitle =~ s/^\s+//;
                              $gtitle =~ s/\s+$//;
                              $add_parm = ($gr_type eq "With Parameter Color Scheme") ? 1 : 0;

                              %parms             = ();
                              $parms{xmax}       = $xmax;
                              $parms{xmajor}     = $xmajor;
                              $parms{qunits}     = $qaxis_units;
                              $parms{ymin}       = $ymin;
                              $parms{ymax}       = $ymax;
                              $parms{ymajor}     = $ymajor;
                              $parms{ytype}      = $yaxis_type;
                              $parms{yunits}     = $yaxis_units;
                              $parms{gtitle}     = $gtitle;
                              $props{$id}{parms} = { %parms };

                              $props{$id}{files}     = 1;
                              $props{$id}{con_file}  = $con_file;
                              $props{$id}{bth_file}  = $bth_file;
                              $props{$id}{qla_file}  = $qla_file;
                              $props{$id}{qla_lines} = $qla_lines;
                              $props{$id}{add_parm}  = $add_parm;
                              $props{$id}{seg}       = $segnum;
                              $props{$id}{byear}     = $byear;
                              $props{$id}{tz_offset} = $tz_offset;
                              $props{$id}{jd_skip}   = $jd_skip;

                              $w2outflow_setup_menu->g_bind('<Destroy>', "");
                              if ($add_parm) {
                                  $geom = $w2outflow_setup_menu->g_wm_geometry();
                                  (undef, $X, $Y) = split(/\+/, $geom);
                                  &setup_w2_outflow_part2($canv, $id, $X, $Y, 0);
                              } else {
                                  $w2outflow_setup_menu->g_destroy();
                                  undef $w2outflow_setup_menu;
                                  &reset_bindings;
                                  &make_w2_outflow($canv, $id, 0);
                              }
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $w2outflow_setup_menu->g_bind('<Destroy>', "");
                              $w2outflow_setup_menu->g_destroy();
                              undef $w2outflow_setup_menu;
                              $canv->delete("graph" . $id);
                              delete $props{$id};
                              delete $grid{$id} if (defined($grid{$id}));
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Delete graph if this menu is destroyed by other than the Cancel button
    $w2outflow_setup_menu->g_bind('<Destroy>' => sub { undef $w2outflow_setup_menu;
                                                       $canv->delete("graph" . $id);
                                                       delete $props{$id}; 
                                                       delete $grid{$id} if (defined($grid{$id}));
                                                       &reset_bindings;
                                                     });

    $f = $w2outflow_setup_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "W2 Control File: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$con_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);
    $f->new_button(
            -text    => "Browse",
            -command => sub { my ($file, $i, $wdof_max, $wdof_min, @wdof);
                              $file = Tkx::tk___getOpenFile(
                                      -parent           => $w2outflow_setup_menu,
                                      -title            => "Select W2 Control File",
                                      -initialdir       => abs_path(),
                                      -filetypes => [ ['All Files',  '*'],
                                                      ['CSV (comma delimited)', '.csv'],
                                                      ['NPT (W2 input file)', '.npt'],
                                                    ],
                                      );
                              if (defined($file) && -e $file) {
                                  $con_file = File::Spec->rel2abs($file);
                                  &read_con($main, $id, $con_file);

                                  $nwb   = $grid{$id}{nwb};
                                  @bs    = @{ $grid{$id}{bs}   };
                                  @be    = @{ $grid{$id}{be}   };
                                  @us    = @{ $grid{$id}{us}   };
                                  @ds    = @{ $grid{$id}{ds}   };
                                  @wdof  = @{ $grid{$id}{wdof} };
                                  $byear = $grid{$id}{byear};
                                  if ($byear <= $yr_min) {
                                      $yr_min = $byear -5;
                                      $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                  }
                                  $byear_cb->configure(-state => 'readonly');
                                  $qla_file_btn->configure(-state => 'normal');
                                  $bth_file_btn->configure(-state => 'normal');
                              } else {
                                  $con_file = "";
                                  $byear_cb->configure(-state => 'disabled');
                                  $qla_file_btn->configure(-state => 'disabled');
                                  $bth_file_btn->configure(-state => 'disabled');
                              }
                              $qla_file = $bth_file = $segnum = $segnum_txt = "";
                              $jd_skip_active = 0;
                              $wdof_min =  9.E6;
                              $wdof_max = -9.E6;
                              for ($i=1; $i<=$#wdof; $i++) {
                                  $jd_skip_active = 1 if ($wdof[$i] < 1.0);
                                  $wdof_min = $wdof[$i] if ($wdof[$i] < $wdof_min);
                                  $wdof_max = $wdof[$i] if ($wdof[$i] > $wdof_max);
                              }
                              if ($wdof_min == $wdof_max) {
                                  $wdof_msg = " [Outflow frequency is " . $wdof_min;
                              } else {
                                  $wdof_msg = " [Outflow frequency range: " . $wdof_min . " - " . $wdof_max;
                              }
                              $wdof_msg .= ($wdof_max > 1.0) ? " days.]" : " day.]";
                              if ($jd_skip_active) {
                                  $jd_skip = 0 if ($jd_skip < 0 || $jd_skip > 49);
                                  $jd_skip_explain = $jd_skip_opts[$jd_skip];
                                  $jd_skip_label->g_grid();
                                  $jd_skip_frame->g_grid();
                              } else {
                                  $jd_skip_label->g_grid_remove();
                                  $jd_skip_frame->g_grid_remove();
                              }
                              $ok_btn->configure(-state => 'disabled');
                            }
            )->g_grid(-row => $row, -column => 4, -sticky => 'ew', -padx => 2, -pady => 2);

    $row++;
    $f->new_label(
            -text => "W2 QLayers File: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$qla_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);
    ($qla_file_btn = $f->new_button(
            -text    => "Browse",
            -state   => 'disabled',
            -command => sub { my ($file, $ftype, $jb, $jw, $wb_txt, @parms);
                              $file = Tkx::tk___getOpenFile(
                                      -parent           => $w2outflow_setup_menu,
                                      -title            => "Select QLayers File",
                                    # -initialdir       => abs_path(),
                                      -filetypes => [ ['All Files', '*'],
                                                      ['W2 Output Files', '.opt'],
                                                      ['CSV (comma delimited)', '.csv'],
                                                    ],
                                      );
                              if (defined($file) && -e $file) {
                                  $qla_file = File::Spec->rel2abs($file);
                                  ($ftype, $qla_lines, @parms)
                                      = &determine_ts_type($w2outflow_setup_menu, $qla_file, 1);
                                  if ($ftype ne "W2 Layer Outflow CSV format") {
                                      $qla_file = "";
                                      $ok_btn->configure(-state => 'disabled');
                                      return &pop_up_error($w2outflow_setup_menu,
                                        "The specified file is not a W2 Layer Outflow file:\n$file");
                                  }
                                  ($segnum = $parms[0]) =~ s/^Total Outflow, segment (\d+)/$1/;
                                  $wb_txt = "";
                                  for ($jw=1; $jw<=$nwb; $jw++) {
                                      for ($jb=$bs[$jw]; $jb<=$be[$jw]; $jb++) {
                                          if ($segnum >= $us[$jb] && $segnum <= $ds[$jb]) {
                                              $wb_txt = " (waterbody $jw, branch $jb)";
                                              last;
                                          }
                                      }
                                      last if ($wb_txt ne "");
                                  }
                                  $segnum_txt = sprintf("%d", $segnum) . $wb_txt;
                                  if ($bth_file ne "" && -e $bth_file) {
                                      $ok_btn->configure(-state => 'normal');
                                  }
                              } else {
                                  $ok_btn->configure(-state => 'disabled');
                              }
                            },
            ))->g_grid(-row => $row, -column => 4, -sticky => 'ew', -padx => 2, -pady => 2);

    $row++;
    $f->new_label(
            -text => "W2 Bathymetry File: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$bth_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);
    ($bth_file_btn = $f->new_button(
            -text    => "Browse",
            -state   => 'disabled',
            -command => sub { my ($file);
                              $file = Tkx::tk___getOpenFile(
                                      -parent           => $w2outflow_setup_menu,
                                      -title            => "Select W2 Bathymetry File",
                                    # -initialdir       => abs_path(),
                                      -defaultextension => ".csv",
                                      -filetypes => [ ['CSV (comma delimited)', '.csv'],
                                                      ['NPT (W2 input file)', '.npt'],
                                                      ['All Files',  '*'],
                                                    ],
                                      );
                              if (defined($file) && -e $file) {
                                  $bth_file = File::Spec->rel2abs($file);
                                  if ($qla_file ne "" && -e $qla_file) {
                                      $ok_btn->configure(-state => 'normal');
                                  }
                              } else {
                                  $ok_btn->configure(-state => 'disabled');
                              }
                            },
            ))->g_grid(-row => $row, -column => 4, -sticky => 'ew', -padx => 2, -pady => 2);

    $row++;
    $f->new_label(
            -text => "Segment: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$segnum_txt,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Base Year: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($byear_cb = $f->new_ttk__combobox(
            -textvariable => \$byear,
            -values       => [ reverse($yr_min .. $yr_max) ],
            -state        => 'disabled',
            -width        => 5,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $byear_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($byear == $yr_min) {
                                $yr_min -= 5;
                                $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                            }
                          });
    $f->new_label(
            -text   => " for JDAY = 1.0",
            -anchor => 'w',
            -font   => 'default',
            )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Time Offset: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($offset_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    $offset_frame->new_ttk__combobox(
            -textvariable => \$tz_offset,
            -values       => [ @tz_offsets ],
            -justify      => 'right',
            -state        => 'readonly',
            -width        => 6,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $offset_frame->new_label(
            -text   => " time zone adjustment ",
            -anchor => 'w',
            -font   => 'default',
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $offset_frame->new_button(
            -text    => "Help",
            -command => sub { &pop_up_info($w2outflow_setup_menu,
                                    "The time offset allows the user to add or subtract a time\n"
                                  . "offset if the W2 model was run with a non-local time zone.\n\n"
                                  . "For example, if W2 was run in UTC but the local time zone\n"
                                  . "is PST, an offset of -08:00 would convert the model date/time\n"
                                  . "to a local standard time of PST. This offset does not make\n"
                                  . "any adjustments related to daylight saving time. In general,\n"
                                  . "W2 is best run in the local standard time.\n\n"
                                  . "Leave the time offset at +00:00 for no adjustment.",
                                    "Time Offset Notice");
                            },
            )->g_pack(-side => 'left', -anchor => 'w', -padx => 2);

    $row++;
    $f->new_label(
            -text => "Release Rate Units: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($qaxis_units_cb = $f->new_ttk__combobox(
            -textvariable => \$qaxis_units,
            -values       => [ ("cfs/ft", "cms/m", "ft/s", "m/s") ],
            -state        => 'readonly',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $qaxis_units_cb->g_bind("<<ComboboxSelected>>",
                             sub { if ($qaxis_units eq "cfs/ft") {
                                       $title = "Release Rate, in cfs/(vert. ft)";
                                   } elsif ($qaxis_units eq "cms/m") {
                                       $title = "Release Rate, in cms/(vert. m)";
                                   } elsif ($qaxis_units eq "ft/s") {
                                       $title = "Velocity, in ft/s";
                                   } else {
                                       $title = "Velocity, in m/s";
                                   }
                                 });

    $row++;
    $f->new_label(
            -text => "X Axis Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$title,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "X Axis Max: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($xmax_entry = $f->new_entry(
            -textvariable => \$xmax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $xmax_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($xmax_entry);
                                              $xmax =~ s/^-//;
                                            });

    $row++;
    $f->new_label(
            -text => "X Axis Major: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($xmajor_entry = $f->new_entry(
            -textvariable => \$xmajor,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $xmajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($xmajor_entry, 1);
                                                $xmajor =~ s/^-//;
                                              });

    $row++;
    $f->new_label(
            -text => "Y Axis Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($yaxis_type_cb = $f->new_ttk__combobox(
            -textvariable => \$yaxis_type,
            -values       => [ ("Elevation", "Depth") ],
            -state        => 'readonly',
            -width        => 10,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $yaxis_type_cb->g_bind("<<ComboboxSelected>>",
                           sub { if ($yaxis_type eq "Elevation") {
                                     $ymin_label->g_grid();
                                     $ymin_entry->g_grid();
                                     $ymin_units_label->g_grid();
                                     $ymax_label->configure(-text => "Elevation Max: ");
                                     $ymajor_label->configure(-text => "Elevation Major: ");
                                     $yaxis_units_label->configure(-text => "Elevation Units: ");
                                     if ($elev_base != -999 && $ymax ne "") {
                                         $ymin  = $elev_base;
                                         $ymax += $elev_base;
                                     } else {
                                         $ymin = "";
                                     }
                                 } else {
                                     $ymin_label->g_grid_remove();
                                     $ymin_entry->g_grid_remove();
                                     $ymin_units_label->g_grid_remove();
                                     $ymax_label->configure(-text => "Depth Max: ");
                                     $ymajor_label->configure(-text => "Depth Major: ");
                                     $yaxis_units_label->configure(-text => "Depth Units: ");
                                     if ($ymax ne "" && $ymin ne "" && $ymax -$ymin != 0) {
                                         $elev_base = &min($ymin, $ymax);
                                         $ymax      = abs($ymax -$ymin);
                                     } else {
                                         $ymax = "";
                                     }
                                     $ymin = 0;
                                 }
                               }
                          );

    $row++;
    ($ymin_label = $f->new_label(
            -text => "Elevation Min: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ymin_entry = $f->new_entry(
            -textvariable => \$ymin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $ymin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $ymin_entry ]);
    ($ymin_units_label = $f->new_label(
            -textvariable => \$yaxis_units,
            -font         => 'default',
            -anchor       => 'w',
            ))->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    ($ymax_label = $f->new_label(
            -text => "Elevation Max: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ymax_entry = $f->new_entry(
            -textvariable => \$ymax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $ymax_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($ymax_entry);
                                              $ymax =~ s/^-// if ($yaxis_type eq "Depth");
                                            });
    $f->new_label(
            -textvariable => \$yaxis_units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    ($ymajor_label = $f->new_label(
            -text => "Elevation Major: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ymajor_entry = $f->new_entry(
            -textvariable => \$ymajor,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $ymajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($ymajor_entry, 1);
                                                $ymajor =~ s/^-//;
                                              });
    $f->new_label(
            -textvariable => \$yaxis_units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    ($yaxis_units_label = $f->new_label(
            -text => "Elevation Units: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_ttk__combobox(
            -textvariable => \$yaxis_units,
            -values       => [ ("feet", "meters") ],
            -state        => 'readonly',
            -width        => 7,
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    ($jd_skip_label = $f->new_label(
            -text => "Skip Dates: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($jd_skip_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    $jd_skip_frame->new_spinbox(
            -textvariable => \$jd_skip,
            -state        => 'readonly',
            -font         => 'default',
            -from         => 0,
            -to           => 49,
            -increment    => 1,
            -width        => 4,
            -command      => sub { $jd_skip_explain = $jd_skip_opts[$jd_skip]; },
            )->g_pack(-side => 'left', -anchor => 'w');
    $jd_skip_frame->new_label(
            -textvariable => \$jd_skip_explain,
            -font         => 'default',
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $jd_skip_frame->new_label(
            -textvariable => \$wdof_msg,
            -font         => 'default',
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $jd_skip_label->g_grid_remove();
    $jd_skip_frame->g_grid_remove();

    $row++;
    $f->new_label(
            -text => "Graph Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_ttk__combobox(
            -textvariable => \$gr_type,
            -values       => [ ("Release Rates Only", "With Parameter Color Scheme") ],
            -state        => 'readonly',
            -width        => 28,
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Graph Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$gtitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'ew', -pady => 2);

    $f->g_grid_columnconfigure(3, -weight => 2);

    Tkx::wm_resizable($w2outflow_setup_menu,0,0);
    &adjust_window_position($w2outflow_setup_menu);
    $w2outflow_setup_menu->g_focus;
}


sub setup_w2_outflow_part2 {
    my ($canv, $id, $X, $Y, $graph_exists) = @_;
    my (
        $conv_add, $conv_add_entry, $conv_mult, $conv_mult_entry, $conv_type,
        $conv_type_cb, $conv_type_na_label, $cpl_msg, $cplf_max, $cplf_min,
        $cscheme, $cscheme_cb, $custom_frame, $f, $frame, $ftype, $geom,
        $i, $imx, $jb, $jd_skip, $jd_skip_active, $jd_skip_explain,
        $jd_skip_frame, $jd_skip_parm, $jd_skip_parm_active,
        $jd_skip_parm_explain, $jd_skip_parm_frame, $jd_skip_parm_label,
        $jw, $lcon_freq, $lcon_msg, $meta, $msg_label, $n, $ncolors,
        $ncolors_cb, $nwb, $ok, $ok_btn, $old_units, $oldparm,
        $oldparm_short, $oldsrc_type, $parm, $parm_cb, $parm_chars,
        $parm_div, $parm_div_cb, $parm_div_label, $parm_frame, $parm_short,
        $parms_ref, $pmax, $pmax_entry, $pmin, $pmin_entry, $ptitle, $row,
        $segnum, $segnum_txt, $spr_msg, $sprf_max, $sprf_min, $src_file,
        $src_file_btn, $src_file_label, $src_lines, $src_parm, $src_type,
        $src_type_cb, $tecplot, $tol, $tol_frame, $units, $units_cb,
        $units_entry, $vplf_max, $vplf_min, $vpl_msg, $wb_txt, $wdo_msg,
        $wdof_max, $wdof_min,

        @be, @bs, @cmaps, @cplf, @ds, @jd_skip_opts, @ncpl, @nspr, @nvpl,
        @parm_divlist, @parmlist, @slope, @sprf, @us, @vplf, @wdof,

        %parms,
       );

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($w2outflow_setup_menu) && Tkx::winfo_exists($w2outflow_setup_menu)) {
        if ($w2outflow_setup_menu->g_wm_title() eq "W2 Layer Outflows Setup") {
            $w2outflow_setup_menu->g_destroy();
            undef $w2outflow_setup_menu;
        }
    }
    $w2outflow_setup_menu = $main->new_toplevel();
    $w2outflow_setup_menu->g_wm_transient($main);
    $w2outflow_setup_menu->g_wm_title("W2 Layer Outflows Setup");
    $w2outflow_setup_menu->configure(-cursor => $cursor_norm);
    $w2outflow_setup_menu->g_wm_geometry($geom);

#   Try to keep the nascent graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

#   De-select graph if it already exists
    if (defined($props{$id}{old_jd_skip})) {
        &end_select($canv, $id, 1);
    }

#   If this routine was called to change the color-display parameter
    if ($graph_exists && defined($props{$id}{src_type})) {
        $src_type      = $props{$id}{src_type};
        $src_file      = $props{$id}{src_file};
        $src_lines     = ($src_type =~ /Vector/i) ? 0 : $props{$id}{src_lines};
        $tecplot       = ($src_type =~ /Contour/i) ? $props{$id}{tplot} : 0;
        $parm          = $props{$id}{parm};
        $parm_div      = $props{$id}{parm_div};
        $units         = $props{$id}{parm_units};
        $conv_type     = $props{$id}{parm_ctype};
        $jd_skip_parm  = $props{$id}{parm_skip};
        $tol           = $props{$id}{match_tol};

        %parms         = ();
        $parms{xmax}   = $gr_props{$id}{xmax};
        $parms{xmajor} = $gr_props{$id}{xmajor};
        $parms{qunits} = $gr_props{$id}{qunits};
        $parms{ymin}   = $gr_props{$id}{ymin};
        $parms{ymax}   = $gr_props{$id}{ymax};
        $parms{ymajor} = $gr_props{$id}{ymajor};
        $parms{ytype}  = $gr_props{$id}{ytype};
        $parms{yunits} = $gr_props{$id}{yunits};
        $parms{gtitle} = $gr_props{$id}{gtitle};
        $props{$id}{parms} = { %parms };
        undef %parms;

        $pmin          = $gr_props{$id}{cs_min};
        $pmax          = $gr_props{$id}{cs_max};
        $ncolors       = $gr_props{$id}{ncolors};
        if ($gr_props{$id}{cscheme1} =~ /CoolWarm|Turbo|Viridis/) {
            $cscheme   = $gr_props{$id}{cscheme1};
            $ncolors   = &max(8, &min(100, $ncolors));
        } elsif ($gr_props{$id}{cscheme1} eq "Blue" && $gr_props{$id}{cscheme2} eq "Orange") {
            $cscheme   = "Blue to Orange";
            $ncolors  *= 2;
            $ncolors   = &max(16, &min(46, $ncolors));
            foreach $n (reverse @valid_nc) {
                if ($ncolors >= 2 *$n) {
                    $ncolors = 2 *$n;
                    last;
                }
            }
        } elsif ($gr_props{$id}{cscheme1} eq "Blue" && $gr_props{$id}{cscheme2} eq "Red") {
            $cscheme   = "Blue to Red";
            $ncolors  *= 2;
            $ncolors   = &max(16, &min(46, $ncolors));
            foreach $n (reverse @valid_nc) {
                if ($ncolors >= 2 *$n) {
                    $ncolors = 2 *$n;
                    last;
                }
            }
        } else {
            $cscheme = "Blue to Orange";
            $ncolors = 20;
        }
        if ($conv_type =~ /Custom/) {
            ($conv_type, $conv_mult, $conv_add) = split(/,/, $conv_type);
        } else {
            $conv_mult = 1.0;
            $conv_add  = 0.0;
        }
        if ($src_type =~ /Spreadsheet/i) {
            ($ok, undef, undef, $parms_ref)
                      = &scan_w2_spr_file($w2outflow_setup_menu, $src_file, "");
            @parmlist = @{ $parms_ref };

        } elsif ($src_type =~ /Contour/i) {
            ($tecplot, undef, $jw, $parms_ref, undef, undef)
                      = &scan_w2_cpl_file($w2outflow_setup_menu, $src_file, $id, 0, "");
            @parmlist = @{ $parms_ref };

        } elsif ($src_type =~ /Vector/i) {
            ($ok, $parms_ref, undef, undef, undef)
                      = &scan_w2_vector_file($w2outflow_setup_menu, $src_file, $id, 0);
            @parmlist = @{ $parms_ref };

        } elsif ($src_type =~ /LakeCon/i) {
            ($ftype, $src_parm, $meta, undef)
                      = &scan_w2_rlcon_file($w2outflow_setup_menu, $src_file, "");
            @parmlist = ($src_parm);
            (undef, $lcon_freq) = split(/_/, $meta);
            if ($lcon_freq < 1.0 && length($lcon_freq) > 6) {
                $lcon_freq = sprintf("%0.4f", $lcon_freq);
            }
        }
        $lcon_freq  = "" if ($src_type !~ /LakeCon/i);
        $parm_chars = length($parmlist[0]);
        for ($i=1; $i<=$#parmlist; $i++) {
            $parm_chars = &max($parm_chars, length($parmlist[$i]));
        }
        $parm_chars += 2;
        if (&list_match($parm, @parmlist) == -1) {
            $parm  = $parmlist[0];
            $parm  =~ s/^\s+//;
            $parm  =~ s/\s+$//;
            $units = "";
        }
        $parm_short = $parm;
        if ($parm eq "Temperature") {
            $units  = "Celsius" if ($units !~ /(Celsius|Fahrenheit)/);
            $ptitle = "Temperature, in degrees " . $units;
        } else {
            $parm_short =~ s/\(ms-1\)//i;
            $parm_short =~ s/\(m3s-1\)//i;
            $parm_short =~ s/ [kmu]?g\/L\/day//i;
            $parm_short =~ s/ [kmu]?g\/m2\/day//i;
            $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
            $parm_short =~ s/ [kmu]?g\/L//i;
            $parm_short =~ s/ [kmu]?g\/m3//i;
            $parm_short =~ s/ [kmu]?g\/m\^3//i;
            $parm_short =~ s/, days//i;
            $parm_short =~ s/ days//i;
            $parm_short =~ s/,$//;
            $ptitle = $parm_short . ", in " . $units;
        }
        @parm_divlist = ("None");
        for ($i=0; $i<=$#parmlist; $i++) {
            if ($parm ne $parmlist[$i]) {
                push (@parm_divlist, $parmlist[$i]);
            }
        }

#   Otherwise, fall back on some defaults
    } else {
        $src_file = $src_type = $pmin = $pmax = $ptitle = "";
        $src_lines       = 0;
        $tecplot         = 0;
        $parm            = "Unknown";
        $parm_short      = $parm;
        @parmlist        = ();
        $parmlist[0]     = $parm;
        $parm_chars      = length($parm) +2;
        $parm_div        = "None";
        @parm_divlist    = ();
        $parm_divlist[0] = $parm_div;
        $units           = "";
        $cscheme         = "Blue to Orange";
        $ncolors         = 20;
        $tol             = 10;
        $conv_type       = $conv_types[0];
        $conv_mult       = 1.0;
        $conv_add        = 0.0;
        $lcon_freq       = "";
        $jd_skip_parm    = 0;
    }
    $oldsrc_type   = $src_type;
    $oldparm       = $parm;
    $oldparm_short = $parm_short;
    $old_units     = $units;

    $nwb   = $grid{$id}{nwb};
    $imx   = $grid{$id}{imx};
    @bs    = @{ $grid{$id}{bs}    };
    @be    = @{ $grid{$id}{be}    };
    @us    = @{ $grid{$id}{us}    };
    @ds    = @{ $grid{$id}{ds}    };
    @slope = @{ $grid{$id}{slope} };
    @nspr  = @{ $grid{$id}{nspr}  };
    @sprf  = @{ $grid{$id}{sprf}  };
    @ncpl  = @{ $grid{$id}{ncpl}  };
    @cplf  = @{ $grid{$id}{cplf}  };
    @nvpl  = @{ $grid{$id}{nvpl}  };
    @vplf  = @{ $grid{$id}{vplf}  };
    @wdof  = @{ $grid{$id}{wdof}  };

    $segnum = $props{$id}{seg};
    $wb_txt = "";
    for ($jw=1; $jw<=$nwb; $jw++) {
        for ($jb=$bs[$jw]; $jb<=$be[$jw]; $jb++) {
            if ($segnum >= $us[$jb] && $segnum <= $ds[$jb]) {
                $wb_txt = " (waterbody $jw, branch $jb)";
                last;
            }
        }
        last if ($wb_txt ne "");
    }
    $segnum_txt = sprintf("%d", $segnum) . $wb_txt;

    $jd_skip_active = $jd_skip_parm_active = 0;
    $jd_skip = $props{$id}{jd_skip};
    $jd_skip = 0 if ($jd_skip < 0 || $jd_skip > 49);
    for ($i=1; $i<=$#wdof; $i++) {
        if ($wdof[$i] < 1.0) {
            $jd_skip_active = 1;
            last;
        }
    }
    @jd_skip_opts = ("(keep all)", "(keep every other)", "(keep every 3rd)", "(keep every 4th)",
                     "(keep every 5th)",  "(keep every 6th)",  "(keep every 7th)",  "(keep every 8th)",
                     "(keep every 9th)",  "(keep every 10th)", "(keep every 11th)", "(keep every 12th)",
                     "(keep every 13th)", "(keep every 14th)", "(keep every 15th)", "(keep every 16th)",
                     "(keep every 17th)", "(keep every 18th)", "(keep every 19th)", "(keep every 20th)",
                     "(keep every 21st)", "(keep every 22nd)", "(keep every 23rd)", "(keep every 24th)",
                     "(keep every 25th)", "(keep every 26th)", "(keep every 27th)", "(keep every 28th)",
                     "(keep every 29th)", "(keep every 30th)", "(keep every 31st)", "(keep every 32nd)",
                     "(keep every 33rd)", "(keep every 34th)", "(keep every 35st)", "(keep every 36th)",
                     "(keep every 37th)", "(keep every 38th)", "(keep every 39th)", "(keep every 40th)",
                     "(keep every 41st)", "(keep every 42nd)", "(keep every 43rd)", "(keep every 44th)",
                     "(keep every 45th)", "(keep every 46th)", "(keep every 47th)", "(keep every 48th)",
                     "(keep every 49th)", "(keep every 50th)");
    $jd_skip_explain = $jd_skip_opts[$jd_skip];

    $wdof_min = $sprf_min = $cplf_min = $vplf_min =  9.E6;
    $wdof_max = $sprf_max = $cplf_max = $vplf_max = -9.E6;
    for ($i=1; $i<=$#wdof; $i++) {
        $wdof_min = $wdof[$i] if ($wdof[$i] < $wdof_min);
        $wdof_max = $wdof[$i] if ($wdof[$i] > $wdof_max);
    }
    if ($wdof_min == $wdof_max) {
        $wdo_msg = "Outflow frequency is " . $wdof_min;
    } else {
        $wdo_msg = "Outflow frequency range: " . $wdof_min . " - " . $wdof_max;
    }
    $wdo_msg .= ($wdof_max > 1.0) ? " days." : " day.";

    for ($i=1; $i<=$nspr[$jw]; $i++) {
        $sprf_min = $sprf[$i][$jw] if ($sprf[$i][$jw] < $sprf_min);
        $sprf_max = $sprf[$i][$jw] if ($sprf[$i][$jw] > $sprf_max);
    }
    if ($sprf_min == $sprf_max) {
        $spr_msg = "Spreadsheet frequency is " . $sprf_min;
    } else {
        $spr_msg = "Spreadsheet frequency range: " . $sprf_min . " - " . $sprf_max;
    }
    $spr_msg .= ($sprf_max > 1.0) ? " days." : " day.";

    for ($i=1; $i<=$ncpl[$jw]; $i++) {
        $cplf_min = $cplf[$i][$jw] if ($cplf[$i][$jw] < $cplf_min);
        $cplf_max = $cplf[$i][$jw] if ($cplf[$i][$jw] > $cplf_max);
    }
    if ($cplf_min == $cplf_max) {
        $cpl_msg = "Contour frequency is " . $cplf_min;
    } else {
        $cpl_msg = "Contour frequency range: " . $cplf_min . " - " . $cplf_max;
    }
    $cpl_msg .= ($cplf_max > 1.0) ? " days." : " day.";

    for ($i=1; $i<=$nvpl[$jw]; $i++) {
        $vplf_min = $vplf[$i][$jw] if ($vplf[$i][$jw] < $vplf_min);
        $vplf_max = $vplf[$i][$jw] if ($vplf[$i][$jw] > $vplf_max);
    }
    if ($vplf_min == $vplf_max) {
        $vpl_msg = "Vector frequency is " . $vplf_min;
    } else {
        $vpl_msg = "Vector frequency range: " . $vplf_min . " - " . $vplf_max;
    }
    $vpl_msg .= ($vplf_max > 1.0) ? " days." : " day.";

    if ($lcon_freq eq "") {
        $lcon_msg = "Lake Contour frequency is unknown.";
    } else {
        $lcon_msg = "Lake Contour frequency is " . $lcon_freq . " day.";
    }

    if ($src_type =~ /Spreadsheet/i) {
        $jd_skip_parm_active = 1 if ($sprf_min < 1.0);
    } elsif ($src_type =~ /Contour/i) {
        $jd_skip_parm_active = 1 if ($cplf_min < 1.0);
    } elsif ($src_type =~ /Vector/i) {
        $jd_skip_parm_active = 1 if ($vplf_min < 1.0);
    } elsif ($src_type =~ /LakeCon/i) {
        $jd_skip_parm_active = 1 if ($lcon_freq ne "" && $lcon_freq < 1.0);
    }
    $jd_skip_parm_explain = $jd_skip_opts[$jd_skip_parm];

#   Available initial colormaps
    @cmaps = ("Blue to Orange", "Blue to Red", "CoolWarm", "Turbo", "Viridis");

#   Set up the menu
    $frame = $w2outflow_setup_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -state   => 'disabled',
            -command => sub { my ($confirm_type, %parms);
                              if ($src_type =~ /Spreadsheet/i) {
                                  if ($src_file eq "" || ! -e $src_file) {
                                      return &pop_up_error($w2outflow_setup_menu,
                                      "W2 Spreadsheet file not set or does not exist:\n$src_file");
                                  }
                              } elsif ($src_type =~ /Contour/i) {
                                  if ($src_file eq "" || ! -e $src_file) {
                                      return &pop_up_error($w2outflow_setup_menu,
                                      "W2 Contour file not set or does not exist:\n$src_file");
                                  }
                              } elsif ($src_type =~ /Vector/i) {
                                  if ($src_file eq "" || ! -e $src_file) {
                                      return &pop_up_error($w2outflow_setup_menu,
                                      "W2 Vector file not set or does not exist:\n$src_file");
                                  }
                              } elsif ($src_type =~ /LakeCon/i) {
                                  if ($src_file eq "" || ! -e $src_file) {
                                      return &pop_up_error($w2outflow_setup_menu,
                                      "W2 Lake Contour file not set or does not exist:\n$src_file");
                                  }
                              }
                              $confirm_type = &confirm_w2_ftype($w2outflow_setup_menu, $src_file);
                              if ($src_type =~ /Spreadsheet/i && $confirm_type ne "spr") {
                                  return &pop_up_error($w2outflow_setup_menu,
                                      "The W2 source file is not a W2 Spreadsheet file:\n$src_file");
                              } elsif ($src_type =~ /Contour/i && $confirm_type ne "cpl") {
                                  return &pop_up_error($w2outflow_setup_menu,
                                      "The W2 source file is not a W2 Contour file:\n$src_file");
                              } elsif ($src_type =~ /Vector/i && $confirm_type ne "w2l") {
                                  return &pop_up_error($w2outflow_setup_menu,
                                      "The W2 source file is not a W2 Vector (w2l) file:\n$src_file");
                              } elsif ($src_type =~ /LakeCon/i && $confirm_type ne "lcon1") {
                                  return &pop_up_error($w2outflow_setup_menu,
                                      "The W2 source file is not an acceptable\n"
                                    . "W2 Lake Contour (format 1) file:\n$src_file");
                              }
                              if ($pmin eq "" || $pmax eq "") {
                                  return &pop_up_error($w2outflow_setup_menu,
                                  "Please provide both a min and max for your parameter.");
                              }
                              if ($pmin >= $pmax) {
                                  return &pop_up_error($w2outflow_setup_menu,
                                      "The minimum parameter value must be\n"
                                    . "less than the maximum parameter value.");
                              }
                              if ($conv_type eq "Custom") {
                                  $conv_type = sprintf("Custom,%s,%s", $conv_mult, $conv_add);
                              }

                              %parms             = %{ $props{$id}{parms} };
                              $parms{pmin}       = $pmin;
                              $parms{pmax}       = $pmax;
                              $parms{cscheme}    = $cscheme;
                              $parms{ncolors}    = $ncolors;
                              $props{$id}{parms} = { %parms };

                              $props{$id}{data}       = 0;
                              $props{$id}{add_parm}   = 1;
                              $props{$id}{src_type}   = $src_type;
                              $props{$id}{src_file}   = $src_file;
                              $props{$id}{src_lines}  = $src_lines;
                              $props{$id}{tplot}      = $tecplot;
                              $props{$id}{parm}       = $parm;
                              $props{$id}{parm_div}   = $parm_div;
                              $props{$id}{parm_units} = $units;
                              $props{$id}{parm_ctype} = $conv_type;
                              $props{$id}{jd_skip}    = $jd_skip;
                              $props{$id}{parm_skip}  = $jd_skip_parm;
                              $props{$id}{match_tol}  = $tol;

                              $w2outflow_setup_menu->g_bind('<Destroy>', "");
                              $w2outflow_setup_menu->g_destroy();
                              undef $w2outflow_setup_menu;
                              &reset_bindings;

                              &make_w2_outflow($canv, $id, 0);
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $w2outflow_setup_menu->g_bind('<Destroy>', "");
                              $w2outflow_setup_menu->g_destroy();
                              undef $w2outflow_setup_menu;
                              if (! $graph_exists) {
                                  $canv->delete("graph" . $id);
                                  delete $props{$id};
                                  delete $grid{$id} if (defined($grid{$id}));
                              }
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Delete graph if this menu is destroyed by other than the Cancel button
    $w2outflow_setup_menu->g_bind('<Destroy>' => sub { undef $w2outflow_setup_menu;
                                                       if (! $graph_exists) {
                                                           $canv->delete("graph" . $id);
                                                           delete $props{$id}; 
                                                           delete $grid{$id} if (defined($grid{$id}));
                                                       }
                                                       &reset_bindings;
                                                     });

    $f = $w2outflow_setup_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "Please provide profile data from a W2 Spreadsheet, "
                     . "Contour, Vector, or Lake Contour file.",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -columnspan => 5, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Segment: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -text => $segnum_txt,
            -font => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "W2 Source Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($src_type_cb = $f->new_ttk__combobox(
            -textvariable => \$src_type,
            -values       => [ ("W2 Spreadsheet File", "W2 Contour File",
                                "W2 Vector File", "W2 LakeCon File") ],
            -state        => 'readonly',
            -width        => 20,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w', -pady => 2);
    $src_type_cb->g_bind("<<ComboboxSelected>>",
                          sub { return if ($src_type eq $oldsrc_type);
                                $oldsrc_type     = $src_type;
                                $src_file        = $ptitle = $units = $old_units = "";
                                $parm            = "Unknown";
                                $oldparm         = $parm;
                                $parm_short      = $parm;
                                $oldparm_short   = $parm;
                                @parmlist        = ();
                                $parmlist[0]     = $parm;
                                $parm_chars      = length($parm) +2;
                                $parm_div        = "None";
                                @parm_divlist    = ();
                                $parm_divlist[0] = $parm_div;
                                $parm_cb->configure(-values => [ @parmlist ],
                                                    -width  => $parm_chars);
                                $parm_div_cb->configure(-values => [ @parm_divlist ],
                                                        -width  => $parm_chars);
                                $units_cb->g_grid_remove();
                                $units_entry->g_grid();
                                $conv_type_na_label->g_grid_remove();
                                $custom_frame->g_grid() if ($conv_type eq "Custom");
                                $conv_type_cb->g_grid();
                                $ok_btn->configure(-state => 'disabled');

                                if ($src_type =~ /Spreadsheet|Contour|Vector|LakeCon/i) {
                                    $src_file_label->configure(-text => $src_type . ": ");
                                    $src_file_btn->configure(-state => 'normal');
                                    if ($slope[$jb] > 0.0) {
                                        if ($src_type =~ /Spreadsheet/i) {
                                            return &pop_up_info($w2outflow_setup_menu,
                                                    "Branch $jb has a nonzero slope.\n"
                                                  . "W2 spreadsheet outputs may not\n"
                                                  . "work well for nonzero branch slopes.\n"
                                                  . "Consider using the W2 Contour File\n"
                                                  . "or W2 Vector File output option.");
                                        } elsif ($src_type =~ /LakeCon/i) {
                                            return &pop_up_info($w2outflow_setup_menu,
                                                    "Branch $jb has a nonzero slope.\n"
                                                  . "W2 Lake Contour outputs may not\n"
                                                  . "work well for nonzero branch slopes.\n"
                                                  . "Consider using the W2 Contour File\n"
                                                  . "or W2 Vector File output option.");
                                        }
                                    }
                                } else {
                                    $src_file_label->configure(-text => "W2 Output File: ");
                                    $src_file_btn->configure(-state => 'disabled');
                                }
                                $jd_skip_parm_active = 0;
                                if ($src_type =~ /Spreadsheet/i) {
                                    $jd_skip_parm_active = 1 if ($sprf_min < 1.0);
                                } elsif ($src_type =~ /Contour/i) {
                                    $jd_skip_parm_active = 1 if ($cplf_min < 1.0);
                                } elsif ($src_type =~ /Vector/i) {
                                    $jd_skip_parm_active = 1 if ($vplf_min < 1.0);
                                } elsif ($src_type =~ /LakeCon/i) {
                                    $jd_skip_parm_active = 1;  # placeholder
                                }
                                if ($jd_skip_parm_active) {
                                    $jd_skip_parm_explain = $jd_skip_opts[$jd_skip_parm];
                                    $jd_skip_parm_label->g_grid();
                                    $jd_skip_parm_frame->g_grid();
                                    $msg_label->g_grid();
                                } else {
                                    $jd_skip_parm_label->g_grid_remove();
                                    $jd_skip_parm_frame->g_grid_remove();
                                    if ($jd_skip_active) {
                                        $msg_label->g_grid();
                                    } else {
                                        $msg_label->g_grid_remove();
                                    }
                                }
                              });

    $row++;
    ($src_file_label = $f->new_label(
            -text => "W2 Output File: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$src_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);
    ($src_file_btn = $f->new_button(
            -text    => "Browse",
            -state   => 'disabled',
            -command => sub { my ($confirm_type, $file, $i, $jjb, $jw_check,
                                  $pbar, $pbar_img, $pbar_win, $seg, $segs_ref, @segs);
                              $file = Tkx::tk___getOpenFile(
                                      -parent           => $w2outflow_setup_menu,
                                      -title            => "Select $src_type",
                                    # -initialdir       => abs_path(),
                                      -filetypes => [ ['All Files',  '*'],
                                                      ['CSV (comma delimited)', '.csv'],
                                                      ['W2 Output Files', '.opt'],
                                                      ['W2 Vector Files', '.w2l'],
                                                    ],
                                      );
                              if (defined($file) && -e $file) {
                                  $src_file        = File::Spec->rel2abs($file);
                                  $ptitle          = $units = $old_units = "";
                                  $parm            = "Unknown";
                                  $oldparm         = $parm;
                                  $parm_short      = $parm;
                                  $oldparm_short   = $parm;
                                  @parmlist        = ();
                                  $parmlist[0]     = $parm;
                                  $parm_chars      = length($parm) +2;
                                  $parm_div        = "None";
                                  @parm_divlist    = ();
                                  $parm_divlist[0] = $parm_div;
                                  $parm_cb->configure(-values => [ @parmlist ],
                                                      -width  => $parm_chars);
                                  $parm_div_cb->configure(-values => [ @parm_divlist ],
                                                          -width  => $parm_chars);
                                  $units_cb->g_grid_remove();
                                  $units_entry->g_grid();
                                  $conv_type_na_label->g_grid_remove();
                                  $custom_frame->g_grid() if ($conv_type eq "Custom");
                                  $conv_type_cb->g_grid();

                                  $confirm_type = &confirm_w2_ftype($w2outflow_setup_menu, $src_file);
                                  if ($src_type =~ /Spreadsheet/i && $confirm_type ne "spr") {
                                      $src_file = "";
                                      $ok_btn->configure(-state => 'disabled');
                                      return &pop_up_error($w2outflow_setup_menu,
                                          "The specified file is not a W2 Spreadsheet file:\n$file");
                                  } elsif ($src_type =~ /Contour/i && $confirm_type ne "cpl") {
                                      $src_file = "";
                                      $ok_btn->configure(-state => 'disabled');
                                      return &pop_up_error($w2outflow_setup_menu,
                                          "The specified file is not a W2 Contour file:\n$file");
                                  } elsif ($src_type =~ /Vector/i && $confirm_type ne "w2l") {
                                      $src_file = "";
                                      $ok_btn->configure(-state => 'disabled');
                                      return &pop_up_error($w2outflow_setup_menu,
                                          "The specified file is not a W2 Vector (w2l) file:\n$file");
                                  } elsif ($src_type =~ /LakeCon/i && $confirm_type ne "lcon1") {
                                      return &pop_up_error($w2outflow_setup_menu,
                                          "The specified file is not an acceptable\n"
                                        . "W2 Lake Contour (format 1) file:\n$file");
                                  }
                                  if ($src_type =~ /Spreadsheet/i) {
                                      ($pbar_win, $pbar, $pbar_img)
                                          = &create_alt_progress_bar($main, $id,
                                                                     "Scanning W2 spreadsheet file...");
                                      ($ok, $src_lines, $segs_ref, $parms_ref)
                                          = &scan_w2_spr_file($w2outflow_setup_menu, $src_file, $pbar_img);
                                      &destroy_progress_bar($main, $pbar_win);

                                      if ($ok ne "okay") {
                                          $src_file = "";
                                          $ok_btn->configure(-state => 'disabled');
                                          return &pop_up_error($w2outflow_setup_menu,
                                              "The specified file is not a W2 Spreadsheet file:\n$file");
                                      }
                                      @parmlist = @{ $parms_ref };
                                      @segs     = @{ $segs_ref  };
                                      if (&list_match($segnum, @segs) == -1) {
                                          $src_file = "";
                                          $ok_btn->configure(-state => 'disabled');
                                          return &pop_up_error($w2outflow_setup_menu,
                                              "The specified W2 Spreadsheet file does not\n"
                                            . "contain data for segment $segnum:\n$file");
                                      }

                                  } elsif ($src_type =~ /Contour/i) {
                                      ($pbar_win, $pbar, $pbar_img)
                                          = &create_alt_progress_bar($main, $id,
                                                                     "Scanning W2 contour file...");
                                      ($tecplot, $src_lines, $jw_check, $parms_ref, undef, undef)
                                          = &scan_w2_cpl_file($w2outflow_setup_menu, $src_file,
                                                              $id, 0, $pbar_img);
                                      &destroy_progress_bar($main, $pbar_win);

                                      if ($tecplot == -1) {
                                          $src_file = "";
                                          $ok_btn->configure(-state => 'disabled');
                                          return &pop_up_error($w2outflow_setup_menu,
                                              "The specified file is not a W2 Contour output file:\n$file");
                                      }
                                      if ($jw_check != $jw) {
                                          $src_file = "";
                                          $ok_btn->configure(-state => 'disabled');
                                          return &pop_up_error($w2outflow_setup_menu,
                                              "The specified W2 Contour file is not\n"
                                            . "from the correct waterbody ($jw):\n$file");
                                      }
                                      @segs = ();
                                      for ($jjb=$bs[$jw]; $jjb<=$be[$jw]; $jjb++) {
                                          push (@segs, ($us[$jjb] .. $ds[$jjb]));
                                      }
                                      if (&list_match($segnum, @segs) == -1) {
                                          $src_file = "";
                                          $ok_btn->configure(-state => 'disabled');
                                          return &pop_up_error($w2outflow_setup_menu,
                                              "The specified W2 Contour file does not\n"
                                            . "contain data for segment $segnum:\n$file");
                                      }
                                      @parmlist = @{ $parms_ref };

                                  } elsif ($src_type =~ /Vector/i) {
                                      $status_line = "Scanning W2 vector file...";
                                      ($ok, $parms_ref, undef, undef, undef)
                                              = &scan_w2_vector_file($w2outflow_setup_menu,
                                                                     $src_file, $id, 0);
                                      $status_line = "";

                                      if ($ok ne "okay") {
                                          $src_file = "";
                                          $ok_btn->configure(-state => 'disabled');
                                          return &pop_up_error($w2outflow_setup_menu,
                                              "The specified file is not a W2 Vector (w2l) file:\n$file");
                                      }
                                      if ($segnum > $imx) {
                                          $src_file = "";
                                          $ok_btn->configure(-state => 'disabled');
                                          return &pop_up_error($w2outflow_setup_menu,
                                              "The specified W2 Vector file does not\n"
                                            . "contain data for segment $segnum:\n$file");
                                      }
                                      @parmlist = @{ $parms_ref };

                                  } elsif ($src_type =~ /LakeCon/i) {
                                      ($pbar_win, $pbar, $pbar_img)
                                          = &create_alt_progress_bar($main, $id,
                                                                     "Scanning W2 Lake Contour file...");
                                      ($ftype, $src_parm, $meta, $src_lines)
                                          = &scan_w2_rlcon_file($w2outflow_setup_menu, $src_file, $pbar_img);
                                      &destroy_progress_bar($main, $pbar_win);

                                      if ($ftype ne "lcon1") {
                                          $src_file = "";
                                          $ok_btn->configure(-state => 'disabled');
                                          return &pop_up_error($w2outflow_setup_menu,
                                              "The specified file is not an acceptable\n"
                                            . "W2 Lake Contour (format 1) file:\n$file");
                                      }
                                      @parmlist = ($src_parm);
                                      ($seg, $lcon_freq) = split(/_/, $meta);
                                      if ($seg != $segnum) {
                                          $src_file = "";
                                          $ok_btn->configure(-state => 'disabled');
                                          return &pop_up_error($w2outflow_setup_menu,
                                              "The specified W2 Lake Contour file does not\n"
                                            . "contain data for segment $segnum:\n$file");
                                      }
                                      if ($lcon_freq < 1.0 && length($lcon_freq) > 6) {
                                          $lcon_freq = sprintf("%0.4f", $lcon_freq);
                                      }
                                      $lcon_msg = "Lake Contour frequency is " . $lcon_freq . " day.";
                                      $msg_label->configure(-text => $wdo_msg . "\n" . $spr_msg . "\n"
                                                                   . $cpl_msg . "\n" . $vpl_msg . "\n"
                                                                   . $lcon_msg);
                                      $jd_skip_parm_active = ($lcon_freq < 1.0) ? 1 : 0;
                                      if ($jd_skip_parm_active) {
                                          $jd_skip_parm_explain = $jd_skip_opts[$jd_skip_parm];
                                          $jd_skip_parm_label->g_grid();
                                          $jd_skip_parm_frame->g_grid();
                                          $msg_label->g_grid();
                                      } else {
                                          $jd_skip_parm_label->g_grid_remove();
                                          $jd_skip_parm_frame->g_grid_remove();
                                          if ($jd_skip_active) {
                                              $msg_label->g_grid();
                                          } else {
                                              $msg_label->g_grid_remove();
                                          }
                                      }
                                  }
                                  $parm_chars = length($parmlist[0]);
                                  for ($i=1; $i<=$#parmlist; $i++) {
                                      $parm_chars = &max($parm_chars, length($parmlist[$i]));
                                  }
                                  $parm_chars += 2;
                                  $parm_cb->configure(-values => [ @parmlist ],
                                                      -width  => $parm_chars);
                                  if (&list_match($parm, @parmlist) == -1) {
                                      $parm = $parmlist[0];
                                      $parm =~ s/^\s+//;
                                      $parm =~ s/\s+$//;
                                  }
                                  $parm_short = $parm;
                                  if ($parm eq "Temperature") {
                                      $units  = "Celsius" if ($units !~ /(Celsius|Fahrenheit)/);
                                      $ptitle = "Temperature, in degrees " . $units;
                                      $units_cb->g_grid();
                                      $units_entry->g_grid_remove();
                                      $conv_type_na_label->g_grid();
                                      $custom_frame->g_grid_remove();
                                      $conv_type_cb->g_grid_remove();
                                      $conv_type = "None";
                                  } else {
                                      $units = "";
                                      $parm_short =~ s/\(ms-1\)//i;
                                      $parm_short =~ s/\(m3s-1\)//i;
                                      $parm_short =~ s/ [kmu]?g\/L\/day//i;
                                      $parm_short =~ s/ [kmu]?g\/m2\/day//i;
                                      $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
                                      $parm_short =~ s/ [kmu]?g\/L//i;
                                      $parm_short =~ s/ [kmu]?g\/m3//i;
                                      $parm_short =~ s/ [kmu]?g\/m\^3//i;
                                      $parm_short =~ s/, days//i;
                                      $parm_short =~ s/ days//i;
                                      $parm_short =~ s/,$//;
                                      if ($parm eq "Horizontal Velocity" || $parm eq "Vertical Velocity") {
                                          $units  = "m/s";
                                          $ptitle = $parm_short . ", in m/s";
                                      } elsif ($parm eq "Horizontal Layer Flow") {
                                          $units  = "m3/s";
                                          $ptitle = $parm_short . ", in m3/s";
                                      } elsif ($parm eq "Density") {
                                          $units  = "kg/m3";
                                          $ptitle = $parm_short . ", in kg/m3";
                                      } else {
                                          $ptitle = $parm_short . ", in ";
                                      }
                                      $units_cb->g_grid_remove();
                                      $units_entry->g_grid();
                                      $conv_type_na_label->g_grid_remove();
                                      $custom_frame->g_grid() if ($conv_type eq "Custom");
                                      $conv_type_cb->g_grid();
                                  }
                                  $old_units     = $units;
                                  $oldparm       = $parm;
                                  $oldparm_short = $parm_short;
                                  @parm_divlist  = ("None");
                                  for ($i=0; $i<=$#parmlist; $i++) {
                                      next if ($parmlist[$i] eq "Horizontal Velocity"
                                               || $parmlist[$i] eq "Vertical Velocity"
                                               || $parmlist[$i] eq "Horizontal Layer Flow"
                                               || $parmlist[$i] eq "Density"
                                               || $parmlist[$i] eq "Habitat");
                                      if ($parm ne $parmlist[$i]) {
                                          push (@parm_divlist, $parmlist[$i]);
                                      }
                                  }
                                  $parm_div_cb->configure(-values => [ @parm_divlist ],
                                                          -width  => $parm_chars);
                                  if (&list_match($parm_div, @parm_divlist) == -1) {
                                      $parm_div = "None";
                                  }
                                  if ($parm eq "Temperature" || $parm eq "Horizontal Velocity"
                                        || $parm eq "Vertical Velocity" || $parm eq "Density"
                                        || $parm eq "Horizontal Layer Flow"
                                        || $parm eq "Habitat" || $#parm_divlist == 0) {
                                      $parm_div_label->g_pack_forget();
                                      $parm_div_cb->g_pack_forget();
                                      $parm_div = "None";
                                  } else {
                                      $parm_div_label->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                                      $parm_div_cb->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                                  }
                                  $ok_btn->configure(-state => 'normal');
                              } else {
                                  $ok_btn->configure(-state => 'disabled');
                              }
                            },
            ))->g_grid(-row => $row, -column => 4, -sticky => 'ew', -padx => 2, -pady => 2);

    $row++;
    $f->new_label(
            -text => "Parameter: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($parm_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    ($parm_cb = $parm_frame->new_ttk__combobox(
            -textvariable => \$parm,
            -values       => [ @parmlist ],
            -state        => 'readonly',
            -width        => $parm_chars,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $parm_cb->g_bind("<<ComboboxSelected>>",
                         sub { my ($i);
                               return if ($parm eq $oldparm);
                               $parm_short = $parm;
                               if ($parm eq "Temperature") {
                                   $units  = "Celsius" if ($units !~ /(Celsius|Fahrenheit)/);
                                   $ptitle = "Temperature, in degrees " . $units;
                                   $units_cb->g_grid();
                                   $units_entry->g_grid_remove();
                                   $conv_type_na_label->g_grid();
                                   $custom_frame->g_grid_remove();
                                   $conv_type_cb->g_grid_remove();
                                   $conv_type = "None";
                               } else {
                                   $units = "";
                                   $parm_short =~ s/\(ms-1\)//i;
                                   $parm_short =~ s/\(m3s-1\)//i;
                                   $parm_short =~ s/ [kmu]?g\/L\/day//i;
                                   $parm_short =~ s/ [kmu]?g\/m2\/day//i;
                                   $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
                                   $parm_short =~ s/ [kmu]?g\/L//i;
                                   $parm_short =~ s/ [kmu]?g\/m3//i;
                                   $parm_short =~ s/ [kmu]?g\/m\^3//i;
                                   $parm_short =~ s/, days//i;
                                   $parm_short =~ s/ days//i;
                                   $parm_short =~ s/,$//;
                                   if ($parm eq "Horizontal Velocity" || $parm eq "Vertical Velocity") {
                                       $units  = "m/s";
                                       $ptitle = $parm_short . ", in m/s";
                                   } elsif ($parm eq "Horizontal Layer Flow") {
                                       $units  = "m3/s";
                                       $ptitle = $parm_short . ", in m3/s";
                                   } elsif ($parm eq "Density") {
                                       $units  = "kg/m3";
                                       $ptitle = $parm_short . ", in kg/m3";
                                   } else {
                                       $ptitle = $parm_short . ", in ";
                                   }
                                   $units_cb->g_grid_remove();
                                   $units_entry->g_grid();
                                   $conv_type_na_label->g_grid_remove();
                                   $custom_frame->g_grid() if ($conv_type eq "Custom");
                                   $conv_type_cb->g_grid();
                               }
                               $old_units     = $units;
                               $oldparm       = $parm;
                               $oldparm_short = $parm_short;
                               @parm_divlist  = ("None");
                               for ($i=0; $i<=$#parmlist; $i++) {
                                   next if ($parmlist[$i] eq "Horizontal Velocity"
                                            || $parmlist[$i] eq "Vertical Velocity"
                                            || $parmlist[$i] eq "Horizontal Layer Flow"
                                            || $parmlist[$i] eq "Density"
                                            || $parmlist[$i] eq "Habitat");
                                   if ($parm ne $parmlist[$i]) {
                                       push (@parm_divlist, $parmlist[$i]);
                                   }
                               }
                               $parm_div_cb->configure(-values => [ @parm_divlist ]);
                               if (&list_match($parm_div, @parm_divlist) == -1) {
                                   $parm_div = "None";
                               }
                               if ($parm eq "Temperature" || $parm eq "Horizontal Velocity"
                                       || $parm eq "Vertical Velocity" || $parm eq "Density"
                                       || $parm eq "Horizontal Layer Flow"
                                       || $parm eq "Habitat" || $#parm_divlist == 0) {
                                   $parm_div_label->g_pack_forget();
                                   $parm_div_cb->g_pack_forget();
                                   $parm_div = "None";
                               } else {
                                   $parm_div_label->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                                   $parm_div_cb->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
                               }
                             });
    ($parm_div_label = $parm_frame->new_label(
            -text => " divided by ",
            -font => 'default',
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    ($parm_div_cb = $parm_frame->new_ttk__combobox(
            -textvariable => \$parm_div,
            -values       => [ @parm_divlist ],
            -state        => 'readonly',
            -width        => $parm_chars,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Conversion: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($conv_type_na_label = $f->new_label(
            -text => "n/a",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $conv_type_na_label->g_grid_remove();
    ($conv_type_cb = $f->new_ttk__combobox(
            -textvariable => \$conv_type,
            -values       => [ @conv_types ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $conv_type_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($conv_type eq "Custom") {
                                $custom_frame->g_grid();
                            } else {
                                $custom_frame->g_grid_remove();
                            }
                          }
                      );
    $row++;
    ($custom_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    $custom_frame->new_label(
            -text => "Multiply by: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_mult_entry = $custom_frame->new_entry(
            -textvariable => \$conv_mult,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_mult_entry->g_bind("<KeyRelease>",
                              sub { &numeric_entry_only($conv_mult_entry);
                                    my $chars = &max(7, length($conv_mult));
                                    $conv_mult_entry->configure(-width => $chars);
                                  });
    $custom_frame->new_label(
            -text => "  Then add: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_add_entry = $custom_frame->new_entry(
            -textvariable => \$conv_add,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_add_entry->g_bind("<KeyRelease>",
                             sub { &numeric_entry_only($conv_add_entry);
                                   my $chars = &max(7, length($conv_add));
                                   $conv_add_entry->configure(-width => $chars);
                                 });

    $row++;
    $f->new_label(
            -text => "Parameter Units: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($units_cb = $f->new_ttk__combobox(
            -textvariable => \$units,
            -values       => [ ("Celsius", "Fahrenheit") ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $units_cb->g_bind("<<ComboboxSelected>>",
                       sub { return if ($units eq $old_units);
                             $old_units = $units;
                             $pmin = 0 if ($pmin eq "-");
                             $pmax = 0 if ($pmax eq "-");
                             if ($units eq "Celsius") {
                                 $pmin = &floor(($pmin -32) /1.8) if ($pmin ne "");
                                 $pmax = &ceil(($pmax  -32) /1.8) if ($pmax ne "");
                             } elsif ($units eq "Fahrenheit") {
                                 $pmin = &floor($pmin *1.8 +32) if ($pmin ne "");
                                 $pmax = &ceil($pmax  *1.8 +32) if ($pmax ne "");
                             }
                             $ptitle = "Temperature, in degrees " . $units;
                           });
    $units_cb->g_grid_remove();
    ($units_entry = $f->new_entry(
            -textvariable => \$units,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $units_entry->g_bind("<KeyRelease>",
                         sub { my $chars = &max(7, length($units));
                               $units_entry->configure(-width => $chars);
                               if ($parm eq "Temperature") {
                                   $ptitle = "Temperature, in degrees " . $units;
                               } else {
                                   $ptitle = $parm_short . ", in " . $units;
                               }
                             });

    $row++;
    $f->new_label(
            -text => "Parameter Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$ptitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Parameter Min: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmin_entry = $f->new_entry(
            -textvariable => \$pmin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmin_entry ]);

    $row++;
    $f->new_label(
            -text => "Parameter Max: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmax_entry = $f->new_entry(
            -textvariable => \$pmax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmax_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmax_entry ]);

    $row++;
    $f->new_label(
            -text => "Color Scheme: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($cscheme_cb = $f->new_ttk__combobox(
            -textvariable => \$cscheme,
            -values       => [ @cmaps ],
            -state        => 'readonly',
            -width        => 15,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $cscheme_cb->g_bind("<<ComboboxSelected>>",
                           sub { my ($n);
                                 if ($cscheme =~ /CoolWarm|Turbo|Viridis/) {
                                     $ncolors_cb->configure(-values => [ (8 .. 100) ]);
                                 } else {
                                     $ncolors_cb->configure(-values =>
                                         [ (16, 18, 20, 22, 24, 30, 34, 38, 42, 46) ]);
                                     if ($ncolors < 16) {
                                         $ncolors = 16;
                                     } elsif ($ncolors > 46) {
                                         $ncolors = 46;
                                     } else {
                                         foreach $n (reverse @valid_nc) {
                                             if ($ncolors >= 2 *$n) {
                                                 $ncolors = 2 *$n;
                                                 last;
                                             }
                                         }
                                     }
                                 }
                               });

    $row++;
    $f->new_label(
            -text => "Number of Colors: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ncolors_cb = $f->new_ttk__combobox(
            -textvariable => \$ncolors,
            -values       => [ (16, 18, 20, 22, 24, 30, 34, 38, 42, 46) ],
            -state        => 'readonly',
            -width        => 4,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    if ($jd_skip_active) {
        $row++;
        $f->new_label(
                -text => "Outflow Skip: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($jd_skip_frame = $f->new_frame(
                -borderwidth => 0,
                -relief      => 'flat',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
        $jd_skip_frame->new_spinbox(
                -textvariable => \$jd_skip,
                -state        => 'readonly',
                -font         => 'default',
                -from         => 0,
                -to           => 49,
                -increment    => 1,
                -width        => 4,
                -command      => sub { $jd_skip_explain = $jd_skip_opts[$jd_skip]; },
                )->g_pack(-side => 'left', -anchor => 'w');
        $jd_skip_frame->new_label(
                -textvariable => \$jd_skip_explain,
                -font         => 'default',
                )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    }

    $row++;
    ($jd_skip_parm_label = $f->new_label(
            -text => "Parameter Skip: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($jd_skip_parm_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    $jd_skip_parm_frame->new_spinbox(
            -textvariable => \$jd_skip_parm,
            -state        => 'readonly',
            -font         => 'default',
            -from         => 0,
            -to           => 49,
            -increment    => 1,
            -width        => 4,
            -command      => sub { $jd_skip_parm_explain = $jd_skip_opts[$jd_skip_parm]; },
            )->g_pack(-side => 'left', -anchor => 'w');
    $jd_skip_parm_frame->new_label(
            -textvariable => \$jd_skip_parm_explain,
            -font         => 'default',
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);

    $row++;
    ($msg_label = $f->new_label(
            -text    => $wdo_msg . "\n" . $spr_msg . "\n" . $cpl_msg . "\n" . $vpl_msg . "\n" . $lcon_msg,
            -font    => 'default',
            -justify => 'left',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');

    $row++;
    $f->new_label(
            -text => "Match Tolerance: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($tol_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w');
    $tol_frame->new_spinbox(
            -textvariable => \$tol,
            -state        => 'readonly',
            -font         => 'default',
            -from         => 0,
            -to           => 60,
            -increment    => 1,
            -width        => 3,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $tol_frame->new_label(
            -text => " minutes",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');

    if ($jd_skip_parm_active) {
        $jd_skip_parm_label->g_grid();
        $jd_skip_parm_frame->g_grid();
        $msg_label->g_grid();
    } else {
        $jd_skip_parm_label->g_grid_remove();
        $jd_skip_parm_frame->g_grid_remove();
        if ($jd_skip_active) {
            $msg_label->g_grid();
        } else {
            $msg_label->g_grid_remove();
        }
    }
    if ($src_type =~ /Spreadsheet|Contour|Vector|LakeCon/i) {
        $src_file_label->configure(-text => $src_type . ": ");
        $src_file_btn->configure(-state => 'normal');
        $ok_btn->configure(-state => 'normal');
    }
    if ($parm eq "Temperature") {
        $units_cb->g_grid();
        $units_entry->g_grid_remove();
        $conv_type_na_label->g_grid();
        $custom_frame->g_grid_remove();
        $conv_type_cb->g_grid_remove();
        $conv_type = "None";
        $parm_div  = "None";
    } else {
        $units_cb->g_grid_remove();
        $units_entry->g_grid();
        $conv_type_na_label->g_grid_remove();
        $custom_frame->g_grid() if ($conv_type eq "Custom");
        $conv_type_cb->g_grid();
    }
    if ($parm eq "Temperature" || $parm eq "Horizontal Velocity" || $parm eq "Vertical Velocity"
                               || $parm eq "Horizontal Layer Flow" || $parm eq "Density"
                               || $parm eq "Habitat" || $#parm_divlist == 0 || $src_type =~ /LakeCon/i) {
        $parm_div_label->g_pack_forget();
        $parm_div_cb->g_pack_forget();
    } else {
        $parm_div_label->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        $parm_div_cb->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    }
    if ($conv_type ne "Custom") {
        $custom_frame->g_grid_remove();
    }
    if ($cscheme =~ /CoolWarm|Turbo|Viridis/) {
        $ncolors_cb->configure(-values => [ (8 .. 100) ]);
    } else {
        $ncolors_cb->configure(-values => [ (16, 18, 20, 22, 24, 30, 34, 38, 42, 46) ]);
        if ($ncolors < 16) {
            $ncolors = 16;
        } elsif ($ncolors > 46) {
            $ncolors = 46;
        } else {
            foreach $n (reverse @valid_nc) {
                if ($ncolors >= 2 *$n) {
                    $ncolors = 2 *$n;
                    last;
                }
            }
        }
    }
    $f->g_grid_columnconfigure(3, -weight => 2);

    Tkx::wm_resizable($w2outflow_setup_menu,0,0);
    &adjust_window_position($w2outflow_setup_menu);
    $w2outflow_setup_menu->g_focus;
}


sub make_w2_outflow {
    my ($canv, $id, $props_updated) = @_;
    my (
        $box_id, $cmap_image, $cs_max, $cs_min, $cs_range, $cs_rev,
        $cscheme1, $cscheme2, $data_available, $date_id, $date_label,
        $dsize, $dt, $dt2, $dt_parm, $dt_parm2, $elev_ref, $first,
        $found, $geom, $group_tags, $gtag, $i, $id2, $ih, $item, $iw,
        $j, $jw, $k, $kalt, $kn_digits, $kmx, $kt, $kt_parm, $kt_ref,
        $last_xp, $mi, $mismatch, $mult, $n, $ncolors, $new_graph, $np,
        $nwb, $parm_ref, $parm_short, $pbar, $pbar_window, $pval, $q_ref,
        $qmult, $refresh_menus, $resized, $seg, $surf_elev, $tabid, $tag,
        $tol, $update_cs, $v_ref, $X, $x1, $x2, $xmax, $xp, $Y, $y1, $y2,
        $ymax, $ymin, $yp, $yp1, $yp2, $yrange, $yval,

        @be, @bs, @colors, @coords, @cpl_files, @ds, @el, @elws, @flows,
        @grp_tags, @items, @kb, @mydates, @old_coords, @pdata, @scale,
        @tags, @us, @wbs,

        %axis_props, %color_key_props, %data, %elev_data, %kt_data, %limits,
        %parm_data, %parms, %profile, %qdata, %vdata,
       );

#   For new plots, pop up a menu for file names and parameters
    if (! defined($props{$id}{files})) {
        return &setup_w2_outflow($canv, $id);
    }

#   Make tag and get coordinates of graph frame
    $gtag   = "graph" . $id;
    @coords = @{ $props{$id}{coordlist} };
    ($x1, $y1, $x2, $y2) = @coords;

#   Determine whether group tags are present and save the list
    $group_tags = 0;
    @grp_tags   = ();
    @tags       = Tkx::SplitList($canv->itemcget($id, -tags));
    if (&list_search("group_", @tags) > -1) {
        $group_tags = 1;
        foreach $tag (@tags) {
            push (@grp_tags, $tag) if ($tag =~ /^group_/);
        }
    }

#   Read the data files, if not done already
    if (! defined($props{$id}{data}) || ! $props{$id}{data}) {
        %parms = %{ $props{$id}{parms} };
        $seg   = $props{$id}{seg};

#       Set up some variables previously read from the control file
        $nwb = $grid{$id}{nwb};
        @bs  = @{ $grid{$id}{bs} };
        @be  = @{ $grid{$id}{be} };
        @us  = @{ $grid{$id}{us} };
        @ds  = @{ $grid{$id}{ds} };
        for ($jw=1; $jw<=$nwb; $jw++) {
            last if ($seg >= $us[$bs[$jw]] && $seg <= $ds[$be[$jw]]);
        }

#       Don't change most graph attributes if just changing color parameters.
#       Also don't need to re-read the bathymetry file.
        if ($props{$id}{add_parm} && defined($gr_props{$id})) {
            %profile = %{ $gr_props{$id} };
        } else {
            %profile = ();

#           Set some variables and read the bathymetry file
            &read_bth($main, $id, $jw, $props{$id}{bth_file});
            &get_grid_elevations($main, $id, $jw);
        }

#       Don't need to re-read the layer outflows file if just changing color parameters
#       and the jd_skip parameter hasn't changed.
        if ($props{$id}{add_parm} && defined($gr_props{$id}) && defined($props{$id}{old_jd_skip})
             && $props{$id}{jd_skip} == $props{$id}{old_jd_skip}) {
            %qdata = %{ $profile{qdata} };
            %vdata = %{ $profile{vdata} };

        } else {
#           Move mouse cursor on first creation, to ensure that it changes to cursor_wait
            if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
                $canv->g_bind("<Motion>", "");
                Tkx::event_generate($main, "<Motion>", -warp => 1, -x => ($x1+$x2)/2, -y => ($y1+$y2)/2);
                $canv->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"), $canv, "menu" ]);
            }

#           Read the Layer Outflows file
            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $props{$id}{qla_lines},
                                                     "Reading W2 Layer Outflow file...");
            ($q_ref, $v_ref) = &read_w2_layer_outflow($main, $id, $props{$id}{qla_file}, $seg,
                                                      $props{$id}{byear}, $props{$id}{tz_offset},
                                                      $props{$id}{jd_skip}, $pbar);
            &destroy_progress_bar($main, $pbar_window);

            %qdata          = %{ $q_ref };
            %vdata          = %{ $v_ref };
            $profile{qdata} = { %qdata };
            $profile{vdata} = { %vdata };

#           Find minimum and maximum elevation and layer outflow values
            %limits = &find_w2_outflow_limits($id, $seg, \%qdata, \%vdata);
            $profile{date_min} = $limits{date_min};
            $profile{date_max} = $limits{date_max};
            $profile{dpth_min} = $limits{dpth_min};
            $profile{dpth_max} = $limits{dpth_max};
            $profile{elev_min} = $limits{elev_min};
            $profile{elev_max} = $limits{elev_max};
            $profile{flow_min} = $limits{flow_min};
            $profile{flow_max} = $limits{flow_max};
            $profile{vel_min}  = $limits{vel_min};
            $profile{vel_max}  = $limits{vel_max};
            undef %limits;
        }

#       Read the added parameter source file, if needed
        if ($props{$id}{add_parm}) {
            if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
                $canv->g_bind("<Motion>", "");
                Tkx::event_generate($main, "<Motion>", -warp => 1, -x => ($x1+$x2)/2, -y => ($y1+$y2)/2);
                $canv->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"), $canv, "menu" ]);
            }

            if ($props{$id}{src_type} =~ /Spreadsheet/i) {
                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $props{$id}{src_lines},
                                                             "Reading W2 spreadsheet file...");
                ($kt_ref, $elev_ref, $parm_ref)
                        = &read_w2_spr_file($main, $id, $props{$id}{src_file}, $props{$id}{parm},
                                            $props{$id}{parm_div}, $props{$id}{byear}, $seg,
                                            $props{$id}{tz_offset}, $props{$id}{parm_skip}, $pbar);
                &destroy_progress_bar($main, $pbar_window);

                %kt_data   = %{ $kt_ref   };
                %elev_data = %{ $elev_ref };
                %parm_data = %{ $parm_ref };

            } elsif ($props{$id}{src_type} =~ /Contour/i) {
                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $props{$id}{src_lines},
                                                             "Reading W2 contour file...");
                %data = &read_w2_cpl_file($main, $id, $jw, $props{$id}{src_file}, $props{$id}{tplot},
                                          $seg, $props{$id}{parm}, $props{$id}{parm_div},
                                          $props{$id}{byear}, $props{$id}{tz_offset},
                                          $props{$id}{parm_skip}, $pbar);
                &destroy_progress_bar($main, $pbar_window);

                %kt_data   = ();
                %elev_data = ();
                %parm_data = ();
                @mydates = keys %data;
                for ($j=0; $j<=$#mydates; $j++) {
                    $dt    = $mydates[$j];
                    $kt    = $data{$dt}{kt};
                    @elws  = @{ $data{$dt}{elws}      };
                    @pdata = @{ $data{$dt}{parm_data} };
                    if (defined($elws[$seg])) {
                        $elev_data{$dt} = $elws[$seg];
                        for ($k=$kt; $k<=$#pdata; $k++) {
                            $parm_data{$dt}[$k-$kt] = $pdata[$k][$seg];
                        }
                    }
                    $kt_data{$dt} = $kt;
                }
                undef %data;

            } elsif ($props{$id}{src_type} =~ /Vector/i) {
                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, -s $props{$id}{src_file},
                                                             "Reading W2 vector file...");
                $status_line = "Reading W2 vector file... Date = 1";
                %data = &read_w2_vector_file($main, $id, $props{$id}{src_file}, $seg,
                                             $props{$id}{parm}, $props{$id}{parm_div}, $props{$id}{byear},
                                             $props{$id}{tz_offset}, $props{$id}{parm_skip}, $pbar);
                &destroy_progress_bar($main, $pbar_window);

                %kt_data   = ();
                %elev_data = ();
                %parm_data = ();
                @kb        = @{ $grid{$id}{kb} };
                @mydates   = keys %data;
                for ($j=0; $j<=$#mydates; $j++) {
                    $dt    = $mydates[$j];
                    $kt    = $data{$dt}{kt};
                    @pdata = @{ $data{$dt}{parm_data} };
                    if (defined($data{$dt}{elws}) && $data{$dt}{elws} != -99) {
                        $elev_data{$dt} = $data{$dt}{elws};
                        for ($k=$kt; $k<=$#pdata; $k++) {
                            $parm_data{$dt}[$k-$kt] = $pdata[$k];
                            last if ($k >= $kb[$seg]);
                        }
                    }
                    $kt_data{$dt} = $kt;
                }
                undef %data;

            } elsif ($props{$id}{src_type} =~ /LakeCon/i) {
                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $props{$id}{src_lines},
                                                             "Reading W2 Lake Contour file...");
                ($kt_ref, $elev_ref, $parm_ref)
                        = &read_w2_lakecon_file($main, $id, $props{$id}{src_file}, $seg, $props{$id}{parm},
                                                $props{$id}{byear}, $props{$id}{tz_offset},
                                                $props{$id}{parm_skip}, $pbar);
                &destroy_progress_bar($main, $pbar_window);

                %kt_data   = %{ $kt_ref   };
                %elev_data = %{ $elev_ref };
                %parm_data = %{ $parm_ref };
            }

            if (&list_match($props{$id}{parm_ctype}, @conv_types) > 0
                  || $props{$id}{parm_ctype} =~ /^Custom,/) {
                $status_line = "Converting units...";
                Tkx::update_idletasks();
                %parm_data = &convert_timeseries($main, $props{$id}{parm_ctype}, 1, %parm_data);
                $status_line = "";
                Tkx::update_idletasks();
            }

#           Find minimum and maximum elevation and parameter values
            %limits = &find_w2_profile_limits($id, $seg, \%elev_data, \%parm_data);
            $profile{parm_min}  = $limits{parm_min};
            $profile{parm_max}  = $limits{parm_max};
            undef %limits;

            $profile{kt_data}   = { %kt_data   };
            $profile{elev_data} = { %elev_data };
            $profile{parm_data} = { %parm_data };
        }

#       Don't change most graph attributes if just changing color parameters
        if (! $props{$id}{add_parm} || ! defined($props{$id}{old_jd_skip})) {
            $profile{yfont}     = $default_family;
            $profile{yl_size}   = &min(11, &max(8, int((abs($x2-$x1)+abs($y2-$y1))/2./41)));
            $profile{yt_size}   = $profile{yl_size} +2;
            $profile{yl_weight} = 'normal';
            $profile{yt_weight} = 'normal';
            $profile{ytype}     = $parms{ytype};
            $profile{yunits}    = $parms{yunits};
            $profile{ymin}      = ($parms{ymin} ne "") ? $parms{ymin} : 0;
            $profile{ymax}      = $parms{ymax};
            $profile{ymajor}    = ($parms{ymajor} eq "") ? "auto" : $parms{ymajor};
            $profile{ypr_tics}  = "outside";
            $profile{yop_tics}  = "none";
            $profile{ytitle}    = $parms{ytype} . ", in " . $parms{yunits};

            $profile{xfont}     = $profile{yfont};
            $profile{xl_size}   = $profile{yl_size};
            $profile{xt_size}   = $profile{yt_size};
            $profile{xl_weight} = $profile{yl_weight};
            $profile{xt_weight} = $profile{yt_weight};
            $profile{xmin}      = 0;
            $profile{xmax}      = $parms{xmax};
            $profile{xmajor}    = ($parms{xmajor} eq "") ? "auto" : $parms{xmajor};
            $profile{xpr_tics}  = "outside";
            $profile{xop_tics}  = "none";
            $profile{qunits}    = $parms{qunits};
            if ($parms{qunits} eq "cfs/ft") {
                $profile{xtitle} = "Release Rate, in cfs/(vert. ft)";
            } elsif ($parms{qunits} eq "cms/m") {
                $profile{xtitle} = "Release Rate, in cms/(vert. m)";
            } elsif ($parms{qunits} eq "ft/s") {
                $profile{xtitle} = "Velocity, in ft/s";
            } else {
                $profile{xtitle} = "Velocity, in m/s";
            }

            $profile{gtfont}    = $profile{yfont};
            $profile{gt_size}   = $profile{yt_size};
            $profile{gs_size}   = $profile{gt_size} -1;
            $profile{gt_weight} = 'bold';
            $profile{gs_weight} = $profile{gt_weight};
            $profile{gtitle}    = $parms{gtitle};

            $profile{cs_rev}    =  0;
            $profile{cs_hide}   =  0;
            $profile{xleg_off}  = 40;
            $profile{yleg_off}  =  0;
            $profile{cs_width}  = 24;
            $profile{cs_major}  = "auto";
        }

        if (! $props{$id}{add_parm}) {
            undef $profile{add_cs} if (defined($profile{add_cs}));
        } else {
            if ($props{$id}{parm} eq "Temperature") {
                $profile{keytitle} = "Water temperature, in degrees " . $props{$id}{parm_units};
            } else {
                $parm_short = $props{$id}{parm};
                $parm_short =~ s/\(ms-1\)//i;
                $parm_short =~ s/\(m3s-1\)//i;
                $parm_short =~ s/ [kmu]?g\/L\/day//i;
                $parm_short =~ s/ [kmu]?g\/m2\/day//i;
                $parm_short =~ s/ [kmu]?g\/m\^2\/day//i;
                $parm_short =~ s/ [kmu]?g\/L//i;
                $parm_short =~ s/ [kmu]?g\/m3//i;
                $parm_short =~ s/ [kmu]?g\/m\^3//i;
                $parm_short =~ s/, days//i;
                $parm_short =~ s/ days//i;
                $parm_short =~ s/,$//;
                $profile{keytitle} = $parm_short . ", in " . $props{$id}{parm_units};
            }
            if (! defined($profile{keyfont})) {
                $profile{keyfont}   = $default_family;
                $profile{kn_size}   = $profile{yl_size};
                $profile{kt_size}   = $profile{yl_size} +2;
                $profile{kt_weight} = 'normal';
                $profile{kn_weight} = 'normal';
                $profile{kn_digits} = 1;
            }
            $profile{add_cs}    = 1;
            $profile{cs_height} = &max(2, &min(18, int(($y2-$y1+1) /$parms{ncolors})));
            if ($parms{cscheme} eq "Blue to Orange") {
                $profile{cscheme1} = "Blue";
                $profile{cscheme2} = "Orange";
                $profile{ncolors}  = $parms{ncolors} /2;
            } elsif ($parms{cscheme} eq "Blue to Red") {
                $profile{cscheme1} = "Blue";
                $profile{cscheme2} = "Red";
                $profile{ncolors}  = $parms{ncolors} /2;
            } else {
                $profile{cscheme1} = $parms{cscheme};
                $profile{cscheme2} = "None";
                $profile{ncolors}  = $parms{ncolors};
            }
            $profile{cs_min}  = $parms{pmin};
            $profile{cs_max}  = $parms{pmax};
            $profile{cs_link} = 0;

            if (@animate_ids && $#animate_ids >= 0) {
                $update_cs = 0;
                foreach $item (@animate_ids) {
                    next if ($item == $id);
                    next if ($props{$item}{meta} =~ /time_series|w2_wlevels/);
                    next if ($props{$item}{meta} eq "w2_outflow" && ! $props{$item}{add_parm});
                    if ($gr_props{$item}{cs_link} == 2) {
                        if ($props{$item}{meta} =~ /(w2_profile|w2_slice|w2_outflow)/
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$item}{parm_div}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                            $id2 = $item;
                            last;
                        } elsif ($props{$item}{meta} eq "w2_tdmap"
                             && $props{$item}{map_type}   eq "standard"
                             && $props{$item}{parm_sav}   eq $props{$id}{parm}
                             && $props{$item}{pdiv_sav}   eq $props{$id}{parm_div}
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                            $id2 = $item;
                            last;
                        } elsif ($props{$item}{meta} =~ /data_profile/
                             && $props{$item}{prof_type}  eq "standard"
                             && $props{$item}{parm}       eq $props{$id}{parm}
                             && $props{$id}{parm_div}     eq "None"
                             && $props{$item}{parm_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                            $id2 = $item;
                            last;
                        } elsif ($props{$item}{meta} =~ /vert_wd_zone/
                             && $props{$id}{parm}       eq "Temperature"
                             && $props{$id}{parm_div}   eq "None"
                             && $props{$item}{wt_units} eq $props{$id}{parm_units}) {
                            $update_cs = 1;
                            $id2 = $item;
                            last;
                        }
                    }
                }
                if (! $update_cs) {
                    foreach $item (@animate_ids) {
                        next if ($item == $id);
                        next if ($props{$item}{meta} =~ /data_profile|vert_wd_zone|time_series|w2_wlevels/);
                        next if ($props{$item}{meta} eq "w2_outflow" && ! $props{$item}{add_parm});
                        next if ($props{$item}{meta} =~ /w2_slice|w2_tdmap/
                                  && $props{$item}{src_type} ne $props{$id}{src_type});
                        if ($gr_props{$item}{cs_link} == 1) {
                            if ($props{$item}{meta} =~ /w2_profile|w2_outflow/
                                 && $props{$item}{parm}       eq $props{$id}{parm}
                                 && $props{$item}{parm_div}   eq $props{$id}{parm_div}
                                 && $props{$item}{parm_units} eq $props{$id}{parm_units}
                                 && $props{$item}{src_file}   eq $props{$id}{src_file}) {
                                $update_cs = 1;
                                $id2 = $item;
                                last;
                            } elsif (($props{$item}{meta} =~ /w2_slice/
                                      && $props{$item}{parm}       eq $props{$id}{parm}
                                      && $props{$item}{parm_div}   eq $props{$id}{parm_div}
                                      && $props{$item}{parm_units} eq $props{$id}{parm_units})
                                  || ($props{$item}{meta} eq "w2_tdmap"
                                      && $props{$item}{map_type}   eq "standard"
                                      && $props{$item}{parm_sav}   eq $props{$id}{parm}
                                      && $props{$item}{pdiv_sav}   eq $props{$id}{parm_div}
                                      && $props{$item}{parm_units} eq $props{$id}{parm_units})) {
                                if ($props{$item}{src_type} =~ /Contour/i) {
                                    @wbs       = split(/,/, $props{$item}{wb_list});
                                    @cpl_files = @{ $props{$item}{cpl_files} };
                                    for ($n=0; $n<=$#wbs; $n++) {
                                        if ($cpl_files[$n] eq $props{$id}{src_file}) {
                                            $update_cs = 1;
                                            $id2 = $item;
                                            last;
                                        }
                                    }
                                    last if ($update_cs);
                                } elsif ($props{$item}{src_type} =~ /Vector/i) {
                                    if ($props{$item}{w2l_file} eq $props{$id}{src_file}) {
                                        $update_cs = 1;
                                        $id2 = $item;
                                        last;
                                    }
                                }
                            }
                        }
                    }
                }
                if ($update_cs) {
                    $ncolors           = $profile{ncolors};
                    $profile{cs_link}  = $gr_props{$id2}{cs_link};
                    $profile{cscheme1} = $gr_props{$id2}{cscheme1};
                    $profile{cscheme2} = $gr_props{$id2}{cscheme2};
                    $profile{ncolors}  = $gr_props{$id2}{ncolors};
                    $profile{cs_rev}   = $gr_props{$id2}{cs_rev};
                    $profile{cs_min}   = $gr_props{$id2}{cs_min};
                    $profile{cs_max}   = $gr_props{$id2}{cs_max};
                    $profile{cs_major} = $gr_props{$id2}{cs_major};
                    if ($profile{cs_height} *$ncolors > $y2-$y1+1 && $profile{cs_height} > 2) {
                        $profile{cs_height} = &max(2, &min(18, int(($y2-$y1+1) /$profile{ncolors})));
                    }
                }
            }
        }
        $profile{redraw}  = 1;
        $gr_props{$id}    = { %profile };
        $props{$id}{data} = 1;
        $props{$id}{gnum} = ++$graph_num if (! defined($props{$id}{oldcoords}));
        $resized          = 0;
        $refresh_menus    = 0;
        undef %profile;

#       Rebuild the @dates array if the color-display parameter
#       was changed and the jd_skip value was also changed
        if ($props{$id}{add_parm} && defined($props{$id}{old_jd_skip})) {
            if ($props{$id}{jd_skip} != $props{$id}{old_jd_skip}) {
                &rebuild_datelist;
            }
            $refresh_menus = 1;
            $canv->delete($gtag . "_xaxis");
            $canv->delete($gtag . "_xaxisTitle");
            $canv->delete($gtag . "_yaxis");
            $canv->delete($gtag . "_yaxisTitle");
            $canv->delete($gtag . "_date");
            $canv->delete($gtag . "_gtitle");
            $canv->delete($gtag . "_colorKey");
            $canv->delete($gtag . "_colorKeyTitle");
            $canv->delete($gtag . "_profile");
            $canv->delete($gtag . "_colorProfile");
        }
        undef %parms;

#   Or use previously read info.  If resized, delete graph and redraw
    } else {
        @old_coords    = @{ $props{$id}{oldcoords} };
        $refresh_menus = 0;
        $resized       = 0;
        for ($i=0; $i<=$#coords; $i++) {
            if ($coords[$i] != $old_coords[$i]) {
                $resized = 1;
                last;
            }
        }
        return if (! $resized && ! $props_updated);
        $gr_props{$id}{redraw} = 1 if ($resized);

        $seg   = $props{$id}{seg};
        %qdata = %{ $gr_props{$id}{qdata} };
        %vdata = %{ $gr_props{$id}{vdata} };
        if ($props{$id}{add_parm} && $gr_props{$id}{add_cs}) {
            %kt_data   = %{ $gr_props{$id}{kt_data}   };
            %parm_data = %{ $gr_props{$id}{parm_data} };
        }
        $canv->delete($gtag . "_xaxis");
        $canv->delete($gtag . "_xaxisTitle");
        $canv->delete($gtag . "_yaxis");
        $canv->delete($gtag . "_yaxisTitle");
        $canv->delete($gtag . "_date");
        $canv->delete($gtag . "_gtitle");
        $canv->delete($gtag . "_colorKey");
        $canv->delete($gtag . "_colorKeyTitle");
        if ($gr_props{$id}{redraw}) {
            $canv->delete($gtag . "_profile");
            $canv->delete($gtag . "_colorProfile");
        }
    }
    $props{$id}{oldcoords}   = [ @coords ];
    $props{$id}{old_jd_skip} = $props{$id}{jd_skip};

#   Set the list of dates or merge the dates array if necessary
#   Add the graph to the list of animated graphs, if necessary
    if (! @animate_ids || &list_match($id, @animate_ids) == -1) {
        @mydates = sort keys %qdata;
        if (@dates && @animate_ids && $#animate_ids >= 0) {
            $mismatch = 0;
            foreach $id2 (@animate_ids) {
#               next if ($id2 == $id);
                next if ($props{$id2}{meta} =~ /data_profile_cmap|w2_profile_cmap|w2_tdmap|time_series/);
                if ($props{$id2}{meta} =~ /data_profile|w2_profile|w2_slice|w2_wlevels|vert_wd_zone/) {
                    $mismatch = 1;
                    last;
                } elsif ($props{$id2}{meta} eq "w2_outflow") {
                    if ($props{$id2}{qla_file}     ne $props{$id}{qla_file}
                        || $props{$id2}{byear}     != $props{$id}{byear}
                        || $props{$id2}{tz_offset} ne $props{$id}{tz_offset} 
                        || $props{$id2}{jd_skip}   != $props{$id}{jd_skip}) {
                        $mismatch = 1;
                        last;
                    }
                }
            }
            if ($mismatch) {
                if (defined($animate_tb) && Tkx::winfo_exists($animate_tb)) {
                    if ($animate_tb->g_wm_title() eq "Animation toolbar") {
                        $animate_tb->g_destroy();
                        undef $animate_tb;
                    }
                }
                $dt      = $dates[$dti-1];
                @dates   = &merge_dates(\@dates, \@mydates);
                $dti_max = $#dates+1;
                $dti     = 1 + &nearest_dt_index($dt, @dates);
                $dti++ if ($dti == 0);
            }
        } else {
            @dates   = @mydates;
            $dti_max = $#dates+1;
            $dti     = 1;
            $delay   = 0.5;
        }
        $dti_old = $dti;
        push (@animate_ids, $id);
    }
    $dt = $dates[$dti-1];              # Define current date/time
    if (! defined($qdata{$dt})) {      # Adjust by up to 10 minutes, if needed
        for ($mi=1; $mi<=10; $mi++) {
            $dt2 = &adjust_dt($dt, $mi);
            if (defined($qdata{$dt2})) {
                $dt = $dt2;
                last;
            }
            $dt2 = &adjust_dt($dt, -1 *$mi);
            if (defined($qdata{$dt2})) {
                $dt = $dt2;
                last;
            }
        }
    }
    $export_menu->entryconfigure(3, -state => 'normal') if ($use_GS);
    $pref_menu->entryconfigure(0,   -state => 'normal');

#   Plot a white rectangle below the graph frame
    @items     = Tkx::SplitList($canv->find_withtag($gtag . "_main"));
    $new_graph = ($#items >= 0) ? 0 : 1;
    if ($new_graph) {
        $box_id = $canv->create_rectangle($x1, $y1, $x2, $y2,
                             -outline => "",
                             -width   => 0,
                             -fill    => &get_rgb_code("white"),
                             -tags    => $gtag . " " . $gtag . "_main");
        $canv->lower($box_id, $id);
    } else {
        $canv->coords($gtag . "_main", @coords);
        $canv->raise($id, $gtag . "_main");
    }

#   Plot the date as a subtitle
    $xp = ($x1+$x2)/2.;
    $yp = ($gr_props{$id}{xop_tics} =~ /outside|cross/) ? $y1-14 : $y1-6;
    $date_label = &get_formatted_date($dt);
    $date_id = $canv->create_text($xp, $yp,
                       -anchor => 's',
                       -text   => $date_label,
                       -fill   => &get_rgb_code("black"),
                       -angle  => 0,
                       -tags   => $gtag . " " . $gtag . "_date",
                       -font   => [-family     => $gr_props{$id}{gtfont},
                                   -size       => $gr_props{$id}{gs_size},
                                   -weight     => $gr_props{$id}{gs_weight},
                                   -slant      => 'roman',
                                   -underline  => 0,
                                   -overstrike => 0,
                                  ]);
    @coords = Tkx::SplitList($canv->bbox($date_id));
    $dsize  = &max(10, abs($coords[3] - $coords[1]));

#   Plot the graph title
    $canv->create_text($xp, $yp-$dsize,
                       -anchor => 's',
                       -text   => $gr_props{$id}{gtitle},
                       -fill   => &get_rgb_code("black"),
                       -angle  => 0,
                       -tags   => $gtag . " " . $gtag . "_gtitle",
                       -font   => [-family     => $gr_props{$id}{gtfont},
                                   -size       => $gr_props{$id}{gt_size},
                                   -weight     => $gr_props{$id}{gt_weight},
                                   -slant      => 'roman',
                                   -underline  => 0,
                                   -overstrike => 0,
                                  ]);

#   Plot Y axis
    $axis_props{min}     = $gr_props{$id}{ymin};
    $axis_props{max}     = $gr_props{$id}{ymax};
    $axis_props{major}   = $gr_props{$id}{ymajor};
    $axis_props{pr_tics} = $gr_props{$id}{ypr_tics};
    $axis_props{op_tics} = $gr_props{$id}{yop_tics};
    $axis_props{minor}   = 1;
    $axis_props{reverse} = ($gr_props{$id}{ytype} eq "Depth") ? 1 : 0;
    $axis_props{title}   = $gr_props{$id}{ytitle};
    $axis_props{font}    = $gr_props{$id}{yfont};
    $axis_props{size1}   = $gr_props{$id}{yl_size};
    $axis_props{size2}   = $gr_props{$id}{yt_size};
    $axis_props{weight1} = $gr_props{$id}{yl_weight};
    $axis_props{weight2} = $gr_props{$id}{yt_weight};
    $axis_props{side}    = "left";
    $axis_props{tags}    = $gtag . " " . $gtag . "_yaxis";
    $axis_props{coords}  = [$x1, $y2, $x1, $y1];
    $axis_props{op_loc}  = $x2;
    &make_axis($canv, %axis_props);
    undef %axis_props;

#   Plot X axis
    $axis_props{min}     = $gr_props{$id}{xmin};
    $axis_props{max}     = $gr_props{$id}{xmax};
    $axis_props{major}   = $gr_props{$id}{xmajor};
    $axis_props{pr_tics} = $gr_props{$id}{xpr_tics};
    $axis_props{op_tics} = $gr_props{$id}{xop_tics};
    $axis_props{minor}   = 1;
    $axis_props{reverse} = 0;
    $axis_props{title}   = $gr_props{$id}{xtitle};
    $axis_props{font}    = $gr_props{$id}{xfont};
    $axis_props{size1}   = $gr_props{$id}{xl_size};
    $axis_props{size2}   = $gr_props{$id}{xt_size};
    $axis_props{weight1} = $gr_props{$id}{xl_weight};
    $axis_props{weight2} = $gr_props{$id}{xt_weight};
    $axis_props{side}    = "bottom";
    $axis_props{tags}    = $gtag . " " . $gtag . "_xaxis";
    $axis_props{coords}  = [$x1, $y2, $x2, $y2];
    $axis_props{op_loc}  = $y1;
    &make_axis($canv, %axis_props);
    undef %axis_props;

#   Deal with optional color scheme and create optional color key
    if ($props{$id}{add_parm} && $gr_props{$id}{add_cs}) {
        $cscheme1  = $gr_props{$id}{cscheme1};
        $cscheme2  = $gr_props{$id}{cscheme2};
        $ncolors   = $gr_props{$id}{ncolors};
        $cs_rev    = $gr_props{$id}{cs_rev};
        $cs_min    = $gr_props{$id}{cs_min};
        $cs_max    = $gr_props{$id}{cs_max};
        $kn_digits = $gr_props{$id}{kn_digits};
        if (&list_match($cscheme1, @color_scheme_names) == -1 ||
           (&list_match($cscheme1, @full_color_schemes) == -1 && &list_match($ncolors, @valid_nc) == -1) ||
           (&list_match($cscheme1, @full_color_schemes) >= 0 && &list_match($ncolors, @valid_nc_alt) == -1) ||
           ($cscheme2 ne "" && $cscheme2 ne "None" && &list_match($cscheme2, @color_scheme_names) == -1)) {
            $cscheme1  = $gr_props{$id}{cscheme1}  = "Blue";
            $cscheme2  = $gr_props{$id}{cscheme2}  = "Orange";
            $ncolors   = $gr_props{$id}{ncolors}   = 11;
            $cs_rev    = $gr_props{$id}{cs_rev}    =  0;
            $cs_min    = $gr_props{$id}{cs_min}    =  0;
            $cs_max    = $gr_props{$id}{cs_max}    = 22;
            $kn_digits = $gr_props{$id}{kn_digits} =  1;
        }
        $cs_range = $cs_max -$cs_min;
        @colors   = &make_color_scheme($ncolors, $cs_rev, $cscheme1, $cscheme2);
        @scale    = ();
        for ($i=0; $i<=$#colors+1; $i++) {
            $j = $#colors +1 -$i;
            $scale[$j] = $cs_min +$cs_range*$j/($#colors+1);
        }
        $gr_props{$id}{colors}    = [ @colors ];
        $gr_props{$id}{scale}     = [ @scale  ];

        $color_key_props{xleg}    = $x2 + $gr_props{$id}{xleg_off};
        $color_key_props{yleg}    = $y1 + $gr_props{$id}{yleg_off};
        $color_key_props{width}   = $gr_props{$id}{cs_width};
        $color_key_props{height}  = $gr_props{$id}{cs_height};
        $color_key_props{colors}  = [ @colors ];
        $color_key_props{scale}   = [ @scale  ];
        $color_key_props{title}   = $gr_props{$id}{keytitle};
        $color_key_props{font}    = $gr_props{$id}{keyfont};
        $color_key_props{size1}   = $gr_props{$id}{kn_size};
        $color_key_props{size2}   = $gr_props{$id}{kt_size};
        $color_key_props{weight1} = $gr_props{$id}{kn_weight};
        $color_key_props{weight2} = $gr_props{$id}{kt_weight};
        $color_key_props{digits}  = $kn_digits;
        $color_key_props{major}   = $gr_props{$id}{cs_major};
        $color_key_props{tags}    = $gtag . " " . $gtag . "_colorKey";
        &make_color_key($canv, %color_key_props);
        undef %color_key_props;

        if ($gr_props{$id}{cs_hide}) {
            $canv->itemconfigure($gtag . "_colorKey", -state => 'hidden');
        }
    }

#   Refresh the Graph Properties menu and Object Information box, if present
    if ($refresh_menus) {
        if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
            if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
                $tabid = $grprops_notebook->index('current');
                $geom  = $graph_props_menu->g_wm_geometry();
                (undef, $X, $Y) = split(/\+/, $geom);
                &edit_graph_props($id, $X, $Y, $tabid);
            }
        }
        if (defined($object_infobox) && Tkx::winfo_exists($object_infobox)) {
            if ($object_infobox->g_wm_title() eq "Object Info") {
                $geom = $object_infobox->g_wm_geometry();
                (undef, $X, $Y) = split(/\+/, $geom);
                &show_info($canv, $id, $X, $Y);
            }
        }
    }

#   Don't recompute and redraw unless necessary
    if (! $gr_props{$id}{redraw}) {
        if ($props{$id}{add_parm} && $gr_props{$id}{add_cs}) {
            $canv->lower($gtag . "_colorKey",      $id);
            $canv->lower($gtag . "_colorKeyTitle", $id);
            $canv->lower($gtag . "_colorProfile",  $id);
        }
        $canv->lower($gtag . "_date",       $id);
        $canv->lower($gtag . "_gtitle",     $id);
        $canv->lower($gtag . "_xaxisTitle", $id);
        $canv->lower($gtag . "_yaxisTitle", $id);
        $canv->lower($gtag . "_profile",    $id);
        $canv->lower($gtag . "_xaxis",      $id);
        $canv->lower($gtag . "_yaxis",      $id);
        if ($group_tags) {
            foreach $tag (@grp_tags) {
                $canv->addtag($tag, withtag => $gtag);
            }
        }
        return;
    }

#   Determine whether layer outflow data are available on this date
#   and set the water-surface elevation
    if (defined($qdata{$dt})) {
        $data_available = 1;
    } else {
        $data_available = $np = 0;
    }

#   Get coordinates for the layer outflows
    if ($data_available) {
        if ($gr_props{$id}{qunits} eq "cfs/ft") {
            @flows = @{ $qdata{$dt} };
            $qmult = 10.763911;
        } elsif ($gr_props{$id}{qunits} eq "cms/m") {
            @flows = @{ $qdata{$dt} };
            $qmult = 1.0;
        } else {
            @flows = @{ $vdata{$dt} };
            $qmult = ($gr_props{$id}{qunits} eq "ft/s") ? 3.28084 : 1.0;
        }
        $surf_elev = $flows[1];                    # second member is WS elevation (m)
        $mult      = ($gr_props{$id}{yunits} eq "feet") ? 3.28084 : 1.0;
        $ymin      = $gr_props{$id}{ymin} /$mult;
        $ymax      = $gr_props{$id}{ymax} /$mult;  # keep depths & elevations in meters
        $yrange    = $ymax -$ymin;
        $kmx       = $grid{$id}{kmx};
        @el        = @{ $grid{$id}{el} };
        @kb        = @{ $grid{$id}{kb} };
        $xmax      = $gr_props{$id}{xmax};
        @coords    = ();
        $np        = 0;
        $first     = 1;
        $last_xp   = $x1;
        for ($k=2; $k<=$kmx; $k++) {
            next if (! defined($flows[$k]) || $flows[$k] eq "");
            if ($first) {
                $yval  = $surf_elev;
                $kt    = $k;
                $first = 0;
            } else {
                $yval  = $el[$k][$seg];
            }
            $xp = $x1 +($x2-$x1) *$flows[$k]*$qmult/$xmax;
            $xp = &max($x1, &min($x2, $xp));
            if ($gr_props{$id}{ytype} eq "Depth") {
                $yp1 = $y1 +($y2-$y1)*($surf_elev-$yval)/$ymax;
            } else {
                $yp1 = $y2 -($y2-$y1)*($yval-$ymin)/$yrange;
            }
            last if ($yp1 >= $y2);
            $yp1  = &max($y1, &min($y2, $yp1));
            $kalt = ($k == $kt && $kt > $kb[$seg]) ? $kb[$seg] : $k;
            if ($gr_props{$id}{ytype} eq "Depth") {
                $yp2 = $y1 +($y2-$y1)*($surf_elev-$el[$kalt+1][$seg])/$ymax;
            } else {
                $yp2 = $y2 -($y2-$y1)*($el[$kalt+1][$seg]-$ymin)/$yrange;
            }
            next if ($yp2 <= $y1);
            $yp2 = &max($y1, &min($y2, $yp2));
            if ($xp == $last_xp) {
                push (@coords, $xp, $yp1) if ($#coords < 0);
                push (@coords, $xp, $yp2);
            } else {
                push (@coords, $last_xp, $yp1, $xp, $yp1, $xp, $yp2);
            }
            if (! defined($flows[$k+1]) && $xp != $x1) {
                push (@coords, $x1, $yp2);
            }
            $np++ if ($xp > $x1);
            $last_xp = $xp;
            last if ($yp2 >= $y2);
        }

#       Work on a parameter-based color fill
        if ($np >= 1 && $props{$id}{add_parm} && $gr_props{$id}{add_cs}) {

#           Find a date match for the parameter-based color bars
            $dt_parm = $dt;
            $tol     = $props{$id}{match_tol};
            $found   = 0;
            if (defined($parm_data{$dt_parm})) {
                $found = 1;
            } elsif ($tol > 0) {
                for ($mi=1; $mi<=$tol; $mi++) {
                    $dt_parm2 = &adjust_dt($dt_parm, $mi);
                    if (defined($parm_data{$dt_parm2})) {
                        $dt_parm = $dt_parm2;
                        $found   = 1;
                        last;
                    }
                    $dt_parm2 = &adjust_dt($dt_parm, -1 *$mi);
                    if (defined($parm_data{$dt_parm2})) {
                        $dt_parm = $dt_parm2;
                        $found   = 1;
                        last;
                    }
                }
            }

#           If a match was found, create the color profile image
            if ($found) {
                $iw = $x2 -$x1 +1;
                $ih = $y2 -$y1 +1;
                $cmap_image = Tkx::image_create_photo(-width => $iw, -height => $ih);
                $cmap_image = Tkx::widget->new($cmap_image);

                if ($gr_props{$id}{ytype} eq "Depth") {
                    $yp2 = 0;
                } else {
                    $yp2 = &round_to_int($ih-1 -($ih-1)*($surf_elev-$ymin)/$yrange);
                    $yp2 = &max(0, &min($ih-1, $yp2));
                }
                $kt_parm = $kt_data{$dt_parm};

                for ($k=$kt; $k<=$kmx; $k++) {
                    $xp   = &round_to_int(($iw-1) *$flows[$k]*$qmult/$xmax);
                    $xp   = &max(0, &min($iw-1, $xp));
                    $yp1  = $yp2;
                    $kalt = ($k == $kt && $kt > $kb[$seg]) ? $kb[$seg] : $k;
                    if ($gr_props{$id}{ytype} eq "Depth") {
                        $yp2 = &round_to_int(($ih-1)*($surf_elev-$el[$kalt+1][$seg])/$ymax);
                    } else {
                        $yp2 = &round_to_int($ih-1 -($ih-1)*($el[$kalt+1][$seg]-$ymin)/$yrange);
                    }
                    last if ($yp1 >= $ih-1);
                    if ($yp2 < 0) {
                        $yp2 = 0;
                        next;
                    }
                    $yp2 = &min($ih-1, $yp2);
                    if ($xp > 0) {
                        $i    = &max(0, $k -$kt_parm);
                        $pval = $parm_data{$dt_parm}[$i];
                        if (defined($pval)) {
                            if ($props{$id}{parm} eq "Temperature"
                                  && $props{$id}{parm_units} eq "Fahrenheit") {
                                $j = int(($#colors+1) *(($pval *1.8 +32)-$cs_min)/$cs_range);
                            } else {
                                $j = int(($#colors+1) *($pval-$cs_min)/$cs_range);
                            }
                            $j = &max(0, &min($#colors, $j));
                            $cmap_image->put($colors[$j], -to => 0, $yp1, $xp, $yp2);
                        }
                    }
                    last if ($yp2 >= $ih-1);
                }
                $canv->create_image($x1, $y1, -anchor => 'nw',
                                              -image  => $cmap_image,
                                              -tags   => $gtag . " " . $gtag . "_colorProfile");
                undef $cmap_image;
            }
        }
        if ($props{$id}{add_parm} && $gr_props{$id}{add_cs}) {
            undef %kt_data;
            undef %parm_data;
        }

#       Plot the water surface and its indicator, if plotting elevations
        if ($gr_props{$id}{ytype} ne "Depth") {
            $yp = $y2 -($y2-$y1)*($surf_elev-$ymin)/$yrange;
            if ($yp >= $y1 && $yp <= $y2) {
                $canv->create_line($x1, $yp, $x2, $yp,
                                    -fill  => &get_rgb_code("gray60"),
                                    -width => 1,
                                    -arrow => 'none',
                                    -tags  => $gtag . " " . $gtag . "_profile");
                $xp = $x1 + 0.9*($x2-$x1);
                $canv->create_polygon($xp, $yp, $xp-4, $yp-8, $xp+4, $yp-8,
                                    -outline => &get_rgb_code("gray60"),
                                    -width   => 1,
                                    -fill    => &get_rgb_code("white"),
                                    -tags    => $gtag . " " . $gtag . "_profile");
            }
        }

#       Plot the profile
        if ($np >= 1) {
            $canv->create_line(@coords, -fill  => &get_rgb_code("black"),
                                        -width => 1,
                                        -arrow => 'none',
                                        -tags  => $gtag . " " . $gtag . "_profile");
        }
    }
    undef %qdata;
    undef %vdata;

#   Plot a no-data message
    if (! $data_available || $np < 1) {
        $canv->create_text(($x1+$x2)/2., ($y1+$y2)/2.,
                           -anchor => 'center',
                           -text   => "No Data",
                           -fill   => &get_rgb_code("gray60"),
                           -angle  => 0,
                           -tags   => $gtag . " " . $gtag . "_profile",
                           -font   => [-family     => $gr_props{$id}{xfont},
                                       -size       => $gr_props{$id}{xl_size},
                                       -weight     => 'normal',
                                       -slant      => 'roman',
                                       -underline  => 0,
                                       -overstrike => 0,
                                      ]);
    }

#   Place the graphic items in the proper order
    &raise_lower($canv, $id, "tiptop") if ($new_graph);
    if ($props{$id}{add_parm} && $gr_props{$id}{add_cs}) {
        $canv->lower($gtag . "_colorKey",      $id);
        $canv->lower($gtag . "_colorKeyTitle", $id);
        $canv->lower($gtag . "_colorProfile",  $id);
    }
    $canv->lower($gtag . "_date",       $id);
    $canv->lower($gtag . "_gtitle",     $id);
    $canv->lower($gtag . "_xaxisTitle", $id);
    $canv->lower($gtag . "_yaxisTitle", $id);
    $canv->lower($gtag . "_profile",    $id);
    $canv->lower($gtag . "_xaxis",      $id);
    $canv->lower($gtag . "_yaxis",      $id);
    if ($group_tags) {
        foreach $tag (@grp_tags) {
            $canv->addtag($tag, withtag => $gtag);
        }
    }

#   Update any links
#xxx &update_links($canv, $id, $dt);
}


sub setup_w2_wlevels_part2 {
    my ($canv, $id, $X, $Y) = @_;
    my (
        $fr, $frame, $frame2, $geom, $jw, $n, $ok_btn, $oldsrc_type, $row,
        $sc_canv, $sc_fr, $src_btn, $src_file, $src_label1, $src_label2,
        $src_type, $src_type_cb, $txt, $vscroll, $w2l_file, $wl_file,
        $wl_lines,

        @bth_files, @cbtn, @clab1, @clab2, @cpl_fdates, @cpl_files,
        @cpl_ldates, @cpl_lines, @f, @tecplot, @wbs,
       );

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($w2levels_setup_menu) && Tkx::winfo_exists($w2levels_setup_menu)) {
        if ($w2levels_setup_menu->g_wm_title() eq "W2 Water Levels Graph Setup"
             || $w2levels_setup_menu->g_wm_title() eq "Modify W2 Water Levels Graph") {
            $w2levels_setup_menu->g_destroy();
            undef $w2levels_setup_menu;
        }
    }
    $w2levels_setup_menu = $main->new_toplevel();
    $w2levels_setup_menu->g_wm_transient($main);
    $w2levels_setup_menu->g_wm_title("W2 Water Levels Graph Setup");
    $w2levels_setup_menu->configure(-cursor => $cursor_norm);
    $w2levels_setup_menu->g_wm_geometry($geom);

#   Try to keep the nascent graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

    @wbs         = split(/,/, $props{$id}{wb_list});
    @cpl_files   = @cpl_lines = @cpl_fdates = @cpl_ldates = @tecplot = @bth_files = ();
    $src_type    = "W2 Contour File";
    $oldsrc_type = $src_type;
    $src_file    = $w2l_file = $wl_file = "";
    $wl_lines    = 0;
    for ($n=0; $n<=$#wbs; $n++) {
        $cpl_files[$n] = "          ";
        $bth_files[$n] = "";
    }

#   Set up the menu
    $frame = $w2levels_setup_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -state   => 'disabled',
            -command => sub { my ($i, $j, $jw1, $jw2, $mismatch, $n,
                                  @cpld, @cplf, @ncpl, %parms);
                              %parms = ();
                              if ($src_type =~ /Contour/i) {
                                  for ($n=0; $n<=$#wbs; $n++) {
                                      if ($cpl_files[$n] eq "" || $cpl_files[$n] eq "          "
                                                               || ! -e $cpl_files[$n]) {
                                          return &pop_up_error($w2levels_setup_menu,
                                          "W2 Contour file not set or does not exist:\n$cpl_files[$n]");
                                      }
                                  }

#                                 Ensure contour dates and frequencies are identical for all waterbodies
                                  if ($#wbs > 0) {
                                      @ncpl = @{ $grid{$id}{ncpl} };
                                      @cpld = @{ $grid{$id}{cpld} };
                                      @cplf = @{ $grid{$id}{cplf} };
                                      $mismatch = 0;
                                      for ($j=0; $j<=$#wbs; $j++) {
                                          $jw1 = $wbs[$j];
                                          for ($n=$j+1; $n<=$#wbs; $n++) {
                                              $jw2 = $wbs[$n];
                                              if ($ncpl[$jw1] != $ncpl[$jw2]) {
                                                  $mismatch = 1;
                                                  last;
                                              }
                                              for ($i=1; $i<=$ncpl[$jw1]; $i++) {
                                                  if ($cpld[$i][$jw1] != $cpld[$i][$jw2] ||
                                                      $cplf[$i][$jw1] != $cplf[$i][$jw2]) {
                                                      $mismatch = 1;
                                                      last;
                                                  }
                                              }
                                              last if ($mismatch);
                                          }
                                          last if ($mismatch);
                                      }
                                      if ($mismatch) {
                                          return &pop_up_error($w2levels_setup_menu,
                                              "The contour plot output dates and frequencies for\n"
                                            . "the chosen waterbodies do not match. Please try again.");
                                      }
                                      $mismatch = 0;
                                      for ($j=0; $j<=$#wbs; $j++) {
                                          for ($n=$j+1; $n<=$#wbs; $n++) {
                                              if (abs($cpl_fdates[$j] -$cpl_fdates[$n]) > 0.0007 ||
                                                  abs($cpl_ldates[$j] -$cpl_ldates[$n]) > 0.0007) {
                                                  $mismatch = 1;
                                                  last;
                                              }
                                          }
                                          last if ($mismatch);
                                      }
                                      if ($mismatch) {
                                          return &pop_up_error($w2levels_setup_menu,
                                              "The contour plot output start and end dates for the\n"
                                            . "chosen waterbodies do not match. Please try again.");
                                      }
                                  }
                                  $props{$id}{tecplot}   = [ @tecplot   ];
                                  $props{$id}{cpl_lines} = [ @cpl_lines ];
                                  $props{$id}{cpl_files} = [ @cpl_files ];

                              } elsif ($src_type =~ /Vector/i) {
                                  if ($w2l_file eq "" || ! -e $w2l_file) {
                                      return &pop_up_error($w2levels_setup_menu,
                                      "W2 Vector file not set or does not exist:\n$w2l_file");
                                  }
                                  $props{$id}{w2l_file} = $w2l_file;

                              } elsif ($src_type =~ /Water Level/i) {
                                  if ($wl_file eq "" || ! -e $wl_file) {
                                      return &pop_up_error($w2levels_setup_menu,
                                      "W2 Water Level file not set or does not exist:\n$wl_file");
                                  }
                                  $props{$id}{wl_file}  = $wl_file;
                                  $props{$id}{wl_lines} = $wl_lines;
                              }

                              for ($n=0; $n<=$#wbs; $n++) {
                                  if ($bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                      return &pop_up_error($w2levels_setup_menu,
                                      "W2 Bathymetry file not set or does not exist:\n$bth_files[$n]");
                                  }
                              }
                              $props{$id}{files}     = 1;
                              $props{$id}{src_type}  = $src_type;
                              $props{$id}{bth_files} = [ @bth_files ];

                              $geom = $w2levels_setup_menu->g_wm_geometry();
                              (undef, $X, $Y) = split(/\+/, $geom);

                              $w2levels_setup_menu->g_bind('<Destroy>', "");
                              $w2levels_setup_menu->g_destroy();
                              undef $w2levels_setup_menu;

                              &setup_w2_wlevels_part3($canv, $id, $X, $Y, "");
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);

    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $w2levels_setup_menu->g_bind('<Destroy>', "");
                              $w2levels_setup_menu->g_destroy();
                              undef $w2levels_setup_menu;
                              $canv->delete("graph" . $id);
                              delete $props{$id};
                              delete $grid{$id};
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Delete graph if this menu is destroyed by other than the Cancel button
    $w2levels_setup_menu->g_bind('<Destroy>' => sub { undef $w2levels_setup_menu;
                                                      $canv->delete("graph" . $id);
                                                      delete $props{$id}; 
                                                      delete $grid{$id};
                                                      &reset_bindings;
                                                    });

#   Need a scrollable container, and a canvas is about the only container that works.
#   Create a parent frame (sc_fr) for the canvas (sc_canv) and scrollbar (vscroll).
#   Then put a frame inside the canvas (fr) as a widget window to hold other menu items.
    ($sc_fr = $w2levels_setup_menu->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_pack(-side => 'top', -expand => 1, -fill => 'both');
    ($vscroll = $sc_fr->new_scrollbar(
            -orient => 'vertical',
            -width  => 15,
            ))->g_grid(-row => 0, -column => 1, -sticky => 'nse');
    ($sc_canv = $sc_fr->new_tk__canvas(
            -highlightthickness => 0,
            -yscrollcommand => [$vscroll, 'set'],
            ))->g_grid(-row => 0, -column => 0, -sticky => 'nsew');
    $vscroll->configure(-command => [$sc_canv, 'yview']);

    $fr = $sc_canv->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );

#   Source type
    $row = 0;
    $fr->new_label(
            -text => "W2 Source Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($src_type_cb = $fr->new_ttk__combobox(
            -textvariable => \$src_type,
            -values       => [ ("W2 Contour File", "W2 Vector File", "W2 Water Level File") ],
            -width        => 20,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $src_type_cb->g_bind("<<ComboboxSelected>>",
                          sub { my ($n, $status);
                                return if ($src_type eq $oldsrc_type);
                                $oldsrc_type = $src_type;
                                $status      = 'normal';
                                if ($src_type =~ /Contour/i) {
                                    $src_label1->g_grid_remove();
                                    $src_label2->g_grid_remove();
                                    $src_btn->g_grid_remove();
                                    for ($n=0; $n<=$#wbs; $n++) {
                                        $clab1[$n]->g_grid();
                                        $clab2[$n]->g_grid();
                                        $cbtn[$n]->g_grid();
                                    }
                                    $frame2->g_grid() if ($#wbs > 0);
                                    for ($n=0; $n<=$#wbs; $n++) {
                                        if ($cpl_files[$n] eq "          " ||
                                            $cpl_files[$n] eq "" || ! -e $cpl_files[$n] ||
                                            $bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                            $status = 'disabled';
                                            last;
                                        }
                                    }
                                } else {
                                    $frame2->g_grid_remove() if ($#wbs > 0);
                                    for ($n=0; $n<=$#wbs; $n++) {
                                        $clab1[$n]->g_grid_remove();
                                        $clab2[$n]->g_grid_remove();
                                        $cbtn[$n]->g_grid_remove();
                                    }
                                    $src_label1->g_grid();
                                    $src_label2->g_grid();
                                    $src_btn->g_grid();
                                    if ($src_type =~ /Vector/i) {
                                        $src_label1->configure(-text => "W2 Vector File: ");
                                        $src_file = $w2l_file;
                                    } else {
                                        $src_label1->configure(-text => "W2 Water Level File: ");
                                        $src_file = $wl_file;
                                    }
                                    if ($src_file eq "" || ! -e $src_file) {
                                        $status = 'disabled';
                                    } else {
                                        for ($n=0; $n<=$#wbs; $n++) {
                                            if ($bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                                $status = 'disabled';
                                                last;
                                            }
                                        }
                                    }
                                }
                                $ok_btn->configure(-state => $status);
                                &update_scrollable_menu($w2levels_setup_menu, $sc_fr, $sc_canv,
                                                        'scrollable', $vscroll);
                              });

#   Input fields for W2 Vector file
    $row++;
    $txt = ($src_type =~ /Vector/i) ? "W2 Vector File: " : "W2 Water Level File: ";
    ($src_label1 = $fr->new_label(
            -text => $txt,
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($src_label2 = $fr->new_label(
            -textvariable => \$src_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'ew', -pady => 2);
    ($src_btn = $fr->new_button(
            -text    => "Browse",
            -command =>
               sub { my ($confirm_type, $file, $n, $ok, $pbar, $pbar_img, $pbar_win, $status);
                     if ($src_type =~ /Vector/i) {
                         $file = Tkx::tk___getOpenFile(
                                 -parent    => $w2levels_setup_menu,
                                 -title     => "Select W2 Vector Output File",
                                 -filetypes => [ ['All Files', '*'],
                                                 ['W2L (W2 Vector)', '.w2l'],
                                               ],
                                 );
                     } else {
                         $file = Tkx::tk___getOpenFile(
                                 -parent    => $w2levels_setup_menu,
                                 -title     => "Select W2 Water Levels File",
                                 -filetypes => [ ['All Files', '*'],
                                                 ['CSV (comma delimited)', '.csv'],
                                                 ['OPT (W2 output files)', '.opt'],
                                               ],
                                 );
                     }
                     if (defined($file) && -e $file) {
                         $src_file = File::Spec->rel2abs($file);
                         &update_scrollable_menu($w2levels_setup_menu,
                                                 $sc_fr, $sc_canv, 'scrollable', $vscroll);
                         if ($src_type =~ /Vector/i) {
                             $status_line = "Scanning W2 vector file...";  # no progress bar needed
                             Tkx::update_idletasks();
                             ($ok, undef, undef, undef, undef)
                                 = &scan_w2_vector_file($w2levels_setup_menu, $src_file, $id, 1);
                             $status_line = "";
                             if ($ok ne "okay") {
                                 $w2l_file = $src_file = "";
                                 $ok_btn->configure(-state => 'disabled');
                                 &update_scrollable_menu($w2levels_setup_menu,
                                                         $sc_fr, $sc_canv, 'scrollable', $vscroll);
                                 return &pop_up_error($w2levels_setup_menu,
                                                "The specified file is not a W2 Vector (w2l) file:\n$file");
                             }
                             $w2l_file = $src_file;
                         } else {
                             ($pbar_win, $pbar, $pbar_img)
                                 = &create_alt_progress_bar($main, $id, "Scanning W2 water level file...");
                             $confirm_type = &confirm_w2_ftype($w2levels_setup_menu, $src_file);
                             if ($confirm_type ne "wl") {
                                 $wl_file  = $src_file = "";
                                 $wl_lines = 0;
                                 &destroy_progress_bar($main, $pbar_win);
                                 $ok_btn->configure(-state => 'disabled');
                                 &update_scrollable_menu($w2levels_setup_menu,
                                                         $sc_fr, $sc_canv, 'scrollable', $vscroll);
                                 return &pop_up_error($w2levels_setup_menu,
                                          "The specified file is not a W2 Water Levels (wl) file:\n$file");
                             }
                             $wl_file = $src_file;
                             (undef, undef, $wl_lines)
                                      = &scan_w2_wlevel($w2levels_setup_menu, $wl_file, $pbar_img);
                             &destroy_progress_bar($main, $pbar_win);
                         }
                         $status = 'normal';
                         for ($n=0; $n<=$#wbs; $n++) {
                             if ($bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                 $status = 'disabled';
                                 last;
                             }
                         }
                         $ok_btn->configure(-state => $status);
                     } else {
                         $ok_btn->configure(-state => 'disabled');
                     }
                     &update_scrollable_menu($w2levels_setup_menu, $sc_fr, $sc_canv, 'scrollable', $vscroll);
                   },
            ))->g_grid(-row => $row, -column => 2, -sticky => 'ew', -padx => 2, -pady => 2);

    $fr->g_grid_columnconfigure(1, -weight => 2);
    $src_label1->g_grid_remove();
    $src_label2->g_grid_remove();
    $src_btn->g_grid_remove();

#   Loop over the required waterbodies
    for ($n=0; $n<=$#wbs; $n++) {
        $jw = $wbs[$n];

        $row++;
        ($f[$n] = $fr->new_labelframe(
                    -borderwidth => 1,
                    -relief      => 'groove',
                    -text        => "Waterbody $jw",
                ))->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew', -pady => 2);

        ($clab1[$n] = $f[$n]->new_label(
                -text => "W2 Contour File: ",
                -font => 'default',
                ))->g_grid(-row => 0, -column => 0, -sticky => 'e', -pady => 2);
        ($clab2[$n] = $f[$n]->new_label(
                -textvariable => \$cpl_files[$n],
                -anchor       => 'w',
                -font         => 'default',
                -background   => 'white',
                -relief       => 'sunken',
                -borderwidth  => 1,
                ))->g_grid(-row => 0, -column => 1, -sticky => 'ew', -pady => 2);
        ($cbtn[$n] = $f[$n]->new_button(
                -text    => "Browse",
                -command =>
                 [ sub { my ($n) = @_;
                         my ($file, $first_jd, $jw_src, $last_jd, $nlines,
                             $pbar, $pbar_img, $pbar_win, $status, $tecplot,
                            );
                         $file = Tkx::tk___getOpenFile(
                                 -parent    => $w2levels_setup_menu,
                                 -title     => "Select W2 Contour Output File",
                                 -filetypes => [ ['All Files', '*'],
                                                 ['CSV (comma delimited)', '.csv'],
                                                 ['OPT (W2 output files)', '.opt'],
                                               ],
                                 );
                         if (defined($file) && -e $file) {
                             $cpl_files[$n] = File::Spec->rel2abs($file);
                             &update_scrollable_menu($w2levels_setup_menu, $sc_fr, $sc_canv,
                                                     'scrollable', $vscroll);
                             ($pbar_win, $pbar, $pbar_img)
                                 = &create_alt_progress_bar($main, $id,
                                                            "Scanning W2 contour file...");
                             ($tecplot, $nlines, $jw_src, undef, $first_jd, $last_jd)
                                 = &scan_w2_cpl_file($w2levels_setup_menu, $cpl_files[$n], $id, 1, $pbar_img);
                             &destroy_progress_bar($main, $pbar_win);

                             if ($tecplot == -1) {
                                 $cpl_files[$n] = "          ";
                                 $ok_btn->configure(-state => 'disabled');
                                 &update_scrollable_menu($w2levels_setup_menu, $sc_fr, $sc_canv,
                                                         'scrollable', $vscroll);
                                 return &pop_up_error($w2levels_setup_menu,
                                     "Specified file is not a W2 Contour output file:\n$file");
                             }
                             if ($tecplot == 0 && $jw_src != $wbs[$n]) {
                                 $cpl_files[$n] = "          ";
                                 $ok_btn->configure(-state => 'disabled');
                                 &update_scrollable_menu($w2levels_setup_menu, $sc_fr, $sc_canv,
                                                         'scrollable', $vscroll);
                                 return &pop_up_error($w2levels_setup_menu,
                                         "The specified W2 Contour output file does not\n"
                                       . "appear to be from the correct waterbody:\n"
                                       . "(" . $jw_src . " rather than " . $wbs[$n] . "):\n$file");
                             }
                             $tecplot[$n]    = $tecplot;
                             $cpl_lines[$n]  = $nlines;
                             $cpl_fdates[$n] = $first_jd;
                             $cpl_ldates[$n] = $last_jd;

                             $status = 'normal';
                             for ($n=0; $n<=$#wbs; $n++) {
                                 if ($cpl_files[$n] eq "          " ||
                                     $cpl_files[$n] eq "" || ! -e $cpl_files[$n] ||
                                     $bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                     $status = 'disabled';
                                     last;
                                 }
                             }
                             $ok_btn->configure(-state => $status);
                         } else {
                             $ok_btn->configure(-state => 'disabled');
                         }
                         &update_scrollable_menu($w2levels_setup_menu, $sc_fr, $sc_canv,
                                                 'scrollable', $vscroll);
                       }, $n ],
                ))->g_grid(-row => 0, -column => 2, -sticky => 'ew', -padx => 2, -pady => 2);

        $f[$n]->new_label(
                -text => "W2 Bathymetry File: ",
                -font => 'default',
                )->g_grid(-row => 1, -column => 0, -sticky => 'e', -pady => 2);
        $f[$n]->new_label(
                -textvariable => \$bth_files[$n],
                -anchor       => 'w',
                -font         => 'default',
                -background   => 'white',
                -relief       => 'sunken',
                -borderwidth  => 1,
                )->g_grid(-row => 1, -column => 1, -sticky => 'ew', -pady => 2);
        $f[$n]->new_button(
                -text    => "Browse",
                -command =>
                 [ sub { my ($n) = @_;
                         my ($file, $status);
                         $file = Tkx::tk___getOpenFile(
                                 -parent           => $w2levels_setup_menu,
                                 -title            => "Select W2 Bathymetry File",
                                 -defaultextension => ".csv",
                                 -filetypes => [ ['CSV (comma delimited)', '.csv'],
                                                 ['NPT (W2 input files)', '.npt'],
                                                 ['All Files', '*'],
                                               ],
                                 );
                         if (defined($file) && -e $file) {
                             $bth_files[$n] = File::Spec->rel2abs($file);
                             $status = 'normal';
                             for ($n=0; $n<=$#wbs; $n++) {
                                 if ($src_type =~ /Contour/i) {
                                     if ($cpl_files[$n] eq "          " ||
                                         $cpl_files[$n] eq "" || ! -e $cpl_files[$n] ||
                                         $bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                         $status = 'disabled';
                                         last;
                                     }
                                 } else {
                                     if ($src_file      eq "" || ! -e $src_file ||
                                         $bth_files[$n] eq "" || ! -e $bth_files[$n]) {
                                         $status = 'disabled';
                                         last;
                                     }
                                 }
                             }
                             $ok_btn->configure(-state => $status);
                         } else {
                             $ok_btn->configure(-state => 'disabled');
                         }
                         &update_scrollable_menu($w2levels_setup_menu, $sc_fr, $sc_canv,
                                                 'scrollable', $vscroll);
                       }, $n ],
                )->g_grid(-row => 1, -column => 2, -sticky => 'ew', -padx => 2, -pady => 2);

        $f[$n]->g_grid_columnconfigure(1, -weight => 2);
    }

    if ($#wbs > 0) {
        $row++;
        ($frame2 = $fr->new_frame(
                    -borderwidth => 1,
                    -relief      => 'groove',
                ))->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'ew');

        $txt = "Note that this program works best when the contour output files from\n"
             . "each waterbody are assigned the same output dates and output frequencies.\n"
             . "In addition, each is required to include data for the parameter being plotted.";
        $frame2->new_label(
                -text    => $txt,
                -font    => 'default',
                -justify => 'left',
                )->g_pack(-side => 'left', -anchor => 'n', -expand => 1, -fill => 'x', -pady => 2);
    }

    $sc_canv->create_window(0, 0,
            -anchor => 'nw',
            -window => $fr,
            -tags   => 'scrollable',
            );
    &update_scrollable_menu($w2levels_setup_menu, $sc_fr, $sc_canv, 'scrollable', $vscroll);
    $sc_fr->g_grid_columnconfigure(0, -weight => 1);

    Tkx::wm_resizable($w2levels_setup_menu,0,0);
    &adjust_window_position($w2levels_setup_menu);
    $w2levels_setup_menu->g_focus;
}


sub setup_w2_wlevels_part3 {
    my ($canv, $id, $X, $Y, $change) = @_;
    my (
        $ask_about_checks, $byear, $byear_cb, $code, $color_btn, $extra_chk,
        $f, $fg, $frame, $geom, $gtitle, $i, $jb, $jd_skip, $jd_skip_active,
        $jd_skip_explain, $jw, $nbr, $new_graph, $offset_frame, $old_units,
        $row, $title, $tz_offset, $units, $units_cb, $wl_color, $wl_grid,
        $wl_gridc, $wl_gridc_btn, $wl_style, $xaxis_flip, $xaxis_frame,
        $xaxis_units, $ymajor, $ymajor_entry, $ymax, $ymax_entry, $ymin,
        $ymin_entry, $yr_max, $yr_min,

        @cplf, @ds, @jd_skip_opts, @ncpl, @nvpl, @seg_limits, @slope,
        @tsrf, @uhs, @us, @vplf, @wbs,
       );

    $change = "" if (! defined($change) || $change ne "misc");
    $geom   = sprintf("+%d+%d", $X, $Y);

    if (defined($w2levels_setup_menu) && Tkx::winfo_exists($w2levels_setup_menu)) {
        if ($w2levels_setup_menu->g_wm_title() eq "W2 Water Levels Graph Setup"
             || $w2levels_setup_menu->g_wm_title() eq "Modify W2 Water Levels Graph") {
            $w2levels_setup_menu->g_destroy();
            undef $w2levels_setup_menu;
        }
    }
    $w2levels_setup_menu = $main->new_toplevel();
    $w2levels_setup_menu->g_wm_transient($main);
    if ($change eq "misc") {
        $w2levels_setup_menu->g_wm_title("Modify W2 Water Levels Graph");
    } else {
        $w2levels_setup_menu->g_wm_title("W2 Water Levels Graph Setup");
    }
    $w2levels_setup_menu->configure(-cursor => $cursor_norm);
    $w2levels_setup_menu->g_wm_geometry($geom);

#   Try to keep the nascent graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

#   Retrieve parameter values if this graph already exists.
    $new_graph = (defined($props{$id}{oldcoords})) ? 0 : 1;
    if (! $new_graph) {
        &end_select($canv, $id, 1);
        $byear       = $props{$id}{byear};
        $tz_offset   = $props{$id}{tz_offset};
        $extra_chk   = $props{$id}{extra_chk};
        $jd_skip     = $props{$id}{jd_skip};
        $jd_skip     = 0 if ($jd_skip < 0 || $jd_skip > 49);
    } else {
        $byear       = $grid{$id}{byear};
        $tz_offset   = "+00:00";
        $jd_skip     = 0;
        $extra_chk   = ($props{$id}{src_type} =~ /Water Level/i) ? 1 : 0;
        $units       = "feet";
        $xaxis_units = "miles";
        $xaxis_flip  = 0;
        $gtitle      = "Water Levels Plot";
        $wl_color    = "black";
        $wl_style    = "Flat surface";
        $wl_grid     = 0;
        $wl_gridc    = "#D0D0D0";
        $title       = "Water Level, in " . $units;
        $old_units   = $units;
    }
    $yr_max = (localtime(time))[5] +1900;
    $yr_min = $yr_max -25;
    $yr_min = $byear -5 if ($byear <= $yr_min);
    $yr_max = $byear +5 if ($byear >= $yr_max);
    $ymax   = $ymin = $ymajor = "";

#   Skip some dates?
    $jd_skip_active = 0;
    if ($props{$id}{src_type} =~ /Contour/i) {
        @ncpl = @{ $grid{$id}{ncpl} };
        @cplf = @{ $grid{$id}{cplf} };
        @wbs  = split(/,/, $props{$id}{wb_list});
        foreach $jw (@wbs) {
            for ($i=1; $i<=$ncpl[$jw]; $i++) {
                if ($cplf[$i][$jw] < 1.0) {
                    $jd_skip_active = 1;
                    last;
                }
            }
            last if ($jd_skip_active);
        }
        undef @ncpl;
        undef @cplf;
        undef @wbs;
    } elsif ($props{$id}{src_type} =~ /Vector/i) {
        @nvpl = @{ $grid{$id}{nvpl} };
        @vplf = @{ $grid{$id}{vplf} };
        @wbs  = split(/,/, $props{$id}{wb_list});
        foreach $jw (@wbs) {
            for ($i=1; $i<=$nvpl[$jw]; $i++) {
                if ($vplf[$i][$jw] < 1.0) {
                    $jd_skip_active = 1;
                    last;
                }
            }
            last if ($jd_skip_active);
        }
        undef @nvpl;
        undef @vplf;
        undef @wbs;
    } else {
        if (defined($grid{$id}{wlf})) {
            $jd_skip_active = 1 if ($grid{$id}{wlf} < 1.0);
        } else {
            @tsrf = @{ $grid{$id}{tsrf} };
            for ($i=1; $i<=$grid{$id}{ntsr}; $i++) {
                if ($tsrf[$i] < 1.0) {
                    $jd_skip_active = 1.0;
                    last;
                }
            }
            undef @tsrf;
        }
    }
    @jd_skip_opts = ("(keep all)", "(keep every other)", "(keep every 3rd)", "(keep every 4th)",
                     "(keep every 5th)",  "(keep every 6th)",  "(keep every 7th)",  "(keep every 8th)",
                     "(keep every 9th)",  "(keep every 10th)", "(keep every 11th)", "(keep every 12th)",
                     "(keep every 13th)", "(keep every 14th)", "(keep every 15th)", "(keep every 16th)",
                     "(keep every 17th)", "(keep every 18th)", "(keep every 19th)", "(keep every 20th)",
                     "(keep every 21st)", "(keep every 22nd)", "(keep every 23rd)", "(keep every 24th)",
                     "(keep every 25th)", "(keep every 26th)", "(keep every 27th)", "(keep every 28th)",
                     "(keep every 29th)", "(keep every 30th)", "(keep every 31st)", "(keep every 32nd)",
                     "(keep every 33rd)", "(keep every 34th)", "(keep every 35st)", "(keep every 36th)",
                     "(keep every 37th)", "(keep every 38th)", "(keep every 39th)", "(keep every 40th)",
                     "(keep every 41st)", "(keep every 42nd)", "(keep every 43rd)", "(keep every 44th)",
                     "(keep every 45th)", "(keep every 46th)", "(keep every 47th)", "(keep every 48th)",
                     "(keep every 49th)", "(keep every 50th)");
    $jd_skip_explain = $jd_skip_opts[$jd_skip];

#   Determine whether extra checks might be needed
    $ask_about_checks = 0;
    if ($props{$id}{src_type} =~ /Water Level/i) {
        $nbr        = $grid{$id}{nbr};
        @us         = @{ $grid{$id}{us}    };
        @ds         = @{ $grid{$id}{ds}    };
        @uhs        = @{ $grid{$id}{uhs}   };
        @slope      = @{ $grid{$id}{slope} };
        @seg_limits = split(/,|-/, $props{$id}{seg_list});
        for ($i=0; $i<=$#seg_limits; $i+=2) {
            for ($jb=1; $jb<=$nbr; $jb++) {
                last if ($seg_limits[$i] >= $us[$jb] && $seg_limits[$i] <= $ds[$jb]);
            }
            if ($slope[$jb] == 0. && $uhs[$jb] == 0) {
                $ask_about_checks = 1;
                last;
            }
        }
        $extra_chk = 0 if ($new_graph && ! $ask_about_checks);
    }

#   Set up the menu
    $frame = $w2levels_setup_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    $frame->new_button(
            -text    => "OK",
            -command => sub { my ($result, %parms);
                              %parms = ();
                              if ($change ne "misc") {
                                  if ($ymin eq "" || $ymax eq "") {
                                      return &pop_up_error($w2levels_setup_menu,
                                        "Please provide both a min and max elevation.");
                                  }
                                  if ($ymin >= $ymax) {
                                      return &pop_up_error($w2levels_setup_menu,
                                        "The minimum elevation must be less than the maximum elevation.");
                                  }
                                  $gtitle =~ s/^\s+//;
                                  $gtitle =~ s/\s+$//;

                                  $parms{xunits}   = $xaxis_units;
                                  $parms{xflip}    = $xaxis_flip;
                                  $parms{ymin}     = $ymin;
                                  $parms{ymax}     = $ymax;
                                  $parms{ymajor}   = $ymajor;
                                  $parms{yunits}   = $units;
                                  $parms{wl_color} = $wl_color;
                                  $parms{wl_style} = $wl_style;
                                  $parms{wl_grid}  = $wl_grid;
                                  $parms{wl_gridc} = $wl_gridc;
                                  $parms{gtitle}   = $gtitle;
                              }
                              $parms{change} = $change;

#                             Rebuild the dates array if different segment, jd_skip, or byear
                              if (! $new_graph) {
                                  $parms{rebuild} = ($byear     != $props{$id}{byear}     ||
                                                     $tz_offset ne $props{$id}{tz_offset} ||
                                                     $jd_skip   != $props{$id}{jd_skip}) ? 1 : 0;
                                  if (! $parms{rebuild} && $extra_chk == $props{$id}{extra_chk}) {
                                      $result = &pop_up_question($w2levels_setup_menu,
                                                                 "No changes were made. Try again?");
                                      return if (lc($result) eq "yes");
                                      $w2levels_setup_menu->g_bind('<Destroy>', "");
                                      $w2levels_setup_menu->g_destroy();
                                      undef $w2levels_setup_menu;
                                      &reset_bindings;
                                      return;
                                  }
                              }
                              $props{$id}{parms}     = { %parms };
                              $props{$id}{data}      = 0;
                              $props{$id}{files}     = 1;
                              $props{$id}{byear}     = $byear;
                              $props{$id}{tz_offset} = $tz_offset;
                              $props{$id}{jd_skip}   = $jd_skip;
                              $props{$id}{extra_chk} = $extra_chk;

                              $w2levels_setup_menu->g_bind('<Destroy>', "");
                              $w2levels_setup_menu->g_destroy();
                              undef $w2levels_setup_menu;
                              &reset_bindings;

                              &make_w2_wlevels($canv, $id, 0);
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $w2levels_setup_menu->g_bind('<Destroy>', "");
                              $w2levels_setup_menu->g_destroy();
                              undef $w2levels_setup_menu;
                              if ($new_graph) {
                                  $canv->delete("graph" . $id);
                                  delete $props{$id};
                                  delete $grid{$id};
                              }
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Delete graph if this menu is destroyed by other than the Cancel button
    $w2levels_setup_menu->g_bind('<Destroy>' => sub { undef $w2levels_setup_menu;
                                                      if ($new_graph) {
                                                          $canv->delete("graph" . $id);
                                                          delete $props{$id};
                                                          delete $grid{$id};
                                                      }
                                                      &reset_bindings;
                                                    });

    ($f = $w2levels_setup_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_pack(-side => 'top');

    $row = -1;
    if ($change ne "misc") {
        $row++;
        $f->new_label(
                -text => "Water Level Units: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($units_cb = $f->new_ttk__combobox(
                -textvariable => \$units,
                -values       => [ ("feet", "meters") ],
                -state        => 'readonly',
                -width        => 8,
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
        $units_cb->g_bind("<<ComboboxSelected>>",
                           sub { return if ($units eq $old_units);
                                 $old_units = $units;
                                 $title = "Water Level, in " . $units;
                               });

        $row++;
        $f->new_label(
                -text => "Axis Title: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $f->new_label(
                -textvariable => \$title,
                -font         => 'default',
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

        $row++;
        $f->new_label(
                -text => "Water Level Min: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($ymin_entry = $f->new_entry(
                -textvariable => \$ymin,
                -font         => 'default',
                -width        => 7,
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $ymin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $ymin_entry ]);
        $f->new_label(
                -textvariable => \$units,
                -font         => 'default',
                -anchor       => 'w',
                )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

        $row++;
        $f->new_label(
                -text => "Water Level Max: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($ymax_entry = $f->new_entry(
                -textvariable => \$ymax,
                -font         => 'default',
                -width        => 7,
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $ymax_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $ymax_entry ]);
        $f->new_label(
                -textvariable => \$units,
                -font         => 'default',
                -anchor       => 'w',
                )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

        $row++;
        $f->new_label(
                -text => "Water Level Major: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($ymajor_entry = $f->new_entry(
                -textvariable => \$ymajor,
                -font         => 'default',
                -width        => 7,
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $ymajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($ymajor_entry, 1);
                                                    $ymajor =~ s/^-//;
                                                  });
        $f->new_label(
                -textvariable => \$units,
                -font         => 'default',
                -anchor       => 'w',
                )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

        $row++;
        $f->new_label(
                -text => "X Axis Units: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($xaxis_frame = $f->new_frame(
                -borderwidth => 0,
                -relief      => 'flat',
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
        $xaxis_frame->new_ttk__combobox(
                -textvariable => \$xaxis_units,
                -values       => [ ("miles", "kilometers") ],
                -state        => 'readonly',
                -width        => 10,
                )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
        $xaxis_frame->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "Flip Axis",
                -font     => 'default',
                -variable => \$xaxis_flip,
                )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    }

    $row++;
    $f->new_label(
            -text => "Base Year: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($byear_cb = $f->new_ttk__combobox(
            -textvariable => \$byear,
            -values       => [ reverse($yr_min .. $yr_max) ],
            -state        => 'readonly',
            -width        => 5,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $byear_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($byear == $yr_min || $byear == $yr_max) {
                                $yr_min -= 5 if ($byear == $yr_min);
                                $yr_max += 5 if ($byear == $yr_max);
                                $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                            }
                          }
                     );
    $f->new_label(
            -text   => " for JDAY = 1.0",
            -anchor => 'w',
            -font   => 'default',
            )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Time Offset: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($offset_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $offset_frame->new_ttk__combobox(
            -textvariable => \$tz_offset,
            -values       => [ @tz_offsets ],
            -justify      => 'right',
            -state        => 'readonly',
            -width        => 6,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $offset_frame->new_label(
            -text   => " time zone adjustment ",
            -anchor => 'w',
            -font   => 'default',
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $offset_frame->new_button(
            -text    => "Help",
            -command => sub { &pop_up_info($w2levels_setup_menu,
                                    "The time offset allows the user to add or subtract a time\n"
                                  . "offset if the W2 model was run with a non-local time zone.\n\n"
                                  . "For example, if W2 was run in UTC but the local time zone\n"
                                  . "is PST, an offset of -08:00 would convert the model date/time\n"
                                  . "to a local standard time of PST. This offset does not make\n"
                                  . "any adjustments related to daylight saving time. In general,\n"
                                  . "W2 is best run in the local standard time.\n\n"
                                  . "Leave the time offset at +00:00 for no adjustment.",
                                    "Time Offset Notice");
                            },
            )->g_pack(-side => 'left', -anchor => 'w', -padx => 2);

    if ($jd_skip_active) {
        $row++;
        $f->new_label(
                -text => "Skip Dates: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $f->new_spinbox(
                -textvariable => \$jd_skip,
                -state        => 'readonly',
                -font         => 'default',
                -from         => 0,
                -to           => 49,
                -increment    => 1,
                -width        => 4,
                -command      => sub { $jd_skip_explain = $jd_skip_opts[$jd_skip]; },
                )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $f->new_label(
                -textvariable => \$jd_skip_explain,
                -font         => 'default',
                )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);
    }

    if ($ask_about_checks) {
        $row++;
        $f->new_label(
                -text => "Filters: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $f->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "Extra checks for inactive segments",
                -font     => 'default',
                -variable => \$extra_chk,
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    }

    if ($change ne "misc") {
        $row++;
        $f->new_label(
                -text => "Line Style: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $f->new_ttk__combobox(
                -textvariable => \$wl_style,
                -values       => [("Flat surface", "Interpolate", "Branch slope")],
                -width        => 14,
                -state        => 'readonly',
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

        $row++;
        $f->new_label(
                -text => "Line Color: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);

        $code     = &get_rgb_code($wl_color);
        $wl_color = &get_rgb_name($code);
        $fg       = &get_rgb_code("White");
        if ($code =~ /^\#[0-9a-f]/i) {
            $fg = &get_rgb_code(&get_bw_contrast($code));
        }
        ($color_btn = $f->new_button(
                -textvariable => \$wl_color,
                -background   => $code,
                -foreground   => $fg,
                -width        => -7,
                -command => sub { my ($newc);
                                  $code = &get_rgb_code($wl_color);
                                  $newc = Tkx::tk___chooseColor(
                                             -initialcolor => $code,
                                             -parent       => $w2levels_setup_menu);
                                  if ($newc) {
                                      $code     = &get_rgb_code($newc);
                                      $wl_color = &get_rgb_name($code);
                                      $fg       = &get_rgb_code("black");
                                      if ($code =~ /^#?[0-9a-f]/i) {
                                          $fg = &get_rgb_code(&get_bw_contrast($code));
                                      }
                                      $color_btn->configure(-foreground => $fg,
                                                            -background => $code);
                                  }
                                }
                ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

        $row++;
        $f->new_label(
                -text => "Grid Layers: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $f->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "Show",
                -font     => 'default',
                -variable => \$wl_grid,
                -command  => sub { my $status = ($wl_grid) ? 'normal' : 'disabled';
                                   $wl_gridc_btn->configure(-state => $status);
                                 },
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

        $row++;
        $f->new_label(
                -text => "Grid Line Color: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);

        $code     = &get_rgb_code($wl_gridc);
        $wl_gridc = &get_rgb_name($code);
        $fg       = &get_rgb_code("black");
        if ($code =~ /^\#[0-9a-f]/i) {
            $fg = &get_rgb_code(&get_bw_contrast($code));
        }
        ($wl_gridc_btn = $f->new_button(
                -textvariable => \$wl_gridc,
                -background   => $code,
                -foreground   => $fg,
                -width        => -7,
                -command => sub { my ($newc);
                                  $code = &get_rgb_code($wl_gridc);
                                  $newc = Tkx::tk___chooseColor(
                                             -initialcolor => $code,
                                             -parent       => $w2levels_setup_menu);
                                  if ($newc) {
                                      $code     = &get_rgb_code($newc);
                                      $wl_gridc = &get_rgb_name($code);
                                      $fg       = &get_rgb_code("black");
                                      if ($code =~ /^#?[0-9a-f]/i) {
                                          $fg = &get_rgb_code(&get_bw_contrast($code));
                                      }
                                      $wl_gridc_btn->configure(-foreground => $fg,
                                                               -background => $code);
                                  }
                                }
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        if (! $wl_grid) {
            $wl_gridc_btn->configure(-state => 'disabled');
        }

        $row++;
        $f->new_label(
                -text => "Graph Title: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        $f->new_entry(
                -textvariable => \$gtitle,
                -font         => 'default',
                )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
    }
    $f->g_grid_columnconfigure(2, -weight => 2);

    Tkx::wm_resizable($w2levels_setup_menu,0,0);
    &adjust_window_position($w2levels_setup_menu);
    $w2levels_setup_menu->g_focus;
}


sub make_w2_wlevels {
    my ($canv, $id, $props_updated) = @_;
    my (
        $add_pt0, $add_pt3, $box_id, $confirm_type, $data_available,
        $date_id, $date_label, $dsize, $dsum, $dt, $dt2, $geom,
        $group_tags, $gtag, $i, $id2, $j, $jb, $jw, $k, $kmx, $last_jb,
        $last_seg, $last_xp, $last_yp, $mi, $mismatch, $mult, $n, $nd,
        $nbr, $new_graph, $np, $ns, $pbar, $pbar_window, $refresh_menus,
        $resized, $seg_dn, $seg_up, $src_type, $tabid, $tag, $wsel, $X,
        $x1, $x2, $xbase, $xd1, $xd2, $xdistance, $xmax, $xmin, $xmult,
        $xp, $xp0, $xp1, $xp2, $xp3, $xrange, $Y, $y1, $y2, $yexag, $ymax,
        $ymin, $yp, $yp0, $yp1, $yp2, $yp3, $yrange,

        @be, @bs, @bth_files, @coords, @cpl_files, @cpl_lines, @cus,
        @dlx, @ds, @el, @elws, @grp_tags, @items, @mydates, @old_coords,
        @seg_limits, @seglist, @slope, @tags, @tecplot, @us, @xdist, @wbs,

        %axis_props, %limits, %parms, %profile, %sdata, %wl_data,
       );

#   For new plots, pop up a menu for file names and parameters
    if (! defined($props{$id}{files})) {
        return &setup_w2_slice_or_tdmap_or_wlevels($canv, $id);
    }

#   Make tag and get coordinates of graph frame
    $gtag   = "graph" . $id;
    @coords = @{ $props{$id}{coordlist} };
    ($x1, $y1, $x2, $y2) = @coords;

#   Determine whether group tags are present and save the list
    $group_tags = 0;
    @grp_tags   = ();
    @tags       = Tkx::SplitList($canv->itemcget($id, -tags));
    if (&list_search("group_", @tags) > -1) {
        $group_tags = 1;
        foreach $tag (@tags) {
            push (@grp_tags, $tag) if ($tag =~ /^group_/);
        }
    }

#   Read the data file, if not done already
    if (! defined($props{$id}{data}) || ! $props{$id}{data}) {
        %parms    = %{ $props{$id}{parms} };
        @wbs      = split(/,/, $props{$id}{wb_list});
        $src_type = $props{$id}{src_type};

        if (defined($props{$id}{oldcoords})) {
            %profile   = %{ $gr_props{$id} };
            $new_graph = 0;
        } else {
            %profile   = ();
            $new_graph = 1;
        }

#       Validate the source type and input source file(s)
        if ($src_type =~ /Contour/i) {
            @cpl_files = @{ $props{$id}{cpl_files} };
            for ($n=0; $n<=$#wbs; $n++) {
                $confirm_type = &confirm_w2_ftype($main, $cpl_files[$n]);
                if ($confirm_type ne "cpl") {
                    return &pop_up_error($main,
                            "The W2 source file is not a W2 Contour file:\n$cpl_files[$n]");
                }
            }
        } elsif ($src_type =~ /Vector/i) {
            $confirm_type = &confirm_w2_ftype($main, $props{$id}{w2l_file});
            if ($confirm_type ne "w2l") {
                return &pop_up_error($main,
                        "The W2 source file is not a W2 Vector (w2l) file:\n$props{$id}{w2l_file}");
            }
        } else {
            $confirm_type = &confirm_w2_ftype($main, $props{$id}{wl_file});
            if ($confirm_type ne "wl") {
                return &pop_up_error($main,
                        "The W2 source file is not a W2 Water Levels (wl) file:\n$props{$id}{wl_file}");
            }
        }

#       Read bathymetry files, as necessary
#       Required for all source file types. Vector (w2l) files don't have a good kb value.
        if ($new_graph) {
            $status_line = "Reading bathymetry files...";
            Tkx::update_idletasks();
            @bth_files = @{ $props{$id}{bth_files} };
            for ($n=0; $n<=$#wbs; $n++) {
                &read_bth($main, $id, $wbs[$n], $bth_files[$n]);
                &get_grid_elevations($main, $id, $wbs[$n]);
            }
            $status_line = "";
            Tkx::update_idletasks();
        }

        if ($src_type =~ /Contour|Vector/i) {
            $nbr = $grid{$id}{nbr};
            @bs  = @{ $grid{$id}{bs} };
            @be  = @{ $grid{$id}{be} };
            @us  = @{ $grid{$id}{us} };
            @ds  = @{ $grid{$id}{ds} };
        }

#       Move mouse cursor on first creation, to ensure that it changes to cursor_wait
        if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
            $canv->g_bind("<Motion>", "");
            Tkx::event_generate($main, "<Motion>", -warp => 1, -x => ($x1+$x2)/2, -y => ($y1+$y2)/2);
            $canv->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"), $canv, "menu" ]);
        }

#       Read the contour files, if needed.
#       Water level is part of the normal return data; ask for Temperature then toss it.
        if ($src_type =~ /Contour/i) {
            @tecplot   = @{ $props{$id}{tecplot}   };
            @cpl_lines = @{ $props{$id}{cpl_lines} };
            @cpl_files = @{ $props{$id}{cpl_files} };
            for ($n=0; $n<=$#wbs; $n++) {
                $jw = $wbs[$n];
                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $cpl_lines[$n],
                                                             "Reading W2 contour file...");
                %sdata = &read_w2_cpl_file($main, $id, $jw, $cpl_files[$n], $tecplot[$n], 0,
                                           "Temperature", "None", $props{$id}{byear},
                                           $props{$id}{tz_offset}, $props{$id}{jd_skip}, $pbar);
                $nd      = 0;
                @mydates = sort keys %sdata;
                $pbar_window->g_wm_title("Processing data...");
                $status_line = "";
                Tkx::update_idletasks();
                &reset_progress_bar($pbar, $#mydates +1, "Processing data... Date = 1");

#               Consolidate data from different waterbodies
                if ($#wbs == 0 || $n == 0) {
                    $dsum    = &sum(@mydates);
                    %wl_data = ();
                    foreach $dt (@mydates) {
                        &update_progress_bar($pbar, ++$nd, $dt);
                        @cus  = @{ $sdata{$dt}{cus}  };
                        @elws = @{ $sdata{$dt}{elws} };
                        for ($jb=$bs[$jw]; $jb<=$be[$jw]; $jb++) {
                            for ($i=$us[$jb]; $i<=$ds[$jb]; $i++) {
                                if (! defined($cus[$jb]) || ! defined($elws[$i]) || $i < $cus[$jb]) {
                                    $wl_data{$dt}[$i] = -999;
                                } else {
                                    $wl_data{$dt}[$i] = $elws[$i];
                                }
                            }
                        }
                    }
                } else {
                    if ($dsum != &sum(@mydates)) {
                        &pop_up_info($main, "Contour file dates for waterbody " . $wbs[$n] . "\n"
                                          . "do not match those for waterbody " . $wbs[0] . "\n"
                                          . "This could lead to visualization problems.");
                    }
                    foreach $dt (@mydates) {
                        &update_progress_bar($pbar, ++$nd, $dt);
                        @cus  = @{ $sdata{$dt}{cus}  };
                        @elws = @{ $sdata{$dt}{elws} };
                        for ($jb=$bs[$jw]; $jb<=$be[$jw]; $jb++) {
                            for ($i=$us[$jb]; $i<=$ds[$jb]; $i++) {
                                if (! defined($cus[$jb]) || ! defined($elws[$i]) || $i < $cus[$jb]) {
                                    $wl_data{$dt}[$i] = -999;
                                } else {
                                    $wl_data{$dt}[$i] = $elws[$i];
                                }
                            }
                        }
                    }
                }
                &destroy_progress_bar($main, $pbar_window);
                $status_line = "Cleaning up...                           ";
                Tkx::update_idletasks();
                undef %sdata;
                undef @cus;
                undef @elws;
            }

#       Read the vector file, if needed.
#       Water level is part of the normal return data; ask for Temperature then toss it.
        } elsif ($src_type =~ /Vector/i) {
            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, -s $props{$id}{w2l_file},
                                                         "Reading W2 vector file...");
            $status_line = "Reading W2 vector file... Date = 1";
            %sdata = &read_w2_vector_file($main, $id, $props{$id}{w2l_file}, 0,
                                          "Temperature", "None", $props{$id}{byear},
                                          $props{$id}{tz_offset}, $props{$id}{jd_skip}, $pbar);
            @mydates = sort keys %sdata;
            $pbar_window->g_wm_title("Processing data...");
            $status_line = "";
            Tkx::update_idletasks();
            &reset_progress_bar($pbar, $#mydates +1, "Processing data... Date = 1");

            $nd      = 0;
            %wl_data = ();
            foreach $dt (@mydates) {
                &update_progress_bar($pbar, ++$nd, $dt);
                @cus  = @{ $sdata{$dt}{cus}  };
                @elws = @{ $sdata{$dt}{elws} };
                for ($jb=1; $jb<=$nbr; $jb++) {
                    for ($i=$us[$jb]; $i<=$ds[$jb]; $i++) {
                        if (! defined($cus[$jb]) || ! defined($elws[$i]) || $i < $cus[$jb]) {
                            $wl_data{$dt}[$i] = -999;
                        } else {
                            $wl_data{$dt}[$i] = $elws[$i];
                        }
                    }
                }
            }
            &destroy_progress_bar($main, $pbar_window);
            $status_line = "Cleaning up...                           ";
            Tkx::update_idletasks();
            undef %sdata;
            undef @cus;
            undef @elws;

#       Read the water levels file
#       See the read_w2_wlevel subroutine in w2anim_w2subs.pl for how inactive segments are detected
        } else {
            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $props{$id}{wl_lines},
                                                         "Reading W2 water levels file...");
            %wl_data = &read_w2_wlevel($main, $id, $props{$id}{wl_file}, $props{$id}{byear},
                                       $props{$id}{tz_offset}, "all", $props{$id}{jd_skip},
                                       $props{$id}{extra_chk}, $pbar);
            &destroy_progress_bar($main, $pbar_window);
        }
        $profile{wl_data} = { %wl_data };

#       Find minimum and maximum dates and water levels
        %limits = &find_w2_wlevel_limits($id, %wl_data);
        $profile{date_min} = $limits{date_min};
        $profile{date_max} = $limits{date_max};
        $profile{elev_min} = $limits{elev_min};    # in meters, or n/a
        $profile{elev_max} = $limits{elev_max};    # in meters, or n/a
        undef %limits;

        if ($new_graph) {
            $profile{yfont}     = $default_family;
            $profile{yl_size}   = &min(11, &max(8, int((abs($x2-$x1)+abs($y2-$y1))/2./41)));
            $profile{yt_size}   = $profile{yl_size} +2;
            $profile{yl_weight} = 'normal';
            $profile{yt_weight} = 'normal';
            $profile{yunits}    = $parms{yunits};
            $profile{ymin}      = ($parms{ymin} ne "") ? $parms{ymin} : 0;
            $profile{ymax}      = $parms{ymax};
            $profile{ymajor}    = ($parms{ymajor} eq "") ? "auto" : $parms{ymajor};
            $profile{ypr_tics}  = "outside";
            $profile{yop_tics}  = "none";
            $profile{ytitle}    = "Water Level, in " . $parms{yunits};

            $profile{xfont}     = $profile{yfont};
            $profile{xl_size}   = $profile{yl_size};
            $profile{xt_size}   = $profile{yt_size};
            $profile{xl_weight} = $profile{yl_weight};
            $profile{xt_weight} = $profile{yt_weight};
            $profile{xunits}    = $parms{xunits};
            $profile{xflip}     = $parms{xflip};
            $profile{xbase}     = 0;
            $profile{xmin}      = 0;
            $profile{xfirst}    = 0;
            $profile{xmax}      = 0;
            $profile{x_km}      = 0;
            $profile{xmajor}    = "auto";
            $profile{xpr_tics}  = "outside";
            $profile{xop_tics}  = "none";
            $profile{xmax_auto} = 1;
            if ($parms{xunits} eq "kilometers") {
                $profile{xtitle} = "River Kilometer";
            } else {
                $profile{xtitle} = "River Mile";
            }

            $profile{stype}     = "none";
            $profile{sfont}     = $default_family;
            $profile{st_size}   = $profile{xt_size};
            $profile{sl_size}   = $profile{xl_size};
            $profile{st_weight} = $profile{xt_weight};
            $profile{sl_weight} = $profile{xl_weight};
            $profile{smajor}    = "auto";
            $profile{spr_tics}  = "outside";
            $profile{sop_tics}  = "none";
            $profile{stic_loc}  = "upstream edge";
            $profile{sgrid}     = 0;
            $profile{sgrid_col} = '#C0C0C0';
            $profile{bgrid}     = 0;
            $profile{bgrid_col} = '#FF8040';
            $profile{stitle}    = "Segment Number";

            $profile{gtfont}    = $profile{yfont};
            $profile{gt_size}   = $profile{yt_size};
            $profile{gt_weight} = 'bold';
            $profile{gs_size}   = $profile{gt_size} -1;
            $profile{gs_weight} = $profile{gt_weight};
            $profile{gtitle}    = $parms{gtitle};

            $profile{wl_color}  = $parms{wl_color};
            $profile{wl_style}  = $parms{wl_style};
            $profile{wl_grid}   = $parms{wl_grid};
            $profile{wl_gridc}  = $parms{wl_gridc};
        }
        $profile{redraw}  = 1;
        $gr_props{$id}    = { %profile };
        $props{$id}{data} = 1;
        $props{$id}{gnum} = ++$graph_num if (! defined($props{$id}{oldcoords}));
        $resized          = 0;
        $refresh_menus    = 0;
        undef %profile;

#       Rebuild the dates array if different jd_skip or byear.
#       The rebuild option is determined in setup_w2_wlevels_part3.
        if (! $new_graph) {
            &rebuild_datelist if ($parms{rebuild});
            $refresh_menus = 1;
            $canv->delete($gtag . "_xaxis");
            $canv->delete($gtag . "_xaxisTitle");
            $canv->delete($gtag . "_yaxis");
            $canv->delete($gtag . "_yaxisTitle");
            $canv->delete($gtag . "_saxis");
            $canv->delete($gtag . "_saxisTitle");
            $canv->delete($gtag . "_sgrid");
            $canv->delete($gtag . "_date");
            $canv->delete($gtag . "_gtitle");
            $canv->delete($gtag . "_wlgrid");
            $canv->delete($gtag . "_wlevels");
        }
        undef %parms;

#   Or use previously read info.  If resized, delete graph and redraw
    } else {
        @old_coords    = @{ $props{$id}{oldcoords} };
        $refresh_menus = 0;
        $resized       = 0;
        for ($i=0; $i<=$#coords; $i++) {
            if ($coords[$i] != $old_coords[$i]) {
                $resized = 1;
                last;
            }
        }
        return if (! $resized && ! $props_updated);
        $gr_props{$id}{redraw} = 1 if ($resized);

        %wl_data = %{ $gr_props{$id}{wl_data} };

        $canv->delete($gtag . "_xaxis");
        $canv->delete($gtag . "_xaxisTitle");
        $canv->delete($gtag . "_yaxis");
        $canv->delete($gtag . "_yaxisTitle");
        $canv->delete($gtag . "_saxis");
        $canv->delete($gtag . "_saxisTitle");
        $canv->delete($gtag . "_sgrid");
        $canv->delete($gtag . "_date");
        $canv->delete($gtag . "_gtitle");
        if ($gr_props{$id}{redraw}) {
            $canv->delete($gtag . "_wlgrid");
            $canv->delete($gtag . "_wlevels");
        }
    }
    $props{$id}{oldcoords} = [ @coords ];

#   Set the list of dates or merge the dates array if necessary
#   Add the graph to the list of animated graphs, if necessary
#   For first creation, ensure mouse cursor is on canvas so it can be changed
    @mydates = sort keys %wl_data;
    if (! @animate_ids || &list_match($id, @animate_ids) == -1) {
        if (@dates && @animate_ids && $#animate_ids >= 0) {
            $mismatch = 0;
            foreach $id2 (@animate_ids) {
                next if ($props{$id2}{meta} =~ /data_profile_cmap|w2_profile_cmap|w2_tdmap|time_series/);
                if ($props{$id2}{meta} =~ /data_profile|vert_wd_zone|w2_outflow/) {
                    $mismatch = 1;
                    last;
                } elsif ($props{$id2}{meta} eq "w2_profile") {
                    if ($props{$id2}{src_type}      ne $props{$id}{src_type}
                         || $props{$id2}{byear}     != $props{$id}{byear}
                         || $props{$id2}{tz_offset} ne $props{$id}{tz_offset}
                         || $props{$id2}{jd_skip}   != $props{$id}{jd_skip}) {
                        $mismatch = 1;
                        last;
                    } elsif ($props{$id2}{src_type} =~ /Contour/i) {
                        @cpl_files = @{ $props{$id}{cpl_files} };
                        $mismatch  = 1;
                        for ($n=0; $n<=$#wbs; $n++) {
                            if ($cpl_files[$n] eq $props{$id2}{src_file}) {
                                $mismatch = 0;
                                last;
                            }
                        }
                        last if ($mismatch);
                    } elsif ($props{$id2}{src_type} =~ /Vector/i) {
                        if ($props{$id2}{src_file} ne $props{$id}{w2l_file}) {
                            $mismatch = 1;
                            last;
                        }
                    }
                } elsif ($props{$id2}{meta} =~ /w2_slice|w2_wlevels/) {
                    if ($props{$id2}{con_file}      ne $props{$id}{con_file}
                         || $props{$id2}{src_type}  ne $props{$id}{src_type}
                         || $props{$id2}{byear}     != $props{$id}{byear}
                         || $props{$id2}{tz_offset} ne $props{$id}{tz_offset}
                         || $props{$id2}{jd_skip}   != $props{$id}{jd_skip}) {
                        $mismatch = 1;
                        last;
                    }
                }
            }
            if ($mismatch) {
                if (defined($animate_tb) && Tkx::winfo_exists($animate_tb)) {
                    if ($animate_tb->g_wm_title() eq "Animation toolbar") {
                        $animate_tb->g_destroy();
                        undef $animate_tb;
                    }
                }
                $dt    = $dates[$dti-1];
                @dates = &merge_dates(\@dates, \@mydates);
                $dti   = 1 + &nearest_dt_index($dt, @dates);
                $dti++ if ($dti == 0);
            }
        } else {
            @dates = @mydates;
            $dti   = 1;
            $delay = 0.5;
        }
        if ($global_dt_limits) {     # Truncate date range if global limits
            $dt    = $dates[$dti-1];
            @dates = &truncate_dates($global_dt_begin, $global_dt_end, @dates);
            $dti   = 1 + &nearest_dt_index($dt, @dates);
            $dti++ if ($dti == 0);
        }
        $dti_max = $#dates+1;
        $dti_old = $dti;
        push (@animate_ids, $id);
    }
    $dt = $dates[$dti-1];              # Define current date/time
    if (! defined($wl_data{$dt})) {  # Adjust by up to 10 minutes, if needed
        for ($mi=1; $mi<=10; $mi++) {
            $dt2 = &adjust_dt($dt, $mi);
            if (defined($wl_data{$dt2})) {
                $dt = $dt2;
                last;
            }
            $dt2 = &adjust_dt($dt, -1 *$mi);
            if (defined($wl_data{$dt2})) {
                $dt = $dt2;
                last;
            }
        }
    }
    $export_menu->entryconfigure(3, -state => 'normal') if ($use_GS);
    $pref_menu->entryconfigure(0,   -state => 'normal');

#   Plot a white rectangle below the graph frame
    @items     = Tkx::SplitList($canv->find_withtag($gtag . "_main"));
    $new_graph = ($#items >= 0) ? 0 : 1;
    if ($new_graph) {
        $box_id = $canv->create_rectangle($x1, $y1, $x2, $y2,
                             -outline => "",
                             -width   => 0,
                             -fill    => &get_rgb_code("white"),
                             -tags    => $gtag . " " . $gtag . "_main");
        $canv->lower($box_id, $id);
    } else {
        $canv->coords($gtag . "_main", @coords);
        $canv->raise($id, $gtag . "_main");
    }

#   Plot Y axis
    $axis_props{min}     = $gr_props{$id}{ymin};
    $axis_props{max}     = $gr_props{$id}{ymax};
    $axis_props{major}   = $gr_props{$id}{ymajor};
    $axis_props{pr_tics} = $gr_props{$id}{ypr_tics};
    $axis_props{op_tics} = $gr_props{$id}{yop_tics};
    $axis_props{minor}   = 1;
    $axis_props{reverse} = 0;
    $axis_props{title}   = $gr_props{$id}{ytitle};
    $axis_props{font}    = $gr_props{$id}{yfont};
    $axis_props{size1}   = $gr_props{$id}{yl_size};
    $axis_props{size2}   = $gr_props{$id}{yt_size};
    $axis_props{weight1} = $gr_props{$id}{yl_weight};
    $axis_props{weight2} = $gr_props{$id}{yt_weight};
    $axis_props{side}    = "left";
    $axis_props{tags}    = $gtag . " " . $gtag . "_yaxis";
    $axis_props{coords}  = [$x1, $y2, $x1, $y1];
    $axis_props{op_loc}  = $x2;
    &make_axis($canv, %axis_props);
    undef %axis_props;

#   Plot the date as a subtitle
    $xp = ($x1+$x2)/2.;
    if (($gr_props{$id}{stype} ne "none"    && $gr_props{$id}{sop_tics} =~ /outside|cross/) ||
        ($gr_props{$id}{stype} ne "replace" && $gr_props{$id}{xop_tics} =~ /outside|cross/)) {
        $yp = $y1-14;
    } else {
        $yp = $y1-6;
    }
    $date_label = &get_formatted_date($dt);
    $date_id = $canv->create_text($xp, $yp,
                       -anchor => 's',
                       -text   => $date_label,
                       -fill   => &get_rgb_code("black"),
                       -angle  => 0,
                       -tags   => $gtag . " " . $gtag . "_date",
                       -font   => [-family     => $gr_props{$id}{gtfont},
                                   -size       => $gr_props{$id}{gs_size},
                                   -weight     => $gr_props{$id}{gs_weight},
                                   -slant      => 'roman',
                                   -underline  => 0,
                                   -overstrike => 0,
                                  ]);
    @coords = Tkx::SplitList($canv->bbox($date_id));
    $dsize  = &max(10, abs($coords[3] - $coords[1]));

#   Plot the graph title
    $canv->create_text($xp, $yp-$dsize,
                       -anchor => 's',
                       -text   => $gr_props{$id}{gtitle},
                       -fill   => &get_rgb_code("black"),
                       -angle  => 0,
                       -tags   => $gtag . " " . $gtag . "_gtitle",
                       -font   => [-family     => $gr_props{$id}{gtfont},
                                   -size       => $gr_props{$id}{gt_size},
                                   -weight     => $gr_props{$id}{gt_weight},
                                   -slant      => 'roman',
                                   -underline  => 0,
                                   -overstrike => 0,
                                  ]);

#   Get segment list and downstream distance.
    $nbr   = $grid{$id}{nbr};
    @us    = @{ $grid{$id}{us}    };
    @ds    = @{ $grid{$id}{ds}    };
    @dlx   = @{ $grid{$id}{dlx}   };
    @slope = @{ $grid{$id}{slope} };

    if (defined($gr_props{$id}{xdist}) && defined($gr_props{$id}{seglist})) {
        @seglist = @{ $gr_props{$id}{seglist} };
        @xdist   = @{ $gr_props{$id}{xdist}   };  # saved in units of kilometers
    } else {
        @seg_limits = reverse split(/,|-/, $props{$id}{seg_list});  # reverse the order: ds to us
        @seglist    = ();
        $xdistance  = $last_seg = $last_jb = 0;
        for ($j=0; $j<=$#seg_limits; $j+=2) {
            $seg_dn = $seg_limits[$j];
            $seg_up = $seg_limits[$j+1];
            for ($jb=1; $jb<=$nbr; $jb++) {
                last if ($seg_dn >= $us[$jb] && $seg_dn <= $ds[$jb]);
            }
            if ($j > 1 && $last_seg != $us[$last_jb]) {
                $xdistance       -= $dlx[$last_seg] /2. *0.001;   # km
                $xdist[$last_seg] = $xdistance;
            }
            for ($i=$seg_dn; $i>=$seg_up; $i--) {
                $xdistance += $dlx[$i] *0.001;    # km
                $xdist[$i]  = $xdistance;
                push (@seglist, $i);
            }
            $last_seg = $seg_up;
            $last_jb  = $jb;
        }
        $gr_props{$id}{seglist} = [ @seglist ];
        $gr_props{$id}{xdist}   = [ @xdist   ];
    }
    $xmult = ($gr_props{$id}{xunits} eq "miles") ? 3280.84/5280. : 1.0;
    $xmin  = $gr_props{$id}{xmin};
    $xbase = $gr_props{$id}{xbase};
    if ($gr_props{$id}{xmax_auto}) {
        $xdistance = &round_to_int(1000.*$xdist[$seglist[$#seglist]] *$xmult)/1000.;
        $gr_props{$id}{xmax} = $xmax = $xbase +$xdistance;
    } else {
        $xmax = $gr_props{$id}{xmax};
    }
    $gr_props{$id}{x_km} = $xdist[$seglist[$#seglist]];

#   Update the Y axis exaggeration factor. Revert Y units to meters.
    $mult  = ($gr_props{$id}{yunits} eq "feet") ? 3.28084 : 1.0;
    $ymin  = $gr_props{$id}{ymin} /$mult;
    $ymax  = $gr_props{$id}{ymax} /$mult;
    $yexag = abs( (($xmax -$xmin) /$xmult  /($x2-$x1))
                 /(($ymax -$ymin) /1000.   /($y2-$y1)));
    $props{$id}{yexag_fac} = sprintf("%.4f", $yexag);

#   Plot X axis
    if ($gr_props{$id}{stype} ne "replace") {
        $axis_props{min}     = $xmin;
        $axis_props{max}     = $xmax;
        $axis_props{first}   = $gr_props{$id}{xfirst};
        $axis_props{major}   = $gr_props{$id}{xmajor};
        $axis_props{pr_tics} = $gr_props{$id}{xpr_tics};
        $axis_props{op_tics} = $gr_props{$id}{xop_tics};
        $axis_props{minor}   = 1;
        $axis_props{reverse} = 0;
        $axis_props{title}   = $gr_props{$id}{xtitle};
        $axis_props{font}    = $gr_props{$id}{xfont};
        $axis_props{size1}   = $gr_props{$id}{xl_size};
        $axis_props{size2}   = $gr_props{$id}{xt_size};
        $axis_props{weight1} = $gr_props{$id}{xl_weight};
        $axis_props{weight2} = $gr_props{$id}{xt_weight};
        $axis_props{side}    = "bottom";
        $axis_props{tags}    = $gtag . " " . $gtag . "_xaxis";
        $axis_props{coords}  = ($gr_props{$id}{xflip}) ? [$x2, $y2, $x1, $y2] : [$x1, $y2, $x2, $y2];
        $axis_props{op_loc}  = $y1;
        &make_axis($canv, %axis_props);
        undef %axis_props;
    }
    if ($gr_props{$id}{stype} ne "none") {
        $axis_props{base}     = $xbase /$xmult;           # convert to km
        $axis_props{min}      = $xmin  /$xmult;           # convert to km
        $axis_props{max}      = $xmax  /$xmult;           # convert to km
        $axis_props{dist}     = $gr_props{$id}{xdist};    # distance array in km
        $axis_props{seglist}  = $gr_props{$id}{seglist};  # list of segments, from ds to us
        $axis_props{type}     = $gr_props{$id}{stype};
        $axis_props{major}    = $gr_props{$id}{smajor};
        $axis_props{pr_tics}  = $gr_props{$id}{spr_tics};
        $axis_props{op_tics}  = $gr_props{$id}{sop_tics};
        $axis_props{title}    = $gr_props{$id}{stitle};
        $axis_props{font}     = $gr_props{$id}{sfont};
        $axis_props{size1}    = $gr_props{$id}{sl_size};
        $axis_props{size2}    = $gr_props{$id}{st_size};
        $axis_props{weight1}  = $gr_props{$id}{sl_weight};
        $axis_props{weight2}  = $gr_props{$id}{st_weight};
        $axis_props{tic_loc}  = $gr_props{$id}{stic_loc};
        $axis_props{grid}     = $gr_props{$id}{sgrid};
        $axis_props{gridcol}  = $gr_props{$id}{sgrid_col};
        $axis_props{bgrid}    = $gr_props{$id}{bgrid};
        $axis_props{bgridcol} = $gr_props{$id}{bgrid_col};
        $axis_props{grcoord}  = [$y1, $y2];
        $axis_props{side}     = "bottom";
        $axis_props{tags}     = $gtag . " " . $gtag . "_saxis";
        $axis_props{coords}   = ($gr_props{$id}{xflip}) ? [$x2, $y2, $x1, $y2] : [$x1, $y2, $x2, $y2];
        $axis_props{op_loc}   = $y1;
        &make_seg_axis($canv, %axis_props);
        undef %axis_props;
    }

#   Refresh the Graph Properties menu and Object Information box, if present
    if ($refresh_menus) {
        if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
            if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
                $tabid = $grprops_notebook->index('current');
                $geom  = $graph_props_menu->g_wm_geometry();
                (undef, $X, $Y) = split(/\+/, $geom);
                &edit_graph_props($id, $X, $Y, $tabid);
            }
        }
        if (defined($object_infobox) && Tkx::winfo_exists($object_infobox)) {
            if ($object_infobox->g_wm_title() eq "Object Info") {
                $geom = $object_infobox->g_wm_geometry();
                (undef, $X, $Y) = split(/\+/, $geom);
                &show_info($canv, $id, $X, $Y);
            }
        }
    }

#   Don't recompute and redraw unless necessary
    if (! $gr_props{$id}{redraw}) {
        $canv->lower($gtag . "_date",       $id);
        $canv->lower($gtag . "_gtitle",     $id);
        $canv->lower($gtag . "_wlgrid",     $id);
        $canv->lower($gtag . "_sgrid",      $id);
        $canv->lower($gtag . "_xaxisTitle", $id);
        $canv->lower($gtag . "_saxisTitle", $id);
        $canv->lower($gtag . "_yaxisTitle", $id);
        $canv->lower($gtag . "_wlevels",    $id);
        $canv->lower($gtag . "_xaxis",      $id);
        $canv->lower($gtag . "_saxis",      $id);
        $canv->lower($gtag . "_yaxis",      $id);
        if ($group_tags) {
            foreach $tag (@grp_tags) {
                $canv->addtag($tag, withtag => $gtag);
            }
        }
        return;
    }

#   Set some length variables
    $xmin  /= $xmult;        # revert to km
    $xmax  /= $xmult;        # revert to km
    $xbase /= $xmult;        # revert to km
    $xrange = $xmax -$xmin;  # km
    $yrange = $ymax -$ymin;  # meters

#   Plot the grid layers, if requested
    if ($gr_props{$id}{wl_grid}) {
        @seg_limits = reverse split(/,|-/, $props{$id}{seg_list});
        $kmx        = $grid{$id}{kmx};
        @el         = @{ $grid{$id}{el} };
        for ($j=0; $j<=$#seg_limits; $j+=2) {
            $seg_dn = $seg_limits[$j];
            $seg_up = $seg_limits[$j+1];
            for ($jb=1; $jb<=$nbr; $jb++) {
                last if ($seg_dn >= $us[$jb] && $seg_dn <= $ds[$jb]);
            }
            $xd1 = ($j == 0) ? 0 : $xdist[$seg_limits[$j-1]];
            $xd2 = $xdist[$seg_up];
            $xp1 = $x1 +($x2-$x1)*($xd1 +$xbase -$xmin)/$xrange;
            $xp2 = $x1 +($x2-$x1)*($xd2 +$xbase -$xmin)/$xrange;
            next if ($xp2 <= $x1);
            last if ($xp1 >= $x2);

            if ($slope[$jb] == 0) {
                $xp1 = &max($x1, &min($x2, $xp1));
                $xp2 = &max($x1, &min($x2, $xp2));
                $xp1 = $x2 -($xp1 -$x1) if ($gr_props{$id}{xflip});
                $xp2 = $x2 -($xp2 -$x1) if ($gr_props{$id}{xflip});
                for ($k=2; $k<=$kmx; $k++) {
                    $yp0 = $y2 -($y2-$y1)*($el[$k][$seg_dn]-$ymin)/$yrange;
                    next if ($yp0 <= $y1 || $yp0 >= $y2);
                    $canv->create_line($xp1, $yp0, $xp2, $yp0,
                                       -fill  => &get_rgb_code($gr_props{$id}{wl_gridc}),
                                       -width => 1,
                                       -arrow => 'none',
                                       -tags  => $gtag . " " . $gtag . "_wlgrid");
                }
            } else {
                for ($k=2; $k<=$kmx; $k++) {
                    $yp0 = $y2 -($y2-$y1)*($el[$k][$seg_dn]-0.5*$dlx[$seg_dn]*$slope[$jb]-$ymin)/$yrange;
                    if ($j+1 != $#seg_limits && $seg_up != $us[$jb]) {
                        $yp3 = $y2 -($y2-$y1)*($el[$k][$seg_up]-$ymin)/$yrange;
                    } else {
                        $yp3 = $y2 -($y2-$y1)*($el[$k][$seg_up]+0.5*$dlx[$seg_up]*$slope[$jb]-$ymin)/$yrange;
                    }
                    next if (($yp0 <= $y1 && $yp3 <= $y1) || ($yp0 >= $y2 && $yp3 >= $y2));

                    $xp0 = $xp1;
                    $xp3 = $xp2;
                    if ($xp0 < $x1) {
                        $yp0 = ($yp3-$yp0)*($x1-$xp0)/($xp3-$xp0)+$yp0;
                        $xp0 = $x1;
                    }
                    if ($xp3 > $x2) {
                        $yp3 = ($yp3-$yp0)*($x2-$xp0)/($xp3-$xp0)+$yp0;
                        $xp3 = $x2;
                    }
                    next if (($yp0 <= $y1 && $yp3 <= $y1) || ($yp0 >= $y2 && $yp3 >= $y2));

                    if ($yp0 < $y1) {
                        $xp0 = ($xp3-$xp0)*($y1-$yp0)/($yp3-$yp0)+$xp0;
                        $yp0 = $y1;
                    } elsif ($yp0 > $y2) {
                        $xp0 = ($xp3-$xp0)*($y2-$yp0)/($yp3-$yp0)+$xp0;
                        $yp0 = $y2;
                    }
                    if ($yp3 < $y1) {
                        $xp3 = ($xp3-$xp0)*($y1-$yp0)/($yp3-$yp0)+$xp0;
                        $yp3 = $y1;
                    } elsif ($yp3 > $y2) {
                        $xp3 = ($xp3-$xp0)*($y2-$yp0)/($yp3-$yp0)+$xp0;
                        $yp3 = $y2;
                    }
                    $xp0 = $x2 -($xp0 -$x1) if ($gr_props{$id}{xflip});
                    $xp3 = $x2 -($xp3 -$x1) if ($gr_props{$id}{xflip});
                    $canv->create_line($xp0, $yp0, $xp3, $yp3,
                                       -fill  => &get_rgb_code($gr_props{$id}{wl_gridc}),
                                       -width => 1,
                                       -arrow => 'none',
                                       -tags  => $gtag . " " . $gtag . "_wlgrid");
                }
            }
        }
    }

#   Plot the water levels, if data are available for this date/time
    $np = 0;
    $data_available = (defined($wl_data{$dt})) ? 1 : 0;

    if ($data_available) {
        @coords = ();

#       Loop over the segment list
        for ($ns=0; $ns<=$#seglist; $ns++) {
            $i    = $seglist[$ns];
            $wsel = $wl_data{$dt}[$i];
            if ($wsel == -999) {
                if ($#coords > 2) {
                    if ($gr_props{$id}{xflip}) {   # Flip the x values, if necessary
                        for ($n=0; $n<$#coords; $n+=2) {
                            $coords[$n] = $x2 -($coords[$n] -$x1);
                        }
                    }
                    $canv->create_line(@coords,
                                       -fill  => &get_rgb_code($gr_props{$id}{wl_color}),
                                       -width => 1,
                                       -arrow => 'none',
                                       -tags  => $gtag . " " . $gtag . "_wlevels");
                }
                @coords = ();
                next;
            }
            $xd1 = ($ns == 0) ? 0 : $xdist[$seglist[$ns-1]];
            $xd2 = $xdist[$i];
            $xp1 = $x1 +($x2-$x1)*($xd1 +$xbase -$xmin)/$xrange;
            $xp2 = $x1 +($x2-$x1)*($xd2 +$xbase -$xmin)/$xrange;
            next if ($xp2 < $x1);
            last if ($xp1 > $x2);

            $add_pt0 = $add_pt3 = 0;
            for ($jb=1; $jb<=$nbr; $jb++) {
                last if ($i >= $us[$jb] && $i <= $ds[$jb]);
            }
            if ($gr_props{$id}{wl_style} =~ /Interpolate/i) {
#               When a branch joins mid-segment, need to account for that.
#               Array seglist is ds to us, so normal progression is to decreasing segment numbers.
                if ($ns < $#seglist && $i != $us[$jb] && $seglist[$ns+1] != $i-1) {
                    $xp3 = $xp2;
                } else {
                    $xp3 = 0.5*($xp1+$xp2);
                }
                $yp3 = $y2 -($y2-$y1)*($wsel-$ymin)/$yrange;

                if ($xp3 < $x1) {
                    $last_xp = $xp3;
                    $last_yp = $yp3;
                    next;
                }
                if ($#coords == -1) {
                    last if ($xp1 == $x2);
                    $yp3 = $y1 if ($yp3 < $y1);
                    $yp3 = $y2 if ($yp3 > $y2);
                    $last_xp = &max($x1, $xp1);
                    $last_yp = $yp3;
                    push (@coords, $last_xp, $last_yp);
                }
                if ($yp3 < $y1 && $last_yp <= $y1) {
                    $yp3 = $y1;
                } elsif ($yp3 > $y2 && $last_yp >= $y2) {
                    $yp3 = $y2;
                }
                if ($xp3 > $x2) {
                    $yp3 = ($yp3-$last_yp)*($x2-$last_xp)/($xp3-$last_xp)+$last_yp;
                    $xp3 = $x2;
                }
                if ($yp3 < $y1) {
                    $xp0 = ($xp3-$last_xp)*($y1-$last_yp)/($yp3-$last_yp)+$last_xp;
                    $yp0 = $yp3 = $y1;
                    $add_pt0 = 1;
                } elsif ($yp3 > $y2) {
                    $xp0 = ($xp3-$last_xp)*($y2-$last_yp)/($yp3-$last_yp)+$last_xp;
                    $yp0 = $yp3 = $y2;
                    $add_pt0 = 1;
                }
                push (@coords, $xp0, $yp0) if ($add_pt0);
                push (@coords, $xp3, $yp3);
                if ($ns == $#seglist && $xp3 != $x2 && $xp2 > $xp3) {
                    push (@coords, &min($x2, $xp2), $yp3);
                }
                $np++;
                $last_xp = $xp3;
                $last_yp = $yp3;
                last if ($xp3 >= $x2);

            } else {
                if ($slope[$jb] == 0 || $gr_props{$id}{wl_style} =~ /Flat surface/i) {
                    $yp1 = $y2 -($y2-$y1)*($wsel-$ymin)/$yrange;
                    $xp1 = &max($x1, &min($x2, $xp1));
                    $xp2 = &max($x1, &min($x2, $xp2));
                    $yp1 = $yp2 = &max($y1, &min($y2, $yp1));
                } else {
#                   When a branch joins mid-segment, need to account for that.
#                   Array seglist is ds to us, so normal progression is to decreasing segment numbers.
                    if ($ns < $#seglist && $i != $us[$jb] && $seglist[$ns+1] != $i-1) {
                        $yp1 = $y2 -($y2-$y1)*($wsel-($xd2-$xd1)*1000.*$slope[$jb]-$ymin)/$yrange;
                        $yp2 = $y2 -($y2-$y1)*($wsel-$ymin)/$yrange;
                    } else {
                        $yp1 = $y2 -($y2-$y1)*($wsel-0.5*($xd2-$xd1)*1000.*$slope[$jb]-$ymin)/$yrange;
                        $yp2 = $y2 -($y2-$y1)*($wsel+0.5*($xd2-$xd1)*1000.*$slope[$jb]-$ymin)/$yrange;
                    }
                    if ($xp1 < $x1) {
                        $yp1 = ($yp2-$yp1)*($x1-$xp1)/($xp2-$xp1)+$yp1;
                        $xp1 = $x1;
                    }
                    if ($xp2 > $x2) {
                        $yp2 = ($yp2-$yp1)*($x2-$xp1)/($xp2-$xp1)+$yp1;
                        $xp2 = $x2;
                    }
                    if ($yp1 < $y1 && $yp2 < $y1) {
                        $yp1 = $yp2 = $y1;
                    } elsif ($yp1 > $y2 && $yp2 > $y2) {
                        $yp1 = $yp2 = $y2;
                    }
                    if ($yp1 < $y1) {
                        $xp0 = $xp1;
                        $yp0 = $y1;
                        $xp1 = ($xp2-$xp1)*($y1-$yp1)/($yp2-$yp1)+$xp1;
                        $yp1 = $y1;
                        $add_pt0 = 1;
                    } elsif ($yp1 > $y2) {
                        $xp0 = $xp1;
                        $yp0 = $y2;
                        $xp1 = ($xp2-$xp1)*($y2-$yp1)/($yp2-$yp1)+$xp1;
                        $yp1 = $y2;
                        $add_pt0 = 1;
                    }
                    if ($yp2 < $y1) {
                        $xp3 = $xp1;
                        $yp3 = $y1;
                        $xp2 = ($xp2-$xp1)*($y1-$yp1)/($yp2-$yp1)+$xp1;
                        $yp2 = $y1;
                        $add_pt3 = 1;
                    } elsif ($yp2 > $y2) {
                        $xp3 = $xp1;
                        $yp3 = $y2;
                        $xp2 = ($xp2-$xp1)*($y2-$yp1)/($yp2-$yp1)+$xp1;
                        $yp2 = $y2;
                        $add_pt3 = 1;
                    }
                }
                push (@coords, $xp0, $yp0) if ($add_pt0);
                push (@coords, $xp1, $yp1, $xp2, $yp2);
                push (@coords, $xp3, $yp3) if ($add_pt3);
                $np++;
            }
        }
        if ($#coords > 2) {
            if ($gr_props{$id}{xflip}) {   # Flip the x values, if necessary
                for ($n=0; $n<$#coords; $n+=2) {
                    $coords[$n] = $x2 -($coords[$n] -$x1);
                }
            }
            $canv->create_line(@coords, -fill  => &get_rgb_code($gr_props{$id}{wl_color}),
                                        -width => 1,
                                        -arrow => 'none',
                                        -tags  => $gtag . " " . $gtag . "_wlevels");
        }
    }
    undef %wl_data;

#   Plot a no-data message
    if (! $data_available || $np == 0) {
        $canv->create_text(($x1+$x2)/2., ($y1 +$y2)/2.,
                           -anchor => 'center',
                           -text   => "No Data",
                           -fill   => &get_rgb_code("gray60"),
                           -angle  => 0,
                           -tags   => $gtag . " " . $gtag . "_wlevels",
                           -font   => [-family     => $gr_props{$id}{xfont},
                                       -size       => $gr_props{$id}{xl_size},
                                       -weight     => 'normal',
                                       -slant      => 'roman',
                                       -underline  => 0,
                                       -overstrike => 0,
                                      ]);
    }

#   Place the graphic items in the proper order
    &raise_lower($canv, $id, "tiptop") if ($new_graph);
    $canv->lower($gtag . "_date",       $id);
    $canv->lower($gtag . "_gtitle",     $id);
    $canv->lower($gtag . "_wlgrid",     $id);
    $canv->lower($gtag . "_sgrid",      $id);
    $canv->lower($gtag . "_xaxisTitle", $id);
    $canv->lower($gtag . "_saxisTitle", $id);
    $canv->lower($gtag . "_yaxisTitle", $id);
    $canv->lower($gtag . "_wlevels",    $id);
    $canv->lower($gtag . "_xaxis",      $id);
    $canv->lower($gtag . "_saxis",      $id);
    $canv->lower($gtag . "_yaxis",      $id);
    if ($group_tags) {
        foreach $tag (@grp_tags) {
            $canv->addtag($tag, withtag => $gtag);
        }
    }

#   Update any links
#xxx &update_links($canv, $id, $dt);
}


sub make_ts_graph {
    my ($canv, $id, $props_updated) = @_;
    my (
        $add_date_pts, $add_dateline, $base_jd, $box_id, $date, $dt,
        $flow, $group_tags, $gtag, $i, $id2, $jd, $jd_max, $jd_min,
        $link_id, $min_major, $n, $ne, $new_graph, $num_hidden, $power,
        $range, $resized, $tag, $ts_state, $ws_elev, $wt, $x1, $x2, $xp,
        $y1, $y2, $ymax, $ymin, $yp, $yr_max, $yr_min,

        @add_ts_byear, @add_ts_color, @add_ts_ctype, @add_ts_file,
        @add_ts_ftype, @add_ts_lines, @add_ts_param, @add_ts_seg,
        @add_ts_setnum, @add_ts_show, @add_ts_text, @add_ts_tzoff,
        @add_ts_width, @color, @coords, @grp_tags, @items, @legend_entry,
        @names, @old_coords, @points, @qstr, @show, @tags, @tstr, @width,

        %add_ts_parms, %axis_props, %legend_props, %parms, %profile,
        %qdata, %tdata, %wsurf,
       );

    %profile = ();

#   Make tag and get coordinates of graph frame
    $gtag   = "graph" . $id;
    @coords = @{ $props{$id}{coordlist} };
    ($x1, $y1, $x2, $y2) = @coords;

#   Determine whether group tags are present and save the list
    $group_tags = 0;
    @grp_tags   = ();
    @tags       = Tkx::SplitList($canv->itemcget($id, -tags));
    if (&list_search("group_", @tags) > -1) {
        $group_tags = 1;
        foreach $tag (@tags) {
            push (@grp_tags, $tag) if ($tag =~ /^group_/);
        }
    }

#   Unpack some parameters
    %parms = %{ $props{$id}{ts_parms} };
    if (defined($props{$id}{add_ts_parms})) {
        %add_ts_parms  = %{ $props{$id}{add_ts_parms} };
        @add_ts_setnum = @{ $add_ts_parms{ts_setnum}  };
        @add_ts_file   = @{ $add_ts_parms{ts_file}    };
        @add_ts_show   = @{ $add_ts_parms{ts_show}    };
        @add_ts_width  = @{ $add_ts_parms{ts_width}   };
        @add_ts_color  = @{ $add_ts_parms{ts_color}   };
        @add_ts_text   = @{ $add_ts_parms{ts_text}    };
        @add_ts_ftype  = @{ $add_ts_parms{ts_ftype}   };
        @add_ts_lines  = @{ $add_ts_parms{ts_lines}   };
        @add_ts_param  = @{ $add_ts_parms{ts_param}   };
        @add_ts_byear  = @{ $add_ts_parms{ts_byear}   };
        @add_ts_tzoff  = @{ $add_ts_parms{ts_tzoff}   };
        @add_ts_seg    = @{ $add_ts_parms{ts_seg}     };
        @add_ts_ctype  = @{ $add_ts_parms{ts_ctype}   };
    }

#   Make sure a linked time-series graph is tagged with its linked source
    if ($props{$id}{meta} eq "linked_time_series") {
        $link_id = $props{$id}{link_id};
        @show    = @{ $parms{show}  };
        @width   = @{ $parms{width} };
        @color   = @{ $parms{color} };
        $canv->addtag("tslink_gr" . $link_id, withtag => $id);
    }

#   First time here
    if (! defined($props{$id}{data}) || ! $props{$id}{data}) {
        if (defined($parms{ts_type}) && $parms{ts_type} ne "") {
            if ($parms{ts_type} eq "Temperature") {
                $profile{ytitle} = "Temperature, in degrees " . $parms{units};
            } else {
                $profile{ytitle} = $parms{ts_type} . ", in " . $parms{units};
            }
            $profile{gtitle} = $parms{ts_type} . " Time Series";
        } else {
            $profile{ytitle} = "";
            $profile{gtitle} = "";
        }
        $profile{ymin}      = $parms{ymin};
        $profile{ymax}      = $parms{ymax};
        $profile{xmin}      = $parms{xmin};
        $profile{xmax}      = $parms{xmax};
        $profile{base_yr}   = $parms{base_yr} if (defined($parms{base_yr}));
        $profile{xtype}     = (defined($parms{xtype})) ? $parms{xtype} : "Date/Time";
        if ($profile{xtype} eq "Julian Date") {
            $profile{xtitle} = "Julian Date";
            $profile{xmajor} = "auto";
        }
        $profile{gap_tol}   = 2.0;

        $profile{yfont}     = $default_family;
        $profile{yl_size}   = &min(11, &max(8, int((abs($x2-$x1)+abs($y2-$y1))/2./41)));
        $profile{yt_size}   = $profile{yl_size} +2;
        $profile{yl_weight} = 'normal';
        $profile{yt_weight} = 'normal';
        $profile{ymajor}    = "auto";
        $profile{ypr_tics}  = "outside";
        $profile{yop_tics}  = "none";

        $profile{xfont}     = $profile{yfont};
        $profile{xl_size}   = $profile{yl_size};
        $profile{xt_size}   = $profile{yt_size};
        $profile{xl_weight} = $profile{yl_weight};
        $profile{xt_weight} = $profile{yt_weight};
        $profile{xmajor}    = "auto";
        $profile{xpr_tics}  = "outside";
        $profile{xop_tics}  = "none";
        if (&datelabel2jdate($profile{xmax}) - &datelabel2jdate($profile{xmin}) > 365 *4) {
            $profile{datefmt} = "Year";
        } else {
            $profile{datefmt} = "Month";
        }
        $profile{dateline}  = 0;
        $profile{datelinec} = "black";

        $profile{gtfont}    = $profile{yfont};
        $profile{gt_size}   = $profile{yt_size};
        $profile{gt_weight} = 'bold';

        $profile{legfont}   = $default_family;
        $profile{le_size}   = $profile{yl_size};
        $profile{lt_size}   = $profile{yl_size} +2;
        $profile{le_weight} = 'normal';
        $profile{lt_weight} = 'bold';
        $profile{le_edge}   = 0;
        $profile{le_edgec}  = "black";
        $profile{le_fill}   = 0;
        $profile{le_fillc}  = "white";
        $profile{xleg_off}  = 18;
        $profile{yleg_off}  =  0;
        $profile{legtitle}  = "";

        $profile{gridx}     = 0;
        $profile{gridy}     = 0;
        $profile{gridwidth} = 1;
        $profile{gridcolor} = '#C0C0C0';

        $profile{redraw}    = 1;
        $gr_props{$id}      = { %profile };
        $props{$id}{data}   = 1;
        $props{$id}{gnum}   = ++$graph_num;
        $resized = 0;
        undef %profile;

#   Or use previously saved info.  If resized, delete graph and redraw
    } else {
        @old_coords = @{ $props{$id}{oldcoords} };
        $resized = 0;
        for ($i=0; $i<=$#coords; $i++) {
            if ($coords[$i] != $old_coords[$i]) {
                $resized = 1;
                last;
            }
        }
        return if (! $resized && ! $props_updated);
        $gr_props{$id}{redraw} = 1 if ($resized);

        $canv->delete($gtag . "_xaxis");
        $canv->delete($gtag . "_xaxisTitle");
        $canv->delete($gtag . "_yaxis");
        $canv->delete($gtag . "_yaxisTitle");
        $canv->delete($gtag . "_grid");
        $canv->delete($gtag . "_gtitle");
        $canv->delete($gtag . "_legend");
        $canv->delete($gtag . "_dateline");
        if ($gr_props{$id}{redraw}) {
            $canv->delete($gtag . "_tsData");
            $canv->delete($gtag . "_datePoint");
        }
    }
    $props{$id}{oldcoords} = [ @coords ];

#   Keep track of graphs that can be animated
#   Linked time-series graphs only get a bit of animation
#   Regular time-series graphs may get a vertical dateline
    if ($props{$id}{meta} =~ /^(linked_time_series|time_series)$/) {
        if (&list_match($id, @animate_ids) == -1) {
            push (@animate_ids, $id);
        }
    }

#   Plot a white rectangle below the graph frame
    @items     = Tkx::SplitList($canv->find_withtag($gtag . "_main"));
    $new_graph = ($#items >= 0) ? 0 : 1;
    if ($new_graph) {
        $box_id = $canv->create_rectangle($x1, $y1, $x2, $y2,
                             -outline => "",
                             -width   => 0,
                             -fill    => &get_rgb_code("white"),
                             -tags    => $gtag . " " . $gtag . "_main");
        $canv->lower($box_id, $id);
    } else {
        $canv->coords($gtag . "_main", @coords);
        $canv->raise($id, $gtag . "_main");
    }

#   Plot the graph title
    $xp = ($x1+$x2)/2.;
    $yp = ($gr_props{$id}{xop_tics} =~ /outside|cross/) ? $y1-18 : $y1-10;
    $canv->create_text($xp, $yp,
                       -anchor => 's', 
                       -text   => $gr_props{$id}{gtitle},
                       -fill   => &get_rgb_code("black"),
                       -angle  => 0,
                       -tags   => $gtag . " " . $gtag . "_gtitle",
                       -font   => [-family     => $gr_props{$id}{gtfont},
                                   -size       => $gr_props{$id}{gt_size},
                                   -weight     => $gr_props{$id}{gt_weight},
                                   -slant      => 'roman',
                                   -underline  => 0,
                                   -overstrike => 0,
                                  ]);

#   Determine an optimal Y major tick spacing, if needed
    if ($gr_props{$id}{ymajor} eq "auto") {
        $range     = $gr_props{$id}{ymax} -$gr_props{$id}{ymin};
        $power     = (&log10($range) < 1) ? abs(&floor(&log10($range))) +1 : 0;
        $range    *= 10**$power;
        $min_major = int($range *($gr_props{$id}{yl_size} *3) /abs($y2-$y1) +0.0000001);
        $min_major = 1 if ($min_major == 0);
        for ($i=$min_major; $i<=$range/5; $i++) {
            $gr_props{$id}{ymajor} = $i /(10**$power) if (&round_to_int($range) % $i == 0);
        }
        $gr_props{$id}{ymajor} = $min_major /(10**$power) if ($gr_props{$id}{ymajor} eq "auto");
    }

#   Plot Y axis
    $axis_props{min}     = $gr_props{$id}{ymin};
    $axis_props{max}     = $gr_props{$id}{ymax};
    $axis_props{major}   = $gr_props{$id}{ymajor};
    $axis_props{pr_tics} = $gr_props{$id}{ypr_tics};
    $axis_props{op_tics} = $gr_props{$id}{yop_tics};
    $axis_props{minor}   = 1;
    $axis_props{reverse} = 0;
    $axis_props{grid}    = $gr_props{$id}{gridy};
    $axis_props{grwidth} = $gr_props{$id}{gridwidth};
    $axis_props{grcolor} = $gr_props{$id}{gridcolor};
    $axis_props{grcoord} = [$x1, $x2];
    $axis_props{title}   = $gr_props{$id}{ytitle};
    $axis_props{font}    = $gr_props{$id}{yfont};
    $axis_props{size1}   = $gr_props{$id}{yl_size};
    $axis_props{size2}   = $gr_props{$id}{yt_size};
    $axis_props{weight1} = $gr_props{$id}{yl_weight};
    $axis_props{weight2} = $gr_props{$id}{yt_weight};
    $axis_props{side}    = "left";
    $axis_props{tags}    = $gtag . " " . $gtag . "_yaxis";
    $axis_props{coords}  = [$x1, $y2, $x1, $y1];
    $axis_props{op_loc}  = $x2;
    &make_axis($canv, %axis_props);
    undef %axis_props;

#   Plot X axis -- Date/Time or Julian Date
    $axis_props{major}   = $gr_props{$id}{xmajor};
    $axis_props{pr_tics} = $gr_props{$id}{xpr_tics};
    $axis_props{op_tics} = $gr_props{$id}{xop_tics};
    $axis_props{minor}   = 1;
    $axis_props{reverse} = 0;
    $axis_props{grid}    = $gr_props{$id}{gridx};
    $axis_props{grwidth} = $gr_props{$id}{gridwidth};
    $axis_props{grcolor} = $gr_props{$id}{gridcolor};
    $axis_props{grcoord} = [$y1, $y2];
    $axis_props{font}    = $gr_props{$id}{xfont};
    $axis_props{size1}   = $gr_props{$id}{xl_size};
    $axis_props{size2}   = $gr_props{$id}{xt_size};
    $axis_props{weight1} = $gr_props{$id}{xl_weight};
    $axis_props{weight2} = $gr_props{$id}{xt_weight};
    $axis_props{side}    = "bottom";
    $axis_props{tags}    = $gtag . " " . $gtag . "_xaxis";
    $axis_props{coords}  = [$x1, $y2, $x2, $y2];
    $axis_props{op_loc}  = $y1;
    if ($gr_props{$id}{xtype} eq "Date/Time") {
        $jd_min = &datelabel2jdate($gr_props{$id}{xmin});
        $jd_max = &datelabel2jdate($gr_props{$id}{xmax});
        $yr_min = substr($gr_props{$id}{xmin},7,4);
        $yr_max = substr($gr_props{$id}{xmax},7,4);
        $yr_max-- if (substr($gr_props{$id}{xmax},0,3) eq "Jan" &&
                      substr($gr_props{$id}{xmax},4,2) eq "01");
        if ($yr_min == $yr_max) {
            $gr_props{$id}{xtitle} = "Date in $yr_min";
        } else {
            $gr_props{$id}{xtitle} = "Date ($yr_min-$yr_max)";
        }
        $axis_props{min}     = $jd_min;
        $axis_props{max}     = $jd_max;
        $axis_props{title}   = $gr_props{$id}{xtitle};
        $axis_props{datefmt} = $gr_props{$id}{datefmt};
        &make_date_axis($canv, %axis_props);
    } else {
        $axis_props{min}   = $gr_props{$id}{xmin};
        $axis_props{max}   = $gr_props{$id}{xmax};
        $axis_props{title} = $gr_props{$id}{xtitle};

        if ($gr_props{$id}{xmajor} eq "auto") {
            $range     = $gr_props{$id}{xmax} -$gr_props{$id}{xmin};
            $power     = (&log10($range) < 1) ? abs(&floor(&log10($range))) +1 : 0;
            $range    *= 10**$power;
            $min_major = int($range *($gr_props{$id}{xl_size} *3) /abs($x2-$x1) +0.0000001);
            $min_major = 1 if ($min_major == 0);
            for ($i=$min_major; $i<=$range/5; $i++) {
                $gr_props{$id}{xmajor} = $i /(10**$power) if (&round_to_int($range) % $i == 0);
            }
            $gr_props{$id}{xmajor} = $min_major /(10**$power) if ($gr_props{$id}{xmajor} eq "auto");
        }
        &make_axis($canv, %axis_props);

        $base_jd = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
        $jd_min  = $gr_props{$id}{xmin} +$base_jd -1;
        $jd_max  = $gr_props{$id}{xmax} +$base_jd -1;
    }
    undef %axis_props;

#   Add a legend
    $legend_props{xpos}    = $x2 +$gr_props{$id}{xleg_off};
    $legend_props{ypos}    = $y1 +$gr_props{$id}{yleg_off};
    $legend_props{title}   = $gr_props{$id}{legtitle};
    $legend_props{font}    = $gr_props{$id}{legfont};
    $legend_props{esize}   = $gr_props{$id}{le_size};
    $legend_props{tsize}   = $gr_props{$id}{lt_size};
    $legend_props{eweight} = $gr_props{$id}{le_weight};
    $legend_props{tweight} = $gr_props{$id}{lt_weight};
    $legend_props{edge}    = $gr_props{$id}{le_edge};
    $legend_props{edgec}   = $gr_props{$id}{le_edgec};
    $legend_props{fill}    = $gr_props{$id}{le_fill};
    $legend_props{fillc}   = $gr_props{$id}{le_fillc};

    $ne = 0;
    @legend_entry = ();
    if ($props{$id}{meta} eq "linked_time_series") {
        if ($parms{ts_type} eq "Water Surface Elevation") {
            $legend_entry[0]{text}  = "WS Elev";
            $legend_entry[0]{width} = $width[0];
            $legend_entry[0]{color} = $color[0];
            $ne = 1;
        } else {
            @names = @{ $gr_props{$link_id}{names} };
            push (@names, "All Outlets");
            for ($n=0; $n<=$#names; $n++) {
                if ($show[$n]) {
                    $legend_entry[$ne]{text}  = $names[$n];
                    $legend_entry[$ne]{width} = $width[$n];
                    $legend_entry[$ne]{color} = $color[$n];
                    $ne++;
                }
            }
        }
    }
    $legend_props{num}     = $ne;
    $legend_props{entries} = [ @legend_entry ];
    $legend_props{tags}    = $gtag . " " . $gtag . "_legend";
    &make_ts_legend($canv, %legend_props);
    undef %legend_props;

#   Plot the optional dateline
    if ($gr_props{$id}{dateline}) {
        $add_dateline = 0;
        for ($i=0; $i<=$#animate_ids; $i++) {
            $id2 = $animate_ids[$i];
            next if ($id2 == $id);
            next if ($props{$id2}{meta}
                       !~ /^(data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)$/);
            if ($dti != 1) {
                $add_dateline = 1;
                last;
            }
        }
        if ($add_dateline) {
            $jd = &date2jdate($dates[$dti-1]);
            if ($jd >= $jd_min && $jd <= $jd_max) {
                $xp = $x1 +($x2 -$x1) *($jd -$jd_min)/($jd_max -$jd_min);
                $canv->create_line($xp, $y1, $xp, $y2,
                                   -fill  => &get_rgb_code($gr_props{$id}{datelinec}),
                                   -width => 1,
                                   -arrow => 'none',
                                   -tags  => $gtag . " " . $gtag . "_dateline");
            }
        }
    }

#   Don't recompute and redraw unless necessary
    if (! $gr_props{$id}{redraw}) {

#       Update widths and colors, if needed
        if ($props{$id}{meta} eq "linked_time_series") {
            if ($parms{ts_type} eq "Water Surface Elevation") {
                @items = Tkx::SplitList($canv->find_withtag($gtag . "_dataset0"));
                if ($#items >= 0) {
                    $canv->itemconfigure($gtag . "_dataset0",
                                         -width => $width[0],
                                         -fill  => &get_rgb_code($color[0]));
                }
                @items = Tkx::SplitList($canv->find_withtag($gtag . "_dataPoint0"));
                if ($#items >= 0) {
                    $canv->itemconfigure($gtag . "_dataPoint0",
                                         -fill  => &get_rgb_code($color[0]));
                }
            } else {
                for ($n=0; $n<=$#names; $n++) {
                    $ts_state = ($show[$n]) ? 'normal' : 'hidden';
                    @items = Tkx::SplitList($canv->find_withtag($gtag . "_dataset" . $n));
                    if ($#items >= 0) {
                        $canv->itemconfigure($gtag . "_dataset" . $n,
                                             -state => $ts_state,
                                             -width => $width[$n],
                                             -fill  => &get_rgb_code($color[$n]));
                    }
                    @items = Tkx::SplitList($canv->find_withtag($gtag . "_dataPoint" . $n));
                    if ($#items >= 0) {
                        $canv->itemconfigure($gtag . "_dataPoint" . $n,
                                             -state => $ts_state,
                                             -fill  => &get_rgb_code($color[$n]));
                    }
                }
            }
        }

#       Add legend entries and Update widths and colors of other datasets, if needed
        if (defined($props{$id}{add_ts_parms})) {
            $num_hidden = 0;
            for ($i=0; $i<=$#add_ts_setnum; $i++) {
                $n = $add_ts_setnum[$i];
                if ($add_ts_show[$i]) {
                    $xp  = $x2 +$gr_props{$id}{xleg_off};
                    $yp  = $y1 +$gr_props{$id}{yleg_off};
                    $yp += $gr_props{$id}{lt_size} *1.5 if ($gr_props{$id}{legtitle} ne "");
                    $yp += ($i -$num_hidden +$ne) *$gr_props{$id}{le_size} *1.5;
                    $canv->create_line($xp, $yp, $xp+20, $yp,
                                       -fill   => &get_rgb_code($add_ts_color[$i]),
                                       -width  => $add_ts_width[$i],
                                       -arrow  => 'none',
                                       -tags   => $gtag . " " . $gtag . "_legend");
                    $canv->create_text($xp+25, $yp,
                                       -anchor => 'w',
                                       -text   => $add_ts_text[$i],
                                       -fill   => &get_rgb_code("black"),
                                       -angle  => 0,
                                       -tags   => $gtag . " " . $gtag . "_legend",
                                       -font   => [-family     => $gr_props{$id}{legfont},
                                                   -size       => $gr_props{$id}{le_size},
                                                   -weight     => $gr_props{$id}{le_weight},
                                                   -slant      => 'roman',
                                                   -underline  => 0,
                                                   -overstrike => 0,
                                                  ]);
                    $canv->itemconfigure($gtag . "_dataLine" . $n,
                                         -state => 'normal',
                                         -width => $add_ts_width[$i],
                                         -fill  => &get_rgb_code($add_ts_color[$i]));
                    $canv->itemconfigure($gtag . "_dataPoint" . $n,
                                         -state   => 'normal',
                                         -outline => &get_rgb_code($add_ts_color[$i]),
                                         -fill    => "");
                } else {
                    $num_hidden++;
                    $canv->itemconfigure($gtag . "_dataset" . $n,
                                         -state => 'hidden');
                }
            }

#           Update the legend box, if needed
            &update_legend_box($canv, $id);
        }
        $canv->lower($gtag . "_gtitle",     $id);
        $canv->lower($gtag . "_grid",       $id);
        $canv->lower($gtag . "_xaxisTitle", $id);
        $canv->lower($gtag . "_yaxisTitle", $id);
        $canv->lower($gtag . "_dateline",   $id);
        $canv->lower($gtag . "_legend",     $id);
        $canv->lower($gtag . "_tsData",     $id);
        $canv->lower($gtag . "_datePoint",  $id);
        $canv->lower($gtag . "_xaxis",      $id);
        $canv->lower($gtag . "_yaxis",      $id);
        @items = Tkx::SplitList($canv->find_withtag($gtag . "_legend"));
        if ($#items >= 0) {
            $canv->lower($gtag . "_legendBox", $gtag . "_legend");
        }
        @items = Tkx::SplitList($canv->find_withtag($gtag . "_tsData"));
        if ($#items >= 0) {
            $canv->lower($id, $gtag . "_tsData");    # plot datasets above graph frame
        }
        if ($group_tags) {
            foreach $tag (@grp_tags) {
                $canv->addtag($tag, withtag => $gtag);
            }
        }
        return;
    }

#   Plot the data
    $ymin = $gr_props{$id}{ymin};
    $ymax = $gr_props{$id}{ymax};

    if ($props{$id}{meta} eq "linked_time_series") {
        if ($parms{ts_type} eq "Water Surface Elevation") {
            %wsurf  = %{ $gr_props{$link_id}{ws_elev} };
            @points = ();
            foreach $date (@dates) {
                $jd = &date2jdate($date);
                next if ($jd < $jd_min);
                last if ($jd > $jd_max);
                $xp = $x1 +($x2 -$x1) *($jd -$jd_min) /($jd_max -$jd_min);
                if (defined($wsurf{$date}) && $wsurf{$date} ne "na") {
                    $ws_elev  = $wsurf{$date};
                    $ws_elev *= 3.28084 if ($parms{units} eq "ft");
                    $yp = $y2 -($y2 -$y1) *($ws_elev -$ymin) /($ymax -$ymin);
                    $yp = &min($y2, &max($y1, $yp));
                    push (@points, $xp, $yp);
                } else {
                    if ($#points > 1) {
                        $canv->create_line(@points,
                                        -fill  => &get_rgb_code($color[0]),
                                        -width => $width[0],
                                        -arrow => 'none',
                                        -tags  => $gtag . " " . $gtag . "_tsData"
                                                        . " " . $gtag . "_dataset0");
                    }
                    @points = ();
                }
            }
            if ($#points > 1) {
                $canv->create_line(@points,
                                -fill  => &get_rgb_code($color[0]),
                                -width => $width[0],
                                -arrow => 'none',
                                -tags  => $gtag . " " . $gtag . "_tsData"
                                                . " " . $gtag . "_dataset0");
            }

        } elsif ($parms{ts_type} eq "Flow") {
            %qdata = %{ $gr_props{$link_id}{qdata} };
            for ($n=0; $n<=$#names; $n++) {
                $ts_state = ($show[$n]) ? 'normal' : 'hidden';
                @points = ();
                foreach $date (@dates) {
                    $jd = &date2jdate($date);
                    next if ($jd < $jd_min);
                    last if ($jd > $jd_max);
                    $xp = $x1 +($x2 -$x1) *($jd -$jd_min) /($jd_max -$jd_min);
                    if (defined($qdata{$date})) {
                        @qstr = @{ $qdata{$date} };
                        if ($names[$n] eq "All Outlets") {
                            $flow = &sum(@qstr);
                        } else {
                            $flow = $qstr[$n];
                        }
                        $flow *= 35.31467 if ($parms{units} eq "cfs");
                        $yp = $y2 -($y2 -$y1) *($flow -$ymin) /($ymax -$ymin);
                        $yp = &min($y2, &max($y1, $yp));
                        push (@points, $xp, $yp);
                    } else {
                        if ($#points > 1) {
                            $canv->create_line(@points,
                                            -fill  => &get_rgb_code($color[$n]),
                                            -width => $width[$n],
                                            -arrow => 'none',
                                            -state => $ts_state,
                                            -tags  => $gtag . " " . $gtag . "_tsData"
                                                            . " " . $gtag . "_dataset" . $n);
                        }
                        @points = ();
                    }
                }
                if ($#points > 1) {
                    $canv->create_line(@points,
                                    -fill  => &get_rgb_code($color[$n]),
                                    -width => $width[$n],
                                    -arrow => 'none',
                                    -state => $ts_state,
                                    -tags  => $gtag . " " . $gtag . "_tsData"
                                                    . " " . $gtag . "_dataset" . $n);
                }
            }

        } elsif ($parms{ts_type} eq "Temperature") {
            if (! defined($gr_props{$link_id}{tready})) {
                &generate_outflow_temps($link_id, $id);   # generate the temps, if needed
                $gr_props{$link_id}{tready} = 1;
            }
            %tdata = %{ $gr_props{$link_id}{tdata} };
            for ($n=0; $n<=$#names; $n++) {
                $ts_state = ($show[$n]) ? 'normal' : 'hidden';
                @points = ();
                foreach $date (@dates) {
                    $jd = &date2jdate($date);
                    next if ($jd < $jd_min);
                    last if ($jd > $jd_max);
                    $xp = $x1 +($x2 -$x1) *($jd -$jd_min) /($jd_max -$jd_min);
                    if (defined($tdata{$date})) {
                        @tstr = @{ $tdata{$date} };
                        $wt = $tstr[$n];
                        if ($wt > -99) {
                            $wt = 1.8 *$wt +32 if ($parms{units} eq "Fahrenheit");
                            $yp = $y2 -($y2 -$y1) *($wt -$ymin) /($ymax -$ymin);
                            $yp = &min($y2, &max($y1, $yp));
                            push (@points, $xp, $yp);
                        } else {
                            if ($#points > 1) {
                                $canv->create_line(@points,
                                                -fill  => &get_rgb_code($color[$n]),
                                                -width => $width[$n],
                                                -arrow => 'none',
                                                -state => $ts_state,
                                                -tags  => $gtag . " " . $gtag . "_tsData"
                                                                . " " . $gtag . "_dataset" . $n);
                            }
                            @points = ();
                        }
                    } else {
                        if ($#points > 1) {
                            $canv->create_line(@points,
                                            -fill  => &get_rgb_code($color[$n]),
                                            -width => $width[$n],
                                            -arrow => 'none',
                                            -state => $ts_state,
                                            -tags  => $gtag . " " . $gtag . "_tsData"
                                                            . " " . $gtag . "_dataset" . $n);
                        }
                        @points = ();
                    }
                }
                if ($#points > 1) {
                    $canv->create_line(@points,
                                    -fill  => &get_rgb_code($color[$n]),
                                    -width => $width[$n],
                                    -arrow => 'none',
                                    -state => $ts_state,
                                    -tags  => $gtag . " " . $gtag . "_tsData"
                                                    . " " . $gtag . "_dataset" . $n);
                }
            }
        }
    }

#   Add any other datasets previously provided by the user
    if (defined($props{$id}{add_ts_parms})) {
        for ($i=0; $i<=$#add_ts_setnum; $i++) {
            &plot_ts_data($canv, $id, $new_graph, $add_ts_show[$i], $add_ts_setnum[$i],
                          $add_ts_file[$i],  $add_ts_lines[$i], $add_ts_ftype[$i], $add_ts_param[$i],
                          $add_ts_width[$i], $add_ts_color[$i], $add_ts_text[$i],
                          $add_ts_byear[$i], $add_ts_tzoff[$i], $add_ts_seg[$i], $add_ts_ctype[$i]);
        }
    }

#   Add date highlighting, if necessary
    if ($props{$id}{meta} eq "linked_time_series") {
        $add_date_pts = 0;
        for ($i=0; $i<=$#animate_ids; $i++) {
            $id2 = $animate_ids[$i];
            next if ($id2 == $id);
            if ($props{$id2}{meta} =~ /^(data_profile|vert_wd_zone)$/) {
                if ($props{$id}{link_id} == $id2 && $dti != 1) {
                    $add_date_pts = 1;
                    last;
                }
            }
        }
        if ($add_date_pts) {
            $dt = $dates[$dti-1];
            $jd = &date2jdate($dt);
            if ($jd >= $jd_min && $jd <= $jd_max) {
                $xp = $x1 +($x2 -$x1) *($jd -$jd_min)/($jd_max -$jd_min);

                if ($parms{ts_type} eq "Water Surface Elevation") {
                    if (defined($wsurf{$dt}) && $wsurf{$dt} ne "na") {
                        $ws_elev  = $wsurf{$dt};
                        $ws_elev *= 3.28084 if ($parms{units} eq "ft");
                        $yp = $y2 -($y2 -$y1) *($ws_elev -$ymin) /($ymax -$ymin);
                        $yp = &min($y2, &max($y1, $yp));
                        $canv->create_oval($xp-3, $yp-3, $xp+3, $yp+3,
                                        -outline => "#000000",
                                        -width   => 1,
                                        -fill    => &get_rgb_code($color[0]),
                                        -tags    => $gtag . " " . $gtag . "_tsData"
                                                          . " " . $gtag . "_datePoint"
                                                          . " " . $gtag . "_dataPoint0");
                    }
                } elsif ($parms{ts_type} eq "Flow") {
                    for ($n=0; $n<=$#names; $n++) {
                        $ts_state = ($show[$n]) ? 'normal' : 'hidden';
                        if (defined($qdata{$dt})) {
                            @qstr = @{ $qdata{$dt} };
                            if ($names[$n] eq "All Outlets") {
                                $flow = &sum(@qstr);
                            } else {
                                $flow = $qstr[$n];
                            }
                            $flow *= 35.31467 if ($parms{units} eq "cfs");
                            $yp = $y2 -($y2 -$y1) *($flow -$ymin) /($ymax -$ymin);
                            $yp = &min($y2, &max($y1, $yp));
                            $canv->create_oval($xp-3, $yp-3, $xp+3, $yp+3,
                                            -outline => "#000000",
                                            -width   => 1,
                                            -fill    => &get_rgb_code($color[$n]),
                                            -state   => $ts_state,
                                            -tags    => $gtag . " " . $gtag . "_tsData"
                                                              . " " . $gtag . "_datePoint"
                                                              . " " . $gtag . "_dataPoint" . $n);
                        }
                    }
                } elsif ($parms{ts_type} eq "Temperature") {
                    for ($n=0; $n<=$#names; $n++) {
                        $ts_state = ($show[$n]) ? 'normal' : 'hidden';
                        if (defined($tdata{$dt})) {
                            @tstr = @{ $tdata{$dt} };
                            $wt   = $tstr[$n];
                            if ($wt > -99) {
                                $wt = 1.8 *$wt +32 if ($parms{units} eq "Fahrenheit");
                                $yp = $y2 -($y2 -$y1) *($wt -$ymin) /($ymax -$ymin);
                                $yp = &min($y2, &max($y1, $yp));
                                $canv->create_oval($xp-3, $yp-3, $xp+3, $yp+3,
                                                -outline => "#000000",
                                                -width   => 1,
                                                -fill    => &get_rgb_code($color[$n]),
                                                -state   => $ts_state,
                                                -tags    => $gtag . " " . $gtag . "_tsData"
                                                                  . " " . $gtag . "_datePoint"
                                                                  . " " . $gtag . "_dataPoint" . $n);
                            }
                        }
                    }
                }
            }
        }
    }

#   Place the graphic items in the proper order
    &raise_lower($canv, $id, "tiptop") if ($new_graph);
    $canv->lower($gtag . "_gtitle",     $id);
    $canv->lower($gtag . "_grid",       $id);
    $canv->lower($gtag . "_xaxisTitle", $id);
    $canv->lower($gtag . "_yaxisTitle", $id);
    $canv->lower($gtag . "_dateline",   $id);
    $canv->lower($gtag . "_legend",     $id);
    $canv->lower($gtag . "_tsData",     $id);
    $canv->lower($gtag . "_datePoint",  $id);
    $canv->lower($gtag . "_xaxis",      $id);
    $canv->lower($gtag . "_yaxis",      $id);
    @items = Tkx::SplitList($canv->find_withtag($gtag . "_legend"));
    if ($#items >= 0) {
        $canv->lower($gtag . "_legendBox", $gtag . "_legend");
    }
    @items = Tkx::SplitList($canv->find_withtag($gtag . "_tsData"));
    if ($#items >= 0) {
        $canv->lower($id, $gtag . "_tsData");    # plot datasets above graph frame
    }
    if ($group_tags) {
        foreach $tag (@grp_tags) {
            $canv->addtag($tag, withtag => $gtag);
        }
    }
}


sub add_ts_data {
    my ($canv, $id, $X, $Y) = @_;
    my (
        $byear, $byear_cb, $byear_label, $byear_label2, $code, $color,
        $color_btn, $conv_add, $conv_add_entry, $conv_mult, $conv_mult_entry,
        $conv_type, $conv_type_cb, $create_btn, $custom_frame, $data_file,
        $data_type, $fg, $fmt, $frame, $geom, $indx, $item, $legend_txt,
        $link_id, $n, $new_data, $nlines, $offset_frame, $parm, $parm_cb,
        $parm_chars, $parm_label, $row, $segnum, $segnum_cb, $segnum_label,
        $setnum, $show_data, $ts_frame, $tz_offset, $tzoff_label, $width,
        $yr_max, $yr_min,

        @file_fmts, @items, @names, @parmlist, @segs, @tags,

        %ts_parms,
       );

    &end_select($canv, $id, 1);

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($add_ts_data_menu) && Tkx::winfo_exists($add_ts_data_menu)) {
        if ($add_ts_data_menu->g_wm_title() eq "Add Time Series Data") {
            $add_ts_data_menu->g_destroy();
            undef $add_ts_data_menu;
        }
    }
    $add_ts_data_menu = $main->new_toplevel();
    $add_ts_data_menu->g_wm_transient($main);
    $add_ts_data_menu->g_wm_title("Add Time Series Data");
    $add_ts_data_menu->configure(-cursor => $cursor_norm);
    $add_ts_data_menu->g_wm_geometry($geom);

    %ts_parms   = %{ $props{$id}{ts_parms} };
    $data_type  = $ts_parms{ts_type};
    $data_file  = "";
    $width      = 1;
    $color      = 'red';
    $legend_txt = "Add Legend";
    $segnum     = "";
    $setnum     = 0;
    $new_data   = 1;
    $show_data  = 1;
    $yr_max     = (localtime(time))[5] +1900;
    $yr_min     = $yr_max -25;
    $byear      = $yr_max;
    $tz_offset  = "+00:00";
    $nlines     = 0;

#   Conversion types and factors (@conv_type is global)
    $conv_type  = $conv_types[0];
    $conv_mult  = 1.0;
    $conv_add   = 0.0;

#   Potential file formats
    @file_fmts = ("Undetermined",
                  "USGS getData format",
                  "Aquarius Time-Series format",
                  "Dataquery format",
                  "USGS Water Services format",
                  "USGS Data Grapher format",
                  "CSV format",
                  "W2 TSR format",
                  "W2 Outflow CSV format",
                  "W2 CSV format",
                  "W2 column format",
                  "W2 Daily SurfTemp.dat format",
                  "W2 Daily VolTemp.dat format",
                  "W2 Daily FlowTemp.dat format",
                  "W2 Subdaily SurfTemp2.dat format",
                  "W2 Subdaily VolTemp2.dat format",
                  "W2 Subdaily FlowTemp2.dat format",
                  "W2 Heat Fluxes format",
                  "W2 Water Level (wl) format",
                 );
    $fmt         = $file_fmts[0];
    $parm        = "Unknown";
    @parmlist    = ();
    $parmlist[0] = $parm;
    $parm_chars  = length($parm) +2;
    @segs        = ();

#   Determine the dataset number for the time-series graph.
#   First count up the minimum number of potential datasets.
#   Then check to see if any other user-added datasets increases the number.
    if ($props{$id}{meta} eq "linked_time_series") {
        if ($data_type eq "Water Surface Elevation") {
            $setnum = 1;
        } else {
            $link_id = $props{$id}{link_id};
            @names   = @{ $gr_props{$link_id}{names} };
            $setnum  = $#names +2;
        }
    }
    @items = Tkx::SplitList($canv->find_withtag("graph" . $id . "_tsData"));
    foreach $item (@items) {
        @tags = Tkx::SplitList($canv->gettags($item));
        $indx = &list_search("graph" . $id . "_dataset", @tags);
        if ($indx > -1) {
            ($n = $tags[$indx]) =~ s/graph${id}_dataset(\d+)/$1/;
            $setnum = $n +1 if ($n >= $setnum);
        }
    }

#   Create input menu
    $frame = $add_ts_data_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($create_btn = $frame->new_button(
            -text    => "Create",
            -state   => 'disabled',
            -command => sub { my ($tag, @tags);
                              if ($legend_txt eq "Add Legend" || $legend_txt eq "") {
                                  return &pop_up_error($add_ts_data_menu,
                                                       "Please add or edit the legend text.");
                              }
                              $add_ts_data_menu->g_destroy();
                              undef $add_ts_data_menu;
                              if ($conv_type eq "Custom") {
                                  $conv_type = sprintf("Custom,%s,%s", $conv_mult, $conv_add);
                              }
                              &plot_ts_data($canv, $id, $new_data, $show_data, $setnum,
                                            $data_file, $nlines, $fmt, $parm, $width, $color,
                                            $legend_txt, $byear, $tz_offset, $segnum, $conv_type);

#                             Add group tags
                              @tags = Tkx::SplitList($canv->itemcget($id, -tags));
                              if (&list_search("group_", @tags) > -1) {
                                  foreach $tag (@tags) {
                                      if ($tag =~ /^group_/) {
                                          $canv->addtag($tag, withtag => "graph" . $id);
                                      }
                                  }
                              }

#                             Refresh the Object Information box, if present
                              if (defined($object_infobox) && Tkx::winfo_exists($object_infobox)) {
                                  if ($object_infobox->g_wm_title() eq "Object Info") {
                                      $geom = $object_infobox->g_wm_geometry();
                                      (undef, $X, $Y) = split(/\+/, $geom);
                                      &show_info($canv, $id, $X, $Y);
                                  }
                              }
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $add_ts_data_menu->g_destroy();
                              undef $add_ts_data_menu; },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

    $ts_frame = $add_ts_data_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $ts_frame->g_pack(-side => 'top');

    $row = 0;
    $ts_frame->new_label(
            -text => "Data Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $ts_frame->new_label(
            -text   => $data_type,
            -font   => 'default',
            -anchor => 'w',
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');

    $row++;
    $ts_frame->new_label(
            -text => "Data File: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $ts_frame->new_label(
            -textvariable => \$data_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew');
    $ts_frame->new_button(
            -text    => "Browse",
            -command => sub { my ($file, $i, $segwidth, $segmax);
                              $file = Tkx::tk___getOpenFile(
                                      -parent     => $add_ts_data_menu,
                                      -title      => "Select Data File",
                                      -initialdir => abs_path(),
                                      -filetypes  => [ ['All Files',  '*'],
                                                       ['CSV (comma delimited)', '.csv'],
                                                     ],
                                      );
                              if ( $^O =~ /MSWin32/i ) {
                                  if (defined($file) && $file ne "") {
                                      $file =~ s/\//\\/g;
                                  }
                              }
                              if (defined($file) && $file ne "") {
                                  $data_file = $file;
                                  ($fmt, $nlines, @parmlist)
                                      = &determine_ts_type($add_ts_data_menu, $file);
                                  if ($fmt eq "") {
                                      $fmt         = $file_fmts[0];
                                      $parm        = "Unknown";
                                      @parmlist    = ();
                                      $parmlist[0] = $parm;
                                      $nlines      = 0;
                                      $data_file   = "";
                                  } else {
                                      $parm = $parmlist[0];
                                      $create_btn->configure(-state => 'normal');
                                  }
                                  $parm_chars = length($parmlist[0]);
                                  for ($i=1; $i<=$#parmlist; $i++) {
                                      if (length($parmlist[$i]) > $parm_chars) {
                                          $parm_chars = length($parmlist[$i]);
                                      }
                                  }
                                  $parm_chars += 2;
                                  $parm_cb->configure(-values => [ @parmlist ],
                                                      -width  => $parm_chars);
                                  if ($fmt !~ /^W2 /) {
                                      $byear_label->g_grid_remove();
                                      $byear_label2->g_grid_remove();
                                      $byear_cb->g_grid_remove();
                                      $tzoff_label->g_grid_remove();
                                      $offset_frame->g_grid_remove();
                                      $segnum_label->g_grid_remove();
                                      $segnum_cb->g_grid_remove();
                                      $parm_label->g_grid_remove();
                                      $parm_cb->g_grid();
                                  } else {
                                      $byear_label->g_grid();
                                      $byear_label2->g_grid();
                                      $byear_cb->g_grid();
                                      $tzoff_label->g_grid();
                                      $offset_frame->g_grid();
                                      if ($fmt eq "W2 Heat Fluxes format"
                                            || $fmt eq "W2 Water Level (wl) format"
                                            || $fmt =~ /^W2 .*daily .*Temp2?\.dat format$/i) {
                                          $segnum_label->g_grid();
                                          $segnum_cb->g_grid();
                                      } else {
                                          $segnum_label->g_grid_remove();
                                          $segnum_cb->g_grid_remove();
                                      }
                                      if ($fmt eq "W2 Heat Fluxes format"
                                            || $fmt =~ /^W2 .*daily .*Temp2?\.dat format$/i) {
                                          ($segmax, @segs) = &scan_w2_file4segs($add_ts_data_menu,
                                                                                $data_file, $fmt);
                                          $segwidth = 5;
                                          if ($#segs >= 0 && $segmax > 0) {
                                              $segwidth = &max(5, length($segmax));
                                          }
                                          $segnum_cb->configure(-values => [ @segs ],
                                                                -width  => $segwidth);
                                          if (&list_match($segnum, @segs) == -1) {
                                              $segnum = $segs[0];
                                          }
                                      }
                                      if ($fmt eq "W2 Water Level (wl) format") {
                                          @segs = @parmlist;
                                          $segnum_cb->configure(-values => [ @segs ],
                                                                -width  => $parm_chars);
                                          if (&list_match($segnum, @segs) == -1) {
                                              $segnum = $segs[0];
                                          }
                                          $parm_cb->g_grid_remove();
                                          $parm_label->g_grid();
                                          $parm = "Water Level";
                                      } else {
                                          $parm_label->g_grid_remove();
                                          $parm_cb->g_grid();
                                      }
                                  }
                              } else {
                                  $create_btn->configure(-state => 'disabled');
                              }
                            },
            )->g_grid(-row => $row, -column => 4, -sticky => 'ew', -padx => 2);

    $row++;
    $ts_frame->new_label(
            -text => "File Format: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $ts_frame->new_label(
            -textvariable => \$fmt,
            -anchor       => 'w',
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    ($segnum_label = $ts_frame->new_label(
            -text => "Segment: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($segnum_cb = $ts_frame->new_ttk__combobox(
            -textvariable => \$segnum,
            -values       => [ @segs ],
            -state        => 'readonly',
            -width        => 5,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    $ts_frame->new_label(
            -text => "Parameter: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($parm_label = $ts_frame->new_label(
            -text => "Water Level",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $parm_label->g_grid_remove();
    ($parm_cb = $ts_frame->new_ttk__combobox(
            -textvariable => \$parm,
            -values       => [ @parmlist ],
            -state        => 'readonly',
            -width        => $parm_chars,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    $ts_frame->new_label(
            -text => "Conversion: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($conv_type_cb = $ts_frame->new_ttk__combobox(
            -textvariable => \$conv_type,
            -values       => [ @conv_types ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);
    $conv_type_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($conv_type eq "Custom") {
                                $custom_frame->g_grid();
                            } else {
                                $custom_frame->g_grid_remove();
                            }
                          }
                      );
    $row++;
    ($custom_frame = $ts_frame->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    $custom_frame->new_label(
            -text => "Multiply by: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_mult_entry = $custom_frame->new_entry(
            -textvariable => \$conv_mult,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_mult_entry->g_bind("<KeyRelease>",
                              sub { &numeric_entry_only($conv_mult_entry);
                                    my $chars = &max(7, length($conv_mult));
                                    $conv_mult_entry->configure(-width => $chars);
                                  });
    $custom_frame->new_label(
            -text => "  Then add: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_add_entry = $custom_frame->new_entry(
            -textvariable => \$conv_add,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_add_entry->g_bind("<KeyRelease>",
                             sub { &numeric_entry_only($conv_add_entry);
                                   my $chars = &max(7, length($conv_add));
                                   $conv_add_entry->configure(-width => $chars);
                                 });

    $row++;
    ($byear_label = $ts_frame->new_label(
            -text => "Base Year: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($byear_cb = $ts_frame->new_ttk__combobox(
            -textvariable => \$byear,
            -values       => [ reverse($yr_min .. $yr_max) ],
            -state        => 'readonly',
            -width        => 5,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $byear_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($byear == $yr_min) {
                                $yr_min -= 5;
                                $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                            }
                          }
                     );
    ($byear_label2 = $ts_frame->new_label(
            -text   => " for JDAY = 1.0",
            -anchor => 'w',
            -font   => 'default',
            ))->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    ($tzoff_label = $ts_frame->new_label(
            -text => "Time Offset: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($offset_frame = $ts_frame->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w');
    $offset_frame->new_ttk__combobox(
            -textvariable => \$tz_offset,
            -values       => [ @tz_offsets ],
            -justify      => 'right',
            -state        => 'readonly',
            -width        => 6,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $offset_frame->new_label(
            -text   => " time zone adjustment ",
            -anchor => 'w',
            -font   => 'default',
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $offset_frame->new_button(
            -text    => "Help",
            -command => sub { &pop_up_info($add_ts_data_menu,
                                    "The time offset allows the user to add or subtract a time\n"
                                  . "offset if the W2 model was run with a non-local time zone.\n\n"
                                  . "For example, if W2 was run in UTC but the local time zone\n"
                                  . "is PST, an offset of -08:00 would convert the model date/time\n"
                                  . "to a local standard time of PST. This offset does not make\n"
                                  . "any adjustments related to daylight saving time. In general,\n"
                                  . "W2 is best run in the local standard time.\n\n"
                                  . "Leave the time offset at +00:00 for no adjustment.",
                                    "Time Offset Notice");
                            },
            )->g_pack(-side => 'left', -anchor => 'w', -padx => 2);

    $row++;
    $ts_frame->new_label(
            -text => "Line Width: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $ts_frame->new_spinbox(
            -textvariable => \$width,
            -state        => 'readonly',
            -font         => 'default',
            -from         => 1,
            -to           => 10,
            -increment    => 1,
            -width        => 3,
            )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    $row++;
    $ts_frame->new_label(
            -text => "Line Color: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $code  = &get_rgb_code($color);
    $color = &get_rgb_name($code);
    $fg    = &get_rgb_code("black");
    if ($code =~ /^\#[0-9a-f]/i) {
        $fg = &get_rgb_code(&get_bw_contrast($code));
    }
    ($color_btn = $ts_frame->new_button(
            -textvariable => \$color,
            -background   => $code,
            -foreground   => $fg,
            -width        => -7,
            -command => sub { my ($newc, $code, $fg);
                              $code = &get_rgb_code($color);
                              $newc = Tkx::tk___chooseColor(
                                         -initialcolor => $code,
                                         -parent       => $add_ts_data_menu);
                              if ($newc) {
                                  $code  = &get_rgb_code($newc);
                                  $color = &get_rgb_name($code);
                                  $fg    = &get_rgb_code("black");
                                  if ($code =~ /^#?[0-9a-f]/i) {
                                      $fg = &get_rgb_code(&get_bw_contrast($code));
                                  }
                                  $color_btn->configure(-foreground => $fg,
                                                        -background => $code);
                              }
                            }
            ))->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    $ts_frame->new_label(
            -text => "Legend Entry: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $ts_frame->new_entry(
            -textvariable => \$legend_txt,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'ew', -pady => 2);

    if ($fmt !~ /^W2 /) {
        $byear_label->g_grid_remove();
        $byear_label2->g_grid_remove();
        $byear_cb->g_grid_remove();
        $tzoff_label->g_grid_remove();
        $offset_frame->g_grid_remove();
    }
    if ($fmt ne "W2 Heat Fluxes format" && $fmt ne "W2 Water Level (wl) format"
                                        && $fmt !~ /^W2 .*daily .*Temp2?\.dat format$/i) {
        $segnum_label->g_grid_remove();
        $segnum_cb->g_grid_remove();
    }
    if ($fmt eq "W2 Water Level (wl) format") {
        $parm_cb->g_grid_remove();
        $parm_label->g_grid();
    }
    if ($conv_type ne "Custom") {
        $custom_frame->g_grid_remove();
    }
    $ts_frame->g_grid_columnconfigure(3, -weight => 2);

    Tkx::wm_resizable($add_ts_data_menu,0,0);
    &adjust_window_position($add_ts_data_menu);
    $add_ts_data_menu->g_focus;
}


sub plot_ts_data {
    my ($canv, $id, $new_data, $show_data, $setnum, $data_file, $nlines, $file_type,
        $parm, $width, $color, $legend_txt, $byear, $tzoff, $segnum, $conv_type) = @_;
    my (
        $base_jd, $datemax, $datemin, $dt, $gap_tol, $geom, $gtag, $i, $jd,
        $jd_max, $jd_min, $link_id, $missing, $n, $num_hidden, $num_plotted,
        $num_possible, $pbar, $pbar_window, $pmax, $pmin, $tabid, $ts_state,
        $val, $X, $x1, $x2, $xp, $Y, $y1, $y2, $ymax, $ymin, $yp,

        @add_ts_byear, @add_ts_color, @add_ts_ctype, @add_ts_file,
        @add_ts_ftype, @add_ts_limits, @add_ts_lines, @add_ts_param,
        @add_ts_seg, @add_ts_setnum, @add_ts_show, @add_ts_text,
        @add_ts_tsdata, @add_ts_tzoff, @add_ts_width, @fmt_group1,
        @fmt_group2, @items, @jds, @names, @points, @show, @tmp, @ts_dates,

        %add_ts_parms, %parms, %ts_data, %ts_limits,
       );

    $pbar     = "";
    $ts_state = ($show_data) ? 'normal' : 'hidden';
    $byear    = "n/a"    if (! defined($byear) || $file_type !~ /^W2 /);
    $tzoff    = "+00:00" if (! defined($tzoff) || $file_type !~ /^W2 /);
    $segnum   = "n/a"    if (! defined($segnum)
                             || ($file_type ne "W2 Heat Fluxes format" &&
                                 $file_type ne "W2 Water Level (wl) format" &&
                                 $file_type !~ /^W2 .*daily .*Temp2?\.dat format$/i));
    $missing   = "na";
    %ts_limits = ();

#   Get some info about the time-series graph
    ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
    $gtag = "graph" . $id;
    $ymin = $gr_props{$id}{ymin};
    $ymax = $gr_props{$id}{ymax};
    if (! defined($gr_props{$id}{xtype}) || $gr_props{$id}{xtype} eq "Date/Time") {
        $jd_min = &datelabel2jdate($gr_props{$id}{xmin});
        $jd_max = &datelabel2jdate($gr_props{$id}{xmax});
    } else {
        $base_jd = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
        $jd_min  = $gr_props{$id}{xmin} +$base_jd -1;
        $jd_max  = $gr_props{$id}{xmax} +$base_jd -1;
    }
    $gap_tol = $gr_props{$id}{gap_tol};

#   Read the time-series data
    if ($new_data) {
        @fmt_group1 = ("USGS getData format",
                       "Aquarius Time-Series format",
                       "Dataquery format",
                       "USGS Water Services format",
                       "USGS Data Grapher format",
                       "CSV format",
                      );
        @fmt_group2 = ("W2 TSR format",
                       "W2 Outflow CSV format",
                       "W2 Layer Outflow CSV format",
                       "W2 CSV format",
                       "W2 column format",
                      );
        if ($nlines <= 0) {
            (undef, $nlines, undef) = &determine_ts_type($main, $data_file);
        }
        if ($nlines > 4000) {
            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $nlines,
                                                         "Reading time-series file...");
        }
        if (&list_match($file_type, @fmt_group1) >= 0) {
            %ts_data = &read_timeseries($main, $data_file, $file_type, $parm, $pbar);

        } elsif (&list_match($file_type, @fmt_group2) >= 0) {
            %ts_data = &read_w2_timeseries($main, $data_file, $file_type, $parm, $byear, $tzoff, $pbar);

        } elsif ($file_type eq "W2 Heat Fluxes format") {
            %ts_data = &read_w2_heatfluxes($main, $data_file, $parm, $byear, $tzoff, $segnum, $pbar);

        } elsif ($file_type =~ /W2 .*aily .*Temp2?\.dat format/) {
            %ts_data = &read_w2_flowtemp($main, $data_file, $parm, $byear, $tzoff, $segnum, $pbar);

        } elsif ($file_type eq "W2 Water Level (wl) format") {
            %ts_data = &read_w2_wlevel($main, $id, $data_file, $byear, $tzoff, $segnum, 0, 0, $pbar);
        }
        if ($nlines > 4000) {
            &destroy_progress_bar($main, $pbar_window);
        }
        if (&list_match($conv_type, @conv_types) > 0 || $conv_type =~ /^Custom,/) {
            %ts_data = &convert_timeseries($main, $conv_type, 0, %ts_data);
        }
        @ts_dates = sort keys %ts_data;
        $datemin  = substr($ts_dates[0],0,8);
        $datemax  = substr($ts_dates[$#ts_dates],0,8);
        $pmin     =  9.E6;
        $pmax     = -9.E6;
        foreach $dt (@ts_dates) {
            next if ($ts_data{$dt} eq $missing);
            $pmin = $ts_data{$dt} if ($ts_data{$dt} < $pmin);
            $pmax = $ts_data{$dt} if ($ts_data{$dt} > $pmax);
        }
        $ts_limits{date_min} = $datemin;
        $ts_limits{date_max} = $datemax;
        $ts_limits{parm_min} = $pmin;
        $ts_limits{parm_max} = $pmax;
        if ($props{$id}{meta} eq "time_series") {
            if (! defined($ts_datemin)) {
                $ts_datemin = $datemin;
                $ts_datemax = $datemax;
            } else {
                $ts_datemin = $datemin if ($datemin < $ts_datemin);
                $ts_datemax = $datemax if ($datemax > $ts_datemax);
            }
        }
    } else {
        %add_ts_parms  = %{ $props{$id}{add_ts_parms} };
        @add_ts_setnum = @{ $add_ts_parms{ts_setnum}  };
        @add_ts_tsdata = @{ $add_ts_parms{ts_data}    };
        for ($n=0; $n<=$#add_ts_setnum; $n++) {
            if ($setnum == $add_ts_setnum[$n]) {
                %ts_data = %{ $add_ts_tsdata[$n] };
                last;
            }
        }
    }

#   Plot the time-series data
    @points = @jds = ();
    foreach $dt (sort keys %ts_data) {
        $jd = &date2jdate($dt);
        next if ($jd < $jd_min);
        last if ($jd > $jd_max);
        $val = $ts_data{$dt};
        next if ($val eq $missing);
        $xp = $x1 +($x2 -$x1) *($jd -$jd_min)/($jd_max -$jd_min);
        $yp = $y2 -($y2 -$y1) *($val -$ymin) /($ymax -$ymin);
#xxx interpolate to boundary?
        $yp = &min($y2, &max($y1, $yp));
        push (@points, $xp, $yp);
        push (@jds, $jd);
    }
    if ($#points > 0) {
        if ($gap_tol == 0.) {
            for ($i=0; $i<$#points; $i+=2) {
                $xp = $points[$i];
                $yp = $points[$i+1];
                $canv->create_rectangle($xp-2, $yp-2, $xp+2, $yp+2,
                                        -outline => &get_rgb_code($color),
                                        -width   => $width,
                                        -fill    => "",
                                        -state   => $ts_state,
                                        -tags    => $gtag . " " . $gtag . "_tsData"
                                                          . " " . $gtag . "_dataset"   . $setnum
                                                          . " " . $gtag . "_dataPoint" . $setnum);
            }
        } else {
            @tmp = ($points[0], $points[1]);
            for ($i=1; $i<=$#jds; $i++) {
                if ($jds[$i] -$jds[$i-1] <= $gap_tol) {
                    push (@tmp, $points[2*$i], $points[2*$i+1]);
                }
                if ($jds[$i] -$jds[$i-1] > $gap_tol || $#tmp >= 499) {
                    if ($#tmp > 1) {
                        $canv->create_line(@tmp, -fill  => &get_rgb_code($color),
                                                 -width => $width,
                                                 -arrow => 'none',
                                                 -state => $ts_state,
                                                 -tags  => $gtag . " " . $gtag . "_tsData"
                                                                 . " " . $gtag . "_dataset"  . $setnum
                                                                 . " " . $gtag . "_dataLine" . $setnum);
                    } elsif ($#tmp > 0) {
                        $canv->create_rectangle($tmp[0]-2, $tmp[1]-2, $tmp[0]+2, $tmp[1]+2,
                                                -outline => &get_rgb_code($color),
                                                -width   => $width,
                                                -fill    => "",
                                                -state   => $ts_state,
                                                -tags    => $gtag . " " . $gtag . "_tsData"
                                                                  . " " . $gtag . "_dataset"   . $setnum
                                                                  . " " . $gtag . "_dataPoint" . $setnum);
                    }
                    @tmp = ($points[2*$i], $points[2*$i+1]);
                }
            }
            if ($#tmp > 1) {
                $canv->create_line(@tmp, -fill  => &get_rgb_code($color),
                                         -width => $width,
                                         -arrow => 'none',
                                         -state => $ts_state,
                                         -tags  => $gtag . " " . $gtag . "_tsData"
                                                         . " " . $gtag . "_dataset"  . $setnum
                                                         . " " . $gtag . "_dataLine" . $setnum);
            } elsif ($#tmp > 0) {
                $canv->create_rectangle($tmp[0]-2, $tmp[1]-2, $tmp[0]+2, $tmp[1]+2,
                                        -outline => &get_rgb_code($color),
                                        -width   => $width,
                                        -fill    => "",
                                        -state   => $ts_state,
                                        -tags    => $gtag . " " . $gtag . "_tsData"
                                                          . " " . $gtag . "_dataset"   . $setnum
                                                          . " " . $gtag . "_dataPoint" . $setnum);
            }
        }
    }

#   Add a legend entry, but only if the dataset is visible
    if ($show_data) {

#       Determine how many of the baseline datasets are being plotted
        $num_possible = $num_plotted = 0;
        if ($props{$id}{meta} eq "linked_time_series") {
            %parms = %{ $props{$id}{ts_parms} };
            if ($parms{ts_type} eq "Water Surface Elevation") {
                $num_possible = 1;
                $num_plotted  = 1;
            } else {
                @show    = @{ $parms{show} };
                $link_id = $props{$id}{link_id};
                @names   = @{ $gr_props{$link_id}{names} };
                push (@names, "All Outlets");
                $num_possible = $#names +1;
                $num_plotted  = 0;
                for ($n=0; $n<=$#names; $n++) {
                    $num_plotted++ if ($show[$n]);
                }
            }
        }

#       Determine how many of the previously added datasets are hidden
        $num_hidden = 0;
        if (defined($props{$id}{add_ts_parms})) {
            %add_ts_parms  = %{ $props{$id}{add_ts_parms} };
            @add_ts_show   = @{ $add_ts_parms{ts_show}    };
            @add_ts_setnum = @{ $add_ts_parms{ts_setnum}  };
            for ($n=0; $n<=$#add_ts_setnum; $n++) {
                last if ($setnum <= $add_ts_setnum[$n]);
                $num_hidden++ if (! $add_ts_show[$n]);
            }
        }

#       Plot the legend entry
        $xp  = $x2 +$gr_props{$id}{xleg_off};
        $yp  = $y1 +$gr_props{$id}{yleg_off};
        $yp += $gr_props{$id}{lt_size} *1.5 if ($gr_props{$id}{legtitle} ne "");
        $yp += ($setnum -$num_hidden -$num_possible +$num_plotted) *$gr_props{$id}{le_size} *1.5;
        $canv->create_line($xp, $yp, $xp+20, $yp,
                           -fill   => &get_rgb_code($color),
                           -width  => $width,
                           -arrow  => 'none',
                           -tags   => $gtag . " " . $gtag . "_legend");
        $canv->create_text($xp+25, $yp,
                           -anchor => 'w',
                           -text   => $legend_txt,
                           -fill   => &get_rgb_code("black"),
                           -angle  => 0,
                           -tags   => $gtag . " " . $gtag . "_legend",
                           -font   => [-family     => $gr_props{$id}{legfont},
                                       -size       => $gr_props{$id}{le_size},
                                       -weight     => $gr_props{$id}{le_weight},
                                       -slant      => 'roman',
                                       -underline  => 0,
                                       -overstrike => 0,
                                      ]);
    }

#   Update the legend box, if needed
    &update_legend_box($canv, $id);

#   Put things in the correct order
    $canv->lower($gtag . "_legend",    $id);
    $canv->lower($gtag . "_tsData",    $id);
    $canv->lower($gtag . "_datePoint", $id);
    $canv->lower($gtag . "_xaxis",     $id);
    $canv->lower($gtag . "_yaxis",     $id);
    @items = Tkx::SplitList($canv->find_withtag($gtag . "_legend"));
    if ($#items >= 0) {
        $canv->lower($gtag . "_legendBox", $gtag . "_legend");
    }

#   Add the time-series object and its attributes to the graph's properties.
    if ($new_data) {
        if (defined($props{$id}{add_ts_parms})) {
            %add_ts_parms  = %{ $props{$id}{add_ts_parms} };
            @add_ts_setnum = @{ $add_ts_parms{ts_setnum}  };
            @add_ts_file   = @{ $add_ts_parms{ts_file}    };
            @add_ts_show   = @{ $add_ts_parms{ts_show}    };
            @add_ts_width  = @{ $add_ts_parms{ts_width}   };
            @add_ts_color  = @{ $add_ts_parms{ts_color}   };
            @add_ts_text   = @{ $add_ts_parms{ts_text}    };
            @add_ts_ftype  = @{ $add_ts_parms{ts_ftype}   };
            @add_ts_lines  = @{ $add_ts_parms{ts_lines}   };
            @add_ts_param  = @{ $add_ts_parms{ts_param}   };
            @add_ts_byear  = @{ $add_ts_parms{ts_byear}   };
            @add_ts_tzoff  = @{ $add_ts_parms{ts_tzoff}   };
            @add_ts_seg    = @{ $add_ts_parms{ts_seg}     };
            @add_ts_ctype  = @{ $add_ts_parms{ts_ctype}   };
            @add_ts_limits = @{ $add_ts_parms{ts_limits}  };
            @add_ts_tsdata = @{ $add_ts_parms{ts_data}    };
            $n = &list_match($setnum, @add_ts_setnum);
            $n = $#add_ts_setnum +1 if ($n == -1);
        } else {
            @add_ts_setnum = @add_ts_file   = @add_ts_show   = ();
            @add_ts_width  = @add_ts_color  = @add_ts_text   = ();
            @add_ts_ftype  = @add_ts_param  = @add_ts_byear  = ();
            @add_ts_seg    = @add_ts_ctype  = @add_ts_tsdata = ();
            @add_ts_lines  = @add_ts_limits = @add_ts_tzoff  = ();
            $n = 0;
        }
        $add_ts_setnum[$n] = $setnum;
        $add_ts_file[$n]   = $data_file;
        $add_ts_show[$n]   = $show_data;
        $add_ts_width[$n]  = $width;
        $add_ts_color[$n]  = $color;
        $add_ts_text[$n]   = $legend_txt;
        $add_ts_ftype[$n]  = $file_type;
        $add_ts_lines[$n]  = $nlines;
        $add_ts_param[$n]  = $parm;
        $add_ts_byear[$n]  = $byear;
        $add_ts_tzoff[$n]  = $tzoff;
        $add_ts_seg[$n]    = $segnum;
        $add_ts_ctype[$n]  = $conv_type;
        $add_ts_limits[$n] = { %ts_limits };
        $add_ts_tsdata[$n] = { %ts_data   };

        $add_ts_parms{ts_setnum}  = [ @add_ts_setnum ];
        $add_ts_parms{ts_file}    = [ @add_ts_file   ];
        $add_ts_parms{ts_show}    = [ @add_ts_show   ];
        $add_ts_parms{ts_width}   = [ @add_ts_width  ];
        $add_ts_parms{ts_color}   = [ @add_ts_color  ];
        $add_ts_parms{ts_text}    = [ @add_ts_text   ];
        $add_ts_parms{ts_ftype}   = [ @add_ts_ftype  ];
        $add_ts_parms{ts_lines}   = [ @add_ts_lines  ];
        $add_ts_parms{ts_param}   = [ @add_ts_param  ];
        $add_ts_parms{ts_byear}   = [ @add_ts_byear  ];
        $add_ts_parms{ts_tzoff}   = [ @add_ts_tzoff  ];
        $add_ts_parms{ts_seg}     = [ @add_ts_seg    ];
        $add_ts_parms{ts_ctype}   = [ @add_ts_ctype  ];
        $add_ts_parms{ts_limits}  = [ @add_ts_limits ];
        $add_ts_parms{ts_data}    = [ @add_ts_tsdata ];
        $props{$id}{add_ts_parms} = { %add_ts_parms  };

#       Refresh the Graph Properties menu, if present
        if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
            if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
                $tabid = $grprops_notebook->index('current');
                $geom  = $graph_props_menu->g_wm_geometry();
                (undef, $X, $Y) = split(/\+/, $geom);
                &edit_graph_props($id, $X, $Y, $tabid);
            }
        }
    }
    undef %ts_data;
}


sub add_ts_graph {
    my ($canv, $id) = @_;
    my (
        $bdate_frame, $bdate_label, $bday, $bday_cb, $bm, $bmon, $bmon_cb,
        $byear, $byear_cb, $byear_label, $byear_label2, $byr, $byr_cb,
        $code, $color, $color_btn, $conv_add, $conv_add_entry, $conv_mult,
        $conv_mult_entry, $conv_type, $conv_type_cb, $create_btn,
        $custom_frame, $data_file, $data_type, $data_type_entry,
        $edate_frame, $edate_label, $eday, $eday_cb, $em, $emon, $emon_cb,
        $eyr, $eyr_cb, $fg, $fmt, $frame, $geom, $legend_txt, $nlines,
        $offset_frame, $parm, $parm_cb, $parm_label, $parm_chars,
        $row, $segnum, $segnum_cb, $segnum_label, $setnum, $ts_frame,
        $tz_offset, $tzoff_label, $units, $units_entry, $width, $X, $x1,
        $x2, $xaxis_type, $xaxis_type_cb, $xmax, $xmax_entry, $xmax_label,
        $xmin, $xmin_entry, $xmin_label, $Y, $y1, $y2, $ymax, $ymax_entry,
        $ymin, $ymin_entry, $yr_max, $yr_min, $ytitle,

        @file_fmts, @parmlist, @segs,
       );

    &end_select($canv, $id, 1);

    ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $geom = sprintf("+%d+%d", $X+$x1+50, $Y+$y1+60);

    if (defined($add_ts_graph_menu) && Tkx::winfo_exists($add_ts_graph_menu)) {
        if ($add_ts_graph_menu->g_wm_title() eq "Add Time Series Graph") {
            $add_ts_graph_menu->g_destroy();
            undef $add_ts_graph_menu;
        }
    }
    $add_ts_graph_menu = $main->new_toplevel();
    $add_ts_graph_menu->g_wm_transient($main);
    $add_ts_graph_menu->g_wm_title("Add Time Series Graph");
    $add_ts_graph_menu->configure(-cursor => $cursor_norm);
    $add_ts_graph_menu->g_wm_geometry($geom);

#   Try to keep the nascent graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

    $data_file  = "";
    $data_type  = "";
    $units      = "";
    $xaxis_type = "Date/Time";
    $setnum     = 0;
    $width      = 1;
    $color      = 'red';
    $legend_txt = "Add Legend";
    $segnum     = "";
    $nlines     = 0;
    $tz_offset  = "+00:00";

#   Conversion types and factors (@conv_types is global)
    $conv_type  = $conv_types[0];
    $conv_mult  = 1.0;
    $conv_add   = 0.0;

#   Potential file formats
    @file_fmts = ("Undetermined",
                  "USGS getData format",
                  "Aquarius Time-Series format",
                  "Dataquery format",
                  "USGS Water Services format",
                  "USGS Data Grapher format",
                  "CSV format",
                  "W2 TSR format",
                  "W2 Outflow CSV format",
                  "W2 CSV format",
                  "W2 column format",
                  "W2 Daily SurfTemp.dat format",
                  "W2 Daily VolTemp.dat format",
                  "W2 Daily FlowTemp.dat format",
                  "W2 Subdaily SurfTemp2.dat format",
                  "W2 Subdaily VolTemp2.dat format",
                  "W2 Subdaily FlowTemp2.dat format",
                  "W2 Heat Fluxes format",
                  "W2 Water Level (wl) format",
                 );
    $fmt         = $file_fmts[0];
    $parm        = "Unknown";
    @parmlist    = ();
    $parmlist[0] = $parm;
    $parm_chars  = length($parm) +2;
    @segs        = ();

    $bm     = 0;
    $bmon   = $mon_names[$bm];
    $em     = 11;
    $emon   = $mon_names[$em];
    $bday   = 1;
    $eday   = $days_in_month[$em];
    $yr_max = (localtime(time))[5] +1900;
    $yr_min = $yr_max -25;
    $byear  = $byr  = $eyr = $yr_max;
    $ymin   = $ymax = "";
    $xmin   = $xmax = "";

#   Create input menu
    $frame = $add_ts_graph_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($create_btn = $frame->new_button(
            -text    => "Create",
            -state   => 'disabled',
            -command => sub { my (%add_ts_parms, %parms);
                              if ($legend_txt eq "Add Legend" || $legend_txt eq "") {
                                  return &pop_up_error($add_ts_graph_menu,
                                                       "Please add or edit the legend text.");
                              }
                              if ($ymin eq "" || $ymax eq "") {
                                  return &pop_up_error($add_ts_graph_menu,
                                  "Please provide both a minimum and maximum Y axis value.");
                              }
                              if ($ymin >= $ymax) {
                                  return &pop_up_error($add_ts_graph_menu,
                                      "The minimum Y axis value must be\n"
                                    . "less than the maximum Y axis value.");
                              }
                              if ($xaxis_type eq "Date/Time") {
                                  if ($byr > $eyr || ($byr == $eyr && $bm > $em)
                                                  || ($byr == $eyr && $bm == $em && $bday >= $eday)) {
                                      return &pop_up_error($add_ts_graph_menu,
                                                           "Start date must be before end date.");
                                  }
                              } else {
                                  if ($xmin eq "" || $xmax eq "") {
                                      return &pop_up_error($add_ts_graph_menu,
                                      "Please provide both a minimum and maximum X axis value.");
                                  }
                                  if ($xmin >= $xmax) {
                                      return &pop_up_error($add_ts_graph_menu,
                                          "The minimum X axis value must be\n"
                                        . "less than the maximum X axis value.");
                                  }
                              }
                              $add_ts_graph_menu->g_bind('<Destroy>', "");
                              $add_ts_graph_menu->g_destroy();
                              undef $add_ts_graph_menu;
                              &reset_bindings;

                              %parms          = ();
                              $parms{ts_type} = $data_type;
                              $parms{units}   = $units;
                              $parms{ymin}    = $ymin;
                              $parms{ymax}    = $ymax;
                              $parms{base_yr} = $byear;
                              $parms{xtype}   = $xaxis_type;
                              if ($xaxis_type eq "Date/Time") {
                                  $parms{xmin} = sprintf("%s-%02d-%04d", $bmon, $bday, $byr);
                                  $parms{xmax} = sprintf("%s-%02d-%04d", $emon, $eday, $eyr);
                              } else {
                                  $parms{xmin} = $xmin;
                                  $parms{xmax} = $xmax;
                              }
                              $props{$id}{ts_parms} = { %parms };

                              if ($conv_type eq "Custom") {
                                  $conv_type = sprintf("Custom,%s,%s", $conv_mult, $conv_add);
                              }
                              %add_ts_parms             = ();
                              $add_ts_parms{ts_setnum}  = [ ( $setnum     ) ];
                              $add_ts_parms{ts_file}    = [ ( $data_file  ) ];
                              $add_ts_parms{ts_ftype}   = [ ( $fmt        ) ];
                              $add_ts_parms{ts_lines}   = [ ( $nlines     ) ];
                              $add_ts_parms{ts_show}    = [ ( 1           ) ];
                              $add_ts_parms{ts_width}   = [ ( $width      ) ];
                              $add_ts_parms{ts_color}   = [ ( $color      ) ];
                              $add_ts_parms{ts_text}    = [ ( $legend_txt ) ];
                              $add_ts_parms{ts_param}   = [ ( $parm       ) ];
                              $add_ts_parms{ts_byear}   = [ ( $byear      ) ];
                              $add_ts_parms{ts_tzoff}   = [ ( $tz_offset  ) ];
                              $add_ts_parms{ts_seg}     = [ ( $segnum     ) ];
                              $add_ts_parms{ts_ctype}   = [ ( $conv_type  ) ];
                              $add_ts_parms{ts_limits}  = [ (             ) ];
                              $add_ts_parms{ts_data}    = [ (             ) ];
                              $props{$id}{add_ts_parms} = { %add_ts_parms   };

                              &make_ts_graph($canv, $id, 0);
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $add_ts_graph_menu->g_bind('<Destroy>', "");
                              $add_ts_graph_menu->g_destroy();
                              undef $add_ts_graph_menu;
                              $canv->delete("graph" . $id);
                              delete $props{$id};
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Delete graph if this menu is destroyed by other than the Cancel button
    $add_ts_graph_menu->g_bind('<Destroy>' => sub { undef $add_ts_graph_menu;
                                                    $canv->delete("graph" . $id);
                                                    delete $props{$id}; 
                                                    &reset_bindings;
                                                  });

    $ts_frame = $add_ts_graph_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $ts_frame->g_pack(-side => 'top');

    $row = 0;
    $ts_frame->new_label(
            -text => "Data File: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $ts_frame->new_label(
            -textvariable => \$data_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew');
    $ts_frame->new_button(
            -text    => "Browse",
            -command => sub { my ($file, $i, $segwidth, $segmax);
                              $file = Tkx::tk___getOpenFile(
                                      -parent     => $add_ts_graph_menu,
                                      -title      => "Select Data File",
                                      -initialdir => abs_path(),
                                      -filetypes  => [ ['All Files',  '*'],
                                                       ['CSV (comma delimited)', '.csv'],
                                                     ],
                                      );
                              if ( $^O =~ /MSWin32/i ) {
                                  if (defined($file) && $file ne "") {
                                      $file =~ s/\//\\/g;
                                  }
                              }
                              if (defined($file) && $file ne "") {
                                  $data_file = $file;
                                  ($fmt, $nlines, @parmlist)
                                      = &determine_ts_type($add_ts_graph_menu, $file);
                                  if ($fmt eq "") {
                                      $fmt         = $file_fmts[0];
                                      $parm        = "Unknown";
                                      @parmlist    = ();
                                      $parmlist[0] = $parm;
                                      $nlines      = 0;
                                      $data_file   = "";
                                      $create_btn->configure(-state => 'disabled');
                                  } else {
                                      $parm = $parmlist[0];
                                      $create_btn->configure(-state => 'normal');
                                  }
                                  $legend_txt = "Add Legend";
                                  $data_type  = $units = $ytitle = $ymin = $ymax = "";
                                  $parm_chars = length($parmlist[0]);
                                  for ($i=1; $i<=$#parmlist; $i++) {
                                      if (length($parmlist[$i]) > $parm_chars) {
                                          $parm_chars = length($parmlist[$i]);
                                      }
                                  }
                                  $parm_chars += 2;
                                  $parm_cb->configure(-values => [ @parmlist ],
                                                      -width  => $parm_chars);
                                  if ($fmt !~ /^W2 /) {
                                      if ($xaxis_type eq "Date/Time") {
                                          $byear_label->g_grid_remove();
                                          $byear_label2->g_grid_remove();
                                          $byear_cb->g_grid_remove();
                                      } else {
                                          $byear_label->g_grid();
                                          $byear_label2->g_grid();
                                          $byear_cb->g_grid();
                                      }
                                      $tzoff_label->g_grid_remove();
                                      $offset_frame->g_grid_remove();
                                      $segnum_label->g_grid_remove();
                                      $segnum_cb->g_grid_remove();
                                      $parm_label->g_grid_remove();
                                      $parm_cb->g_grid();
                                  } else {
                                      $byear_label->g_grid();
                                      $byear_label2->g_grid();
                                      $byear_cb->g_grid();
                                      $tzoff_label->g_grid();
                                      $offset_frame->g_grid();
                                      if ($fmt eq "W2 Heat Fluxes format"
                                            || $fmt eq "W2 Water Level (wl) format"
                                            || $fmt =~ /^W2 .*daily .*Temp2?\.dat format$/i) {
                                          $segnum_label->g_grid();
                                          $segnum_cb->g_grid();
                                      } else {
                                          $segnum_label->g_grid_remove();
                                          $segnum_cb->g_grid_remove();
                                      }
                                      if ($fmt eq "W2 Heat Fluxes format"
                                            || $fmt =~ /^W2 .*daily .*Temp2?\.dat format$/i) {
                                          ($segmax, @segs) = &scan_w2_file4segs($add_ts_graph_menu,
                                                                                $data_file, $fmt);
                                          $segwidth = 5;
                                          if ($#segs >= 0 && $segmax > 0) {
                                              $segwidth = &max(5, length($segmax));
                                          }
                                          $segnum_cb->configure(-values => [ @segs ],
                                                                -width  => $segwidth);
                                          if (&list_match($segnum, @segs) == -1) {
                                              $segnum = $segs[0];
                                          }
                                      }
                                      if ($fmt eq "W2 Water Level (wl) format") {
                                          @segs = @parmlist;
                                          $segnum_cb->configure(-values => [ @segs ],
                                                                -width  => $parm_chars);
                                          if (&list_match($segnum, @segs) == -1) {
                                              $segnum = $segs[0];
                                          }
                                          $parm_cb->g_grid_remove();
                                          $parm_label->g_grid();
                                          $parm = "Water Level";
                                      } else {
                                          $parm_label->g_grid_remove();
                                          $parm_cb->g_grid();
                                      }
                                  }
                              } else {
                                  if (! defined($data_file) || $data_file eq "" || ! -e $data_file) {
                                      $legend_txt = "Add Legend";
                                      $data_file  = $data_type = $units = "";
                                      $ytitle     = $ymin      = $ymax  = "";
                                      $create_btn->configure(-state => 'disabled');
                                  }
                              }
                            },
            )->g_grid(-row => $row, -column => 4, -sticky => 'ew', -padx => 2);

    $row++;
    $ts_frame->new_label(
            -text => "File Format: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $ts_frame->new_label(
            -textvariable => \$fmt,
            -anchor       => 'w',
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    ($segnum_label = $ts_frame->new_label(
            -text => "Segment: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($segnum_cb = $ts_frame->new_ttk__combobox(
            -textvariable => \$segnum,
            -values       => [ @segs ],
            -state        => 'readonly',
            -width        => 5,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    $ts_frame->new_label(
            -text => "Parameter: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($parm_label = $ts_frame->new_label(
            -text => "Water Level",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w', -pady => 2);
    $parm_label->g_grid_remove();
    ($parm_cb = $ts_frame->new_ttk__combobox(
            -textvariable => \$parm,
            -values       => [ @parmlist ],
            -state        => 'readonly',
            -width        => $parm_chars,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    $ts_frame->new_label(
            -text => "Conversion: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($conv_type_cb = $ts_frame->new_ttk__combobox(
            -textvariable => \$conv_type,
            -values       => [ @conv_types ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w', -pady => 2);
    $conv_type_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($conv_type eq "Custom") {
                                $custom_frame->g_grid();
                            } else {
                                $custom_frame->g_grid_remove();
                            }
                          }
                      );
    $row++;
    ($custom_frame = $ts_frame->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w');
    $custom_frame->new_label(
            -text => "Multiply by: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_mult_entry = $custom_frame->new_entry(
            -textvariable => \$conv_mult,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_mult_entry->g_bind("<KeyRelease>",
                              sub { &numeric_entry_only($conv_mult_entry);
                                    my $chars = &max(7, length($conv_mult));
                                    $conv_mult_entry->configure(-width => $chars);
                                  });
    $custom_frame->new_label(
            -text => "  Then add: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_add_entry = $custom_frame->new_entry(
            -textvariable => \$conv_add,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_add_entry->g_bind("<KeyRelease>",
                             sub { &numeric_entry_only($conv_add_entry);
                                   my $chars = &max(7, length($conv_add));
                                   $conv_add_entry->configure(-width => $chars);
                                 });

    $row++;
    $ts_frame->new_label(
            -text => "Data Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($data_type_entry = $ts_frame->new_entry(
            -textvariable => \$data_type,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w', -pady => 2);
    $data_type_entry->g_bind("<KeyRelease>",
                             sub { my $chars = &max(7, length($data_type));
                                   $data_type_entry->configure(-width => $chars);
                                   if ($data_type eq "Temperature") {
                                       $ytitle = "Temperature, in degrees " . $units;
                                   } else {
                                       $ytitle = $data_type . ", in " . $units;
                                   }
                                 });
    $row++;
    $ts_frame->new_label(
            -text => "Data Units: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($units_entry = $ts_frame->new_entry(
            -textvariable => \$units,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w', -pady => 2);
    $units_entry->g_bind("<KeyRelease>",
                         sub { my $chars = &max(7, length($units));
                               $units_entry->configure(-width => $chars);
                               if ($data_type eq "Temperature") {
                                   $ytitle = "Temperature, in degrees " . $units;
                               } else {
                                   $ytitle = $data_type . ", in " . $units;
                               }
                             });

    $row++;
    $ts_frame->new_label(
            -text => "Y Axis Title: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $ts_frame->new_label(
            -textvariable => \$ytitle,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    $ts_frame->new_label(
            -text => "Y Axis Min: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ymin_entry = $ts_frame->new_entry(
            -textvariable => \$ymin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $ymin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $ymin_entry ]);

    $row++;
    $ts_frame->new_label(
            -text => "Y Axis Max: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ymax_entry = $ts_frame->new_entry(
            -textvariable => \$ymax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $ymax_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $ymax_entry ]);

    $row++;
    $ts_frame->new_label(
            -text => "X Axis Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($xaxis_type_cb = $ts_frame->new_ttk__combobox(
            -textvariable => \$xaxis_type,
            -values       => [ ("Date/Time", "Julian Date") ],
            -state        => 'readonly',
            -width        => 12,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w', -pady => 2);
    $xaxis_type_cb->g_bind("<<ComboboxSelected>>",
                            sub { if ($xaxis_type eq "Date/Time") {
                                      $xmin_label->g_grid_remove();
                                      $xmin_entry->g_grid_remove();
                                      $xmax_label->g_grid_remove();
                                      $xmax_entry->g_grid_remove();
                                      $bdate_label->g_grid();
                                      $bdate_frame->g_grid();
                                      $edate_label->g_grid();
                                      $edate_frame->g_grid();
                                      if ($fmt !~ /^W2 /) {
                                          $byear_label->g_grid_remove();
                                          $byear_label2->g_grid_remove();
                                          $byear_cb->g_grid_remove();
                                      } else {
                                          $byear_label->g_grid();
                                          $byear_label2->g_grid();
                                          $byear_cb->g_grid();
                                      }
                                  } else {
                                      $xmin_label->g_grid();
                                      $xmin_entry->g_grid();
                                      $xmax_label->g_grid();
                                      $xmax_entry->g_grid();
                                      $bdate_label->g_grid_remove();
                                      $bdate_frame->g_grid_remove();
                                      $edate_label->g_grid_remove();
                                      $edate_frame->g_grid_remove();
                                      $byear_label->g_grid();
                                      $byear_label2->g_grid();
                                      $byear_cb->g_grid();
                                  }
                                  if ($fmt !~ /^W2 /) {
                                      $tzoff_label->g_grid_remove();
                                      $offset_frame->g_grid_remove();
                                  } else {
                                      $tzoff_label->g_grid();
                                      $offset_frame->g_grid();
                                  }
                                }
                           );

    $row++;
    ($byear_label = $ts_frame->new_label(
            -text => "Base Year: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($byear_cb = $ts_frame->new_ttk__combobox(
            -textvariable => \$byear,
            -values       => [ reverse($yr_min .. $yr_max) ],
            -state        => 'readonly',
            -width        => 5,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $byear_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($byear == $yr_min) {
                                $yr_min -= 5;
                                $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                $byr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                                $eyr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                            }
                          }
                     );
    ($byear_label2 = $ts_frame->new_label(
            -text   => " for JDAY = 1.0",
            -anchor => 'w',
            -font   => 'default',
            ))->g_grid(-row => $row, -column => 2, -columnspan => 2, -sticky => 'w', -pady => 2);

    $row++;
    ($tzoff_label = $ts_frame->new_label(
            -text => "Time Offset: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($offset_frame = $ts_frame->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w');
    $offset_frame->new_ttk__combobox(
            -textvariable => \$tz_offset,
            -values       => [ @tz_offsets ],
            -justify      => 'right',
            -state        => 'readonly',
            -width        => 6,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $offset_frame->new_label(
            -text   => " time zone adjustment ",
            -anchor => 'w',
            -font   => 'default',
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $offset_frame->new_button(
            -text    => "Help",
            -command => sub { &pop_up_info($add_ts_graph_menu,
                                    "The time offset allows the user to add or subtract a time\n"
                                  . "offset if the W2 model was run with a non-local time zone.\n\n"
                                  . "For example, if W2 was run in UTC but the local time zone\n"
                                  . "is PST, an offset of -08:00 would convert the model date/time\n"
                                  . "to a local standard time of PST. This offset does not make\n"
                                  . "any adjustments related to daylight saving time. In general,\n"
                                  . "W2 is best run in the local standard time.\n\n"
                                  . "Leave the time offset at +00:00 for no adjustment.",
                                    "Time Offset Notice");
                            },
            )->g_pack(-side => 'left', -anchor => 'w', -padx => 2);

    $row++;
    ($bdate_label = $ts_frame->new_label(
            -text => "X Axis Start: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($bdate_frame = $ts_frame->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w');
    ($bmon_cb = $bdate_frame->new_ttk__combobox(
            -textvariable => \$bmon,
            -values       => [ @mon_names ],
            -state        => 'readonly',
            -width        => 4,
            ))->g_pack(-side => 'left');
    $bmon_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($byr);
                          $bm = &list_match($bmon, @mon_names);
                          $bday_cb->configure(-values => [ 1 .. $days_in_month[$bm] ]);
                          $bday = $days_in_month[$bm] if ($bday > $days_in_month[$bm]);
                        }
                    );
    $bdate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($bday_cb = $bdate_frame->new_ttk__combobox(
            -textvariable => \$bday,
            -values       => [ 1 .. $days_in_month[$bm] ],
            -state        => 'readonly',
            -width        => 3,
            ))->g_pack(-side => 'left');
    $bdate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($byr_cb = $bdate_frame->new_ttk__combobox(
            -textvariable => \$byr,
            -values       => [ reverse($yr_min .. $yr_max) ],
            -state        => 'readonly',
            -width        => 5,
            ))->g_pack(-side => 'left');
    $byr_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($byr);
                          $bm = &list_match($bmon, @mon_names);
                          if ($bm == 1) {
                              $bday_cb->configure(-values => [ 1 .. $days_in_month[$bm] ]);
                              $bday = $days_in_month[$bm] if ($bday > $days_in_month[$bm]);
                          }
                          if ($byr == $yr_min) {
                              $yr_min -= 5;
                              $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                              $byr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                              $eyr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                          }
                        }
                    );

    $row++;
    ($edate_label = $ts_frame->new_label(
            -text => "X Axis End: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($edate_frame = $ts_frame->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w');
    ($emon_cb = $edate_frame->new_ttk__combobox(
            -textvariable => \$emon,
            -values       => [ @mon_names ],
            -state        => 'readonly',
            -width        => 4,
            ))->g_pack(-side => 'left');
    $emon_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($eyr);
                          $em = &list_match($emon, @mon_names);
                          $eday_cb->configure(-values => [ 1 .. $days_in_month[$em] ]);
                          $eday = $days_in_month[$em] if ($eday > $days_in_month[$em]);
                        }
                    );
    $edate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($eday_cb = $edate_frame->new_ttk__combobox(
            -textvariable => \$eday,
            -values       => [ 1 .. $days_in_month[$em] ],
            -state        => 'readonly',
            -width        => 3,
            ))->g_pack(-side => 'left');
    $edate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($eyr_cb = $edate_frame->new_ttk__combobox(
            -textvariable => \$eyr,
            -values       => [ reverse($yr_min .. $yr_max) ],
            -state        => 'readonly',
            -width        => 5,
            ))->g_pack(-side => 'left');
    $eyr_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($eyr);
                          $em = &list_match($emon, @mon_names);
                          if ($em == 1) {
                              $eday_cb->configure(-values => [ 1 .. $days_in_month[$em] ]);
                              $eday = $days_in_month[$em] if ($eday > $days_in_month[$em]);
                          }
                          if ($eyr == $yr_min) {
                              $yr_min -= 5;
                              $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                              $byr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                              $eyr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                          }
                        }
                    );

    $row++;
    ($xmin_label = $ts_frame->new_label(
            -text => "X Axis Min: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($xmin_entry = $ts_frame->new_entry(
            -textvariable => \$xmin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $xmin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $xmin_entry ]);

    $row++;
    ($xmax_label = $ts_frame->new_label(
            -text => "X Axis Max: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($xmax_entry = $ts_frame->new_entry(
            -textvariable => \$xmax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $xmax_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $xmax_entry ]);

    $row++;
    $ts_frame->new_label(
            -text => "Line Width: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $ts_frame->new_spinbox(
            -textvariable => \$width,
            -state        => 'readonly',
            -font         => 'default',
            -from         => 1,
            -to           => 10,
            -increment    => 1,
            -width        => 3,
            )->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    $row++;
    $ts_frame->new_label(
            -text => "Line Color: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $code  = &get_rgb_code($color);
    $color = &get_rgb_name($code);
    $fg    = &get_rgb_code("black");
    if ($code =~ /^\#[0-9a-f]/i) {
        $fg = &get_rgb_code(&get_bw_contrast($code));
    }
    ($color_btn = $ts_frame->new_button(
            -textvariable => \$color,
            -background   => $code,
            -foreground   => $fg,
            -width        => -7,
            -command => sub { my ($newc, $code, $fg);
                              $code = &get_rgb_code($color);
                              $newc = Tkx::tk___chooseColor(
                                         -initialcolor => $code,
                                         -parent       => $add_ts_graph_menu);
                              if ($newc) {
                                  $code  = &get_rgb_code($newc);
                                  $color = &get_rgb_name($code);
                                  $fg    = &get_rgb_code("black");
                                  if ($code =~ /^#?[0-9a-f]/i) {
                                      $fg = &get_rgb_code(&get_bw_contrast($code));
                                  }
                                  $color_btn->configure(-foreground => $fg,
                                                        -background => $code);
                              }
                            }
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w', -pady => 2);

    $row++;
    $ts_frame->new_label(
            -text => "Legend Entry: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $ts_frame->new_entry(
            -textvariable => \$legend_txt,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'ew', -pady => 2);

    $xmin_label->g_grid_remove();
    $xmin_entry->g_grid_remove();
    $xmax_label->g_grid_remove();
    $xmax_entry->g_grid_remove();
    if ($fmt !~ /^W2 /) {
        $byear_label->g_grid_remove();
        $byear_label2->g_grid_remove();
        $byear_cb->g_grid_remove();
        $tzoff_label->g_grid_remove();
        $offset_frame->g_grid_remove();
    }
    if ($fmt ne "W2 Heat Fluxes format" && $fmt ne "W2 Water Level (wl) format"
                                        && $fmt !~ /^W2 .*daily .*Temp2?\.dat format$/i) {
        $segnum_label->g_grid_remove();
        $segnum_cb->g_grid_remove();
    }
    if ($fmt eq "W2 Water Level (wl) format") {
        $parm_cb->g_grid_remove();
        $parm_label->g_grid();
    }
    if ($conv_type ne "Custom") {
        $custom_frame->g_grid_remove();
    }
    $ts_frame->g_grid_columnconfigure(3, -weight => 2);

    Tkx::wm_resizable($add_ts_graph_menu,0,0);
    &adjust_window_position($add_ts_graph_menu);
    $add_ts_graph_menu->g_focus;
}


sub add_ref_data {
    my ($canv, $id, $X, $Y) = @_;
    my (
        $code, $color_btn, $conv_add, $conv_add_entry, $conv_mult,
        $conv_mult_entry, $conv_type, $conv_type_cb, $conv_type_label,
        $custom_frame, $data_parm, $data_parm_label, $f, $fg, $frame, $geom,
        $ok_btn, $ref_color, $ref_file, $ref_tol, $row, $tol_frame, $txt,
        $txt_chars, $x1, $x2, $y1, $y2,
        );

    &end_select($canv, $id, 1);

    ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $geom = sprintf("+%d+%d", $X+$x1+50, $Y+$y1+60);

    if (defined($add_ref_data_menu) && Tkx::winfo_exists($add_ref_data_menu)) {
        if ($add_ref_data_menu->g_wm_title() eq "Add Reference Profile Data") {
            $add_ref_data_menu->g_destroy();
            undef $add_ref_data_menu;
        }
    }
    $add_ref_data_menu = $main->new_toplevel();
    $add_ref_data_menu->g_wm_transient($main);
    $add_ref_data_menu->g_wm_title("Add Reference Profile Data");
    $add_ref_data_menu->configure(-cursor => $cursor_norm);
    $add_ref_data_menu->g_wm_geometry($geom);

#   Try to keep the nascent graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

    $ref_file = "";
    if ($props{$id}{parm} eq "Temperature") {
        $txt = "Temperature, in degrees " . $props{$id}{parm_units};
    } else {
        $txt = $props{$id}{parm} . ", in " . $props{$id}{parm_units};
    }
    $txt_chars = &max(25, length($txt));
    $data_parm = "";
    $ref_tol   = 10;
    $ref_color = "black";

#   Conversion types and factors (@conv_types is global)
    $conv_type = $conv_types[0];
    $conv_mult = 1.0;
    $conv_add  = 0.0;

#   Create input menu
    $frame = $add_ref_data_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -state   => 'disabled',
            -command => sub { if ($ref_file eq "" || ! -e $ref_file) {
                                  return &pop_up_error($add_ref_data_menu,
                                  "Reference data file not set or does not exist:\n$ref_file");
                              }
                              if ($conv_type eq "Custom") {
                                  $conv_type = sprintf("Custom,%s,%s", $conv_mult, $conv_add);
                              }
                              $add_ref_data_menu->g_bind('<Destroy>', "");
                              $add_ref_data_menu->g_destroy();
                              undef $add_ref_data_menu;
                              &reset_bindings;

                              $props{$id}{ref_file}  = $ref_file;
                              $props{$id}{ref_ctype} = $conv_type;
                              $props{$id}{ref_tol}   = $ref_tol;
                              $props{$id}{ref_color} = $ref_color;
                              $props{$id}{ref_hide}  = 0;

                              &plot_ref_profile($canv, $id, 1);
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $add_ref_data_menu->g_bind('<Destroy>', "");
                              $add_ref_data_menu->g_destroy();
                              undef $add_ref_data_menu;
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Clean up if this menu is destroyed by other than the Cancel button
    $add_ref_data_menu->g_bind('<Destroy>' => sub { undef $add_ref_data_menu;
                                                    &reset_bindings;
                                                  });

    ($f = $add_ref_data_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "Please provide a reference data file with measured profiles.",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -columnspan => 4, -sticky => 'w');

    $row++;
    $f->new_label(
            -text => "Model Parameter: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $f->new_label(
            -text   => $txt,
            -font   => 'default',
            -anchor => 'w',
            -width  => $txt_chars,
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');

    $row++;
    $f->new_label(
            -text => "Profile Data File: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_label(
            -textvariable => \$ref_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
    $f->new_button(
            -text    => "Browse",
            -command => sub { my ($file, $i, $status, $str, %meta);
                              $file = Tkx::tk___getOpenFile(
                                      -parent           => $add_ref_data_menu,
                                      -title            => "Select Reference Profile File",
                                      -initialdir       => abs_path(),
                                      -filetypes => [ ['CSV (comma delimited)', '.csv'],
                                                      ['All Files',  '*'],
                                                    ],
                                      );
                              if (defined($file) && -e $file) {
                                  $ref_file = File::Spec->rel2abs($file);
                                  ($status, %meta) = &scan_profile($add_ref_data_menu, $ref_file);
                                  if ($status ne "okay") {
                                      $ref_file = "";
                                      $ok_btn->configure(-state => 'disabled');
                                      return &pop_up_error($add_ref_data_menu,
                                            "Specified file is not a profile data file "
                                          . "or is incomplete:\n$file");
                                  }
                                  if (lc($meta{parm}) ne lc($props{$id}{parm})) {
                                      $ref_file = "";
                                      $ok_btn->configure(-state => 'disabled');
                                      return &pop_up_error($add_ref_data_menu,
                                            "Parameter name from the profile data file\n("
                                          . $meta{parm} . ") does not match the expected\n"
                                          . "parameter (" . $props{$id}{parm} . ").");
                                  } 
                                  $conv_type = "None";
                                  $custom_frame->g_grid_remove();
                                  if ($meta{parm} eq "Temperature") {
                                      $conv_type_label->g_grid();
                                      $conv_type_cb->g_grid_remove();
                                      $data_parm = $meta{parm};
                                  } else {
                                      $conv_type_label->g_grid_remove();
                                      $conv_type_cb->g_grid();
                                      $data_parm = $meta{parm} . ", in " . $meta{parm_units};
                                      if (lc($props{$id}{parm_units}) ne lc($meta{parm_units})
                                           && &list_search($meta{parm_units}, @conv_types) >= 0
                                           && &list_search($props{$id}{parm_units}, @conv_types) >= 0) {
                                          $str = $meta{parm_units} . " to " . $props{$id}{parm_units};
                                          $i   = &list_match($str, @conv_types);
                                          $conv_type = $conv_types[$i] if ($i >= 0);
                                      }
                                  }
                                  $ok_btn->configure(-state => 'normal');
                              } else {
                                  $ref_file  = "";
                                  $conv_type = "None";
                                  $custom_frame->g_grid_remove();
                                  $ok_btn->configure(-state => 'disabled');
                              }
                            },
            )->g_grid(-row => $row, -column => 3, -sticky => 'ew', -padx => 2, -pady => 2);

    $row++;
    $f->new_label(
            -text => "Data Parameter: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    ($data_parm_label = $f->new_label(
            -textvariable => \$data_parm,
            -anchor       => 'w',
            -font         => 'default',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');

    $row++;
    $f->new_label(
            -text => "Conversion: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($conv_type_label = $f->new_label(
            -text => "none necessary",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $conv_type_label->g_grid_remove();
    ($conv_type_cb = $f->new_ttk__combobox(
            -textvariable => \$conv_type,
            -values       => [ @conv_types ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $conv_type_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($conv_type eq "Custom") {
                                $custom_frame->g_grid();
                            } else {
                                $custom_frame->g_grid_remove();
                            }
                          }
                      );
    $row++;
    ($custom_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $custom_frame->new_label(
            -text => "Multiply by: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_mult_entry = $custom_frame->new_entry(
            -textvariable => \$conv_mult,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_mult_entry->g_bind("<KeyRelease>",
                              sub { &numeric_entry_only($conv_mult_entry);
                                    my $chars = &max(7, length($conv_mult));
                                    $conv_mult_entry->configure(-width => $chars);
                                  });
    $custom_frame->new_label(
            -text => "  Then add: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_add_entry = $custom_frame->new_entry(
            -textvariable => \$conv_add,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_add_entry->g_bind("<KeyRelease>",
                             sub { &numeric_entry_only($conv_add_entry);
                                   my $chars = &max(7, length($conv_add));
                                   $conv_add_entry->configure(-width => $chars);
                                 });

    $row++;
    $f->new_label(
            -text => "Match Tolerance: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($tol_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $tol_frame->new_spinbox(
            -textvariable => \$ref_tol,
            -state        => 'readonly',
            -font         => 'default',
            -from         => 0,
            -to           => 180,
            -increment    => 1,
            -width        => 4,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $tol_frame->new_label(
            -text => " minutes",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');

    $row++;
    $f->new_label(
            -text => "Line Color: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);

    $code      = &get_rgb_code($ref_color);
    $ref_color = &get_rgb_name($code);
    $fg        = &get_rgb_code("black");
    if ($code =~ /^\#[0-9a-f]/i) {
        $fg = &get_rgb_code(&get_bw_contrast($code));
    }
    ($color_btn = $f->new_button(
               -textvariable => \$ref_color,
               -background   => $code,
               -foreground   => $fg,
               -width        => -7,
               -command => sub { my ($newc, $code, $fg);
                                 $code = &get_rgb_code($ref_color);
                                 $newc = Tkx::tk___chooseColor(
                                            -initialcolor => $code,
                                            -parent       => $add_ref_data_menu);
                                 if ($newc) {
                                   $code      = &get_rgb_code($newc);
                                   $ref_color = &get_rgb_name($code);
                                   $fg        = &get_rgb_code("black");
                                   if ($code =~ /^\#[0-9a-f]/i) {
                                       $fg = &get_rgb_code(&get_bw_contrast($code));
                                   }
                                   $color_btn->configure(-foreground => $fg,
                                                         -background => $code);
                                 }
                               }
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);

    if ($conv_type ne "Custom") {
        $custom_frame->g_grid_remove();
    }
    $f->g_grid_columnconfigure(2, -weight => 2);

    Tkx::wm_resizable($add_ref_data_menu,0,0);
    &adjust_window_position($add_ref_data_menu);
    $add_ref_data_menu->g_focus;
}


sub plot_ref_profile {
    my ($canv, $id, $new) = @_;
    my (
        $cs_max, $cs_min, $data_daily, $dt, $dt_ref, $dt_ref2, $found,
        $got_depth, $gtag, $i, $j, $lastpt, $mi, $mult, $np, $pt1_in,
        $pt2_in, $ref_ctype, $ref_daily, $status, $surf_elev, $tol, $val,
        $x1, $x2, $xmax, $xmin, $xp, $xp1, $xp2, $y1, $y2, $ymax, $ymin,
        $yp, $yp1, $yp2, $yrange, $ytype, $yunits,

        @colors, @coords, @depths, @elevations, @estimated, @items,
        @keys_ref, @pdata, @pt_color, @pt_elevations, @valid_elevs,
        @valid_pdata,

        %elev_data, %ref_data, %ref_profile, %wsurf,
       );

    ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
    $gtag = "graph" . $id;
    $tol  = $props{$id}{ref_tol};

    if ($new) {
        %ref_profile = &read_profile($main, $props{$id}{ref_file});
        %ref_data    = %{ $ref_profile{pdata} };
        $ref_ctype   = $props{$id}{ref_ctype};

        if (&list_match($ref_ctype, @conv_types) > 0 || $ref_ctype =~ /^Custom,/) {
            %ref_data = &convert_timeseries($main, $ref_ctype, 1, %ref_data);
            $ref_profile{pdata} = { %ref_data };
        }
        $gr_props{$id}{ref_data} = { %ref_profile };
    } else {
        %ref_profile = %{ $gr_props{$id}{ref_data} };
        %ref_data    = %{ $ref_profile{pdata}      };
    }

#   Get the modeled water-surface elevation, just in case it is needed
    %elev_data = %{ $gr_props{$id}{elev_data} };

#   Set the date and see if a match exists in the reference data profile
    $dt = $dates[$dti-1];
    @keys_ref   = keys %ref_data;
    $data_daily = (length($dt)          == 12) ? 0 : 1;
    $ref_daily  = (length($keys_ref[0]) == 12) ? 0 : 1;

    $dt_ref = $dt;
    if ($data_daily != $ref_daily) {
        if ($ref_daily) {
            $dt_ref = &nearest_daily_dt($dt);
            return if (&get_dt_diff($dt, 10000 *$dt_ref) > $tol || ! defined($ref_data{$dt_ref}));
        } else {
            $dt_ref .= "0000";
        }
    }
    if (! defined($ref_data{$dt_ref})) {
        return if (($data_daily && $ref_daily) || $tol == 0);
        $found = 0;
        for ($mi=1; $mi<=$tol; $mi++) {
            $dt_ref2 = &adjust_dt($dt_ref, $mi);
            if (defined($ref_data{$dt_ref2})) {
                $dt_ref = $dt_ref2;
                $found  = 1;
                last;
            }
            $dt_ref2 = &adjust_dt($dt_ref, -1 *$mi);
            if (defined($ref_data{$dt_ref2})) {
                $dt_ref = $dt_ref2;
                $found  = 1;
                last;
            }
        }
        return if (! $found);
    }

#   Get some graph parameters
    if ($gr_props{$id}{add_cs}) {
        $cs_min = $gr_props{$id}{cs_min};
        $cs_max = $gr_props{$id}{cs_max};
        @colors = @{ $gr_props{$id}{colors} };
    }
    $status = ($props{$id}{ref_hide}) ? 'hidden' : 'normal';
    $ytype  = $gr_props{$id}{ytype};
    $yunits = $gr_props{$id}{yunits};
    $mult   = ($yunits eq "feet") ? 3.28084 : 1.0;
    $ymin   = $gr_props{$id}{ymin} /$mult;
    $ymax   = $gr_props{$id}{ymax} /$mult;
    $yrange = $ymax -$ymin;
    $xmin   = $gr_props{$id}{xmin};
    $xmax   = $gr_props{$id}{xmax};

#   Set some variables and populate some arrays and hashes
    %wsurf     = %{ $ref_profile{ws_elev}   };
    @estimated = @{ $ref_profile{estimated} };
    $got_depth = ($ref_profile{elv_dep} eq "elevation") ? 0 : 1;
    if ($got_depth) {
        @depths     = @{ $ref_profile{depths} };
    } else {
        @elevations = @{ $ref_profile{elevations} };
    }
    $surf_elev = ($wsurf{$dt_ref} ne "na") ? $wsurf{$dt_ref} : $elev_data{$dt};
    $lastpt    = ($got_depth) ? $#depths : $#elevations;
    @pt_elevations = ();
    for ($i=0; $i<=$lastpt; $i++) {
        if ($got_depth) {
            push (@pt_elevations, $surf_elev -$depths[$i]);
        } else {
            push (@pt_elevations, $elevations[$i]);
        }
    }
    undef %wsurf;
    undef %elev_data;

#   Translate the data to the graph coordinates
    @pdata = @{ $ref_data{$dt_ref} };
    if ($ref_profile{parm} eq "Temperature" && $props{$id}{parm_units} eq "Fahrenheit") {
        for ($i=0; $i<=$lastpt; $i++) {
            next if ($pdata[$i] eq "na");
            $pdata[$i] = $pdata[$i] *1.8 +32;
        }
    }
    @coords   = @valid_pdata = ();
    @pt_color = @valid_elevs = ();
    for ($i=0; $i<=$lastpt; $i++) {
        next if ($pdata[$i] eq "na");
        next if ($pt_elevations[$i] > $surf_elev +0.1/3.28084);
        $xp = $x1 +($x2-$x1)*($pdata[$i]-$xmin)/($xmax-$xmin);
        if ($ytype eq "Depth") {
            $yp = $y1 +($y2-$y1)*($surf_elev-$pt_elevations[$i])/$ymax;
        } else {
            $yp = $y2 -($y2-$y1)*($pt_elevations[$i]-$ymin)/$yrange;
        }
        push (@coords, $xp, $yp);
        push (@valid_pdata, $pdata[$i]);
        push (@valid_elevs, $pt_elevations[$i]);
        if ($estimated[$i]) {
            push (@pt_color, "DarkGray");
        } else {
            push (@pt_color, $props{$id}{ref_color});
        }
    }
    $np = ($#coords +1)/2;

#   Plot the measured vertical profile
    if ($np > 1) {
        for ($i=1; $i<$np; $i++) {
            $xp1 = $coords[2*$i-2];
            $yp1 = $coords[2*$i-1];
            $xp2 = $coords[2*$i];
            $yp2 = $coords[2*$i+1];
            $pt1_in = ($xp1 >= $x1 && $xp1 <= $x2 &&
                       $yp1 >= $y1 && $yp1 <= $y2) ? 1 : 0;
            $pt2_in = ($xp2 >= $x1 && $xp2 <= $x2 &&
                       $yp2 >= $y1 && $yp2 <= $y2) ? 1 : 0;
            next if (! $pt1_in && ! $pt2_in);
            if (! $pt1_in) {
                if ($xp1 < $x1) {
                    $yp = $yp1 +($yp2-$yp1) *($x1-$xp1) /($xp2-$xp1);
                    $xp = $x1;
                } elsif ($xp1 > $x2) {
                    $yp = $yp1 +($yp2-$yp1) *($x2-$xp1) /($xp2-$xp1);
                    $xp = $x2;
                } else {
                    $xp = $xp1 +($xp2-$xp1) *($y1-$yp1) /($yp2-$yp1);
                    $yp = $y1;
                }
                if ($yp < $y1) {
                    $xp = $xp1 +($xp2-$xp1) *($y1-$yp1) /($yp2-$yp1);
                    $yp = $y1;
                }
                $xp1 = $xp;
                $yp1 = $yp;
            } elsif (! $pt2_in) {
                if ($xp2 < $x1) {
                    $yp = $yp1 +($yp2-$yp1) *($x1-$xp1) /($xp2-$xp1);
                    $xp = $x1;
                } elsif ($xp2 > $x2) {
                    $yp = $yp1 +($yp2-$yp1) *($x2-$xp1) /($xp2-$xp1);
                    $xp = $x2;
                } else {
                    $xp = $xp1 +($xp2-$xp1) *($y2-$yp1) /($yp2-$yp1);
                    $yp = $y2;
                }
                if ($yp > $y2) {
                    $xp = $xp1 +($xp2-$xp1) *($y2-$yp1) /($yp2-$yp1);
                    $yp = $y2;
                }
                $xp2 = $xp;
                $yp2 = $yp;
            }
            $canv->create_line($xp1, $yp1, $xp2, $yp2,
                                    -fill  => &get_rgb_code($pt_color[$i]),
                                    -width => 1,
                                    -arrow => 'none',
                                    -state => $status,
                                    -tags  => $gtag . " " . $gtag . "_refData");
        }
    }

#   Plot the measured points
    for ($i=0; $i<$np; $i++) {
        $xp = $coords[2*$i];
        $yp = $coords[2*$i+1];
        if ($xp >= $x1 && $xp <= $x2 && $yp >= $y1 && $yp <= $y2) {
            if ($gr_props{$id}{add_cs}) {
                $val = $valid_pdata[$i];
                $j   = int(($#colors+1) *($val-$cs_min)/($cs_max-$cs_min));
                $j   = &max(0, &min($#colors, $j));
                $canv->create_oval($xp-3, $yp-3, $xp+3, $yp+3,
                                    -outline => &get_rgb_code($pt_color[$i]),
                                    -width   => 1,
                                    -fill    => $colors[$j],
                                    -state   => $status,
                                    -tags    => $gtag . " " . $gtag . "_refData");
            } else {
                $canv->create_oval($xp-3, $yp-3, $xp+3, $yp+3,
                                    -outline => &get_rgb_code($pt_color[$i]),
                                    -width   => 1,
                                    -fill    => &get_rgb_code("white"),
                                    -state   => $status,
                                    -tags    => $gtag . " " . $gtag . "_refData");
            }
        }
    }
    @items = Tkx::SplitList($canv->find_withtag($gtag . "_profile"));
    if ($#items >= 0) {
        $canv->raise($gtag . "_refData", $gtag . "_profile");
    }
}


################################################################################
#
#  Statistics and Differences
#
################################################################################

sub convert_to_diffs {
    my ($canv, $id, $X, $Y) = @_;
    my (
        $byear, $byear_cb, $byear_label1, $byear_label2, $conv_add,
        $conv_add_entry, $conv_mult, $conv_mult_entry, $conv_type,
        $conv_type_cb, $conv_type_label, $custom_frame, $diff_major,
        $diff_major_entry, $diff_max, $diff_max_entry, $diff_min,
        $diff_min_entry, $f, $frame, $geom, $offset_frame, $old_ref_type,
        $ok_btn, $parm_label, $ref_file, $ref_file_btn, $ref_file_label1,
        $ref_file_label2, $ref_ftype, $ref_lines, $ref_parm, $ref_parm_cb,
        $ref_parm_label1, $ref_parm_label2, $ref_tol, $ref_type,
        $ref_type_cb, $ref_val, $ref_val_entry, $ref_val_label, $row,
        $temp_msg_label, $title, $title_txt, $tol_frame, $tol_label, $txt,
        $txt_chars, $tz_offset, $tzoff_label, $units, $yr_max, $yr_min,

        @all_fmts, @fmt_grp1, @fmt_grp2, @parmlist,
       );

    &end_select($canv, $id, 1);
    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($convert_diff_menu) && Tkx::winfo_exists($convert_diff_menu)) {
        if ($convert_diff_menu->g_wm_title() eq "Convert to Difference") {
            $convert_diff_menu->g_destroy();
            undef $convert_diff_menu;
        }
    }
    $convert_diff_menu = $main->new_toplevel();
    $convert_diff_menu->g_wm_transient($main);
    $convert_diff_menu->g_wm_title("Convert to Difference");
    $convert_diff_menu->configure(-cursor => $cursor_norm);
    $convert_diff_menu->g_wm_geometry($geom);

#   Try to keep the nascent graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

    $ref_type  = "Constant";
    $ref_val   = $ref_lines = 0;
    $ref_file  = $ref_ftype = $ref_parm = "";
    $ref_tol   = 10;
    $yr_max    = (localtime(time))[5] +1900;
    $yr_min    = $yr_max -25;
    $byear     = $yr_max;
    $tz_offset = "+00:00";
    @parmlist  = ();

    $parmlist[0]  = $ref_parm;
    $old_ref_type = $ref_type;

    if ($props{$id}{meta} eq "data_profile") {
        $diff_min   = $gr_props{$id}{xmin};
        $diff_max   = $gr_props{$id}{xmax};
        $diff_major = $gr_props{$id}{xmajor};
        $title      = $gr_props{$id}{xtitle};
    } else {
        $diff_min   = $gr_props{$id}{cs_min};
        $diff_max   = $gr_props{$id}{cs_max};
        $title      = $gr_props{$id}{keytitle};
    }
    if ($props{$id}{parm} eq "Temperature") {
        $title =~ s/Temperature/Temperature Difference/;
        $title =~ s/temperature/temperature difference/;
        $txt   = "Temperature Difference, in degrees " . $props{$id}{parm_units};
        $units = "\N{U+00B0}" . substr($props{$id}{parm_units},0,1);
    } else {
        $title =~ s/$props{$id}{parm}/$props{$id}{parm} Difference/;
        $txt   = $props{$id}{parm} . " Difference, in " . $props{$id}{parm_units};
        $units = $props{$id}{parm_units};
    }
    $txt_chars = &max(25, length($txt));

#   Accepted file types
    @fmt_grp1 = ("USGS getData format",
                 "Aquarius Time-Series format",
                 "Dataquery format",
                 "USGS Water Services format",
                 "USGS Data Grapher format",
                 "CSV format",
                );
    @fmt_grp2 = ("W2 TSR format",
                 "W2 Outflow CSV format",
                 "W2 CSV format",
                 "W2 column format",
                );
    @all_fmts = (@fmt_grp1, @fmt_grp2);

#   Conversion types and factors (@conv_types is global)
    $conv_type = $conv_types[0];
    $conv_mult = 1.0;
    $conv_add  = 0.0;

#   Create input menu
    $frame = $convert_diff_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -command => sub { my ($tabid);
                              if ($ref_type =~ /Time-Series/i &&
                                  ($ref_file eq "" || ! -e $ref_file)) {
                                  return &pop_up_error($convert_diff_menu,
                                  "Reference time-series file not set or does not exist:\n$ref_file");
                              }
                              if ($diff_min eq "" || $diff_max eq "") {
                                  return &pop_up_error($convert_diff_menu,
                                  "Please provide both a minimum and maximum value.");
                              }
                              if ($diff_min >= $diff_max) {
                                  return &pop_up_error($convert_diff_menu,
                                  "The minimum value must be less than the maximum value.");
                              }
                              if ($conv_type eq "Custom") {
                                  $conv_type = sprintf("Custom,%s,%s", $conv_mult, $conv_add);
                              }
                              $props{$id}{dref_type}  = $ref_type;
                              $props{$id}{dref_val}   = $ref_val;
                              $props{$id}{dref_file}  = $ref_file;
                              $props{$id}{dref_ftype} = $ref_ftype;
                              $props{$id}{dref_lines} = $ref_lines;
                              $props{$id}{dref_parm}  = $ref_parm;
                              $props{$id}{dref_byear} = $byear;
                              $props{$id}{dref_tzoff} = $tz_offset;
                              $props{$id}{dref_ctype} = $conv_type;
                              $props{$id}{dref_tol}   = $ref_tol;
                              $props{$id}{prof_type}  = "difference";

                              if ($props{$id}{meta} eq "data_profile") {
                                  $gr_props{$id}{orig_xmin}   = $gr_props{$id}{xmin};
                                  $gr_props{$id}{orig_xmax}   = $gr_props{$id}{xmax};
                                  $gr_props{$id}{orig_xmajor} = $gr_props{$id}{xmajor};
                                  $gr_props{$id}{orig_xtitle} = $gr_props{$id}{xtitle};
                                  $gr_props{$id}{xmin}   = $diff_min;
                                  $gr_props{$id}{xmax}   = $diff_max;
                                  $gr_props{$id}{xmajor} = $diff_major;
                                  $gr_props{$id}{xtitle} = $title;
                              }
                              $gr_props{$id}{orig_cs_min}   = $gr_props{$id}{cs_min};
                              $gr_props{$id}{orig_cs_max}   = $gr_props{$id}{cs_max};
                              $gr_props{$id}{orig_keytitle} = $gr_props{$id}{keytitle};
                              $gr_props{$id}{cs_min}   = $diff_min;
                              $gr_props{$id}{cs_max}   = $diff_max;
                              $gr_props{$id}{cs_major} = "auto";
                              $gr_props{$id}{keytitle} = $title;
                              $gr_props{$id}{redraw}   = 1;

                              $convert_diff_menu->g_bind('<Destroy>', "");
                              $convert_diff_menu->g_destroy();
                              undef $convert_diff_menu;
                              &reset_bindings;

                              &calculate_diffs($id);
                              &make_data_profile($canv, $id, 1);

#                             Refresh the Graph Properties menu, if present
                              if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
                                  if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
                                      $tabid = $grprops_notebook->index('current');
                                      $geom  = $graph_props_menu->g_wm_geometry();
                                      (undef, $X, $Y) = split(/\+/, $geom);
                                      &edit_graph_props($id, $X, $Y, $tabid);
                                  }
                              }

#                             Refresh the Object Information box, if present
                              if (defined($object_infobox) && Tkx::winfo_exists($object_infobox)) {
                                  if ($object_infobox->g_wm_title() eq "Object Info") {
                                      $geom = $object_infobox->g_wm_geometry();
                                      (undef, $X, $Y) = split(/\+/, $geom);
                                      &show_info($canv, $id, $X, $Y);
                                  }
                              }
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $convert_diff_menu->g_bind('<Destroy>', "");
                              $convert_diff_menu->g_destroy();
                              undef $convert_diff_menu;
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Clean up if this menu is destroyed by other than the Cancel button
    $convert_diff_menu->g_bind('<Destroy>' => sub { undef $convert_diff_menu;
                                                    &reset_bindings;
                                                  });

    ($f = $convert_diff_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "Please provide a constant or time-series as the basis for a difference.",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -columnspan => 4, -sticky => 'w');

    $row++;
    $f->new_label(
            -text => "Reference Type: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ref_type_cb = $f->new_ttk__combobox(
            -textvariable => \$ref_type,
            -values       => [ ("Constant", "Time-Series") ],
            -width        => 12,
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $ref_type_cb->g_bind("<<ComboboxSelected>>",
                          sub { return if ($ref_type eq $old_ref_type);
                                $old_ref_type = $ref_type;
                                $ok_btn->configure(-state => 'normal');
                                if ($ref_type =~ /Constant/i) {
                                    $ref_val_label->g_grid();
                                    $ref_val_entry->g_grid();
                                    $ref_file_label1->g_grid_remove();
                                    $ref_file_label2->g_grid_remove();
                                    $ref_file_btn->g_grid_remove();
                                    $ref_parm_label1->g_grid_remove();
                                    $ref_parm_label2->g_grid_remove();
                                    $ref_parm_cb->g_grid_remove();
                                    $temp_msg_label->g_grid_remove();
                                    $conv_type_label->g_grid_remove();
                                    $conv_type_cb->g_grid_remove();
                                    $custom_frame->g_grid_remove();
                                    $tol_label->g_grid_remove();
                                    $tol_frame->g_grid_remove();
                                    $byear_label1->g_grid_remove();
                                    $byear_label2->g_grid_remove();
                                    $byear_cb->g_grid_remove();
                                    $tzoff_label->g_grid_remove();
                                    $offset_frame->g_grid_remove();
                                    if ($props{$id}{parm} eq "Temperature") {
                                        $txt = "Temperature Difference, in degrees "
                                             . $props{$id}{parm_units};
                                    } else {
                                        $txt = $props{$id}{parm} . " Difference, in "
                                             . $props{$id}{parm_units};
                                    }
                                    $txt_chars = &max(25, length($txt));
                                    $parm_label->configure(-text => $txt, -width => $txt_chars);
                                } else {
                                    $ref_val_label->g_grid_remove();
                                    $ref_val_entry->g_grid_remove();
                                    $ref_file_label1->g_grid();
                                    $ref_file_label2->g_grid();
                                    $ref_file_btn->g_grid();
                                    $ref_parm_label1->g_grid();
                                    if ($#parmlist == 0) {
                                        $ref_parm_label2->g_grid();
                                    } else {
                                        $ref_parm_cb->g_grid();
                                    }
                                    if ($ref_parm =~ /Temperature/i) {
                                        $temp_msg_label->g_grid();
                                    } else {
                                        $temp_msg_label->g_grid_remove();
                                    }
                                    $conv_type_label->g_grid();
                                    $conv_type_cb->g_grid();
                                    $custom_frame->g_grid() if ($conv_type ne "None");
                                    $tol_label->g_grid();
                                    $tol_frame->g_grid();
                                    if ($ref_ftype =~ /^W2 /) {
                                        $byear_label1->g_grid();
                                        $byear_label2->g_grid();
                                        $byear_cb->g_grid();
                                        $tzoff_label->g_grid();
                                        $offset_frame->g_grid();
                                    }
                                    if ($props{$id}{parm} eq "Temperature") {
                                        $txt = "Temperature, in degrees " . $props{$id}{parm_units};
                                    } else {
                                        $txt = $props{$id}{parm} . ", in " . $props{$id}{parm_units};
                                    }
                                    $txt_chars = &max(25, length($txt));
                                    $parm_label->configure(-text => $txt, -width => $txt_chars);
                                    if ($ref_file eq "" || ! -e $ref_file) {
                                        $ok_btn->configure(-state => 'disabled');
                                    }
                                }
                              });

    $row++;
    ($ref_val_label = $f->new_label(
            -text => "Reference Value: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ref_val_entry = $f->new_entry(
            -textvariable => \$ref_val,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $ref_val_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $ref_val_entry ]);

    $row++;
    $f->new_label(
            -text => "Data Parameter: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    ($parm_label = $f->new_label(
            -text   => $txt,
            -font   => 'default',
            -anchor => 'w',
            -width  => $txt_chars,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');

    $row++;
    ($ref_file_label1 = $f->new_label(
            -text => "Reference Data File: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ref_file_label2 = $f->new_label(
            -textvariable => \$ref_file,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);
    ($ref_file_btn = $f->new_button(
            -text    => "Browse",
            -command => sub { my ($file);
                              $ok_btn->configure(-state => 'disabled');
                              $file = Tkx::tk___getOpenFile(
                                      -parent           => $convert_diff_menu,
                                      -title            => "Select Reference Time-Series",
                                      -initialdir       => abs_path(),
                                      -filetypes => [ ['All Files',  '*'],
                                                      ['CSV (comma delimited)', '.csv'],
                                                      ['NPT (W2 input file)', '.npt'],
                                                    ],
                                      );
                              if (defined($file) && -e $file) {
                                  $ref_file = File::Spec->rel2abs($file);
                                  ($ref_ftype, $ref_lines, @parmlist)
                                      = &determine_ts_type($convert_diff_menu, $ref_file);
                                  if (&list_match($ref_ftype, @all_fmts) == -1) {
                                      $ref_file = $ref_ftype = $ref_parm = "";
                                      $ref_lines   = 0;
                                      @parmlist    = ();
                                      $parmlist[0] = $ref_parm;
                                      $ref_parm_label2->g_grid();
                                      $ref_parm_cb->g_grid_remove();
                                      $byear_label1->g_grid_remove();
                                      $byear_label2->g_grid_remove();
                                      $byear_cb->g_grid_remove();
                                      $tzoff_label->g_grid_remove();
                                      $offset_frame->g_grid_remove();
                                      return &pop_up_error($convert_diff_menu,
                                            "Specified file format is not recognized "
                                          . "or is not honored:\n$file");
                                  }
                                  $ref_parm = $parmlist[0];
                                  if ($#parmlist > 0) {
                                      $ref_parm_label2->g_grid_remove();
                                      $ref_parm_cb->g_grid();
                                      $ref_parm_cb->configure(-values => [ @parmlist ]);
                                  } else {
                                      $ref_parm_label2->g_grid();
                                      $ref_parm_cb->g_grid_remove();
                                  }
                                  if ($ref_parm =~ /Temperature/i) {
                                      $temp_msg_label->g_grid();
                                  } else {
                                      $temp_msg_label->g_grid_remove();
                                  }
                                  $conv_type = "None";
                                  $custom_frame->g_grid_remove();

                                  if ($ref_ftype =~ /^W2 /) {
                                      $byear_label1->g_grid();
                                      $byear_label2->g_grid();
                                      $byear_cb->g_grid();
                                      $tzoff_label->g_grid();
                                      $offset_frame->g_grid();
                                  } else {
                                      $byear_label1->g_grid_remove();
                                      $byear_label2->g_grid_remove();
                                      $byear_cb->g_grid_remove();
                                      $tzoff_label->g_grid_remove();
                                      $offset_frame->g_grid_remove();
                                  }
                                  $ok_btn->configure(-state => 'normal');
                              } else {
                                  $ref_file = $ref_ftype = $ref_parm = "";
                                  $ref_lines   = 0;
                                  @parmlist    = ();
                                  $parmlist[0] = $ref_parm;
                                  $conv_type   = "None";
                                  $custom_frame->g_grid_remove();
                                  $ref_parm_label2->g_grid();
                                  $ref_parm_cb->g_grid_remove();
                                  $byear_label1->g_grid_remove();
                                  $byear_label2->g_grid_remove();
                                  $byear_cb->g_grid_remove();
                                  $tzoff_label->g_grid_remove();
                                  $offset_frame->g_grid_remove();
                              }
                            },
            ))->g_grid(-row => $row, -column => 3, -sticky => 'ew', -padx => 2, -pady => 2);

    $row++;
    ($ref_parm_label1 = $f->new_label(
            -text => "Ref. Parameter: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e');
    ($ref_parm_label2 = $f->new_label(
            -textvariable => \$ref_parm,
            -anchor       => 'w',
            -font         => 'default',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $ref_parm_label2->g_grid_remove();
    ($ref_parm_cb = $f->new_ttk__combobox(
            -textvariable => \$ref_parm,
            -values       => [ @parmlist ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $ref_parm_cb->g_bind("<<ComboboxSelected>>",
                          sub { if ($ref_parm =~ /Temperature/i) {
                                    $temp_msg_label->g_grid();
                                } else {
                                    $temp_msg_label->g_grid_remove();
                                }
                              });

    $row++;
    ($temp_msg_label = $f->new_label(
            -text => "(Please ensure temperature is in deg. Celsius.)",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);

    $row++;
    ($conv_type_label = $f->new_label(
            -text => "Conversion: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($conv_type_cb = $f->new_ttk__combobox(
            -textvariable => \$conv_type,
            -values       => [ @conv_types ],
            -state        => 'readonly',
            -width        => 13,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $conv_type_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($conv_type eq "Custom") {
                                $custom_frame->g_grid();
                            } else {
                                $custom_frame->g_grid_remove();
                            }
                          }
                      );
    $row++;
    ($custom_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $custom_frame->new_label(
            -text => "Multiply by: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_mult_entry = $custom_frame->new_entry(
            -textvariable => \$conv_mult,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_mult_entry->g_bind("<KeyRelease>",
                              sub { &numeric_entry_only($conv_mult_entry);
                                    my $chars = &max(7, length($conv_mult));
                                    $conv_mult_entry->configure(-width => $chars);
                                  });
    $custom_frame->new_label(
            -text => "  Then add: ",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');
    ($conv_add_entry = $custom_frame->new_entry(
            -textvariable => \$conv_add,
            -font         => 'default',
            -width        => 7,
            ))->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $conv_add_entry->g_bind("<KeyRelease>",
                             sub { &numeric_entry_only($conv_add_entry);
                                   my $chars = &max(7, length($conv_add));
                                   $conv_add_entry->configure(-width => $chars);
                                 });

    $row++;
    ($tol_label = $f->new_label(
            -text => "Match Tolerance: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($tol_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w');
    $tol_frame->new_spinbox(
            -textvariable => \$ref_tol,
            -state        => 'readonly',
            -font         => 'default',
            -from         => 0,
            -to           => 60,
            -increment    => 1,
            -width        => 3,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $tol_frame->new_label(
            -text => " minutes",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');

    $row++;
    $f->new_label(
            -text => "Difference Min: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($diff_min_entry = $f->new_entry(
            -textvariable => \$diff_min,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $diff_min_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $diff_min_entry ]);
    $f->new_label(
            -textvariable => \$units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Difference Max: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($diff_max_entry = $f->new_entry(
            -textvariable => \$diff_max,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $diff_max_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $diff_max_entry ]);
    $f->new_label(
            -textvariable => \$units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

    if ($props{$id}{meta} eq "data_profile") {
        $row++;
        $f->new_label(
                -text => "Difference Major: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($diff_major_entry = $f->new_entry(
                -textvariable => \$diff_major,
                -font         => 'default',
                -width        => 7,
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $diff_major_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($diff_major_entry, 1);
                                                        $diff_major =~ s/^-//;
                                                      });
        $f->new_label(
                -textvariable => \$units,
                -font         => 'default',
                -anchor       => 'w',
                )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);
    }

    $row++;
    ($byear_label1 = $f->new_label(
            -text => "Base Year: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($byear_cb = $f->new_ttk__combobox(
            -textvariable => \$byear,
            -values       => [ reverse($yr_min .. $yr_max) ],
            -width        => 5,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $byear_cb->g_bind("<<ComboboxSelected>>",
                      sub { if ($byear == $yr_min) {
                                $yr_min -= 5;
                                $byear_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                            }
                          });
    ($byear_label2 = $f->new_label(
            -text   => " for JDAY = 1.0",
            -anchor => 'w',
            -font   => 'default',
            ))->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

    $row++;
    ($tzoff_label = $f->new_label(
            -text => "Time Offset: ",
            -font => 'default',
            ))->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($offset_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w');
    $offset_frame->new_ttk__combobox(
            -textvariable => \$tz_offset,
            -values       => [ @tz_offsets ],
            -justify      => 'right',
            -state        => 'readonly',
            -width        => 6,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $offset_frame->new_label(
            -text   => " time zone adjustment ",
            -anchor => 'w',
            -font   => 'default',
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $offset_frame->new_button(
            -text    => "Help",
            -command => sub { &pop_up_info($convert_diff_menu,
                                    "The time offset allows the user to add or subtract a time\n"
                                  . "offset if the W2 model was run with a non-local time zone.\n\n"
                                  . "For example, if W2 was run in UTC but the local time zone\n"
                                  . "is PST, an offset of -08:00 would convert the model date/time\n"
                                  . "to a local standard time of PST. This offset does not make\n"
                                  . "any adjustments related to daylight saving time. In general,\n"
                                  . "W2 is best run in the local standard time.\n\n"
                                  . "Leave the time offset at +00:00 for no adjustment.",
                                    "Time Offset Notice");
                            },
            )->g_pack(-side => 'left', -anchor => 'w', -padx => 2);

    $row++;
    $title_txt = ($props{$id}{meta} eq "data_profile") ? "Axis Title: " : "Key Title: ";
    $f->new_label(
            -text => $title_txt,
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$title,
            -font         => 'default',
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew', -pady => 2);

    $ref_file_label1->g_grid_remove();
    $ref_file_label2->g_grid_remove();
    $ref_file_btn->g_grid_remove();
    $ref_parm_label1->g_grid_remove();
    $ref_parm_label2->g_grid_remove();
    $ref_parm_cb->g_grid_remove();
    $temp_msg_label->g_grid_remove();
    $conv_type_label->g_grid_remove();
    $conv_type_cb->g_grid_remove();
    $custom_frame->g_grid_remove();
    $tol_label->g_grid_remove();
    $tol_frame->g_grid_remove();
    $byear_label1->g_grid_remove();
    $byear_label2->g_grid_remove();
    $byear_cb->g_grid_remove();
    $tzoff_label->g_grid_remove();
    $offset_frame->g_grid_remove();

    $f->g_grid_columnconfigure(2, -weight => 2);

    Tkx::wm_resizable($convert_diff_menu,0,0);
    &adjust_window_position($convert_diff_menu);
    $convert_diff_menu->g_focus;
}


sub calculate_diffs {
    my ($id) = @_;
    my (
        $byear, $conv_type, $data_daily, $ref_file, $ref_type, $dt, $dt_ref,
        $dt_ref2, $found, $ftype, $mi, $n, $nd, $nlines, $parm, $pbar,
        $pbar_window, $pmax, $pmin, $ref_daily, $ref_val, $tol, $tzoff,

        @all_fmts, @data, @fmt_grp1, @fmt_grp2, @keys_dat, @keys_ref,

        %pdata, %ref_data,
       );

    $ref_type = $props{$id}{dref_type};
    if ($ref_type =~ /Constant/i) {
        $ref_val   = $props{$id}{dref_val};
    } else {
        $ref_file  = $props{$id}{dref_file};
        $ftype     = $props{$id}{dref_ftype};
        $nlines    = $props{$id}{dref_lines};
        $conv_type = $props{$id}{dref_ctype};
        $parm      = $props{$id}{dref_parm};
        $tol       = $props{$id}{dref_tol};

        @fmt_grp1 = ("USGS getData format",
                     "Aquarius Time-Series format",
                     "Dataquery format",
                     "USGS Water Services format",
                     "USGS Data Grapher format",
                     "CSV format",
                    );
        @fmt_grp2 = ("W2 TSR format",
                     "W2 Outflow CSV format",
                     "W2 CSV format",
                     "W2 column format",
                    );
        @all_fmts = (@fmt_grp1, @fmt_grp2);
    }
    $pbar = "";
    $pmax = -9.E6;
    $pmin =  9.E6;

#   Get and save the original parameter data and limits
    $gr_props{$id}{orig_parm_min} = $gr_props{$id}{parm_min};
    $gr_props{$id}{orig_parm_max} = $gr_props{$id}{parm_max};
    $gr_props{$id}{orig_pdata}    = $gr_props{$id}{pdata};
    %pdata = %{ $gr_props{$id}{pdata} };

#   Read the reference time series
    if ($ref_type !~ /Constant/i) {
        if ($nlines > 4000 && &list_match($ftype, @all_fmts) >= 0) {
            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $nlines,
                                                         "Reading time-series file...");
        }
        if (&list_match($ftype, @fmt_grp1) >= 0) {
            %ref_data = &read_timeseries($main, $ref_file, $ftype, $parm, $pbar);

        } elsif (&list_match($ftype, @fmt_grp2) >= 0) {
            $byear    = $props{$id}{dref_byear};
            $tzoff    = $props{$id}{dref_tzoff};
            %ref_data = &read_w2_timeseries($main, $ref_file, $ftype, $parm, $byear, $tzoff, $pbar);

        } else {
            return &pop_up_error($main, "Reference time-series file format not honored.");
        }
        if ($nlines > 4000 && &list_match($ftype, @all_fmts) >= 0) {
            &destroy_progress_bar($main, $pbar_window);
        }
        if (&list_match($conv_type, @conv_types) > 0 || $conv_type =~ /^Custom,/) {
            %ref_data = &convert_timeseries($main, $conv_type, 0, %ref_data);
        }
    }

#   Set up a progress bar using the number of dates
    $nd = 0;
    @keys_dat = keys %pdata;
    ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $#keys_dat +1,
                                                 "Calculating differences...");
    &reset_progress_bar($pbar, $#keys_dat +1, "Calculating differences... Date = 1");

#   Convert values using a constant reference
    if ($ref_type =~ /Constant/i) {
        foreach $dt (sort @keys_dat) {
            &update_progress_bar($pbar, ++$nd, $dt);
            next if (! defined($pdata{$dt}));
            @data = @{ $pdata{$dt} };
            for ($n=0; $n<=$#data; $n++) {
                next if $data[$n] eq "na";
                $data[$n] -= $ref_val;
                $pmin = $data[$n] if ($data[$n] < $pmin);
                $pmax = $data[$n] if ($data[$n] > $pmax);
            }
            $pdata{$dt} = [ @data ];
        }

#   Convert values using a time-series reference
    } else {
        @keys_ref   = keys %ref_data;
        $data_daily = (length($keys_dat[0]) == 12) ? 0 : 1;
        $ref_daily  = (length($keys_ref[0]) == 12) ? 0 : 1;

        foreach $dt (sort @keys_dat) {
            &update_progress_bar($pbar, ++$nd, $dt);
            delete $pdata{$dt} if (! defined($pdata{$dt}));
            $dt_ref = $dt;
            if ($data_daily != $ref_daily) {
                if ($ref_daily) {
                    $dt_ref = &nearest_daily_dt($dt);
                    if (&get_dt_diff($dt, 10000 *$dt_ref) > $tol || ! defined($ref_data{$dt_ref})) {
                        delete $pdata{$dt};
                        next;
                    }
                } else {
                    $dt_ref .= "0000";
                }
            }
            if (! defined($ref_data{$dt_ref})) {
                if (($data_daily && $ref_daily) || $tol == 0) {
                    delete $pdata{$dt};
                    next;
                }
                $found = 0;
                for ($mi=1; $mi<=$tol; $mi++) {
                    $dt_ref2 = &adjust_dt($dt_ref, $mi);
                    if (defined($ref_data{$dt_ref2})) {
                        $dt_ref = $dt_ref2;
                        $found  = 1;
                        last;
                    }
                    $dt_ref2 = &adjust_dt($dt_ref, -1 *$mi);
                    if (defined($ref_data{$dt_ref2})) {
                        $dt_ref = $dt_ref2;
                        $found  = 1;
                        last;
                    }
                }
                if (! $found) {
                    delete $pdata{$dt};
                    next;
                }
            }

#           Compute differences
            @data = @{ $pdata{$dt} };
            for ($n=0; $n<=$#data; $n++) {
                next if $data[$n] eq "na";
                $data[$n] -= $ref_data{$dt_ref};
                $pmin = $data[$n] if ($data[$n] < $pmin);
                $pmax = $data[$n] if ($data[$n] > $pmax);
            }
            $pdata{$dt} = [ @data ];
        }
    }

#   Kill the progress bar and save the data
    &destroy_progress_bar($main, $pbar_window);

#   Save the modified data and the new parameter limits
    $gr_props{$id}{parm_min} = $pmin;
    $gr_props{$id}{parm_max} = $pmax;
    $gr_props{$id}{pdata}    = { %pdata };
}


sub undo_diffs {
    my ($canv, $id, $X, $Y) = @_;
    my (
        $f, $frame, $geom, $pmax, $pmax_entry, $pmin, $pmin_entry, $row,
        $title, $title_chars, $title_txt, $units, $xmajor, $xmajor_entry,
        $xmax, $xmax_entry, $xmin, $xmin_entry,
       );

    &end_select($canv, $id, 1);
    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($undo_diff_menu) && Tkx::winfo_exists($undo_diff_menu)) {
        if ($undo_diff_menu->g_wm_title() eq "Undo Difference") {
            $undo_diff_menu->g_destroy();
            undef $undo_diff_menu;
        }
    }
    $undo_diff_menu = $main->new_toplevel();
    $undo_diff_menu->g_wm_transient($main);
    $undo_diff_menu->g_wm_title("Undo Difference");
    $undo_diff_menu->configure(-cursor => $cursor_norm);
    $undo_diff_menu->g_wm_geometry($geom);

#   Try to keep the nascent graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

    if ($props{$id}{meta} eq "data_profile") {
        if (defined($gr_props{$id}{orig_xmin})) {
            $xmin   = $gr_props{$id}{orig_xmin};
            $xmax   = $gr_props{$id}{orig_xmax};
            $xmajor = $gr_props{$id}{orig_xmajor};
            $pmin   = $gr_props{$id}{orig_cs_min};
            $pmax   = $gr_props{$id}{orig_cs_max};
            $title  = $gr_props{$id}{orig_xtitle};
        } else {
            $xmin   = $gr_props{$id}{xmin};
            $xmax   = $gr_props{$id}{xmax};
            $xmajor = $gr_props{$id}{xmajor};
            $pmin   = $gr_props{$id}{cs_min};
            $pmax   = $gr_props{$id}{cs_max};
            $title  = $gr_props{$id}{xtitle};
        }
    } else {
        if (defined($gr_props{$id}{orig_cs_min})) {
            $pmin   = $gr_props{$id}{orig_cs_min};
            $pmax   = $gr_props{$id}{orig_cs_max};
            $title  = $gr_props{$id}{orig_keytitle};
        } else {
            $pmin   = $gr_props{$id}{cs_min};
            $pmax   = $gr_props{$id}{cs_max};
            $title  = $gr_props{$id}{keytitle};
        }
    }
    if ($props{$id}{parm} eq "Temperature") {
        $title =~ s/Temperature Difference/Temperature/;
        $title =~ s/temperature difference/temperature/;
        $units = "\N{U+00B0}" . substr($props{$id}{parm_units},0,1);
    } else {
        $title =~ s/$props{$id}{parm} Difference/$props{$id}{parm}/;
        $title =~ s/$props{$id}{parm} difference/$props{$id}{parm}/;
        $units = $props{$id}{parm_units};
    }
    $title_chars = &max(25, length($title));

#   Create input menu
    $frame = $undo_diff_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    $frame->new_button(
            -text    => "OK",
            -command => sub { my ($tabid);
                              if ($pmin eq "" || $pmax eq "") {
                                  return &pop_up_error($undo_diff_menu,
                                  "Please provide both a minimum and maximum value.");
                              }
                              if ($pmin >= $pmax) {
                                  return &pop_up_error($undo_diff_menu,
                                  "The minimum value must be less than the maximum value.");
                              }
                              if ($props{$id}{meta} eq "data_profile") {
                                  if ($xmin eq "" || $xmax eq "") {
                                      return &pop_up_error($undo_diff_menu,
                                      "Please provide both a minimum and maximum X axis value.");
                                  }
                                  if ($xmin >= $xmax) {
                                      return &pop_up_error($undo_diff_menu,
                                          "The minimum X axis value must be\n"
                                        . "less than the maximum X axis value.");
                                  }
                                  if ($xmajor eq "" || $xmajor == 0) {
                                      return &pop_up_error($undo_diff_menu,
                                      "Please provide a nonzero X axis major spacing.");
                                  }
                                  $gr_props{$id}{xmin}   = $xmin;
                                  $gr_props{$id}{xmax}   = $xmax;
                                  $gr_props{$id}{xmajor} = $xmajor;
                                  $gr_props{$id}{xtitle} = $title;
                              }
                              $gr_props{$id}{cs_min}   = $pmin;
                              $gr_props{$id}{cs_max}   = $pmax;
                              $gr_props{$id}{cs_major} = "auto";
                              $gr_props{$id}{keytitle} = $title;

                              $gr_props{$id}{parm_min} = $gr_props{$id}{orig_parm_min};
                              $gr_props{$id}{parm_max} = $gr_props{$id}{orig_parm_max};
                              $gr_props{$id}{pdata}    = $gr_props{$id}{orig_pdata};
                              $props{$id}{prof_type}   = "standard";
                              $gr_props{$id}{redraw}   = 1;

                              $undo_diff_menu->g_bind('<Destroy>', "");
                              $undo_diff_menu->g_destroy();
                              undef $undo_diff_menu;
                              &reset_bindings;

                              &make_data_profile($canv, $id, 1);

#                             Refresh the Graph Properties menu, if present
                              if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
                                  if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
                                      $tabid = $grprops_notebook->index('current');
                                      $geom  = $graph_props_menu->g_wm_geometry();
                                      (undef, $X, $Y) = split(/\+/, $geom);
                                      &edit_graph_props($id, $X, $Y, $tabid);
                                  }
                              }

#                             Refresh the Object Information box, if present
                              if (defined($object_infobox) && Tkx::winfo_exists($object_infobox)) {
                                  if ($object_infobox->g_wm_title() eq "Object Info") {
                                      $geom = $object_infobox->g_wm_geometry();
                                      (undef, $X, $Y) = split(/\+/, $geom);
                                      &show_info($canv, $id, $X, $Y);
                                  }
                              }
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $undo_diff_menu->g_bind('<Destroy>', "");
                              $undo_diff_menu->g_destroy();
                              undef $undo_diff_menu;
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Clean up if this menu is destroyed by other than the Cancel button
    $undo_diff_menu->g_bind('<Destroy>' => sub { undef $undo_diff_menu;
                                                 &reset_bindings;
                                               });

    ($f = $undo_diff_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_pack(-side => 'top');

    $row = -1;
    if ($props{$id}{meta} eq "data_profile") {
        $row++;
        $f->new_label(
                -text => "X Axis Min: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($xmin_entry = $f->new_entry(
                -textvariable => \$xmin,
                -font         => 'default',
                -width        => 7,
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $xmin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $xmin_entry ]);
        $f->new_label(
                -textvariable => \$units,
                -font         => 'default',
                -anchor       => 'w',
                )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);
        $row++;
        $f->new_label(
                -text => "X Axis Max: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($xmax_entry = $f->new_entry(
                -textvariable => \$xmax,
                -font         => 'default',
                -width        => 7,
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $xmax_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $xmax_entry ]);
        $f->new_label(
                -textvariable => \$units,
                -font         => 'default',
                -anchor       => 'w',
                )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);
        $row++;
        $f->new_label(
                -text => "X Axis Major: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
        ($xmajor_entry = $f->new_entry(
                -textvariable => \$xmajor,
                -font         => 'default',
                -width        => 7,
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
        $xmajor_entry->g_bind("<KeyRelease>", sub { &numeric_entry_only($xmajor_entry, 1);
                                                    $xmajor =~ s/^-//;
                                                  });
        $f->new_label(
                -textvariable => \$units,
                -font         => 'default',
                -anchor       => 'w',
                )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);
    }

    $row++;
    $f->new_label(
            -text => "Scale Min: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmin_entry = $f->new_entry(
            -textvariable => \$pmin,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmin_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmin_entry ]);
    $f->new_label(
            -textvariable => \$units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Scale Max: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($pmax_entry = $f->new_entry(
            -textvariable => \$pmax,
            -font         => 'default',
            -width        => 7,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $pmax_entry->g_bind("<KeyRelease>", [ \&numeric_entry_only, $pmax_entry ]);
    $f->new_label(
            -textvariable => \$units,
            -font         => 'default',
            -anchor       => 'w',
            )->g_grid(-row => $row, -column => 2, -sticky => 'w', -pady => 2);

    $row++;
    $title_txt = ($props{$id}{meta} eq "data_profile") ? "Axis Title: " : "Key Title: ";
    $f->new_label(
            -text => $title_txt,
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    $f->new_entry(
            -textvariable => \$title,
            -font         => 'default',
            -width        => $title_chars,
            )->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'ew', -pady => 2);

    $f->g_grid_columnconfigure(2, -weight => 2);

    Tkx::wm_resizable($undo_diff_menu,0,0);
    &adjust_window_position($undo_diff_menu);
    $undo_diff_menu->g_focus;
}


sub find_data_limits {
    my ($id, %profile) = @_;
    my (
        $dmax, $dmin, $dt, $dt2, $dtmax, $dtmin, $emax, $emin, $got_depth,
        $i, $k, $kb, $maxdepth, $pmax, $pmin, $qmax, $qmin, $qsum, $qtot_max,
        $qtot_min, $vtot_max, $vtot_min,

        @depths, @elevations, @flow, @pdata, @qstr, @velo,
        %limits, %parm_data, %qdata, %qtot_data, %vtot_data, %wsurf,
       );

    %wsurf     = %{ $profile{ws_elev} };
    %parm_data = %{ $profile{pdata}   };
    %limits    = ();

    $dtmin = $dtmax = -999;
    $pmax  = $emax  = $dmax = -9.E6;
    $pmin  = $emin  = $dmin =  9.E6;
    $got_depth = ($profile{elv_dep} eq "elevation") ? 0 : 1;
    if ($got_depth) {
        @depths     = @{ $profile{depths} };
        $maxdepth   = &max(@depths);
        $dmin       = &min(@depths);
        $dmax       = $maxdepth;
    } else {
        @elevations = @{ $profile{elevations} };
        $emin       = &min(@elevations);
    }
    foreach $dt (keys %wsurf) {
        next if ($wsurf{$dt} eq "na");
        $emax = $wsurf{$dt} if ($wsurf{$dt} > $emax);
        if ($got_depth) {
            $emin = $wsurf{$dt} -$maxdepth if ($wsurf{$dt} -$maxdepth < $emin);
        } else {
            $dmax = $wsurf{$dt} -$emin if ($wsurf{$dt} -$emin > $dmax);
            for ($i=0; $i<=$#elevations; $i++) {
                next if ($elevations[$i] > $wsurf{$dt} +0.1/3.28084);
                $dmin = $wsurf{$dt} -$elevations[$i] if ($wsurf{$dt} -$elevations[$i] < $dmin);
            }
        }
    }
    $dmin = &max(0.0, $dmin);
    foreach $dt (keys %parm_data) {
        @pdata = @{ $parm_data{$dt} };
        $dt2   = (length($dt) == 12) ? $dt : $dt *10000;
        $dtmin = $dt2 if ($dtmin == -999 || $dt2 < $dtmin);  # dates tied to profile{pdata}
        $dtmax = $dt2 if ($dtmax == -999 || $dt2 > $dtmax);
        for ($i=0; $i<=$#pdata; $i++) {
            next if ($pdata[$i] eq "na");
            if (! $got_depth && defined($wsurf{$dt})) {
                next if ($wsurf{$dt} eq "na");
                next if ($elevations[$i] > $wsurf{$dt} +0.1/3.28084);
            }
            $pmin = $pdata[$i] if ($pdata[$i] < $pmin);
            $pmax = $pdata[$i] if ($pdata[$i] > $pmax);
        }
    }
    $limits{date_min} = $dtmin;
    $limits{date_max} = $dtmax;
    $limits{dpth_min} = ($dmin <  9.E6) ? $dmin : "n/a";
    $limits{dpth_max} = ($dmax > -9.E6) ? $dmax : "n/a";
    $limits{elev_min} = ($emin <  9.E6) ? $emin : "n/a";
    $limits{elev_max} = ($emax > -9.E6) ? $emax : "n/a";
    $limits{parm_min} = ($pmin <  9.E6) ? $pmin : "n/a";
    $limits{parm_max} = ($pmax > -9.E6) ? $pmax : "n/a";

    if ($props{$id}{meta} eq "vert_wd_zone") {
        $qmax  = -9.E6;
        $qmin  =  9.E6;
        %qdata = %{ $profile{qdata} };
        foreach $dt (keys %qdata) {
            $dt2  = (length($dt) == 12) ? $dt : $dt *10000;
            next if ($dtmin == -999 || $dt2 < $dtmin || $dt2 > $dtmax);
            @qstr = @{ $qdata{$dt} };
            $qsum = &sum(@qstr);
            $qmin = $qsum if ($qsum < $qmin);
            $qmax = $qsum if ($qsum > $qmax);
        }
        $limits{flow_min} = ($qmin <  9.E6) ? $qmin : "n/a";
        $limits{flow_max} = ($qmax > -9.E6) ? $qmax : "n/a";

#       Assess the layer-specific flows and velocities, if available
        if (defined($profile{qtot_data})) {
            $kb        = $profile{kb};
            $qtot_max  = $vtot_max = -9.E6;
            $qtot_min  = $vtot_min =  9.E6;
            %qtot_data = %{ $profile{qtot_data} };
            %vtot_data = %{ $profile{vtot_data} };
            foreach $dt (keys %qtot_data) {
                $dt2  = (length($dt) == 12) ? $dt : $dt *10000;
                next if ($dtmin == -999 || $dt2 < $dtmin || $dt2 > $dtmax);
                @flow = @{ $qtot_data{$dt} };
                @velo = @{ $vtot_data{$dt} };
                for ($k=2; $k<=$kb; $k++) {
                    $qtot_min = $flow[$k] if ($flow[$k] < $qtot_min);
                    $qtot_max = $flow[$k] if ($flow[$k] > $qtot_max);
                    $vtot_min = $velo[$k] if ($velo[$k] < $vtot_min);
                    $vtot_max = $velo[$k] if ($velo[$k] > $vtot_max);
                }
            }
            $limits{qtot_min} = ($qtot_min <  9.E6) ? $qtot_min : "n/a";
            $limits{qtot_max} = ($qtot_max > -9.E6) ? $qtot_max : "n/a";
            $limits{vtot_min} = ($vtot_min <  9.E6) ? $vtot_min : "n/a";
            $limits{vtot_max} = ($vtot_max > -9.E6) ? $vtot_max : "n/a";
        } else {
            $limits{qtot_min} = "not determined";
            $limits{qtot_max} = "not determined";
            $limits{vtot_min} = "not determined";
            $limits{vtot_max} = "not determined";
        }
    }
    return %limits;
}


sub find_w2_profile_limits {
    my ($id, $seg, $elev_ref, $pdata_ref) = @_;
    my ($dt, $dtmax, $dtmin, $emax, $emin, $i, $pmax, $pmin,
        @el, @kb, @pdata,
        %elev_data, %limits, %parm_data,
       );

    %elev_data = %{ $elev_ref  };
    %parm_data = %{ $pdata_ref };
    %limits    = ();

    @el   = @{ $grid{$id}{el} };
    @kb   = @{ $grid{$id}{kb} };
    $emin = $el[$kb[$seg]+1][$seg];
    $pmax = $emax = $dtmin = $dtmax = -999.;
    $pmin = 9.E6;
    foreach $dt (keys %elev_data) {
        $emax = $elev_data{$dt} if ($elev_data{$dt} > $emax);
    }
    foreach $dt (keys %parm_data) {
        @pdata = @{ $parm_data{$dt} };
        $dtmin = $dt if ($dtmin == -999 || $dt < $dtmin);
        $dtmax = $dt if ($dtmax == -999 || $dt > $dtmax);
        for ($i=0; $i<=$#pdata; $i++) {
            $pmin = $pdata[$i] if ($pdata[$i] < $pmin);
            $pmax = $pdata[$i] if ($pdata[$i] > $pmax);
        }
    }
    $dtmin *= 10000 if ($dtmin != -999 && length($dtmin) == 8);
    $dtmax *= 10000 if ($dtmax != -999 && length($dtmax) == 8);
    $limits{date_min} = $dtmin;
    $limits{date_max} = $dtmax;
    $limits{dpth_min} = 0.0;
    $limits{dpth_max} = $emax -$emin;
    $limits{elev_min} = $emin;
    $limits{elev_max} = $emax;
    $limits{parm_min} = $pmin;
    $limits{parm_max} = $pmax;

    return %limits;
}


sub find_w2_outflow_limits {
    my ($id, $seg, $qdata_ref, $vdata_ref) = @_;
    my (
        $dt, $dtmax, $dtmin, $emax, $emin, $k, $kmx, $nd, $pbar,
        $pbar_window, $qmax, $qmin, $vmax, $vmin,
        @el, @kb, @flow, @qdates, @velo,
        %limits, %qdata, %vdata,
       );

    %qdata  = %{ $qdata_ref     };
    %vdata  = %{ $vdata_ref     };
    @el     = @{ $grid{$id}{el} };
    @kb     = @{ $grid{$id}{kb} };
    $kmx    = $grid{$id}{kmx};
    $emin   = $el[$kb[$seg]+1][$seg];   # elevation in meters
    $dtmin  = $dtmax = -999;
    $qmax   = $vmax  = $emax = -9.E6;
    $qmin   = $vmin  = 9.E6;
    %limits = ();

    @qdates = sort keys %qdata;
    ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $#qdates +1,
                                                 "Finding outflow limits...");
    &reset_progress_bar($pbar, $#qdates +1, "Finding outflow limits... Date = 1");

    for ($nd=0; $nd<=$#qdates; $nd++) {
        $dt    = $qdates[$nd];
        $dtmin = $dt if ($dtmin == -999 || $dt < $dtmin);
        $dtmax = $dt if ($dtmax == -999 || $dt > $dtmax);
        &update_progress_bar($pbar, $nd, $dt) if ($nd % 10 == 0);

        @flow = @{ $qdata{$dt} };
        @velo = @{ $vdata{$dt} };
        $emax = $flow[1] if ($flow[1] > $emax);  # $flow[1] is WS elevation
        for ($k=2; $k<=$kmx; $k++) {
            next if (! defined($flow[$k]) || $flow[$k] eq "");
            $vmin = $velo[$k] if ($velo[$k] < $vmin);
            $vmax = $velo[$k] if ($velo[$k] > $vmax);
            $qmin = $flow[$k] if ($flow[$k] < $qmin);
            $qmax = $flow[$k] if ($flow[$k] > $qmax);
        }
    }
    $dtmin *= 10000 if ($dtmin != -999 && length($dtmin) == 8);
    $dtmax *= 10000 if ($dtmax != -999 && length($dtmax) == 8);
    $limits{date_min} = $dtmin;
    $limits{date_max} = $dtmax;
    $limits{dpth_min} = 0.0;          # units: meters
    $limits{dpth_max} = $emax -$emin;
    $limits{elev_min} = $emin;        # units: meters
    $limits{elev_max} = $emax;
    $limits{flow_min} = $qmin;        # units: cms per vertical meter
    $limits{flow_max} = $qmax;
    $limits{vel_min}  = $vmin;        # units: m/s
    $limits{vel_max}  = $vmax;
    &destroy_progress_bar($main, $pbar_window);

    return %limits;
}


sub find_w2_slice_limits {
    my ($id, %profile) = @_;
    my (
        $dmax, $dt, $dtmax, $dtmin, $emax, $emin, $i, $jb, $jw, $k, $kmx,
        $kt, $n, $nbr, $nd, $ns, $nwb, $pbar, $pbar_window, $pmax, $pmin,
        $seg_dn, $seg_up, $src_type,

        @be, @bs, @cus, @ds, @el, @elws, @kb, @pdata, @sdates, @seg_br,
        @seg_limits, @seg_wb, @seglist, @slice_data, @us, @wbs,

        %limits, %sdata,
       );

    $src_type   = $props{$id}{src_type};        # contour or vector
    @slice_data = @{ $profile{slice_data} };
    %limits     = ();

    @wbs   = split(/,/, $props{$id}{wb_list});
    $nwb   = $grid{$id}{nwb};
    $nbr   = $grid{$id}{nbr};
    $kmx   = $grid{$id}{kmx};
    @bs    = @{ $grid{$id}{bs}  };
    @be    = @{ $grid{$id}{be}  };
    @us    = @{ $grid{$id}{us}  };
    @ds    = @{ $grid{$id}{ds}  };
    @kb    = @{ $grid{$id}{kb}  };
    @el    = @{ $grid{$id}{el}  };
    $pmax  = $emax = $dmax = -9.E6;
    $pmin  = $emin = 9.E6;
    $dtmin = $dtmax = -999;

    @seg_limits = reverse split(/,|-/, $props{$id}{seg_list});
    @seglist    = ();
    @seg_wb     = ();
    @seg_br     = ();
    for ($n=0; $n<$#seg_limits; $n+=2) {
        $seg_dn = $seg_limits[$n];
        $seg_up = $seg_limits[$n+1];
        for ($jb=1; $jb<=$nbr; $jb++) {
            last if ($seg_dn >= $us[$jb] && $seg_dn <= $ds[$jb]);
        }
        for ($jw=1; $jw<=$nwb; $jw++) {
            last if ($jb >= $bs[$jw] && $jb <= $be[$jw]);
        }
        for ($i=$seg_dn; $i>=$seg_up; $i--) {
            $seg_wb[$i] = $jw;
            $seg_br[$i] = $jb;
            push (@seglist, $i);
            $emin = $el[$kb[$i]+1][$i] if ($el[$kb[$i]+1][$i] < $emin);
        }
    }

#   Set up a progress bar.  It will reset itself for each waterbody.
    @sdates = keys %{ $slice_data[0] };
    ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $#sdates +1,
                                                 "Finding parameter limits...");
    &reset_progress_bar($pbar, $#sdates +1, "Finding parameter limits... Date = 1");

    for ($n=0; $n<=$#wbs; $n++) {
        $jw = $wbs[$n];
        if ($n == 0 || $src_type =~ /Contour/i) {
            %sdata  = %{ $slice_data[$n] };
            @sdates = sort keys %sdata;
        }
        for ($nd=0; $nd<=$#sdates; $nd++) {
            $dt    = $sdates[$nd];
            $dtmin = $dt if ($dtmin == -999 || $dt < $dtmin);
            $dtmax = $dt if ($dtmax == -999 || $dt > $dtmax);
            &update_progress_bar($pbar, $nd, $dt);

            if ($src_type =~ /Contour/i) {
                $kt = $sdata{$dt}{kt};
            } else {
                $kt = $sdata{$dt}{kt}[$jw];       # vector file has kt values in array
            }
            @cus   = @{ $sdata{$dt}{cus}       };
            @elws  = @{ $sdata{$dt}{elws}      };
            @pdata = @{ $sdata{$dt}{parm_data} };
            for ($ns=0; $ns<=$#seglist; $ns++) {
                $i = $seglist[$ns];
                next if ($jw != $seg_wb[$i]);
                next if (! defined($cus[$seg_br[$i]]) || $cus[$seg_br[$i]] == 0 || $i < $cus[$seg_br[$i]]);
                $emax = $elws[$i] if ($elws[$i] > $emax);
                $dmax = $elws[$i] -$el[$kb[$i]+1][$i] if ($elws[$i] -$el[$kb[$i]+1][$i] > $dmax);
                for ($k=$kt; $k<=$kmx; $k++) {
                    last if (! defined($pdata[$k][$i]));               # cannot count on kb for sloped grid
                    last if ($src_type =~ /Vector/i && $pdata[$k][$i] == -99); # vector flag, inactive cell
                    $pmin = $pdata[$k][$i] if ($pdata[$k][$i] < $pmin);
                    $pmax = $pdata[$k][$i] if ($pdata[$k][$i] > $pmax);
                }
            }
        }
    }
    $dtmin *= 10000 if ($dtmin != -999 && length($dtmin) == 8);
    $dtmax *= 10000 if ($dtmax != -999 && length($dtmax) == 8);
    $limits{date_min} = $dtmin;
    $limits{date_max} = $dtmax;
    $limits{dpth_min} = 0.0;
    $limits{dpth_max} = $dmax;
    $limits{elev_min} = $emin;
    $limits{elev_max} = $emax;
    $limits{parm_min} = $pmin;
    $limits{parm_max} = $pmax;
    &destroy_progress_bar($main, $pbar_window);

    return %limits;
}


sub find_w2_tdmap_limits {
    my ($id, %data) = @_;
    my (
        $dt, $dtmax, $dtmin, $j, $nd, $pbar, $pbar_window, $pmax, $pmin,
        $seg, $skip,
        @seg_limits, @td_dates,
        %limits,
       );

    $nd     =     0;
    $pmax   = -9.E6;
    $pmin   =  9.E6;
    $dtmin  = $dtmax = -999;
    %limits = ();

    @seg_limits = split(/,|-/, $props{$id}{seg_list});

#   Set up a progress bar.  It will reset itself for each waterbody.
    @td_dates = keys %data;
    ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $#td_dates +1,
                                                 "Finding parameter limits...");
    &reset_progress_bar($pbar, $#td_dates +1, "Finding parameter limits... Date = 1");

#   Loop over the dates
    foreach $dt (sort @td_dates) {
        $nd++;
        $dtmin = $dt if ($dtmin == -999 || $dt < $dtmin);
        $dtmax = $dt if ($dtmax == -999 || $dt > $dtmax);
        &update_progress_bar($pbar, $nd, $dt);

#       Loop over the segments
        foreach $seg (keys %{ $data{$dt} }) {
            $skip = 1;
            for ($j=0; $j<$#seg_limits; $j+=2) {
                if ($seg >= $seg_limits[$j] && $seg <= $seg_limits[$j+1]) {
                    $skip = 0;
                    last;
                }
            }
            next if ($skip);                                         # segment not included
            next if ($data{$dt}{$seg} == -99);                       # inactive cell
            $pmin = $data{$dt}{$seg} if ($data{$dt}{$seg} < $pmin);
            $pmax = $data{$dt}{$seg} if ($data{$dt}{$seg} > $pmax);
        }
    }
    $dtmin *= 10000 if ($dtmin != -999 && length($dtmin) == 8);
    $dtmax *= 10000 if ($dtmax != -999 && length($dtmax) == 8);
    $limits{date_min} = $dtmin;
    $limits{date_max} = $dtmax;
    $limits{parm_min} = ($pmin <  9.E6) ? $pmin : "n/a";
    $limits{parm_max} = ($pmax > -9.E6) ? $pmax : "n/a";
    &destroy_progress_bar($main, $pbar_window);

    return %limits;
}


sub find_w2_wlevel_limits {
    my ($id, %data) = @_;
    my (
        $dt, $dtmax, $dtmin, $emax, $emin, $i, $n, $nd, $pbar, $pbar_window,
        $seg,
        @seg_limits, @seglist, @wl_dates,
        %limits,
       );

    $nd     = -1;
    $emax   = -9.E6;
    $emin   =  9.E6;
    $dtmin  = $dtmax = -999;
    %limits = ();

#   Set up segment list
    @seg_limits = split(/,|-/, $props{$id}{seg_list});
    @seglist    = ();
    for ($n=0; $n<$#seg_limits; $n+=2) {
        for ($i=$seg_limits[$n]; $i<=$seg_limits[$n+1]; $i++) {
            push (@seglist, $i);
        }
    }

#   Set up a progress bar
    @wl_dates = keys %data;
    ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $#wl_dates +1,
                                                 "Finding parameter limits...");
    &reset_progress_bar($pbar, $#wl_dates +1, "Finding parameter limits... Date = 1");

#   Loop over the dates
    foreach $dt (sort @wl_dates) {
        $dtmin = $dt if ($dtmin == -999 || $dt < $dtmin);
        $dtmax = $dt if ($dtmax == -999 || $dt > $dtmax);
        if (++$nd %10 == 0) {
            &update_progress_bar($pbar, $nd, $dt);
        }

#       Loop over the segments
        for ($i=0; $i<=$#seglist; $i++) {
            $seg  = $seglist[$i];
            next if ($data{$dt}[$seg] == -999);
            $emin = $data{$dt}[$seg] if ($data{$dt}[$seg] < $emin);
            $emax = $data{$dt}[$seg] if ($data{$dt}[$seg] > $emax);
        }
    }
    $dtmin *= 10000 if ($dtmin != -999 && length($dtmin) == 8);
    $dtmax *= 10000 if ($dtmax != -999 && length($dtmax) == 8);
    $limits{date_min} = $dtmin;
    $limits{date_max} = $dtmax;
    $limits{elev_min} = ($emin <  9.E6) ? $emin : "n/a";
    $limits{elev_max} = ($emax > -9.E6) ? $emax : "n/a";
    &destroy_progress_bar($main, $pbar_window);

    return %limits;
}


sub find_ts_limits {
    my ($id, $vonly, $dtlo, $dthi) = @_;
    my (
        $dt, $dt2, $dtmax, $dtmin, $link_id, $mult, $n, $nsets, $pmax,
        $pmin, $sum, $wt,
        @add_ts_limits, @add_ts_show, @add_ts_tsdata, @names, @qstr, @show, @tstr,
        %add_ts_parms, %limits, %parms, %qdata, %tdata, %ts_data, %wsurf,
       );

#   vonly is a flag telling this routine to evaluate limits only for non-hidden datasets
#   dtlo is an optional date (YYYYMMDDHHmm) constraining the minimum date for the search
#   dthi is an optional date (YYYYMMDDHHmm) constraining the maximum date for the search

    $pmin  =  9.E6;
    $pmax  = -9.E6;
    $dtmin = $dtmax = -999;
    $dtlo  = -9.E12 if (! defined($dtlo) || $dtlo eq "");
    $dthi  =  9.E12 if (! defined($dthi) || $dthi eq "");
    $vonly = 0 if (! defined($vonly) || $vonly eq "" || $vonly ne "1");

#   For linked time-series, start by finding the limits of the linked data
    if ($props{$id}{meta} eq "linked_time_series") {
        $link_id = $props{$id}{link_id};
        %parms   = %{ $props{$id}{ts_parms} };
        @show    = @{ $parms{show} };
        if ($parms{ts_type} eq "Water Surface Elevation") {
            %wsurf = %{ $gr_props{$link_id}{ws_elev} };
            $mult  = ($parms{units} eq "ft") ? 3.28084 : 1.0;
            foreach $dt (sort keys %wsurf) {
                next if (! defined($wsurf{$dt}) || $wsurf{$dt} eq "na");
                $dt2 = (length($dt) == 12) ? $dt : $dt *10000;
                next if ($dt2 < $dtlo);
                last if ($dt2 > $dthi);
                $dtmin = $dt2 if ($dtmin == -999 || $dt2 < $dtmin);
                $dtmax = $dt2 if ($dtmax == -999 || $dt2 > $dtmax);
                $pmin  = $wsurf{$dt} *$mult if ($wsurf{$dt} *$mult < $pmin);
                $pmax  = $wsurf{$dt} *$mult if ($wsurf{$dt} *$mult > $pmax);
            }
            undef %wsurf;

        } elsif ($parms{ts_type} eq "Flow") {
            %qdata = %{ $gr_props{$link_id}{qdata} };
            @names = @{ $gr_props{$link_id}{names} };
            $mult  = ($parms{units} eq "cfs") ? 35.31467 : 1.0;
            if (! $vonly || &sum(@show) > 0) {
                foreach $dt (sort keys %qdata) {
                    next if (! defined($qdata{$dt}));
                    $dt2 = (length($dt) == 12) ? $dt : $dt *10000;
                    if ($gr_props{$link_id}{date_min} != -999) {
                        next if ($dt2 < $gr_props{$link_id}{date_min});
                        last if ($dt2 > $gr_props{$link_id}{date_max});
                    }
                    next if ($dt2 < $dtlo);
                    last if ($dt2 > $dthi);
                    $dtmin = $dt2 if ($dtmin == -999 || $dt2 < $dtmin);
                    $dtmax = $dt2 if ($dtmax == -999 || $dt2 > $dtmax);
                    @qstr  = @{ $qdata{$dt} };
                    if (! $vonly || $show[$#show]) {
                        $sum  = &sum(@qstr);
                        $pmax = $sum *$mult if ($sum *$mult > $pmax);
                    }
                    for ($n=0; $n<=$#names; $n++) {
                        next if ($vonly && ! $show[$n]);
                        $pmin = $qstr[$n] *$mult if ($qstr[$n] *$mult < $pmin);
                        $pmax = $qstr[$n] *$mult if ($qstr[$n] *$mult > $pmax);
                    }
                }
            }
            undef %qdata;

        } elsif ($parms{ts_type} eq "Temperature") {
            %tdata = %{ $gr_props{$link_id}{tdata} };
            @names = @{ $gr_props{$link_id}{names} };
            push (@names, "All Outlets");
            if (! $vonly || &sum(@show) > 0) {
                foreach $dt (sort keys %tdata) {
                    next if (! defined($tdata{$dt}));
                    $dt2 = (length($dt) == 12) ? $dt : $dt *10000;
                    if ($gr_props{$link_id}{date_min} != -999) {
                        next if ($dt2 < $gr_props{$link_id}{date_min});
                        last if ($dt2 > $gr_props{$link_id}{date_max});
                    }
                    next if ($dt2 < $dtlo);
                    last if ($dt2 > $dthi);
                    @tstr = @{ $tdata{$dt} };
                    for ($n=0; $n<=$#names; $n++) {
                        next if ($vonly && ! $show[$n]);
                        $wt = $tstr[$n];
                        if ($wt > -99) {
                            $wt    = 1.8 *$wt +32 if ($parms{units} eq "Fahrenheit");
                            $dtmin = $dt2 if ($dtmin == -999 || $dt2 < $dtmin);
                            $dtmax = $dt2 if ($dtmax == -999 || $dt2 > $dtmax);
                            $pmin  = $wt if ($wt < $pmin);
                            $pmax  = $wt if ($wt > $pmax);
                        }
                    }
                }
            }
            undef %tdata;
        }
    }

#   Check limits of other time-series datasets.  No need to check units.
    if (defined($props{$id}{add_ts_parms})) {
        %add_ts_parms = %{ $props{$id}{add_ts_parms} };
        @add_ts_show  = @{ $add_ts_parms{ts_show} };
        if ($dtlo > -9.E12 && $dthi < 9.E12) {             # check each point
            @add_ts_tsdata = @{ $add_ts_parms{ts_data} };
            $nsets = $#add_ts_tsdata +1;
            for ($n=0; $n<$nsets; $n++) {
                next if ($vonly && ! $add_ts_show[$n]);
                %ts_data = %{ $add_ts_tsdata[$n] };
                foreach $dt (sort keys %ts_data) {
                    $dt2 = (length($dt) == 12) ? $dt : $dt *10000;
                    next if ($dt2 < $dtlo);
                    last if ($dt2 > $dthi);
                    next if ($ts_data{$dt} eq "na");
                    $dtmin = $dt2 if ($dtmin == -999 || $dt2 < $dtmin);
                    $dtmax = $dt2 if ($dtmax == -999 || $dt2 > $dtmax);
                    $pmin  = $ts_data{$dt} if ($ts_data{$dt} < $pmin);
                    $pmax  = $ts_data{$dt} if ($ts_data{$dt} > $pmax);
                }
            }
        } else {                                           # just check the limits
            @add_ts_limits = @{ $add_ts_parms{ts_limits} };
            $nsets = $#add_ts_limits +1;
            for ($n=0; $n<$nsets; $n++) {
                next if ($vonly && ! $add_ts_show[$n]);
                %limits = %{ $add_ts_limits[$n] };
                $dtmin = $limits{date_min} if ($dtmin == -999 || $limits{date_min} < $dtmin);
                $dtmax = $limits{date_max} if ($dtmax == -999 || $limits{date_max} > $dtmax);
                $pmin  = $limits{parm_min} if ($limits{parm_min} < $pmin);
                $pmax  = $limits{parm_max} if ($limits{parm_max} > $pmax);
            }
        }
    }
    return ($dtmin, $dtmax, $pmin, $pmax);
}


sub setup_ref_stats {
    my ($canv, $id, $X, $Y) = @_;
    my (
        $bdate_frame, $bday, $bday_alt, $bday_cb, $bday_sav, $bm, $bm_alt,
        $bmon, $bmon_alt, $bmon_cb, $bmon_sav, $byr, $byr_alt, $byr_cb,
        $byr_sav, $dates_cb, $dates_opt, $dates_opt_sav, $dt_begin, $dt_end,
        $edate_frame, $eday, $eday_alt, $eday_cb, $eday_sav, $em, $em_alt,
        $emon, $emon_alt, $emon_cb, $emon_sav, $eyr, $eyr_alt, $eyr_cb,
        $eyr_sav, $f, $frame, $geom, $got_depth, $interp, $interp_txt,
        $monthly, $row, $yr_max, $yr_min,

        @date_ops, @keys_data,
        %parm_data, %ref_profile,
       );

    &end_select($canv, $id, 1);

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($ref_stats_menu) && Tkx::winfo_exists($ref_stats_menu)) {
        if ($ref_stats_menu->g_wm_title() eq "Choose Profile Fit Statistics") {
            $ref_stats_menu->g_destroy();
            undef $ref_stats_menu;
        }
    }
    $ref_stats_menu = $main->new_toplevel();
    $ref_stats_menu->g_wm_transient($main);
    $ref_stats_menu->g_wm_title("Choose Profile Fit Statistics");
    $ref_stats_menu->configure(-cursor => $cursor_norm);
    $ref_stats_menu->g_wm_geometry($geom);

#   Try to keep any objects from being selected. Reset bindings later.
    $canvas->g_bind("<Motion>", "");

    $monthly   = 1;
    $interp    = 1;
    $dates_opt = $dates_opt_sav = "Include all dates";
    if (defined($gr_props{$id}{date_min})) {
        $dt_begin = $gr_props{$id}{date_min};
        $dt_end   = $gr_props{$id}{date_max};
    } else {
        %parm_data = %{ $gr_props{$id}{parm_data} };
        @keys_data = sort keys %parm_data;
        $dt_begin  = $keys_data[0];
        $dt_end    = $keys_data[$#keys_data];
        $dt_begin *= 10000 if (length($dt_begin) == 8);
        $dt_end   *= 10000 if (length($dt_end)   == 8);
        undef %parm_data;
        undef @keys_data;
    }
    %ref_profile = %{ $gr_props{$id}{ref_data} };
    $got_depth   = ($ref_profile{elv_dep} eq "elevation") ? 0 : 1;
    if ($got_depth) {
        $interp_txt = "Interpolate profile to measured depths";
    } else {
        $interp_txt = "Interpolate profile to measured elevations";
    }
    undef %ref_profile;

    ($bm, $bday, $byr) = &parse_date($dt_begin, 1);
    ($em, $eday, $eyr) = &parse_date(&jdate2date(&ceil(&date2jdate($dt_end))), 1);
    $bm--;
    $em--;
    $bday    += 0;
    $eday    += 0;
    $bmon     = $mon_names[$bm];
    $emon     = $mon_names[$em];
    $bday_sav = $bday;
    $eday_sav = $eday;
    $bmon_sav = $bmon;
    $emon_sav = $emon;
    $byr_sav  = $byr;
    $eyr_sav  = $eyr;
    $yr_max   = (localtime(time))[5] +1900;
    $yr_min   = $yr_max -25;
    $yr_min   = $byr if ($byr < $yr_min);
    $yr_max   = $eyr if ($eyr > $yr_max);

    if ($global_dt_limits) {
        ($bm_alt, $bday_alt, $byr_alt) = &parse_date($global_dt_begin, 1);
        ($em_alt, $eday_alt, $eyr_alt) = &parse_date($global_dt_end,   1);
        $bday_alt += 0;
        $eday_alt += 0;
        $bmon_alt  = $mon_names[$bm_alt-1];
        $emon_alt  = $mon_names[$em_alt-1];
        $yr_min    = $byr_alt if ($byr_alt < $yr_min);
        $yr_max    = $eyr_alt if ($eyr_alt > $yr_max);
        @date_ops  = ("Include all dates", "Use global date limits", "Custom date range");
    } else {
        @date_ops  = ("Include all dates", "Custom date range");
    }

#   Build the menu.
    $frame = $ref_stats_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    $frame->new_button(
            -text    => "OK",
            -command => sub { my ($m);
                              if ($dates_opt eq "Include all dates") {
                                  $dt_begin = $dt_end = -999;
                              } elsif ($global_dt_limits && $dates_opt eq "Use global date limits") {
                                  $dt_begin = $global_dt_begin;
                                  $dt_end   = $global_dt_end;
                              } else {
                                  $m        = &list_match($bmon, @mon_names);
                                  $dt_begin = sprintf("%04d%02d%02d0000", $byr, $m+1, $bday);
                                  $m        = &list_match($emon, @mon_names);
                                  $dt_end   = sprintf("%04d%02d%02d0000", $eyr, $m+1, $eday);
                                  if ($dt_begin > $dt_end) {
                                      return &pop_up_error($ref_stats_menu,
                                                  "The start date is after the end date.\n"
                                                . "Please adjust and try again.");
                                  } elsif ($dt_begin == $dt_end) {
                                      return &pop_up_error($ref_stats_menu,
                                                  "The start date is equal to the end date.\n"
                                                . "Please adjust and try again.");
                                  }
                              }

                              $ref_stats_menu->g_bind('<Destroy>', "");
                              $ref_stats_menu->g_destroy();
                              undef $ref_stats_menu;
                              &reset_bindings;

                              &show_ref_stats($id, $interp, $monthly, $dt_begin, $dt_end);
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $ref_stats_menu->g_bind('<Destroy>', "");
                              $ref_stats_menu->g_destroy();
                              undef $ref_stats_menu;
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2); 

#   Reset bindings if this menu is destroyed by other than the Cancel button
    $ref_stats_menu->g_bind('<Destroy>' => sub { undef $ref_stats_menu;
                                                 &reset_bindings;
                                               });

    ($f = $ref_stats_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_pack(-side => 'top', -expand => 1, -fill => 'both');

    $row = 0;
    $f->new_label(
            -text => "Choose a set of options for the goodness-of-fit statistics:",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -columnspan => 2, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Options: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $f->new_checkbutton(
            -onvalue  => 1,
            -offvalue => 0,
            -text     => $interp_txt,
            -font     => 'default',
            -variable => \$interp,
            )->g_grid(-row => $row, -column => 1, -sticky => 'w');

    $row++;
    $f->new_checkbutton(
            -onvalue  => 1,
            -offvalue => 0,
            -text     => "Include stats by month",
            -font     => 'default',
            -variable => \$monthly,
            )->g_grid(-row => $row, -column => 1, -sticky => 'w');

    $row++;
    $f->new_label(
            -text => "Date Range: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($dates_cb = $f->new_ttk__combobox(
            -textvariable => \$dates_opt,
            -values       => [ @date_ops ],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w');
    $dates_cb->g_bind("<<ComboboxSelected>>",
                       sub { return if ($dates_opt eq $dates_opt_sav);
                             if ($dates_opt eq "Custom date range") {
                                 $bmon_cb->configure(-state => 'readonly');
                                 $bday_cb->configure(-state => 'readonly');
                                 $byr_cb->configure(-state  => 'readonly');
                                 $emon_cb->configure(-state => 'readonly');
                                 $eday_cb->configure(-state => 'readonly');
                                 $eyr_cb->configure(-state  => 'readonly');
                             } else {
                                 $bmon_cb->configure(-state => 'disabled');
                                 $bday_cb->configure(-state => 'disabled');
                                 $byr_cb->configure(-state  => 'disabled');
                                 $emon_cb->configure(-state => 'disabled');
                                 $eday_cb->configure(-state => 'disabled');
                                 $eyr_cb->configure(-state  => 'disabled');
                                 if ($dates_opt eq "Use global date limits") {
                                     $bmon = $bmon_alt;
                                     $bday = $bday_alt;
                                     $byr  = $byr_alt;
                                     $emon = $emon_alt;
                                     $eday = $eday_alt;
                                     $eyr  = $eyr_alt;
                                 } else {
                                     $bmon = $bmon_sav;
                                     $bday = $bday_sav;
                                     $byr  = $byr_sav;
                                     $emon = $emon_sav;
                                     $eday = $eday_sav;
                                     $eyr  = $eyr_sav;
                                 }
                             }
                             $dates_opt_sav = $dates_opt;
                           }
                     );

    $row++;
    $f->new_label(
            -text => "Start Date: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($bdate_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w');
    ($bmon_cb = $bdate_frame->new_ttk__combobox(
            -textvariable => \$bmon,
            -values       => [ @mon_names ],
            -state        => 'readonly',
            -width        => 4,
            ))->g_pack(-side => 'left');
    $bmon_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($byr);
                          $bm = &list_match($bmon, @mon_names);
                          $bday_cb->configure(-values => [ 1 .. $days_in_month[$bm] ]);
                          $bday = $days_in_month[$bm] if ($bday > $days_in_month[$bm]);
                        }
                    );
    $bdate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($bday_cb = $bdate_frame->new_ttk__combobox(
            -textvariable => \$bday,
            -values       => [ 1 .. $days_in_month[$bm] ],
            -state        => 'readonly',
            -width        => 3,
            ))->g_pack(-side => 'left');
    $bdate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($byr_cb = $bdate_frame->new_ttk__combobox(
            -textvariable => \$byr,
            -values       => [ reverse($yr_min .. $yr_max) ],
            -state        => 'readonly',
            -width        => 5,
            ))->g_pack(-side => 'left');
    $byr_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($byr);
                          $bm = &list_match($bmon, @mon_names);
                          if ($bm == 1) {
                              $bday_cb->configure(-values => [ 1 .. $days_in_month[$bm] ]);
                              $bday = $days_in_month[$bm] if ($bday > $days_in_month[$bm]);
                          }
                          if ($byr == $yr_min || $byr == $yr_max) {
                              $yr_min -= 5 if ($byr == $yr_min);
                              $yr_max += 5 if ($byr == $yr_max);
                              $byr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                              $eyr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                          }
                        }
                    );

    $row++;
    $f->new_label(
            -text => "End Date: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($edate_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w');
    ($emon_cb = $edate_frame->new_ttk__combobox(
            -textvariable => \$emon,
            -values       => [ @mon_names ],
            -state        => 'readonly',
            -width        => 4,
            ))->g_pack(-side => 'left');
    $emon_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($eyr);
                          $em = &list_match($emon, @mon_names);
                          $eday_cb->configure(-values => [ 1 .. $days_in_month[$em] ]);
                          $eday = $days_in_month[$em] if ($eday > $days_in_month[$em]);
                        }
                    );
    $edate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($eday_cb = $edate_frame->new_ttk__combobox(
            -textvariable => \$eday,
            -values       => [ 1 .. $days_in_month[$em] ],
            -state        => 'readonly',
            -width        => 3,
            ))->g_pack(-side => 'left');
    $edate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($eyr_cb = $edate_frame->new_ttk__combobox(
            -textvariable => \$eyr,
            -values       => [ reverse($yr_min .. $yr_max) ],
            -state        => 'readonly',
            -width        => 5,
            ))->g_pack(-side => 'left');
    $eyr_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($eyr);
                          $em = &list_match($emon, @mon_names);
                          if ($em == 1) {
                              $eday_cb->configure(-values => [ 1 .. $days_in_month[$em] ]);
                              $eday = $days_in_month[$em] if ($eday > $days_in_month[$em]);
                          }
                          if ($eyr == $yr_min || $eyr == $yr_max) {
                              $yr_min -= 5 if ($eyr == $yr_min);
                              $yr_max += 5 if ($eyr == $yr_max);
                              $byr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                              $eyr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                          }
                        }
                    );

    $f->g_grid_columnconfigure(1, -weight => 1);

    $bmon_cb->configure(-state => 'disabled');
    $bday_cb->configure(-state => 'disabled');
    $byr_cb->configure(-state  => 'disabled');
    $emon_cb->configure(-state => 'disabled');
    $eday_cb->configure(-state => 'disabled');
    $eyr_cb->configure(-state  => 'disabled');

    Tkx::wm_resizable($ref_stats_menu,0,0);
    &adjust_window_position($ref_stats_menu);
    $ref_stats_menu->g_focus;
}


sub show_ref_stats {
    my ($id, $interp, $monthly, $dt_begin, $dt_end) = @_;
    my (
        $col, $estat_ref, $f, $frame, $geom, $m, $mon, $pstat_ref,
        $pstat2_ref, $ref_window, $row, $seg, $tol, $txt, $X, $x1, $x2,
        $Y, $y1, $y2,

        %elev_data, %parm_data, %ref_profile, %estats, %pstats, %pstats2,
       );

    $monthly     = 1    if (! defined($monthly)  || $monthly ne "0");
    $interp      = 0    if (! defined($interp)   || $interp  ne "1");
    $dt_begin    = -999 if (! defined($dt_begin) || $dt_begin !~ /^[12][0-9][0-9][0-9][01][0-9][0-3][0-9]/);
    $dt_end      = -999 if (! defined($dt_end)   || $dt_end   !~ /^[12][0-9][0-9][0-9][01][0-9][0-3][0-9]/);
    $tol         = $props{$id}{ref_tol};
    $seg         = $props{$id}{seg};
    %elev_data   = %{ $gr_props{$id}{elev_data} };
    %parm_data   = %{ $gr_props{$id}{parm_data} };
    %ref_profile = %{ $gr_props{$id}{ref_data}  };

    $status_line = "Computing fit statistics...";
    Tkx::update();

    ($pstat_ref, $pstat2_ref, $estat_ref)
            = &get_stats_ref_profile($id, $seg, $monthly, $tol, $interp, $dt_begin, $dt_end,
                                     \%elev_data, \%parm_data, \%ref_profile);
    undef %elev_data;
    undef %parm_data;
    undef %ref_profile;

    %pstats  = %{ $pstat_ref  };
    %pstats2 = %{ $pstat2_ref };
    %estats  = %{ $estat_ref  };
    $status_line = "";

#   Convert units, if needed
    if ($props{$id}{parm} eq "Temperature" && $props{$id}{parm_units} eq "Fahrenheit") {
        if ($pstats{n}{all} > 0) {
            $pstats{me}{all}   *= 1.8;
            $pstats{mae}{all}  *= 1.8;
            $pstats{rmse}{all} *= 1.8;
            if ($monthly) {
                for ($m=0; $m<12; $m++) {
                    $mon = $mon_names[$m];
                    if ($pstats{n}{$mon} > 0) {
                        $pstats{me}{$mon}   *= 1.8;
                        $pstats{mae}{$mon}  *= 1.8;
                        $pstats{rmse}{$mon} *= 1.8;
                    }
                }
            }
        }
        if ($pstats2{n}{all} > 0) {
            $pstats2{me}{all}   *= 1.8;
            $pstats2{mae}{all}  *= 1.8;
            $pstats2{rmse}{all} *= 1.8;
            if ($monthly) {
                for ($m=0; $m<12; $m++) {
                    $mon = $mon_names[$m];
                    if ($pstats2{n}{$mon} > 0) {
                        $pstats2{me}{$mon}   *= 1.8;
                        $pstats2{mae}{$mon}  *= 1.8;
                        $pstats2{rmse}{$mon} *= 1.8;
                    }
                }
            }
        }
    }
    if ($gr_props{$id}{yunits} eq "feet") {
        if ($estats{n}{all} > 0) {
            $estats{me}{all}   *= 3.28084;
            $estats{mae}{all}  *= 3.28084;
            $estats{rmse}{all} *= 3.28084;
            if ($monthly) {
                for ($m=0; $m<12; $m++) {
                    $mon = $mon_names[$m];
                    if ($estats{n}{$mon} > 0) {
                        $estats{me}{$mon}   *= 3.28084;
                        $estats{mae}{$mon}  *= 3.28084;
                        $estats{rmse}{$mon} *= 3.28084;
                    }
                }
            }
        }
    }

    ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $geom = sprintf("+%d+%d", $X+$x1+50, $Y+$y1+60);

    if ($interp) {
        if (defined($ref_stats_interp_window) && Tkx::winfo_exists($ref_stats_interp_window)) {
            if ($ref_stats_interp_window->g_wm_title()
                    eq "Profile Goodness-of-Fit Statistics (Vertically Interpolated)") {
                $ref_stats_interp_window->g_destroy();
                undef $ref_stats_interp_window;
            }
        }
        $ref_stats_interp_window = $main->new_toplevel();
        $ref_stats_interp_window->g_wm_transient($main);
        $ref_stats_interp_window->g_wm_title("Profile Goodness-of-Fit Statistics (Vertically Interpolated)");
        $ref_window = $ref_stats_interp_window;
    } else {
        if (defined($ref_stats_window) && Tkx::winfo_exists($ref_stats_window)) {
            if ($ref_stats_window->g_wm_title() eq "Profile Goodness-of-Fit Statistics") {
                $ref_stats_window->g_destroy();
                undef $ref_stats_window;
            }
        }
        $ref_stats_window = $main->new_toplevel();
        $ref_stats_window->g_wm_transient($main);
        $ref_stats_window->g_wm_title("Profile Goodness-of-Fit Statistics");
        $ref_window = $ref_stats_window;
    }
    $ref_window->configure(-cursor => $cursor_norm);
    $ref_window->g_wm_geometry($geom);

    $frame = $ref_window->new_frame();
    $frame->g_pack(-side => 'bottom');
    $frame->new_button(
            -text    => "OK",
            -command => sub { $ref_window->g_destroy();
                              undef $ref_window;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Save",
            -command => sub { my ($dir, $file, $fname, $m, $mon, $project_path, $vol);
                              $file = Tkx::tk___getSaveFile(
                                  -parent           => $ref_window,
                                  -title            => "Save Profile Statistics",
                                  -initialdir       => abs_path(),
                                  -defaultextension => ".txt",
                                  -filetypes => [ ['Text Files', '.txt'],
                                                  ['All Files',  '*'],
                                                ],
                                  );
                              if (defined($file) && $file ne "") {
                                  open (OUT, ">", $file)
                                      || return &pop_up_error($ref_window, "Unable to open\n$file");
                                  print OUT "# W2 Animator, version $version\n";
                                  print OUT "# File created: ", &get_datetime, "\n";
                                  if ($savefile ne "") {
                                      ($vol, $dir, $fname) = File::Spec->splitpath($savefile);
                                      $project_path = $vol . $dir;
                                      $file = File::Spec->rel2abs($savefile, $project_path);
                                      print OUT "# W2Anim project: $file\n";
                                  }
                                  if ($interp) {
                                      $txt = "# Modeled profiles were vertically interpolated to "
                                           . "match the measured vertical profile measurement points "
                                           . "for each comparison.\n";
                                  } else {
                                      $txt = "# Modeled profiles were NOT vertically interpolated. "
                                           . "Measured points were compared to modeled values for "
                                           . "the appropriate model layer.\n";
                                  }
                                  if ($dt_begin != -999 && $dt_end != -999) {
                                      $txt .= "# All\* = Dates in the range "
                                            . &date2datelabel($dt_begin, "Mon-DD-YYYY") . " to "
                                            . &date2datelabel($dt_end,   "Mon-DD-YYYY") . "\n\n";
                                  } else {
                                      $txt .= "# All\* = All available dates\n\n";
                                  }
                                  print OUT $txt;
                                  if ($estats{n}{all} > 0) {
                                      print OUT "\tGoodness-of-Fit Statistics";
                                      print OUT "\t\t\t\tMean Fit Statistics By Profile";
                                      print OUT "\t\t\t\tGoodness-of-Fit Statistics\n";
                                      print OUT "\t", $props{$id}{parm};
                                      print OUT "\t\t\t\t", $props{$id}{parm};
                                      print OUT "\t\t\t\tWater-Surface Elevation\n";
                                      print OUT "\t(", $props{$id}{parm_units}, ")";
                                      print OUT "\t\t\t\t(", $props{$id}{parm_units}, ")";
                                      print OUT "\t\t\t\t(", $gr_props{$id}{yunits}, ")\n";
                                      print OUT "\tn\tME\tMAE\tRMSE\tn\tME\tMAE\tRMSE\tn\tME\tMAE\tRMSE\n";
                                      print OUT "All\*\t", $pstats{n}{all};
                                      if ($pstats{me}{all} eq "na") {
                                          print OUT "\tna\tna\tna";
                                      } else {
                                          print OUT "\t", sprintf("%.4f",$pstats{me}{all});
                                          print OUT "\t", sprintf("%.4f",$pstats{mae}{all});
                                          print OUT "\t", sprintf("%.4f",$pstats{rmse}{all});
                                      }
                                      print OUT "\t", $pstats2{n}{all};
                                      if ($pstats2{me}{all} eq "na") {
                                          print OUT "\tna\tna\tna";
                                      } else {
                                          print OUT "\t", sprintf("%.4f",$pstats2{me}{all});
                                          print OUT "\t", sprintf("%.4f",$pstats2{mae}{all});
                                          print OUT "\t", sprintf("%.4f",$pstats2{rmse}{all});
                                      }
                                      print OUT "\t", $estats{n}{all};
                                      if ($estats{me}{all} eq "na") {
                                          print OUT "\tna\tna\tna\n";
                                      } else {
                                          print OUT "\t", sprintf("%.4f",$estats{me}{all});
                                          print OUT "\t", sprintf("%.4f",$estats{mae}{all});
                                          print OUT "\t", sprintf("%.4f",$estats{rmse}{all}), "\n";
                                      }
                                      if ($monthly) {
                                          for ($m=0; $m<12; $m++) {
                                              $mon = $mon_names[$m];
                                              print OUT "$mon\t", $pstats{n}{$mon};
                                              if ($pstats{me}{$mon} eq "na") {
                                                  print OUT "\tna\tna\tna";
                                              } else {
                                                  print OUT "\t", sprintf("%.4f",$pstats{me}{$mon});
                                                  print OUT "\t", sprintf("%.4f",$pstats{mae}{$mon});
                                                  print OUT "\t", sprintf("%.4f",$pstats{rmse}{$mon});
                                              }
                                              print OUT "\t", $pstats2{n}{$mon};
                                              if ($pstats2{me}{$mon} eq "na") {
                                                  print OUT "\tna\tna\tna";
                                              } else {
                                                  print OUT "\t", sprintf("%.4f",$pstats2{me}{$mon});
                                                  print OUT "\t", sprintf("%.4f",$pstats2{mae}{$mon});
                                                  print OUT "\t", sprintf("%.4f",$pstats2{rmse}{$mon});
                                              }
                                              print OUT "\t", $estats{n}{$mon};
                                              if ($estats{me}{$mon} eq "na") {
                                                  print OUT "\tna\tna\tna\n";
                                              } else {
                                                  print OUT "\t", sprintf("%.4f",$estats{me}{$mon});
                                                  print OUT "\t", sprintf("%.4f",$estats{mae}{$mon});
                                                  print OUT "\t", sprintf("%.4f",$estats{rmse}{$mon}), "\n";
                                              }
                                          }
                                      }
                                  } else {
                                      print OUT "\tGoodness-of-Fit Statistics";
                                      print OUT "\t\t\t\tMean Fit Statistics By Profile\n";
                                      print OUT "\t", $props{$id}{parm};
                                      print OUT "\t\t\t\t", $props{$id}{parm}, "\n";
                                      print OUT "\t(", $props{$id}{parm_units}, ")";
                                      print OUT "\t\t\t\t(", $props{$id}{parm_units}, ")\n";
                                      print OUT "\tn\tME\tMAE\tRMSE";
                                      print OUT "\tn\tME\tMAE\tRMSE\n";
                                      print OUT "All\*\t", $pstats{n}{all};
                                      if ($pstats{me}{all} eq "na") {
                                          print OUT "\tna\tna\tna";
                                      } else {
                                          print OUT "\t", sprintf("%.4f",$pstats{me}{all});
                                          print OUT "\t", sprintf("%.4f",$pstats{mae}{all});
                                          print OUT "\t", sprintf("%.4f",$pstats{rmse}{all});
                                      }
                                      print OUT "\t", $pstats2{n}{all};
                                      if ($pstats2{me}{all} eq "na") {
                                          print OUT "\tna\tna\tna\n";
                                      } else {
                                          print OUT "\t", sprintf("%.4f",$pstats2{me}{all});
                                          print OUT "\t", sprintf("%.4f",$pstats2{mae}{all});
                                          print OUT "\t", sprintf("%.4f",$pstats2{rmse}{all}), "\n";
                                      }
                                      if ($monthly) {
                                          for ($m=0; $m<12; $m++) {
                                              $mon = $mon_names[$m];
                                              print OUT "$mon\t", $pstats{n}{$mon};
                                              if ($pstats{me}{$mon} eq "na") {
                                                  print OUT "\tna\tna\tna";
                                              } else {
                                                  print OUT "\t", sprintf("%.4f",$pstats{me}{$mon});
                                                  print OUT "\t", sprintf("%.4f",$pstats{mae}{$mon});
                                                  print OUT "\t", sprintf("%.4f",$pstats{rmse}{$mon});
                                              }
                                              print OUT "\t", $pstats2{n}{$mon};
                                              if ($pstats2{me}{$mon} eq "na") {
                                                  print OUT "\tna\tna\tna\n";
                                              } else {
                                                  print OUT "\t", sprintf("%.4f",$pstats2{me}{$mon});
                                                  print OUT "\t", sprintf("%.4f",$pstats2{mae}{$mon});
                                                  print OUT "\t", sprintf("%.4f",$pstats2{rmse}{$mon}), "\n";
                                              }
                                          }
                                      }
                                  }
                                  close (OUT)
                                      || return &pop_up_error($ref_window, "Trouble closing\n$file");
                              }
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

    ($f = $ref_window->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_pack(-side => 'top');

    $row = 0;
    $col = 1;
    $f->new_label(
            -text   => "Goodness-of-Fit Statistics",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+1, -columnspan => 4);
    $row++;
    $f->new_label(
            -text   => $props{$id}{parm},
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+1, -columnspan => 4);
    $row++;
    $f->new_label(
            -text   => "(" . $props{$id}{parm_units} . ")",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+1, -columnspan => 4);

    $row++;
    if ($monthly) {
        $f->new_ttk__separator(
                -orient => 'vertical',
                )->g_grid(-row => $row, -rowspan => 17, -column => $col, -sticky => 'ns');
    } else {
        $f->new_ttk__separator(
                -orient => 'vertical',
                )->g_grid(-row => $row, -rowspan => 5, -column => $col, -sticky => 'ns');
    }
    $f->new_label(
            -text   => "n",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+1, -sticky => 's', -ipadx => 3, -pady => 2);
    $f->new_label(
            -text   => "Mean\nError",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+2, -sticky => 's', -ipadx => 3, -pady => 2);
    $f->new_label(
            -text   => "Mean\nAbsolute\nError",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+3, -sticky => 's', -ipadx => 3, -pady => 2);
    $f->new_label(
            -text   => "Root\nMean\nSquared\nError",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+4, -sticky => 's', -ipadx => 3, -pady => 2);

    $row++;
    $f->new_ttk__separator(
            -orient => 'horizontal',
            )->g_grid(-row => $row, -column => $col-1, -columnspan => 6, -sticky => 'ew');

    $row++;
    $f->new_label(
            -text   => "All\*",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col-1, -ipadx => 2, -pady => 2);
    $f->new_label(
            -text   => $pstats{n}{all},
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+1, -ipadx => 2, -pady => 2);
    $f->new_label(
            -text   => ($pstats{me}{all} eq "na") ? "na" : sprintf("%.4f",$pstats{me}{all}),
            -anchor => 'e',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+2, -ipadx => 2, -pady => 2);
    $f->new_label(
            -text   => ($pstats{mae}{all} eq "na") ? "na" : sprintf("%.4f",$pstats{mae}{all}),
            -anchor => 'e',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+3, -ipadx => 2, -pady => 2);
    $f->new_label(
            -text   => ($pstats{rmse}{all} eq "na") ? "na" : sprintf("%.4f",$pstats{rmse}{all}),
            -anchor => 'e',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+4, -ipadx => 2, -pady => 2);

    $row++;
    $f->new_ttk__separator(
            -orient => 'horizontal',
            )->g_grid(-row => $row, -column => $col-1, -columnspan => 6, -sticky => 'ew');

    if ($monthly) {
        for ($m=0; $m<12; $m++) {
            $mon = $mon_names[$m];
            $row++;
            $f->new_label(
                    -text   => $mon,
                    -anchor => 'center',
                    -font   => 'default',
                    )->g_grid(-row => $row, -column => $col-1, -ipadx => 2, -pady => 2);
            $f->new_label(
                    -text   => $pstats{n}{$mon},
                    -anchor => 'center',
                    -font   => 'default',
                    )->g_grid(-row => $row, -column => $col+1, -ipadx => 2, -pady => 2);
            $f->new_label(
                    -text   => ($pstats{me}{$mon} eq "na") ? "na" : sprintf("%.4f",$pstats{me}{$mon}),
                    -anchor => 'e',
                    -font   => 'default',
                    )->g_grid(-row => $row, -column => $col+2, -ipadx => 2, -pady => 2);
            $f->new_label(
                    -text   => ($pstats{mae}{$mon} eq "na") ? "na" : sprintf("%.4f",$pstats{mae}{$mon}),
                    -anchor => 'e',
                    -font   => 'default',
                    )->g_grid(-row => $row, -column => $col+3, -ipadx => 2, -pady => 2);
            $f->new_label(
                    -text   => ($pstats{rmse}{$mon} eq "na") ? "na" : sprintf("%.4f",$pstats{rmse}{$mon}),
                    -anchor => 'e',
                    -font   => 'default',
                    )->g_grid(-row => $row, -column => $col+4, -ipadx => 2, -pady => 2);
        }
        $row++;
        $f->new_ttk__separator(
                -orient => 'horizontal',
                )->g_grid(-row => $row, -column => $col-1, -columnspan => 6, -sticky => 'ew');
    }

    $row  = 0;
    $col += 5;
    $f->new_label(
            -text   => "Mean Fit Statistics By Profile",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+1, -columnspan => 4);
    $row++;
    $f->new_label(
            -text   => $props{$id}{parm},
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+1, -columnspan => 4);
    $row++;
    $f->new_label(
            -text   => "(" . $props{$id}{parm_units} . ")",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+1, -columnspan => 4);

    $row++;
    if ($monthly) {
        $f->new_ttk__separator(
                -orient => 'vertical',
                )->g_grid(-row => $row, -rowspan => 17, -column => $col, -sticky => 'ns');
    } else {
        $f->new_ttk__separator(
                -orient => 'vertical',
                )->g_grid(-row => $row, -rowspan => 5, -column => $col, -sticky => 'ns');
    }
    $f->new_label(
            -text   => "n",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+1, -sticky => 's', -ipadx => 3, -pady => 2);
    $f->new_label(
            -text   => "Mean\nError",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+2, -sticky => 's', -ipadx => 3, -pady => 2);
    $f->new_label(
            -text   => "Mean\nAbsolute\nError",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+3, -sticky => 's', -ipadx => 3, -pady => 2);
    $f->new_label(
            -text   => "Root\nMean\nSquared\nError",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+4, -sticky => 's', -ipadx => 3, -pady => 2);

    $row++;
    $f->new_ttk__separator(
            -orient => 'horizontal',
            )->g_grid(-row => $row, -column => $col, -columnspan => 5, -sticky => 'ew');

    $row++;
    $f->new_label(
            -text   => $pstats2{n}{all},
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+1, -ipadx => 2, -pady => 2);
    $f->new_label(
            -text   => ($pstats2{me}{all} eq "na") ? "na" : sprintf("%.4f",$pstats2{me}{all}),
            -anchor => 'e',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+2, -ipadx => 2, -pady => 2);
    $f->new_label(
            -text   => ($pstats2{mae}{all} eq "na") ? "na" : sprintf("%.4f",$pstats2{mae}{all}),
            -anchor => 'e',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+3, -ipadx => 2, -pady => 2);
    $f->new_label(
            -text   => ($pstats2{rmse}{all} eq "na") ? "na" : sprintf("%.4f",$pstats2{rmse}{all}),
            -anchor => 'e',
            -font   => 'default',
            )->g_grid(-row => $row, -column => $col+4, -ipadx => 2, -pady => 2);

    $row++;
    $f->new_ttk__separator(
            -orient => 'horizontal',
            )->g_grid(-row => $row, -column => $col, -columnspan => 5, -sticky => 'ew');

    if ($monthly) {
        for ($m=0; $m<12; $m++) {
            $mon = $mon_names[$m];
            $row++;
            $f->new_label(
                    -text   => $pstats2{n}{$mon},
                    -anchor => 'center',
                    -font   => 'default',
                    )->g_grid(-row => $row, -column => $col+1, -ipadx => 2, -pady => 2);
            $f->new_label(
                    -text   => ($pstats2{me}{$mon} eq "na") ? "na" : sprintf("%.4f",$pstats2{me}{$mon}),
                    -anchor => 'e',
                    -font   => 'default',
                    )->g_grid(-row => $row, -column => $col+2, -ipadx => 2, -pady => 2);
            $f->new_label(
                    -text   => ($pstats2{mae}{$mon} eq "na") ? "na" : sprintf("%.4f",$pstats2{mae}{$mon}),
                    -anchor => 'e',
                    -font   => 'default',
                    )->g_grid(-row => $row, -column => $col+3, -ipadx => 2, -pady => 2);
            $f->new_label(
                    -text   => ($pstats2{rmse}{$mon} eq "na") ? "na" : sprintf("%.4f",$pstats2{rmse}{$mon}),
                    -anchor => 'e',
                    -font   => 'default',
                    )->g_grid(-row => $row, -column => $col+4, -ipadx => 2, -pady => 2);
        }
        $row++;
        $f->new_ttk__separator(
                -orient => 'horizontal',
                )->g_grid(-row => $row, -column => $col, -columnspan => 5, -sticky => 'ew');
    }

    if ($estats{n}{all} > 0) {
        $row  = 0;
        $col += 5;
        $f->new_label(
                -text   => "Goodness-of-Fit Statistics",
                -anchor => 'center',
                -font   => 'default',
                )->g_grid(-row => $row, -column => $col+1, -columnspan => 4);
        $row++;
        $f->new_label(
                -text   => "Water-Surface Elevation",
                -anchor => 'center',
                -font   => 'default',
                )->g_grid(-row => $row, -column => $col+1, -columnspan => 4);
        $row++;
        $f->new_label(
                -text   => "(" . $gr_props{$id}{yunits} . ")",
                -anchor => 'center',
                -font   => 'default',
                )->g_grid(-row => $row, -column => $col+1, -columnspan => 4);

        $row++;
        if ($monthly) {
            $f->new_ttk__separator(
                    -orient => 'vertical',
                    )->g_grid(-row => $row, -rowspan => 17, -column => $col, -sticky => 'ns');
        } else {
            $f->new_ttk__separator(
                    -orient => 'vertical',
                    )->g_grid(-row => $row, -rowspan => 5, -column => $col, -sticky => 'ns');
        }
        $f->new_label(
                -text   => "n",
                -anchor => 'center',
                -font   => 'default',
                )->g_grid(-row => $row, -column => $col+1, -sticky => 's', -ipadx => 3, -pady => 2);
        $f->new_label(
                -text   => "Mean\nError",
                -anchor => 'center',
                -font   => 'default',
                )->g_grid(-row => $row, -column => $col+2, -sticky => 's', -ipadx => 3, -pady => 2);
        $f->new_label(
                -text   => "Mean\nAbsolute\nError",
                -anchor => 'center',
                -font   => 'default',
                )->g_grid(-row => $row, -column => $col+3, -sticky => 's', -ipadx => 3, -pady => 2);
        $f->new_label(
                -text   => "Root\nMean\nSquared\nError",
                -anchor => 'center',
                -font   => 'default',
                )->g_grid(-row => $row, -column => $col+4, -sticky => 's', -ipadx => 3, -pady => 2);

        $row++;
        $f->new_ttk__separator(
                -orient => 'horizontal',
                )->g_grid(-row => $row, -column => $col, -columnspan => 5, -sticky => 'ew');

        $row++;
        $f->new_label(
                -text   => $estats{n}{all},
                -anchor => 'center',
                -font   => 'default',
                )->g_grid(-row => $row, -column => $col+1, -ipadx => 2, -pady => 2);
        $f->new_label(
                -text   => ($estats{me}{all} eq "na") ? "na" : sprintf("%.4f",$estats{me}{all}),
                -anchor => 'e',
                -font   => 'default',
                )->g_grid(-row => $row, -column => $col+2, -ipadx => 2, -pady => 2);
        $f->new_label(
                -text   => ($estats{mae}{all} eq "na") ? "na" : sprintf("%.4f",$estats{mae}{all}),
                -anchor => 'e',
                -font   => 'default',
                )->g_grid(-row => $row, -column => $col+3, -ipadx => 2, -pady => 2);
        $f->new_label(
                -text   => ($estats{rmse}{all} eq "na") ? "na" : sprintf("%.4f",$estats{rmse}{all}),
                -anchor => 'e',
                -font   => 'default',
                )->g_grid(-row => $row, -column => $col+4, -ipadx => 2, -pady => 2);

        $row++;
        $f->new_ttk__separator(
                -orient => 'horizontal',
                )->g_grid(-row => $row, -column => $col, -columnspan => 5, -sticky => 'ew');

        if ($monthly) {
            for ($m=0; $m<12; $m++) {
                $mon = $mon_names[$m];
                $row++;
                $f->new_label(
                        -text   => $estats{n}{$mon},
                        -anchor => 'center',
                        -font   => 'default',
                        )->g_grid(-row => $row, -column => $col+1, -ipadx => 2, -pady => 2);
                $f->new_label(
                        -text   => ($estats{me}{$mon} eq "na") ? "na" : sprintf("%.4f",$estats{me}{$mon}),
                        -anchor => 'e',
                        -font   => 'default',
                        )->g_grid(-row => $row, -column => $col+2, -ipadx => 2, -pady => 2);
                $f->new_label(
                        -text   => ($estats{mae}{$mon} eq "na") ? "na" : sprintf("%.4f",$estats{mae}{$mon}),
                        -anchor => 'e',
                        -font   => 'default',
                        )->g_grid(-row => $row, -column => $col+3, -ipadx => 2, -pady => 2);
                $f->new_label(
                        -text   => ($estats{rmse}{$mon} eq "na") ? "na" : sprintf("%.4f",$estats{rmse}{$mon}),
                        -anchor => 'e',
                        -font   => 'default',
                        )->g_grid(-row => $row, -column => $col+4, -ipadx => 2, -pady => 2);
            }
            $row++;
            $f->new_ttk__separator(
                    -orient => 'horizontal',
                    )->g_grid(-row => $row, -column => $col, -columnspan => 5, -sticky => 'ew');
        }
    }

#   Footer info
    $row = ($monthly) ? 20 : 7;
    if ($interp) {
        $txt = "Modeled profiles were vertically interpolated to match the measured\n"
             . "vertical profile measurement points for each comparison.\n";
    } else {
        $txt = "Modeled profiles were NOT vertically interpolated.  Measured points\n"
             . "were compared to modeled values for the appropriate model layer.\n";
    }
    if ($dt_begin != -999 && $dt_end != -999) {
        $txt .= "\*All = Dates in the range "
              . &date2datelabel($dt_begin, "Mon-DD-YYYY") . " to "
              . &date2datelabel($dt_end,   "Mon-DD-YYYY");
    } else {
        $txt .= "\*All = All available dates.";
    }
    $f->new_ttk__separator(
            -orient => 'vertical',
            )->g_grid(-row => $row, -column => 1, -sticky => 'ns');
    $f->new_label(
            -text    => $txt,
            -anchor  => 'w',
            -justify => 'left',
            -font    => 'default',
            )->g_grid(-row => $row, -column => 2, -columnspan => 9, -ipadx => 2, -pady => 2);
    $f->new_ttk__separator(
            -orient => 'vertical',
            )->g_grid(-row => $row, -column => 11, -sticky => 'ns');

    Tkx::wm_resizable($ref_window,0,0);
    &adjust_window_position($ref_window);
    $ref_window->g_focus;
}


sub choose_datasets {
    my ($canv, $id, $X, $Y) = @_;
    my (
        $bdate_frame, $bday, $bday_alt, $bday_cb, $bday_sav, $bm, $bm_alt,
        $bmon, $bmon_alt, $bmon_cb, $bmon_sav, $byr, $byr_alt, $byr_cb,
        $byr_sav, $dat_color_label, $dat_choice, $dat_choice_cb, $dat_indx,
        $dat_show_label, $dates_cb, $dates_opt, $dates_opt_sav, $dt_begin,
        $dt_end, $edate_frame, $eday, $eday_alt, $eday_cb, $eday_sav, $em,
        $em_alt, $emon, $emon_alt, $emon_cb, $emon_sav, $eyr, $eyr_alt,
        $eyr_cb, $eyr_sav, $f, $frame, $geom, $link_id, $monthly, $n,
        $nsets, $ref_color_label, $ref_choice, $ref_choice_cb, $ref_indx,
        $ref_show_label, $row, $tol, $tol_frame, $ts_chars, $yr_max, $yr_min,

        @add_ts_text, @add_ts_color, @add_ts_show, @color, @date_ops,
        @names, @ref_text, @show, @ts_color, @ts_show, @ts_text,

        %add_ts_parms, %parms,
       );

    &end_select($canv, $id, 1);

    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($choose_sets_menu) && Tkx::winfo_exists($choose_sets_menu)) {
        if ($choose_sets_menu->g_wm_title() eq "Choose Datasets for Fit Statistics") {
            $choose_sets_menu->g_destroy();
            undef $choose_sets_menu;
        }
    }
    $choose_sets_menu = $main->new_toplevel();
    $choose_sets_menu->g_wm_transient($main);
    $choose_sets_menu->g_wm_title("Choose Datasets for Fit Statistics");
    $choose_sets_menu->configure(-cursor => $cursor_norm);
    $choose_sets_menu->g_wm_geometry($geom);

#   Try to keep the nascent graph from being selected. Reset bindings later.
    $canv->g_bind("<Motion>", "");

#   Set variable for dataset selection
    %add_ts_parms = %{ $props{$id}{add_ts_parms} };
    @add_ts_text  = @{ $add_ts_parms{ts_text}    };
    @add_ts_color = @{ $add_ts_parms{ts_color}   };
    @add_ts_show  = @{ $add_ts_parms{ts_show}    };

    $monthly   = 1;
    $tol       = 10;
    $dat_indx  = $ts_chars = 0;
    @ts_text   = @ts_color = @ts_show = ();
    $dates_opt = $dates_opt_sav = "Include all dates";

    ($dt_begin, $dt_end, undef, undef) = &find_ts_limits($id);
    ($bm, $bday, $byr) = &parse_date($dt_begin, 1);
    ($em, $eday, $eyr) = &parse_date(&jdate2date(&ceil(&date2jdate($dt_end))), 1);
    $bm--;
    $em--;
    $bday    += 0;
    $eday    += 0;
    $bmon     = $mon_names[$bm];
    $emon     = $mon_names[$em];
    $bday_sav = $bday;
    $eday_sav = $eday;
    $bmon_sav = $bmon;
    $emon_sav = $emon;
    $byr_sav  = $byr;
    $eyr_sav  = $eyr;
    $yr_max   = (localtime(time))[5] +1900;
    $yr_min   = $yr_max -25;
    $yr_min   = $byr if ($byr < $yr_min);
    $yr_max   = $eyr if ($eyr > $yr_max);

    if ($global_dt_limits) {
        ($bm_alt, $bday_alt, $byr_alt) = &parse_date($global_dt_begin, 1);
        ($em_alt, $eday_alt, $eyr_alt) = &parse_date($global_dt_end,   1);
        $bday_alt += 0;
        $eday_alt += 0;
        $bmon_alt  = $mon_names[$bm_alt-1];
        $emon_alt  = $mon_names[$em_alt-1];
        $yr_min    = $byr_alt if ($byr_alt < $yr_min);
        $yr_max    = $eyr_alt if ($eyr_alt > $yr_max);
        @date_ops  = ("Include all dates", "Use global date limits", "Custom date range");
    } else {
        @date_ops  = ("Include all dates", "Custom date range");
    }

    $nsets = -1;
    if ($props{$id}{meta} eq "linked_time_series") {
        $link_id = $props{$id}{link_id};
        %parms   = %{ $props{$id}{ts_parms} };
        @show    = @{ $parms{show}  };
        @color   = @{ $parms{color} };
        if ($parms{ts_type} eq "Water Surface Elevation") {
            $nsets++;
            $ts_text[$nsets]  = "WS Elev";
            $ts_color[$nsets] = $color[0];
            $ts_show[$nsets]  = ($show[0]) ? "active" : "hidden";
            $ts_chars         = 7;

        } elsif ($parms{ts_type} =~ /Flow|Temperature/) {
            @names = @{ $gr_props{$link_id}{names} };
            push (@names, "All Outlets");
            for ($n=0; $n<=$#names; $n++) {
                $nsets++;
                $ts_text[$nsets]  = $names[$n];
                $ts_color[$nsets] = $color[$n];
                $ts_show[$nsets]  = ($show[$n]) ? "active" : "hidden";
                $ts_chars = length($names[$n]) if (length($names[$n]) > $ts_chars);
            }
        }
    }
    for ($n=0; $n<=$#add_ts_text; $n++) {
        $nsets++;
        $ts_text[$nsets]  = $add_ts_text[$n];
        $ts_color[$nsets] = $add_ts_color[$n];
        $ts_show[$nsets]  = ($add_ts_show[$n]) ? "active" : "hidden";
        $ts_chars = length($add_ts_text[$n]) if (length($add_ts_text[$n]) > $ts_chars);
        $ref_indx = $nsets if (($n == 0 && $props{$id}{meta} eq "linked_time_series") ||
                               ($n == 1 && $props{$id}{meta} eq "time_series"));
    }

#   Exit early if insufficient datasets present
    if ($nsets < 1) {
        $choose_sets_menu->g_destroy();
        undef $choose_sets_menu;
        &reset_bindings;
        return;
    }

#   Set the initial choices
    @ref_text   = @ts_text[1..$nsets];
    $dat_choice = $ts_text[$dat_indx];
    $ref_choice = $ts_text[$ref_indx];

#   Make the menu and its options
    $frame = $choose_sets_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    $frame->new_button(
            -text    => "OK",
            -command => sub { my ($m);
                              if ($dates_opt eq "Include all dates") {
                                  $dt_begin = $dt_end = -999;
                              } elsif ($global_dt_limits && $dates_opt eq "Use global date limits") {
                                  $dt_begin = $global_dt_begin;
                                  $dt_end   = $global_dt_end;
                              } else {
                                  $m        = &list_match($bmon, @mon_names);
                                  $dt_begin = sprintf("%04d%02d%02d0000", $byr, $m+1, $bday);
                                  $m        = &list_match($emon, @mon_names);
                                  $dt_end   = sprintf("%04d%02d%02d0000", $eyr, $m+1, $eday);
                                  if ($dt_begin > $dt_end) {
                                      return &pop_up_error($choose_sets_menu,
                                                  "The start date is after the end date.\n"
                                                . "Please adjust and try again.");
                                  } elsif ($dt_begin == $dt_end) {
                                      return &pop_up_error($choose_sets_menu,
                                                  "The start date is equal to the end date.\n"
                                                . "Please adjust and try again.");
                                  }
                              }

                              $choose_sets_menu->g_bind('<Destroy>', "");
                              $choose_sets_menu->g_destroy();
                              undef $choose_sets_menu;
                              &reset_bindings;

                              &show_ts_stats($id, $dat_indx, $ref_indx, $tol, $monthly, $dt_begin, $dt_end);
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $choose_sets_menu->g_bind('<Destroy>', "");
                              $choose_sets_menu->g_destroy();
                              undef $choose_sets_menu;
                              &reset_bindings;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Clean up if this menu is destroyed by other than the Cancel button
    $choose_sets_menu->g_bind('<Destroy>' => sub { undef $choose_sets_menu;
                                                   &reset_bindings;
                                                 });

    ($f = $choose_sets_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "Choose datasets and options for fit statistic computation:",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -columnspan => 4, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Test Dataset: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($dat_choice_cb = $f->new_ttk__combobox(
            -textvariable => \$dat_choice,
            -values       => [ @ts_text ],
            -width        => $ts_chars,
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $dat_choice_cb->g_bind("<<ComboboxSelected>>",
                            sub { $dat_indx = &list_match($dat_choice, @ts_text);
                                  $dat_color_label->configure(-background
                                                              => &get_rgb_code($ts_color[$dat_indx]));
                                  $dat_show_label->configure(-text => $ts_show[$dat_indx]);
                                  @ref_text = ();
                                  for ($n=0; $n<=$#ts_text; $n++) {
                                      push (@ref_text, $ts_text[$n]) if ($n != $dat_indx);
                                  }
                                  $ref_choice_cb->configure(-values => [ @ref_text ]);
                                  if ($ref_indx == $dat_indx) {
                                      if ($ref_indx < $nsets) {
                                          $ref_indx++;
                                      } else {
                                          $ref_indx--;
                                      }
                                      $ref_choice = $ts_text[$ref_indx];
                                      $ref_color_label->configure(-background
                                                                  => &get_rgb_code($ts_color[$ref_indx]));
                                      $ref_show_label->configure(-text => $ts_show[$ref_indx]);
                                  }
                                });
    ($dat_color_label = $f->new_label(
            -text        => " ",
            -width       => 5,
            -anchor      => 'w',
            -font        => 'sm',
            -background  => &get_rgb_code($ts_color[$dat_indx]),
            -relief      => 'flat',
            -borderwidth => 0,
            ))->g_grid(-row => $row, -column => 2, -sticky => 'ew', -padx => 3, -pady => 2);
    ($dat_show_label = $f->new_label(
            -text => $ts_show[$dat_indx],
            -font => 'default',
            ))->g_grid(-row => $row, -column => 3, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Reference Dataset: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($ref_choice_cb = $f->new_ttk__combobox(
            -textvariable => \$ref_choice,
            -values       => [ @ref_text ],
            -width        => $ts_chars,
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w', -pady => 2);
    $ref_choice_cb->g_bind("<<ComboboxSelected>>",
                            sub { $ref_indx = &list_match($ref_choice, @ts_text);
                                  $ref_color_label->configure(-background
                                                              => &get_rgb_code($ts_color[$ref_indx]));
                                  $ref_show_label->configure(-text => $ts_show[$ref_indx]);
                                });
    ($ref_color_label = $f->new_label(
            -text        => " ",
            -width       => 5,
            -anchor      => 'w',
            -font        => 'sm',
            -background  => &get_rgb_code($ts_color[$ref_indx]),
            -relief      => 'flat',
            -borderwidth => 0,
            ))->g_grid(-row => $row, -column => 2, -sticky => 'ew', -padx => 3, -pady => 2);
    ($ref_show_label = $f->new_label(
            -text => $ts_show[$ref_indx],
            -font => 'default',
            ))->g_grid(-row => $row, -column => 3, -sticky => 'w', -pady => 2);

    $row++;
    $f->new_label(
            -text => "Match Tolerance: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($tol_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w');
    $tol_frame->new_spinbox(
            -textvariable => \$tol,
            -state        => 'readonly',
            -font         => 'default',
            -from         => 0,
            -to           => 60,
            -increment    => 1,
            -width        => 3,
            )->g_pack(-side => 'left', -anchor => 'w', -pady => 2);
    $tol_frame->new_label(
            -text => " minutes",
            -font => 'default',
            )->g_pack(-side => 'left', -anchor => 'w');

    $row++;
    $f->new_label(
            -text => "Options: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $f->new_checkbutton(
            -onvalue  => 1,
            -offvalue => 0,
            -text     => "Include stats by month",
            -font     => 'default',
            -variable => \$monthly,
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w');

    $row++;
    $f->new_label(
            -text => "Date Range: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($dates_cb = $f->new_ttk__combobox(
            -textvariable => \$dates_opt,
            -values       => [ @date_ops ],
            -state        => 'readonly',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w');
    $dates_cb->g_bind("<<ComboboxSelected>>",
                       sub { return if ($dates_opt eq $dates_opt_sav);
                             if ($dates_opt eq "Custom date range") {
                                 $bmon_cb->configure(-state => 'readonly');
                                 $bday_cb->configure(-state => 'readonly');
                                 $byr_cb->configure(-state  => 'readonly');
                                 $emon_cb->configure(-state => 'readonly');
                                 $eday_cb->configure(-state => 'readonly');
                                 $eyr_cb->configure(-state  => 'readonly');
                             } else {
                                 $bmon_cb->configure(-state => 'disabled');
                                 $bday_cb->configure(-state => 'disabled');
                                 $byr_cb->configure(-state  => 'disabled');
                                 $emon_cb->configure(-state => 'disabled');
                                 $eday_cb->configure(-state => 'disabled');
                                 $eyr_cb->configure(-state  => 'disabled');
                                 if ($dates_opt eq "Use global date limits") {
                                     $bmon = $bmon_alt;
                                     $bday = $bday_alt;
                                     $byr  = $byr_alt;
                                     $emon = $emon_alt;
                                     $eday = $eday_alt;
                                     $eyr  = $eyr_alt;
                                 } else {
                                     $bmon = $bmon_sav;
                                     $bday = $bday_sav;
                                     $byr  = $byr_sav;
                                     $emon = $emon_sav;
                                     $eday = $eday_sav;
                                     $eyr  = $eyr_sav;
                                 }
                             }
                             $dates_opt_sav = $dates_opt;
                           }
                     );

    $row++;
    $f->new_label(
            -text => "Start Date: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($bdate_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w');
    ($bmon_cb = $bdate_frame->new_ttk__combobox(
            -textvariable => \$bmon,
            -values       => [ @mon_names ],
            -state        => 'readonly',
            -width        => 4,
            ))->g_pack(-side => 'left');
    $bmon_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($byr);
                          $bm = &list_match($bmon, @mon_names);
                          $bday_cb->configure(-values => [ 1 .. $days_in_month[$bm] ]);
                          $bday = $days_in_month[$bm] if ($bday > $days_in_month[$bm]);
                        }
                    );
    $bdate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($bday_cb = $bdate_frame->new_ttk__combobox(
            -textvariable => \$bday,
            -values       => [ 1 .. $days_in_month[$bm] ],
            -state        => 'readonly',
            -width        => 3,
            ))->g_pack(-side => 'left');
    $bdate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($byr_cb = $bdate_frame->new_ttk__combobox(
            -textvariable => \$byr,
            -values       => [ reverse($yr_min .. $yr_max) ],
            -state        => 'readonly',
            -width        => 5,
            ))->g_pack(-side => 'left');
    $byr_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($byr);
                          $bm = &list_match($bmon, @mon_names);
                          if ($bm == 1) {
                              $bday_cb->configure(-values => [ 1 .. $days_in_month[$bm] ]);
                              $bday = $days_in_month[$bm] if ($bday > $days_in_month[$bm]);
                          }
                          if ($byr == $yr_min || $byr == $yr_max) {
                              $yr_min -= 5 if ($byr == $yr_min);
                              $yr_max += 5 if ($byr == $yr_max);
                              $byr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                              $eyr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                          }
                        }
                    );

    $row++;
    $f->new_label(
            -text => "End Date: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($edate_frame = $f->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'w');
    ($emon_cb = $edate_frame->new_ttk__combobox(
            -textvariable => \$emon,
            -values       => [ @mon_names ],
            -state        => 'readonly',
            -width        => 4,
            ))->g_pack(-side => 'left');
    $emon_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($eyr);
                          $em = &list_match($emon, @mon_names);
                          $eday_cb->configure(-values => [ 1 .. $days_in_month[$em] ]);
                          $eday = $days_in_month[$em] if ($eday > $days_in_month[$em]);
                        }
                    );
    $edate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($eday_cb = $edate_frame->new_ttk__combobox(
            -textvariable => \$eday,
            -values       => [ 1 .. $days_in_month[$em] ],
            -state        => 'readonly',
            -width        => 3,
            ))->g_pack(-side => 'left');
    $edate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($eyr_cb = $edate_frame->new_ttk__combobox(
            -textvariable => \$eyr,
            -values       => [ reverse($yr_min .. $yr_max) ],
            -state        => 'readonly',
            -width        => 5,
            ))->g_pack(-side => 'left');
    $eyr_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($eyr);
                          $em = &list_match($emon, @mon_names);
                          if ($em == 1) {
                              $eday_cb->configure(-values => [ 1 .. $days_in_month[$em] ]);
                              $eday = $days_in_month[$em] if ($eday > $days_in_month[$em]);
                          }
                          if ($eyr == $yr_min || $eyr == $yr_max) {
                              $yr_min -= 5 if ($eyr == $yr_min);
                              $yr_max += 5 if ($eyr == $yr_max);
                              $byr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                              $eyr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                          }
                        }
                    );

    $f->g_grid_columnconfigure(3, -weight => 2);

    $bmon_cb->configure(-state => 'disabled');
    $bday_cb->configure(-state => 'disabled');
    $byr_cb->configure(-state  => 'disabled');
    $emon_cb->configure(-state => 'disabled');
    $eday_cb->configure(-state => 'disabled');
    $eyr_cb->configure(-state  => 'disabled');

    Tkx::wm_resizable($choose_sets_menu,0,0);
    &adjust_window_position($choose_sets_menu);
    $choose_sets_menu->g_focus;
}


sub show_ts_stats {
    my ($id, $dat_indx, $ref_indx, $tol, $monthly, $dt_begin, $dt_end) = @_;
    my (
        $dat_text, $dt, $f, $frame, $geom, $link_id, $m, $mon, $mult, $n,
        $nsets, $ref_text, $row, $txt, $wt, $X, $x1, $x2, $Y, $y1, $y2,

        @add_ts_text, @add_ts_tsdata, @names, @qstr, @tstr,

        %add_ts_parms, %data, %parms, %qdata, %ref_data, %stats, %tdata,
        %tmp,
       );

    $monthly  = 1    if (! defined($monthly)  || $monthly ne "0");
    $dt_begin = -999 if (! defined($dt_begin) || $dt_begin !~ /^[12][0-9][0-9][0-9][01][0-9][0-3][0-9]/);
    $dt_end   = -999 if (! defined($dt_end)   || $dt_end   !~ /^[12][0-9][0-9][0-9][01][0-9][0-3][0-9]/);

#   Find and set the datasets in date/time-indexed hashes
    $nsets = -1;
    if ($props{$id}{meta} eq "linked_time_series") {
        $link_id = $props{$id}{link_id};
        %parms   = %{ $props{$id}{ts_parms} };
        if ($parms{ts_type} eq "Water Surface Elevation") {
            $nsets++;
            if ($nsets == $dat_indx || $nsets == $ref_indx) {
                %tmp = %{ $gr_props{$link_id}{ws_elev} };
                if ($parms{units} eq "ft") {
                    foreach $dt (keys %tmp) {
                        $tmp{$dt} *= 3.28084 if (defined($tmp{$dt}) && $tmp{$dt} ne "na");
                    }
                }
                if ($nsets == $dat_indx) {
                    %data     = %tmp;
                    $dat_text = "WS Elev (" . $parms{units} . ")";
                } else {
                    %ref_data = %tmp;
                    $ref_text = "WS Elev (" . $parms{units} . ")";
                }
            }
        } elsif ($parms{ts_type} eq "Flow") {
            %qdata = %{ $gr_props{$link_id}{qdata} };
            @names = @{ $gr_props{$link_id}{names} };
            push (@names, "All Outlets");
            for ($n=0; $n<=$#names; $n++) {
                $nsets++;
                if ($nsets == $dat_indx || $nsets == $ref_indx) {
                    $mult = ($parms{units} eq "cfs") ? 35.31467 : 1.0;
                    %tmp  = ();
                    foreach $dt (keys %qdata) {
                        next if (! defined($qdata{$dt}));
                        @qstr = @{ $qdata{$dt} };
                        if ($names[$n] eq "All Outlets") {
                            $tmp{$dt} = &sum(@qstr) *$mult;
                        } else {
                            $tmp{$dt} = $qstr[$n] *$mult;
                        }
                    }
                    if ($nsets == $dat_indx) {
                        %data     = %tmp;
                        $dat_text = "Flow (" . $parms{units} . ") - " . $names[$n];
                    } else {
                        %ref_data = %tmp;
                        $ref_text = "Flow (" . $parms{units} . ") - " . $names[$n];
                    }
                }
            }
            undef %qdata;

        } elsif ($parms{ts_type} eq "Temperature") {
            %tdata = %{ $gr_props{$link_id}{tdata} };
            @names = @{ $gr_props{$link_id}{names} };
            push (@names, "All Outlets");
            for ($n=0; $n<=$#names; $n++) {
                $nsets++;
                if ($nsets == $dat_indx || $nsets == $ref_indx) {
                    %tmp = ();
                    foreach $dt (keys %tdata) {
                        next if (! defined($tdata{$dt}));
                        @tstr = @{ $tdata{$dt} };
                        $wt   = $tstr[$n];
                        if ($wt > -99) {
                            $wt = 1.8 *$wt +32 if ($parms{units} eq "Fahrenheit");
                            $tmp{$dt} = $wt;
                        }
                    }
                    if ($nsets == $dat_indx) {
                        %data     = %tmp;
                        $dat_text = "Temperature (" . substr($parms{units},0,1) . ") - " . $names[$n];
                    } else {
                        %ref_data = %tmp;
                        $ref_text = "Temperature (" . substr($parms{units},0,1) . ") - " . $names[$n];
                    }
                }
            }
            undef %tdata;
        }
    }

    %add_ts_parms  = %{ $props{$id}{add_ts_parms} };
    @add_ts_text   = @{ $add_ts_parms{ts_text}    };
    @add_ts_tsdata = @{ $add_ts_parms{ts_data}    };
    for ($n=0; $n<=$#add_ts_tsdata; $n++) {
        $nsets++;
        if ($nsets == $dat_indx) {
            %data     = %{ $add_ts_tsdata[$n] };
            $dat_text = $add_ts_text[$n];
        } elsif ($nsets == $ref_indx) {
            %ref_data = %{ $add_ts_tsdata[$n] };
            $ref_text = $add_ts_text[$n];
        }
    }

#   Calculate the goodness-of-fit statistics
    %stats = &get_ts_stats(\%data, \%ref_data, $monthly, $tol, $dt_begin, $dt_end);
    undef %data;
    undef %ref_data;

#   Report the stats to the user
    ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $geom = sprintf("+%d+%d", $X+$x1+50, $Y+$y1+60);

    if (defined($ts_stats_window) && Tkx::winfo_exists($ts_stats_window)) {
        if ($ts_stats_window->g_wm_title() eq "TS Goodness-of-Fit Statistics") {
            $ts_stats_window->g_destroy();
            undef $ts_stats_window;
        }
    }
    $ts_stats_window = $main->new_toplevel();
    $ts_stats_window->g_wm_transient($main);
    $ts_stats_window->g_wm_title("TS Goodness-of-Fit Statistics");
    $ts_stats_window->configure(-cursor => $cursor_norm);
    $ts_stats_window->g_wm_geometry($geom);

    $frame = $ts_stats_window->new_frame();
    $frame->g_pack(-side => 'bottom');
    $frame->new_button(
            -text    => "OK",
            -command => sub { $ts_stats_window->g_destroy();
                              undef $ts_stats_window;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Save",
            -command => sub { my ($dir, $file, $fname, $m, $mon, $project_path, $vol);
                              $file = Tkx::tk___getSaveFile(
                                  -parent           => $ts_stats_window,
                                  -title            => "Save Time-Series Statistics",
                                  -initialdir       => abs_path(),
                                  -defaultextension => ".txt",
                                  -filetypes => [ ['Text Files', '.txt'],
                                                  ['All Files',  '*'],
                                                ],
                                  );
                              if (defined($file)) {
                                  open (OUT, ">", $file)
                                      || return &pop_up_error($ts_stats_window, "Unable to open\n$file");
                                  print OUT "# W2 Animator, version $version\n";
                                  print OUT "# File created: ", &get_datetime, "\n";
                                  if ($savefile ne "") {
                                      ($vol, $dir, $fname) = File::Spec->splitpath($savefile);
                                      $project_path = $vol . $dir;
                                      $file = File::Spec->rel2abs($savefile, $project_path);
                                      print OUT "# W2Anim project: $file\n";
                                  }
                                  print OUT "# Time-Series Goodness-of-Fit Statistics\n";
                                  if ($dt_begin != -999 && $dt_end != -999) {
                                      print OUT "# All\* = Dates in the range "
                                            . &date2datelabel($dt_begin, "Mon-DD-YYYY") . " to "
                                            . &date2datelabel($dt_end,   "Mon-DD-YYYY") . "\n";
                                  } else {
                                      print OUT "# All\* = All available dates\n";
                                  }
                                  print OUT "#\n";
                                  print OUT "Goodness-of-Fit Statistics\n";
                                  print OUT "Test dataset:  $dat_text\n";
                                  print OUT "Reference dataset:  $ref_text\n";
                                  print OUT "\tn\tME\tMAE\tRMSE\n";
                                  print OUT "All\t", $stats{n}{all};
                                  if ($stats{me}{all} eq "na") {
                                      print OUT "\tna\tna\tna\n";
                                  } else {
                                      print OUT "\t", sprintf("%.4f",$stats{me}{all});
                                      print OUT "\t", sprintf("%.4f",$stats{mae}{all});
                                      print OUT "\t", sprintf("%.4f",$stats{rmse}{all}), "\n";
                                  }
                                  if ($monthly) {
                                      for ($m=0; $m<12; $m++) {
                                          $mon = $mon_names[$m];
                                          print OUT "$mon\t", $stats{n}{$mon};
                                          if ($stats{me}{$mon} eq "na") {
                                              print OUT "\tna\tna\tna\n";
                                          } else {
                                              print OUT "\t", sprintf("%.4f",$stats{me}{$mon});
                                              print OUT "\t", sprintf("%.4f",$stats{mae}{$mon});
                                              print OUT "\t", sprintf("%.4f",$stats{rmse}{$mon}), "\n";
                                          }
                                      }
                                  }
                                  close (OUT)
                                      || return &pop_up_error($ts_stats_window, "Trouble closing\n$file");
                              }
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

    ($f = $ts_stats_window->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text   => "Goodness-of-Fit Statistics",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => 0, -columnspan => 5);
    $row++;
    $f->new_label(
            -text   => "Test: " . $dat_text,
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => 0, -columnspan => 5);
    $row++;
    $f->new_label(
            -text   => "Reference: " . $ref_text,
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => 0, -columnspan => 5);

    $row++;
    $f->new_label(
            -text   => "n",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => 1, -sticky => 's', -ipadx => 3, -pady => 2);
    $f->new_label(
            -text   => "Mean\nError",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => 2, -sticky => 's', -ipadx => 3, -pady => 2);
    $f->new_label(
            -text   => "Mean\nAbsolute\nError",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => 3, -sticky => 's', -ipadx => 3, -pady => 2);
    $f->new_label(
            -text   => "Root\nMean\nSquared\nError",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => 4, -sticky => 's', -ipadx => 3, -pady => 2);

    $row++;
    $f->new_ttk__separator(
            -orient => 'horizontal',
            )->g_grid(-row => $row, -column => 0, -columnspan => 5, -sticky => 'ew');

    $row++;
    $f->new_label(
            -text   => "All\*",
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => 0, -ipadx => 2, -pady => 2);
    $f->new_label(
            -text   => $stats{n}{all},
            -anchor => 'center',
            -font   => 'default',
            )->g_grid(-row => $row, -column => 1, -ipadx => 2, -pady => 2);
    $f->new_label(
            -text   => ($stats{me}{all} eq "na") ? "na" : sprintf("%.4f",$stats{me}{all}),
            -anchor => 'e',
            -font   => 'default',
            )->g_grid(-row => $row, -column => 2, -ipadx => 2, -pady => 2);
    $f->new_label(
            -text   => ($stats{mae}{all} eq "na") ? "na" : sprintf("%.4f",$stats{mae}{all}),
            -anchor => 'e',
            -font   => 'default',
            )->g_grid(-row => $row, -column => 3, -ipadx => 2, -pady => 2);
    $f->new_label(
            -text   => ($stats{rmse}{all} eq "na") ? "na" : sprintf("%.4f",$stats{rmse}{all}),
            -anchor => 'e',
            -font   => 'default',
            )->g_grid(-row => $row, -column => 4, -ipadx => 2, -pady => 2);
    $row++;
    $f->new_ttk__separator(
            -orient => 'horizontal',
            )->g_grid(-row => $row, -column => 0, -columnspan => 5, -sticky => 'ew');

    if ($monthly) {
        for ($m=0; $m<12; $m++) {
            $mon = $mon_names[$m];
            $row++;
            $f->new_label(
                    -text   => $mon,
                    -anchor => 'center',
                    -font   => 'default',
                    )->g_grid(-row => $row, -column => 0, -ipadx => 2, -pady => 2);
            $f->new_label(
                    -text   => $stats{n}{$mon},
                    -anchor => 'center',
                    -font   => 'default',
                    )->g_grid(-row => $row, -column => 1, -ipadx => 2, -pady => 2);
            $f->new_label(
                    -text   => ($stats{me}{$mon} eq "na") ? "na" : sprintf("%.4f",$stats{me}{$mon}),
                    -anchor => 'e',
                    -font   => 'default',
                    )->g_grid(-row => $row, -column => 2, -ipadx => 2, -pady => 2);
            $f->new_label(
                    -text   => ($stats{mae}{$mon} eq "na") ? "na" : sprintf("%.4f",$stats{mae}{$mon}),
                    -anchor => 'e',
                    -font   => 'default',
                    )->g_grid(-row => $row, -column => 3, -ipadx => 2, -pady => 2);
            $f->new_label(
                    -text   => ($stats{rmse}{$mon} eq "na") ? "na" : sprintf("%.4f",$stats{rmse}{$mon}),
                    -anchor => 'e',
                    -font   => 'default',
                    )->g_grid(-row => $row, -column => 4, -ipadx => 2, -pady => 2);
        }
        $row++;
        $f->new_ttk__separator(
                -orient => 'horizontal',
                )->g_grid(-row => $row, -column => 0, -columnspan => 5, -sticky => 'ew');
    }

#   Footer info
    $row++;
    if ($dt_begin != -999 && $dt_end != -999) {
        $txt = "Dates in the range\n" . &date2datelabel($dt_begin, "Mon-DD-YYYY") . " to "
                                      . &date2datelabel($dt_end,   "Mon-DD-YYYY");
        $f->new_label(
                -text => "\*All =",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'nw', -ipadx => 2, -pady => 2);
        $f->new_label(
                -text    => $txt,
                -justify => 'left',
                -font    => 'default',
                )->g_grid(-row => $row, -column => 1, -columnspan => 4,
                          -sticky => 'w', -ipadx => 2, -pady => 2);
    } else {
        $f->new_label(
                -text => "\*All = All available dates",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -columnspan => 5,
                          -sticky => 'w', -ipadx => 2, -pady => 2);
    }

    Tkx::wm_resizable($ts_stats_window,0,0);
    &adjust_window_position($ts_stats_window);
    $ts_stats_window->g_focus;
}


################################################################################
#
# Standard graph parts
#
################################################################################

sub make_axis {
    my ($canv, %axis_props) = @_;
    my (
        $add_minor, $anc, $ang, $axmax, $axmin, $d, $d1, $d2, $d3, $fac,
        $family, $first, $fmt, $gr1, $gr2, $grcolor, $grid, $gridtags,
        $grwidth, $i, $id, $label, $label_size, $label_weight, $major,
        $min_major, $minor, $nt, $op_loc, $op_tags, $op_tics, $orient,
        $power, $pr_tics, $range, $reverse, $side, $tag, $tags, $title,
        $title_size, $title_weight, $tmp, $tsize, $x1, $x2, $xp1, $xp1o,
        $xp2, $xp2o, $xp3, $xp4, $xp4o, $xp5, $xp5o, $y1, $y2, $yp1, $yp1o,
        $yp2, $yp2o, $yp3, $yp4, $yp4o, $yp5, $yp5o,

        @coords, @taglist,
       );

    $family       = $axis_props{font};
    $label_size   = $axis_props{size1};
    $title_size   = $axis_props{size2};
    $label_weight = $axis_props{weight1};
    $title_weight = $axis_props{weight2};

    $axmin   = $axis_props{min};
    $axmax   = $axis_props{max};
    $first   = $axis_props{first} if (defined($axis_props{first}));
    $major   = $axis_props{major};
    $minor   = $axis_props{minor};     # 0 = no, 1 = yes
    $reverse = $axis_props{reverse};   # 0 = no, 1 = yes
    $title   = $axis_props{title};
    $side    = $axis_props{side};      # left, right, top, bottom
    $pr_tics = $axis_props{pr_tics};   # primary side:   inside, outside, cross, none
    $op_tics = $axis_props{op_tics};   # opposite side:  inside, outside, cross, none
    $op_loc  = $axis_props{op_loc};    # opposite side coordinate
    $tags    = $axis_props{tags};

    if (defined($axis_props{grid})) {
        $grid        = $axis_props{grid};
        $grwidth     = $axis_props{grwidth};
        $grcolor     = $axis_props{grcolor};
        ($gr1, $gr2) = @{ $axis_props{grcoord} };
        ($gridtags = $tags) =~ s/_.axis$/_grid/;
    } else {
        $grid = 0;
    }
    if ($op_tics ne "none") {
        $op_tags = $tags;
        @taglist = split(/ /, $op_tags);
        foreach $tag (@taglist) {
            if ($tag =~ /_.axis$/) {
                $op_tags .= " " . $tag . "2";
                last;
            }
        }
    }
    $title =~ s/^"//;
    $title =~ s/"$//;
    $tsize =  0;

    ($x1, $y1, $x2, $y2) = @{ $axis_props{coords} };

    if ($axmin > $axmax) {
        $axmin = $axis_props{max};
        $axmax = $axis_props{min};
    } elsif ($axmin == $axmax) {
        &pop_up_error($main, "Axis minimum and maximum values are identical");
        return;
    }
    if ($reverse) {
        $first = $axmax if (! defined($first) || $first eq "");
    } else {
        $first = $axmin if (! defined($first) || $first eq "");
    }
    if ($major ne "auto") {
        $major *= -1     if ($major+0  < 0);
        $major  = "auto" if ($major+0 == 0);
    }
    $minor *= -1 if ($minor < 0);
    if ($y1 == $y2) {
        $orient = "horizontal";
        $side   = "bottom" if (! defined($side) || $side ne "top");
    } elsif ($x1 == $x2) {
        $orient = "vertical";
        $side   = "left" if (! defined($side) || $side ne "right");
    } else {
        &pop_up_error($main, "Invalid coordinates for axis");
        return;
    }
    if ($op_tics ne "none") {
        if ($orient eq "horizontal") {
            $op_tics = "none" if ($op_loc == $y1 || ($side eq "bottom" && $op_loc > $y1)
                                                 || ($side eq "top"    && $op_loc < $y1));
        } else {
            $op_tics = "none" if ($op_loc == $x1 || ($side eq "left"  && $op_loc < $x1)
                                                 || ($side eq "right" && $op_loc > $x1));
        }
    }

#   Determine an optimal major tick spacing, if needed
    if ($major eq "auto") {
        $range  = $axmax-$axmin;
        $power  = (&log10($range) < 1) ? abs(&floor(&log10($range))) +1 : 0;
        $range *= 10**$power;
        if ($orient eq "horizontal") {
            $min_major = int($range *($label_size *3) /abs($x2-$x1) +0.0000001);
        } else {
            $min_major = int($range *($label_size *3) /abs($y2-$y1) +0.0000001);
        }
        $min_major = 1 if ($min_major == 0);
        for ($i=$min_major; $i<=$range/5; $i++) {
            $major = $i /(10**$power) if (&round_to_int($range) % $i == 0);
        }
        $major = $min_major /(10**$power) if ($major eq "auto");
    }

#   Determine an optimal number of digits after decimal
    $d   = 0;
    $fac = 1;
    $tmp = $major;
    until (abs($tmp*$fac - int($tmp*$fac)) < 0.00001 || $d == 3) {
        $d++;
        $fac = (10**$d);
    }
    $tmp = abs($first);
    until (abs($tmp*$fac - int($tmp*$fac)) < 0.00001 || $d == 3) {
        $d++;
        $fac = (10**$d);
    }
    $fmt = ($d == 0) ? "%d" : "%.${d}f";

#   Make major tick marks and labels
#   Default is increasing value left to right or bottom to top
    $ang = 0;
    if ($orient eq "horizontal") {
        $anc = ($side eq "bottom") ? 'n' : 's';
        $d1  = ($pr_tics eq "cross")       ? 4 : 0;
        $d2  = ($pr_tics eq "inside")      ? 8 : 0;
        $d3  = ($pr_tics =~ /inside|none/) ? 6 : 0;
        $yp1 = ($side eq "bottom") ? $y1-2*$d1   : $y1+2*$d1;   # major ticks
        $yp2 = ($side eq "bottom") ? $y1+8-2*$d2 : $y1-8+2*$d2; # major ticks
        $yp3 = ($side eq "bottom") ? $y1+9-$d3   : $y1-9+$d3;   # tick labels
        $yp4 = ($side eq "bottom") ? $y1-$d1     : $y1+$d1;     # minor ticks
        $yp5 = ($side eq "bottom") ? $y1+4-$d2   : $y1-4+$d2;   # minor ticks
        if ($op_tics ne "none") {
            $d1   = ($op_tics eq "cross")  ? 4 : 0;
            $d2   = ($op_tics eq "inside") ? 8 : 0;
            $yp1o = ($side eq "bottom") ? $op_loc+2*$d1   : $op_loc-2*$d1;   # major ticks
            $yp2o = ($side eq "bottom") ? $op_loc-8+2*$d2 : $op_loc+8-2*$d2; # major ticks
            $yp4o = ($side eq "bottom") ? $op_loc+$d1     : $op_loc-$d1;     # minor ticks
            $yp5o = ($side eq "bottom") ? $op_loc-4+$d2   : $op_loc+4-$d2;   # minor ticks
        }
    } else {
        $anc = ($side eq "left") ? 'e' : 'w';
        $d1  = ($pr_tics eq "cross")       ? 4 : 0;
        $d2  = ($pr_tics eq "inside")      ? 8 : 0;
        $d3  = ($pr_tics =~ /inside|none/) ? 6 : 0;
        $xp1 = ($side eq "left") ? $x1+2*$d1   : $x1-2*$d1;   # major ticks
        $xp2 = ($side eq "left") ? $x1-8+2*$d2 : $x1+8-2*$d2; # major ticks
        $xp3 = ($side eq "left") ? $x1-10+$d3  : $x1+10-$d3;  # tick labels
        $xp4 = ($side eq "left") ? $x1+$d1     : $x1-$d1;     # minor ticks
        $xp5 = ($side eq "left") ? $x1-4+$d2   : $x1+4-$d2;   # minor ticks
        if ($op_tics ne "none") {
            $d1   = ($op_tics eq "cross")  ? 4 : 0;
            $d2   = ($op_tics eq "inside") ? 8 : 0;
            $xp1o = ($side eq "left") ? $op_loc-2*$d1   : $op_loc+2*$d1;   # major ticks
            $xp2o = ($side eq "left") ? $op_loc+8-2*$d2 : $op_loc-8+2*$d2; # major ticks
            $xp4o = ($side eq "left") ? $op_loc-$d1     : $op_loc+$d1;     # minor ticks
            $xp5o = ($side eq "left") ? $op_loc+4-$d2   : $op_loc-4+$d2;   # minor ticks
        }
    }
    if ($reverse) {
        for ($i=$first; $i>=$axmin*0.999999; $i-=$major) {
            $label = sprintf($fmt, $i);
            if ($orient eq "horizontal") {
                $xp1 = $x1 +($x2-$x1)*($axmax-$i)/($axmax-$axmin);
                $xp2 = $xp3 = $xp1o = $xp2o = $xp1;
            } else {
                $yp1 = $y1 +($y2-$y1)*($axmax-$i)/($axmax-$axmin);
                $yp2 = $yp3 = $yp1o = $yp2o = $yp1;
            }
            if ($grid && $i > $axmin && $i < $axmax) {
                if ($orient eq "horizontal") {
                    @coords = ($xp1, $gr1, $xp1, $gr2);
                } else {
                    @coords = ($gr1, $yp1, $gr2, $yp1);
                }
                $canv->create_line(@coords, -fill  => &get_rgb_code($grcolor),
                                            -width => $grwidth,
                                            -arrow => 'none',
                                            -tags  => $gridtags);
            }
            if ($pr_tics ne "none") {
                $canv->create_line($xp1, $yp1, $xp2, $yp2,
                                   -fill  => &get_rgb_code("black"),
                                   -width => 1,
                                   -arrow => 'none',
                                   -tags  => $tags);
            }
            if ($op_tics ne "none") {
                $canv->create_line($xp1o, $yp1o, $xp2o, $yp2o,
                                   -fill  => &get_rgb_code("black"),
                                   -width => 1,
                                   -arrow => 'none',
                                   -tags  => $op_tags);
            }
            $id = $canv->create_text($xp3, $yp3,
                               -anchor => $anc,
                               -text   => $label,
                               -fill   => &get_rgb_code("black"),
                               -angle  => $ang,
                               -tags   => $tags,
                               -font   => [-family     => $family,
                                           -size       => $label_size,
                                           -weight     => $label_weight,
                                           -slant      => 'roman',
                                           -underline  => 0,
                                           -overstrike => 0,
                                          ]);
            if ($i == $first || $i - $major < $axmin) {
                @coords = Tkx::SplitList($canv->bbox($id));
                if ($orient eq "horizontal") {
                    $tsize = &max($tsize, abs($coords[3] - $coords[1]));
                } else {
                    $tsize = &max($tsize, abs($coords[2] - $coords[0]));
                }
            }
        }
    } else {
        for ($i=$first; $i<=$axmax*1.000001; $i+=$major) {
            $label = sprintf($fmt, $i);
            if ($orient eq "horizontal") {
                $xp1 = $x1 +($x2-$x1)*($i-$axmin)/($axmax-$axmin);
                $xp2 = $xp3 = $xp1o = $xp2o = $xp1;
            } else {
                $yp1 = $y1 +($y2-$y1)*($i-$axmin)/($axmax-$axmin);
                $yp2 = $yp3 = $yp1o = $yp2o = $yp1;
            }
            if ($grid && $i > $axmin && $i < $axmax) {
                if ($orient eq "horizontal") {
                    @coords = ($xp1, $gr1, $xp1, $gr2);
                } else {
                    @coords = ($gr1, $yp1, $gr2, $yp1);
                }
                $canv->create_line(@coords, -fill  => &get_rgb_code($grcolor),
                                            -width => $grwidth,
                                            -arrow => 'none',
                                            -tags  => $gridtags);
            }
            if ($pr_tics ne "none") {
                $canv->create_line($xp1, $yp1, $xp2, $yp2,
                                   -fill  => &get_rgb_code("black"),
                                   -width => 1,
                                   -arrow => 'none',
                                   -tags  => $tags);
            }
            if ($op_tics ne "none") {
                $canv->create_line($xp1o, $yp1o, $xp2o, $yp2o,
                                   -fill  => &get_rgb_code("black"),
                                   -width => 1,
                                   -arrow => 'none',
                                   -tags  => $op_tags);
            }
            $id = $canv->create_text($xp3, $yp3,
                               -anchor => $anc,
                               -text   => $label,
                               -fill   => &get_rgb_code("black"),
                               -angle  => $ang,
                               -tags   => $tags,
                               -font   => [-family     => $family,
                                           -size       => $label_size,
                                           -weight     => $label_weight,
                                           -slant      => 'roman',
                                           -underline  => 0,
                                           -overstrike => 0,
                                          ]);
            if ($i == $first || $i + $major > $axmax) {
                @coords = Tkx::SplitList($canv->bbox($id));
                if ($orient eq "horizontal") {
                    $tsize = &max($tsize, abs($coords[3] - $coords[1]));
                } else {
                    $tsize = &max($tsize, abs($coords[2] - $coords[0]));
                }
            }
        }
    }
    if ($minor != 0 && ($pr_tics ne "none" || $op_tics ne "none")) {
        $nt = int(($axmax - $axmin)/$major +0.00001) +1;
        if ($orient eq "horizontal") {
            $add_minor = (abs($x2-$x1)/$nt > 30) ? 1 : 0;
        } else {
            $add_minor = (abs($y2-$y1)/$nt > 30) ? 1 : 0;
        }
        if ($add_minor) {
            if ($reverse) {
                for ($i=$first-$major/2.; $i>=$axmin; $i-=$major) {
                    if ($orient eq "horizontal") {
                        $xp4 = $x1 +($x2-$x1)*($axmax-$i)/($axmax-$axmin);
                        $xp5 = $xp4o = $xp5o = $xp4;
                    } else {
                        $yp4 = $y1 +($y2-$y1)*($axmax-$i)/($axmax-$axmin);
                        $yp5 = $yp4o = $yp5o = $yp4;
                    }
                    if ($pr_tics ne "none") {
                        $canv->create_line($xp4, $yp4, $xp5, $yp5,
                                           -fill  => &get_rgb_code("black"),
                                           -width => 1,
                                           -arrow => 'none',
                                           -tags  => $tags);
                    }
                    if ($op_tics ne "none") {
                        $canv->create_line($xp4o, $yp4o, $xp5o, $yp5o,
                                           -fill  => &get_rgb_code("black"),
                                           -width => 1,
                                           -arrow => 'none',
                                           -tags  => $op_tags);
                    }
                }
            } else {
                for ($i=$first+$major/2.; $i<=$axmax; $i+=$major) {
                    if ($orient eq "horizontal") {
                        $xp4 = $x1 +($x2-$x1)*($i-$axmin)/($axmax-$axmin);
                        $xp5 = $xp4o = $xp5o = $xp4;
                    } else {
                        $yp4 = $y1 +($y2-$y1)*($i-$axmin)/($axmax-$axmin);
                        $yp5 = $yp4o = $yp5o = $yp4;
                    }
                    if ($pr_tics ne "none") {
                        $canv->create_line($xp4, $yp4, $xp5, $yp5,
                                           -fill  => &get_rgb_code("black"),
                                           -width => 1,
                                           -arrow => 'none',
                                           -tags  => $tags);
                    }
                    if ($op_tics ne "none") {
                        $canv->create_line($xp4o, $yp4o, $xp5o, $yp5o,
                                           -fill  => &get_rgb_code("black"),
                                           -width => 1,
                                           -arrow => 'none',
                                           -tags  => $op_tags);
                    }
                }
            }
        }
    }
    if ($title ne "") {
        $tags .= "Title";
        if ($orient eq "horizontal") {
            $xp1 = ($x1+$x2)/2.;
            $ang = 0;
            $yp1 = ($side eq "bottom") ? $yp3+$tsize : $yp3-$tsize;
            $anc = ($side eq "bottom") ? 'n' : 's';
        } else {
            $yp1 = ($y1+$y2)/2.;
            $anc = 's';
            $xp1 = ($side eq "left") ? $xp3-2-$tsize : $xp3+2+$tsize;
            $ang = ($side eq "left") ? 90 : 270;
        }
        $canv->create_text($xp1, $yp1,
                           -anchor => $anc,
                           -text   => $title,
                           -fill   => &get_rgb_code("black"),
                           -angle  => $ang,
                           -tags   => $tags,
                           -font   => [-family     => $family,
                                       -size       => $title_size,
                                       -weight     => $title_weight,
                                       -slant      => 'roman',
                                       -underline  => 0,
                                       -overstrike => 0,
                                      ]);
    }
}


sub make_seg_axis {
    my ($canv, %axis_props) = @_;
    my (
        $anc, $ang, $axbase, $axis_tag, $axis_tag2, $axmax, $axmin, $bgrid,
        $bgrcolor, $d1, $d2, $d3, $dx, $dy, $family, $flipped, $gr1, $gr2,
        $grcolor, $grid, $gridtags, $gtag, $i, $id, $item, $label_size,
        $label_weight, $major, $min_major, $minor, $mstart, $nsegs, $op_loc,
        $op_tags, $op_tics, $orient, $pr_tics, $saxis_tag, $saxis_tag2,
        $side, $tag, $tags, $ticloc, $title, $title_size, $title_weight,
        $tsize, $type, $val, $x1, $x2, $xp1, $xp1o, $xp2, $xp2o, $xp3,
        $xp4, $xp4o, $xp5, $xp5o, $xtra, $y1, $y2, $yp1, $yp1o, $yp2,
        $yp2o, $yp3, $yp4, $yp4o, $yp5, $yp5o,

        @coords, @dist, @items, @seglist, @taglist,
       );

    $family       = $axis_props{font};
    $label_size   = $axis_props{size1};
    $title_size   = $axis_props{size2};
    $label_weight = $axis_props{weight1};
    $title_weight = $axis_props{weight2};

    $type    = $axis_props{type};           # above, below, replace
    $axbase  = $axis_props{base};           # km
    $axmin   = $axis_props{min};            # km
    $axmax   = $axis_props{max};            # km
    $major   = $axis_props{major};          # number of segments
    $grid    = $axis_props{grid};           # 0 = no, 1 = yes
    $bgrid   = $axis_props{bgrid};          # 0 = no, 1 = yes
    $title   = $axis_props{title};
    $ticloc  = $axis_props{tic_loc};        # center, upstream edge, downstream edge
    $side    = $axis_props{side};           # bottom, left, top, right
    $pr_tics = $axis_props{pr_tics};        # primary side:   inside, outside, cross, none
    $op_tics = $axis_props{op_tics};        # opposite side:  inside, outside, cross, none
    $op_loc  = $axis_props{op_loc};         # opposite side coordinate
    $tags    = $axis_props{tags};

    @seglist = @{ $axis_props{seglist} };   # list of segments, from ds to us
    @dist    = @{ $axis_props{dist}    };   # distance array in km

    if ($grid || $bgrid) {
        $grcolor     = $axis_props{gridcol} if ($grid);
        $bgrcolor    = $axis_props{bgridcol} if ($bgrid);
        ($gr1, $gr2) = @{ $axis_props{grcoord} };
        ($gridtags = $tags) =~ s/_saxis$/_sgrid/;
    }
    if ($op_tics ne "none") {
        $op_tags = $tags;
        @taglist = split(/ /, $op_tags);
        foreach $tag (@taglist) {
            if ($tag =~ /_saxis$/) {
                $op_tags .= " " . $tag . "2";
                last;
            }
        }
    }
    $title =~ s/^"//;
    $title =~ s/"$//;
    $tsize = 5;
    $dx = $dy = 0;

    ($x1, $y1, $x2, $y2) = @{ $axis_props{coords} };

    if ($axmin > $axmax) {
        $axmin = $axis_props{max};
        $axmax = $axis_props{min};
    } elsif ($axmin == $axmax) {
        &pop_up_error($main, "Axis minimum and maximum values are identical");
        return;
    }
    $major = "auto" if ($major eq "");
    if ($major ne "auto") {
        $major *= -1     if ($major+0  < 0);
        $major  = "auto" if ($major+0 == 0);
    }
    if ($y1 == $y2) {
        $orient  = "horizontal";
        $side    = "bottom" if (! defined($side) || $side ne "top");
        $flipped = ($x1 > $x2) ? 1 : 0;
    } elsif ($x1 == $x2) {
        $orient  = "vertical";
        $side    = "left" if (! defined($side) || $side ne "right");
        $flipped = ($y1 > $y2) ? 1 : 0;
    } else {
        &pop_up_error($main, "Invalid coordinates for segment axis");
        return;
    }
    if ($op_tics ne "none") {
        if ($orient eq "horizontal") {
            $op_tics = "none" if ($op_loc == $y1 || ($side eq "bottom" && $op_loc > $y1)
                                                 || ($side eq "top"    && $op_loc < $y1));
        } else {
            $op_tics = "none" if ($op_loc == $x1 || ($side eq "left"  && $op_loc < $x1)
                                                 || ($side eq "right" && $op_loc > $x1));
        }
    }

#   Calculate offset if segment axis is below X axis or left of Y axis
    if ($type eq "below") {
        @taglist = split(/ /, $tags);
        foreach $tag (@taglist) {
            if ($tag =~ /_saxis/) {
                if ($orient eq "horizontal") {
                    ($axis_tag = $tag) =~ s/_saxis/_xaxis/;
                } else {
                    ($axis_tag = $tag) =~ s/_saxis/_yaxis/;
                }
                $axis_tag2 = $axis_tag . "2";
                last;
            }
        }
        @items = Tkx::SplitList($canv->find_withtag($axis_tag));
        foreach $item (@items) {
            @taglist = Tkx::SplitList($canv->gettags($item));
            next if (&list_search($axis_tag2, @taglist) >= 0);
            $canv->addtag('group_axis', withtag => $item);
        }
        $canv->addtag('group_axis', withtag => $axis_tag . "Title");
        @coords = Tkx::SplitList($canv->bbox('group_axis'));
        $canv->dtag('group_axis');
        if ($orient eq "horizontal") {
            $dx = 0;
            if ($side eq "bottom") {
                $dy  = &max($coords[3], $coords[1]) -$y1 +7;
                $dy += 8 if ($pr_tics =~ /inside|cross/);
            } else {
                $dy  = &min($coords[3], $coords[1]) -$y1 -7;
                $dy -= 8 if ($pr_tics =~ /inside|cross/);
            }
        } else {
            $dy = 0;
            if ($side eq "left") {
                $dx  = &min($coords[2], $coords[0]) -$x1 -7;
                $dx -= 8 if ($pr_tics =~ /inside|cross/);
            } else {
                $dx  = &max($coords[2], $coords[0]) -$x1 +7;
                $dx += 8 if ($pr_tics =~ /inside|cross/);
            }
        }

      # Make an axis bar
        $canv->create_line($x1+$dx, $y1+$dy, $x2+$dx, $y2+$dy,
                           -fill  => &get_rgb_code("black"),
                           -width => 1,
                           -arrow => 'none',
                           -tags  => $tags);
    }

#   Figure out major spacing if set to "auto"
    $nsegs = $#seglist +1;
    if ($major eq "auto") {
        if ($orient eq "horizontal") {
            $min_major = int($nsegs *($label_size *4) /abs($x2-$x1) +0.0000001);
        } else {
            $min_major = int($nsegs *($label_size *4) /abs($y2-$y1) +0.0000001);
        }
        $major = &max(1, $min_major);
    }

#   Figure out minor spacing
    $minor = 0;
    if ($major > 1) {
        if ($major <= 5) {
            $minor = 1;
        } else {
            $mstart = &round_to_int($major /3.);
            for ($i=$mstart; $i<=$major; $i++) {
                if ($major % $i == 0) {
                    $minor = $i;
                    last;
                }
            }
            $minor = 0 if ($minor == $major);
        }
    }

#   Calculate locations of tick marks and labels
    $ang = 0;
    if ($orient eq "horizontal") {
        $anc = ($side eq "bottom") ? 'n' : 's';
        if ($ticloc =~ /down|up/) {
            if ($ticloc =~ /down/) {
                $xtra = ($flipped) ? 'e': 'w';
            } else {
                $xtra = ($flipped) ? 'w': 'e';
            }
            $anc .= $xtra;
        }
        $d1  = ($pr_tics eq "cross")       ? 4 : 0;
        $d2  = ($pr_tics eq "inside")      ? 8 : 0;
        $d3  = ($pr_tics =~ /inside|none/) ? 6 : 0;
        $yp1 = ($side eq "bottom") ? $y1-2*$d1   : $y1+2*$d1;   # major ticks
        $yp2 = ($side eq "bottom") ? $y1+8-2*$d2 : $y1-8+2*$d2; # major ticks
        $yp3 = ($side eq "bottom") ? $y1+9-$d3   : $y1-9+$d3;   # tick labels
        $yp4 = ($side eq "bottom") ? $y1-$d1     : $y1+$d1;     # minor ticks
        $yp5 = ($side eq "bottom") ? $y1+4-$d2   : $y1-4+$d2;   # minor ticks
        if ($op_tics ne "none") {
            $d1   = ($op_tics eq "cross")  ? 4 : 0;
            $d2   = ($op_tics eq "inside") ? 8 : 0;
            $yp1o = ($side eq "bottom") ? $op_loc+2*$d1   : $op_loc-2*$d1;   # major ticks
            $yp2o = ($side eq "bottom") ? $op_loc-8+2*$d2 : $op_loc+8-2*$d2; # major ticks
            $yp4o = ($side eq "bottom") ? $op_loc+$d1     : $op_loc-$d1;     # minor ticks
            $yp5o = ($side eq "bottom") ? $op_loc-4+$d2   : $op_loc+4-$d2;   # minor ticks
        }
    } else {
        $anc = ($side eq "left") ? 'e' : 'w';
        if ($ticloc =~ /down|up/) {
            if ($ticloc =~ /down/) {
                $xtra = ($flipped) ? 'n': 's';
            } else {
                $xtra = ($flipped) ? 's': 'n';
            }
            $anc = $xtra . $anc;
        }
        $d1  = ($pr_tics eq "cross")       ? 4 : 0;
        $d2  = ($pr_tics eq "inside")      ? 8 : 0;
        $d3  = ($pr_tics =~ /inside|none/) ? 6 : 0;
        $xp1 = ($side eq "left") ? $x1+2*$d1   : $x1-2*$d1;   # major ticks
        $xp2 = ($side eq "left") ? $x1-8+2*$d2 : $x1+8-2*$d2; # major ticks
        $xp3 = ($side eq "left") ? $x1-10+$d3  : $x1+10-$d3;  # tick labels
        $xp4 = ($side eq "left") ? $x1+$d1     : $x1-$d1;     # minor ticks
        $xp5 = ($side eq "left") ? $x1-4+$d2   : $x1+4-$d2;   # minor ticks
        if ($op_tics ne "none") {
            $d1   = ($op_tics eq "cross")  ? 4 : 0;
            $d2   = ($op_tics eq "inside") ? 8 : 0;
            $xp1o = ($side eq "left") ? $op_loc-2*$d1   : $op_loc+2*$d1;   # major ticks
            $xp2o = ($side eq "left") ? $op_loc+8-2*$d2 : $op_loc-8+2*$d2; # major ticks
            $xp4o = ($side eq "left") ? $op_loc-$d1     : $op_loc+$d1;     # minor ticks
            $xp5o = ($side eq "left") ? $op_loc+4-$d2   : $op_loc-4+$d2;   # minor ticks
        }
    }

#   Make grid lines, if requested
    if ($grid) {
        for ($i=$#seglist; $i>=0; $i-=$major) {
            if ($ticloc eq "upstream edge") {
                $val = $dist[$seglist[$i]];
            } elsif ($ticloc eq "downstream edge") {
                $val = ($i == 0) ? 0.0 : $dist[$seglist[$i-1]];
            } else {
                $val = ($i == 0) ? 0.5*$dist[$seglist[$i]] : 0.5*($dist[$seglist[$i]] +$dist[$seglist[$i-1]]);
            }
            $val += $axbase;
            next if ($val < $axmin -0.001 || $val > $axmax +0.001);
            if ($orient eq "horizontal") {
                $xp1 = $x1 +($x2-$x1)*($val-$axmin)/($axmax-$axmin);
                @coords = ($xp1, $gr1, $xp1, $gr2);
            } else {
                $yp1 = $y1 +($y2-$y1)*($val-$axmin)/($axmax-$axmin);
                @coords = ($gr1, $yp1, $gr2, $yp1);
            }
            $canv->create_line(@coords, -fill  => &get_rgb_code($grcolor),
                                        -width => 1,
                                        -arrow => 'none',
                                        -tags  => $gridtags);
        }
    }

#   Make branch boundary grid lines, if requested
    if ($bgrid) {
        for ($i=$#seglist; $i>0; $i--) {
            next if ($seglist[$i-1] == $seglist[$i] +1);
            $val  = $dist[$seglist[$i-1]];
            $val += $axbase;
            next if ($val < $axmin || $val > $axmax);
            if ($orient eq "horizontal") {
                $xp1 = $x1 +($x2-$x1)*($val-$axmin)/($axmax-$axmin);
                @coords = ($xp1, $gr1, $xp1, $gr2);
            } else {
                $yp1 = $y1 +($y2-$y1)*($val-$axmin)/($axmax-$axmin);
                @coords = ($gr1, $yp1, $gr2, $yp1);
            }
            $canv->create_line(@coords, -fill  => &get_rgb_code($bgrcolor),
                                        -width => 1,
                                        -arrow => 'none',
                                        -tags  => $gridtags);
        }
    }

#   Make major tick marks and labels
    for ($i=$#seglist; $i>=0; $i-=$major) {
        if ($ticloc eq "upstream edge") {
            $val = $dist[$seglist[$i]];
        } elsif ($ticloc eq "downstream edge") {
            $val = ($i == 0) ? 0.0 : $dist[$seglist[$i-1]];
        } else {
            $val = ($i == 0) ? 0.5* $dist[$seglist[$i]] : 0.5* ($dist[$seglist[$i]] +$dist[$seglist[$i-1]]);
        }
        $val += $axbase;
        next if ($val < $axmin -0.001 || $val > $axmax +0.001);
        if ($orient eq "horizontal") {
            $xp1 = $x1 +($x2-$x1)*($val-$axmin)/($axmax-$axmin);
            $xp2 = $xp3 = $xp1o = $xp2o = $xp1;
        } else {
            $yp1 = $y1 +($y2-$y1)*($val-$axmin)/($axmax-$axmin);
            $yp2 = $yp3 = $yp1o = $yp2o = $yp1;
        }
        if ($pr_tics ne "none") {
            $canv->create_line($xp1+$dx, $yp1+$dy, $xp2+$dx, $yp2+$dy,
                               -fill  => &get_rgb_code("black"),
                               -width => 1,
                               -arrow => 'none',
                               -tags  => $tags);
        }
        if ($op_tics ne "none") {
            $canv->create_line($xp1o, $yp1o, $xp2o, $yp2o,
                               -fill  => &get_rgb_code("black"),
                               -width => 1,
                               -arrow => 'none',
                               -tags  => $op_tags);
        }
        $id = $canv->create_text($xp3+$dx, $yp3+$dy,
                           -anchor => $anc,
                           -text   => $seglist[$i],
                           -fill   => &get_rgb_code("black"),
                           -angle  => $ang,
                           -tags   => $tags,
                           -font   => [-family     => $family,
                                       -size       => $label_size,
                                       -weight     => $label_weight,
                                       -slant      => 'roman',
                                       -underline  => 0,
                                       -overstrike => 0,
                                      ]);
        @coords = Tkx::SplitList($canv->bbox($id));
        if ($orient eq "horizontal") {
            $tsize = &max($tsize, abs($coords[3] - $coords[1]));
        } else {
            $tsize = &max($tsize, abs($coords[2] - $coords[0]));
        }
    }

#   Make minor tick marks
    if ($minor > 0 && ($pr_tics ne "none" || $op_tics ne "none")) {
        for ($i=$#seglist; $i>=0; $i-=$minor) {
            next if (($#seglist-$i) % $major == 0);
            if ($ticloc eq "upstream edge") {
                $val = $dist[$seglist[$i]];
            } elsif ($ticloc eq "downstream edge") {
                $val = ($i==0) ? 0.0 : $dist[$seglist[$i-1]];
            } else {
                $val = ($i==0) ? 0.5* $dist[$seglist[$i]] : 0.5* ($dist[$seglist[$i]] +$dist[$seglist[$i-1]]);
            }
            $val += $axbase;
            next if ($val < $axmin -0.0005 || $val > $axmax +0.0005);
            if ($orient eq "horizontal") {
                $xp4 = $x1 +($x2-$x1)*($val-$axmin)/($axmax-$axmin);
                $xp5 = $xp4o = $xp5o = $xp4;
            } else {
                $yp4 = $y1 +($y2-$y1)*($val-$axmin)/($axmax-$axmin);
                $yp5 = $yp4o = $yp5o = $yp4;
            }
            if ($pr_tics ne "none") {
                $canv->create_line($xp4+$dx, $yp4+$dy, $xp5+$dx, $yp5+$dy,
                                   -fill  => &get_rgb_code("black"),
                                   -width => 1,
                                   -arrow => 'none',
                                   -tags  => $tags);
            }
            if ($op_tics ne "none") {
                $canv->create_line($xp4o, $yp4o, $xp5o, $yp5o,
                                   -fill  => &get_rgb_code("black"),
                                   -width => 1,
                                   -arrow => 'none',
                                   -tags  => $op_tags);
            }
        }
    }

#   Segment axis title
    if ($title ne "") {
        $tags .= "Title";
        $d3    = ($pr_tics =~ /inside|none/) ? 6 : 0;
        if ($orient eq "horizontal") {
            $xp1 = ($x1+$x2)/2.;
            $ang = 0;
            $yp1 = ($side eq "bottom") ? $y1+9+$tsize-$d3 : $y1-9-$tsize+$d3;
            $anc = ($side eq "bottom") ? 'n' : 's';
        } else {
            $yp1 = ($y1+$y2)/2.;
            $anc = 's';
            $xp1 = ($side eq "left") ? $x1-12-$tsize+$d3 : $x1+12+$tsize-$d3;
            $ang = ($side eq "left") ? 90 : 270;
        }
        $canv->create_text($xp1+$dx, $yp1+$dy,
                           -anchor => $anc,
                           -text   => $title,
                           -fill   => &get_rgb_code("black"),
                           -angle  => $ang,
                           -tags   => $tags,
                           -font   => [-family     => $family,
                                       -size       => $title_size,
                                       -weight     => $title_weight,
                                       -slant      => 'roman',
                                       -underline  => 0,
                                       -overstrike => 0,
                                      ]);
    }

#   Move the regular axis if segment axis is above the regular axis.
#   At this point, the segment axis is restricted to orient=horizontal and side=bottom
#     and therefore the regular axis is the X axis.
    if ($type eq "above") {
        @taglist = split(/ /, $tags);
        foreach $tag (@taglist) {
            if ($tag =~ /_saxis/) {
                ($saxis_tag = $tag) =~ s/Title$//;
                if ($orient eq "horizontal") {
                    ($axis_tag = $saxis_tag) =~ s/_saxis/_xaxis/;
                } else {
                    ($axis_tag = $saxis_tag) =~ s/_saxis/_yaxis/;
                }
                $saxis_tag2 = $saxis_tag . "2";
                $axis_tag2  = $axis_tag  . "2";
                last;
            }
        }
      # Get bounding box for segment axis, tick, and title without opposite axis
        @items = Tkx::SplitList($canv->find_withtag($saxis_tag));
        foreach $item (@items) {
            @taglist = Tkx::SplitList($canv->gettags($item));
            next if (&list_search($saxis_tag2, @taglist) >= 0);
            $canv->addtag('group_axis', withtag => $item);
        }
        $canv->addtag('group_axis', withtag => $saxis_tag . "Title");
        @coords = Tkx::SplitList($canv->bbox('group_axis'));
        $canv->dtag('group_axis');
        if ($orient eq "horizontal") {
            $dx = 0;
            if ($side eq "bottom") {
                $dy = &max($coords[3], $coords[1]) -$y1 +7;
            } else {
                $dy = &min($coords[3], $coords[1]) -$y1 -7;
            }
        } else {
            $dy = 0;
            if ($side eq "left") {
                $dx = &min($coords[2], $coords[0]) -$x1 -7;
            } else {
                $dx = &max($coords[2], $coords[0]) -$x1 +7;
            }
        }
      # Get bounding box for regular axis, tick, and title without opposite axis
        @items = Tkx::SplitList($canv->find_withtag($axis_tag));
        foreach $item (@items) {
            @taglist = Tkx::SplitList($canv->gettags($item));
            next if (&list_search($axis_tag2, @taglist) >= 0);
            $canv->addtag('group_axis', withtag => $item);
        }
        $canv->addtag('group_axis', withtag => $axis_tag . "Title");
        @coords = Tkx::SplitList($canv->bbox('group_axis'));
        if ($orient eq "horizontal") {
            if ($side eq "bottom") {
                $dy += &max(0, $y1-&min($coords[3], $coords[1]));
            } else {
                $dy -= &max(0, &max($coords[3], $coords[1]) -$y1);
            }
        } else {
            if ($side eq "left") {
                $dx -= &max(0, &max($coords[2], $coords[0]) -$x1);
            } else {
                $dx += &max(0, $x1-&min($coords[2], $coords[0]));
            }
        }
        $canv->move('group_axis', $dx, $dy);
        $canv->dtag('group_axis');

      # Add an axis line for the regular axis
        ($gtag = $axis_tag) =~ s/_.axis//;
        $tags = $gtag . " " . $axis_tag;
        $canv->create_line($x1+$dx, $y1+$dy, $x2+$dx, $y2+$dy,
                           -fill  => &get_rgb_code("black"),
                           -width => 1,
                           -arrow => 'none',
                           -tags  => $tags);
    }
}


sub make_date_axis {
    my ($canv, %axis_props) = @_;
    my (

        $add_minor, $anc, $ang, $ax_pix, $axmax, $axmin, $d, $d1, $d2, $d3,
        $datefmt, $family, $fmt, $gr1, $gr2, $grcolor, $grid, $gridtags,
        $grwidth, $i, $id, $jd, $label, $label_size, $label_weight, $m,
        $major, $min_major, $minor, $next_jd, $nt, $on_tick, $op_loc,
        $op_tags, $op_tics, $orient, $pix_per_mon, $pix_per_yr, $pr_tics,
        $range, $reverse, $side, $tag, $tags, $title, $title_size,
        $title_weight, $tsize, $x1, $x2, $xp1, $xp1o, $xp2, $xp2o, $xp3,
        $xp4, $xp4o, $xp5, $xp5o, $xtra, $y, $y1, $y2, $yp1, $yp1o, $yp2,
        $yp2o, $yp3, $yp4, $yp4o, $yp5, $yp5o, $yr_max, $yr_min,

        @coords, @long_ticks, @major_ticks, @taglist, @tick_jd, @tick_jd2,
        @tick_labels, @tick_labels2,
       );

    $family       = $axis_props{font};
    $label_size   = $axis_props{size1};
    $title_size   = $axis_props{size2};
    $label_weight = $axis_props{weight1};
    $title_weight = $axis_props{weight2};

    $axmin   = $axis_props{min};
    $axmax   = $axis_props{max};
    $major   = $axis_props{major};
    $minor   = $axis_props{minor};     # 0 = no, 1 = yes
    $reverse = $axis_props{reverse};   # 0 = no, 1 = yes
    $datefmt = $axis_props{datefmt};   # Year, Month, Mon-DD, Mon-DD-YYYY
    $title   = $axis_props{title};
    $side    = $axis_props{side};      # left, right, top, bottom
    $pr_tics = $axis_props{pr_tics};   # primary side:   inside, outside, cross, none
    $op_tics = $axis_props{op_tics};   # opposite side:  inside, outside, cross, none
    $op_loc  = $axis_props{op_loc};    # opposite side coordinate
    $tags    = $axis_props{tags};

    if (defined($axis_props{grid})) {
        $grid        = $axis_props{grid};
        $grwidth     = $axis_props{grwidth};
        $grcolor     = $axis_props{grcolor};
        ($gr1, $gr2) = @{ $axis_props{grcoord} };
        ($gridtags = $tags) =~ s/_.axis$/_grid/;
    } else {
        $grid = 0;
    }
    if ($op_tics ne "none") {
        $op_tags = $tags;
        @taglist = split(/ /, $op_tags);
        foreach $tag (@taglist) {
            if ($tag =~ /_.axis$/) {
                $op_tags .= " " . $tag . "2";
                last;
            }
        }
    }
    $title =~ s/^"//;
    $title =~ s/"$//;
    $tsize =  0;

    ($x1, $y1, $x2, $y2) = @{ $axis_props{coords} };

    if ($axmin > $axmax) {
        $axmin = $axis_props{max};
        $axmax = $axis_props{min};
    } elsif ($axmin == $axmax) {
        &pop_up_error($main, "Axis minimum and maximum values are identical");
        return;
    }
    if ($major ne "auto") {
        $major *= -1     if ($major+0  < 0);
        $major  = "auto" if ($major+0 == 0);
    }
    $minor *= -1 if ($minor < 0);
    if ($y1 == $y2) {
        $orient = "horizontal";
        $side   = "bottom" if (! defined($side) || $side ne "top");
        $ax_pix = abs($x2-$x1);
    } elsif ($x1 == $x2) {
        $orient = "vertical";
        $side   = "left" if (! defined($side) || $side ne "right");
        $ax_pix = abs($y2-$y1);
    } else {
        &pop_up_error($main, "Invalid coordinates for axis");
        return;
    }
    if ($op_tics ne "none") {
        if ($orient eq "horizontal") {
            $op_tics = "none" if ($op_loc == $y1 || ($side eq "bottom" && $op_loc > $y1)
                                                 || ($side eq "top"    && $op_loc < $y1));
        } else {
            $op_tics = "none" if ($op_loc == $x1 || ($side eq "left"  && $op_loc < $x1)
                                                 || ($side eq "right" && $op_loc > $x1));
        }
    }

#   Determine an optimal major tick spacing for date axis
    $xtra    = 0;
    $on_tick = 0;
    @major_ticks  = ();
    @long_ticks   = ();
    @tick_jd      = ();
    @tick_jd2     = ();
    @tick_labels  = ();
    @tick_labels2 = ();
    if ($datefmt eq "Year") {
        $fmt = $datefmt;
        if ($orient eq "horizontal") {
            $ang = 0;
            $anc = ($side eq "bottom") ? 'n' : 's';
        } else {
            $ang = 90;
            $anc = ($side eq "left") ? 's' : 'n';
        }
        $pix_per_yr = $ax_pix /(($axmax-$axmin) /365.25);
        if ($pix_per_yr / $label_size <= 1.5) {    # Year on major tick mark, rotated; use major
            $on_tick = 1;
            if ($orient eq "horizontal") {
                $ang  = 90;
                $anc  = ($side eq "bottom") ? 'e' : 'w';
                $xtra = 2 if ($side eq "bottom");
            } else {
                $ang  = 0;
                $anc  = ($side eq "left") ? 'e' : 'w';
                $xtra = 2 if ($side eq "left");
            }
            ($yr_min, $m, $d) = split(/-/, &jdate2datelabel(&floor($axmin +0.0000001), ""));
            ($yr_max, $m, $d) = split(/-/, &jdate2datelabel($axmax, ""));
            $range = $yr_max -$yr_min;
            if ($major eq "auto") {
                if ($orient eq "horizontal") {
                    $min_major = int($range *($label_size *2.5) /abs($x2-$x1) +0.0000001);
                } else {
                    $min_major = int($range *($label_size *2.5) /abs($y2-$y1) +0.0000001);
                }
                $min_major = 1 if ($min_major == 0);
                for ($i=$range-1; $i>=$min_major; $i--) {
                    $major = $i if ($range % $i == 0);
                }
                $major = $min_major if ($major eq "auto");
            }
            $major = &min($range, $major);
        } elsif ($pix_per_yr /$label_size <= 4) {  # Year between tick marks, rotated
            $on_tick = 0;
            $minor   = 0;
            if ($orient eq "horizontal") {
                $ang  = 90;
                $anc  = ($side eq "bottom") ? 'e' : 'w';
                $xtra = 2 if ($side eq "bottom");
            } else {
                $ang  = 0;
                $anc  = ($side eq "left") ? 'e' : 'w';
                $xtra = 2 if ($side eq "left");
            }
        } else {                                   # Year between ticks, unrotated
            $on_tick = 0;
            $minor   = 0;
        }
        $jd = &floor($axmin +0.0000001);
        ($y, $m, $d) = split(/-/, &jdate2datelabel($jd, ""));
        if ($on_tick) {
            if ($m == 1 && $d == 1) {
                push (@major_ticks, $jd);
                push (@tick_labels, $y);
                $next_jd = &date2jdate(sprintf("%04d%s", $y+$major, "0101"));
                $y += $major;
            } else {
                $next_jd = &date2jdate(sprintf("%04d%s", $y+1, "0101"));
                $y++;
            }
            while ($next_jd <= $axmax) {
                $jd      = $next_jd;
                $next_jd = &date2jdate(sprintf("%04d%s", $y+$major, "0101"));
                if ($jd <= $axmax) {
                    push (@major_ticks, $jd);
                    push (@tick_labels, $y);
                }
                $y += $major;
            }
            @tick_jd = @major_ticks;
        } else {
            $next_jd = &date2jdate(sprintf("%04d%s", $y+1, "0101"));
            if ($m == 1 && $d == 1) {
                push (@major_ticks, $jd);
                push (@tick_labels, $y);
                push (@tick_jd, ($jd + &min($next_jd, $axmax))/2.);
            } elsif ($m <= 6) {
                push (@tick_labels, $y);
                push (@tick_jd, ($jd + &min($next_jd, $axmax))/2.);
            }
            $y++;
            while ($next_jd <= $axmax) {
                push (@major_ticks, $next_jd);
                $jd      = $next_jd;
                $next_jd = &date2jdate(sprintf("%04d%s", $y+1, "0101"));
                if ($next_jd <= $axmax) {
                    push (@tick_labels, $y);
                    push (@tick_jd, ($jd +$next_jd)/2.);
                }
                $y++;
            }
            if ($jd < $axmax) {
                ($y, $m, $d) = split(/-/, &jdate2datelabel($axmax, ""));
                if ($m >= 7) {
                    push (@tick_labels, $y);
                    push (@tick_jd, ($jd +$axmax)/2.);
                }
            }
        }

    } elsif ($datefmt eq "Month") {
        $minor = 0;
        if ($orient eq "horizontal") {
            $ang = 0;
            $anc = ($side eq "bottom") ? 'n' : 's';
        } else {
            $ang = 90;
            $anc = ($side eq "left") ? 's' : 'n';
        }
        $pix_per_mon = $ax_pix /(($axmax-$axmin) *12/365.25);
        if ($pix_per_mon /$label_size >= 8) {
            $fmt = "Month";
            $datefmt = "MonthDay" if (($axmax -$axmin) *1.9 *$label_size < $ax_pix);
        } elsif ($pix_per_mon /$label_size > 4) {
            $fmt = "Mon";
        } elsif ($pix_per_mon /$label_size > 1.5) {
            $fmt = "Mon";
            if ($orient eq "horizontal") {
                $ang  = 90;
                $anc  = ($side eq "bottom") ? 'e' : 'w';
                $xtra = 2 if ($side eq "bottom");
            } else {
                $ang  = 0;
                $anc  = ($side eq "left") ? 'e' : 'w';
                $xtra = 2 if ($side eq "left");
            }
        } else {
            $fmt = "M";
        }
        $jd = &floor($axmin +0.0000001);
        ($y, $m, $d) = split(/-/, &jdate2datelabel($jd, ""));
        push (@major_ticks, $jd) if ($d == 1);
        &set_leap_year($y);
        $next_jd = &min($axmax, $jd -$d +$days_in_month[$m-1] +1);
        if ($fmt eq "Month" && (($datefmt eq "MonthDay" && ($next_jd -$jd) < 10) ||
                                ($datefmt eq "Month"    && ($next_jd -$jd) < 20))) {
            $label = &jdate2datelabel($jd, "Mon");
        } else {
            $label = &jdate2datelabel($jd, $fmt);
        }
        if ($next_jd -$jd >= 17
             || 2 *length($label) *$label_size /$ax_pix < ($next_jd -$jd) /($axmax -$axmin)) {
            push (@tick_jd, ($jd + &min($next_jd, $axmax))/2.);
            push (@tick_labels, $label);
        }
        $next_jd = $jd -$d +$days_in_month[$m-1] +1;
        while ($next_jd <= $axmax) {
            $jd = $next_jd;
            push (@major_ticks, $jd);
            $m++;
            if ($m > 12) {
                $m = 1;
                $y++;
                &set_leap_year($y);
            }
            $next_jd = $jd +$days_in_month[$m-1];
            if ($next_jd <= $axmax) {
                push (@tick_jd,     ($jd +$next_jd)/2.);
                push (@tick_labels, &jdate2datelabel($jd, $fmt));
            }
        }
        if ($jd < $axmax) {
            ($y, $m, $d) = split(/-/, &jdate2datelabel($axmax, ""));
            if ($fmt eq "Month" && (($datefmt eq "MonthDay" && $d < 10) ||
                                    ($datefmt eq "Month"    && $d < 20))) {
                $label = &jdate2datelabel($jd, "Mon");
            } else {
                $label = &jdate2datelabel($jd, $fmt);
            }
            if ($d >= 17 || 2 *length($label) *$label_size /$ax_pix < ($d-1) /($axmax -$axmin)) {
                push (@tick_jd, ($jd +$axmax)/2.);
                push (@tick_labels, $label);
            }
        }
        if ($#tick_jd > 0 && $tick_jd[-1] == $tick_jd[-2]) {
            pop (@tick_jd);
            $tick_labels[-1] = pop (@tick_labels);
        }
        if ($datefmt eq "MonthDay") {
            @tick_jd2     = @tick_jd;
            @tick_labels2 = @tick_labels;
            for ($i=0; $i<=$#tick_jd2; $i++) {
                ($y, $m, $d) = split(/-/, &jdate2datelabel($tick_jd2[$i], ""));
                $tick_labels2[$i] .= ", $y";
            }
            @major_ticks = ();
            @tick_jd     = ();
            @tick_labels = ();
            $title = "" if ($#tick_labels2 >= 0);
            $jd    = &floor($axmin +0.0000001);
            ($y, $m, $d) = split(/-/, &jdate2datelabel($jd, ""));
            &set_leap_year($y);
            if ($d == 1) {
                push (@long_ticks, $jd);
            } else {
                push (@major_ticks, $jd);
            }
            while ($jd +1 <= $axmax) {
                push (@tick_jd,     $jd +0.5);
                push (@tick_labels, sprintf("%d", $d));
                $jd++;
                $d++;
                if ($d > $days_in_month[$m-1]) {
                    $d = 1;
                    $m++;
                    if ($m > 12) {
                        $m = 1;
                        $y++;
                        &set_leap_year($y);
                    }
                }
                if ($d == 1) {
                    push (@long_ticks, $jd);
                } else {
                    push (@major_ticks, $jd);
                }
            }
        }

    } else {                           # Mon-DD or Mon-DD-YYYY format
        $fmt = $datefmt;
        if ($orient eq "horizontal") {
            $ang  = 90;
            $anc  = ($side eq "bottom") ? 'e' : 'w';
            $xtra = 2 if ($side eq "bottom");
        } else {
            $ang  = 0;
            $anc  = ($side eq "left") ? 'e' : 'w';
            $xtra = 2 if ($side eq "left");
        }
        if ($major eq "auto") {
            $range = $axmax-$axmin;
            if ($orient eq "horizontal") {
                $min_major = int($range *($label_size *3) /abs($x2-$x1) +0.0000001);
            } else {
                $min_major = int($range *($label_size *3) /abs($y2-$y1) +0.0000001);
            }
            $min_major = 1 if ($min_major == 0);
            for ($i=$min_major; $i<=$range/12; $i++) {
                $major = $i if (&round_to_int($range) % $i == 0);
            }
            $major = $min_major if ($major eq "auto");
        }
        if ($reverse) {
            for ($i=$axmax; $i<=$axmin; $i-=$major) {
                push (@major_ticks, $i);
                push (@tick_labels, &jdate2datelabel($i, $fmt));
            }
        } else {
            for ($i=$axmin; $i<=$axmax; $i+=$major) {
                push (@major_ticks, $i);
                push (@tick_labels, &jdate2datelabel($i, $fmt));
            }
        }
        @tick_jd = @major_ticks;
    }

#   Make major tick marks and labels
    if ($orient eq "horizontal") {
        $d1  = ($pr_tics eq "cross")       ? 4 : 0;
        $d2  = ($pr_tics eq "inside")      ? 8 : 0;
        $d3  = ($pr_tics =~ /inside|none/) ? 6 : 0;
        $yp1 = ($side eq "bottom") ? $y1-2*$d1   : $y1+2*$d1;                # major ticks
        $yp2 = ($side eq "bottom") ? $y1+8-2*$d2 : $y1-8+2*$d2;              # major ticks
        $yp4 = ($side eq "bottom") ? $y1-$d1     : $y1+$d1;                  # minor ticks
        $yp5 = ($side eq "bottom") ? $y1+4-$d2   : $y1-4+$d2;                # minor ticks
        if ($fmt =~ /^(Month|Mon|M)$/ || ($fmt eq "Year" && ! $on_tick)) {
            $yp3 = ($side eq "bottom") ? $y1+5-(2/6*$d3)+$xtra : $y1-5+(2/6*$d3)-$xtra;
        } else {
            $yp3 = ($side eq "bottom") ? $y1+9-$d3+$xtra : $y1-9+$d3-$xtra;  # tick marks
        }
        if ($op_tics ne "none") {
            $d1   = ($op_tics eq "cross")  ? 4 : 0;
            $d2   = ($op_tics eq "inside") ? 8 : 0;
            $yp1o = ($side eq "bottom") ? $op_loc+2*$d1   : $op_loc-2*$d1;   # major ticks
            $yp2o = ($side eq "bottom") ? $op_loc-8+2*$d2 : $op_loc+8-2*$d2; # major ticks
            $yp4o = ($side eq "bottom") ? $op_loc+$d1     : $op_loc-$d1;     # minor ticks
            $yp5o = ($side eq "bottom") ? $op_loc-4+$d2   : $op_loc+4-$d2;   # minor ticks
        }
    } else {
        $d1  = ($pr_tics eq "cross")       ? 4 : 0;
        $d2  = ($pr_tics eq "inside")      ? 8 : 0;
        $d3  = ($pr_tics =~ /inside|none/) ? 6 : 0;
        $xp1 = ($side eq "left") ? $x1+2*$d1   : $x1-2*$d1;   # major ticks
        $xp2 = ($side eq "left") ? $x1-8+2*$d2 : $x1+8-2*$d2; # major ticks
        $xp4 = ($side eq "left") ? $x1+$d1     : $x1-$d1;     # minor ticks
        $xp5 = ($side eq "left") ? $x1-4+$d2   : $x1+4-$d2;   # minor ticks
        if ($fmt =~ /^(Month|Mon|M)$/ || ($fmt eq "Year" && ! $on_tick)) {
            $xp3 = ($side eq "left") ? $x1-5+(2/6*$d3)-$xtra : $x1+5-(2/6*$d3)+$xtra;
        } else {
            $xp3 = ($side eq "left") ? $x1-9+$d3-$xtra : $x1+9-$d3+$xtra;
        }
        if ($op_tics ne "none") {
            $d1   = ($op_tics eq "cross")  ? 4 : 0;
            $d2   = ($op_tics eq "inside") ? 8 : 0;
            $xp1o = ($side eq "left") ? $op_loc-2*$d1   : $op_loc+2*$d1;   # major ticks
            $xp2o = ($side eq "left") ? $op_loc+8-2*$d2 : $op_loc-8+2*$d2; # major ticks
            $xp4o = ($side eq "left") ? $op_loc-$d1     : $op_loc+$d1;     # minor ticks
            $xp5o = ($side eq "left") ? $op_loc+4-$d2   : $op_loc-4+$d2;   # minor ticks
        }
    }
    if ($grid || $pr_tics ne "none" || $op_tics ne "none") {
        for ($i=0; $i<=$#major_ticks; $i++) {
            $jd = $major_ticks[$i];
            if ($reverse) {
                if ($orient eq "horizontal") {
                    $xp1 = $x1 +($x2-$x1)*($axmax-$jd)/($axmax-$axmin);
                    $xp2 = $xp1o = $xp2o = $xp1;
                } else {
                    $yp1 = $y1 +($y2-$y1)*($axmax-$jd)/($axmax-$axmin);
                    $yp2 = $yp1o = $yp2o = $yp1;
                }
            } else {
                if ($orient eq "horizontal") {
                    $xp1 = $x1 +($x2-$x1)*($jd-$axmin)/($axmax-$axmin);
                    $xp2 = $xp1o = $xp2o = $xp1;
                } else {
                    $yp1 = $y1 +($y2-$y1)*($jd-$axmin)/($axmax-$axmin);
                    $yp2 = $yp1o = $yp2o = $yp1;
                }
            }
            if ($grid && $jd > $axmin && $jd < $axmax) {
                if ($orient eq "horizontal") {
                    @coords = ($xp1, $gr1, $xp1, $gr2);
                } else {
                    @coords = ($gr1, $yp1, $gr2, $yp1);
                }
                $canv->create_line(@coords, -fill  => &get_rgb_code($grcolor),
                                            -width => $grwidth,
                                            -arrow => 'none',
                                            -tags  => $gridtags);
            }
            if ($pr_tics ne "none") {
                $canv->create_line($xp1, $yp1, $xp2, $yp2,
                                   -fill  => &get_rgb_code("black"),
                                   -width => 1,
                                   -arrow => 'none',
                                   -tags  => $tags);
            }
            if ($op_tics ne "none") {
                $canv->create_line($xp1o, $yp1o, $xp2o, $yp2o,
                                   -fill  => &get_rgb_code("black"),
                                   -width => 1,
                                   -arrow => 'none',
                                   -tags  => $op_tags);
            }
        }
    }
    for ($i=0; $i<=$#tick_jd; $i++) {
        $jd    = $tick_jd[$i];
        $label = $tick_labels[$i];
        if ($reverse) {
            if ($orient eq "horizontal") {
                $xp3 = $x1 +($x2-$x1)*($axmax-$jd)/($axmax-$axmin);
            } else {
                $yp3 = $y1 +($y2-$y1)*($axmax-$jd)/($axmax-$axmin);
            }
        } else {
            if ($orient eq "horizontal") {
                $xp3 = $x1 +($x2-$x1)*($jd-$axmin)/($axmax-$axmin);
            } else {
                $yp3 = $y1 +($y2-$y1)*($jd-$axmin)/($axmax-$axmin);
            }
        }
        $id = $canv->create_text($xp3, $yp3,
                           -anchor => $anc,
                           -text   => $label,
                           -fill   => &get_rgb_code("black"),
                           -angle  => $ang,
                           -tags   => $tags,
                           -font   => [-family     => $family,
                                       -size       => $label_size,
                                       -weight     => $label_weight,
                                       -slant      => 'roman',
                                       -underline  => 0,
                                       -overstrike => 0,
                                      ]);
        if ($i == 0 || $i == $#tick_labels) {
            @coords = Tkx::SplitList($canv->bbox($id));
            if ($orient eq "horizontal") {
                $tsize = &max($tsize, abs($coords[3] - $coords[1]));
            } else {
                $tsize = &max($tsize, abs($coords[2] - $coords[0]));
            }
        }
    }
    if ($#long_ticks >= 0 && ($grid || $pr_tics ne "none" || $op_tics ne "none")) {
        if ($orient eq "horizontal") {
            $d1  = ($pr_tics eq "cross")  ? 12 : 0;
            $d2  = ($pr_tics eq "inside") ? 17+$tsize+$xtra : 0;
            $yp1 = ($side eq "bottom") ? $y1-$d1                : $y1+$d1;
            $yp2 = ($side eq "bottom") ? $y1+5+$tsize+$xtra-$d2 : $y1-5-$tsize-$xtra+$d2;
            if ($op_tics ne "none") {
                $d1   = ($op_tics eq "cross")  ? 12 : 0;
                $d2   = ($op_tics eq "inside") ? 24 : 0;
                $yp1o = ($side eq "bottom") ? $op_loc+$d1    : $op_loc-$d1;
                $yp2o = ($side eq "bottom") ? $op_loc-12+$d2 : $op_loc+12-$d2;
            }
        } else {
            $d1  = ($pr_tics eq "cross")  ? 12 : 0;
            $d2  = ($pr_tics eq "inside") ? 22+$tsize : 0;
            $xp1 = ($side eq "left") ? $x1+$d1           : $x1-$d1;
            $xp2 = ($side eq "left") ? $x1-10-$tsize+$d2 : $x1+10+$tsize-$d2;
            if ($op_tics ne "none") {
                $d1   = ($op_tics eq "cross")  ? 12 : 0;
                $d2   = ($op_tics eq "inside") ? 24 : 0;
                $xp1o = ($side eq "left") ? $op_loc-$d1    : $op_loc+$d1;
                $xp2o = ($side eq "left") ? $op_loc+12-$d2 : $op_loc-12+$d2;
            }
        }
        for ($i=0; $i<=$#long_ticks; $i++) {
            $jd = $long_ticks[$i];
            if ($reverse) {
                if ($orient eq "horizontal") {
                    $xp1 = $x1 +($x2-$x1)*($axmax-$jd)/($axmax-$axmin);
                    $xp2 = $xp1o = $xp2o = $xp1;
                } else {
                    $yp1 = $y1 +($y2-$y1)*($axmax-$jd)/($axmax-$axmin);
                    $yp2 = $yp1o = $yp2o = $yp1;
                }
            } else {
                if ($orient eq "horizontal") {
                    $xp1 = $x1 +($x2-$x1)*($jd-$axmin)/($axmax-$axmin);
                    $xp2 = $xp1o = $xp2o = $xp1;
                } else {
                    $yp1 = $y1 +($y2-$y1)*($jd-$axmin)/($axmax-$axmin);
                    $yp2 = $yp1o = $yp2o = $yp1;
                }
            }
            if ($grid && $jd > $axmin && $jd < $axmax) {
                if ($orient eq "horizontal") {
                    @coords = ($xp1, $gr1, $xp1, $gr2);
                } else {
                    @coords = ($gr1, $yp1, $gr2, $yp1);
                }
                $canv->create_line(@coords, -fill  => &get_rgb_code($grcolor),
                                            -width => $grwidth,
                                            -arrow => 'none',
                                            -tags  => $gridtags);
            }
            if ($pr_tics ne "none") {
                $canv->create_line($xp1, $yp1, $xp2, $yp2,
                                   -fill  => &get_rgb_code("black"),
                                   -width => 1,
                                   -arrow => 'none',
                                   -tags  => $tags);
            }
            if ($op_tics ne "none") {
                $canv->create_line($xp1o, $yp1o, $xp2o, $yp2o,
                                   -fill  => &get_rgb_code("black"),
                                   -width => 1,
                                   -arrow => 'none',
                                   -tags  => $op_tags);
            }
        }
    }
    if ($minor != 0 && ($pr_tics ne "none" || $op_tics ne "none")) {
        $nt = int(($axmax -$axmin)/$major +0.00001) +1;
        if ($orient eq "horizontal") {
            $add_minor = (abs($x2-$x1)/$nt > 30) ? 1 : 0;
        } else {
            $add_minor = (abs($y2-$y1)/$nt > 30) ? 1 : 0;
        }
        if ($add_minor) {
            if ($reverse) {
                for ($i=$axmax-$major/2.; $i>=$axmin; $i-=$major) {
                    if ($orient eq "horizontal") {
                        $xp4 = $x1 +($x2-$x1)*($axmax-$i)/($axmax-$axmin);
                        $xp5 = $xp4o = $xp5o = $xp4;
                    } else {
                        $yp4 = $y1 +($y2-$y1)*($axmax-$i)/($axmax-$axmin);
                        $yp5 = $yp4o = $yp5o = $yp4;
                    }
                    if ($pr_tics ne "none") {
                        $canv->create_line($xp4, $yp4, $xp5, $yp5,
                                           -fill  => &get_rgb_code("black"),
                                           -width => 1,
                                           -arrow => 'none',
                                           -tags  => $tags);
                    }
                    if ($op_tics ne "none") {
                        $canv->create_line($xp4o, $yp4o, $xp5o, $yp5o,
                                           -fill  => &get_rgb_code("black"),
                                           -width => 1,
                                           -arrow => 'none',
                                           -tags  => $op_tags);
                    }
                }
            } else {
                for ($i=$axmin+$major/2.; $i<=$axmax; $i+=$major) {
                    if ($orient eq "horizontal") {
                        $xp4 = $x1 +($x2-$x1)*($i-$axmin)/($axmax-$axmin);
                        $xp5 = $xp4o = $xp5o = $xp4;
                    } else {
                        $yp4 = $y1 +($y2-$y1)*($i-$axmin)/($axmax-$axmin);
                        $yp5 = $yp4o = $yp5o = $yp4;
                    }
                    if ($pr_tics ne "none") {
                        $canv->create_line($xp4, $yp4, $xp5, $yp5,
                                           -fill  => &get_rgb_code("black"),
                                           -width => 1,
                                           -arrow => 'none',
                                           -tags  => $tags);
                    }
                    if ($op_tics ne "none") {
                        $canv->create_line($xp4o, $yp4o, $xp5o, $yp5o,
                                           -fill  => &get_rgb_code("black"),
                                           -width => 1,
                                           -arrow => 'none',
                                           -tags  => $op_tags);
                    }
                }
            }
        }
    }
    for ($i=0; $i<=$#tick_jd2; $i++) {
        $jd    = $tick_jd2[$i];
        $label = $tick_labels2[$i];
        $d3    = ($pr_tics =~ /inside|none/) ? 6 : 0;
        if ($reverse) {
            if ($orient eq "horizontal") {
                $xp3 = $x1 +($x2-$x1)*($axmax-$jd)/($axmax-$axmin);
                $yp3 = ($side eq "bottom") ? $y1+9+$tsize+$xtra-$d3 : $y1-9-$tsize-$xtra+$d3;
            } else {
                $yp3 = $y1 +($y2-$y1)*($axmax-$jd)/($axmax-$axmin);
                $xp3 = ($side eq "left") ? $x1-12-$tsize+$d3 : $x1+12+$tsize-$d3;
            }
        } else {
            if ($orient eq "horizontal") {
                $xp3 = $x1 +($x2-$x1)*($jd-$axmin)/($axmax-$axmin);
                $yp3 = ($side eq "bottom") ? $y1+9+$tsize+$xtra-$d3 : $y1-9-$tsize-$xtra+$d3;
            } else {
                $yp3 = $y1 +($y2-$y1)*($jd-$axmin)/($axmax-$axmin);
                $xp3 = ($side eq "left") ? $x1-12-$tsize+$d3 : $x1+12+$tsize-$d3;
            }
        }
        $canv->create_text($xp3, $yp3,
                           -anchor => $anc,
                           -text   => $label,
                           -fill   => &get_rgb_code("black"),
                           -angle  => $ang,
                           -tags   => $tags,
                           -font   => [-family     => $family,
                                       -size       => $title_size,
                                       -weight     => $title_weight,
                                       -slant      => 'roman',
                                       -underline  => 0,
                                       -overstrike => 0,
                                      ]);
    }
    if ($title ne "" && $fmt ne "Mon-DD-YYYY") {
        $tags .= "Title";
        $d3    = ($pr_tics =~ /inside|none/) ? 6 : 0;
        if ($orient eq "horizontal") {
            $xp1 = ($x1+$x2)/2.;
            $ang = 0;
            $yp1 = ($side eq "bottom") ? $y1+9+$tsize+$xtra-$d3 : $y1-9-$tsize-$xtra+$d3;
            $anc = ($side eq "bottom") ? 'n' : 's';
        } else {
            $yp1 = ($y1+$y2)/2.;
            $anc = 's';
            $xp1 = ($side eq "left") ? $x1-12-$tsize+$d3 : $x1+12+$tsize-$d3;
            $ang = ($side eq "left") ? 90 : 270;
        }
        $canv->create_text($xp1, $yp1,
                           -anchor => $anc,
                           -text   => $title,
                           -fill   => &get_rgb_code("black"),
                           -angle  => $ang,
                           -tags   => $tags,
                           -font   => [-family     => $family,
                                       -size       => $title_size,
                                       -weight     => $title_weight,
                                       -slant      => 'roman',
                                       -underline  => 0,
                                       -overstrike => 0,
                                      ]);
    }
}


sub find_axis_limits {
    my ($axmin, $axmax) = @_;
    my (
        $i, $last_major, $last_ratio, $major, $power, $range, $ratio, $val,
        @mult,
       );

    @mult = (1, 2, 2.5, 3, 4, 5, 6, 7, 7.5, 8, 9, 10, 20, 25, 30, 40, 50);

    $axmin = 0. if ($axmin > 0 && $axmin < $axmax *0.2);
    $range = $axmax -$axmin;
    if ($range == 0.) {
        if ($axmin >= 0. && $axmin < 0.5) {
            $axmin = 0.0;
            $axmax = 1.0;
        } else {
            $axmin -= 0.5;
            $axmax += 0.5;
        }
        $major = 0.5;
        return ($axmin, $axmax, $major);
    }
    $power = &floor(&log10($range)) -1;
    $major = $mult[0] *(10**$power);
    $ratio = $range /$major;
    for ($i=1; $i<=$#mult; $i++) {
        $last_major = $major;
        $last_ratio = $ratio;
        $major = $mult[$i] *(10**$power);
        $ratio = $range /$major;
        if ($ratio < 5) {
            if (abs($ratio -5) < abs($last_ratio -5)) {
                last;
            } else {
                $major = $last_major;
                last;
            }
        }
    }
    $val = 0.;
    if ($axmin < 0) {
        while ($val > $axmin) {
            $val -= $major;
        }
    } else {
        while ($val +$major <= $axmin) {
            $val += $major;
        }
    }
    $axmin = $val;
    $val = 0.;
    if ($axmax < 0) {
        while ($val -$major >= $axmax) {
            $val -= $major;
        }
    } else {
        while ($val < $axmax) {
            $val += $major;
        }
    }
    $axmax = $val;

    return ($axmin, $axmax, $major);
}


sub make_color_key {
    my ($canv, %key_props) = @_;
    my (
        $ch, $clabel, $cmax, $cmin, $cw, $digits, $fmt, $fmt_w, $font,
        $i, $inc, $j, $range, $size1, $size2, $tag1, $tag2, $tags, $title,
        $weight1, $weight2, $xleg, $yleg, $ypos,

        @color, @scale,
       );

    $xleg    = $key_props{xleg};
    $yleg    = $key_props{yleg};
    $cw      = $key_props{width};
    $ch      = $key_props{height};
    $title   = $key_props{title};
    $font    = $key_props{font};
    $size1   = $key_props{size1};
    $size2   = $key_props{size2};
    $weight1 = $key_props{weight1};
    $weight2 = $key_props{weight2};
    $digits  = $key_props{digits};
    $tags    = $key_props{tags};
    @color   = @{ $key_props{colors} };
    @scale   = @{ $key_props{scale} };
    $range   = abs($scale[$#scale] -$scale[0]);

    if (defined($key_props{major}) && $key_props{major} ne "auto" && $key_props{major} ne "") {
        $inc = $key_props{major};
        if ($inc <= 0) {
            $inc = "auto";
        } elsif ($inc > $range) {
            $inc = $range;
        }
    } else {
        $inc = "auto";
    }

#   Format the scale numbers for display
    $fmt_w = length(int(&max(abs($scale[0]),abs($scale[$#scale]))));
    $fmt_w++ if ($scale[0] < 0 || $scale[$#scale] < 0);
    if ($digits > 0) {
        $fmt_w += $digits +1;
        $fmt = "%${fmt_w}.${digits}f";
    } else {
        $fmt = "%${fmt_w}d";
    }

#   Draw the color key
    for ($i=0; $i<=$#color; $i++) {
        $j = $#color -$i;
        $canv->create_rectangle($xleg, $yleg+$ch*$i, $xleg+$cw, $yleg+$ch*($i+1),
                         -outline => "",
                         -width   => 0,
                         -fill    => $color[$j],
                         -tags    => $tags);
    }

#   Add the numeric color labels
    if ($inc eq "auto") {
        for ($i=0; $i<=$#scale; $i++) {
            $scale[$i] = sprintf($fmt, $scale[$i]);
        }
        $inc = int($size1 /&max(1,$ch-2)) +1;
        for ($i=0; $i<=$#color+1; $i+=$inc) {
            $j = $#color +1 -$i;
            $canv->create_text($xleg+$cw+4, $yleg+$ch*$i,
                               -anchor  => 'w',
                               -text    => $scale[$j],
                               -fill    => &get_rgb_code("black"),
                               -angle   => 0,
                               -tags    => $tags,
                               -font    => [-family     => $font,
                                            -size       => $size1,
                                            -weight     => $weight1,
                                            -slant      => 'roman',
                                            -underline  => 0,
                                            -overstrike => 0,
                                           ]);
        }
    } else {
        $cmin = sprintf($fmt, $scale[0]);
        $cmax = sprintf($fmt, $scale[$#scale]);
        for ($i=$cmax; $i>=$cmin-0.000001; $i-=$inc) {
            $i = 0.0 if (abs($cmax-$cmin) > 0.00001 && abs($i) <= 0.000001);
            $clabel = sprintf($fmt, $i);
            $ypos = $yleg +$ch*($#color+1)*($cmax-$i)/$range;
            $canv->create_text($xleg+$cw+4, $ypos,
                               -anchor  => 'w',
                               -text    => $clabel,
                               -fill    => &get_rgb_code("black"),
                               -angle   => 0,
                               -tags    => $tags,
                               -font    => [-family     => $font,
                                            -size       => $size1,
                                            -weight     => $weight1,
                                            -slant      => 'roman',
                                            -underline  => 0,
                                            -overstrike => 0,
                                           ]);
        }
    }

#   Add the color key title
    if ($title ne "") {
        $tags .= "Title";
        $canv->create_text($xleg-5, $yleg+0.5*$ch*($#color+1),
                           -anchor  => 's',
                           -justify => 'center',
                           -text    => $title,
                           -fill    => &get_rgb_code("black"),
                           -angle   => 90,
                           -tags    => $tags,
                           -font    => [-family     => $font,
                                        -size       => $size2,
                                        -weight     => $weight2,
                                        -slant      => 'roman',
                                        -underline  => 0,
                                        -overstrike => 0,
                                       ]);
        ($tag1 = $tags) =~ s/.* //;
        $tag2 = substr($tag1,0,-5);
        $canv->addtag($tag2, withtag => $tag1);
    }
}


sub make_ts_legend {
    my ($canv, %legend_props) = @_;
    my (
        $box_tags, $edge, $edgec, $esize, $eweight, $fill, $fillc, $font,
        $leg_tag, $n, $ne, $tag, $tags, $title, $tsize, $tweight, $xpos,
        $ypos,
        @coords, @entries, @taglist,
       );

    $ne      = $legend_props{num};
    $xpos    = $legend_props{xpos};
    $ypos    = $legend_props{ypos};
    $title   = $legend_props{title};
    $font    = $legend_props{font};
    $esize   = $legend_props{esize};
    $tsize   = $legend_props{tsize};
    $eweight = $legend_props{eweight};
    $tweight = $legend_props{tweight};
    $edge    = $legend_props{edge};      # border: 0 = off, 1 = on
    $edgec   = $legend_props{edgec};     # border color
    $fill    = $legend_props{fill};      # fill: 0 = off, 1 = on
    $fillc   = $legend_props{fillc};     # fill color
    $tags    = $legend_props{tags};
    @entries = @{ $legend_props{entries} };

    $box_tags = $tags;
    @taglist = split(/ /, $box_tags);
    foreach $tag (@taglist) {
        if ($tag =~ /_legend$/) {
            $box_tags .= " " . $tag . "Box";
            $leg_tag   = $tag;
            last;
        }
    }

#   Create legend title
    if ($title ne "") {
        $canv->create_text($xpos, $ypos,
                           -anchor => 'w',
                           -text   => $title,
                           -fill   => &get_rgb_code("black"),
                           -angle  => 0,
                           -tags   => $tags,
                           -font   => [-family     => $font,
                                       -size       => $tsize,
                                       -weight     => $tweight,
                                       -slant      => 'roman',
                                       -underline  => 0,
                                       -overstrike => 0,
                                      ]);
        $ypos += $tsize *1.5;
    }

#   Create legend entries
    for ($n=0; $n<$ne; $n++) {
        $canv->create_line($xpos, $ypos, $xpos+20, $ypos,
                           -fill   => &get_rgb_code($entries[$n]{color}),
                           -width  => $entries[$n]{width},
                           -arrow  => 'none',
                           -tags   => $tags);
        $canv->create_text($xpos+25, $ypos,
                           -anchor => 'w',
                           -text   => $entries[$n]{text},
                           -fill   => &get_rgb_code("black"),
                           -angle  => 0,
                           -tags   => $tags,
                           -font   => [-family     => $font,
                                       -size       => $esize,
                                       -weight     => $eweight,
                                       -slant      => 'roman',
                                       -underline  => 0,
                                       -overstrike => 0,
                                      ]);
        $ypos += $esize *1.5;
    }

#   Create legend outline and fill, if requested
    if ((($edge && $edgec ne "") || ($fill && $fillc ne "")) && ($title ne "" || $ne > 0)) {
        @coords = Tkx::SplitList($canv->bbox($leg_tag));
        $coords[0] -= 5;
        $coords[1] -= 4;
        $coords[2] += 5;
        $coords[3] += 4;
        if ($edge && $edgec ne "" && $fill && $fillc ne "") {
            $canv->create_rectangle(@coords,
                           -outline => &get_rgb_code($edgec),
                           -width   => 1,
                           -fill    => &get_rgb_code($fillc),
                           -tags    => $box_tags);
        } elsif ($edge && $edgec ne "") {
            $canv->create_rectangle(@coords,
                           -outline => &get_rgb_code($edgec),
                           -width   => 1,
                           -fill    => "",
                           -tags    => $box_tags);
        } else {
            $canv->create_rectangle(@coords,
                           -outline => "",
                           -width   => 0,
                           -fill    => &get_rgb_code($fillc),
                           -tags    => $box_tags);
        }
    }
}


sub update_legend_box {
    my ($canv, $id) = @_;
    my (
        $box_exists, $box_tags, $edge, $edgec, $fill, $fillc, $gtag,
        $item, $legend_exists,
        @coords, @items, @taglist,
       );

    $edge  = $gr_props{$id}{le_edge};
    $edgec = $gr_props{$id}{le_edgec};
    $fill  = $gr_props{$id}{le_fill};
    $fillc = $gr_props{$id}{le_fillc};

    return if ((! $edge || $edgec eq "") && (! $fill || $fillc eq ""));

    $gtag = "graph" . $id;
    $legend_exists = $box_exists = 0;

    @items = Tkx::SplitList($canv->find_withtag($gtag . "_legend"));
    foreach $item (@items) {
        @taglist = Tkx::SplitList($canv->gettags($item));
        if (&list_search($gtag . "_legendBox", @taglist) >= 0) {
            $box_exists = 1;
            next;
        }
        $legend_exists = 1;
        $canv->addtag('group_legend', withtag => $item);
    }
    return if (! $legend_exists);

    @coords = Tkx::SplitList($canv->bbox('group_legend'));
    $canv->dtag('group_legend');
    $coords[0] -= 5;
    $coords[1] -= 4;
    $coords[2] += 5;
    $coords[3] += 4;
    if ($box_exists) {
        $canv->coords($gtag . "_legendBox", @coords);
    } else {
        $box_tags = $gtag . " " . $gtag . "_legend" . " " . $gtag . "_legendBox";
        if ($edge && $edgec ne "" && $fill && $fillc ne "") {
            $canv->create_rectangle(@coords,
                           -outline => &get_rgb_code($edgec),
                           -width   => 1,
                           -fill    => &get_rgb_code($fillc),
                           -tags    => $box_tags);
        } elsif ($edge && $edgec ne "") {
            $canv->create_rectangle(@coords,
                           -outline => &get_rgb_code($edgec),
                           -width   => 1,
                           -fill    => "",
                           -tags    => $box_tags);
        } else {
            $canv->create_rectangle(@coords,
                           -outline => "",
                           -width   => 0,
                           -fill    => &get_rgb_code($fillc),
                           -tags    => $box_tags);
        }
    }
}


################################################################################
#
# Date calculations
#
################################################################################

sub rebuild_datelist {
    my ($honor_global_limits) = @_;
    my ($dt, $first, $i, $id,
        @mydates, @slice_data,
        %pdata,
       );

    $honor_global_limits = 1 if (! defined($honor_global_limits) || $honor_global_limits eq ""
                                                                 || $honor_global_limits ne "0");

#   Remove animation toolbar, because the number of frames may change
    if (defined($animate_tb) && Tkx::winfo_exists($animate_tb)) {
        if ($animate_tb->g_wm_title() eq "Animation toolbar") {
            $animate_tb->g_destroy();
            undef $animate_tb;
        }
    }
    $status_line = "Rebuilding animation dates list...";
    Tkx::update_idletasks();

#   Save the current date, and rebuild the dates array
    $dt    = $dates[$dti-1];
    @dates = ();
    $first = 1;
    for ($i=0; $i<=$#animate_ids; $i++) {
        $id = $animate_ids[$i];
        next if ($props{$id}{meta}
                     !~ /^(data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)$/);

        if ($props{$id}{meta} =~ /data_profile|vert_wd_zone/) {
            %pdata = %{ $gr_props{$id}{pdata} };

        } elsif ($props{$id}{meta} eq "w2_profile") {
            %pdata = %{ $gr_props{$id}{parm_data} };

        } elsif ($props{$id}{meta} eq "w2_slice") {
            @slice_data = @{ $gr_props{$id}{slice_data} };
            %pdata      = %{ $slice_data[0] };

        } elsif ($props{$id}{meta} eq "w2_outflow") {
            %pdata = %{ $gr_props{$id}{qdata} };

        } elsif ($props{$id}{meta} eq "w2_wlevels") {
            %pdata = %{ $gr_props{$id}{wl_data} };
        }
        @mydates = sort keys %pdata;
        if ($first) {
            @dates = @mydates;
            $first = 0;
        } else {
            @dates = &merge_dates(\@dates, \@mydates);
        }
        undef %pdata;
    }
    if ($global_dt_limits && $honor_global_limits) {     # Truncate date range if global limits
        @dates = &truncate_dates($global_dt_begin, $global_dt_end, @dates);
    }
    $status_line = "";

#   Reset the date indices
    $dti_max = $#dates+1;
    $dti     = 1 + &nearest_dt_index($dt, @dates);
    $dti++ if ($dti == 0);
    $dti_old = $dti;
}


sub set_global_date_limits {
    my ($X, $Y) = @_;
    my (
        $align_btn, $align_slices, $bd_narrow, $bdate_frame, $bday,
        $bday_cb, $bday_sav, $bm, $bm_narrow, $bmon, $bmon_cb, $bmon_sav,
        $by_narrow, $byr, $byr_cb, $byr_sav, $cancel_btn, $d, $dt_max,
        $dt_min, $ed_narrow, $edate_frame, $eday, $eday_cb, $eday_sav,
        $em, $em_narrow, $emon, $emon_cb, $emon_sav, $ey_narrow, $eyr,
        $eyr_cb, $eyr_sav, $f, $f2, $fr, $fr_row, $frame, $geom, $got_slice,
        $got_slice_limits, $id, $limit_dates, $limits_frame, $m, $max_dtmin,
        $min_dtmax, $narrow, $narrow_btn, $nobj, $ok_btn, $rm_slice_limits,
        $row, $row2, $sc_canv, $sc_fr, $txt, $type, $vscroll, $y, $yr_max,
        $yr_min,

        %date_max, %date_min,
       );

    if ($X == 0) {
        (undef, $X, $Y) = split(/\+/, $main->g_wm_geometry());
        $X += 100;
        $Y += 100;
    }
    $geom = sprintf("+%d+%d", $X, $Y);

    if (defined($date_limits_menu) && Tkx::winfo_exists($date_limits_menu)) {
        if ($date_limits_menu->g_wm_title() eq "Global Date Limits") {
            $date_limits_menu->g_destroy();
            undef $date_limits_menu;
        }
    }
    $date_limits_menu = $main->new_toplevel();
    $date_limits_menu->g_wm_transient($main);
    $date_limits_menu->g_wm_title("Global Date Limits");
    $date_limits_menu->configure(-cursor => $cursor_norm);
    $date_limits_menu->g_wm_geometry($geom);

#   Try to keep any objects from being selected. Reset bindings later.
    $canvas->g_bind("<Motion>", "");

#   Set some variables
    %date_min  = %date_max = ();
    $dt_min    = $dt_max   = $max_dtmin = $min_dtmax = -999;
    $narrow    = $nobj     = 0;
    $got_slice = $align_slices = $got_slice_limits = $rm_slice_limits = 0;

    if ($global_dt_limits && $global_dt_begin =~ /^[12][0-9][0-9][0-9][01][0-9][0-3][0-9]0000$/
                          && $global_dt_end   =~ /^[12][0-9][0-9][0-9][01][0-9][0-3][0-9]0000$/) {
        $limit_dates       = $global_dt_limits;
    } else {
        $limit_dates     = $global_dt_limits = 0;
        $global_dt_begin = $global_dt_end    = "na";
    }

    foreach $id (@animate_ids) {
        if ($props{$id}{meta} =~ /^(data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)$/) {
            $date_min{$id} = $gr_props{$id}{date_min};
            $date_max{$id} = $gr_props{$id}{date_max};
            if ($date_min{$id} != -999) {
                $dt_min        = $date_min{$id} if ($dt_min    == -999 || $dt_min    > $date_min{$id});
                $max_dtmin     = $date_min{$id} if ($max_dtmin == -999 || $max_dtmin < $date_min{$id});
                ($m, $d, $y)   = &parse_date($date_min{$id}, 1);
                $date_min{$id} = sprintf("%s-%02d-%04d", $mon_names[$m-1], $d, $y);
            }
            if ($date_max{$id} != -999) {
                $dt_max        = $date_max{$id} if ($dt_max    == -999 || $dt_max    < $date_max{$id});
                $min_dtmax     = $date_max{$id} if ($min_dtmax == -999 || $min_dtmax > $date_max{$id});
                ($m, $d, $y)   = &parse_date(&jdate2date(&ceil(&date2jdate($date_max{$id}))), 1);
                $date_max{$id} = sprintf("%s-%02d-%04d", $mon_names[$m-1], $d, $y);
            }
            if ($props{$id}{meta} eq "w2_slice") {
                $got_slice = 1;
                $got_slice_limits = 1 if ($props{$id}{dt_limits});
            }
            $nobj++;
        }
    }

#   Saved dates. _sav = initial; _narrow = minimum
    ($bm_narrow, $bd_narrow, $by_narrow) = &parse_date($max_dtmin, 1);
    ($em_narrow, $ed_narrow, $ey_narrow) = &parse_date(&jdate2date(&ceil(&date2jdate($min_dtmax))), 1);
    $bd_narrow += 0;
    $ed_narrow += 0;
    $bm_narrow  = $mon_names[$bm_narrow-1];
    $em_narrow  = $mon_names[$em_narrow-1];

    if ($limit_dates) {
        ($bm, $bday, $byr) = &parse_date($global_dt_begin, 1);
        ($em, $eday, $eyr) = &parse_date(&jdate2date(&ceil(&date2jdate($global_dt_end))),   1);
    } else {
        ($bm, $bday, $byr) = &parse_date($dt_min, 1);
        ($em, $eday, $eyr) = &parse_date(&jdate2date(&ceil(&date2jdate($dt_max))), 1);
    }
    $bday += 0;
    $eday += 0;
    $bm--;
    $em--;
    $bmon     = $mon_names[$bm];
    $emon     = $mon_names[$em];
    $bmon_sav = $bmon;
    $bday_sav = $bday;
    $byr_sav  = $byr;
    $emon_sav = $emon;
    $eday_sav = $eday;
    $eyr_sav  = $eyr;

    $yr_max = (localtime(time))[5] +1900;
    $yr_min = $yr_max -25;
    $yr_min = &min($yr_min, $by_narrow, $byr);
    $yr_max = &min($yr_max, $ey_narrow, $eyr);

#   Build the menu.
    $frame = $date_limits_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -command => sub { my (
                                  $anim_tb, $begin_jd, $dt, $dt_begin, $dt_end, $dt1, $dt2,
                                  $first_jd, $first_slice_dt, $height, $hr, $jd_offset, $jd1,
                                  $jd2, $last_jd, $last_slice_dt, $m, $maxrow, $mi, $n, $pbar,
                                  $pbar_img, $pbar_win, $pos, $result, $sav_dti, $width, $X, $Y,

                                  @cpl_files, @labels, @msgs, @sav_dates, @wbs,
                                  %parms,
                                 );

                              @msgs     = ();
                              $m        = &list_match($bmon, @mon_names);
                              $dt_begin = sprintf("%04d%02d%02d0000", $byr, $m+1, $bday);
                              $m        = &list_match($emon, @mon_names);
                              $dt_end   = sprintf("%04d%02d%02d0000", $eyr, $m+1, $eday);

                              if ((! $limit_dates && ! $global_dt_limits && ! $rm_slice_limits) ||
                                  ($limit_dates && $global_dt_limits
                                                && $dt_begin eq $global_dt_begin
                                                && $dt_end   eq $global_dt_end
                                                && ! $align_slices && ! $rm_slice_limits)) {
                                  $result = &pop_up_question($date_limits_menu,
                                                             "No changes were made. Try again?");
                                  return if (lc($result) eq "yes");
                                  $date_limits_menu->g_bind('<Destroy>', "");
                                  $date_limits_menu->g_destroy();
                                  undef $date_limits_menu;
                                  &reset_bindings;
                                  return;
                              }

                              if ($limit_dates) {
                                  if ($dt_begin > $dt_end) {
                                      return &pop_up_error($date_limits_menu,
                                                  "The start date is after the end date.\n"
                                                . "Please adjust and try again.");
                                  } elsif ($dt_begin == $dt_end) {
                                      return &pop_up_error($date_limits_menu,
                                                  "The start date is the same as the end date.\n"
                                                . "Please adjust and try again.");
                                  }
                              }

                              $anim_tb = 0;
                              if (defined($animate_tb) && Tkx::winfo_exists($animate_tb)) {
                                  if ($animate_tb->g_wm_title() eq "Animation toolbar") {
                                      $anim_tb = 1;
                                      (undef, $X, $Y) = split(/\+/, $animate_tb->g_wm_geometry());
                                  }
                              }
                              @sav_dates = @dates;
                              $sav_dti   = $dti;
                              if (! $limit_dates ||
                                  ($limit_dates && $global_dt_limits
                                     && ($dt_begin > $dt_min || $dt_end < $dt_max))) {
                                  &rebuild_datelist(0);  # don't honor global limits here
                                  push (@msgs, "Rebuilding animation dates list...");
                              }

#                             If removing slice date limits, need to know full date range.
#                             Use saved values or scan input files for full date range.
                              if (length($dates[0]) == 12) {
                                  $first_slice_dt = $dates[0];
                                  $last_slice_dt  = $dates[$#dates];
                              } else {
                                  $first_slice_dt = $dates[0] *10000;
                                  $last_slice_dt  = $dates[$#dates] *10000;
                              }
                              if ($limit_dates && $got_slice_limits && $rm_slice_limits) {
                                  foreach $id (@animate_ids) {
                                      next if ($props{$id}{meta} ne "w2_slice");
                                      if ($props{$id}{dt_limits}) {
                                          if (! defined($props{$id}{start_dt})) {
                                              push (@msgs, "Scanning slice $props{$id}{gnum} "
                                                         . "for full date range...");
                                              @wbs = split(/,/, $props{$id}{wb_list});
                                              if ($props{$id}{src_type} =~ /Contour/i) {
                                                  @cpl_files = @{ $props{$id}{cpl_files} };
                                                  ($pbar_win, $pbar, $pbar_img)
                                                      = &create_alt_progress_bar($main, $id,
                                                                            "Scanning W2 contour files...");
                                                  for ($n=0; $n<=$#wbs; $n++) {
                                                      (undef, undef, undef, undef, $jd1, $jd2)
                                                            = &scan_w2_cpl_file($main, $cpl_files[$n],
                                                                                $id, 1, $pbar_img);
                                                      if ($n == 0) {
                                                          $first_jd = $jd1;
                                                          $last_jd  = $jd2;
                                                      } else {
                                                          $first_jd = $jd1 if ($jd1 < $first_jd);
                                                          $last_jd  = $jd2 if ($jd2 > $last_jd);
                                                      }
                                                  }
                                                  &destroy_progress_bar($main, $pbar_win);

                                              } elsif ($props{$id}{src_type} =~ /Vector/i) {
                                                  $status_line = "Scanning W2 vector file...";
                                                  Tkx::update_idletasks();
                                                  (undef, undef, undef, $first_jd, $last_jd)
                                                      = &scan_w2_vector_file($main, $props{$id}{w2l_file},
                                                                             $id, 1);
                                                  $status_line = "";
                                                  Tkx::update_idletasks();
                                              }
                                              ($hr, $mi) = split(/:/, $props{$id}{tz_offset});
                                              $hr += 0;
                                              $mi += 0;
                                              $mi *= -1 if ($hr < 0);
                                              $jd_offset = $hr/24. +$mi/1440.;
                                              $begin_jd  = &date2jdate(sprintf("%04d%02d%02d",
                                                                               $props{$id}{byear}, 1, 1));
                                              $props{$id}{start_dt} = &jdate2date($first_jd +$jd_offset
                                                                                  +$begin_jd -1);
                                              $props{$id}{end_dt}   = &jdate2date($last_jd  +$jd_offset
                                                                                  +$begin_jd -1);
                                          }
                                          if ($first_slice_dt > $props{$id}{start_dt}) {
                                              $first_slice_dt = $props{$id}{start_dt};
                                          }
                                          if ($last_slice_dt < $props{$id}{end_dt}) {
                                              $last_slice_dt = $props{$id}{end_dt};
                                          }
                                      }
                                  }
                              }

#                             Check date ranges and set global limits
                              if ($limit_dates) {
                                  if (length($dates[0]) == 12) {
                                      if ((! $rm_slice_limits && $dt_begin > $dates[$#dates])
                                           || ($rm_slice_limits && $dt_begin > $last_slice_dt)) {
                                          @dates   = @sav_dates;
                                          $dti     = $dti_old = $sav_dti;
                                          $dti_max = $#dates+1;
                                          return &pop_up_error($date_limits_menu,
                                                      "The start date is after all available data.\n"
                                                    . "Please adjust and try again.");
                                      } elsif ((! $rm_slice_limits && $dt_end < $dates[0])
                                                || ($rm_slice_limits && $dt_end < $first_slice_dt)) {
                                          @dates   = @sav_dates;
                                          $dti     = $dti_old = $sav_dti;
                                          $dti_max = $#dates+1;
                                          return &pop_up_error($date_limits_menu,
                                                      "The end date is before all available data.\n"
                                                    . "Please adjust and try again.");
                                      } elsif ((! $rm_slice_limits && $dt_begin <= $dates[0]
                                                                   && $dt_end   >= $dates[$#dates])
                                              || ($rm_slice_limits && $dt_begin <= $first_slice_dt
                                                                   && $dt_end   >= $last_slice_dt)) {
                                          @dates   = @sav_dates;
                                          $dti     = $dti_old = $sav_dti;
                                          $dti_max = $#dates+1;
                                          return &pop_up_error($date_limits_menu,
                                                      "The start and end dates encompass all data.\n"
                                                    . "A global date restriction is unnecessary.\n"
                                                    . "Adjust and try again?");
                                      }
                                  } elsif (length($dates[0]) == 8) {
                                      if ((! $rm_slice_limits && $dt_begin/10000 > $dates[$#dates])
                                           || ($rm_slice_limits && $dt_begin > $last_slice_dt)) {
                                          @dates   = @sav_dates;
                                          $dti     = $dti_old = $sav_dti;
                                          $dti_max = $#dates+1;
                                          return &pop_up_error($date_limits_menu,
                                                      "The start date is after all available data.\n"
                                                    . "Please adjust and try again.");
                                      } elsif ((! $rm_slice_limits && $dt_end/10000 < $dates[0])
                                                || ($rm_slice_limits && $dt_end < $first_slice_dt)) {
                                          @dates   = @sav_dates;
                                          $dti     = $dti_old = $sav_dti;
                                          $dti_max = $#dates+1;
                                          return &pop_up_error($date_limits_menu,
                                                      "The end date is before all available data.\n"
                                                    . "Please adjust and try again.");
                                      } elsif ((! $rm_slice_limits && $dt_begin/10000 <= $dates[0]
                                                                   && $dt_end/10000   >= $dates[$#dates])
                                              || ($rm_slice_limits && $dt_begin <= $first_slice_dt
                                                                   && $dt_end   >= $last_slice_dt)) {
                                          @dates   = @sav_dates;
                                          $dti     = $dti_old = $sav_dti;
                                          $dti_max = $#dates+1;
                                          return &pop_up_error($date_limits_menu,
                                                      "The start and end dates encompass all data.\n"
                                                    . "A global date restriction is unnecessary.\n"
                                                    . "Adjust and try again?");
                                      }
                                  }
                                  $global_dt_limits = 1;
                                  $global_dt_begin  = $dt_begin;
                                  $global_dt_end    = $dt_end;
                              } else {
                                  $global_dt_limits = 0;
                                  $global_dt_begin  = $global_dt_end = "na"
                              }

#                             Make some space in the menu for some status messages
                              $ok_btn->configure(-state => 'disabled');
                              $cancel_btn->configure(-state => 'disabled');
                              ($width, $height, undef, undef)
                                  = split(/x|\+/, $date_limits_menu->g_wm_geometry());
                              $date_limits_menu->g_wm_minsize($width,$height);
                              $date_limits_menu->configure(-cursor => $cursor_wait);
                              $f2->g_grid_remove();
                              Tkx::update();
                              ($f2 = $f->new_frame(
                                      -borderwidth => 1,
                                      -relief      => 'flat',
                                      ))->g_grid(-row => $row, -column => 0, -columnspan => 2,
                                                 -sticky => 'nsew', -pady => 2);
                              $maxrow = $row2+1;
                              $row2   = -1;
                              @labels = ();
                              for ($n=0; $n<=$#msgs; $n++) {
                                  $row2++;
                                  ($labels[$row2] = $f2->new_label(
                                          -text => $msgs[$n],
                                          -font => 'default',
                                          ))->g_grid(-row => $row2, -column => 0, -sticky => 'w');
                              }
                              Tkx::update();

#                             If date restrictions for W2 slice graphs are being aligned to global limits
#                               or removed entirely, then each slice plot needs to have its limits re-set,
#                               the inputs re-read, and the graph re-made.
                              if (($limit_dates && $align_slices) || $rm_slice_limits) {
                                  foreach $id (@animate_ids) {
                                      next if ($props{$id}{meta} ne "w2_slice");
                                      if ($limit_dates && $align_slices) {
                                          $dt1 = sprintf("%s-%02d-%04d", $bmon, $bday, $byr);
                                          $dt2 = sprintf("%s-%02d-%04d", $emon, $eday, $eyr);
                                          next if ($props{$id}{dt_limits} && $dt1 eq $props{$id}{dt_begin}
                                                                          && $dt2 eq $props{$id}{dt_end});
                                          $props{$id}{dt_limits} = 1;
                                          $props{$id}{dt_begin}  = $dt1;
                                          $props{$id}{dt_end}    = $dt2;

                                      } elsif ($rm_slice_limits) {
                                          next if (! $props{$id}{dt_limits});
                                          $props{$id}{dt_limits} = 0;
                                          $props{$id}{dt_begin}  = "na";
                                          $props{$id}{dt_end}    = "na";
                                      }
                                      if ($row2 >= $maxrow) {
                                          $labels[$row2 -$maxrow]->g_grid_remove();
                                          Tkx::update();
                                      }
                                      $row2++;
                                      ($labels[$row2] = $f2->new_label(
                                              -text => "Rebuilding W2 slice $props{$id}{gnum}...",
                                              -font => 'default',
                                              ))->g_grid(-row => $row2, -column => 0, -sticky => 'w');
                                      $parms{rebuild}    = 1;
                                      $parms{pmin}       = $gr_props{$id}{cs_min};
                                      $parms{pmax}       = $gr_props{$id}{cs_max};
                                      $parms{pmajor}     = $gr_props{$id}{cs_major};
                                      $parms{gtitle}     = $gr_props{$id}{gtitle};
                                      $parms{change}     = "misc";
                                      $props{$id}{parms} = { %parms };
                                      $props{$id}{data}  = 0;
                                      &make_w2_slice($canvas, $id, 0);

                                      $date_limits_menu->g_raise();
                                      $date_limits_menu->g_focus;
                                  }
                              }

#                             Truncate the dates array and replot all animated features
                              if ($limit_dates) {
                                  if ($row2 >= $maxrow) {
                                      $labels[$row2 -$maxrow]->g_grid_remove();
                                      Tkx::update();
                                  }
                                  $row2++;
                                  ($labels[$row2] = $f2->new_label(
                                          -text => "Truncating animation date list...",
                                          -font => 'default',
                                          ))->g_grid(-row => $row2, -column => 0, -sticky => 'w');
                                  Tkx::update_idletasks();
                                  $dt    = $dates[$dti-1];
                                  @dates = &truncate_dates($dt_begin, $dt_end, @dates);
                                  $dti   = 1 + &nearest_dt_index($dt, @dates);
                                  $dti++ if ($dti == 0);
                                  $dti_old = $dti;
                                  $dti_max = $#dates+1;
                                  $dt      = $dates[$dti-1];

                                  if ($row2 >= $maxrow) {
                                      $labels[$row2 -$maxrow]->g_grid_remove();
                                      Tkx::update();
                                  }
                                  $row2++;
                                  ($labels[$row2] = $f2->new_label(
                                          -text => "Updating graphs for date $dt...",
                                          -font => 'default',
                                          ))->g_grid(-row => $row2, -column => 0, -sticky => 'w');
                                  &update_animate(&get_formatted_date($dt));
                              }

#                             Rebuild the animation toolbar, if it was present
                              if ($anim_tb) {
                                  if (defined($animate_tb) && Tkx::winfo_exists($animate_tb)) {
                                      if ($animate_tb->g_wm_title() eq "Animation toolbar") {
                                          $animate_tb->g_destroy();
                                          undef $animate_tb;
                                      }
                                  }
                                  &animate_toolbar($X, $Y, -1);
                              }
                              $date_limits_menu->g_raise();
                              $date_limits_menu->g_focus;
                              Tkx::update();
                              sleep 1;

                              $date_limits_menu->g_bind('<Destroy>', "");
                              $date_limits_menu->g_destroy();
                              undef $date_limits_menu;
                              &reset_bindings;
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    ($cancel_btn = $frame->new_button(
            -text    => "Cancel",
            -command => sub { $date_limits_menu->g_bind('<Destroy>', "");
                              $date_limits_menu->g_destroy();
                              undef $date_limits_menu;
                              &reset_bindings;
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);

#   Reset bindings if this menu is destroyed by other than the Cancel button
    $date_limits_menu->g_bind('<Destroy>' => sub { undef $date_limits_menu;
                                                   &reset_bindings;
                                                 });

    ($f = $date_limits_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_pack(-side => 'top', -expand => 1, -fill => 'both');
    $row = 0;
    $f->new_label(
            -text => " Date ranges for animated objects:",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -columnspan => 2, -sticky => 'w', -pady => 2);

#   Need a scrollable container, and a canvas is about the only container that works.
#   Create a parent frame (sc_fr) for the canvas (sc_canv) and scrollbar (vscroll).
#   Then put a frame inside the canvas (fr) as a widget window to hold other menu items.
    $row++;
    ($sc_fr = $f->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_grid(-row => $row, -column => 0, -columnspan => 2, -sticky => 'nsew', -pady => 2);
    ($vscroll = $sc_fr->new_scrollbar(
            -orient => 'vertical',
            -width  => 15,
            ))->g_grid(-row => 0, -column => 1, -sticky => 'nse');
    ($sc_canv = $sc_fr->new_tk__canvas(
            -highlightthickness => 0,
            -yscrollcommand => [$vscroll, 'set'],
            ))->g_grid(-row => 0, -column => 0, -sticky => 'nsew');
    $vscroll->configure(-command => [$sc_canv, 'yview']);

    $fr = $sc_canv->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            );

    $fr_row = 0;
    $fr->new_label(
            -text => "#",
            -font => 'default',
            )->g_grid(-row => $fr_row, -column => 0, -padx => 2, -pady => 2);
    $fr->new_label(
            -text => "Object",
            -font => 'default',
            )->g_grid(-row => $fr_row, -column => 1, -padx => 2, -pady => 2);
    $fr->new_label(
            -text => "Start Date",
            -font => 'default',
            )->g_grid(-row => $fr_row, -column => 2, -padx => 2, -pady => 2);
    $fr->new_label(
            -text => "End Date",
            -font => 'default',
            )->g_grid(-row => $fr_row, -column => 3, -padx => 2, -pady => 2);
    if ($got_slice) {
        $fr->new_label(
                -text => "Date Limits",
                -font => 'default',
                )->g_grid(-row => $fr_row, -column => 4, -padx => 2, -pady => 2);
    }

    foreach $id (@animate_ids) {
        if ($props{$id}{meta} =~ /^(data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)$/) {
            ($type = $props{$id}{meta}) =~ s/_/ /g;
            $type = ucfirst($type);
            $fr_row++;
            $fr->new_label(
                    -text => $props{$id}{gnum},
                    -font => 'default',
                    )->g_grid(-row => $fr_row, -column => 0, -padx => 2, -pady => 2);
            $fr->new_label(
                    -text => $type,
                    -font => 'default',
                    )->g_grid(-row => $fr_row, -column => 1, -sticky => 'w', -padx => 2, -pady => 2);
            $fr->new_label(
                    -text => $date_min{$id},
                    -font => 'default',
                    )->g_grid(-row => $fr_row, -column => 2, -padx => 2, -pady => 2);
            $fr->new_label(
                    -text => $date_max{$id},
                    -font => 'default',
                    )->g_grid(-row => $fr_row, -column => 3, -padx => 2, -pady => 2);
            if ($got_slice) {
                if ($props{$id}{meta} eq "w2_slice" && $props{$id}{dt_limits}) {
                    $txt = "restricted";
                } else {
                    $txt = "none";
                }
                $fr->new_label(
                        -text => $txt,
                        -font => 'default',
                        )->g_grid(-row => $fr_row, -column => 4, -padx => 2, -pady => 2);
            }
        }
    }

    $sc_canv->create_window(0, 0,
            -anchor => 'nw',
            -window => $fr,
            -tags   => 'scrollable',
            );
    &update_scrollable_tab($date_limits_menu, $sc_fr, $sc_canv, 'scrollable', $vscroll);
    $sc_fr->g_grid_columnconfigure(0, -weight => 1);

    $row++;
    ($f2 = $f->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_grid(-row => $row, -column => 0, -columnspan => 2, -sticky => 'nsew', -pady => 2);

    $row2 = -1;
    if ($got_slice_limits) {
        $row2++;
        $f2->new_label(
                -text => "Slice Dates: ",
                -font => 'default',
                )->g_grid(-row => $row2, -column => 0, -sticky => 'e', -pady => 2);
        $f2->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "Remove all slice date restrictions",
                -font     => 'default',
                -variable => \$rm_slice_limits,
                -command  => sub { $align_slices = 0 if ($rm_slice_limits); },
                )->g_grid(-row => $row2, -column => 1, -sticky => 'w');
    }

    $row2++;
    $f2->new_label(
            -text => "Date Limits: ",
            -font => 'default',
            )->g_grid(-row => $row2, -column => 0, -sticky => 'e', -pady => 2);
    ($limits_frame = $f2->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row2, -column => 1, -sticky => 'w');
    $limits_frame->new_checkbutton(
            -onvalue  => 1,
            -offvalue => 0,
            -text     => "Impose global date limits ",
            -font     => 'default',
            -variable => \$limit_dates,
            -command  => sub { if ($limit_dates) {
                                   $bmon_cb->configure(-state => 'readonly');
                                   $bday_cb->configure(-state => 'readonly');
                                   $byr_cb->configure(-state  => 'readonly');
                                   $emon_cb->configure(-state => 'readonly');
                                   $eday_cb->configure(-state => 'readonly');
                                   $eyr_cb->configure(-state  => 'readonly');
                                   $align_btn->configure(-state => 'normal') if ($got_slice);
                                   $narrow_btn->configure(-state => 'normal') if ($max_dtmin < $min_dtmax
                                                                                  && $nobj > 1);
                                   if ($narrow) {
                                       $bmon = $bm_narrow;
                                       $bday = $bd_narrow;
                                       $byr  = $by_narrow;
                                       $emon = $em_narrow;
                                       $eday = $ed_narrow;
                                       $eyr  = $ey_narrow;
                                   } else {
                                       $bmon = $bmon_sav;
                                       $bday = $bday_sav;
                                       $byr  = $byr_sav;
                                       $emon = $emon_sav;
                                       $eday = $eday_sav;
                                       $eyr  = $eyr_sav;
                                   }
                               } else {
                                   $bmon_cb->configure(-state => 'disabled');
                                   $bday_cb->configure(-state => 'disabled');
                                   $byr_cb->configure(-state  => 'disabled');
                                   $emon_cb->configure(-state => 'disabled');
                                   $eday_cb->configure(-state => 'disabled');
                                   $eyr_cb->configure(-state  => 'disabled');
                                   $align_btn->configure(-state => 'disabled') if ($got_slice);
                                   $narrow_btn->configure(-state => 'disabled') if ($max_dtmin < $min_dtmax
                                                                                    && $nobj > 1);
                               }
                             },
            )->g_pack(-side => 'left', -anchor => 'w');
    $limits_frame->new_button(
            -text    => "Help",
            -command => sub { &pop_up_info($date_limits_menu,
                                    "Imposing global date limits will restrict the date range for\n"
                                  . "animatons. The global date restriction is independent of the\n"
                                  . "data stored with each animated object.\n\n"
                                  . "W2 Longitudinal Slice plots may have a separate date\n"
                                  . "restriction that affects the data stored with that object.\n"
                                  . "You may leave such restrictions in place, or modify them\n"
                                  . "here to align with a global date restriction. Such alignment\n"
                                  . "will force the data files for any W2 Longitudinal Slice plots\n"
                                  . "to be re-read and the slice images to be re-created.",
                                    "Global Date Limits");
                            },
            )->g_pack(-side => 'left', -anchor => 'w', -padx => 2);

    $row2++;
    $f2->new_label(
            -text => "Start Date: ",
            -font => 'default',
            )->g_grid(-row => $row2, -column => 0, -sticky => 'e', -pady => 2);
    ($bdate_frame = $f2->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row2, -column => 1, -sticky => 'w');
    ($bmon_cb = $bdate_frame->new_ttk__combobox(
            -textvariable => \$bmon,
            -values       => [ @mon_names ],
            -state        => 'readonly',
            -width        => 4,
            ))->g_pack(-side => 'left');
    $bmon_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($byr);
                          $bm = &list_match($bmon, @mon_names);
                          $bday_cb->configure(-values => [ 1 .. $days_in_month[$bm] ]);
                          $bday = $days_in_month[$bm] if ($bday > $days_in_month[$bm]);
                        }
                    );
    $bdate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($bday_cb = $bdate_frame->new_ttk__combobox(
            -textvariable => \$bday,
            -values       => [ 1 .. $days_in_month[$bm] ],
            -state        => 'readonly',
            -width        => 3,
            ))->g_pack(-side => 'left');
    $bdate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($byr_cb = $bdate_frame->new_ttk__combobox(
            -textvariable => \$byr,
            -values       => [ reverse($yr_min .. $yr_max) ],
            -state        => 'readonly',
            -width        => 5,
            ))->g_pack(-side => 'left');
    $byr_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($byr);
                          $bm = &list_match($bmon, @mon_names);
                          if ($bm == 1) {
                              $bday_cb->configure(-values => [ 1 .. $days_in_month[$bm] ]);
                              $bday = $days_in_month[$bm] if ($bday > $days_in_month[$bm]);
                          }
                          if ($byr == $yr_min || $byr == $yr_max) {
                              $yr_min -= 5 if ($byr == $yr_min);
                              $yr_max += 5 if ($byr == $yr_max);
                              $byr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                              $eyr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                          }
                        }
                    );

    $row2++;
    $f2->new_label(
            -text => "End Date: ",
            -font => 'default',
            )->g_grid(-row => $row2, -column => 0, -sticky => 'e', -pady => 2);
    ($edate_frame = $f2->new_frame(
            -borderwidth => 0,
            -relief      => 'flat',
            ))->g_grid(-row => $row2, -column => 1, -sticky => 'w');
    ($emon_cb = $edate_frame->new_ttk__combobox(
            -textvariable => \$emon,
            -values       => [ @mon_names ],
            -state        => 'readonly',
            -width        => 4,
            ))->g_pack(-side => 'left');
    $emon_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($eyr);
                          $em = &list_match($emon, @mon_names);
                          $eday_cb->configure(-values => [ 1 .. $days_in_month[$em] ]);
                          $eday = $days_in_month[$em] if ($eday > $days_in_month[$em]);
                        }
                    );
    $edate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($eday_cb = $edate_frame->new_ttk__combobox(
            -textvariable => \$eday,
            -values       => [ 1 .. $days_in_month[$em] ],
            -state        => 'readonly',
            -width        => 3,
            ))->g_pack(-side => 'left');
    $edate_frame->new_label(
            -text => "-",
            -font => 'default',
            )->g_pack(-side => 'left');
    ($eyr_cb = $edate_frame->new_ttk__combobox(
            -textvariable => \$eyr,
            -values       => [ reverse($yr_min .. $yr_max) ],
            -state        => 'readonly',
            -width        => 5,
            ))->g_pack(-side => 'left');
    $eyr_cb->g_bind("<<ComboboxSelected>>",
                    sub { &set_leap_year($eyr);
                          $em = &list_match($emon, @mon_names);
                          if ($em == 1) {
                              $eday_cb->configure(-values => [ 1 .. $days_in_month[$em] ]);
                              $eday = $days_in_month[$em] if ($eday > $days_in_month[$em]);
                          }
                          if ($eyr == $yr_min || $eyr == $yr_max) {
                              $yr_min -= 5 if ($eyr == $yr_min);
                              $yr_max += 5 if ($eyr == $yr_max);
                              $byr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                              $eyr_cb->configure(-values => [ reverse($yr_min .. $yr_max) ]);
                          }
                        }
                    );

    if ($max_dtmin < $min_dtmax && $nobj > 1) {
        $row2++;
        $f2->new_label(
                -text => "Options: ",
                -font => 'default',
                )->g_grid(-row => $row2, -column => 0, -sticky => 'e', -pady => 2);
        ($narrow_btn = $f2->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "Choose most restricted limits",
                -font     => 'default',
                -variable => \$narrow,
                -command  => sub { if ($narrow) {
                                       $bmon = $bm_narrow;
                                       $bday = $bd_narrow;
                                       $byr  = $by_narrow;
                                       $emon = $em_narrow;
                                       $eday = $ed_narrow;
                                       $eyr  = $ey_narrow;
                                       $bmon_cb->configure(-state => 'disabled');
                                       $bday_cb->configure(-state => 'disabled');
                                       $byr_cb->configure(-state  => 'disabled');
                                       $emon_cb->configure(-state => 'disabled');
                                       $eday_cb->configure(-state => 'disabled');
                                       $eyr_cb->configure(-state  => 'disabled');
                                   } else {
                                       $bmon = $bmon_sav;
                                       $bday = $bday_sav;
                                       $byr  = $byr_sav;
                                       $emon = $emon_sav;
                                       $eday = $eday_sav;
                                       $eyr  = $eyr_sav;
                                       $bmon_cb->configure(-state => 'readonly');
                                       $bday_cb->configure(-state => 'readonly');
                                       $byr_cb->configure(-state  => 'readonly');
                                       $emon_cb->configure(-state => 'readonly');
                                       $eday_cb->configure(-state => 'readonly');
                                       $eyr_cb->configure(-state  => 'readonly');
                                   }
                                 },
                ))->g_grid(-row => $row2, -column => 1, -sticky => 'w');
    }

    if ($got_slice) {
        $row2++;
        if ($max_dtmin >= $min_dtmax || $nobj <= 1) {
            $f2->new_label(
                    -text => "Options: ",
                    -font => 'default',
                    )->g_grid(-row => $row2, -column => 0, -sticky => 'e', -pady => 2);
        }
        ($align_btn = $f2->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "Align slice restrictions to global limits",
                -font     => 'default',
                -variable => \$align_slices,
                -command  => sub { $rm_slice_limits = 0 if ($align_slices); },
                ))->g_grid(-row => $row2, -column => 1, -sticky => 'w');
    }

    if ($limit_dates) {
        $bmon_cb->configure(-state => 'readonly');
        $bday_cb->configure(-state => 'readonly');
        $byr_cb->configure(-state  => 'readonly');
        $emon_cb->configure(-state => 'readonly');
        $eday_cb->configure(-state => 'readonly');
        $eyr_cb->configure(-state  => 'readonly');
        $narrow_btn->configure(-state => 'normal') if ($max_dtmin < $min_dtmax && $nobj > 1);
        $align_btn->configure(-state => 'normal') if ($got_slice);
    } else {
        $bmon_cb->configure(-state => 'disabled');
        $bday_cb->configure(-state => 'disabled');
        $byr_cb->configure(-state  => 'disabled');
        $emon_cb->configure(-state => 'disabled');
        $eday_cb->configure(-state => 'disabled');
        $eyr_cb->configure(-state  => 'disabled');
        $narrow_btn->configure(-state => 'disabled') if ($max_dtmin < $min_dtmax && $nobj > 1);
        $align_btn->configure(-state => 'disabled') if ($got_slice);
    }
    $f2->g_grid_columnconfigure(1, -weight => 1);

    Tkx::wm_resizable($date_limits_menu,0,0);
    &adjust_window_position($date_limits_menu);
    $date_limits_menu->g_focus;
}


################################################################################
#
# Animation tools
#
################################################################################

sub animate_toolbar {
    my ($X, $Y, $id) = @_;
    my (
        $bkwd_btn, $date_label, $end_btn, $faster_btn, $faster_img, $frame,
        $fr_btns, $fr_msgs, $frame_label, $fwd_btn, $geom, $pause_img,
        $play_btn, $play_img, $repeat_btn, $repeat_img, $repeaton_img,
        $reverse_img, $rvrs_btn, $slower_btn, $slower_img, $step_bkw_img,
        $step_fwd_img, $stop_btn, $stop_img, $strt_btn, $to_end_img,
        $to_start_img, $tooltip,
       );

    $geom = sprintf("+%d+%d", $X, $Y);
    &end_select($canvas, $id, 1) if (defined($id) && $id != -1);

    if (defined($animate_tb) && Tkx::winfo_exists($animate_tb)) {
        if ($animate_tb->g_wm_title() eq "Animation toolbar") {
            $animate_tb->g_wm_deiconify();
            $animate_tb->g_wm_geometry($geom);
            $animate_tb->g_raise();
            $animate_tb->g_focus;
            &adjust_window_position($animate_tb);
            return;
        }
    }
    $animate_tb = $main->new_toplevel();
    $animate_tb->g_wm_transient($main);
    $animate_tb->g_wm_title("Animation toolbar");
    $animate_tb->configure(-cursor => $cursor_norm);
    $animate_tb->g_wm_geometry($geom);

#   Stop animation if this menu is destroyed
    $animate_tb->g_bind('<Destroy>' => sub { $anim_tb_status = "stopped";
                                             &reset_bindings;
                                           });

#   Toolbar images
    $to_start_img = Tkx::image_create_photo(-file => "${prog_path}images/to_start.png");
    $step_bkw_img = Tkx::image_create_photo(-file => "${prog_path}images/step_bkw.png");
    $reverse_img  = Tkx::image_create_photo(-file => "${prog_path}images/reverse.png");
    $stop_img     = Tkx::image_create_photo(-file => "${prog_path}images/stop.png");
    $pause_img    = Tkx::image_create_photo(-file => "${prog_path}images/pause.png");
    $play_img     = Tkx::image_create_photo(-file => "${prog_path}images/play.png");
    $step_fwd_img = Tkx::image_create_photo(-file => "${prog_path}images/step_fwd.png");
    $to_end_img   = Tkx::image_create_photo(-file => "${prog_path}images/to_end.png");
    $faster_img   = Tkx::image_create_photo(-file => "${prog_path}images/plus.png");
    $slower_img   = Tkx::image_create_photo(-file => "${prog_path}images/minus.png");
    $repeat_img   = Tkx::image_create_photo(-file => "${prog_path}images/repeat.png");
    $repeaton_img = Tkx::image_create_photo(-file => "${prog_path}images/repeat_on.png");

    $anim_tb_status = "stopped";
    $tooltip = "";

    ($frame = $animate_tb->new_frame(
                -borderwidth => 2,
                -relief      => 'groove',
                ))->g_pack(-anchor => 'nw', -expand => 1, -fill => 'x');
    ($fr_btns = $frame->new_frame(
                ))->g_grid(-row => 0, -column => 0, -sticky => 'nw', -padx => 0, -pady => 0);
    ($strt_btn = $fr_btns->new_button(
                -repeatdelay    => 10000,
                -repeatinterval => 10000,
                -image   => $to_start_img,
                -command => sub { $dti = 1;
                                  if ($anim_tb_status eq "playing") {
                                      $play_btn->configure(-image => $play_img);
                                      $stop_btn->configure(-state => 'disabled');
                                      $anim_tb_status = "stopped";
                                  } elsif ($anim_tb_status eq "reversing") {
                                      $rvrs_btn->configure(-image => $reverse_img);
                                      $stop_btn->configure(-state => 'disabled');
                                      $anim_tb_status = "stopped";
                                  }
                                  if ($dti != $dti_old) {
                                      ($frame_label, $date_label) = &get_animation_date;
                                      &update_animate($date_label);
                                      $dti_old = $dti;
                                  }
                                },
                ))->g_pack(-side => 'left', -padx => 0, -pady => 1);
    ($bkwd_btn = $fr_btns->new_button(
                -repeatdelay    => 400,
                -repeatinterval => 18,
                -image   => $step_bkw_img,
                -command => sub { $dti = &max(1,$dti-1);
                                  if ($anim_tb_status eq "playing") {
                                      $play_btn->configure(-image => $play_img);
                                      $stop_btn->configure(-state => 'disabled');
                                      $anim_tb_status = "stopped";
                                  } elsif ($anim_tb_status eq "reversing") {
                                      $rvrs_btn->configure(-image => $reverse_img);
                                      $stop_btn->configure(-state => 'disabled');
                                      $anim_tb_status = "stopped";
                                  }
                                  if ($dti != $dti_old) {
                                      ($frame_label, $date_label) = &get_animation_date;
                                      &update_animate($date_label);
                                      $dti_old = $dti;
                                  }
                                },
                ))->g_pack(-side => 'left', -padx => 0, -pady => 1);
    ($rvrs_btn = $fr_btns->new_button(
                -repeatdelay    => 10000,
                -repeatinterval => 10000,
                -image   => $reverse_img,
                -command => sub { if ($anim_tb_status ne "reversing" && ($repeat_anim || $dti > 1)) {
                                      $rvrs_btn->configure(-image => $pause_img);
                                      $play_btn->configure(-image => $play_img);
                                      $stop_btn->configure(-state => 'normal');
                                      $anim_tb_status = "reversing";
                                      $tooltip   = "Pause";
                                  } else {
                                      $rvrs_btn->configure(-image => $reverse_img);
                                      $stop_btn->configure(-state => 'disabled');
                                      $anim_tb_status = "stopped";
                                      $tooltip   = "Reverse";
                                  }
                                  $canvas->g_bind("<Motion>", "");
                                  while ($anim_tb_status eq "reversing" && ($repeat_anim || $dti > 1)) {
                                      if ($repeat_anim && $dti == 1) {
                                          $dti = $dti_max;
                                      } else {
                                          $dti--;
                                      }
                                      ($frame_label, $date_label) = &get_animation_date;
                                      &update_animate($date_label);
                                      $dti_old = $dti;
                                      if (! $repeat_anim && $dti == 1) {
                                          $rvrs_btn->configure(-image => $reverse_img);
                                          $stop_btn->configure(-state => 'disabled');
                                          $anim_tb_status = "stopped";
                                          $tooltip   = "";
                                      } else {
                                          Tkx::update();
                                          usleep($delay*1E6) if ($delay > 0);
                                      }
                                  }
                                  &reset_bindings;
                                },
                ))->g_pack(-side => 'left', -padx => 0, -pady => 1);
    ($stop_btn = $fr_btns->new_button(
                -repeatdelay    => 10000,
                -repeatinterval => 10000,
                -image   => $stop_img,
                -state   => 'disabled',
                -command => sub { $rvrs_btn->configure(-image => $reverse_img);
                                  $play_btn->configure(-image => $play_img);
                                  $stop_btn->configure(-state => 'disabled');
                                  $anim_tb_status = "stopped";
                                  $tooltip   = "";
                                  ($frame_label, $date_label) = &get_animation_date;
                                  &reset_bindings;
                                },
                ))->g_pack(-side => 'left', -padx => 0, -pady => 1);
    ($play_btn = $fr_btns->new_button(
                -repeatdelay    => 10000,
                -repeatinterval => 10000,
                -image   => $play_img,
                -command => sub { if ($anim_tb_status ne "playing" && ($repeat_anim || $dti < $dti_max)) {
                                      $play_btn->configure(-image => $pause_img);
                                      $rvrs_btn->configure(-image => $reverse_img);
                                      $stop_btn->configure(-state => 'normal');
                                      $anim_tb_status = "playing";
                                      $tooltip   = "Pause";
                                  } else {
                                      $play_btn->configure(-image => $play_img);
                                      $stop_btn->configure(-state => 'disabled');
                                      $anim_tb_status = "stopped";
                                      $tooltip   = "Play";
                                  }
                                  $canvas->g_bind("<Motion>", "");
                                  while ($anim_tb_status eq "playing" && ($repeat_anim || $dti < $dti_max)) {
                                      if ($repeat_anim && $dti == $dti_max) {
                                          $dti = 1;
                                      } else {
                                          $dti++;
                                      }
                                      ($frame_label, $date_label) = &get_animation_date;
                                      &update_animate($date_label);
                                      $dti_old = $dti;
                                      if (! $repeat_anim && $dti == $dti_max) {
                                          $play_btn->configure(-image => $play_img);
                                          $stop_btn->configure(-state => 'disabled');
                                          $anim_tb_status = "stopped";
                                          $tooltip   = "";
                                      } else {
                                          Tkx::update();
                                          usleep($delay*1E6) if ($delay > 0);
                                      }
                                  }
                                  &reset_bindings;
                                },
                ))->g_pack(-side => 'left', -padx => 0, -pady => 1);
    ($fwd_btn = $fr_btns->new_button(
                -repeatdelay    => 400,
                -repeatinterval => 18,
                -image   => $step_fwd_img,
                -command => sub { $dti = &min($dti_max,$dti+1);
                                  if ($anim_tb_status eq "playing") {
                                      $play_btn->configure(-image => $play_img);
                                      $stop_btn->configure(-state => 'disabled');
                                      $anim_tb_status = "stopped";
                                  } elsif ($anim_tb_status eq "reversing") {
                                      $rvrs_btn->configure(-image => $reverse_img);
                                      $stop_btn->configure(-state => 'disabled');
                                      $anim_tb_status = "stopped";
                                  }
                                  if ($dti != $dti_old) {
                                      ($frame_label, $date_label) = &get_animation_date;
                                      &update_animate($date_label);
                                      $dti_old = $dti;
                                  }
                                },
                ))->g_pack(-side => 'left', -padx => 0, -pady => 1);
    ($end_btn = $fr_btns->new_button(
                -repeatdelay    => 10000,
                -repeatinterval => 10000,
                -image   => $to_end_img,
                -command => sub { $dti = $dti_max;
                                  if ($anim_tb_status eq "playing") {
                                      $play_btn->configure(-image => $play_img);
                                      $stop_btn->configure(-state => 'disabled');
                                      $anim_tb_status = "stopped";
                                  } elsif ($anim_tb_status eq "reversing") {
                                      $rvrs_btn->configure(-image => $reverse_img);
                                      $stop_btn->configure(-state => 'disabled');
                                      $anim_tb_status = "stopped";
                                  }
                                  if ($dti != $dti_old) {
                                      ($frame_label, $date_label) = &get_animation_date;
                                      &update_animate($date_label);
                                      $dti_old = $dti;
                                  }
                                },
                ))->g_pack(-side => 'left', -padx => 0, -pady => 1);
    ($repeat_btn = $fr_btns->new_button(
                -repeatdelay    => 100000,
                -repeatinterval => 100000,
                -image   => ($repeat_anim) ? $repeaton_img : $repeat_img,
                -command => sub { if ($repeat_anim) {
                                      $repeat_anim = 0;
                                      $repeat_btn->configure(-image => $repeat_img);
                                  } else {
                                      $repeat_anim = 1;
                                      $repeat_btn->configure(-image => $repeaton_img);
                                  }
                                  $tooltip = ($repeat_anim) ? "Repeat: On" : "Repeat: Off";
                                },
                ))->g_pack(-side => 'left', -padx => 0, -pady => 1);

    $frame->new_scale(
                -orient       => 'horizontal',
                -from         => 1,
                -to           => $dti_max,
                -variable     => \$dti,
                -showvalue    => 'false',
                -width        => 12,
                -length       => 300,
                -sliderlength => 6,
                -takefocus    => 1,
                -command      => sub { if ($anim_tb_status eq "playing") {
                                           $play_btn->configure(-image => $play_img);
                                           $stop_btn->configure(-state => 'disabled');
                                           $anim_tb_status = "stopped";
                                       } elsif ($anim_tb_status eq "reversing") {
                                           $rvrs_btn->configure(-image => $reverse_img);
                                           $stop_btn->configure(-state => 'disabled');
                                           $anim_tb_status = "stopped";
                                       } 
                                       if ($dti != $dti_old) {
                                           ($frame_label, $date_label) = &get_animation_date;
                                           &update_animate($date_label);
                                           $dti_old = $dti;
                                           $anim_tb_status = "stopped";
                                       }
                                     },
                )->g_grid(-row    =>   0,  -column => 1, -columnspan => 2,
                          -sticky => 'ew', -padx   => 2, -pady       => 0);

    ($frame_label, $date_label) = &get_animation_date;
    $fr_msgs = $frame->new_frame();
    $fr_msgs->g_grid(-row => 1, -column => 0, -sticky => 'nsew', -padx => 0, -pady => 0);
    $fr_msgs->new_label(
                -textvariable => \$tooltip,
                -justify      => 'left',
                -font         => 'default',
                )->g_pack(-side => 'left', -padx => 0, -pady => 1);
    ($slower_btn = $fr_msgs->new_button(
                -repeatdelay    => 400,
                -repeatinterval => 18,
                -image   => $slower_img,
                -command => sub { if ($delay < 0.05) {
                                      $faster_btn->configure(-state => 'normal');
                                  }
                                  $delay   = &min(10,$delay+0.1);
                                  $tooltip = sprintf("Slower (delay %.1fs)", $delay);
                                  if ($delay > 9.95) {
                                      $slower_btn->configure(-state => 'disabled');
                                  }
                                },
                ))->g_pack(-side => 'right', -padx => 0, -pady => 1);
    ($faster_btn = $fr_msgs->new_button(
                -repeatdelay    => 400,
                -repeatinterval => 18,
                -image   => $faster_img,
                -command => sub { if ($delay > 9.95) {
                                      $slower_btn->configure(-state => 'normal');
                                  }
                                  $delay   = &max(0,$delay-0.1);
                                  $tooltip = sprintf("Faster (delay %.1fs)", $delay);
                                  if ($delay < 0.05) {
                                      $faster_btn->configure(-state => 'disabled');
                                  }
                                },
                ))->g_pack(-side => 'right', -padx => 0, -pady => 1);

    $frame->new_label(
                -textvariable => \$frame_label,
                -justify      => 'left',
                -font         => 'default',
                )->g_grid(-row => 1, -column => 1, -sticky => 'sw', -padx => 1, -pady => 1);
    $frame->new_label(
                -textvariable => \$date_label,
                -justify      => 'right',
                -font         => 'default',
                )->g_grid(-row => 1, -column => 2, -sticky => 'se', -padx => 1, -pady => 1);

#   Bindings for mouse focus
    $strt_btn->g_bind("<Enter>",   sub { $tooltip = "To Start"; });
    $bkwd_btn->g_bind("<Enter>",   sub { $tooltip = "Step Backward"; });
    $rvrs_btn->g_bind("<Enter>",   sub { $tooltip = ($anim_tb_status eq "reversing") ? "Pause"
                                                                                     : "Reverse"; });
    $stop_btn->g_bind("<Enter>",   sub { $tooltip = ($anim_tb_status eq "stopped") ? "" : "Stop"; });
    $play_btn->g_bind("<Enter>",   sub { $tooltip = ($anim_tb_status eq "playing") ? "Pause" : "Play"; });
    $fwd_btn->g_bind("<Enter>",    sub { $tooltip = "Step Forward"; });
    $end_btn->g_bind("<Enter>",    sub { $tooltip = "To End"; });
    $repeat_btn->g_bind("<Enter>", sub { $tooltip = ($repeat_anim) ? "Repeat: On" : "Repeat: Off"; });
    $faster_btn->g_bind("<Enter>", sub { $tooltip = sprintf("Faster (delay %.1fs)", $delay); });
    $slower_btn->g_bind("<Enter>", sub { $tooltip = sprintf("Slower (delay %.1fs)", $delay); });

    $strt_btn->g_bind("<Leave>",    sub { $tooltip = ""; });
    $bkwd_btn->g_bind("<Leave>",    sub { $tooltip = ""; });
    $rvrs_btn->g_bind("<Leave>",    sub { $tooltip = ""; });
    $stop_btn->g_bind("<Leave>",    sub { $tooltip = ""; });
    $play_btn->g_bind("<Leave>",    sub { $tooltip = ""; });
    $fwd_btn->g_bind("<Leave>",     sub { $tooltip = ""; });
    $end_btn->g_bind("<Leave>",     sub { $tooltip = ""; });
    $repeat_btn->g_bind("<Leave>",  sub { $tooltip = ""; });
    $faster_btn->g_bind("<Leave>",  sub { $tooltip = ""; });
    $slower_btn->g_bind("<Leave>",  sub { $tooltip = ""; });

#   Bindings for keyboard focus
    $strt_btn->g_bind("<FocusIn>",   sub { $strt_btn->configure(-default => 'active');
                                           $tooltip = "To Start"; });
    $bkwd_btn->g_bind("<FocusIn>",   sub { $bkwd_btn->configure(-default => 'active');
                                           $tooltip = "Step Backward"; });
    $rvrs_btn->g_bind("<FocusIn>",   sub { $rvrs_btn->configure(-default => 'active');
                                           $tooltip = ($anim_tb_status eq "reversing") ? "Pause"
                                                                                       : "Reverse"; });
    $stop_btn->g_bind("<FocusIn>",   sub { $stop_btn->configure(-default => 'active');
                                           $tooltip = ($anim_tb_status eq "stopped") ? "" : "Stop"; });
    $play_btn->g_bind("<FocusIn>",   sub { $play_btn->configure(-default => 'active');
                                           $tooltip = ($anim_tb_status eq "playing") ? "Pause" : "Play"; });
    $fwd_btn->g_bind("<FocusIn>",    sub { $fwd_btn->configure(-default => 'active');
                                           $tooltip = "Step Forward"; });
    $end_btn->g_bind("<FocusIn>",    sub { $end_btn->configure(-default => 'active');
                                           $tooltip = "To End"; });
    $repeat_btn->g_bind("<FocusIn>", sub { $repeat_btn->configure(-default => 'active');
                                           $tooltip = ($repeat_anim) ? "Repeat: On" : "Repeat: Off"; });
    $faster_btn->g_bind("<FocusIn>", sub { $faster_btn->configure(-default => 'active');
                                           $tooltip = sprintf("Faster (delay %.1fs)", $delay); });
    $slower_btn->g_bind("<FocusIn>", sub { $slower_btn->configure(-default => 'active');
                                           $tooltip = sprintf("Slower (delay %.1fs)", $delay); });

    $strt_btn->g_bind("<FocusOut>",   sub { $strt_btn->configure(-default   => 'normal'); });
    $bkwd_btn->g_bind("<FocusOut>",   sub { $bkwd_btn->configure(-default   => 'normal'); });
    $rvrs_btn->g_bind("<FocusOut>",   sub { $rvrs_btn->configure(-default   => 'normal'); });
    $stop_btn->g_bind("<FocusOut>",   sub { $stop_btn->configure(-default   => 'normal'); });
    $play_btn->g_bind("<FocusOut>",   sub { $play_btn->configure(-default   => 'normal'); });
    $fwd_btn->g_bind("<FocusOut>",    sub { $fwd_btn->configure(-default    => 'normal'); });
    $end_btn->g_bind("<FocusOut>",    sub { $end_btn->configure(-default    => 'normal'); });
    $repeat_btn->g_bind("<FocusOut>", sub { $repeat_btn->configure(-default => 'normal'); });
    $faster_btn->g_bind("<FocusOut>", sub { $faster_btn->configure(-default => 'normal'); });
    $slower_btn->g_bind("<FocusOut>", sub { $slower_btn->configure(-default => 'normal'); });

#   Bindings to restore button shape after keyboard input is sustained
    $strt_btn->g_bind("<KeyPress>",   [\&restore_btn, Tkx::Ev("%k"), $strt_btn   ]);
    $bkwd_btn->g_bind("<KeyPress>",   [\&restore_btn, Tkx::Ev("%k"), $bkwd_btn   ]);
    $rvrs_btn->g_bind("<KeyPress>",   [\&restore_btn, Tkx::Ev("%k"), $rvrs_btn   ]);
    $stop_btn->g_bind("<KeyPress>",   [\&restore_btn, Tkx::Ev("%k"), $stop_btn   ]);
    $play_btn->g_bind("<KeyPress>",   [\&restore_btn, Tkx::Ev("%k"), $play_btn   ]);
    $fwd_btn->g_bind("<KeyPress>",    [\&restore_btn, Tkx::Ev("%k"), $fwd_btn    ]);
    $end_btn->g_bind("<KeyPress>",    [\&restore_btn, Tkx::Ev("%k"), $end_btn    ]);
    $repeat_btn->g_bind("<KeyPress>", [\&restore_btn, Tkx::Ev("%k"), $repeat_btn ]);
    $faster_btn->g_bind("<KeyPress>", [\&restore_btn, Tkx::Ev("%k"), $faster_btn ]);
    $slower_btn->g_bind("<KeyPress>", [\&restore_btn, Tkx::Ev("%k"), $slower_btn ]);

    Tkx::wm_resizable($animate_tb,0,0);
    &adjust_window_position($animate_tb);
    $animate_tb->g_focus;
}


sub restore_btn {
    my ($k, $btn) = @_;
    if ($k == 32) {
        Tkx::update_idletasks();
        $btn->configure(-relief => 'raised');
    }
}


sub get_animation_date {
    my ($frame_label, $date_label);

    $frame_label = "Frame $dti of $dti_max";
    $date_label  = &get_formatted_date($dates[$dti-1]);
    return ($frame_label, $date_label);
}


sub update_animate {
    my ($date_label) = @_;
    my (
        $add_pt0, $add_pt3, $anc, $base_jd, $blank_img, $bot, $cmap_image,
        $cs_max, $cs_min, $cs_range, $diff, $do_calcs, $dt, $dt_parm,
        $dt_parm2, $dt2, $dy, $el_limit, $el1, $el2, $el3, $elev, $first,
        $flow, $flow_data, $found, $got_depth, $group_tags, $gtag, $height,
        $i, $id, $id2, $ih, $iw, $j, $jb, $jd, $jd_max, $jd_min, $k,
        $kalt, $kbot, $kmx, $kt, $kt_parm, $last_xp, $last_yp, $lastpt,
        $link_id, $mi, $msg, $mult, $n, $nbr, $nlayers, $nout, $np, $ns,
        $nww, $ok2animate, $old_elev, $pt1_in, $pt2_in, $pval, $pval1,
        $pval2, $pval3, $qmult, $qsum, $seg, $surf_elev, $tag, $tol, $top,
        $tout, $ts_state, $tsum, $val, $wsel, $wt, $wt_max, $wt_min, $wt1,
        $wt2, $wt3, $x1, $x2, $xbase, $xd1, $xd2, $xmax, $xmin, $xmult,
        $xp, $xp0, $xp1, $xp2, $xp3, $xrange, $y1, $y2, $ymax, $ymin, $yp,
        $yp0, $yp1, $yp2, $yp3, $yrange, $yval,

        @b, @color, @colors, @coords, @depths, @ds, @el, @elevations,
        @estimated, @estr, @flows, @grp_tags, @items, @kb, @kbsw, @ktsw,
        @lw, @names, @noutlets, @nslots, @pdata, @pt_color, @pt_elevations,
        @qout, @qstr, @qtot, @rho, @seglist, @show, @slope, @sw_alg, @t,
        @tags, @tstr, @us, @valid_elevs, @valid_temps, @valid_pdata, @vtot,
        @wtemps, @ww_names, @xdist,

        %bh_parms, %ds_parms, %elev_data, %kt_data, %parm_data, %parms,
        %qdata, %qtot_data, %tdata, %temps, %vdata, %vtot_data, %wl_data,
        %wsurf,
       );

#   Loop over each graph and do the appropriate animation
    foreach $id (@animate_ids) {
        next if ($props{$id}{meta} eq "w2_tdmap");   # No animation for time/distance maps

        $dt   = $dates[$dti-1];   # set each time, in case it is modified
        $gtag = "graph" . $id;

#       Determine whether group tags are present and save the list
        $group_tags = 0;
        @grp_tags   = ();
        @tags       = Tkx::SplitList($canvas->itemcget($id, -tags));
        if (&list_search("group_", @tags) > -1) {
            $group_tags = 1;
            foreach $tag (@tags) {
                push (@grp_tags, $tag) if ($tag =~ /^group_/);
            }
        }

#       For a W2 longitudinal slice, just swap the colormap frames
        if ($props{$id}{meta} eq "w2_slice") {
            $canvas->delete($gtag . "_noData");
            if (defined($gr_props{$id}{slice_img}{$dt})) {
                $canvas->itemconfigure($gtag . "_date",     -text  => $date_label);
                $canvas->itemconfigure($gtag . "_colorMap", -image => $gr_props{$id}{slice_img}{$dt});
            } else {
                for ($mi=1; $mi<=10; $mi++) {
                    $dt2 = &adjust_dt($dt, $mi);
                    if (defined($gr_props{$id}{slice_img}{$dt2})) {
                        $dt = $dt2;
                        last;
                    }
                    $dt2 = &adjust_dt($dt, -1 *$mi);
                    if (defined($gr_props{$id}{slice_img}{$dt2})) {
                        $dt = $dt2;
                        last;
                    }
                }
                if ($dt != $dates[$dti-1]) {
                    $canvas->itemconfigure($gtag . "_date",     -text  => &get_formatted_date($dt));
                    $canvas->itemconfigure($gtag . "_colorMap", -image => $gr_props{$id}{slice_img}{$dt});
                } else {
                    ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
                    $blank_img = Tkx::image_create_photo(-width => $x2-$x1+1, -height => $y2-$y1+1);
                    $canvas->itemconfigure($gtag . "_date",     -text  => $date_label);
                    $canvas->itemconfigure($gtag . "_colorMap", -image => $blank_img);
                    $canvas->create_text(($x1+$x2)/2, ($y1+$y2)/2,
                                       -anchor => 'center', 
                                       -text   => "No Data",
                                       -fill   => &get_rgb_code("gray60"),
                                       -angle  => 0,
                                       -tags   => $gtag . " " . $gtag . "_noData",
                                       -font   => [-family     => $gr_props{$id}{xfont},
                                                   -size       => $gr_props{$id}{xl_size},
                                                   -weight     => 'normal',
                                                   -slant      => 'roman',
                                                   -underline  => 0,
                                                   -overstrike => 0,
                                                  ]);
                    $canvas->lower($gtag . "_noData", $gtag . "_xaxis");
                    if ($group_tags) {
                        foreach $tag (@grp_tags) {
                            $canvas->addtag($tag, withtag => $gtag . "_noData");
                        }
                    }
                    undef $blank_img;
                }
            }
#xxx        &update_links($canvas, $id, $dt);
            next;
        }

#       Okay to do a simple animation for a colormap
#       in conjunction with a paired temperature profile
        if ($props{$id}{meta} =~ /(data_profile_cmap|w2_profile_cmap|time_series)/) {
            return if ($#animate_ids == 0);
            $ok2animate = 0;
            if ($props{$id}{meta} =~ /(data_profile_cmap|w2_profile_cmap|time_series)/) {
                $ok2animate = 1 if ($gr_props{$id}{dateline});
            }
            if (! $ok2animate && $props{$id}{meta} eq "linked_time_series") {
                for ($i=0; $i<=$#animate_ids; $i++) {
                    $id2 = $animate_ids[$i];
                    next if ($id2 == $id);
                    if ($props{$id2}{meta}
                           =~ /^(data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)$/) {
                        if ($props{$id}{link_id} == $id2) {
                            $ok2animate = 1;
                            last;
                        }
                    }
                }
            }
            next if (! $ok2animate);

            $jd = &date2jdate($dt);
            if ($gr_props{$id}{xtype} eq "Date/Time") {
                $jd_min = &datelabel2jdate($gr_props{$id}{xmin});
                $jd_max = &datelabel2jdate($gr_props{$id}{xmax});
            } else {
                $base_jd = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
                $jd_min  = $gr_props{$id}{xmin} +$base_jd -1;
                $jd_max  = $gr_props{$id}{xmax} +$base_jd -1;
            }
            if ($props{$id}{meta} =~ /profile_cmap/) {
                $canvas->delete($gtag . "_colorMapDateline");
            } elsif ($props{$id}{meta} eq "time_series") {
                $canvas->delete($gtag . "_dateline");
            } elsif ($props{$id}{meta} eq "linked_time_series") {
                $canvas->delete($gtag . "_dateline");
                $canvas->delete($gtag . "_datePoint");
            }
            next if ($jd <= $jd_min || $jd >= $jd_max);

            ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
            $xp = $x1 +($x2 -$x1) *($jd -$jd_min) /($jd_max -$jd_min);

#           For profile colormaps and time-series plots, draw a vertical line at the current date
            if ($props{$id}{meta} =~ /profile_cmap/ && $gr_props{$id}{dateline}) {
                $canvas->create_line($xp, $y1, $xp, $y2,
                                 -fill  => &get_rgb_code($gr_props{$id}{datelinec}),
                                 -width => 1,
                                 -arrow => 'none',
                                 -tags  => $gtag . " " . $gtag . "_colorMapDateline");
                $canvas->lower($gtag . "_colorMapDateline", $gtag . "_xaxis");
                if ($group_tags) {
                    foreach $tag (@grp_tags) {
                        $canvas->addtag($tag, withtag => $gtag . "_colorMapDateline");
                    }
                }
            } elsif ($props{$id}{meta} =~ /time_series/ && $gr_props{$id}{dateline}) {
                $canvas->create_line($xp, $y1, $xp, $y2,
                                 -fill  => &get_rgb_code($gr_props{$id}{datelinec}),
                                 -width => 1,
                                 -arrow => 'none',
                                 -tags  => $gtag . " " . $gtag . "_dateline");
                $canvas->lower($gtag . "_dateline", $gtag . "_xaxis");
                @items = Tkx::SplitList($canvas->find_withtag($gtag . "_legend"));
                if ($#items >= 0) {
                    $canvas->lower($gtag . "_dateline", $gtag . "_legend");
                }
                @items = Tkx::SplitList($canvas->find_withtag($gtag . "_legendBox"));
                if ($#items >= 0) {
                    $canvas->lower($gtag . "_dateline", $gtag . "_legendBox");
                }
                if ($group_tags) {
                    foreach $tag (@grp_tags) {
                        $canvas->addtag($tag, withtag => $gtag . "_dateline");
                    }
                }
            }

#           For linked time-series plots, highlight the points at current date
            if ($props{$id}{meta} eq "linked_time_series") {
                $link_id = $props{$id}{link_id};
                %parms   = %{ $props{$id}{ts_parms} };
                @show    = @{ $parms{show}  };
                @color   = @{ $parms{color} };
                $ymin    = $gr_props{$id}{ymin};
                $ymax    = $gr_props{$id}{ymax};

                if ($parms{ts_type} eq "Water Surface Elevation") {
                    %wsurf = %{ $gr_props{$link_id}{ws_elev} };

#                   Adjust dt, if needed. Link_id is data_profile or vert_wd_zone.
                    if (length($dt) == 12) {
                        if ($gr_props{$link_id}{daily}) {
                            $dt = substr($dt,0,8);
                        } elsif (! defined($wsurf{$dt})) {
                            for ($mi=1; $mi<=10; $mi++) {
                                $dt2 = &adjust_dt($dt, $mi);
                                if (defined($wsurf{$dt2})) {
                                    $dt = $dt2;
                                    last;
                                }
                                $dt2 = &adjust_dt($dt, -1 *$mi);
                                if (defined($wsurf{$dt2})) {
                                    $dt = $dt2;
                                    last;
                                }
                            }
                        }
                    }
                    if (defined($wsurf{$dt}) && $wsurf{$dt} ne "na") {
                        $surf_elev  = $wsurf{$dt};
                        $surf_elev *= 3.28084 if ($parms{units} eq "ft");
                        $yp = $y2 -($y2 -$y1) *($surf_elev -$ymin) /($ymax -$ymin);
                        $yp = &min($y2, &max($y1, $yp));
                        $canvas->create_oval($xp-3, $yp-3, $xp+3, $yp+3,
                                        -outline => "#000000",
                                        -width   => 1,
                                        -fill    => &get_rgb_code($color[0]),
                                        -tags    => $gtag . " " . $gtag . "_tsData"
                                                          . " " . $gtag . "_datePoint"
                                                          . " " . $gtag . "_dataPoint0");
                    }
                    undef %wsurf;

                } elsif ($parms{ts_type} eq "Flow") {
                    %qdata = %{ $gr_props{$link_id}{qdata} };
                    @names = @{ $gr_props{$link_id}{names} };
                    push (@names, "All Outlets");

#                   Adjust dt, if needed. Link_id is vert_wd_zone.
                    if (length($dt) == 12) {
                        if ($gr_props{$link_id}{daily}) {
                            $dt = substr($dt,0,8);
                        } elsif (! defined($qdata{$dt})) {
                            for ($mi=1; $mi<=10; $mi++) {
                                $dt2 = &adjust_dt($dt, $mi);
                                if (defined($qdata{$dt2})) {
                                    $dt = $dt2;
                                    last;
                                }
                                $dt2 = &adjust_dt($dt, -1 *$mi);
                                if (defined($qdata{$dt2})) {
                                    $dt = $dt2;
                                    last;
                                }
                            }
                        }
                    }
                    for ($n=0; $n<=$#names; $n++) {
                        $ts_state = ($show[$n]) ? 'normal' : 'hidden';
                        if (defined($qdata{$dt})) {
                            @qstr = @{ $qdata{$dt} };
                            if ($names[$n] eq "All Outlets") {
                                $flow = &sum(@qstr);
                            } else {
                                $flow = $qstr[$n];
                            }
                            $flow *= 35.31467 if ($parms{units} eq "cfs");
                            $yp = $y2 -($y2 -$y1) *($flow -$ymin) /($ymax -$ymin);
                            $yp = &min($y2, &max($y1, $yp));
                            $canvas->create_oval($xp-3, $yp-3, $xp+3, $yp+3,
                                            -outline => "#000000",
                                            -width   => 1,
                                            -fill    => &get_rgb_code($color[$n]),
                                            -state   => $ts_state,
                                            -tags    => $gtag . " " . $gtag . "_tsData"
                                                              . " " . $gtag . "_datePoint"
                                                              . " " . $gtag . "_dataPoint" . $n);
                        }
                    }
                    undef %qdata;

                } elsif ($parms{ts_type} eq "Temperature") {
                    %tdata = %{ $gr_props{$link_id}{tdata} };
                    @names = @{ $gr_props{$link_id}{names} };
                    push (@names, "All Outlets");

#                   Adjust dt, if needed. Link_id is vert_wd_zone.
                    if (length($dt) == 12) {
                        if ($gr_props{$link_id}{daily}) {
                            $dt = substr($dt,0,8);
                        } elsif (! defined($tdata{$dt})) {
                            for ($mi=1; $mi<=10; $mi++) {
                                $dt2 = &adjust_dt($dt, $mi);
                                if (defined($tdata{$dt2})) {
                                    $dt = $dt2;
                                    last;
                                }
                                $dt2 = &adjust_dt($dt, -1 *$mi);
                                if (defined($tdata{$dt2})) {
                                    $dt = $dt2;
                                    last;
                                }
                            }
                        }
                    }
                    for ($n=0; $n<=$#names; $n++) {
                        $ts_state = ($show[$n]) ? 'normal' : 'hidden';
                        if (defined($tdata{$dt})) {
                            @tstr = @{ $tdata{$dt} };
                            $wt   = $tstr[$n];
                            if ($wt > -99) {
                                $wt = 1.8 *$wt +32 if ($parms{units} eq "Fahrenheit");
                                $yp = $y2 -($y2 -$y1) *($wt -$ymin) /($ymax -$ymin);
                                $yp = &min($y2, &max($y1, $yp));
                                $canvas->create_oval($xp-3, $yp-3, $xp+3, $yp+3,
                                                -outline => "#000000",
                                                -width   => 1,
                                                -fill    => &get_rgb_code($color[$n]),
                                                -state   => $ts_state,
                                                -tags    => $gtag . " " . $gtag . "_tsData"
                                                                  . " " . $gtag . "_datePoint"
                                                                  . " " . $gtag . "_dataPoint" . $n);
                            }
                        }
                    }
                    undef %tdata;
                }
                $canvas->lower($gtag . "_datePoint", $id);
                if ($group_tags) {
                    foreach $tag (@grp_tags) {
                        $canvas->addtag($tag, withtag => $gtag . "_datePoint");
                    }
                }
                undef %parms;
            }
            next;
        }

#       The remainder of this subroutine deals with the other animated graphs:
#         data_profile, vert_wd_zone, w2_profile, w2_outflow, w2_wlevels
        ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };

#       Delete the old profile and set up variables
        $canvas->delete($gtag . "_profile");
        $canvas->delete($gtag . "_colorProfile");
        $canvas->delete($gtag . "_refData");
        $canvas->delete($gtag . "_wlevels");

#       Populate some common hashes
        if ($props{$id}{meta} eq "data_profile") {
            %parm_data = %{ $gr_props{$id}{pdata}   };
            %wsurf     = %{ $gr_props{$id}{ws_elev} };
        } elsif ($props{$id}{meta} eq "vert_wd_zone") {
            %temps = %{ $gr_props{$id}{pdata}   };
            %wsurf = %{ $gr_props{$id}{ws_elev} };
        } elsif ($props{$id}{meta} eq "w2_profile") {
            %kt_data   = %{ $gr_props{$id}{kt_data}   };
            %elev_data = %{ $gr_props{$id}{elev_data} };
            %parm_data = %{ $gr_props{$id}{parm_data} };
        } elsif ($props{$id}{meta} eq "w2_outflow") {
            %qdata = %{ $gr_props{$id}{qdata} };
            %vdata = %{ $gr_props{$id}{vdata} };
            if ($props{$id}{add_parm} && $gr_props{$id}{add_cs}) {
                %kt_data   = %{ $gr_props{$id}{kt_data}   };
                %parm_data = %{ $gr_props{$id}{parm_data} };
            }
        } elsif ($props{$id}{meta} eq "w2_wlevels") {
            %wl_data = %{ $gr_props{$id}{wl_data} };
        }

#       Plot the number of bulkhead openings, if asked
        if ($props{$id}{meta} eq "vert_wd_zone") {
            if ($props{$id}{wd_alg} eq "Libby Dam" && $gr_props{$id}{bh_show}) {
                $bh_parms{ymin}      = $gr_props{$id}{ymin};
                $bh_parms{ymax}      = $gr_props{$id}{ymax};
                $bh_parms{ytype}     = $gr_props{$id}{ytype};
                $bh_parms{yunits}    = $gr_props{$id}{yunits};
                $bh_parms{num_ww}    = $gr_props{$id}{num_ww};
                $bh_parms{ww_names}  = $gr_props{$id}{ww_names};
                $bh_parms{num_rows}  = $gr_props{$id}{num_rows};
                $bh_parms{bh_height} = $gr_props{$id}{bh_height};  # meters
                $bh_parms{base_elev} = $gr_props{$id}{base_elev};  # meters
                $bh_parms{surf_elev} = $wsurf{$dt};                # meters
                $bh_parms{bh_miss}   = $gr_props{$id}{bh_miss};
                $bh_parms{bh_font}   = $gr_props{$id}{bh_font};
                $bh_parms{bh_size}   = $gr_props{$id}{bh_size};
                $bh_parms{bh_weight} = $gr_props{$id}{bh_weight};
                $bh_parms{bh_tcolor} = $gr_props{$id}{bh_tcolor};
                $bh_parms{bh_bwidth} = $gr_props{$id}{bh_bwidth};
                $bh_parms{bh_bcolor} = $gr_props{$id}{bh_bcolor};
                $bh_parms{bh_bcellw} = $gr_props{$id}{bh_bcellw};
                $bh_parms{bh_docked} = $gr_props{$id}{bh_docked};
                $bh_parms{bh_xpos}   = $gr_props{$id}{bh_xpos};
                $bh_parms{bh_ypos}   = $gr_props{$id}{bh_ypos};
                $bh_parms{bh_bcellh} = $gr_props{$id}{bh_bcellh};

                $canvas->delete($gtag . "_openBH");
                &make_bulkhead_graphic($canvas, $id, $dt, %bh_parms);
                undef %bh_parms;
                $canvas->lower($gtag . "_openBH", $id);
            }
        }

#       Adjust target date to daily, or by up to 10 minutes, if needed
        if ($props{$id}{meta} =~ /^(data_profile|vert_wd_zone)$/) {
            if (length($dt) == 12) {
                if ($gr_props{$id}{daily}) {
                    $dt = substr($dt,0,8);
                } elsif ($props{$id}{meta} eq "data_profile") {
                    if (! defined($parm_data{$dt})) {
                        for ($mi=1; $mi<=10; $mi++) {
                            $dt2 = &adjust_dt($dt, $mi);
                            if (defined($parm_data{$dt2})) {
                                $dt = $dt2;
                                last;
                            }
                            $dt2 = &adjust_dt($dt, -1 *$mi);
                            if (defined($parm_data{$dt2})) {
                                $dt = $dt2;
                                last;
                            }
                        }
                    }
                } elsif ($props{$id}{meta} eq "vert_wd_zone") {
                    if (! defined($temps{$dt})) {
                        for ($mi=1; $mi<=10; $mi++) {
                            $dt2 = &adjust_dt($dt, $mi);
                            if (defined($temps{$dt2})) {
                                $dt = $dt2;
                                last;
                            }
                            $dt2 = &adjust_dt($dt, -1 *$mi);
                            if (defined($temps{$dt2})) {
                                $dt = $dt2;
                                last;
                            }
                        }
                    }
                }
            }
        } elsif ($props{$id}{meta} eq "w2_profile") {
            if (! defined($parm_data{$dt})) {
                for ($mi=1; $mi<=10; $mi++) {
                    $dt2 = &adjust_dt($dt, $mi);
                    if (defined($parm_data{$dt2})) {
                        $dt = $dt2;
                        last;
                    }
                    $dt2 = &adjust_dt($dt, -1 *$mi);
                    if (defined($parm_data{$dt2})) {
                        $dt = $dt2;
                        last;
                    }
                }
            }
        } elsif ($props{$id}{meta} eq "w2_outflow") {
            if (! defined($qdata{$dt})) {
                for ($mi=1; $mi<=10; $mi++) {
                    $dt2 = &adjust_dt($dt, $mi);
                    if (defined($qdata{$dt2})) {
                        $dt = $dt2;
                        last;
                    }
                    $dt2 = &adjust_dt($dt, -1 *$mi);
                    if (defined($qdata{$dt2})) {
                        $dt = $dt2;
                        last;
                    }
                }
            }
        } elsif ($props{$id}{meta} eq "w2_wlevels") {
            if (! defined($wl_data{$dt})) {
                for ($mi=1; $mi<=10; $mi++) {
                    $dt2 = &adjust_dt($dt, $mi);
                    if (defined($wl_data{$dt2})) {
                        $dt = $dt2;
                        last;
                    }
                    $dt2 = &adjust_dt($dt, -1 *$mi);
                    if (defined($wl_data{$dt2})) {
                        $dt = $dt2;
                        last;
                    }
                }
            }
        }

#       Update the date subtitle
        if ($dt != $dates[$dti-1]) {
            $canvas->itemconfigure($gtag . "_date", -text => &get_formatted_date($dt));
        } else {
            $canvas->itemconfigure($gtag . "_date", -text => $date_label);
        }

#       Exit early if data are unavailable on this date
        if (($props{$id}{meta} eq "data_profile"
              && (! defined($wsurf{$dt}) || ! defined($parm_data{$dt})))
           || ($props{$id}{meta} eq "vert_wd_zone"
                && (! defined($wsurf{$dt}) || ! defined($temps{$dt})))
           || ($props{$id}{meta} eq "w2_outflow" && ! defined($qdata{$dt}))
           || ($props{$id}{meta} eq "w2_wlevels" && ! defined($wl_data{$dt}))
           || ($props{$id}{meta} eq "w2_profile"
                && (! defined($elev_data{$dt}) || ! defined($parm_data{$dt})))) {
            if ($props{$id}{meta} eq "w2_wlevels") {
                $tag = $gtag . "_wlevels";
            } else {
                $tag = $gtag . "_profile";
            }
            $canvas->create_text(($x1+$x2)/2, ($y1+$y2)/2,
                               -anchor => 'center', 
                               -text   => "No Data",
                               -fill   => &get_rgb_code("gray60"),
                               -angle  => 0,
                               -tags   => $gtag . " " . $tag,
                               -font   => [-family     => $gr_props{$id}{xfont},
                                           -size       => $gr_props{$id}{xl_size},
                                           -weight     => 'normal',
                                           -slant      => 'roman',
                                           -underline  => 0,
                                           -overstrike => 0,
                                          ]);
            $canvas->lower($tag, $id);
            if ($group_tags) {
                foreach $tag (@grp_tags) {
                    $canvas->addtag($tag, withtag => $tag);
                }
            }

#           Free up some memory before moving on
            if ($props{$id}{meta} eq "data_profile") {
                undef %parm_data;
                undef %wsurf;
            } elsif ($props{$id}{meta} eq "vert_wd_zone") {
                undef %temps;
                undef %wsurf;
            } elsif ($props{$id}{meta} eq "w2_profile") {
                undef %kt_data;
                undef %elev_data;
                undef %parm_data;
            } elsif ($props{$id}{meta} eq "w2_outflow") {
                undef %qdata;
                undef %vdata;
                if ($props{$id}{add_parm} && $gr_props{$id}{add_cs}) {
                    undef %kt_data;
                    undef %parm_data;
                }
            } elsif ($props{$id}{meta} eq "w2_wlevels") {
                undef %wl_data;
            }

#           Update any links before moving on
            if ($props{$id}{meta} =~ /^(data_profile|vert_wd_zone|w2_profile)$/) {
                &update_links($canvas, $id, $dt);
            }

            next;
        }

#       Continue with the update...
        $mult   = ($gr_props{$id}{yunits} eq "feet") ? 3.28084 : 1.0;
        $ymin   = $gr_props{$id}{ymin} /$mult;
        $ymax   = $gr_props{$id}{ymax} /$mult;   # Use meters for depths and elevations
        $yrange = $ymax -$ymin;

        if ($props{$id}{meta} =~ /^(data_profile|vert_wd_zone)$/) {
            $surf_elev = ($wsurf{$dt} ne "na") ? $wsurf{$dt} : 0.0;
            $got_depth = ($gr_props{$id}{elv_dep} eq "elevation") ? 0 : 1;
            if ($got_depth) {
                @depths     = @{ $gr_props{$id}{depths} };
            } else {
                @elevations = @{ $gr_props{$id}{elevations} };
            }
            $lastpt = ($got_depth) ? $#depths : $#elevations;
            @pt_elevations = ();
            for ($i=0; $i<=$lastpt; $i++) {
                if ($got_depth) {
                    push (@pt_elevations, $surf_elev - $depths[$i]);
                } else {
                    push (@pt_elevations, $elevations[$i]);
                }
            }
        } elsif ($props{$id}{meta} eq "w2_profile") {
            @el        = @{ $grid{$id}{el} };
            @kb        = @{ $grid{$id}{kb} };
            $nlayers   = $#{ $parm_data{$dt} } +1;
            $surf_elev = $elev_data{$dt};
            $seg       = $props{$id}{seg};
            $kt        = $kt_data{$dt};
            $kt        = $kb[$seg] if ($kt > $kb[$seg] && $nlayers == 1);
        } elsif ($props{$id}{meta} eq "w2_outflow") {
            $kmx       = $grid{$id}{kmx};
            @el        = @{ $grid{$id}{el} };
            @kb        = @{ $grid{$id}{kb} };
            if ($gr_props{$id}{qunits} eq "cfs/ft") {
                @flows = @{ $qdata{$dt} };
                $qmult = 10.763911;
            } elsif ($gr_props{$id}{qunits} eq "cms/m") {
                @flows = @{ $qdata{$dt} };
                $qmult = 1.0;
            } else {
                @flows = @{ $vdata{$dt} };
                $qmult = ($gr_props{$id}{qunits} eq "ft/s") ? 3.28084 : 1.0;
            }
            $surf_elev = $flows[1];           # second member is WS elevation (m)
        }
        if (defined($gr_props{$id}{add_cs}) && $gr_props{$id}{add_cs}) {
            @colors   = @{ $gr_props{$id}{colors} };
            $cs_min   = $gr_props{$id}{cs_min};
            $cs_max   = $gr_props{$id}{cs_max};
            $cs_range = $cs_max -$cs_min;
        }

#       W2 profile plot
        if ($props{$id}{meta} eq "w2_profile") {
            $xmin   = $gr_props{$id}{xmin};
            $xmax   = $gr_props{$id}{xmax};
            $xrange = $xmax -$xmin;
            @coords = ();
            for ($i=0; $i<$nlayers; $i++) {
                if ($props{$id}{parm} eq "Temperature" && $props{$id}{parm_units} eq "Fahrenheit") {
                    $xp = $x1 +($x2-$x1)*(($parm_data{$dt}[$i] *1.8 +32)-$xmin)/$xrange;
                } else {
                    $xp = $x1 +($x2-$x1)*($parm_data{$dt}[$i]-$xmin)/$xrange;
                }
                $xp = &max($x1, &min($x2, $xp));
                if ($i == 0) {
                    $yval = $surf_elev;
                } else {
                    $yval = $el[$kt+$i][$seg];
                }
                if ($gr_props{$id}{ytype} eq "Depth") {
                    $yp1 = $y1 +($y2-$y1)*($surf_elev-$yval)/$ymax;
                } else {
                    $yp1 = $y2 -($y2-$y1)*($yval-$ymin)/$yrange;
                }
                last if ($yp1 >= $y2);
                $yp1  = &max($y1, &min($y2, $yp1));
                $yval = $el[$kt+$i+1][$seg];
                if ($gr_props{$id}{ytype} eq "Depth") {
                    $yp2 = $y1 +($y2-$y1)*($surf_elev-$yval)/$ymax;
                } else {
                    $yp2 = $y2 -($y2-$y1)*($yval-$ymin)/$yrange;
                }
                next if ($yp2 <= $y1);
                $yp2 = &max($y1, &min($y2, $yp2));
                push (@coords, $xp, $yp1, $xp, $yp2);
                last if ($yp2 >= $y2);
            }
            $np = ($#coords +1)/2;

#           Plot optional color profile with depth
            if ($gr_props{$id}{add_cs} && $np > 1) {

#               Create an image to hold the color profile and recognize its methods
                $iw = $x2 -$x1 +1;
                $ih = $y2 -$y1 +1;
                $cmap_image = Tkx::image_create_photo(-width => $iw, -height => $ih);
                $cmap_image = Tkx::widget->new($cmap_image);
                $xp1 = 0;
                $xp2 = $iw -1;

                if ($gr_props{$id}{ytype} eq "Depth") {
                    $yp2 = 0;
                } else {
                    $yp2 = &round_to_int($ih-1 -($ih-1)*($surf_elev-$ymin)/$yrange);
                    $yp2 = &max(0, &min($ih-1, $yp2));
                }
                for ($i=0; $i<$nlayers; $i++) {
                    $yp1  = $yp2;
                    $yval = $el[$kt+$i+1][$seg];
                    if ($gr_props{$id}{ytype} eq "Depth") {
                        $yp2 = &round_to_int(($ih-1)*($surf_elev-$yval)/$ymax);
                    } else {
                        $yp2 = &round_to_int($ih-1 -($ih-1)*($yval-$ymin)/$yrange);
                    }
                    last if ($yp1 >= $ih-1);
                    if ($yp2 < 0) {
                        $yp2 = 0;
                        next;
                    }
                    $yp2 = &max(0, &min($ih-1, $yp2));
                    if ($props{$id}{parm} eq "Temperature" && $props{$id}{parm_units} eq "Fahrenheit") {
                        $j = int(($#colors+1) *(($parm_data{$dt}[$i] *1.8 +32)-$cs_min)/$cs_range);
                    } else {
                        $j = int(($#colors+1) *($parm_data{$dt}[$i]-$cs_min)/$cs_range);
                    }
                    $j = &max(0, &min($#colors, $j));
                    $cmap_image->put($colors[$j], -to => $xp1, $yp1, $xp2, $yp2);
                    last if ($yp2 >= $ih-1);
                }
                $canvas->create_image($x1, $y1, -anchor => 'nw',
                                                -image  => $cmap_image,
                                                -tags   => $gtag . " " . $gtag . "_colorProfile");
                undef $cmap_image;
            }
            undef %kt_data;
            undef %elev_data;
            undef %parm_data;

#           Plot the water surface and its indicator, if plotting elevations
            if ($gr_props{$id}{ytype} ne "Depth") {
                $yp = $y2 -($y2-$y1)*($surf_elev-$ymin)/$yrange;
                if ($yp >= $y1 && $yp <= $y2) {
                    $canvas->create_line($x1, $yp, $x2, $yp,
                                        -fill  => &get_rgb_code("gray60"),
                                        -width => 1,
                                        -arrow => 'none',
                                        -tags  => $gtag . " " . $gtag . "_profile");
                    $xp = $x1 + 0.9*($x2-$x1);
                    $canvas->create_polygon($xp, $yp, $xp-4, $yp-8, $xp+4, $yp-8,
                                        -outline => &get_rgb_code("gray60"),
                                        -width   => 1,
                                        -fill    => &get_rgb_code("white"),
                                        -tags    => $gtag . " " . $gtag . "_profile");
                }
            }

#           Plot the profile
            if ($np > 1) {
                $canvas->create_line(@coords, -fill  => &get_rgb_code("black"),
                                              -width => 1,
                                              -arrow => 'none',
                                              -tags  => $gtag . " " . $gtag . "_profile");
            }

#           Plot a no-data message
            if ($np <= 1) {
                if ($gr_props{$id}{ytype} eq "Depth") {
                    $yp  = ($y1+$y2)/2;
                    $anc = 'center';
                } else {
                    $yp  = $y2 -($y2-$y1)*($surf_elev-$ymin)/$yrange +5;
                    $anc = 'n';
                    if ($yp < $y1 || $yp > $y2) {
                        $yp  = ($y1+$y2)/2;
                        $anc = 'center';
                    }
                }
                $canvas->create_text(($x1+$x2)/2., $yp,
                                   -anchor => $anc, 
                                   -text   => "No Data",
                                   -fill   => &get_rgb_code("gray60"),
                                   -angle  => 0,
                                   -tags   => $gtag . " " . $gtag . "_profile",
                                   -font   => [-family     => $gr_props{$id}{xfont},
                                               -size       => $gr_props{$id}{xl_size},
                                               -weight     => 'normal',
                                               -slant      => 'roman',
                                               -underline  => 0,
                                               -overstrike => 0,
                                              ]);
            }

#           Add any measured profile data
            if (defined($props{$id}{ref_file})) {
                &plot_ref_profile($canvas, $id, 0);
            }

#       W2 layer outflow profile
        } elsif ($props{$id}{meta} eq "w2_outflow") {
            $seg     = $props{$id}{seg};
            $xmax    = $gr_props{$id}{xmax};
            @coords  = ();
            $np      = 0;
            $first   = 1;
            $last_xp = $x1;
            for ($k=2; $k<=$kmx; $k++) {
                next if (! defined($flows[$k]) || $flows[$k] eq "");
                if ($first) {
                    $yval  = $surf_elev;
                    $kt    = $k;
                    $first = 0;
                } else {
                    $yval  = $el[$k][$seg];
                }
                $xp = $x1 +($x2-$x1) *$flows[$k]*$qmult/$xmax;
                $xp = &max($x1, &min($x2, $xp));
                if ($gr_props{$id}{ytype} eq "Depth") {
                    $yp1 = $y1 +($y2-$y1)*($surf_elev-$yval)/$ymax;
                } else {
                    $yp1 = $y2 -($y2-$y1)*($yval-$ymin)/$yrange;
                }
                last if ($yp1 >= $y2);
                $yp1  = &max($y1, &min($y2, $yp1));
                $kalt = ($k == $kt && $kt > $kb[$seg]) ? $kb[$seg] : $k;
                if ($gr_props{$id}{ytype} eq "Depth") {
                    $yp2 = $y1 +($y2-$y1)*($surf_elev-$el[$kalt+1][$seg])/$ymax;
                } else {
                    $yp2 = $y2 -($y2-$y1)*($el[$kalt+1][$seg]-$ymin)/$yrange;
                }
                next if ($yp2 <= $y1);
                $yp2 = &max($y1, &min($y2, $yp2));
                if ($xp == $last_xp) {
                    push (@coords, $xp, $yp1) if ($#coords < 0);
                    push (@coords, $xp, $yp2);
                } else {
                    push (@coords, $last_xp, $yp1, $xp, $yp1, $xp, $yp2);
                }
                if (! defined($flows[$k+1]) && $xp != $x1) {
                    push (@coords, $x1, $yp2);
                }
                $np++ if ($xp > $x1);
                $last_xp = $xp;
                last if ($yp2 >= $y2);
            }

#           Work on a parameter-based color fill
            if ($np >= 1 && $props{$id}{add_parm} && $gr_props{$id}{add_cs}) {

#               Find a date match for the parameter-based color bars
                $dt_parm = $dt;
                $tol     = $props{$id}{match_tol};
                $found   = 0;
                if (defined($parm_data{$dt_parm})) {
                    $found = 1;
                } elsif ($tol > 0) {
                    for ($mi=1; $mi<=$tol; $mi++) {
                        $dt_parm2 = &adjust_dt($dt_parm, $mi);
                        if (defined($parm_data{$dt_parm2})) {
                            $dt_parm = $dt_parm2;
                            $found   = 1;
                            last;
                        }
                        $dt_parm2 = &adjust_dt($dt_parm, -1 *$mi);
                        if (defined($parm_data{$dt_parm2})) {
                            $dt_parm = $dt_parm2;
                            $found   = 1;
                            last;
                        }
                    }
                }

#               If a match was found, create the color profile image
                if ($found) {
                    $iw = $x2 -$x1 +1;
                    $ih = $y2 -$y1 +1;
                    $cmap_image = Tkx::image_create_photo(-width => $iw, -height => $ih);
                    $cmap_image = Tkx::widget->new($cmap_image);

                    if ($gr_props{$id}{ytype} eq "Depth") {
                        $yp2 = 0;
                    } else {
                        $yp2 = &round_to_int($ih-1 -($ih-1)*($surf_elev-$ymin)/$yrange);
                        $yp2 = &max(0, &min($ih-1, $yp2));
                    }
                    $kt_parm = $kt_data{$dt_parm};

                    for ($k=$kt; $k<=$kmx; $k++) {
                        $xp   = &round_to_int(($iw-1) *$flows[$k]*$qmult/$xmax);
                        $xp   = &max(0, &min($iw-1, $xp));
                        $yp1  = $yp2;
                        $kalt = ($k == $kt && $kt > $kb[$seg]) ? $kb[$seg] : $k;
                        if ($gr_props{$id}{ytype} eq "Depth") {
                            $yp2 = &round_to_int(($ih-1)*($surf_elev-$el[$kalt+1][$seg])/$ymax);
                        } else {
                            $yp2 = &round_to_int($ih-1 -($ih-1)*($el[$kalt+1][$seg]-$ymin)/$yrange);
                        }
                        last if ($yp1 >= $ih-1);
                        if ($yp2 < 0) {
                            $yp2 = 0;
                            next;
                        }
                        $yp2 = &min($ih-1, $yp2);
                        if ($xp > 0) {
                            $i    = &max(0, $k -$kt_parm);
                            $pval = $parm_data{$dt_parm}[$i];
                            if (defined($pval)) {
                                if ($props{$id}{parm} eq "Temperature"
                                       && $props{$id}{parm_units} eq "Fahrenheit") {
                                    $j = int(($#colors+1) *(($pval *1.8 +32)-$cs_min)/$cs_range);
                                } else {
                                    $j = int(($#colors+1) *($pval-$cs_min)/$cs_range);
                                }
                                $j = &max(0, &min($#colors, $j));
                                $cmap_image->put($colors[$j], -to => 0, $yp1, $xp, $yp2);
                            }
                        }
                        last if ($yp2 >= $ih-1);
                    }
                    $canvas->create_image($x1, $y1, -anchor => 'nw',
                                                    -image  => $cmap_image,
                                                    -tags   => $gtag . " " . $gtag . "_colorProfile");
                    undef $cmap_image;
                }
            }
            if ($props{$id}{add_parm} && $gr_props{$id}{add_cs}) {
                undef %kt_data;
                undef %parm_data;
            }

#           Plot the water surface and its indicator, if plotting elevations
            if ($gr_props{$id}{ytype} ne "Depth") {
                $yp = $y2 -($y2-$y1)*($surf_elev-$ymin)/$yrange;
                if ($yp >= $y1 && $yp <= $y2) {
                    $canvas->create_line($x1, $yp, $x2, $yp,
                                          -fill  => &get_rgb_code("gray60"),
                                          -width => 1,
                                          -arrow => 'none',
                                          -tags  => $gtag . " " . $gtag . "_profile");
                    $xp = $x1 + 0.9*($x2-$x1);
                    $canvas->create_polygon($xp, $yp, $xp-4, $yp-8, $xp+4, $yp-8,
                                          -outline => &get_rgb_code("gray60"),
                                          -width   => 1,
                                          -fill    => &get_rgb_code("white"),
                                          -tags    => $gtag . " " . $gtag . "_profile");
                }
            }

#           Plot the profile
            if ($np >= 1) {
                $canvas->create_line(@coords, -fill  => &get_rgb_code("black"),
                                              -width => 1,
                                              -arrow => 'none',
                                              -tags  => $gtag . " " . $gtag . "_profile");

#           Plot a no-data message
            } else {
                $canvas->create_text(($x1+$x2)/2., ($y1+$y2)/2.,
                                     -anchor => 'center',
                                     -text   => "No Data",
                                     -fill   => &get_rgb_code("gray60"),
                                     -angle  => 0,
                                     -tags   => $gtag . " " . $gtag . "_profile",
                                     -font   => [-family     => $gr_props{$id}{xfont},
                                                 -size       => $gr_props{$id}{xl_size},
                                                 -weight     => 'normal',
                                                 -slant      => 'roman',
                                                 -underline  => 0,
                                                 -overstrike => 0,
                                                ]);
            }
            undef %qdata;
            undef %vdata;

#       W2 water levels plot
        } elsif ($props{$id}{meta} eq "w2_wlevels") {
            $xmult   = ($gr_props{$id}{xunits} eq "miles") ? 3280.84/5280. : 1.0;
            $xbase   = $gr_props{$id}{xbase} /$xmult;  # km
            $xmin    = $gr_props{$id}{xmin}  /$xmult;  # km
            $xmax    = $gr_props{$id}{xmax}  /$xmult;  # km
            $xrange  = $xmax -$xmin;
            @seglist = @{ $gr_props{$id}{seglist} };
            @xdist   = @{ $gr_props{$id}{xdist}   };  # km
            @us      = @{ $grid{$id}{us}    };
            @ds      = @{ $grid{$id}{ds}    };
            @slope   = @{ $grid{$id}{slope} };
            $nbr     = $grid{$id}{nbr};
            @coords  = ();

#           Loop over the segment list
            $np = 0;
            for ($ns=0; $ns<=$#seglist; $ns++) {
                $i    = $seglist[$ns];
                $wsel = $wl_data{$dt}[$i];
                if ($wsel == -999) {
                    if ($#coords > 2) {
                        if ($gr_props{$id}{xflip}) {   # Flip the x values, if necessary
                            for ($n=0; $n<$#coords; $n+=2) {
                                $coords[$n] = $x2 -($coords[$n] -$x1);
                            }
                        }
                        $canvas->create_line(@coords,
                                             -fill  => &get_rgb_code($gr_props{$id}{wl_color}),
                                             -width => 1,
                                             -arrow => 'none',
                                             -tags  => $gtag . " " . $gtag . "_wlevels");
                    }
                    @coords = ();
                    next;
                }
                $xd1 = ($ns == 0) ? 0 : $xdist[$seglist[$ns-1]];
                $xd2 = $xdist[$i];
                $xp1 = $x1 +($x2-$x1)*($xd1 +$xbase -$xmin)/$xrange;
                $xp2 = $x1 +($x2-$x1)*($xd2 +$xbase -$xmin)/$xrange;
                next if ($xp2 < $x1);
                last if ($xp1 > $x2);

                $add_pt0 = $add_pt3 = 0;
                for ($jb=1; $jb<=$nbr; $jb++) {
                    last if ($i >= $us[$jb] && $i <= $ds[$jb]);
                }
                if ($gr_props{$id}{wl_style} =~ /Interpolate/i) {
#                   When a branch joins mid-segment, need to account for that.
#                   Array seglist is ds to us, so normal progression is to decreasing segment numbers.
                    if ($ns < $#seglist && $i != $us[$jb] && $seglist[$ns+1] != $i-1) {
                        $xp3 = $xp2;
                    } else {
                        $xp3 = 0.5*($xp1+$xp2);
                    }
                    $yp3 = $y2 -($y2-$y1)*($wsel-$ymin)/$yrange;

                    if ($xp3 < $x1) {
                        $last_xp = $xp3;
                        $last_yp = $yp3;
                        next;
                    }
                    if ($#coords == -1) {
                        last if ($xp1 == $x2);
                        $yp3 = $y1 if ($yp3 < $y1);
                        $yp3 = $y2 if ($yp3 > $y2);
                        $last_xp = &max($x1, $xp1);
                        $last_yp = $yp3;
                        push (@coords, $last_xp, $last_yp);
                    }
                    if ($yp3 < $y1 && $last_yp <= $y1) {
                        $yp3 = $y1;
                    } elsif ($yp3 > $y2 && $last_yp >= $y2) {
                        $yp3 = $y2;
                    }
                    if ($xp3 > $x2) {
                        $yp3 = ($yp3-$last_yp)*($x2-$last_xp)/($xp3-$last_xp)+$last_yp;
                        $xp3 = $x2;
                    }
                    if ($yp3 < $y1) {
                        $xp0 = ($xp3-$last_xp)*($y1-$last_yp)/($yp3-$last_yp)+$last_xp;
                        $yp0 = $yp3 = $y1;
                        $add_pt0 = 1;
                    } elsif ($yp3 > $y2) {
                        $xp0 = ($xp3-$last_xp)*($y2-$last_yp)/($yp3-$last_yp)+$last_xp;
                        $yp0 = $yp3 = $y2;
                        $add_pt0 = 1;
                    }
                    push (@coords, $xp0, $yp0) if ($add_pt0);
                    push (@coords, $xp3, $yp3);
                    if ($ns == $#seglist && $xp3 != $x2 && $xp2 > $xp3) {
                        push (@coords, &min($x2, $xp2), $yp3);
                    }
                    $np++;
                    $last_xp = $xp3;
                    $last_yp = $yp3;
                    last if ($xp3 >= $x2);

                } else {
                    if ($slope[$jb] == 0 || $gr_props{$id}{wl_style} =~ /Flat surface/i) {
                        $yp1 = $y2 -($y2-$y1)*($wsel-$ymin)/$yrange;
                        $xp1 = &max($x1, &min($x2, $xp1));
                        $xp2 = &max($x1, &min($x2, $xp2));
                        $yp1 = $yp2 = &max($y1, &min($y2, $yp1));
                    } else {
#                       When a branch joins mid-segment, need to account for that.
#                       Array seglist is ds to us, so normal progression is to decreasing segment numbers.
                        if ($ns < $#seglist && $i != $us[$jb] && $seglist[$ns+1] != $i-1) {
                            $yp1 = $y2 -($y2-$y1)*($wsel-($xd2-$xd1)*1000.*$slope[$jb]-$ymin)/$yrange;
                            $yp2 = $y2 -($y2-$y1)*($wsel-$ymin)/$yrange;
                        } else {
                            $yp1 = $y2 -($y2-$y1)*($wsel-0.5*($xd2-$xd1)*1000.*$slope[$jb]-$ymin)/$yrange;
                            $yp2 = $y2 -($y2-$y1)*($wsel+0.5*($xd2-$xd1)*1000.*$slope[$jb]-$ymin)/$yrange;
                        }
                        if ($xp1 < $x1) {
                            $yp1 = ($yp2-$yp1)*($x1-$xp1)/($xp2-$xp1)+$yp1;
                            $xp1 = $x1;
                        }
                        if ($xp2 > $x2) {
                            $yp2 = ($yp2-$yp1)*($x2-$xp1)/($xp2-$xp1)+$yp1;
                            $xp2 = $x2;
                        }
                        if ($yp1 < $y1 && $yp2 < $y1) {
                            $yp1 = $yp2 = $y1;
                        } elsif ($yp1 > $y2 && $yp2 > $y2) {
                            $yp1 = $yp2 = $y2;
                        }
                        if ($yp1 < $y1) {
                            $xp0 = $xp1;
                            $yp0 = $y1;
                            $xp1 = ($xp2-$xp1)*($y1-$yp1)/($yp2-$yp1)+$xp1;
                            $yp1 = $y1;
                            $add_pt0 = 1;
                        } elsif ($yp1 > $y2) {
                            $xp0 = $xp1;
                            $yp0 = $y2;
                            $xp1 = ($xp2-$xp1)*($y2-$yp1)/($yp2-$yp1)+$xp1;
                            $yp1 = $y2;
                            $add_pt0 = 1;
                        }
                        if ($yp2 < $y1) {
                            $xp3 = $xp1;
                            $yp3 = $y1;
                            $xp2 = ($xp2-$xp1)*($y1-$yp1)/($yp2-$yp1)+$xp1;
                            $yp2 = $y1;
                            $add_pt3 = 1;
                        } elsif ($yp2 > $y2) {
                            $xp3 = $xp1;
                            $yp3 = $y2;
                            $xp2 = ($xp2-$xp1)*($y2-$yp1)/($yp2-$yp1)+$xp1;
                            $yp2 = $y2;
                            $add_pt3 = 1;
                        }
                    }
                    push (@coords, $xp0, $yp0) if ($add_pt0);
                    push (@coords, $xp1, $yp1, $xp2, $yp2);
                    push (@coords, $xp3, $yp3) if ($add_pt3);
                    $np++;
                }
            }
            if ($#coords > 2) {
                if ($gr_props{$id}{xflip}) {   # Flip the x values, if necessary
                    for ($n=0; $n<$#coords; $n+=2) {
                        $coords[$n] = $x2 -($coords[$n] -$x1);
                    }
                }
                $canvas->create_line(@coords, -fill  => &get_rgb_code($gr_props{$id}{wl_color}),
                                              -width => 1,
                                              -arrow => 'none',
                                              -tags  => $gtag . " " . $gtag . "_wlevels");
            } elsif ($np == 0) {
                $canvas->create_text(($x1+$x2)/2., ($y1 +$y2)/2.,
                                     -anchor => 'center',
                                     -text   => "No Data",
                                     -fill   => &get_rgb_code("gray60"),
                                     -angle  => 0,
                                     -tags   => $gtag . " " . $gtag . "_wlevels",
                                     -font   => [-family     => $gr_props{$id}{xfont},
                                                 -size       => $gr_props{$id}{xl_size},
                                                 -weight     => 'normal',
                                                 -slant      => 'roman',
                                                 -underline  => 0,
                                                 -overstrike => 0,
                                                ]);
            }
            undef %wl_data;

#       Vertical profile data plot
        } elsif ($props{$id}{meta} eq "data_profile") {
            @pdata     = @{ $parm_data{$dt} };
            @estimated = @{ $gr_props{$id}{estimated} };
            $xmin      = $gr_props{$id}{xmin};
            $xmax      = $gr_props{$id}{xmax};
            $xrange    = $xmax -$xmin;
            if ($props{$id}{parm_units} eq "Fahrenheit") {
                $diff = ($props{$id}{prof_type} eq "difference") ? 0 : 32;
                for ($i=0; $i<=$lastpt; $i++) {
                    next if ($pdata[$i] eq "na");
                    $pdata[$i] = $pdata[$i] *1.8 +$diff;
                }
            }

#           Populate a data array, and make sure data are available
            @coords   = @valid_pdata = ();
            @pt_color = @valid_elevs = ();
            for ($i=0; $i<=$lastpt; $i++) {
                next if ($pdata[$i] eq "na");
                next if ($pt_elevations[$i] > $surf_elev +0.1/3.28084);
                next if ($gr_props{$id}{ytype} ne "Depth" && $wsurf{$dt} eq "na");
                $xp = $x1 +($x2-$x1)*($pdata[$i]-$xmin)/$xrange;
                if ($gr_props{$id}{ytype} eq "Depth") {
                    $yp = $y1 +($y2-$y1)*($surf_elev-$pt_elevations[$i])/$ymax;
                } else {
                    $yp = $y2 -($y2-$y1)*($pt_elevations[$i]-$ymin)/$yrange;
                }
                push (@coords, $xp, $yp);
                push (@valid_pdata, $pdata[$i]);
                push (@valid_elevs, $pt_elevations[$i]);
                if ($estimated[$i]) {
                    push (@pt_color, "DarkGray");
                } else {
                    push (@pt_color, "black");
                }
            }
            $np = ($#coords +1)/2;

#           Plot optional color profile with depth
            if ($gr_props{$id}{add_cs} && $np > 1) {

#               Create an image to hold the color profile and recognize its methods
                $iw = $x2 -$x1 +1;
                $ih = $y2 -$y1 +1;
                $cmap_image = Tkx::image_create_photo(-width => $iw, -height => $ih);
                $cmap_image = Tkx::widget->new($cmap_image);
                $xp1 = 0;
                $xp2 = $iw -1;

                $old_elev = $surf_elev;
                if ($gr_props{$id}{ytype} eq "Depth") {
                    $yp2 = 0;
                    $el_limit = $surf_elev -$ymax;
                } else {
                    $yp2 = &round_to_int($ih-1 -($ih-1)*($old_elev-$ymin)/$yrange);
                    $yp2 = &max(0, &min($ih-1, $yp2));
                    $el_limit = $ymin;
                }
                $dy = &max(1.0/3.28084, $yrange/($ih-1));
                for ($elev=$surf_elev-$dy; $elev>$el_limit-$dy; $elev-=$dy) {
                    $yp1 = $yp2;
                    if ($gr_props{$id}{ytype} eq "Depth") {
                        $yp2 = &round_to_int(($ih-1)*($surf_elev-$elev)/$ymax);
                    } else {
                        $yp2 = &round_to_int($ih-1 -($ih-1)*($elev-$ymin)/$yrange);
                    }
                    last if ($yp1 >= $ih-1);
                    if ($yp2 < 0) {
                        $old_elev = $elev;
                        $yp2 = 0;
                        next;
                    }
                    $yp2 = &max(0, &min($ih-1, $yp2));

#                   Elevation range of interest is deeper than deepest measurement
                    if ($old_elev <= $valid_elevs[$np-1]) {
                        $pval = $valid_pdata[$np-1];
                    } else {
                        $first = 1;
                        for ($i=0; $i<$np; $i++) {
                            next if ($valid_elevs[$i] > $surf_elev +0.1/3.28084);
                            $el1   = $valid_elevs[$i];
                            $el2   = $valid_elevs[$i+1] if ($i < $np-1);
                            $el3   = $valid_elevs[$i-1] if ($i > 0 && ! $first);
                            $pval1 = $valid_pdata[$i];
                            $pval2 = $valid_pdata[$i+1] if ($i < $np-1);
                            $pval3 = $valid_pdata[$i-1] if ($i > 0 && ! $first);

#                           Elevation is shallower than first measurement
                            if ($first && $el1 <= $elev) {
                                $pval = $pval1;
                                last;

#                           Measurement is in the elevation range of interest
                            } elsif ($el1 < $old_elev && $el1 >= $elev) {

#                               Shallowest measurement in elevation range of interest
                                if ($first) {
                                    $bot  = $pval1 + ($pval2-$pval1)*($el1-$elev)/($el1-$el2);
                                    $pval = ($pval1*($old_elev-$el1)
                                            +(($pval1+$bot)/2.)*($el1-$elev))/($old_elev-$elev);
                                    last;

#                               Deepest measurement in elevation range of interest
                                } elsif ($i == $np-1) {
                                    $top  = $pval3 + ($pval1-$pval3)*($el3-$old_elev)/($el3-$el1);
                                    $pval = ((($top+$pval1)/2.)*($old_elev-$el1)
                                            +$pval1*($el1-$elev))/($old_elev-$elev);
                                    last;

#                               Not shallowest, not deepest, in range of interest
                                } else {
                                    $top  = $pval3 + ($pval1-$pval3)*($el3-$old_elev)/($el3-$el1);
                                    $bot  = $pval1 + ($pval2-$pval1)*($el1-$elev)/($el1-$el2);
                                    $pval = ((($top+$pval1)/2.)*($old_elev-$el1)
                                            +(($pval1+$bot)/2.)*($el1-$elev))/($old_elev-$elev);
                                    last;
                                }

#                           One measurement above and one below the elevation range of interest
                            } elsif ($el1 >= $old_elev && $el2 <= $elev) {
                                $top  = $pval1 + ($pval2-$pval1)*($el1-$old_elev)/($el1-$el2);
                                $bot  = $pval1 + ($pval2-$pval1)*($el1-$elev)/($el1-$el2);
                                $pval = ($top+$bot)/2.;
                                last;
                            }
                            $first = 0;
                        }
                    }
                    $j = int(($#colors+1) *($pval-$cs_min)/$cs_range);
                    $j = &max(0, &min($#colors, $j));
                    $cmap_image->put($colors[$j], -to => $xp1, $yp1, $xp2, $yp2);
                    $old_elev = $elev;
                    last if ($yp2 >= $ih-1);
                }
                $canvas->create_image($x1, $y1, -anchor => 'nw',
                                                -image  => $cmap_image,
                                                -tags   => $gtag . " " . $gtag . "_colorProfile");
                undef $cmap_image;
            }

#           Plot the water surface and its indicator, if plotting elevations
            if ($gr_props{$id}{ytype} ne "Depth" && $wsurf{$dt} ne "na") {
                $yp = $y2 -($y2-$y1)*($surf_elev-$ymin)/$yrange;
                if ($yp >= $y1 && $yp <= $y2) {
                    $canvas->create_line($x1, $yp, $x2, $yp,
                                         -fill  => &get_rgb_code("gray60"),
                                         -width => 1,
                                         -arrow => 'none',
                                         -tags  => $gtag . " " . $gtag . "_profile");
                    $xp = $x1 + 0.9*($x2-$x1);
                    $canvas->create_polygon($xp, $yp, $xp-4, $yp-8, $xp+4, $yp-8,
                                         -outline => &get_rgb_code("gray60"),
                                         -width   => 1,
                                         -fill    => &get_rgb_code("white"),
                                         -tags    => $gtag . " " . $gtag . "_profile");
                }
            }

#           Plot the vertical profile
            if ($np > 1) {
                for ($i=1; $i<$np; $i++) {
                    $xp1 = $coords[2*$i-2];
                    $yp1 = $coords[2*$i-1];
                    $xp2 = $coords[2*$i];
                    $yp2 = $coords[2*$i+1];
                    $pt1_in = ($xp1 >= $x1 && $xp1 <= $x2 &&
                               $yp1 >= $y1 && $yp1 <= $y2) ? 1 : 0;
                    $pt2_in = ($xp2 >= $x1 && $xp2 <= $x2 &&
                               $yp2 >= $y1 && $yp2 <= $y2) ? 1 : 0;
                    next if (! $pt1_in && ! $pt2_in);
                    if (! $pt1_in) {
                        if ($xp1 < $x1) {
                            $yp = $yp1 +($yp2-$yp1) *($x1-$xp1) /($xp2-$xp1);
                            $xp = $x1;
                        } elsif ($xp1 > $x2) {
                            $yp = $yp1 +($yp2-$yp1) *($x2-$xp1) /($xp2-$xp1);
                            $xp = $x2;
                        } else {
                            $xp = $xp1 +($xp2-$xp1) *($y1-$yp1) /($yp2-$yp1);
                            $yp = $y1;
                        }
                        if ($yp < $y1) {
                            $xp = $xp1 +($xp2-$xp1) *($y1-$yp1) /($yp2-$yp1);
                            $yp = $y1;
                        }
                        $xp1 = $xp;
                        $yp1 = $yp;
                    } elsif (! $pt2_in) {
                        if ($xp2 < $x1) {
                            $yp = $yp1 +($yp2-$yp1) *($x1-$xp1) /($xp2-$xp1);
                            $xp = $x1;
                        } elsif ($xp2 > $x2) {
                            $yp = $yp1 +($yp2-$yp1) *($x2-$xp1) /($xp2-$xp1);
                            $xp = $x2;
                        } else {
                            $xp = $xp1 +($xp2-$xp1) *($y2-$yp1) /($yp2-$yp1);
                            $yp = $y2;
                        }
                        if ($yp > $y2) {
                            $xp = $xp1 +($xp2-$xp1) *($y2-$yp1) /($yp2-$yp1);
                            $yp = $y2;
                        }
                        $xp2 = $xp;
                        $yp2 = $yp;
                    }
                    $canvas->create_line($xp1, $yp1, $xp2, $yp2,
                                            -fill  => &get_rgb_code($pt_color[$i]),
                                            -width => 1,
                                            -arrow => 'none',
                                            -tags  => $gtag . " " . $gtag . "_profile");
                }

#           Plot a no-data message
            } else {
                if ($gr_props{$id}{ytype} eq "Depth" || $wsurf{$dt} eq "na") {
                    $yp  = ($y1+$y2)/2;
                    $anc = 'center';
                } else {
                    $yp  = $y2 -($y2-$y1)*($surf_elev-$ymin)/$yrange +5;
                    $anc = 'n';
                    if ($yp < $y1 || $yp > $y2) {
                        $yp  = ($y1+$y2)/2;
                        $anc = 'center';
                    }
                }
                $canvas->create_text(($x1+$x2)/2, $yp,
                                    -anchor => $anc, 
                                    -text   => "No Data",
                                    -fill   => &get_rgb_code("gray60"),
                                    -angle  => 0,
                                    -tags   => $gtag . " " . $gtag . "_profile",
                                    -font   => [-family     => $gr_props{$id}{xfont},
                                                -size       => $gr_props{$id}{xl_size},
                                                -weight     => 'normal',
                                                -slant      => 'roman',
                                                -underline  => 0,
                                                -overstrike => 0,
                                               ]);
            }

#           Plot the measured points
            for ($i=0; $i<$np; $i++) {
                $xp = $coords[2*$i];
                $yp = $coords[2*$i+1];
                if ($xp >= $x1 && $xp <= $x2 && $yp >= $y1 && $yp <= $y2) {
                    if ($gr_props{$id}{add_cs}) {
                        $pval = $valid_pdata[$i];
                        $j    = int(($#colors+1) *($pval-$cs_min)/$cs_range);
                        $j    = &max(0, &min($#colors, $j));
                        $canvas->create_oval($xp-3, $yp-3, $xp+3, $yp+3,
                                            -outline => &get_rgb_code($pt_color[$i]),
                                            -width   => 1,
                                            -fill    => $colors[$j],
                                            -tags    => $gtag . " " . $gtag . "_profile");
                    } else {
                        $canvas->create_oval($xp-3, $yp-3, $xp+3, $yp+3,
                                            -outline => &get_rgb_code($pt_color[$i]),
                                            -width   => 1,
                                            -fill    => &get_rgb_code("white"),
                                            -tags    => $gtag . " " . $gtag . "_profile");
                    }
                }
            }
            undef %parm_data;
            undef %wsurf;

#       Vertical withdrawal zone
        } elsif ($props{$id}{meta} eq "vert_wd_zone") {
            $kbot = $gr_props{$id}{kb};
            @el   = @{ $gr_props{$id}{el} };
            @t    = ();
            $np   = $flow_data = 0;
            @valid_temps = ();
            @valid_elevs = ();
            for ($i=0; $i<=$lastpt; $i++) {
                next if ($temps{$dt}[$i] eq "na");
                next if ($pt_elevations[$i] > $surf_elev +0.1/3.28084);
                next if ($gr_props{$id}{ytype} ne "Depth" && $wsurf{$dt} eq "na");
                push (@valid_temps, $temps{$dt}[$i]);
                push (@valid_elevs, $pt_elevations[$i]);
                $np++;
            }
            undef %temps;

            if ($np > 0) {
                for ($k=2; $k<=$kbot; $k++) {
                    if ($el[$k+1] >= $surf_elev) {
                        $t[$k] = -999.;
                        next;
                    }

#                   Elevation range of interest is deeper than deepest measurement
                    if ($el[$k] <= $valid_elevs[$np-1]) {
                        $t[$k] = $valid_temps[$np-1];

                    } else {
                        if ($el[$k] > $surf_elev) {
                            $height = $surf_elev -$el[$k+1];
                        } else {
                            $height = $el[$k] -$el[$k+1];
                        }
                        $first = 1;
                        for ($i=0; $i<$np; $i++) {
                            next if ($valid_elevs[$i] > $surf_elev +0.1/3.28084);
                            $el1 = $valid_elevs[$i];
                            $el2 = $valid_elevs[$i+1] if ($i < $np-1);
                            $el3 = $valid_elevs[$i-1] if ($i > 0 && ! $first);
                            $wt1 = $valid_temps[$i];
                            $wt2 = $valid_temps[$i+1] if ($i < $np-1);
                            $wt3 = $valid_temps[$i-1] if ($i > 0 && ! $first);

#                           Elevation is shallower than first measurement
                            if ($first && $el1 <= $el[$k+1]) {
                                $t[$k] = $wt1;
                                last;

#                           Measurement is in the elevation range of interest
                            } elsif ($el1 < $el[$k] && $el1 >= $el[$k+1]) {

#                               Shallowest measurement in elevation range of interest
                                if ($first) {
                                    $bot   = $wt1 + ($wt2-$wt1)*($el1-$el[$k+1])/($el1-$el2);
                                    $t[$k] = ($wt1*(&min($el[$k], $surf_elev)-$el1)
                                            +(($wt1+$bot)/2.)*($el1-$el[$k+1]))/$height;
                                    last;

#                               Deepest measurement in elevation range of interest
                                } elsif ($i == $np-1) {
                                    $top   = $wt3 + ($wt1-$wt3)*($el3-$el[$k])/($el3-$el1);
                                    $t[$k] = ((($top+$wt1)/2.)*($el[$k]-$el1)
                                            +$wt1*($el1-$el[$k+1]))/$height;
                                    last;

#                               Not shallowest, not deepest, in range of interest
                                } else {
                                    $top   = $wt3 + ($wt1-$wt3)*($el3-$el[$k])/($el3-$el1);
                                    $bot   = $wt1 + ($wt2-$wt1)*($el1-$el[$k+1])/($el1-$el2);
                                    $t[$k] = ((($top+$wt1)/2.)*($el[$k]-$el1)
                                            +(($wt1+$bot)/2.)*($el1-$el[$k+1]))/$height;
                                    last;
                                }

#                           One measurement above and one below the elevation range of interest
                            } elsif ($el1 >= $el[$k] && $el2 <= $el[$k+1]) {
                                $top   = $wt1 + ($wt2-$wt1)*($el1-$el[$k])  /($el1-$el2);
                                $bot   = $wt1 + ($wt2-$wt1)*($el1-$el[$k+1])/($el1-$el2);
                                $t[$k] = ($top+$bot)/2.;
                                last;
                            }
                            $first = 0;
                        }
                    }
                }

#               Determine whether flow data are available
#               and whether computations have already been completed for this date
                %qdata     = %{ $gr_props{$id}{qdata} };
                $flow_data = (defined($qdata{$dt})) ? 1 : 0;
                $do_calcs  = 0;
                if ($flow_data) {
                    $do_calcs = 1;
                    if (defined($gr_props{$id}{qtot_data})) {
                        %tdata     = %{ $gr_props{$id}{tdata}     };
                        %qtot_data = %{ $gr_props{$id}{qtot_data} };
                        %vtot_data = %{ $gr_props{$id}{vtot_data} };
                        if (defined($qtot_data{$dt})) {
                            $do_calcs = 0;                 # computations already done for this date
                            @qtot = @{ $qtot_data{$dt} };  # layer outflows in cms/m
                            @vtot = @{ $vtot_data{$dt} };  # layer velocities in m/s
                        }
                    } else {
                        %tdata = %qtot_data = %vtot_data = ();
                    }
                }

#               Do the outflow computations if not already completed
                if ($flow_data && $do_calcs) {
                    @qstr = @{ $qdata{$dt} };
                    @tstr = ();

#                   Set parameters for computing vertical withdrawal zone
                    @qtot = @vtot = ();
                    for ($k=2; $k<=$kbot; $k++) {
                        $qtot[$k] = $vtot[$k] = 0;
                    }
                    $qsum   = 0;
                    $tsum   = 0;
                    $nout   = $gr_props{$id}{nout};
                    @sw_alg = @{ $gr_props{$id}{sw_alg} };
                    @names  = @{ $gr_props{$id}{names}  };
                    @estr   = @{ $gr_props{$id}{estr}   };
                    @lw     = @{ $gr_props{$id}{lw}     };
                    @ktsw   = @{ $gr_props{$id}{ktsw}   };
                    @kbsw   = @{ $gr_props{$id}{kbsw}   };
                    @b      = @{ $gr_props{$id}{b}      };

#                   Compute water densities
                    @rho = ();
                    for ($k=2; $k<=$kbot; $k++) {
                        next if ($t[$k] == -999.);
                        $rho[$k] = ((((6.536332E-9*$t[$k]-1.120083E-6)*$t[$k]+1.001685E-4)*$t[$k]
                                      -9.09529E-3)*$t[$k]+6.793952E-2)*$t[$k]+999.842594;
                    }

#                   Collect data needed for selective withdrawal routines
                    $ds_parms{kb}   = $kbot;
                    $ds_parms{kmx}  = $gr_props{$id}{kmx};
                    $ds_parms{wsel} = $surf_elev;       # meters
                    $ds_parms{b}    = [ @b   ];         # meters
                    $ds_parms{el}   = [ @el  ];         # meters
                    $ds_parms{wt}   = [ @t   ];         # deg C
                    $ds_parms{rho}  = [ @rho ];         # kg/cu.m.

                    if ($props{$id}{wd_alg} eq "Libby Dam") {
                        $ds_parms{num_rows}  = $gr_props{$id}{num_rows};
                        $ds_parms{bh_width}  = $gr_props{$id}{bh_width};      # meters
                        $ds_parms{bh_height} = $gr_props{$id}{bh_height};     # meters
                        $ds_parms{base_elev} = $gr_props{$id}{base_elev};     # meters
                        $ds_parms{hlc_base}  = $gr_props{$id}{hlc_base};
                        $ds_parms{hlc_inc}   = $gr_props{$id}{hlc_inc};
                        $ds_parms{bh_miss}   = $gr_props{$id}{bh_miss};
                        @nslots              = @{ $gr_props{$id}{num_slots} };
                        @ww_names            = @{ $gr_props{$id}{ww_names}  };
                        @noutlets            = @{ $gr_props{$id}{num_outs}  };
                    }

#                   Loop over the outlets
                    for ($n=0; $n<$nout; $n++) {
                        if ($qstr[$n] == 0.) {
                            $tstr[$n] = -99.;
                            next;
                        }
                        $ds_parms{qstr} = $qstr[$n];         # cms
                        $ds_parms{ktsw} = $ktsw[$n];
                        $ds_parms{kbsw} = $kbsw[$n];

#                       Compute flows to a discrete outlet using original W2 algorithm
                        if ($sw_alg[$n] eq "W2orig") {
                            $ds_parms{estr} = $estr[$n];     # meters
                            $ds_parms{wstr} = $lw[$n];       # meters
                            ($tout, @qout)  = &downstream_withdrawal(%ds_parms);

#                       Compute flows over/through bulkhead stacks to a wet well
#                       using the new Libby Dam algorithm
                        } elsif ($sw_alg[$n] eq "LibbyDam") {

#                           The wet well number is found by matching outlet names
                            $nww = &list_match($names[$n], @ww_names);
                            if ($nww == -1 || $nww > $gr_props{$id}{num_ww} -1) {
                                return &pop_up_error($main,
                                          "Failed to match the name of the wet well to\n"
                                        . "one of the named outlets in the release rate file:\n"
                                        . "  $props{$id}{lbc_file}\n  $props{$id}{flow_file}");
                            }
                            $ds_parms{nslots}   = $nslots[$nww];
                            $ds_parms{noutlets} = $noutlets[$nww];

                            ($tout, @qout) = &libby_calcs($nww, $dt, %ds_parms);
                        }

                        $qsum += $qstr[$n];          # Note: qstr[] and qout[] in cms
                        $tsum += $qstr[$n] *$tout;   # and tout is in deg Celsius
                        for ($k=2; $k<=$kbot; $k++) {
                            $qtot[$k] += $qout[$k];
                        }
                        $tstr[$n] = $tout;
                    }
                    undef %ds_parms;

                    $tstr[$nout] = ($qsum > 0) ? $tsum /$qsum : -99.;
                    $tdata{$dt}  = [ @tstr ];
                    $gr_props{$id}{tdata} = { %tdata };    # in deg Celsius

#                   Adjust flow per unit height (cms/m) and compute velocity (m/s)
                    for ($k=2; $k<=$kbot; $k++) {
                        next if ($el[$k+1] >= $surf_elev);
                        $height    = &min($surf_elev, $el[$k]) -$el[$k+1];
                        $vtot[$k]  = $qtot[$k] /($height *$b[$k]);
                        $qtot[$k] /= $height;
                    }
                    $qtot_data{$dt} = [ @qtot ];
                    $vtot_data{$dt} = [ @vtot ];
                    $gr_props{$id}{qtot_data} = { %qtot_data };  # layer outflows in cms/m
                    $gr_props{$id}{vtot_data} = { %vtot_data };  # layer velocities in m/s
                }
                undef %qdata;
            }

#           Draw the water-surface indicator
            if ($gr_props{$id}{ytype} ne "Depth" && $wsurf{$dt} ne "na") {
                $yp = $y2 -($y2-$y1)*($surf_elev-$ymin)/$yrange;
                if ($yp >= $y1 && $yp <= $y2) {
                    $canvas->create_line($x1, $yp, $x2, $yp,
                                        -fill  => &get_rgb_code("gray60"),
                                        -width => 1,
                                        -arrow => 'none',
                                        -tags  => $gtag . " " . $gtag . "_profile");
                    $xp = $x1 + 0.9*($x2-$x1);
                    $canvas->create_polygon($xp, $yp, $xp-4, $yp-8, $xp+4, $yp-8,
                                        -outline => &get_rgb_code("gray60"),
                                        -width   => 1,
                                        -fill    => &get_rgb_code("white"),
                                        -tags    => $gtag . " " . $gtag . "_profile");
                }
            }

#           Plot a no-data message
            if ($np == 0 || ! $flow_data) {
                if ($gr_props{$id}{ytype} ne "Depth" && $wsurf{$dt} ne "na") {
                    $yp  = $y2 -($y2-$y1)*($surf_elev-$ymin)/$yrange +5;
                    $anc = 'n';
                    if ($yp < $y1 || $yp > $y2) {
                        $yp  = ($y1 +$y2)/2.;
                        $anc = 'center';
                    }
                } else {
                    $yp  = ($y1 +$y2)/2.;
                    $anc = 'center';
                }
                $msg = ($np == 0) ? "No Data" : "No Outlet Flow Data";
                $canvas->create_text(($x1+$x2)/2, $yp,
                                -anchor => $anc, 
                                -text   => $msg,
                                -fill   => &get_rgb_code("gray60"),
                                -angle  => 0,
                                -tags   => $gtag . " " . $gtag . "_profile",
                                -font   => [-family     => $gr_props{$id}{xfont},
                                            -size       => $gr_props{$id}{xl_size},
                                            -weight     => 'normal',
                                            -slant      => 'roman',
                                            -underline  => 0,
                                            -overstrike => 0,
                                           ]);
            }
            undef %wsurf;

#           Draw the layer-specific flow graph
            if ($np > 0 && $flow_data) {

#               Create an image to hold the color profile and recognize its methods
                if ($gr_props{$id}{add_cs}) {
                    $iw = $x2 -$x1 +1;
                    $ih = $y2 -$y1 +1;
                    $cmap_image = Tkx::image_create_photo(-width => $iw, -height => $ih);
                    $cmap_image = Tkx::widget->new($cmap_image);
                }

                if ($gr_props{$id}{qunits} eq "cfs/ft") {      # outflow per unit height
                    $qmult = 10.763911;
                } elsif ($gr_props{$id}{qunits} eq "cms/m") {  # outflow per unit height
                    $qmult = 1.0;
                } else {                                 # swap for velocity data
                    @qtot  = @vtot;
                    $qmult = ($gr_props{$id}{qunits} eq "ft/s") ? 3.28084 : 1.0;
                }
                @coords  = ();
                $last_xp = $x1;
                for ($k=2; $k<=$kbot; $k++) {
                    next if ($el[$k+1] >= $surf_elev);
                    if ($gr_props{$id}{ytype} eq "Depth") {
                        last if ($surf_elev -$el[$k] > $ymax);
                    } else {
                        next if ($el[$k+1] > $ymax);
                        last if ($el[$k]   < $ymin);
                    }
                    if ($gr_props{$id}{add_cs}) {
                        $xp = &round_to_int(&min($iw-1, ($iw-1)*$qtot[$k]*$qmult/$gr_props{$id}{xmax}));
                        if ($xp > 0) {
                            if ($gr_props{$id}{ytype} eq "Depth") {
                                $yp1 = &round_to_int(($ih-1)*(&max(0.0, $surf_elev-$el[$k]))/$ymax);
                                $yp2 = &round_to_int(($ih-1)*($surf_elev-$el[$k+1])/$ymax);
                            } else {
                                $yp1 = &round_to_int($ih-1 -($ih-1)*(&min($surf_elev,$el[$k])-$ymin)/$yrange);
                                $yp2 = &round_to_int($ih-1 -($ih-1)*($el[$k+1]-$ymin)/$yrange);
                            }
                            $yp1 = &max(0, &min($ih-1, $yp1));
                            $yp2 = &max(0, &min($ih-1, $yp2));
                            if ($props{$id}{wt_units} eq "Fahrenheit") {
                                $j = int(($#colors+1) *(($t[$k] *1.8 +32)-$cs_min)/$cs_range);
                            } else {
                                $j = int(($#colors+1) *($t[$k]-$cs_min)/$cs_range);
                            }
                            $j = &max(0, &min($#colors, $j));
                            $cmap_image->put($colors[$j], -to => 0, $yp1, $xp, $yp2);
                        }
                    }
                    $xp = &min($x2, $x1 +($x2-$x1)*$qtot[$k]*$qmult/$gr_props{$id}{xmax});
                    if ($gr_props{$id}{ytype} eq "Depth") {
                        $yp1 = $y1 +($y2-$y1)*(&max(0.0, $surf_elev-$el[$k]))/$ymax;
                        $yp2 = $y1 +($y2-$y1)*($surf_elev-$el[$k+1])/$ymax;
                    } else {
                        $yp1 = $y2 -($y2-$y1)*(&min($surf_elev, $el[$k])-$ymin)/$yrange;
                        $yp2 = $y2 -($y2-$y1)*($el[$k+1]-$ymin)/$yrange;
                    }
                    $yp1 = &max($y1, &min($y2, $yp1));
                    $yp2 = &max($y1, &min($y2, $yp2));
                    if ($xp == $last_xp) {
                        push (@coords, $xp, $yp1) if ($#coords < 0);
                        push (@coords, $xp, $yp2);
                    } else {
                        push (@coords, $last_xp, $yp1, $xp, $yp1, $xp, $yp2);
                    }
                    if ($k == $kbot && $xp != $x1) {
                        push (@coords, $x1, $yp2);
                    }
                    $last_xp = $xp;
                    last if ($yp2 == $y2);
                }
                if ($gr_props{$id}{add_cs}) {
                    $canvas->create_image($x1, $y1,
                                          -anchor => 'nw',
                                          -image  => $cmap_image,
                                          -tags   => $gtag . " " . $gtag . "_colorProfile");
                    undef $cmap_image;
                }

#               Plot the flow graph
                if ($#coords >= 3) {
                    $canvas->create_line(@coords,
                                         -fill  => &get_rgb_code("black"),
                                         -width => 1,
                                         -arrow => 'none',
                                         -tags  => $gtag . " " . $gtag . "_profile");
                }
            }
        }

#       Update any links
        if ($props{$id}{meta} =~ /^(data_profile|vert_wd_zone|w2_profile)$/) {
            &update_links($canvas, $id, $dt);
        }

#       Place the graphic items in the proper order
        $canvas->lower($gtag . "_colorProfile", $gtag . "_xaxis") if (defined($gr_props{$id}{add_cs})
                                                                      && $gr_props{$id}{add_cs});
        $canvas->lower($gtag . "_profile",      $gtag . "_xaxis");
        $canvas->lower($gtag . "_refData",      $gtag . "_xaxis");
        $canvas->lower($gtag . "_wlevels",      $gtag . "_xaxis") if ($props{$id}{meta} eq "w2_wlevels");
        if ($props{$id}{meta} eq "vert_wd_zone") {
            if ($props{$id}{wd_alg} eq "Libby Dam" && $gr_props{$id}{bh_show}) {
                $canvas->lower($gtag . "_openBH", $id);
            }
        }
        if ($group_tags) {
            foreach $tag (@grp_tags) {
                $canvas->addtag($tag, withtag => $gtag);
            }
        }
    }
    Tkx::update_idletasks();
}


################################################################################
#
# Zoom tools
#
################################################################################

sub zoom_toolbar {
    my ($X, $Y) = @_;
    my (
        $fr_btns, $fr_msgs, $frame, $geom, $gkid, $ggkid, $i, $indx, $kid,

        @grandkids, @greatgrandkids, @kids, @zoom_btn, @zoom_btn_img,
        @zoom_btn_img2,
       );

    $zoom_tip = "";

#   Normal zoom toolbar images
    $zoom_btn_img[0] = Tkx::image_create_photo(-file => "${prog_path}images/zoom_in.png");
    $zoom_btn_img[1] = Tkx::image_create_photo(-file => "${prog_path}images/zoom_inX.png");
    $zoom_btn_img[2] = Tkx::image_create_photo(-file => "${prog_path}images/zoom_inY.png");
    $zoom_btn_img[3] = Tkx::image_create_photo(-file => "${prog_path}images/zoom_out.png");
    $zoom_btn_img[4] = Tkx::image_create_photo(-file => "${prog_path}images/zoom_outX.png");
    $zoom_btn_img[5] = Tkx::image_create_photo(-file => "${prog_path}images/zoom_outY.png");
    $zoom_btn_img[6] = Tkx::image_create_photo(-file => "${prog_path}images/zoom_full.png");
    $zoom_btn_img[7] = Tkx::image_create_photo(-file => "${prog_path}images/zoom_fullX.png");
    $zoom_btn_img[8] = Tkx::image_create_photo(-file => "${prog_path}images/zoom_fullY.png");

    if (defined($zoom_tb) && Tkx::winfo_exists($zoom_tb)) {
        if ($zoom_tb->g_wm_title() eq "Zoom toolbar") {
            $zoom_tb->configure(-cursor => $cursor_norm);
            $indx = 0;
            @kids = Tkx::SplitList(Tkx::winfo_children($zoom_tb));
            foreach $kid (@kids) {
                @grandkids = Tkx::SplitList(Tkx::winfo_children($kid));
                foreach $gkid (@grandkids) {
                    @greatgrandkids = Tkx::SplitList(Tkx::winfo_children($gkid));
                    foreach $ggkid (@greatgrandkids) {
                        if (Tkx::winfo_class($ggkid) eq "Button") {
                            $ggkid = Tkx::widget->new($ggkid);
                            $ggkid->configure(-image => $zoom_btn_img[$indx]);
                            $indx++;
                            return if ($indx > 8);
                        }
                    }
                }
            }
            return;
        }
    }

    $geom = sprintf("+%d+%d", $X, $Y);
    $zoom_tb = $main->new_toplevel();
    $zoom_tb->g_wm_transient($main);
    $zoom_tb->g_wm_title("Zoom toolbar");
    $zoom_tb->configure(-cursor => $cursor_norm);
    $zoom_tb->g_wm_geometry($geom);

#   Active zoom toolbar images
    $zoom_btn_img2[0] = Tkx::image_create_photo(-file => "${prog_path}images/zoom_in2.png");
    $zoom_btn_img2[1] = Tkx::image_create_photo(-file => "${prog_path}images/zoom_inX2.png");
    $zoom_btn_img2[2] = Tkx::image_create_photo(-file => "${prog_path}images/zoom_inY2.png");
    $zoom_btn_img2[3] = Tkx::image_create_photo(-file => "${prog_path}images/zoom_out2.png");
    $zoom_btn_img2[4] = Tkx::image_create_photo(-file => "${prog_path}images/zoom_outX2.png");
    $zoom_btn_img2[5] = Tkx::image_create_photo(-file => "${prog_path}images/zoom_outY2.png");
    $zoom_btn_img2[6] = Tkx::image_create_photo(-file => "${prog_path}images/zoom_full2.png");
    $zoom_btn_img2[7] = Tkx::image_create_photo(-file => "${prog_path}images/zoom_fullX2.png");
    $zoom_btn_img2[8] = Tkx::image_create_photo(-file => "${prog_path}images/zoom_fullY2.png");

    $frame = $zoom_tb->new_frame(
                -borderwidth => 2,
                -relief      => 'groove');
    $frame->g_pack(-anchor => 'nw', -expand => 1, -fill => 'x');
    $fr_btns = $frame->new_frame();
    $fr_btns->g_grid(-row => 0, -column => 0, -sticky => 'nw', -padx => 0, -pady => 0);
    ($zoom_btn[0] = $fr_btns->new_button(
                -repeatdelay    => 100000,
                -repeatinterval => 100000,
                -image          => $zoom_btn_img[0],
                -command        => sub { &forget_drawing('') if ($zoom_tip =~ /Select|Draw/);
                                         $zoom_tip = "Draw a zoom box on a TS graph...";
                                         $zoom_tb->configure(-cursor => $cursor_draw);
                                         $zoom_btn[0]->configure(-image => $zoom_btn_img2[0]);
                                         &prepare_to("zoom_in");
                                       },
                ))->g_pack(-side => 'left', -padx => 0, -pady => 1);
    ($zoom_btn[1] = $fr_btns->new_button(
                -repeatdelay    => 100000,
                -repeatinterval => 100000,
                -image          => $zoom_btn_img[1],
                -command        => sub { &forget_drawing('') if ($zoom_tip =~ /Select|Draw/);
                                         $zoom_tip = "Draw an X zoom bar on a TS graph...";
                                         $zoom_tb->configure(-cursor => $cursor_draw);
                                         $zoom_btn[1]->configure(-image => $zoom_btn_img2[1]);
                                         &prepare_to("zoom_in_X");
                                       },
                ))->g_pack(-side => 'left', -padx => 0, -pady => 1);
    ($zoom_btn[2] = $fr_btns->new_button(
                -repeatdelay    => 100000,
                -repeatinterval => 100000,
                -image          => $zoom_btn_img[2],
                -command        => sub { &forget_drawing('') if ($zoom_tip =~ /Select|Draw/);
                                         $zoom_tip = "Draw a Y zoom bar on a TS graph...";
                                         $zoom_tb->configure(-cursor => $cursor_draw);
                                         $zoom_btn[2]->configure(-image => $zoom_btn_img2[2]);
                                         &prepare_to("zoom_in_Y");
                                       },
                ))->g_pack(-side => 'left', -padx => 0, -pady => 1);
    ($zoom_btn[3] = $fr_btns->new_button(
                -repeatdelay    => 100000,
                -repeatinterval => 100000,
                -image          => $zoom_btn_img[3],
                -command        => sub { &forget_drawing('') if ($zoom_tip =~ /Select|Draw/);
                                         $zoom_tip = "Select a TS graph... (Zoom Out)";
                                         $zoom_tb->configure(-cursor => $cursor_hand);
                                         $zoom_btn[3]->configure(-image => $zoom_btn_img2[3]);
                                         &prepare_to("zoom_out");
                                       },
                ))->g_pack(-side => 'left', -padx => 0, -pady => 1);
    ($zoom_btn[4] = $fr_btns->new_button(
                -repeatdelay    => 100000,
                -repeatinterval => 100000,
                -image          => $zoom_btn_img[4],
                -command        => sub { &forget_drawing('') if ($zoom_tip =~ /Select|Draw/);
                                         $zoom_tip = "Select a TS graph... (Zoom Out X)";
                                         $zoom_tb->configure(-cursor => $cursor_hand);
                                         $zoom_btn[4]->configure(-image => $zoom_btn_img2[4]);
                                         &prepare_to("zoom_out_X");
                                       },
                ))->g_pack(-side => 'left', -padx => 0, -pady => 1);
    ($zoom_btn[5] = $fr_btns->new_button(
                -repeatdelay    => 100000,
                -repeatinterval => 100000,
                -image          => $zoom_btn_img[5],
                -command        => sub { &forget_drawing('') if ($zoom_tip =~ /Select|Draw/);
                                         $zoom_tip = "Select a TS graph... (Zoom Out Y)";
                                         $zoom_tb->configure(-cursor => $cursor_hand);
                                         $zoom_btn[5]->configure(-image => $zoom_btn_img2[5]);
                                         &prepare_to("zoom_out_Y");
                                       },
                ))->g_pack(-side => 'left', -padx => 0, -pady => 1);
    ($zoom_btn[6] = $fr_btns->new_button(
                -repeatdelay    => 100000,
                -repeatinterval => 100000,
                -image          => $zoom_btn_img[6],
                -command        => sub { &forget_drawing('') if ($zoom_tip =~ /Select|Draw/);
                                         $zoom_tip = "Select a TS graph... (Zoom Full Extent)";
                                         $zoom_tb->configure(-cursor => $cursor_hand);
                                         $zoom_btn[6]->configure(-image => $zoom_btn_img2[6]);
                                         &prepare_to("zoom_full");
                                       },
                ))->g_pack(-side => 'left', -padx => 0, -pady => 1);
    ($zoom_btn[7] = $fr_btns->new_button(
                -repeatdelay    => 100000,
                -repeatinterval => 100000,
                -image          => $zoom_btn_img[7],
                -command        => sub { &forget_drawing('') if ($zoom_tip =~ /Select|Draw/);
                                         $zoom_tip = "Select a TS graph... (Zoom X Full Extent)";
                                         $zoom_tb->configure(-cursor => $cursor_hand);
                                         $zoom_btn[7]->configure(-image => $zoom_btn_img2[7]);
                                         &prepare_to("zoom_full_X");
                                       },
                ))->g_pack(-side => 'left', -padx => 0, -pady => 1);
    ($zoom_btn[8] = $fr_btns->new_button(
                -repeatdelay    => 100000,
                -repeatinterval => 100000,
                -image          => $zoom_btn_img[8],
                -command        => sub { &forget_drawing('') if ($zoom_tip =~ /Select|Draw/);
                                         $zoom_tip = "Select a TS graph... (Zoom Y Full Extent)";
                                         $zoom_tb->configure(-cursor => $cursor_hand);
                                         $zoom_btn[8]->configure(-image => $zoom_btn_img2[8]);
                                         &prepare_to("zoom_full_Y");
                                       },
                ))->g_pack(-side => 'left', -padx => 0, -pady => 1);

    $fr_msgs = $frame->new_frame();
    $fr_msgs->g_grid(-row => 1, -column => 0, -sticky => 'nsew', -padx => 0, -pady => 0);
    $fr_msgs->new_label(
                -textvariable => \$zoom_tip,
                -justify      => 'left',
                -font         => 'default',
                )->g_pack(-side => 'left', -padx => 1, -pady => 1);

#   Bindings for mouse focus
    $zoom_btn[0]->g_bind("<Enter>", sub { $zoom_tip = "Zoom In"
                                                      if ($zoom_tip !~ /(Select|Draw)/); });
    $zoom_btn[1]->g_bind("<Enter>", sub { $zoom_tip = "Zoom In, X only"
                                                      if ($zoom_tip !~ /(Select|Draw)/); });
    $zoom_btn[2]->g_bind("<Enter>", sub { $zoom_tip = "Zoom In, Y only"
                                                      if ($zoom_tip !~ /(Select|Draw)/); });
    $zoom_btn[3]->g_bind("<Enter>", sub { $zoom_tip = "Zoom Out"
                                                      if ($zoom_tip !~ /(Select|Draw)/); });
    $zoom_btn[4]->g_bind("<Enter>", sub { $zoom_tip = "Zoom Out, X only"
                                                      if ($zoom_tip !~ /(Select|Draw)/); });
    $zoom_btn[5]->g_bind("<Enter>", sub { $zoom_tip = "Zoom Out, Y only"
                                                      if ($zoom_tip !~ /(Select|Draw)/); });
    $zoom_btn[6]->g_bind("<Enter>", sub { $zoom_tip = "Zoom to Full Extent"
                                                      if ($zoom_tip !~ /(Select|Draw)/); });
    $zoom_btn[7]->g_bind("<Enter>", sub { $zoom_tip = "Zoom to X Full Extent"
                                                      if ($zoom_tip !~ /(Select|Draw)/); });
    $zoom_btn[8]->g_bind("<Enter>", sub { $zoom_tip = "Zoom to Y Full Extent"
                                                      if ($zoom_tip !~ /(Select|Draw)/); });
    for ($i=0; $i<=8; $i++) {
        $zoom_btn[$i]->g_bind("<Leave>", sub { $zoom_tip = "" if ($zoom_tip =~ /^Zoom/); });
    }

#   Bindings for keyboard focus
    $zoom_btn[0]->g_bind("<FocusIn>", sub { $zoom_btn[0]->configure(-default => 'active');
                                            $zoom_tip = "Zoom In"
                                                        if ($zoom_tip !~ /(Select|Draw)/); });
    $zoom_btn[1]->g_bind("<FocusIn>", sub { $zoom_btn[1]->configure(-default => 'active');
                                            $zoom_tip = "Zoom In, X only"
                                                        if ($zoom_tip !~ /(Select|Draw)/); });
    $zoom_btn[2]->g_bind("<FocusIn>", sub { $zoom_btn[2]->configure(-default => 'active');
                                            $zoom_tip = "Zoom In, Y only"
                                                        if ($zoom_tip !~ /(Select|Draw)/); });
    $zoom_btn[3]->g_bind("<FocusIn>", sub { $zoom_btn[3]->configure(-default => 'active');
                                            $zoom_tip = "Zoom Out"
                                                        if ($zoom_tip !~ /(Select|Draw)/); });
    $zoom_btn[4]->g_bind("<FocusIn>", sub { $zoom_btn[4]->configure(-default => 'active');
                                            $zoom_tip = "Zoom Out, X only"
                                                        if ($zoom_tip !~ /(Select|Draw)/); });
    $zoom_btn[5]->g_bind("<FocusIn>", sub { $zoom_btn[5]->configure(-default => 'active');
                                            $zoom_tip = "Zoom Out, Y only"
                                                        if ($zoom_tip !~ /(Selec|Drawt)/); });
    $zoom_btn[6]->g_bind("<FocusIn>", sub { $zoom_btn[6]->configure(-default => 'active');
                                            $zoom_tip = "Zoom to Full Extent"
                                                        if ($zoom_tip !~ /(Sele|Drawct)/); });
    $zoom_btn[7]->g_bind("<FocusIn>", sub { $zoom_btn[7]->configure(-default => 'active');
                                            $zoom_tip = "Zoom to X Full Extent"
                                                        if ($zoom_tip !~ /(Sele|Drawct)/); });
    $zoom_btn[8]->g_bind("<FocusIn>", sub { $zoom_btn[8]->configure(-default => 'active');
                                            $zoom_tip = "Zoom to Y Full Extent"
                                                        if ($zoom_tip !~ /(Sele|Drawct)/); });
    for ($i=0; $i<=8; $i++) {
        $zoom_btn[$i]->g_bind("<FocusOut>", sub { $zoom_btn[$i]->configure(-default => 'normal'); });
    }

#   Bindings to restore button shape after keyboard input is sustained
    for ($i=0; $i<=8; $i++) {
        $zoom_btn[$i]->g_bind("<KeyPress>", [\&restore_btn, Tkx::Ev("%k"), $zoom_btn[$i] ]);
    }

    Tkx::wm_resizable($zoom_tb,0,0);
    &adjust_window_position($zoom_tb);
    $zoom_tb->g_focus;
}


sub begin_zoom_box {
    my ($x, $y, $canv, $id, $action) = @_;
    my (
        $x1, $x2, $y1, $y2, $zbox, $zxbar, $zybar,
       );

    $canv->delete("zoom_box");
    $canv->delete("zoom_bar");

    $zbox = $zxbar = $zybar = "";

    ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
    ($x, $y) = &get_xy($canv, $x, $y, 0);
    $x = $x1 if ($x < $x1);
    $x = $x2 if ($x > $x2);
    $y = $y1 if ($y < $y1);
    $y = $y2 if ($y > $y2);
    if ($action eq "zoom_in") {
        $zbox = $canv->create_rectangle($x, $y, $x, $y,
                       -outline => &get_rgb_code("blue"),
                       -width   => 1,
                       -fill    => "",
                       -tags    => "zoom_box");
    }
    if ($action =~ /^(zoom_in|zoom_in_X)$/) {
        $zxbar = $canv->create_rectangle($x, $y2, $x, $y2+4,
                        -outline => "",
                        -width   => 0,
                        -fill    => &get_rgb_code("blue"),
                        -tags    => "zoom_bar");
    }
    if ($action =~ /^(zoom_in|zoom_in_Y)$/) {
        $zybar = $canv->create_rectangle($x1-4, $y, $x1, $y,
                        -outline => "",
                        -width   => 0,
                        -fill    => &get_rgb_code("blue"),
                        -tags    => "zoom_bar");
    }
    $canv->g_bind("<Motion>",          [ \&draw_zoom_box, Tkx::Ev("%x","%y"), $canv, $id, $action,
                                                          $zbox, $zxbar, $zybar, $x, $y ]);
    $canv->g_bind("<ButtonRelease-1>", [ \&end_zoom_box,  Tkx::Ev("%x","%y"), $canv, $id, $action, $x, $y ]);
}


sub draw_zoom_box {
    my ($x, $y, $canv, $id, $action, $zbox, $zxbar, $zybar, $xo, $yo) = @_;
    my (
        $x1, $x2, $xloc1, $xloc2, $xmax, $xmin, $xtype, $y1, $y2, $yloc1,
        $yloc2, $ymax, $ymin,
       );

    ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
    $xmin  = $gr_props{$id}{xmin};
    $xmax  = $gr_props{$id}{xmax};
    $ymin  = $gr_props{$id}{ymin};
    $ymax  = $gr_props{$id}{ymax};
    $xtype = $gr_props{$id}{xtype};

    ($x, $y) = &get_xy($canv, $x, $y, 0);
    $x = $x1 if ($x < $x1);
    $x = $x2 if ($x > $x2);
    $y = $y1 if ($y < $y1);
    $y = $y2 if ($y > $y2);

    if ($action eq "zoom_in") {
        $canv->coords($zbox, $xo, $yo, $x, $y);
    }
    if ($action =~ /^(zoom_in|zoom_in_X)$/) {
        $canv->coords($zxbar, $xo, $y2, $x, $y2+4);
        if ($xtype eq "Date/Time") {
            $xmin  = &datelabel2jdate($xmin);
            $xmax  = &datelabel2jdate($xmax);
            $xloc1 = $xmin + ($xmax -$xmin) *(&min($xo, $x) -$x1) /($x2 -$x1);
            $xloc2 = $xmin + ($xmax -$xmin) *(&max($xo, $x) -$x1) /($x2 -$x1);
            $xloc1 = &jdate2datelabel($xloc1, "Mon-DD-YYYY");
            $xloc2 = &jdate2datelabel($xloc2, "Mon-DD-YYYY");
        } else {
            $xloc1 = $xmin + ($xmax -$xmin) *(&min($xo, $x) -$x1) /($x2 -$x1);
            $xloc2 = $xmin + ($xmax -$xmin) *(&max($xo, $x) -$x1) /($x2 -$x1);
        }
    }
    if ($action =~ /^(zoom_in|zoom_in_Y)$/) {
        $canv->coords($zybar, $x1-4, $yo, $x1, $y);
        $yloc1 = $ymin + ($ymax -$ymin) *($y2 - &max($yo, $y)) /($y2 -$y1);
        $yloc2 = $ymin + ($ymax -$ymin) *($y2 - &min($yo, $y)) /($y2 -$y1);
    }
    if ($action eq "zoom_in_X") {
        if ($xtype eq "Date/Time") {
            $status_line = sprintf("Zoom X: %s to %s", $xloc1, $xloc2);
        } else {
            $status_line = sprintf("Zoom X: %.2f to %.2f", $xloc1, $xloc2);
        }
    } elsif ($action eq "zoom_in_Y") {
        $status_line = sprintf("Zoom Y: %.2f to %.2f", $yloc1, $yloc2);
    } else {
        if ($xtype eq "Date/Time") {
            $status_line = sprintf("Zoom X,Y: %s to %s, %.2f to %.2f", $xloc1, $xloc2, $yloc1, $yloc2);
        } else {
            $status_line = sprintf("Zoom X,Y: %.2f to %.2f, %.2f to %.2f", $xloc1, $xloc2, $yloc1, $yloc2);
        }
    }
}


sub end_zoom_box {
    my ($x, $y, $canv, $id, $action, $xo, $yo) = @_;
    my (
        $x1, $x2, $xloc1, $xloc2, $xmax, $xmin, $xtype, $y1, $y2, $yloc1,
        $yloc2, $ymax, $ymin,
       );

    ($x1, $y1, $x2, $y2) = @{ $props{$id}{coordlist} };
    $xmin  = $gr_props{$id}{xmin};
    $xmax  = $gr_props{$id}{xmax};
    $ymin  = $gr_props{$id}{ymin};
    $ymax  = $gr_props{$id}{ymax};
    $xtype = $gr_props{$id}{xtype};

    ($x, $y) = &get_xy($canv, $x, $y, 0);
    $x = $x1 if ($x < $x1);
    $x = $x2 if ($x > $x2);
    $y = $y1 if ($y < $y1);
    $y = $y2 if ($y > $y2);

    if ($action eq "zoom_in" && ($x == $xo || $y == $yo)) {
        $canv->delete("zoom_box");
        &prepare_to("zoom_in");
        return;
    } elsif ($action eq "zoom_in_X" && $x == $xo) {
        &prepare_to("zoom_in_X");
        return;
    } elsif ($action eq "zoom_in_Y" && $y == $yo) {
        &prepare_to("zoom_in_Y");
        return;
    }
    if ($action =~ /^(zoom_in|zoom_in_X)$/) {
        if ($xtype eq "Date/Time") {
            $xmin  = &datelabel2jdate($xmin);
            $xmax  = &datelabel2jdate($xmax);
            $xloc1 = $xmin + ($xmax -$xmin) *(&min($xo, $x) -$x1) /($x2 -$x1);
            $xloc2 = $xmin + ($xmax -$xmin) *(&max($xo, $x) -$x1) /($x2 -$x1);
            $xloc1 = &jdate2datelabel($xloc1, "Mon-DD-YYYY");
            $xloc2 = &jdate2datelabel($xloc2, "Mon-DD-YYYY");
        } else {
            $xloc1 = $xmin + ($xmax -$xmin) *(&min($xo, $x) -$x1) /($x2 -$x1);
            $xloc2 = $xmin + ($xmax -$xmin) *(&max($xo, $x) -$x1) /($x2 -$x1);
        }
    }
    if ($action =~ /^(zoom_in|zoom_in_Y)$/) {
        $yloc1 = $ymin + ($ymax -$ymin) *($y2 - &max($yo, $y)) /($y2 -$y1);
        $yloc2 = $ymin + ($ymax -$ymin) *($y2 - &min($yo, $y)) /($y2 -$y1);
    }

    $canv->delete("zoom_box");
    $canv->delete("zoom_bar");

    if ($action eq "zoom_in") {
        &zoom_in($canv, $id, $xloc1, $xloc2, $yloc1, $yloc2);
    } elsif ($action eq "zoom_in_X") {
        &zoom_in_X($canv, $id, $xloc1, $xloc2);
    } elsif ($action eq "zoom_in_Y") {
        &zoom_in_Y($canv, $id, $yloc1, $yloc2);
    }
}


sub zoom_in {
    my ($canv, $id, $xmin, $xmax, $ymin, $ymax) = @_;
    my (
        $base_jd, $geom, $jd1, $jd2, $tabid, $X, $Y, $ymajor,
       );

    &end_select($canv, $id, 1);
    &reset_bindings;

#   Set the X axis limits and adjust the axis format or major tick spacing, if needed
    $gr_props{$id}{xmin} = $xmin;
    $gr_props{$id}{xmax} = $xmax;
    if ($gr_props{$id}{xtype} eq "Date/Time") {
        $jd1 = &datelabel2jdate($xmin);
        $jd2 = &datelabel2jdate($xmax);
        if ($xmin eq $xmax) {
            $jd2++;
            $gr_props{$id}{xmax} = &jdate2datelabel($jd2, "Mon-DD-YYYY");
        }
        if ($gr_props{$id}{datefmt} eq "Year" && $jd2 -$jd1 <= 365 *2) {
            $gr_props{$id}{datefmt} = "Month";
        } elsif ($gr_props{$id}{datefmt} eq "Month" && $jd2 -$jd1 >= 365 *5) {
            $gr_props{$id}{datefmt} = "Year";
        } elsif ($gr_props{$id}{datefmt} =~ /Mon-DD/) {
            if ($gr_props{$id}{xmajor} ne "auto" && ($jd2 -$jd1) /$gr_props{$id}{xmajor} < 5) {
                $gr_props{$id}{xmajor} = &max(1, int((($jd2 -$jd1) /30. +2.51)/5.) *5.);
                if (($jd2 -$jd1) /$gr_props{$id}{xmajor} < 5 && $gr_props{$id}{xmajor} != 1) {
                    $gr_props{$id}{xmajor} = &max(1, int((($jd2 -$jd1) /30. +2.51)/5.));
                }
            }
        }
    } else {
        if ($xmin == $xmax) {
            $xmin = $gr_props{$id}{xmin} = $xmin -0.5;
            $xmax = $gr_props{$id}{xmax} = $xmax +0.5;
        }
        $base_jd = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
        $jd1     = $xmin +$base_jd -1;
        $jd2     = $xmax +$base_jd -1;
        if ($gr_props{$id}{xmajor} ne "auto" && ($jd2 -$jd1) /$gr_props{$id}{xmajor} < 5) {
            $gr_props{$id}{xmajor} = &max(1, int((($jd2 -$jd1) /30. +2.51)/5.) *5.);
            if (($jd2 -$jd1) /$gr_props{$id}{xmajor} < 5 && $gr_props{$id}{xmajor} != 1) {
                $gr_props{$id}{xmajor} = &max(1, int((($jd2 -$jd1) /30. +2.51)/5.));
            }
        }
    }

#   Set the Y axis limits and major spacing
    ($ymin, $ymax, $ymajor) = &find_axis_limits($ymin, $ymax);
    $gr_props{$id}{ymin}    = $ymin;
    $gr_props{$id}{ymax}    = $ymax;
    $gr_props{$id}{ymajor}  = $ymajor;

#   Redraw the graph
    $gr_props{$id}{redraw} = 1;
    &make_ts_graph($canv, $id, 1);

#   Refresh the Graph Properties menu, if present
    if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
        if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
            $tabid = $grprops_notebook->index('current');
            $geom  = $graph_props_menu->g_wm_geometry();
            (undef, $X, $Y) = split(/\+/, $geom);
            &edit_graph_props($id, $X, $Y, $tabid);
        }
    }
}


sub zoom_in_X {
    my ($canv, $id, $xmin, $xmax) = @_;
    my (
        $base_jd, $geom, $jd1, $jd2, $tabid, $X, $Y,
       );

    &end_select($canv, $id, 1);
    &reset_bindings;

#   Set the X axis limits and adjust the axis format or major tick spacing, if needed
    $gr_props{$id}{xmin} = $xmin;
    $gr_props{$id}{xmax} = $xmax;
    if ($gr_props{$id}{xtype} eq "Date/Time") {
        $jd1 = &datelabel2jdate($xmin);
        $jd2 = &datelabel2jdate($xmax);
        if ($xmin eq $xmax) {
            $jd2++;
            $gr_props{$id}{xmax} = &jdate2datelabel($jd2, "Mon-DD-YYYY");
        }
        if ($gr_props{$id}{datefmt} eq "Year" && $jd2 -$jd1 <= 365 *2) {
            $gr_props{$id}{datefmt} = "Month";
        } elsif ($gr_props{$id}{datefmt} eq "Month" && $jd2 -$jd1 >= 365 *5) {
            $gr_props{$id}{datefmt} = "Year";
        } elsif ($gr_props{$id}{datefmt} =~ /Mon-DD/) {
            if ($gr_props{$id}{xmajor} ne "auto" && ($jd2 -$jd1) /$gr_props{$id}{xmajor} < 5) {
                $gr_props{$id}{xmajor} = &max(1, int((($jd2 -$jd1) /30. +2.51)/5.) *5.);
                if (($jd2 -$jd1) /$gr_props{$id}{xmajor} < 5 && $gr_props{$id}{xmajor} != 1) {
                    $gr_props{$id}{xmajor} = &max(1, int((($jd2 -$jd1) /30. +2.51)/5.));
                }
            }
        }
    } else {
        if ($xmin == $xmax) {
            $xmin = $gr_props{$id}{xmin} = $xmin -0.5;
            $xmax = $gr_props{$id}{xmax} = $xmax +0.5;
        }
        $base_jd = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
        $jd1     = $xmin +$base_jd -1;
        $jd2     = $xmax +$base_jd -1;
        if ($gr_props{$id}{xmajor} ne "auto" && ($jd2 -$jd1) /$gr_props{$id}{xmajor} < 5) {
            $gr_props{$id}{xmajor} = &max(1, int((($jd2 -$jd1) /30. +2.51)/5.) *5.);
            if (($jd2 -$jd1) /$gr_props{$id}{xmajor} < 5 && $gr_props{$id}{xmajor} != 1) {
                $gr_props{$id}{xmajor} = &max(1, int((($jd2 -$jd1) /30. +2.51)/5.));
            }
        }
    }

#   Redraw the graph
    $gr_props{$id}{redraw} = 1;
    &make_ts_graph($canv, $id, 1);

#   Refresh the Graph Properties menu, if present
    if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
        if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
            $tabid = $grprops_notebook->index('current');
            $geom  = $graph_props_menu->g_wm_geometry();
            (undef, $X, $Y) = split(/\+/, $geom);
            &edit_graph_props($id, $X, $Y, $tabid);
        }
    }
}


sub zoom_in_Y {
    my ($canv, $id, $ymin, $ymax) = @_;
    my (
        $geom, $tabid, $X, $Y, $ymajor,
       );

    &end_select($canv, $id, 1);
    &reset_bindings;

#   Set the Y axis limits and major spacing, and redraw the graph
    ($ymin, $ymax, $ymajor) = &find_axis_limits($ymin, $ymax);
    $gr_props{$id}{ymin}    = $ymin;
    $gr_props{$id}{ymax}    = $ymax;
    $gr_props{$id}{ymajor}  = $ymajor;
    $gr_props{$id}{redraw}  = 1;
    &make_ts_graph($canv, $id, 1);

#   Refresh the Graph Properties menu, if present
    if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
        if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
            $tabid = $grprops_notebook->index('current');
            $geom  = $graph_props_menu->g_wm_geometry();
            (undef, $X, $Y) = split(/\+/, $geom);
            &edit_graph_props($id, $X, $Y, $tabid);
        }
    }
}


sub zoom_out {
    my ($canv, $id) = @_;
    my (
        $base_jd, $datemax, $datemin, $dtmax, $dtmin, $geom, $jd_expand,
        $jd1, $jd2, $jdmax, $jdmin, $tabid, $target_range, $X, $Y, $ymajor,
        $ymax, $ymin,
       );

    &end_select($canv, $id, 1);
    &reset_bindings;

#   Get date limits for visible datasets
    ($dtmin, $dtmax, undef, undef) = &find_ts_limits($id, 1);
    return if ($dtmin == -999);
    $dtmax = &adjust_dt_by_day($dtmax, 1);

#   Expand date range by 50 percent, ideally 25 percent on each side
    if ($gr_props{$id}{xtype} eq "Date/Time") {
        $datemin = &datelabel2date($gr_props{$id}{xmin});
        $datemax = &datelabel2date($gr_props{$id}{xmax});
    } else {
        $base_jd = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
        $datemin = substr(&jdate2date($gr_props{$id}{xmin} +$base_jd -1), 0,8);
        $datemax = substr(&jdate2date($gr_props{$id}{xmax} +$base_jd -1), 0,8);
    }
    ($jdmin, $jdmax, $jd1, $jd2) = &dates2jdates($dtmin, $dtmax, $datemin, $datemax);
    $jd_expand    = &max(1, &round_to_int(($jd2 -$jd1) *0.25));
    $target_range = ($jd2 -$jd1) +$jd_expand *2;
    $jd1 = &max($jdmin, $jd1 -$jd_expand);
    $jd2 = &min($jdmax, $jd2 +$jd_expand);
    if ($jd1 == $jdmin) {
        $jd2 = &min($jdmax, $jd1 +$target_range);
    } elsif ($jd2 == $jdmax) {
        $jd1 = &max($jdmin, $jd2 -$target_range);
    }
    if ($gr_props{$id}{xtype} eq "Date/Time") {
        $gr_props{$id}{xmin} = &jdate2datelabel($jd1, "Mon-DD-YYYY");
        $gr_props{$id}{xmax} = &jdate2datelabel($jd2, "Mon-DD-YYYY");
        if ($gr_props{$id}{datefmt} eq "Year" && $jd2 -$jd1 <= 365 *2) {
            $gr_props{$id}{datefmt} = "Month";
        } elsif ($gr_props{$id}{datefmt} eq "Month" && $jd2 -$jd1 >= 365 *5) {
            $gr_props{$id}{datefmt} = "Year";
        } elsif ($gr_props{$id}{datefmt} =~ /Mon-DD/) {
            if ($gr_props{$id}{xmajor} ne "auto" && ($jd2 -$jd1) /$gr_props{$id}{xmajor} > 30) {
                $gr_props{$id}{xmajor} = &max(1, int((($jd2 -$jd1) /30. +2.51)/5.) *5.);
            }
        }
    } else {
        $gr_props{$id}{xmin} = $jd1 -$base_jd +1;
        $gr_props{$id}{xmax} = $jd2 -$base_jd +1;
        if ($gr_props{$id}{xmajor} ne "auto" && ($jd2 -$jd1) /$gr_props{$id}{xmajor} > 30) {
            $gr_props{$id}{xmajor} = &max(1, int((($jd2 -$jd1) /30. +2.51)/5.) *5.);
        }
    }

#   Expand the Y axis range by roughly 1 major tick division in both directions
    $ymin   = $gr_props{$id}{ymin};
    $ymax   = $gr_props{$id}{ymax};
    $ymajor = $gr_props{$id}{ymajor};
    if ($ymajor eq "auto") {
        ($ymin, $ymax, $ymajor) = &find_axis_limits($ymin, $ymax);
    }
    if ($ymin > 0) {
        $ymin = &max(0, $ymin -$ymajor);
    } elsif ($ymin < 0) {
        $ymin -= $ymajor;
    } else {
        $ymax += $ymajor;
    }
    $ymax += $ymajor *0.9;
    ($ymin, $ymax, $ymajor) = &find_axis_limits($ymin, $ymax);
    $gr_props{$id}{ymin}   = $ymin;
    $gr_props{$id}{ymax}   = $ymax;
    $gr_props{$id}{ymajor} = $ymajor;

#   Redraw the graph
    $gr_props{$id}{redraw} = 1;
    &make_ts_graph($canv, $id, 1);

#   Refresh the Graph Properties menu, if present
    if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
        if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
            $tabid = $grprops_notebook->index('current');
            $geom  = $graph_props_menu->g_wm_geometry();
            (undef, $X, $Y) = split(/\+/, $geom);
            &edit_graph_props($id, $X, $Y, $tabid);
        }
    }
}


sub zoom_out_X {
    my ($canv, $id) = @_;
    my (
        $base_jd, $datemax, $datemin, $dtmax, $dtmin, $geom, $jd_expand,
        $jd1, $jd2, $jdmax, $jdmin, $tabid, $target_range, $X, $Y,
       );

    &end_select($canv, $id, 1);
    &reset_bindings;

#   Get date limits for visible datasets
    ($dtmin, $dtmax, undef, undef) = &find_ts_limits($id, 1);
    return if ($dtmin == -999);
    $dtmax = &adjust_dt_by_day($dtmax, 1);

#   Expand date range by 50 percent, ideally 25 percent on each side
    if ($gr_props{$id}{xtype} eq "Date/Time") {
        $datemin = &datelabel2date($gr_props{$id}{xmin});
        $datemax = &datelabel2date($gr_props{$id}{xmax});
    } else {
        $base_jd = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
        $datemin = substr(&jdate2date($gr_props{$id}{xmin} +$base_jd -1), 0,8);
        $datemax = substr(&jdate2date($gr_props{$id}{xmax} +$base_jd -1), 0,8);
    }
    return if ($dtmin == $datemin && $dtmax == $datemax);
    ($jdmin, $jdmax, $jd1, $jd2) = &dates2jdates($dtmin, $dtmax, $datemin, $datemax);
    $jd_expand    = &max(1, &round_to_int(($jd2 -$jd1) *0.25));
    $target_range = ($jd2 -$jd1) +$jd_expand *2;
    $jd1 = &max($jdmin, $jd1 -$jd_expand);
    $jd2 = &min($jdmax, $jd2 +$jd_expand);
    if ($jd1 == $jdmin) {
        $jd2 = &min($jdmax, $jd1 +$target_range);
    } elsif ($jd2 == $jdmax) {
        $jd1 = &max($jdmin, $jd2 -$target_range);
    }
    if ($gr_props{$id}{xtype} eq "Date/Time") {
        $gr_props{$id}{xmin} = &jdate2datelabel($jd1, "Mon-DD-YYYY");
        $gr_props{$id}{xmax} = &jdate2datelabel($jd2, "Mon-DD-YYYY");
        if ($gr_props{$id}{datefmt} eq "Year" && $jd2 -$jd1 <= 365 *2) {
            $gr_props{$id}{datefmt} = "Month";
        } elsif ($gr_props{$id}{datefmt} eq "Month" && $jd2 -$jd1 >= 365 *5) {
            $gr_props{$id}{datefmt} = "Year";
        } elsif ($gr_props{$id}{datefmt} =~ /Mon-DD/) {
            if ($gr_props{$id}{xmajor} ne "auto" && ($jd2 -$jd1) /$gr_props{$id}{xmajor} > 30) {
                $gr_props{$id}{xmajor} = &max(1, int((($jd2 -$jd1) /30. +2.51)/5.) *5.);
            }
        }
    } else {
        $gr_props{$id}{xmin} = $jd1 -$base_jd +1;
        $gr_props{$id}{xmax} = $jd2 -$base_jd +1;
        if ($gr_props{$id}{xmajor} ne "auto" && ($jd2 -$jd1) /$gr_props{$id}{xmajor} > 30) {
            $gr_props{$id}{xmajor} = &max(1, int((($jd2 -$jd1) /30. +2.51)/5.) *5.);
        }
    }
    $gr_props{$id}{redraw} = 1;
    &make_ts_graph($canv, $id, 1);

#   Refresh the Graph Properties menu, if present
    if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
        if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
            $tabid = $grprops_notebook->index('current');
            $geom  = $graph_props_menu->g_wm_geometry();
            (undef, $X, $Y) = split(/\+/, $geom);
            &edit_graph_props($id, $X, $Y, $tabid);
        }
    }
}


sub zoom_out_Y {
    my ($canv, $id) = @_;
    my (
        $geom, $tabid, $X, $Y, $ymajor, $ymax, $ymin,
       );

    &end_select($canv, $id, 1);
    &reset_bindings;

#   Expand the Y axis range by roughly 1 major tick division in both directions
    $ymin   = $gr_props{$id}{ymin};
    $ymax   = $gr_props{$id}{ymax};
    $ymajor = $gr_props{$id}{ymajor};
    if ($ymajor eq "auto") {
        ($ymin, $ymax, $ymajor) = &find_axis_limits($ymin, $ymax);
    }
    if ($ymin > 0) {
        $ymin = &max(0, $ymin -$ymajor);
    } elsif ($ymin < 0) {
        $ymin -= $ymajor;
    } else {
        $ymax += $ymajor;
    }
    $ymax += $ymajor *0.9;
    ($ymin, $ymax, $ymajor) = &find_axis_limits($ymin, $ymax);

    $gr_props{$id}{ymin}   = $ymin;
    $gr_props{$id}{ymax}   = $ymax;
    $gr_props{$id}{ymajor} = $ymajor;
    $gr_props{$id}{redraw} = 1;
    &make_ts_graph($canv, $id, 1);

#   Refresh the Graph Properties menu, if present
    if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
        if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
            $tabid = $grprops_notebook->index('current');
            $geom  = $graph_props_menu->g_wm_geometry();
            (undef, $X, $Y) = split(/\+/, $geom);
            &edit_graph_props($id, $X, $Y, $tabid);
        }
    }
}


sub zoom_full {
    my ($canv, $id) = @_;
    my (
        $base_jd, $datemax, $datemin, $dtmax, $dtmin, $geom, $jd1, $jd2,
        $pmax, $pmin, $tabid, $X, $Y, $ymajor, $ymax, $ymin,
       );

    &end_select($canv, $id, 1);
    &reset_bindings;

    ($dtmin, $dtmax, $pmin, $pmax) = &find_ts_limits($id, 1);
    return if ($dtmin == -999);
    $dtmax = &adjust_dt_by_day($dtmax, 1);
    if ($gr_props{$id}{xtype} eq "Date/Time") {
        $datemin = &datelabel2date($gr_props{$id}{xmin});
        $datemax = &datelabel2date($gr_props{$id}{xmax});
    } else {
        $base_jd = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
        $datemin = substr(&jdate2date($gr_props{$id}{xmin} +$base_jd -1), 0,8);
        $datemax = substr(&jdate2date($gr_props{$id}{xmax} +$base_jd -1), 0,8);
    }

    $ymin   = $gr_props{$id}{ymin};
    $ymax   = $gr_props{$id}{ymax};
    $ymajor = $gr_props{$id}{ymajor};
    if ($ymin > $pmin || $ymax < $pmax || $ymax -$ymin > ($pmax -$pmin) *1.15) {
        ($ymin, $ymax, $ymajor) = &find_axis_limits($pmin, $pmax);
    }
    return if ($dtmin == $datemin && $dtmax == $datemax
               && $ymin == $gr_props{$id}{ymin} && $ymax == $gr_props{$id}{ymax});

    if ($gr_props{$id}{xtype} eq "Date/Time") {
        $gr_props{$id}{xmin} = &date2datelabel($dtmin, "Mon-DD-YYYY");
        $gr_props{$id}{xmax} = &date2datelabel($dtmax, "Mon-DD-YYYY");
        ($jd1, $jd2) = &dates2jdates($dtmin, $dtmax);
        if ($gr_props{$id}{datefmt} eq "Year" && $jd2 -$jd1 <= 365 *2) {
            $gr_props{$id}{datefmt} = "Month";
        } elsif ($gr_props{$id}{datefmt} eq "Month" && $jd2 -$jd1 >= 365 *5) {
            $gr_props{$id}{datefmt} = "Year";
        } elsif ($gr_props{$id}{datefmt} =~ /Mon-DD/) {
            if ($gr_props{$id}{xmajor} ne "auto" && ($jd2 -$jd1) /$gr_props{$id}{xmajor} > 30) {
                $gr_props{$id}{xmajor} = &max(1, int((($jd2 -$jd1) /30. +2.51)/5.) *5.);
            }
        }
    } else {
        ($jd1, $jd2) = &dates2jdates($dtmin, $dtmax);
        $gr_props{$id}{xmin} = $jd1 -$base_jd +1;
        $gr_props{$id}{xmax} = $jd2 -$base_jd +1;
        if ($gr_props{$id}{xmajor} ne "auto" && ($jd2 -$jd1) /$gr_props{$id}{xmajor} > 30) {
            $gr_props{$id}{xmajor} = &max(1, int((($jd2 -$jd1) /30. +2.51)/5.) *5.);
        }
    }
    $gr_props{$id}{ymin}   = $ymin;
    $gr_props{$id}{ymax}   = $ymax;
    $gr_props{$id}{ymajor} = $ymajor;
    $gr_props{$id}{redraw} = 1;
    &make_ts_graph($canv, $id, 1);

#   Refresh the Graph Properties menu, if present
    if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
        if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
            $tabid = $grprops_notebook->index('current');
            $geom  = $graph_props_menu->g_wm_geometry();
            (undef, $X, $Y) = split(/\+/, $geom);
            &edit_graph_props($id, $X, $Y, $tabid);
        }
    }
}


sub zoom_full_X {
    my ($canv, $id) = @_;
    my (
        $base_jd, $datemax, $datemin, $dtmax, $dtmin, $geom, $jd1, $jd2,
        $tabid, $X, $Y,
       );

    &end_select($canv, $id, 1);
    &reset_bindings;

    ($dtmin, $dtmax, undef, undef) = &find_ts_limits($id, 1);
    return if ($dtmin == -999);
    $dtmax = &adjust_dt_by_day($dtmax, 1);
    if ($gr_props{$id}{xtype} eq "Date/Time") {
        $datemin = &datelabel2date($gr_props{$id}{xmin});
        $datemax = &datelabel2date($gr_props{$id}{xmax});
    } else {
        $base_jd = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
        $datemin = substr(&jdate2date($gr_props{$id}{xmin} +$base_jd -1), 0,8);
        $datemax = substr(&jdate2date($gr_props{$id}{xmax} +$base_jd -1), 0,8);
    }
    return if ($dtmin == $datemin && $dtmax == $datemax);

    if ($gr_props{$id}{xtype} eq "Date/Time") {
        $gr_props{$id}{xmin} = &date2datelabel($dtmin, "Mon-DD-YYYY");
        $gr_props{$id}{xmax} = &date2datelabel($dtmax, "Mon-DD-YYYY");
        ($jd1, $jd2) = &dates2jdates($dtmin, $dtmax);
        if ($gr_props{$id}{datefmt} eq "Year" && $jd2 -$jd1 <= 365 *2) {
            $gr_props{$id}{datefmt} = "Month";
        } elsif ($gr_props{$id}{datefmt} eq "Month" && $jd2 -$jd1 >= 365 *5) {
            $gr_props{$id}{datefmt} = "Year";
        } elsif ($gr_props{$id}{datefmt} =~ /Mon-DD/) {
            if ($gr_props{$id}{xmajor} ne "auto" && ($jd2 -$jd1) /$gr_props{$id}{xmajor} > 30) {
                $gr_props{$id}{xmajor} = &max(1, int((($jd2 -$jd1) /30. +2.51)/5.) *5.);
            }
        }
    } else {
        ($jd1, $jd2) = &dates2jdates($dtmin, $dtmax);
        $gr_props{$id}{xmin} = $jd1 -$base_jd +1;
        $gr_props{$id}{xmax} = $jd2 -$base_jd +1;
        if ($gr_props{$id}{xmajor} ne "auto" && ($jd2 -$jd1) /$gr_props{$id}{xmajor} > 30) {
            $gr_props{$id}{xmajor} = &max(1, int((($jd2 -$jd1) /30. +2.51)/5.) *5.);
        }
    }
    $gr_props{$id}{redraw} = 1;
    &make_ts_graph($canv, $id, 1);

#   Refresh the Graph Properties menu, if present
    if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
        if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
            $tabid = $grprops_notebook->index('current');
            $geom  = $graph_props_menu->g_wm_geometry();
            (undef, $X, $Y) = split(/\+/, $geom);
            &edit_graph_props($id, $X, $Y, $tabid);
        }
    }
}


sub zoom_full_Y {
    my ($canv, $id) = @_;
    my (
        $base_jd, $dtmax, $dtmin, $geom, $pmax, $pmin, $tabid, $X, $Y,
        $ymajor, $ymax, $ymin,
       );

    &end_select($canv, $id, 1);
    &reset_bindings;

#   Restrict the search to the dates included in the visible graph
#   dtmin and dtmax will be in YYYYMMDDHHmm format
    if ($gr_props{$id}{xtype} eq "Date/Time") {
        $dtmin = &datelabel2date($gr_props{$id}{xmin}) *10000;
        $dtmax = &datelabel2date($gr_props{$id}{xmax}) *10000;
    } else {
        $base_jd = &date2jdate(sprintf("%04d%02d%02d", $gr_props{$id}{base_yr}, 1, 1));
        $dtmin   = &jdate2date($gr_props{$id}{xmin} +$base_jd -1);
        $dtmax   = &jdate2date($gr_props{$id}{xmax} +$base_jd -1);
    }
    ($dtmin, $dtmax, $pmin, $pmax) = &find_ts_limits($id, 1, $dtmin, $dtmax);
    return if ($dtmin == -999);

    $ymin   = $gr_props{$id}{ymin};
    $ymax   = $gr_props{$id}{ymax};
    $ymajor = $gr_props{$id}{ymajor};
    if ($ymin > $pmin || $ymax < $pmax || $ymax -$ymin > ($pmax -$pmin) *1.15) {
        ($ymin, $ymax, $ymajor) = &find_axis_limits($pmin, $pmax);
    }
    return if ($ymin == $gr_props{$id}{ymin} && $ymax == $gr_props{$id}{ymax});

    $gr_props{$id}{ymin}   = $ymin;
    $gr_props{$id}{ymax}   = $ymax;
    $gr_props{$id}{ymajor} = $ymajor;
    $gr_props{$id}{redraw} = 1;
    &make_ts_graph($canv, $id, 1);

#   Refresh the Graph Properties menu, if present
    if (defined($graph_props_menu) && Tkx::winfo_exists($graph_props_menu)) {
        if ($graph_props_menu->g_wm_title() =~ /Graph Properties/) {
            $tabid = $grprops_notebook->index('current');
            $geom  = $graph_props_menu->g_wm_geometry();
            (undef, $X, $Y) = split(/\+/, $geom);
            &edit_graph_props($id, $X, $Y, $tabid);
        }
    }
}


################################################################################
#
# Open or save project files
#
################################################################################

sub open_file {
    my ($file, $revert) = @_;
    my (

        $add_cs, $add_parm, $ahd1, $ahd2, $ahd3, $anchor, $angle, $answer,
        $arrow, $b_ref, $base_yr, $bgrid, $bgrid_col, $bh_bcellh, $bh_bcellw,
        $bh_bcolor, $bh_bwidth, $bh_docked, $bh_font, $bh_show, $bh_size,
        $bh_tcolor, $bh_weight, $bh_xpos, $bh_ypos, $br_list, $br_list2,
        $bth_file, $byear, $clines, $color, $con_file, $confirm_type,
        $coordlist, $cs_height, $cs_hide, $cs_link, $cs_major, $cs_max,
        $cs_min, $cs_rev, $cs_width, $cscheme1, $cscheme2, $ctype, $ctype2,
        $datafile, $date_axis, $datefmt, $dateline, $datelinec, $day,
        $dbase, $dfirst, $dflip, $dfont, $different, $dir, $dl_size,
        $dl_weight, $dmajor, $dmax, $dmax_auto, $dmin, $dop_tics,
        $dpr_tics, $dref_byear, $dref_ctype, $dref_file, $dref_ftype,
        $dref_lines, $dref_parm, $dref_tol, $dref_type, $dref_tzoff,
        $dref_val, $dsum, $dt, $dt_adj, $dt_begin, $dt_end, $dt_limits,
        $dt_size, $dt_weight, $dt2, $dtitle, $dunits, $elbot, $elev_ref,
        $extra_chk, $family, $fh, $fill, $fillcolor, $flip, $flow_file,
        $fname, $gap_tol, $gnum, $got_anchor, $got_bth_file, $got_con_file,
        $got_coordlist, $got_cpl_file, $got_cpl_file2, $got_cpl_info,
        $got_cpl_info2, $got_file, $got_hh, $got_hw, $got_lbc_file,
        $got_link, $got_links, $got_qla_file, $got_qla_lines, $got_text,
        $got_flow_file, $got_meta, $got_ref, $got_riv_file, $got_riv_file2,
        $got_riv_info, $got_riv_info2, $got_src_file, $got_src_file2,
        $got_src_lines, $got_w2l_file, $got_w2l_file2, $got_wl_file,
        $got_wl_lines, $got_wt_file, $got_x, $got_xc, $got_y, $got_yc,
        $gridcolor, $gridwidth, $gridx, $gridy, $gs_size, $gs_weight,
        $gstitle, $gt_size, $gt_weight, $gtfont, $gtitle, $h_ref, $hh,
        $hide_daxis, $hide_taxis, $hide_title, $hw, $i, $id, $ihc,
        $iho, $image, $img, $img_data, $input_section, $iwc, $iwo, $j,
        $jb, $jd_skip, $jw, $k, $kb_seg, $key, $keyfont, $keytitle, $kmx,
        $kn_digits, $kn_size, $kn_weight, $kt, $kt_ref, $kt_size, $kt_weight,
        $lbc_file, $le_edge, $le_edgec, $le_fill, $le_fillc, $le_size,
        $le_weight, $legfont, $legtitle, $line, $link_id, $ln_digits,
        $ln_form, $ln_gnum, $ln_interp, $ln_outlet, $ln_tol, $ln_type,
        $ln_units, $lt_size, $lt_weight, $map_type, $match_tol, $meta, $mi,
        $mon, $n, $ncolors, $nd, $nwb, $nww, $parm, $parm_div, $parm_ref,
        $parm_skip, $parm_units, $parm2, $parm2_div, $pbar, $pbar_window,
        $pos, $prof_stat, $prof_type, $project_path, $q_ref, $qla_file,
        $qla_lines, $qunits, $r, $ref_color, $ref_ctype, $ref_file,
        $ref_hide, $ref_tol, $rlines, $scale, $seg, $seg_list, $set, $sfont,
        $sgrid, $sgrid_col, $size, $sl_size, $sl_weight, $slant, $smajor,
        $smooth, $sop_tics, $spr_tics, $src_file, $src_file2, $src_lines,
        $src_lines2, $src_type, $src_type2, $st_size, $st_weight, $stic_loc,
        $stitle, $stype, $swap_order, $tags, $tecplot, $text, $tflip,
        $tfont, $tl_size, $tl_weight, $tmajor, $tmax, $tmin, $tmp_file,
        $top_tics, $tplot, $tpr_tics, $ts_gnum, $ts_id, $ts_type, $ts_units,
        $tt_size, $tt_weight, $ttitle, $ttype, $txt, $type, $tz_offset,
        $underline, $v_ref, $val, $vol, $w2l_file, $w2l_file2, $wb_list,
        $wd_alg, $weight, $width, $wl_color, $wl_grid, $wl_gridc, $wl_file,
        $wl_lines, $wl_style, $wt_file, $wt_units, $x, $xbase, $xc, $xfirst,
        $xflip, $xfont, $xl_size, $xl_weight, $xleg_off, $xmajor, $xmax,
        $xmax_auto, $xmin, $xop_tics, $xpr_tics, $xt_size, $xt_weight,
        $xtitle, $xunits, $xtype, $y, $yc, $yfont, $yl_size, $yl_weight,
        $yleg_off, $ymajor, $ymax, $ymin, $yop_tics, $ypr_tics, $yr,
        $yt_size, $yt_weight, $ytitle, $ytype, $yunits,

        @add_ts_byear, @add_ts_color, @add_ts_ctype, @add_ts_file,
        @add_ts_ftype, @add_ts_lines, @add_ts_param, @add_ts_seg,
        @add_ts_setnum, @add_ts_show, @add_ts_text, @add_ts_tzoff,
        @add_ts_width, @b, @be, @brs, @bs, @bth_files, @coords, @cpl_files,
        @cpl_files2, @cpl_lines, @cpl_lines2, @crop, @cus, @ds, @el,
        @elws, @graph_ids, @graph_nums, @h, @id_list, @kb, @kbsw, @ktsw,
        @mydates, @pdata, @riv_files, @riv_files2, @riv_lines, @riv_lines2,
        @slice_data, @sw_alg, @tecplot, @tecplot2, @ts_color, @ts_show,
        @ts_width, @tslink_ids, @us, @wbs,

        %add_ts_parms, %bh_config, %data, %elev_data, %kt_data, %limits,
        %parm_data, %parms, %profile, %qdata, %ref_data, %ref_profile,
        %rel_data, %sdata, %td_data, %tmp_data, %vdata, %wl_data,
       );

#   Before opening a file, check to see if any objects on the canvas labeled "keep".
#   Does the user wish to save them before opening a new project?
    @id_list = Tkx::SplitList($canvas->find_withtag("keep"));
    if ($#id_list >= 0) {
        ($tmp_file = $autosave_file) =~ s/\.w2a$/tmp\.w2a/;
        &save_file($tmp_file, 1);

      # If an autosave file already exists, push it to autosave_file2 if different.
      # Don't take this step if loading an autosaved file from this instance of W2Anim.
        if (! defined($file) || ($file ne $autosave_file && $file ne $autosave_file2)) {
            if (-e $autosave_file) {
                $different = &compare_saved($autosave_file, $tmp_file);
                if ($different) {
                    unlink $autosave_file2 if (-e $autosave_file2);
                    move($autosave_file, $autosave_file2);
                    $autosave_menu->entryconfigure('end', -state => 'normal');
                }
            }
            copy($tmp_file, $autosave_file);
            $autosave_menu->entryconfigure(8, -state => 'normal');  # entry 8 is "Revert, recent"
        }

      # Compare current project file to saved file
        if ($savefile ne "" && -e $savefile) {
            $different = &compare_saved($tmp_file, $savefile);
            unlink $tmp_file;
            if ($different) {
                $answer = &pop_up_question($main,
                               "Current project is different than saved\n"
                             . "project file. Do you want to save the\n"
                             . "current project before opening a new one?");
                return if (lc($answer) eq "yes");
            }
        } else {
            unlink $tmp_file;
            $answer = &pop_up_question($main,
                           "Current project has not been saved. Do you\n"
                         . "want to save it before opening a new one?");
            return if (lc($answer) eq "yes");
        }
    }

#   Get or process the file name
    if (! defined($file)) {
        $file = Tkx::tk___getOpenFile(
            -parent           => $main,
            -title            => "Open Project File",
            -initialdir       => abs_path(),
            -defaultextension => ".w2a",
            -filetypes => [ ['W2 Animator Files', '.w2a'],
                            ['All Files',  '*'],
                          ],
            );
    }
    return if (! defined($file) || $file eq "");
    if (! -e $file) {
        return &pop_up_error($main, "File not found\nor does not exist");
    }
    $file = File::Spec->rel2abs($file);
    open ($fh, "<", $file) || return &pop_up_error($main, "Unable to open\n$file");

#   Get project path
    ($vol, $dir, $fname) = File::Spec->splitpath($file);
    $project_path = $vol . $dir;
    $revert = 1 if ($file eq $autosave_file || $file eq $autosave_file2 ||
                    $file =~ /_autosave\d+\.w2a$/ || $file =~ /_autosave\d+_2\.w2a$/);

#   Delete existing stuff on the canvas and reset variables
    @id_list = Tkx::SplitList($canvas->find_all());
    for ($i=0; $i<=$#id_list; $i++) {
        $canvas->delete($id_list[$i]);
    }
    undef $ts_datemin;
    undef $ts_datemax;
    undef $cmap_datemin;
    undef $cmap_datemax;
    undef @dates;
    undef @id_list;
    undef %grid;
    undef %props;
    undef %gr_props;
    undef %link_props;
    undef $old_id if (defined($old_id));
    @animate_ids = ();
    @graph_nums  = ();
    @graph_ids   = ();
    @tslink_ids  = ();
    $graph_num   = -1;
    $got_links   =  0;
    $savefile    = "";
    $global_dt_limits = 0;
    $global_dt_begin  = $global_dt_end = "na";
    $anim_tb_status   = "stopped";
    $delay_autosave   = 1;
    $export_menu->entryconfigure(3, -state => 'disabled');
    $pref_menu->entryconfigure(0,   -state => 'disabled');

#   Kill any open pop-up menus that might be tied to old objects
#   Reset the general and canvas defaults
    &remove_and_restore_menus();

#   Read and parse the file
    while (defined( $line = <$fh> )) {
        $line =~ s/^\s+//;
        $line =~ s/\s+$//;
        next if ($line =~ /^#/ || $line eq "");

        if ($line =~ /==== CANVAS ====/) {
            $input_section = "canvas";
            next;
        } elsif ($line =~ /==== END CANVAS ====/) {
            $canvas_width      = $min_canvas_width  if ($canvas_width  < $min_canvas_width);
            $canvas_height     = $min_canvas_height if ($canvas_height < $min_canvas_height);
            $canvas_width      = 20000              if ($canvas_width  > 20000);
            $canvas_height     = 20000              if ($canvas_height > 20000);
            $max_canvas_width  = $canvas_width      if ($canvas_width  > $max_canvas_width);
            $max_canvas_height = $canvas_height     if ($canvas_height > $max_canvas_height);

            &initialize_canvas_scrollbars();
            $canvas->configure(-background   => &get_rgb_code($canvas_color),
                               -width        => $canvas_width,
                               -height       => $canvas_height,
                               -scrollregion => [0, 0, $canvas_width, $canvas_height],
                              );
            &adjust_main_position();
            $input_section = "none";
            next;
        } elsif ($line =~ /==== DATE LIMITS ====/) {
            $input_section = "date limits";
            next;
        } elsif ($line =~ /==== END DATE LIMITS ====/) {
            $global_dt_limits = 1 if ($global_dt_begin =~ /^[12][0-9][0-9][0-9][01][0-9][0-3][0-9]0000$/ &&
                                      $global_dt_end   =~ /^[12][0-9][0-9][0-9][01][0-9][0-3][0-9]0000$/);
            $input_section = "none";
            next;
        } elsif ($line =~ /==== OBJECTS ====/) {
            $input_section = "objects";
            next;
        } elsif ($line =~ /==== END OBJECTS ====/) {
            $input_section = "none";
            next;
        }
        if ($input_section eq "canvas") {
            if ($line =~ /[a-zA-Z_]+: /) {
                $pos = index($line, ":");
                $key = substr($line, 0, $pos);
                $val = substr($line, $pos + 1);
                $val =~ s/^\s+//;
                $canvas_width      = $val if ($key eq "width");
                $canvas_height     = $val if ($key eq "height");
                $canvas_color      = $val if ($key eq "color");
                $snap2grid         = $val if ($key eq "snap2grid");
                $grid_spacing      = $val if ($key eq "grid_spac");
                $text_select_color = $val if ($key eq "text_slct");
            }
        }
        if ($input_section eq "date limits") {
            if ($line =~ /[a-zA-Z_]+: /) {
                $pos = index($line, ":");
                $key = substr($line, 0, $pos);
                $val = substr($line, $pos + 1);
                $val =~ s/^\s+//;
                if ($key eq "gdt_begin") {
                    if ($val =~ /^[a-z][a-z][a-z]-[0-3]?[0-9]-[12][0-9][0-9][0-9]$/i) {
                        ($mon, $day, $yr) = &parse_date($val, 1);
                        $global_dt_begin = sprintf("%04d%02d%02d0000", $yr, $mon, $day);
                    }
                }
                if ($key eq "gdt_end") {
                    if ($val =~ /^[a-z][a-z][a-z]-[0-3]?[0-9]-[12][0-9][0-9][0-9]$/i) {
                        ($mon, $day, $yr) = &parse_date($val, 1);
                        $global_dt_end = sprintf("%04d%02d%02d0000", $yr, $mon, $day);
                    }
                }
            }
        }
        if ($input_section eq "objects") {
            $got_x = $got_y = $got_xc = $got_yc = $got_hw = $got_hh = 0;
            $got_anchor  = $got_coordlist = $got_text = $got_meta = $got_file = 0;
            $got_wt_file = $got_flow_file = $got_bth_file = $got_lbc_file = 0;
            $got_src_file  = $got_src_lines = $got_link = $got_ref = 0;
            $got_con_file  = $got_cpl_info  = $got_cpl_file  = $got_wl_lines  = 0;
            $got_qla_file  = $got_qla_lines = $got_w2l_file  = $got_wl_file   = 0;
            $got_cpl_info2 = $got_cpl_file2 = $got_w2l_file2 = $got_src_file2 = 0;
            $got_riv_info  = $got_riv_file  = $got_riv_info2 = $got_riv_file2 = 0;

            $tags      = "keep";
            $color     = $default_color;
            $width     = $default_width;
            $fill      = $default_fill;
            $fillcolor = $default_fillcolor;
            $angle     = $default_angle;
            $arrow     = $default_arrow;
            $ahd1      = $default_ahd1;
            $ahd2      = $default_ahd2;
            $ahd3      = $default_ahd3;
            $smooth    = $default_smooth;
            $family    = $default_family;
            $size      = $default_size;
            $weight    = $default_weight;
            $slant     = $default_slant;
            $underline = $default_underline;

            $xleg_off  = 40;
            $yleg_off  =  0;
            $kn_digits =  1;
            $cs_hide   =  0;
            $cs_link   =  0;
            $cs_width  = 24;
            $cs_height = 18;
            $cs_major  = -999;
            $xfont     = $yfont     = $gtfont    = $keyfont   = $tfont   = $dfont   = $default_family;
            $xt_size   = $yt_size   = $gt_size   = $kt_size   = $tt_size = $dt_size = 13;
            $xl_size   = $yl_size   =              $kn_size   = $tl_size = $dl_size = 11;
            $xt_weight = $xl_weight = $tt_weight = $tl_weight = 'normal';
            $yt_weight = $yl_weight = $dt_weight = $dl_weight = 'normal';
            $kt_weight = $kn_weight = 'normal';
            $gt_weight = $gs_weight = 'bold';
            $gs_size   = 12;
            $datefmt   = "Month";
            $dateline  = -1;
            $datelinec = "black";
            $date_axis = "X";
            $wd_alg    = "W2 original";
            $seg       = 0;
            $elbot     = 0;
            $xtitle    = $ytitle    = $gtitle   = $gstitle  = $keytitle = $ttitle = $dtitle = "";
            $wt_file   = $flow_file = $bth_file = $lbc_file = $w2l_file = $w2l_file2 = $wl_file = "";
            $src_file  = $src_type  = $con_file = $ref_file = $qla_file = $src_type2 = $src_file2 = "";
            $src_lines = $qla_lines = $wl_lines = $src_lines2 = $tplot = 0;
            $ln_gnum   = $gnum = 0;
            $ln_type   = "Flow";
            $ln_outlet = "All Outlets";
            $ln_form   = "Text";
            $ln_units  = "cfs";
            $ln_digits = 0;
            $ln_interp = 0;
            $ln_tol    = 10;
            $gridx     = $gridy = 0;
            $gridwidth = 1;
            $gridcolor = '#C0C0C0';
            $scale     = 1;
            $flip      = "none";
            @crop      = (0.0, 0.0, 0.0, 0.0);
            $dfirst    = $xfirst = "";
            $dpr_tics  = $tpr_tics = $xpr_tics = $ypr_tics = $spr_tics = "outside";
            $dop_tics  = $top_tics = $xop_tics = $yop_tics = $sop_tics = "none";
            $hide_title = $hide_taxis = $hide_daxis = 0;

            $bh_show   = 0;
            $bh_docked = 1;
            $bh_xpos   = -99;
            $bh_ypos   = -99;
            $bh_bcellh = -99;
            $bh_font   = $yfont;
            $bh_size   = $yl_size;
            $bh_weight = $yl_weight;
            $bh_tcolor = $bh_bcolor = "black";
            $bh_bwidth = 1;
            $bh_bcellw = 18;

            $parm      = $parm2     = $parm_units = "";
            $parm_div  = $parm2_div = "None";
            $byear     = "";
            $base_yr   = "";
            $ctype     = $ctype2 = "None";
            $ytype     = "Elevation";
            $yunits    = "feet";
            $qunits    = "cfs";
            $wt_units  = "Celsius";
            $xunits    = $dunits = "miles";
            $xtype     = $ttype  = "Date/Time";
            $xflip     = $tflip  = $dflip = $dmax_auto = $xmax_auto = 0;
            $jd_skip   = 0;
            $extra_chk = 1;
            $seg_list  = $wb_list = $br_list = $br_list2 = $xbase = $dbase = "";
            $map_type  = "standard";
            $tz_offset = "+00:00";
            $dt_limits = 0;
            $dt_begin  = $dt_end = -999;

            $stype     = "none";
            $sfont     = $default_family;
            $st_size   = 13;
            $sl_size   = 11;
            $st_weight = $sl_weight = 'normal';
            $smajor    = "auto";
            $stic_loc  = "upstream edge";
            $sgrid     = $bgrid = 0;
            $sgrid_col = '#C0C0C0';
            $bgrid_col = '#FF8040';
            $stitle    = "Segment Number";

            $add_parm  = 0;
            $parm_skip = 0;
            $match_tol = 10;
            $swap_order= 0;

            $prof_stat = "";
            $prof_type = "standard";
            $dref_type = "Constant";
            $dref_val  = $dref_lines = $dref_byear = $dref_tol = 0;
            $dref_file = $dref_ftype = $dref_parm  = "";
            $dref_ctype = "None";
            $dref_tzoff = "+00:00";

            $ref_ctype = "None";
            $ref_tol   = 10;
            $ref_color = "black";
            $ref_hide  = 0;

            @ts_color  = @ts_show = @ts_width = ();
            $ts_gnum   = 0;
            $ts_type   = "Flow";
            $ts_units  = "cfs";
            $legtitle  = "";
            $legfont   = $default_family;
            $lt_size   = 13;
            $le_size   = 11;
            $lt_weight = $le_weight = 'normal';
            $le_edge   = $le_fill = 0;
            $le_edgec  = "black";
            $le_fillc  = "white";
            $gap_tol   = 2;
            $wl_color  = "black";
            $wl_style  = "Flat surface";
            $wl_grid   = 0;
            $wl_gridc  = "#D0D0D0";

            @add_ts_setnum = @add_ts_file  = @add_ts_show  = @add_ts_lines = ();
            @add_ts_width  = @add_ts_color = @add_ts_text  = @add_ts_ctype = ();
            @add_ts_ftype  = @add_ts_param = @add_ts_byear = @add_ts_tzoff = @add_ts_seg = ();
            @cpl_files  = @tecplot  = @cpl_lines  = @bth_files = @wbs = ();
            @cpl_files2 = @tecplot2 = @cpl_lines2 = ();
            @riv_files = @riv_lines = @riv_files2 = @riv_lines2 = ();

            if (&list_match($line, @object_types) > -1) {
                $type = $line;
            } else {
                next;
            }
            while (defined( $line = <$fh> ) && $line !~ /end $type/) {
                $line =~ s/^\s+//;
                $line =~ s/\s+$//;
                $pos  = index($line, ":");
                $key  = substr($line, 0, $pos);
                $val  = substr($line, $pos +1);
                $val  =~ s/^\s+//;
                if ($key eq "x") {
                    $x     = $val +3;
                    $got_x = 1;
                } elsif ($key eq "y") {
                    $y     = $val +3;
                    $got_y = 1;
                } elsif ($key eq "xc") {
                    $xc     = $val +3;
                    $got_xc = 1;
                } elsif ($key eq "yc") {
                    $yc     = $val +3;
                    $got_yc = 1;
                } elsif ($key eq "hw") {
                    $hw     = $val;
                    $got_hw = 1;
                } elsif ($key eq "hh") {
                    $hh     = $val;
                    $got_hh = 1;
                } elsif ($key eq "anchor") {
                    $anchor     = $val;
                    $got_anchor = 1;
                } elsif ($key eq "coordlist") {
                    ($coordlist = $val) =~ s/\s+//g;
                    @coords     = split(/,/, $coordlist);
                    for ($i=0; $i<=$#coords; $i++) {
                        $coords[$i] += 3;
                    }
                    $got_coordlist = 1;
                } elsif ($key eq "text") {
                    $text     = $val;
                    $got_text = 1;
                } elsif ($key eq "file") {
                    $datafile = File::Spec->rel2abs($val, $project_path);
                    $got_file = 1;
                } elsif ($key eq "wt_file") {
                    $wt_file = File::Spec->rel2abs($val, $project_path);
                    $got_wt_file = 1;
                } elsif ($key eq "flow_file") {
                    $flow_file = File::Spec->rel2abs($val, $project_path);
                    $got_flow_file = 1;
                } elsif ($key eq "bth_file") {
                    $bth_file = File::Spec->rel2abs($val, $project_path);
                    $got_bth_file = 1;
                } elsif ($key eq "lbc_file") {
                    $lbc_file = File::Spec->rel2abs($val, $project_path);
                    $got_lbc_file = 1;
                } elsif ($key eq "src_file") {
                    $src_file = File::Spec->rel2abs($val, $project_path);
                    $got_src_file = 1;
                } elsif ($key eq "src_file2") {
                    $src_file2 = File::Spec->rel2abs($val, $project_path);
                    $got_src_file2 = 1;
                } elsif ($key eq "src_lines") {
                    $src_lines     = $val;
                    $got_src_lines = 1;
                } elsif ($key eq "src_line2") {
                    $src_lines2 = $val;
                } elsif ($key eq "con_file") {
                    $con_file = File::Spec->rel2abs($val, $project_path);
                    $got_con_file = 1;
                } elsif ($key eq "qla_file") {
                    $qla_file = File::Spec->rel2abs($val, $project_path);
                    $got_qla_file = 1;
                } elsif ($key eq "qla_lines") {
                    $qla_lines     = $val;
                    $got_qla_lines = 1;
                } elsif ($key eq "cpl_info") {
                    ($n, $tecplot, $clines) = split(/,/, $val);
                    $tecplot[$n]   = $tecplot +0;
                    $cpl_lines[$n] = $clines  +0;
                    $got_cpl_info  = 1;
                } elsif ($key eq "cpl_info2") {
                    ($n, $tecplot, $clines) = split(/,/, $val);
                    $tecplot2[$n]   = $tecplot +0;
                    $cpl_lines2[$n] = $clines  +0;
                    $got_cpl_info2  = 1;
                } elsif ($key eq "cpl_files") {
                    ($n, $tmp_file) = split(/,/, $val);
                    $tmp_file =~ s/^\s+//;
                    $cpl_files[$n] = File::Spec->rel2abs($tmp_file, $project_path);
                    $got_cpl_file  = 1;
                } elsif ($key eq "cpl_file2") {
                    ($n, $tmp_file) = split(/,/, $val);
                    $tmp_file =~ s/^\s+//;
                    $cpl_files2[$n] = File::Spec->rel2abs($tmp_file, $project_path);
                    $got_cpl_file2  = 1;
                } elsif ($key eq "riv_info") {
                    ($n, $jb, $rlines) = split(/,/, $val);
                    $br_list      .= ($jb+0) . ",";
                    $riv_lines[$n] = $rlines +0;
                    $got_riv_info  = 1;
                } elsif ($key eq "riv_info2") {
                    ($n, $jb, $rlines) = split(/,/, $val);
                    $br_list2      .= ($jb+0) . ",";
                    $riv_lines2[$n] = $rlines +0;
                    $got_riv_info2  = 1;
                } elsif ($key eq "riv_files") {
                    ($n, $tmp_file) = split(/,/, $val);
                    $tmp_file =~ s/^\s+//;
                    $riv_files[$n] = File::Spec->rel2abs($tmp_file, $project_path);
                    $got_riv_file  = 1;
                } elsif ($key eq "riv_file2") {
                    ($n, $tmp_file) = split(/,/, $val);
                    $tmp_file =~ s/^\s+//;
                    $riv_files2[$n] = File::Spec->rel2abs($tmp_file, $project_path);
                    $got_riv_file2  = 1;
                } elsif ($key eq "bth_files") {
                    ($n, $tmp_file) = split(/,/, $val);
                    $tmp_file =~ s/^\s+//;
                    $bth_files[$n] = File::Spec->rel2abs($tmp_file, $project_path);
                    $got_bth_file  = 1;
                } elsif ($key eq "w2l_file") {
                    $w2l_file = File::Spec->rel2abs($val, $project_path);
                    $got_w2l_file = 1;
                } elsif ($key eq "w2l_file2") {
                    $w2l_file2 = File::Spec->rel2abs($val, $project_path);
                    $got_w2l_file2 = 1;
                } elsif ($key eq "wl_file") {
                    $wl_file = File::Spec->rel2abs($val, $project_path);
                    $got_wl_file = 1;
                } elsif ($key eq "wl_lines") {
                    $wl_lines     = $val;
                    $got_wl_lines = 1;
                } elsif ($key eq "ref_file") {
                    $ref_file = File::Spec->rel2abs($val, $project_path);
                    $got_ref  = 1;
                } elsif ($key eq "meta") {
                    $meta     = $val;
                    $got_meta = 1;
                } elsif ($key eq "ln_gnum") {
                    $ln_gnum  = $val;
                    $got_link = $got_links = 1;
                } elsif ($key eq "crop") {
                    $val =~ s/\s+//g;
                    @crop = split(/,/, $val);  # left, right, top, bottom
                    for ($i=0; $i<4; $i++) {
                        $crop[$i] = &max(0., &min(1., $crop[$i]));
                    }
                    if ($crop[0] +$crop[1] >= 1.0) {
                        $crop[0] = $crop[1] = 0.;
                    }
                    if ($crop[2] +$crop[3] >= 1.0) {
                        $crop[2] = $crop[3] = 0.;
                    }
                }
                $tags     .= " " . $val if ($key eq "grouptags");
                $color     = $val if ($key eq "color");
                $width     = $val if ($key eq "width");
                $fill      = $val if ($key eq "fill");
                $fillcolor = $val if ($key eq "fillcolor");
                $angle     = $val if ($key eq "angle");
                $arrow     = $val if ($key eq "arrow");
                $ahd1      = $val if ($key eq "ahd1");
                $ahd2      = $val if ($key eq "ahd2");
                $ahd3      = $val if ($key eq "ahd3");
                $smooth    = $val if ($key eq "smooth");
                $family    = $val if ($key eq "family");
                $size      = $val if ($key eq "size");
                $weight    = $val if ($key eq "weight");
                $slant     = $val if ($key eq "slant");
                $underline = $val if ($key eq "underline");

                $add_cs    = $val if ($key eq "add_cs");
                $cs_hide   = $val if ($key eq "cs_hide");
                $cs_link   = $val if ($key eq "cs_link");
                $cscheme1  = $val if ($key eq "cscheme1");
                $cscheme2  = $val if ($key eq "cscheme2");
                $ncolors   = $val if ($key eq "ncolors");
                $cs_rev    = $val if ($key eq "cs_rev");
                $cs_min    = $val if ($key eq "cs_min");
                $cs_max    = $val if ($key eq "cs_max");
                $cs_major  = $val if ($key eq "cs_major");
                $cs_width  = $val if ($key eq "cs_width");
                $cs_height = $val if ($key eq "cs_height");
                $xleg_off  = $val if ($key eq "xleg_off");
                $yleg_off  = $val if ($key eq "yleg_off");
                $keyfont   = $val if ($key eq "keyfont");
                $keytitle  = $val if ($key eq "keytitle");
                $kt_size   = $val if ($key eq "kt_size");
                $kt_weight = $val if ($key eq "kt_weight");
                $kn_size   = $val if ($key eq "kn_size");
                $kn_weight = $val if ($key eq "kn_weight");
                $kn_digits = $val if ($key eq "kn_digits");
                $xtitle    = $val if ($key eq "xtitle");
                $xfont     = $val if ($key eq "xfont");
                $xt_size   = $val if ($key eq "xt_size");
                $xt_weight = $val if ($key eq "xt_weight");
                $xl_size   = $val if ($key eq "xl_size");
                $xl_weight = $val if ($key eq "xl_weight");
                $xbase     = $val if ($key eq "xbase");
                $xmin      = $val if ($key eq "xmin");
                $xmax      = $val if ($key eq "xmax");
                $xmax_auto = $val if ($key eq "xmax_auto");
                $xfirst    = $val if ($key eq "xfirst");
                $xmajor    = $val if ($key eq "xmajor");
                $xunits    = $val if ($key eq "xunits");
                $xflip     = $val if ($key eq "xflip");
                $xtype     = $val if ($key eq "xtype");
                $base_yr   = $val if ($key eq "base_yr");
                $datefmt   = $val if ($key eq "datefmt");
                $dateline  = $val if ($key eq "dateline");
                $datelinec = $val if ($key eq "datelinec");
                $ytitle    = $val if ($key eq "ytitle");
                $yfont     = $val if ($key eq "yfont");
                $yt_size   = $val if ($key eq "yt_size");
                $yt_weight = $val if ($key eq "yt_weight");
                $yl_size   = $val if ($key eq "yl_size");
                $yl_weight = $val if ($key eq "yl_weight");
                $ymin      = $val if ($key eq "ymin");
                $ymax      = $val if ($key eq "ymax");
                $ymajor    = $val if ($key eq "ymajor");
                $ytype     = $val if ($key eq "ytype");
                $yunits    = $val if ($key eq "yunits");
                $date_axis = $val if ($key eq "date_axis");
                $ttitle    = $val if ($key eq "ttitle");
                $tfont     = $val if ($key eq "tfont");
                $tt_size   = $val if ($key eq "tt_size");
                $tt_weight = $val if ($key eq "tt_weight");
                $tl_size   = $val if ($key eq "tl_size");
                $tl_weight = $val if ($key eq "tl_weight");
                $tmin      = $val if ($key eq "tmin");
                $tmax      = $val if ($key eq "tmax");
                $tmajor    = $val if ($key eq "tmajor");
                $tflip     = $val if ($key eq "tflip");
                $ttype     = $val if ($key eq "ttype");
                $dtitle    = $val if ($key eq "dtitle");
                $dfont     = $val if ($key eq "dfont");
                $dt_size   = $val if ($key eq "dt_size");
                $dt_weight = $val if ($key eq "dt_weight");
                $dl_size   = $val if ($key eq "dl_size");
                $dl_weight = $val if ($key eq "dl_weight");
                $dbase     = $val if ($key eq "dbase");
                $dmin      = $val if ($key eq "dmin");
                $dmax      = $val if ($key eq "dmax");
                $dmax_auto = $val if ($key eq "dmax_auto");
                $dfirst    = $val if ($key eq "dfirst");
                $dmajor    = $val if ($key eq "dmajor");
                $dflip     = $val if ($key eq "dflip");
                $dunits    = $val if ($key eq "dunits");
                $prof_stat = $val if ($key eq "prof_stat");
                $gtfont    = $val if ($key eq "gtfont");
                $gt_size   = $val if ($key eq "gt_size");
                $gt_weight = $val if ($key eq "gt_weight");
                $gtitle    = $val if ($key eq "gtitle");
                $gstitle   = $val if ($key eq "gstitle");
                $gs_size   = $val if ($key eq "gs_size");
                $gs_weight = $val if ($key eq "gs_weight");
                $wd_alg    = $val if ($key eq "wd_alg");
                $seg       = $val if ($key eq "seg");
                $elbot     = $val if ($key eq "elbot");
                $gnum      = $val if ($key eq "gnum");
                $ln_type   = $val if ($key eq "ln_type");
                $ln_outlet = $val if ($key eq "ln_outlet");
                $ln_form   = $val if ($key eq "ln_form");
                $ln_units  = $val if ($key eq "ln_units");
                $ln_digits = $val if ($key eq "ln_digits");
                $ln_interp = $val if ($key eq "ln_interp");
                $ln_tol    = $val if ($key eq "ln_tol");
                $gridx     = $val if ($key eq "gridx");
                $gridy     = $val if ($key eq "gridy");
                $gridwidth = $val if ($key eq "gridwidth");
                $gridcolor = $val if ($key eq "gridcolor");
                $scale     = $val if ($key eq "scale");
                $flip      = $val if ($key eq "flip");
                $wl_color  = $val if ($key eq "wl_color");
                $wl_style  = $val if ($key eq "wl_style");
                $wl_grid   = $val if ($key eq "wl_grid");
                $wl_gridc  = $val if ($key eq "wl_gridc");

                $dpr_tics  = $val if ($key eq "dpr_tics");
                $dop_tics  = $val if ($key eq "dop_tics");
                $tpr_tics  = $val if ($key eq "tpr_tics");
                $top_tics  = $val if ($key eq "top_tics");
                $xpr_tics  = $val if ($key eq "xpr_tics");
                $xop_tics  = $val if ($key eq "xop_tics");
                $ypr_tics  = $val if ($key eq "ypr_tics");
                $yop_tics  = $val if ($key eq "yop_tics");
                $spr_tics  = $val if ($key eq "spr_tics");
                $sop_tics  = $val if ($key eq "sop_tics");

                $stype     = $val if ($key eq "stype");
                $sfont     = $val if ($key eq "sfont");
                $st_size   = $val if ($key eq "st_size");
                $st_weight = $val if ($key eq "st_weight");
                $sl_size   = $val if ($key eq "sl_size");
                $sl_weight = $val if ($key eq "sl_weight");
                $smajor    = $val if ($key eq "smajor");
                $stic_loc  = $val if ($key eq "stic_loc");
                $sgrid     = $val if ($key eq "sgrid");
                $sgrid_col = $val if ($key eq "sgrid_col");
                $bgrid     = $val if ($key eq "bgrid");
                $bgrid_col = $val if ($key eq "bgrid_col");
                $stitle    = $val if ($key eq "stitle");

                $hide_title = $val if ($key eq "hidetitle");
                $hide_taxis = $val if ($key eq "hidetaxis");
                $hide_daxis = $val if ($key eq "hidedaxis");
                $map_type   = $val if ($key eq "map_type");

                $bh_show   = $val if ($key eq "bh_show");
                $bh_docked = $val if ($key eq "bh_docked");
                $bh_xpos   = $val if ($key eq "bh_xpos");
                $bh_ypos   = $val if ($key eq "bh_ypos");
                $bh_font   = $val if ($key eq "bh_font");
                $bh_size   = $val if ($key eq "bh_size");
                $bh_weight = $val if ($key eq "bh_weight");
                $bh_tcolor = $val if ($key eq "bh_tcolor");
                $bh_bwidth = $val if ($key eq "bh_bwidth");
                $bh_bcolor = $val if ($key eq "bh_bcolor");
                $bh_bcellw = $val if ($key eq "bh_bcellw");
                $bh_bcellh = $val if ($key eq "bh_bcellh");

                $parm      = $val if ($key eq "parm");
                $parm_div  = $val if ($key eq "parm_div");
                $parm2     = $val if ($key eq "parm2");
                $parm2_div = $val if ($key eq "parm2_div");
                $parm_units= $val if ($key eq "parmunits");
                $byear     = $val if ($key eq "byear");
                $tz_offset = $val if ($key eq "tz_offset");
                $ctype     = $val if ($key eq "ctype");
                $ctype2    = $val if ($key eq "ctype2");
                $wt_units  = $val if ($key eq "wt_units");
                $qunits    = $val if ($key eq "qunits");
                $seg_list  = $val if ($key eq "seg_list");
                $wb_list   = $val if ($key eq "wb_list");
                $jd_skip   = $val if ($key eq "jd_skip");
                $extra_chk = $val if ($key eq "extra_chk");
                $src_type  = $val if ($key eq "src_type");
                $src_type2 = $val if ($key eq "src_type2");
                $tplot     = $val if ($key eq "tplot");
                $add_parm  = $val if ($key eq "qla_parm");
                $parm_skip = $val if ($key eq "parm_skip");
                $match_tol = $val if ($key eq "match_tol");
                $swap_order= $val if ($key eq "diff_swap");

                $dt_limits = $val if ($key eq "dt_limits");
                $dt_begin  = $val if ($key eq "dt_begin");
                $dt_end    = $val if ($key eq "dt_end");

                $prof_type  = $val if ($key eq "prof_type");
                $dref_type  = $val if ($key eq "dref_type");
                $dref_val   = $val if ($key eq "dref_val");
                $dref_file  = $val if ($key eq "dref_file");
                $dref_ftype = $val if ($key eq "dref_ftyp");
                $dref_lines = $val if ($key eq "dref_line");
                $dref_parm  = $val if ($key eq "dref_parm");
                $dref_ctype = $val if ($key eq "dref_ctyp");
                $dref_tol   = $val if ($key eq "dref_tol");
                $dref_byear = $val if ($key eq "dref_byr");
                $dref_tzoff = $val if ($key eq "dref_tzof");

                $ref_ctype = $val if ($key eq "ref_ctype");
                $ref_tol   = $val if ($key eq "ref_tol");
                $ref_color = $val if ($key eq "ref_color");
                $ref_hide  = $val if ($key eq "ref_hide");

                $legtitle  = $val if ($key eq "legtitle");
                $legfont   = $val if ($key eq "legfont");
                $lt_size   = $val if ($key eq "lt_size");
                $lt_weight = $val if ($key eq "lt_weight");
                $le_size   = $val if ($key eq "le_size");
                $le_weight = $val if ($key eq "le_weight");
                $le_edge   = $val if ($key eq "le_edge");
                $le_edgec  = $val if ($key eq "le_edgec");
                $le_fill   = $val if ($key eq "le_fill");
                $le_fillc  = $val if ($key eq "le_fillc");
                $ts_gnum   = $val if ($key eq "ts_gnum");
                $ts_type   = $val if ($key eq "ts_type");
                $ts_units  = $val if ($key eq "ts_units");
                $gap_tol   = $val if ($key eq "gap_tol");
                if ($key eq "ts_show") {
                    $val =~ s/\s+//g;
                    @ts_show = split(/,/, $val);
                    for ($i=0; $i<=$#ts_show; $i++) {
                        $ts_show[$i] = 0 if ($ts_show[$i] != 1);
                    }
                } elsif ($key eq "ts_width") {
                    $val =~ s/\s+//g;
                    @ts_width = split(/,/, $val);
                    for ($i=0; $i<=$#ts_width; $i++) {
                        $ts_width[$i] = &max(1, &min(10, $ts_width[$i]));
                    }
                } elsif ($key eq "ts_color") {
                    $val =~ s/\s+//g;
                    @ts_color = split(/,/, $val);

                } elsif ($key eq "add_data") {
                    $pos = index($val, ",");
                    $set = substr($val, 0, $pos);
                    $val = substr($val, $pos +1);
                    $val =~ s/^\s+//;
                    push (@add_ts_setnum, $set);
                    push (@add_ts_file, File::Spec->rel2abs($val, $project_path));
                } elsif ($key eq "add_ftype") {
                    $pos = index($val, ",");
                    $i   = &list_match(substr($val, 0, $pos), @add_ts_setnum);
                    $val = substr($val, $pos +1);
                    $val =~ s/^\s+//;
                    $add_ts_ftype[$i] = $val if ($i >= 0);
                } elsif ($key eq "add_show") {
                    $pos = index($val, ",");
                    $i   = &list_match(substr($val, 0, $pos), @add_ts_setnum);
                    $val = substr($val, $pos +1);
                    $val =~ s/^\s+//;
                    $add_ts_show[$i] = $val if ($i >= 0);
                } elsif ($key eq "add_width") {
                    $pos = index($val, ",");
                    $i   = &list_match(substr($val, 0, $pos), @add_ts_setnum);
                    $val = substr($val, $pos +1);
                    $val =~ s/^\s+//;
                    $add_ts_width[$i] = $val if ($i >= 0);
                } elsif ($key eq "add_color") {
                    $pos = index($val, ",");
                    $i   = &list_match(substr($val, 0, $pos), @add_ts_setnum);
                    $val = substr($val, $pos +1);
                    $val =~ s/^\s+//;
                    $add_ts_color[$i] = $val if ($i >= 0);
                } elsif ($key eq "add_text") {
                    $pos = index($val, ",");
                    $i   = &list_match(substr($val, 0, $pos), @add_ts_setnum);
                    $val = substr($val, $pos +1);
                    $val =~ s/^\s+//;
                    $add_ts_text[$i] = $val if ($i >= 0);
                } elsif ($key eq "add_parm") {
                    $pos = index($val, ",");
                    $i   = &list_match(substr($val, 0, $pos), @add_ts_setnum);
                    $val = substr($val, $pos +1);
                    $val =~ s/^\s+//;
                    $add_ts_param[$i] = $val if ($i >= 0);
                } elsif ($key eq "add_byear") {
                    $pos = index($val, ",");
                    $i   = &list_match(substr($val, 0, $pos), @add_ts_setnum);
                    $val = substr($val, $pos +1);
                    $val =~ s/^\s+//;
                    $val = "n/a" if ($val eq "");
                    $add_ts_byear[$i] = $val if ($i >= 0);
                } elsif ($key eq "add_tzoff") {
                    $pos = index($val, ",");
                    $i   = &list_match(substr($val, 0, $pos), @add_ts_setnum);
                    $val = substr($val, $pos +1);
                    $val =~ s/^\s+//;
                    $val = "n/a" if ($val eq "");
                    $add_ts_tzoff[$i] = $val if ($i >= 0);
                } elsif ($key eq "add_seg") {
                    $pos = index($val, ",");
                    $i   = &list_match(substr($val, 0, $pos), @add_ts_setnum);
                    $val = substr($val, $pos +1);
                    $val =~ s/^\s+//;
                    $val = "n/a" if ($val eq "");
                    $add_ts_seg[$i] = $val if ($i >= 0);
                } elsif ($key eq "add_ctype") {
                    $pos = index($val, ",");
                    $i   = &list_match(substr($val, 0, $pos), @add_ts_setnum);
                    $val = substr($val, $pos +1);
                    $val =~ s/^\s+//;
                    $add_ts_ctype[$i] = $val if ($i >= 0);
                }
            }
            if ($type =~ /^(line|polyline)$/) {
                if ($got_x && $got_y && $got_xc && $got_yc && $got_anchor && $got_coordlist) {
                    $id = $canvas->create_line(@coords,
                             -fill       => &get_rgb_code($color),
                             -width      => $width,
                             -arrow      => $arrow_type[$arrow],
                             -arrowshape => [ $ahd1, $ahd2, $ahd3 ],
                             -tags       => $tags);
                    $props{$id}{type}      = $type;
                    $props{$id}{x}         = $x;
                    $props{$id}{y}         = $y;
                    $props{$id}{xc}        = $xc;
                    $props{$id}{yc}        = $yc;
                    $props{$id}{anchor}    = $anchor;
                    $props{$id}{coordlist} = [ @coords ];
                    $props{$id}{color}     = $color;
                    $props{$id}{width}     = $width;
                    $props{$id}{arrow}     = $arrow;
                    $props{$id}{ahd1}      = $ahd1;
                    $props{$id}{ahd2}      = $ahd2;
                    $props{$id}{ahd3}      = $ahd3;
                    if ($type eq "polyline") {
                        ($xc, $yc, $r) = &smallest_circle(@coords);
                        $props{$id}{xc_rot}    = $xc;
                        $props{$id}{yc_rot}    = $yc;
                        $props{$id}{angle}     = $angle;
                        $props{$id}{angle_tmp} = $angle;
                    }
                }
            } elsif ($type eq "circle") {
                if ($got_x && $got_y && $got_xc && $got_yc && $got_anchor && $got_coordlist) {
                    $id = $canvas->create_oval(@coords,
                             -outline => &get_rgb_code($color),
                             -width   => $width,
                             -tags    => $tags);
                    if ($fill && $fillcolor ne "") {
                        $canvas->itemconfigure($id, -fill => &get_rgb_code($fillcolor));
                    } else {
                        $canvas->itemconfigure($id, -fill => "");
                    }
                    if ($width == 0) {
                        $canvas->itemconfigure($id, -outline => "");
                    }
                    $props{$id}{type}      = $type;
                    $props{$id}{x}         = $x;
                    $props{$id}{y}         = $y;
                    $props{$id}{xc}        = $xc;
                    $props{$id}{yc}        = $yc;
                    $props{$id}{anchor}    = $anchor;
                    $props{$id}{coordlist} = [ @coords ];
                    $props{$id}{color}     = $color;
                    $props{$id}{width}     = $width;
                    $props{$id}{fill}      = $fill;
                    $props{$id}{fillcolor} = $fillcolor;
                }
            } elsif ($type eq "ellipse") {
                if ($got_x && $got_y && $got_xc && $got_yc && $got_hw && $got_hh && $got_anchor) {
                    @coords = &make_shape_coords($type, $xc, $yc, $hw, $hh, $angle);
                    $id = $canvas->create_polygon(@coords,
                             -outline => &get_rgb_code($color),
                             -width   => $width,
                             -smooth  => 'false',
                             -tags    => $tags);
                    if ($fill && $fillcolor ne "") {
                        $canvas->itemconfigure($id, -fill => &get_rgb_code($fillcolor));
                    } else {
                        $canvas->itemconfigure($id, -fill => "");
                    }
                    if ($width == 0) {
                        $canvas->itemconfigure($id, -outline => "");
                    }
                    $props{$id}{type}      = $type;
                    $props{$id}{x}         = $x;
                    $props{$id}{y}         = $y;
                    $props{$id}{xc}        = $xc;
                    $props{$id}{yc}        = $yc;
                    $props{$id}{hw}        = $hw;
                    $props{$id}{hh}        = $hh;
                    $props{$id}{anchor}    = $anchor;
                    $props{$id}{coordlist} = [ @coords ];
                    $props{$id}{color}     = $color;
                    $props{$id}{width}     = $width;
                    $props{$id}{fill}      = $fill;
                    $props{$id}{fillcolor} = $fillcolor;
                    $props{$id}{angle}     = $angle;
                    $props{$id}{angle_tmp} = $angle;
                    $props{$id}{smooth}    = 0;
                }
            } elsif ($type =~ /^(rectangle|diamond)$/) {
                if ($got_x && $got_y && $got_xc && $got_yc && $got_coordlist && $got_anchor) {
                    $id = $canvas->create_polygon(@coords,
                             -outline => &get_rgb_code($color),
                             -width   => $width,
                             -smooth  => $smooth_type[$smooth],
                             -tags    => $tags);
                    if ($fill && $fillcolor ne "") {
                        $canvas->itemconfigure($id, -fill => &get_rgb_code($fillcolor));
                    } else {
                        $canvas->itemconfigure($id, -fill => "");
                    }
                    if ($width == 0) {
                        $canvas->itemconfigure($id, -outline => "");
                    }
                    $props{$id}{type}      = $type;
                    $props{$id}{x}         = $x;
                    $props{$id}{y}         = $y;
                    $props{$id}{xc}        = $xc;
                    $props{$id}{yc}        = $yc;
                    $props{$id}{anchor}    = $anchor;
                    $props{$id}{coordlist} = [ @coords ];
                    $props{$id}{color}     = $color;
                    $props{$id}{width}     = $width;
                    $props{$id}{fill}      = $fill;
                    $props{$id}{fillcolor} = $fillcolor;
                    $props{$id}{angle}     = $angle;
                    $props{$id}{angle_tmp} = $angle;
                    $props{$id}{smooth}    = $smooth;
                }
            } elsif ($type eq "polygon") {
                if ($got_x && $got_y && $got_xc && $got_yc && $got_coordlist && $got_anchor) {
                    $id = $canvas->create_polygon(@coords,
                             -outline => &get_rgb_code($color),
                             -width   => $width,
                             -tags    => $tags);
                    if ($fill && $fillcolor ne "") {
                        $canvas->itemconfigure($id, -fill => &get_rgb_code($fillcolor));
                    } else {
                        $canvas->itemconfigure($id, -fill => "");
                    }
                    if ($width == 0) {
                        $canvas->itemconfigure($id, -outline => "");
                    }
                    $props{$id}{type}      = $type;
                    $props{$id}{x}         = $x;
                    $props{$id}{y}         = $y;
                    $props{$id}{xc}        = $xc;
                    $props{$id}{yc}        = $yc;
                    $props{$id}{anchor}    = $anchor;
                    $props{$id}{coordlist} = [ @coords ];
                    $props{$id}{color}     = $color;
                    $props{$id}{width}     = $width;
                    $props{$id}{fill}      = $fill;
                    $props{$id}{fillcolor} = $fillcolor;
                    $props{$id}{angle}     = $angle;
                    $props{$id}{angle_tmp} = $angle;

                    ($xc, $yc, $r) = &smallest_circle(@coords);
                    $props{$id}{xc_rot}    = $xc;
                    $props{$id}{yc_rot}    = $yc;
                }
            } elsif ($type eq "text") {
                if ($got_x && $got_y && $got_anchor && $got_text) {
                    $id = $canvas->create_text($x, $y,
                             -anchor => $anchor,
                             -text   => $text,
                             -fill   => &get_rgb_code($color),
                             -angle  => $angle,
                             -tags   => $tags,
                             -font   => [-family     => $family,
                                         -size       => $size,
                                         -weight     => $weight,
                                         -slant      => $slant_type[$slant],
                                         -underline  => $underline,
                                         -overstrike => 0,
                                        ]);
                    $props{$id}{type}      = $type;
                    $props{$id}{text}      = $text;
                    $props{$id}{x}         = $x;
                    $props{$id}{y}         = $y;
                    $props{$id}{anchor}    = $anchor;
                    $props{$id}{coordlist} = [$x, $y];
                    $props{$id}{color}     = $color;
                    $props{$id}{family}    = $family;
                    $props{$id}{size}      = $size;
                    $props{$id}{weight}    = $weight;
                    $props{$id}{slant}     = $slant;
                    $props{$id}{underline} = $underline;
                    $props{$id}{angle}     = $angle;
                    &find_rect_from_text_or_image($canvas, $id);
                }
            } elsif ($type eq "image") {
                if ($got_x && $got_y && $got_anchor && $got_file) {
                    if (! -e $datafile || -s $datafile == 0) {
                        return &pop_up_error2($main, "Image file empty or does not exist\n  $datafile");
                    }
                    $img = Imager->new;
                    $img->read(file => $datafile) or
                            return &pop_up_error2($main, "Failed to load $datafile\n $img->errstr");
                    $img = $img->convert(preset => 'addalpha');
                    $iwo = $img->getwidth();
                    $iho = $img->getheight();
                    if ($crop[0] > 0. || $crop[1] > 0. || $crop[2] > 0. || $crop[3] > 0.) {
                        $img = $img->crop(left   => &round_to_int($iwo *$crop[0]),
                                          right  => &round_to_int($iwo *(1.0 -$crop[1])),
                                          top    => &round_to_int($iho *$crop[2]),
                                          bottom => &round_to_int($iho *(1.0 -$crop[3])));
                    }
                    $iwc = $img->getwidth();
                    $ihc = $img->getheight();
                    if (defined($scale) && $scale != 1.0) {
                        $img = $img->scale(xpixels => &round_to_int($iwc *$scale));
                    }
                    if ($flip ne "none") {
                        $img->flip(dir => $flip);
                    }
                    $img->write(data => \$img_data, type => 'png');
                    $image = Tkx::image_create_photo(-data => $img_data);
                    $id = $canvas->create_image($x, $y,
                                                -anchor => 'center',
                                                -image  => $image,
                                                -tags   => $tags,
                                                -state  => 'hidden');
                    $props{$id}{type}   = $type;
                    $props{$id}{x}      = $x;
                    $props{$id}{y}      = $y;
                    $props{$id}{anchor} = $anchor;
                    $props{$id}{iw}     = Tkx::image_width($image);
                    $props{$id}{ih}     = Tkx::image_height($image);
                    $props{$id}{iwo}    = $iwo;
                    $props{$id}{iho}    = $iho;
                    $props{$id}{iwc}    = $iwc;
                    $props{$id}{ihc}    = $ihc;
                    $props{$id}{crop}   = [ @crop ];
                    $props{$id}{file}   = $datafile;
                    $props{$id}{image}  = $image;
                    $props{$id}{idata}  = $img_data;
                    $props{$id}{angle}  = $angle;
                    $props{$id}{flip}   = $flip;

                    &find_rect_from_text_or_image($canvas, $id);  # set xc, yc
                    $props{$id}{coordlist} = [$props{$id}{xc}, $props{$id}{yc}];

                    if ($angle != 0) {
                        $img = $img->rotate(degrees => -1 *$angle);
                        $img->write(data => \$img_data, type => 'png');
                        $image = Tkx::image_create_photo(-data => $img_data);
                        $canvas->itemconfigure($id, -image => $image);
                    }
                    $canvas->coords($id, $props{$id}{xc}, $props{$id}{yc});
                    $canvas->itemconfigure($id, -state => 'normal');
                }
            } elsif ($type eq "graph") {
                if ($meta =~ /w2_profile|w2_slice|w2_wlevels|w2_tdmap/ && ! $got_bth_file) {
                    return &pop_up_error2($main, "Graph type $meta requires a bathymetry file.\n"
                                               . "Please edit the project file or recreate it.");
                }
                if ($got_x && $got_y && $got_anchor && $got_coordlist && $got_meta
                    && ($meta =~ /time_series/
                       || ($meta =~ /data_profile/ && $got_src_file)
                       || ($meta eq "vert_wd_zone" && $got_wt_file && $got_flow_file && $got_bth_file
                           && ($wd_alg ne "Libby Dam" || $got_lbc_file))
                       || ($meta =~ /w2_profile/ && $got_con_file && $got_src_file && $got_bth_file
                                                 && ($src_type =~ /Vector/i 
                                                      || ($src_type =~ /Spreadsheet|Contour|LakeCon/i
                                                            && $got_src_lines)))
                       || ($meta =~ /w2_outflow/ && $got_con_file && $got_bth_file
                                                 && $got_qla_file && $got_qla_lines)
                       || ($meta =~ /w2_slice/ && $got_con_file && $got_bth_file && ($got_w2l_file
                                                  || ($got_cpl_info && $got_cpl_file)))
                       || ($meta =~ /w2_wlevels/ && $got_con_file && $got_bth_file && ($got_w2l_file
                                                  || ($got_wl_file  && $got_wl_lines)
                                                  || ($got_cpl_info && $got_cpl_file)))
                       || ($meta =~ /w2_tdmap/ && $got_con_file && $got_bth_file
                                               && ($got_w2l_file
                                                  || ($got_cpl_info && $got_cpl_file)
                                                  || ($got_riv_info && $got_riv_file)
                                                  || $got_src_file)))) {

                    $status_line = "Reading input files.  Please wait...";
                    $canvas->configure(-cursor => $cursor_wait);
                    Tkx::update();

                    if ($meta =~ /data_profile/ && (! -e $src_file || -s $src_file == 0)) {
                        return &pop_up_error2($main,
                                          "Data file empty or does not exist\n  $src_file");
                    }
                    if ($meta eq "vert_wd_zone") {
                        if (! -e $wt_file || -s $wt_file == 0) {
                            return &pop_up_error2($main,
                                          "Temperature file empty or does not exist\n  $wt_file");
                        }
                        if (! -e $flow_file || -s $flow_file == 0) {
                            return &pop_up_error2($main,
                                          "Outlet flow file empty or does not exist\n  $flow_file");
                        }
                        if (! -e $bth_file || -s $bth_file == 0) {
                            return &pop_up_error2($main,
                                          "Bathymetry file empty or does not exist\n  $bth_file");
                        }
                        if ($wd_alg eq "Libby Dam") {
                            if (! -e $lbc_file || -s $lbc_file == 0) {
                                return &pop_up_error2($main,
                                "Libby bulkhead configuration file empty or does not exist\n  $lbc_file");
                            }
                        }
                    } elsif ($meta =~ /w2_profile/) {
                        if (! -e $con_file || -s $con_file == 0) {
                            return &pop_up_error2($main,
                                          "W2 control file empty or does not exist\n  $con_file");
                        }
                        if (! -e $bth_file || -s $bth_file == 0) {
                            return &pop_up_error2($main,
                                          "Bathymetry file empty or does not exist\n  $bth_file");
                        }
                        if (! -e $src_file || -s $src_file == 0) {
                            if ($src_type =~ /Spreadsheet/i) {
                                return &pop_up_error2($main,
                                          "W2 spreadsheet file empty or does not exist\n  $src_file");
                            } elsif ($src_type =~ /Contour/i) {
                                return &pop_up_error2($main,
                                          "W2 contour file empty or does not exist\n  $src_file");
                            } elsif ($src_type =~ /LakeCon/i) {
                                return &pop_up_error2($main,
                                          "W2 Lake Contour file empty or does not exist\n  $src_file");
                            } else {
                                return &pop_up_error2($main,
                                          "W2 vector file empty or does not exist\n  $src_file");
                            }
                        }
                        if ($got_ref) {
                            if (! -e $ref_file || -s $ref_file == 0) {
                                return &pop_up_error2($main,
                                          "Reference profile file empty or does not exist\n  $ref_file");
                            }
                        }
                    } elsif ($meta =~ /w2_outflow/) {
                        if (! -e $con_file || -s $con_file == 0) {
                            return &pop_up_error2($main,
                                          "W2 control file empty or does not exist\n  $con_file");
                        }
                        if (! -e $bth_file || -s $bth_file == 0) {
                            return &pop_up_error2($main,
                                          "Bathymetry file empty or does not exist\n  $bth_file");
                        }
                        if (! -e $qla_file || -s $qla_file == 0) {
                            return &pop_up_error2($main,
                                          "Layer outflow file empty or does not exist\n  $qla_file");
                        }
                        if ($add_parm) {
                            if (! -e $src_file || -s $src_file == 0) {
                                if ($src_type =~ /Spreadsheet/i) {
                                    return &pop_up_error2($main,
                                              "W2 spreadsheet file empty or does not exist\n  $src_file");
                                } elsif ($src_type =~ /Contour/i) {
                                    return &pop_up_error2($main,
                                              "W2 contour file empty or does not exist\n  $src_file");
                                } elsif ($src_type =~ /Vector/i) {
                                    return &pop_up_error2($main,
                                              "W2 vector file empty or does not exist\n  $src_file");
                                } elsif ($src_type =~ /LakeCon/i) {
                                    return &pop_up_error2($main,
                                              "W2 Lake Contour file empty or does not exist\n  $src_file");
                                }
                            }
                        }
                    } elsif ($meta =~ /w2_slice|w2_wlevels/) {
                        if (! -e $con_file || -s $con_file == 0) {
                            return &pop_up_error2($main,
                                          "W2 control file empty or does not exist\n  $con_file");
                        }
                        if ($meta eq "w2_slice") {
                            if ($src_type eq "" || $src_type !~ /^(W2 Contour File|W2 Vector File)$/) {
                                if ($got_cpl_info && $got_cpl_file) {
                                    $src_type = "W2 Contour File";
                                } elsif ($got_w2l_file) {
                                    $src_type = "W2 Vector File";
                                }
                            }
                        } elsif ($meta eq "w2_wlevels") {
                            if ($src_type eq ""
                                 || $src_type !~ /^(W2 Contour File|W2 Vector File|W2 Water Level File)$/) {
                                if ($got_cpl_info && $got_cpl_file) {
                                    $src_type = "W2 Contour File";
                                } elsif ($got_w2l_file) {
                                    $src_type = "W2 Vector File";
                                } elsif ($got_wl_file && $got_wl_lines) {
                                    $src_type = "W2 Water Level File";
                                }
                            }
                        }
                        $txt = ($meta eq "w2_slice") ? "slice" : "water level";
                        if ($src_type =~ /Contour/i) {
                            if (! $got_bth_file || ! $got_cpl_info || ! $got_cpl_file) {
                                return &pop_up_error2($main,
                                       "W2 $txt object has insufficient data on W2 contour files");
                            }
                            @wbs = split(/,/, $wb_list);
                            for ($j=0; $j<=$#wbs; $j++) {
                                if (! -e $cpl_files[$j] || -s $cpl_files[$j] == 0) {
                                    return &pop_up_error2($main,
                                           "W2 contour file empty or does not exist\n  $cpl_files[$j]");
                                }
                                if (! -e $bth_files[$j] || -s $bth_files[$j] == 0) {
                                    return &pop_up_error2($main,
                                           "W2 bathymetry file empty or does not exist\n  $bth_files[$j]");
                                }
                            }
                        } elsif ($src_type =~ /Vector/i) {
                            if (! $got_w2l_file) {
                                return &pop_up_error2($main,
                                       "W2 $txt object failed to specify the W2 vector file name");
                            }
                            if (! -e $w2l_file || -s $w2l_file == 0) {
                                return &pop_up_error2($main,
                                       "W2 vector file empty or does not exist\n  $w2l_file");
                            }
                            @wbs = split(/,/, $wb_list);
                            for ($j=0; $j<=$#wbs; $j++) {
                                if (! -e $bth_files[$j] || -s $bth_files[$j] == 0) {
                                    return &pop_up_error2($main,
                                           "W2 bathymetry file empty or does not exist\n  $bth_files[$j]");
                                }
                            }
                        } elsif ($src_type =~ /Water Level/i) {
                            if (! $got_wl_file || ! $got_wl_lines) {
                                return &pop_up_error2($main,
                                       "W2 $txt object has insufficient data on the W2 water level file");
                            }
                            if (! -e $wl_file || -s $wl_file == 0) {
                                return &pop_up_error2($main,
                                       "W2 water level file empty or does not exist\n  $wl_file");
                            }
                            @wbs = split(/,/, $wb_list);
                            for ($j=0; $j<=$#wbs; $j++) {
                                if (! -e $bth_files[$j] || -s $bth_files[$j] == 0) {
                                    return &pop_up_error2($main,
                                           "W2 bathymetry file empty or does not exist\n  $bth_files[$j]");
                                }
                            }
                        }
                    } elsif ($meta =~ /w2_tdmap/) {
                        if (! -e $con_file || -s $con_file == 0) {
                            return &pop_up_error2($main,
                                          "W2 control file empty or does not exist\n  $con_file");
                        }
                        if ($src_type eq ""
                               || $src_type !~ /^(W2 Contour File|W2 Vector File|W2 RiverCon File)$/
                               || $src_type !~ /^(W2 SurfTemp File|W2 VolTemp File|W2 FlowTemp File)$/) {
                            if ($got_cpl_info && $got_cpl_file) {
                                $src_type = "W2 Contour File";
                            } elsif ($got_w2l_file) {
                                $src_type = "W2 Vector File";
                            } elsif ($got_riv_info && $got_riv_file) {
                                $src_type  = "W2 RiverCon File";
                                $prof_stat = "Surface value";
                            } elsif ($got_src_file) {
                                ($src_type, undef, undef) = &determine_ts_type($main, $src_file, 1);
                                if ($src_type =~ /SurfTemp/i) {
                                    $src_type  = "W2 SurfTemp File";
                                    $prof_stat = "Surface value";
                                } elsif ($src_type =~ /VolTemp/i) {
                                    $src_type  = "W2 VolTemp File";
                                    $prof_stat = "Volume-weighted";
                                } elsif ($src_type =~ /FlowTemp/i) {
                                    $src_type  = "W2 FlowTemp File";
                                    $prof_stat = "Flow-weighted";
                                }
                            }
                        }
                        if ($src_type =~ /Contour/i) {
                            if (! $got_bth_file || ! $got_cpl_info || ! $got_cpl_file) {
                                return &pop_up_error2($main,
                                       "W2 time/distance object has insufficient data on W2 contour files");
                            }
                            @wbs = split(/,/, $wb_list);
                            for ($j=0; $j<=$#wbs; $j++) {
                                if (! -e $cpl_files[$j] || -s $cpl_files[$j] == 0) {
                                    return &pop_up_error2($main,
                                           "W2 contour file empty or does not exist\n  $cpl_files[$j]");
                                }
                                if (! -e $bth_files[$j] || -s $bth_files[$j] == 0) {
                                    return &pop_up_error2($main,
                                           "W2 bathymetry file empty or does not exist\n  $bth_files[$j]");
                                }
                            }
                            if ($prof_stat eq "Flow-weighted") {
                                return &pop_up_error2($main,
                                       "Profile stat ($prof_stat) for Time/Distance Diff Map\n"
                                     . "inconsistent with use of W2 contour output file");
                            }
                        } elsif ($src_type =~ /Vector/i) {
                            if (! $got_w2l_file) {
                                return &pop_up_error2($main,
                                       "W2 time/distance object failed to specify the W2 vector file name");
                            }
                            if (! -e $w2l_file || -s $w2l_file == 0) {
                                return &pop_up_error2($main,
                                       "W2 vector file empty or does not exist\n  $w2l_file");
                            }
                            @wbs = split(/,/, $wb_list);
                            for ($j=0; $j<=$#wbs; $j++) {
                                if (! -e $bth_files[$j] || -s $bth_files[$j] == 0) {
                                    return &pop_up_error2($main,
                                           "W2 bathymetry file empty or does not exist\n  $bth_files[$j]");
                                }
                            }
                            if ($prof_stat eq "Flow-weighted") {
                                return &pop_up_error2($main,
                                       "Profile stat ($prof_stat) for Time/Distance Diff Map\n"
                                     . "inconsistent with use of W2 vector output file");
                            }
                        } elsif ($src_type =~ /RiverCon/i) {
                            if (! $got_bth_file || ! $got_riv_info || ! $got_riv_file) {
                                return &pop_up_error2($main,
                                       "W2 time/distance object has insufficient data on W2 RiverCon files");
                            }
                            for ($j=0; $j<=$#riv_files; $j++) {
                                if (! -e $riv_files[$j] || -s $riv_files[$j] == 0) {
                                    return &pop_up_error2($main,
                                           "W2 RiverCon file empty or does not exist\n  $riv_files[$j]");
                                }
                            }
                            @wbs = split(/,/, $wb_list);
                            for ($j=0; $j<=$#wbs; $j++) {
                                if (! -e $bth_files[$j] || -s $bth_files[$j] == 0) {
                                    return &pop_up_error2($main,
                                           "W2 bathymetry file empty or does not exist\n  $bth_files[$j]");
                                }
                            }
                            if ($prof_stat eq "Flow-weighted" || $prof_stat eq "Volume-weighted") {
                                return &pop_up_error2($main,
                                       "Profile stat ($prof_stat) for Time/Distance Diff Map\n"
                                     . "inconsistent with use of W2 RiverCon output file");
                            }
                        } elsif ($src_type =~ /SurfTemp|VolTemp|FlowTemp/i) {
                            if (! $got_src_file) {
                                return &pop_up_error2($main, "W2 time/distance object failed to specify the "
                                                            . $src_type . " name");
                            }
                            if (! -e $src_file || -s $src_file == 0) {
                                return &pop_up_error2($main,
                                                      $src_type . " empty or does not exist\n  $src_file");
                            }
                            @wbs = split(/,/, $wb_list);
                            for ($j=0; $j<=$#wbs; $j++) {
                                if (! -e $bth_files[$j] || -s $bth_files[$j] == 0) {
                                    return &pop_up_error2($main,
                                           "W2 bathymetry file empty or does not exist\n  $bth_files[$j]");
                                }
                            }
                            if ($src_type =~ /SurfTemp/i) {
                                if ($prof_stat ne "Surface value") {
                                    return &pop_up_error2($main,
                                           "Profile stat ($prof_stat) for Time/Distance Diff Map\n"
                                         . "inconsistent with use of W2 SurfTemp output file");
                                }
                            } elsif ($src_type =~ /VolTemp/i) {
                                if ($prof_stat ne "Volume-weighted") {
                                    return &pop_up_error2($main,
                                           "Profile stat ($prof_stat) for Time/Distance Diff Map\n"
                                         . "inconsistent with use of W2 VolTemp output file");
                                }
                            } elsif ($src_type =~ /FlowTemp/i) {
                                if ($prof_stat ne "Flow-weighted") {
                                    return &pop_up_error2($main,
                                           "Profile stat ($prof_stat) for Time/Distance Diff Map\n"
                                         . "inconsistent with use of W2 FlowTemp output file");
                                }
                            }
                        }
                        if ($map_type eq "filediff") {
                            if ($src_type2 eq ""
                                   || $src_type2 !~ /^(W2 Contour File|W2 Vector File|W2 RiverCon File)$/
                                   || $src_type2 !~ /^(W2 SurfTemp File|W2 VolTemp File|W2 FlowTemp File)$/) {
                                if ($got_cpl_info2 && $got_cpl_file2) {
                                    $src_type2 = "W2 Contour File";
                                    if ($prof_stat eq "Flow-weighted") {
                                        return &pop_up_error2($main,
                                               "Profile stat ($prof_stat) for Time/Distance Diff Map\n"
                                             . "inconsistent with use of W2 contour output file");
                                    }
                                } elsif ($got_w2l_file2) {
                                    $src_type2 = "W2 Vector File";
                                    if ($prof_stat eq "Flow-weighted") {
                                        return &pop_up_error2($main,
                                               "Profile stat ($prof_stat) for Time/Distance Diff Map\n"
                                             . "inconsistent with use of W2 vector output file");
                                    }
                                } elsif ($got_riv_info2 && $got_riv_file2) {
                                    $src_type2 = "W2 RiverCon File";
                                    if ($prof_stat eq "Flow-weighted" || $prof_stat eq "Volume-weighted") {
                                        return &pop_up_error2($main,
                                               "Profile stat ($prof_stat) for Time/Distance Diff Map\n"
                                             . "inconsistent with use of W2 RiverCon output file");
                                    }
                                } elsif ($got_src_file2) {
                                    ($src_type2, undef, undef) = &determine_ts_type($main, $src_file2, 1);
                                    if ($src_type2 =~ /SurfTemp/i) {
                                        $src_type2 = "W2 SurfTemp File";
                                        if ($prof_stat ne "Surface value") {
                                            return &pop_up_error2($main,
                                                   "Profile stat ($prof_stat) for Time/Distance Diff Map\n"
                                                 . "inconsistent with use of W2 SurfTemp output file");
                                        }
                                    } elsif ($src_type2 =~ /VolTemp/i) {
                                        $src_type2 = "W2 VolTemp File";
                                        if ($prof_stat ne "Volume-weighted") {
                                            return &pop_up_error2($main,
                                                   "Profile stat ($prof_stat) for Time/Distance Diff Map\n"
                                                 . "inconsistent with use of W2 VolTemp output file");
                                        }
                                    } elsif ($src_type =~ /FlowTemp/i) {
                                        $src_type2 = "W2 FlowTemp File";
                                        if ($prof_stat ne "Flow-weighted") {
                                            return &pop_up_error2($main,
                                                   "Profile stat ($prof_stat) for Time/Distance Diff Map\n"
                                                 . "inconsistent with use of W2 FlowTemp output file");
                                        }
                                    }
                                }
                            }
                            if ($src_type2 =~ /Contour/i) {
                                if (! $got_cpl_info2 || ! $got_cpl_file2) {
                                    return &pop_up_error2($main,
                                         "W2 time/distance object has insufficient data on W2 contour files");
                                }
                                @wbs = split(/,/, $wb_list);
                                for ($j=0; $j<=$#wbs; $j++) {
                                    if (! -e $cpl_files2[$j] || -s $cpl_files2[$j] == 0) {
                                        return &pop_up_error2($main,
                                               "W2 contour file empty or does not exist\n  $cpl_files2[$j]");
                                    }
                                }
                                if ($prof_stat eq "Flow-weighted") {
                                    return &pop_up_error2($main,
                                           "Profile stat ($prof_stat) for Time/Distance Diff Map\n"
                                         . "inconsistent with use of W2 contour output file");
                                }
                            } elsif ($src_type2 =~ /Vector/i) {
                                if (! $got_w2l_file2) {
                                    return &pop_up_error2($main,
                                         "W2 time/distance object failed to specify the W2 vector file name");
                                }
                                if (! -e $w2l_file2 || -s $w2l_file2 == 0) {
                                    return &pop_up_error2($main,
                                           "W2 vector file empty or does not exist\n  $w2l_file2");
                                }
                                if ($prof_stat eq "Flow-weighted") {
                                    return &pop_up_error2($main,
                                           "Profile stat ($prof_stat) for Time/Distance Diff Map\n"
                                         . "inconsistent with use of W2 contour output file");
                                }
                            } elsif ($src_type2 =~ /RiverCon/i) {
                                if (! $got_riv_info2 || ! $got_riv_file2) {
                                    return &pop_up_error2($main,
                                        "W2 time/distance object has insufficient data on W2 RiverCon files");
                                }
                                for ($j=0; $j<=$#riv_files2; $j++) {
                                    if (! -e $riv_files2[$j] || -s $riv_files2[$j] == 0) {
                                        return &pop_up_error2($main,
                                               "W2 RiverCon file empty or does not exist\n  $riv_files2[$j]");
                                    }
                                }
                                if ($prof_stat eq "Flow-weighted" || $prof_stat eq "Volume-weighted") {
                                    return &pop_up_error2($main,
                                           "Profile stat ($prof_stat) for Time/Distance Diff Map\n"
                                         . "inconsistent with use of W2 RiverCon output file");
                                }
                            } elsif ($src_type2 =~ /SurfTemp|VolTemp|FlowTemp/i) {
                                if (! $got_src_file2) {
                                    return &pop_up_error2($main,
                                                          "W2 time/distance object failed to specify the "
                                                        . $src_type2 . " name");
                                }
                                if (! -e $src_file2 || -s $src_file2 == 0) {
                                    return &pop_up_error2($main, $src_type2
                                                               . " empty or does not exist\n  $src_file2");
                                }
                                if ($src_type2 =~ /SurfTemp/i) {
                                    if ($prof_stat ne "Surface value") {
                                        return &pop_up_error2($main,
                                               "Profile stat ($prof_stat) for Time/Distance Diff Map\n"
                                             . "inconsistent with use of W2 SurfTemp output file");
                                    }
                                } elsif ($src_type2 =~ /VolTemp/i) {
                                    if ($prof_stat ne "Volume-weighted") {
                                        return &pop_up_error2($main,
                                               "Profile stat ($prof_stat) for Time/Distance Diff Map\n"
                                             . "inconsistent with use of W2 VolTemp output file");
                                    }
                                } elsif ($src_type2 =~ /FlowTemp/i) {
                                    if ($prof_stat ne "Flow-weighted") {
                                        return &pop_up_error2($main,
                                               "Profile stat ($prof_stat) for Time/Distance Diff Map\n"
                                             . "inconsistent with use of W2 FlowTemp output file");
                                    }
                                }
                            }
                        }
                    }
                    $id = $canvas->create_rectangle(@coords,
                             -outline => &get_rgb_code($color),
                             -width   => $width,
                             -fill    => "",
                             -tags    => $tags);
                    $props{$id}{type}      = $type;
                    $props{$id}{meta}      = $meta;
                    $props{$id}{gnum}      = $gnum;
                    $props{$id}{x}         = $x;
                    $props{$id}{y}         = $y;
                    $props{$id}{xc}        = $xc;
                    $props{$id}{yc}        = $yc;
                    $props{$id}{anchor}    = $anchor;
                    $props{$id}{coordlist} = [ @coords ];
                    $props{$id}{oldcoords} = [ @coords ];
                    $props{$id}{color}     = $color;
                    $props{$id}{width}     = $width;
                    $props{$id}{fill}      = $fill;
                    $canvas->addtag("graph" . $id, withtag => $id);

                    if ($meta =~ /time_series/) {
                        %profile = ();

                    } elsif ($meta =~ /w2_profile/) {
                        %profile = ();
                        $props{$id}{files}      = 1;
                        $props{$id}{con_file}   = $con_file;
                        $props{$id}{bth_file}   = $bth_file;
                        $props{$id}{src_type}   = $src_type;
                        $props{$id}{src_file}   = $src_file;
                        $props{$id}{src_lines}  = $src_lines;
                        $props{$id}{tplot}      = $tplot;
                        $props{$id}{parm}       = $parm;
                        $props{$id}{parm_div}   = $parm_div;
                        $props{$id}{parm_units} = $parm_units;
                        $props{$id}{ctype}      = $ctype;
                        $props{$id}{seg}        = $seg;
                        $props{$id}{byear}      = $byear;
                        $props{$id}{tz_offset}  = $tz_offset;
                        $props{$id}{jd_skip}    = $jd_skip;

                        $confirm_type = &confirm_w2_ftype($main, $src_file);
                        if ($src_type =~ /Spreadsheet/i && $confirm_type ne "spr") {
                            return &pop_up_error2($main,
                                    "The W2 source file is not a W2 Spreadsheet file:\n$src_file");
                        } elsif ($src_type =~ /Contour/i && $confirm_type ne "cpl") {
                            return &pop_up_error2($main,
                                    "The W2 source file is not a W2 Contour file:\n$src_file");
                        } elsif ($src_type =~ /Vector/i && $confirm_type ne "w2l") {
                            return &pop_up_error2($main,
                                    "The W2 source file is not a W2 Vector (w2l) file:\n$src_file");
                        } elsif ($src_type =~ /LakeCon/i && $confirm_type ne "lcon1") {
                            return &pop_up_error2($main,
                                    "The W2 source file is not an acceptable\n"
                                  . "W2 Lake Contour (format 1) file:\n$src_file");
                        }

                        &read_con($main, $id, $con_file);
                        $nwb = $grid{$id}{nwb};
                        @bs  = @{ $grid{$id}{bs} };
                        @be  = @{ $grid{$id}{be} };
                        @us  = @{ $grid{$id}{us} };
                        @ds  = @{ $grid{$id}{ds} };
                        for ($jw=1; $jw<=$nwb; $jw++) {
                            last if ($seg >= $us[$bs[$jw]] && $seg <= $ds[$be[$jw]]);
                        }
                        &read_bth($main, $id, $jw, $bth_file);

                        if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
                            $canvas->g_bind("<Motion>", "");
                            Tkx::event_generate($main, "<Motion>", -warp => 1,
                                                                   -x => ($coords[0]+$coords[2])/2,
                                                                   -y => ($coords[1]+$coords[3])/2);
                            $canvas->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"),
                                                                           $canvas, "menu" ]);
                            $main->g_focus;
                        }

                        if ($src_type =~ /Spreadsheet/i) {
                            &get_grid_elevations($main, $id, $jw);
                            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $src_lines,
                                                                "Reading W2 spreadsheet file...");
                            ($kt_ref, $elev_ref, $parm_ref)
                                            = &read_w2_spr_file($main, $id, $src_file, $parm, $parm_div,
                                                                $byear, $seg, $tz_offset, $jd_skip, $pbar);
                            &destroy_progress_bar($main, $pbar_window);

                            %kt_data   = %{ $kt_ref   };
                            %elev_data = %{ $elev_ref };
                            %parm_data = %{ $parm_ref };

                        } elsif ($src_type =~ /Contour/i) {
                            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $src_lines,
                                                                "Reading W2 contour file...");
                            %data = &read_w2_cpl_file($main, $id, $jw, $src_file, $tplot, $seg, $parm,
                                                      $parm_div, $byear, $tz_offset, $jd_skip, $pbar);
                            &destroy_progress_bar($main, $pbar_window);

                            %kt_data   = ();
                            %elev_data = ();
                            %parm_data = ();
                            @mydates = keys %data;
                            for ($j=0; $j<=$#mydates; $j++) {
                                $dt    = $mydates[$j];
                                $kt    = $data{$dt}{kt};
                                @elws  = @{ $data{$dt}{elws}      };
                                @pdata = @{ $data{$dt}{parm_data} };
                                if (defined($elws[$seg])) {
                                    $elev_data{$dt} = $elws[$seg];
                                    for ($k=$kt; $k<=$#pdata; $k++) {
                                        $parm_data{$dt}[$k-$kt] = $pdata[$k][$seg];
                                    }
                                }
                                $kt_data{$dt} = $kt;
                            }
                            undef %data;

                        } elsif ($props{$id}{src_type} =~ /Vector/i) {
                            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, -s $src_file,
                                                                         "Reading W2 vector file...");
                            $status_line = "Reading W2 vector file... Date = 1";
                            %data = &read_w2_vector_file($main, $id, $src_file, $seg, $parm, $parm_div,
                                                         $byear, $tz_offset, $jd_skip, $pbar);
                            &destroy_progress_bar($main, $pbar_window);

                            %kt_data   = ();
                            %elev_data = ();
                            %parm_data = ();
                            @kb        = @{ $grid{$id}{kb} };
                            @mydates   = keys %data;
                            for ($j=0; $j<=$#mydates; $j++) {
                                $dt    = $mydates[$j];
                                $kt    = $data{$dt}{kt};
                                @pdata = @{ $data{$dt}{parm_data} };
                                if (defined($data{$dt}{elws}) && $data{$dt}{elws} != -99) {
                                    $elev_data{$dt} = $data{$dt}{elws};
                                    for ($k=$kt; $k<=$#pdata; $k++) {
                                        $parm_data{$dt}[$k-$kt] = $pdata[$k];
                                        last if ($k >= $kb[$seg]);
                                    }
                                }
                                $kt_data{$dt} = $kt;
                            }
                            undef %data;

                        } elsif ($props{$id}{src_type} =~ /LakeCon/i) {
                            &get_grid_elevations($main, $id, $jw);
                            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $src_lines,
                                                                         "Reading W2 Lake Contour file...");
                            ($kt_ref, $elev_ref, $parm_ref)
                                            = &read_w2_lakecon_file($main, $id, $src_file, $seg, $parm,
                                                                    $byear, $tz_offset, $jd_skip, $pbar);
                            &destroy_progress_bar($main, $pbar_window);

                            %kt_data   = %{ $kt_ref   };
                            %elev_data = %{ $elev_ref };
                            %parm_data = %{ $parm_ref };
                        }

                        if (&list_match($ctype, @conv_types) > 0 || $ctype =~ /^Custom,/) {
                            $status_line = "Converting units...";
                            Tkx::update_idletasks();
                            %parm_data = &convert_timeseries($main, $ctype, 1, %parm_data);
                            $status_line = "";
                            Tkx::update_idletasks();
                        }

                        %limits = &find_w2_profile_limits($id, $seg, \%elev_data, \%parm_data);
                        $profile{date_min}  = $limits{date_min};
                        $profile{date_max}  = $limits{date_max};
                        $profile{dpth_min}  = $limits{dpth_min};
                        $profile{dpth_max}  = $limits{dpth_max};
                        $profile{elev_min}  = $limits{elev_min};
                        $profile{elev_max}  = $limits{elev_max};
                        $profile{parm_min}  = $limits{parm_min};
                        $profile{parm_max}  = $limits{parm_max};
                        undef %limits;

                        $profile{kt_data}   = { %kt_data   };
                        $profile{elev_data} = { %elev_data };
                        $profile{parm_data} = { %parm_data };
                        $profile{ytype}     = $ytype;
                        $profile{yunits}    = $yunits;

                        if ($got_ref) {
                            $props{$id}{ref_file}  = $ref_file;
                            $props{$id}{ref_ctype} = $ref_ctype;
                            $props{$id}{ref_tol}   = $ref_tol;
                            $props{$id}{ref_color} = $ref_color;
                            $props{$id}{ref_hide}  = $ref_hide;

                            %ref_profile = &read_profile($main, $ref_file);
                            if (&list_match($ref_ctype, @conv_types) > 0 || $ref_ctype =~ /^Custom,/) {
                                %ref_data = %{ $ref_profile{pdata} };
                                %ref_data = &convert_timeseries($main, $ref_ctype, 1, %ref_data);
                                $ref_profile{pdata} = { %ref_data };
                            }
                            $profile{ref_data} = { %ref_profile };
                        }

                    } elsif ($meta =~ /w2_outflow/) {
                        %profile = ();
                        $props{$id}{files}      = 1;
                        $props{$id}{con_file}   = $con_file;
                        $props{$id}{bth_file}   = $bth_file;
                        $props{$id}{qla_file}   = $qla_file;
                        $props{$id}{qla_lines}  = $qla_lines;
                        $props{$id}{seg}        = $seg;
                        $props{$id}{byear}      = $byear;
                        $props{$id}{tz_offset}  = $tz_offset;
                        $props{$id}{jd_skip}    = $jd_skip;
                        $props{$id}{add_parm}   = $add_parm;
                        if ($add_parm) {
                            $props{$id}{src_type}   = $src_type;
                            $props{$id}{src_file}   = $src_file;
                            $props{$id}{src_lines}  = $src_lines;
                            $props{$id}{tplot}      = $tplot;
                            $props{$id}{parm}       = $parm;
                            $props{$id}{parm_div}   = $parm_div;
                            $props{$id}{parm_units} = $parm_units;
                            $props{$id}{parm_ctype} = $ctype;
                            $props{$id}{parm_skip}  = $parm_skip;
                            $props{$id}{match_tol}  = $match_tol;
                        }

                        &read_con($main, $id, $con_file);
                        $nwb = $grid{$id}{nwb};
                        @bs  = @{ $grid{$id}{bs} };
                        @be  = @{ $grid{$id}{be} };
                        @us  = @{ $grid{$id}{us} };
                        @ds  = @{ $grid{$id}{ds} };
                        for ($jw=1; $jw<=$nwb; $jw++) {
                            last if ($seg >= $us[$bs[$jw]] && $seg <= $ds[$be[$jw]]);
                        }
                        &read_bth($main, $id, $jw, $bth_file);
                        &get_grid_elevations($main, $id, $jw);

                        if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
                            $canvas->g_bind("<Motion>", "");
                            Tkx::event_generate($main, "<Motion>", -warp => 1,
                                                                   -x => ($coords[0]+$coords[2])/2,
                                                                   -y => ($coords[1]+$coords[3])/2);
                            $canvas->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"),
                                                                           $canvas, "menu" ]);
                            $main->g_focus;
                        }
                        ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $qla_lines,
                                                             "Reading W2 Layer Outflow file...");
                        ($q_ref, $v_ref) = &read_w2_layer_outflow($main, $id, $qla_file, $seg,
                                                                  $byear, $tz_offset, $jd_skip, $pbar);
                        &destroy_progress_bar($main, $pbar_window);

                        %qdata           = %{ $q_ref };
                        %vdata           = %{ $v_ref };
                        $profile{qdata}  = { %qdata };
                        $profile{vdata}  = { %vdata };
                        $profile{ytype}  = $ytype;
                        $profile{yunits} = $yunits;
                        $profile{qunits} = $qunits;

                        %limits = &find_w2_outflow_limits($id, $seg, \%qdata, \%vdata);
                        $profile{date_min} = $limits{date_min};
                        $profile{date_max} = $limits{date_max};
                        $profile{dpth_min} = $limits{dpth_min};
                        $profile{dpth_max} = $limits{dpth_max};
                        $profile{elev_min} = $limits{elev_min};
                        $profile{elev_max} = $limits{elev_max};
                        $profile{flow_min} = $limits{flow_min};
                        $profile{flow_max} = $limits{flow_max};
                        $profile{vel_min}  = $limits{vel_min};
                        $profile{vel_max}  = $limits{vel_max};
                        undef %limits;

                        if ($add_parm) {
                            $confirm_type = &confirm_w2_ftype($main, $src_file);
                            if ($src_type =~ /Spreadsheet/i && $confirm_type ne "spr") {
                                return &pop_up_error2($main,
                                        "The W2 source file is not a W2 Spreadsheet file:\n$src_file");
                            } elsif ($src_type =~ /Contour/i && $confirm_type ne "cpl") {
                                return &pop_up_error2($main,
                                        "The W2 source file is not a W2 Contour file:\n$src_file");
                            } elsif ($src_type =~ /Vector/i && $confirm_type ne "w2l") {
                                return &pop_up_error2($main,
                                        "The W2 source file is not a W2 Vector (w2l) file:\n$src_file");
                            } elsif ($src_type =~ /LakeCon/i && $confirm_type ne "lcon1") {
                                return &pop_up_error2($main,
                                        "The W2 source file is not an acceptable\n"
                                      . "W2 Lake Contour (format 1) file:\n$src_file");
                            }
                            if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
                                $canvas->g_bind("<Motion>", "");
                                Tkx::event_generate($main, "<Motion>", -warp => 1,
                                                                       -x => ($coords[0]+$coords[2])/2,
                                                                       -y => ($coords[1]+$coords[3])/2);
                                $canvas->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"),
                                                                               $canvas, "menu" ]);
                                $main->g_focus;
                            }

                            if ($props{$id}{src_type} =~ /Spreadsheet/i) {
                                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $src_lines,
                                                                 "Reading W2 spreadsheet file...");
                                ($kt_ref, $elev_ref, $parm_ref)
                                        = &read_w2_spr_file($main, $id, $src_file, $parm, $parm_div,
                                                            $byear, $seg, $tz_offset, $parm_skip, $pbar);
                                &destroy_progress_bar($main, $pbar_window);

                                %kt_data   = %{ $kt_ref   };
                                %elev_data = %{ $elev_ref };
                                %parm_data = %{ $parm_ref };

                            } elsif ($props{$id}{src_type} =~ /Contour/i) {
                                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $src_lines,
                                                                 "Reading W2 contour file...");
                                %data = &read_w2_cpl_file($main, $id, $jw, $src_file, $tplot, $seg, $parm,
                                                          $parm_div, $byear, $tz_offset, $parm_skip, $pbar);
                                &destroy_progress_bar($main, $pbar_window);

                                %kt_data   = ();
                                %elev_data = ();
                                %parm_data = ();
                                @mydates = keys %data;
                                for ($j=0; $j<=$#mydates; $j++) {
                                    $dt    = $mydates[$j];
                                    $kt    = $data{$dt}{kt};
                                    @elws  = @{ $data{$dt}{elws}      };
                                    @pdata = @{ $data{$dt}{parm_data} };
                                    if (defined($elws[$seg])) {
                                        $elev_data{$dt} = $elws[$seg];
                                        for ($k=$kt; $k<=$#pdata; $k++) {
                                            $parm_data{$dt}[$k-$kt] = $pdata[$k][$seg];
                                        }
                                    }
                                    $kt_data{$dt} = $kt;
                                }
                                undef %data;

                            } elsif ($props{$id}{src_type} =~ /Vector/i) {
                                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, -s $src_file,
                                                                             "Reading W2 vector file...");
                                $status_line = "Reading W2 vector file... Date = 1";
                                %data = &read_w2_vector_file($main, $id, $src_file, $seg, $parm, $parm_div,
                                                             $byear, $tz_offset, $parm_skip, $pbar);
                                &destroy_progress_bar($main, $pbar_window);

                                %kt_data   = ();
                                %elev_data = ();
                                %parm_data = ();
                                @kb        = @{ $grid{$id}{kb} };
                                @mydates   = keys %data;
                                for ($j=0; $j<=$#mydates; $j++) {
                                    $dt    = $mydates[$j];
                                    $kt    = $data{$dt}{kt};
                                    @pdata = @{ $data{$dt}{parm_data} };
                                    if (defined($data{$dt}{elws}) && $data{$dt}{elws} != -99) {
                                        $elev_data{$dt} = $data{$dt}{elws};
                                        for ($k=$kt; $k<=$#pdata; $k++) {
                                            $parm_data{$dt}[$k-$kt] = $pdata[$k];
                                            last if ($k >= $kb[$seg]);
                                        }
                                    }
                                    $kt_data{$dt} = $kt;
                                }
                                undef %data;

                            } elsif ($props{$id}{src_type} =~ /LakeCon/i) {
                                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $src_lines,
                                                                 "Reading W2 Lake Contour file...");
                                ($kt_ref, $elev_ref, $parm_ref)
                                        = &read_w2_lakecon_file($main, $id, $src_file, $seg, $parm,
                                                                $byear, $tz_offset, $parm_skip, $pbar);
                                &destroy_progress_bar($main, $pbar_window);

                                %kt_data   = %{ $kt_ref   };
                                %elev_data = %{ $elev_ref };
                                %parm_data = %{ $parm_ref };
                            }

                            if (&list_match($ctype, @conv_types) > 0 || $ctype =~ /^Custom,/) {
                                $status_line = "Converting units...";
                                Tkx::update_idletasks();
                                %parm_data = &convert_timeseries($main, $ctype, 1, %parm_data);
                                $status_line = "";
                                Tkx::update_idletasks();
                            }
                            %limits = &find_w2_profile_limits($id, $seg, \%elev_data, \%parm_data);
                            $profile{parm_min}  = $limits{parm_min};
                            $profile{parm_max}  = $limits{parm_max};
                            undef %limits;

                            $profile{kt_data}   = { %kt_data   };
                            $profile{elev_data} = { %elev_data };
                            $profile{parm_data} = { %parm_data };
                        }

                    } elsif ($meta =~ /w2_slice/) {
                        %profile = ();
                        $props{$id}{files}      = 1;
                        $props{$id}{con_file}   = $con_file;
                        $props{$id}{src_type}   = $src_type;
                        $props{$id}{seg_list}   = $seg_list;
                        $props{$id}{wb_list}    = $wb_list;
                        $props{$id}{parm}       = $parm;
                        $props{$id}{parm_div}   = $parm_div;
                        $props{$id}{parm_units} = $parm_units;
                        $props{$id}{ctype}      = $ctype;
                        $props{$id}{byear}      = $byear;
                        $props{$id}{tz_offset}  = $tz_offset;
                        $props{$id}{jd_skip}    = $jd_skip;
                        $props{$id}{dt_limits}  = $dt_limits;
                        if ($src_type =~ /Contour/i) {
                            $props{$id}{tecplot}   = [ @tecplot   ];
                            $props{$id}{cpl_lines} = [ @cpl_lines ];
                            $props{$id}{cpl_files} = [ @cpl_files ];
                            $props{$id}{bth_files} = [ @bth_files ];
                        } elsif ($src_type =~ /Vector/i) {
                            $props{$id}{w2l_file}  = $w2l_file;
                            $props{$id}{bth_files} = [ @bth_files ];
                        }

                        if ($dt_limits) {
                            $props{$id}{dt_begin} = $dt_begin;
                            $props{$id}{dt_end}   = $dt_end;
                            if ($dt_begin =~ /[a-z][a-z][a-z]-[0-3]?[0-9]-[12][0-9][0-9][0-9]/i) {
                                ($mon, $day, $yr) = &parse_date($dt_begin, 1);
                                $dt_begin = sprintf("%04d%02d%02d0000", $yr, $mon, $day);
                            } else {
                                $dt_begin = -999;
                            }
                            if ($dt_end =~ /[a-z][a-z][a-z]-[0-3]?[0-9]-[12][0-9][0-9][0-9]/i) {
                                ($mon, $day, $yr) = &parse_date($dt_end, 1);
                                $dt_end = sprintf("%04d%02d%02d0000", $yr, $mon, $day);
                            } else {
                                $dt_end = -999;
                            }
                            $props{$id}{dt_limits} = 0 if ($dt_begin == -999 || $dt_end == -999);
                        } else {
                            $dt_begin = $dt_end = -999;
                        }

                        &read_con($main, $id, $con_file);
                        $status_line = "Reading bathymetry files...";
                        Tkx::update_idletasks();
                        for ($n=0; $n<=$#wbs; $n++) {
                            &read_bth($main, $id, $wbs[$n], $bth_files[$n]);
                        }
                        $status_line = "";
                        Tkx::update_idletasks();

                        if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
                            $canvas->g_bind("<Motion>", "");
                            Tkx::event_generate($main, "<Motion>", -warp => 1,
                                                                   -x => ($coords[0]+$coords[2])/2,
                                                                   -y => ($coords[1]+$coords[3])/2);
                            $canvas->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"),
                                                                           $canvas, "menu" ]);
                            $main->g_focus;
                        }

                        if ($src_type =~ /Contour/i) {
                            for ($n=0; $n<=$#wbs; $n++) {
                                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $cpl_lines[$n],
                                                             "Reading W2 contour file...");
                                %sdata = &read_w2_cpl_file($main, $id, $wbs[$n], $cpl_files[$n],
                                                           $tecplot[$n], 0, $parm, $parm_div, $byear,
                                                           $tz_offset, $jd_skip, $pbar, $dt_begin, $dt_end);
                                &destroy_progress_bar($main, $pbar_window);

                                if (&list_match($ctype, @conv_types) > 0 || $ctype =~ /^Custom,/) {
                                    $status_line = "Converting units...";
                                    Tkx::update_idletasks();
                                    %sdata = &convert_slice_data($main, $ctype, $id, $wbs[$n], %sdata);
                                    $status_line = "";
                                    Tkx::update_idletasks();
                                }
                                $slice_data[$n] = { %sdata };
                            }
                        } elsif ($src_type =~ /Vector/i) {
                            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, -s $w2l_file,
                                                         "Reading W2 vector file...");
                            $status_line = "Reading W2 vector file... Date = 1";
                            %sdata = &read_w2_vector_file($main, $id, $w2l_file, 0, $parm, $parm_div,
                                                          $byear, $tz_offset, $jd_skip, $pbar,
                                                          $dt_begin, $dt_end);
                            &destroy_progress_bar($main, $pbar_window);

                            if (&list_match($ctype, @conv_types) > 0 || $ctype =~ /^Custom,/) {
                                $status_line = "Converting units...";
                                Tkx::update_idletasks();
                                %sdata = &convert_slice_data($main, $ctype, $id, 'all', %sdata);
                                $status_line = "";
                                Tkx::update_idletasks();
                            }
                            $slice_data[0] = { %sdata };
                        }
                        $profile{slice_data} = [ @slice_data ];
                        undef %sdata;

                        %limits = &find_w2_slice_limits($id, %profile);
                        $profile{date_min}  = $limits{date_min};
                        $profile{date_max}  = $limits{date_max};
                        $profile{dpth_min}  = $limits{dpth_min};
                        $profile{dpth_max}  = $limits{dpth_max};
                        $profile{elev_min}  = $limits{elev_min};
                        $profile{elev_max}  = $limits{elev_max};
                        $profile{parm_min}  = $limits{parm_min};
                        $profile{parm_max}  = $limits{parm_max};
                        undef %limits;

                        $profile{ytype}     = $ytype;
                        $profile{yunits}    = $yunits;
                        $profile{xflip}     = $xflip;
                        $profile{xunits}    = $xunits;
                        $profile{xflip_img} = 0;
                        $profile{xmax_auto} = $xmax_auto;

                    } elsif ($meta =~ /w2_tdmap/) {
                        %profile = ();
                        $props{$id}{files}      = 1;
                        $props{$id}{map_type}   = $map_type;
                        $props{$id}{con_file}   = $con_file;
                        $props{$id}{src_type}   = $src_type;
                        $props{$id}{seg_list}   = $seg_list;
                        $props{$id}{wb_list}    = $wb_list;
                        $props{$id}{parm}       = $parm;
                        $props{$id}{parm_sav}   = $parm;
                        $props{$id}{parm_div}   = $parm_div;
                        $props{$id}{pdiv_sav}   = $parm_div;
                        $props{$id}{parm_units} = $parm_units;
                        $props{$id}{prof_stat}  = $prof_stat;
                        $props{$id}{ctype}      = $ctype;
                        $props{$id}{byear}      = $byear;
                        $props{$id}{tz_offset}  = $tz_offset;
                        $props{$id}{jd_skip}    = $jd_skip;

                        if ($src_type =~ /Contour/i) {
                            $props{$id}{tecplot}   = [ @tecplot   ];
                            $props{$id}{cpl_lines} = [ @cpl_lines ];
                            $props{$id}{cpl_files} = [ @cpl_files ];
                            $props{$id}{bth_files} = [ @bth_files ];
                        } elsif ($src_type =~ /Vector/i) {
                            $props{$id}{w2l_file}  = $w2l_file;
                            $props{$id}{bth_files} = [ @bth_files ];
                        } elsif ($src_type =~ /RiverCon/i) {
                            $br_list =~ s/,$//;
                            $props{$id}{br_list}   = $br_list;
                            $props{$id}{riv_lines} = [ @riv_lines ];
                            $props{$id}{riv_files} = [ @riv_files ];
                            $props{$id}{bth_files} = [ @bth_files ];
                        } elsif ($src_type =~ /SurfTemp|VolTemp|FlowTemp/i) {
                            $props{$id}{src_file}  = $src_file;
                            $props{$id}{src_lines} = $src_lines;
                            $props{$id}{bth_files} = [ @bth_files ];
                        }
                        if ($map_type eq "parmdiff") {
                            $props{$id}{src_type2}  = $src_type2 = $src_type;
                            $props{$id}{parm2}      = $parm2;
                            $props{$id}{parm2_sav}  = $parm2;
                            $props{$id}{parm2_div}  = $parm2_div;
                            $props{$id}{pdiv2_sav}  = $parm2_div;
                            $props{$id}{ctype2}     = $ctype2;
                            $props{$id}{swap_order} = $swap_order;
                            if ($src_type2 =~ /Contour/i) {
                                @tecplot2   = @tecplot;
                                @cpl_lines2 = @cpl_lines;
                                @cpl_files2 = @cpl_files;
                                $props{$id}{tecplot2}   = [ @tecplot2   ];
                                $props{$id}{cpl_lines2} = [ @cpl_lines2 ];
                                $props{$id}{cpl_files2} = [ @cpl_files2 ];
                            } elsif ($src_type2 =~ /Vector/i) {
                                $props{$id}{w2l_file2}  = $w2l_file2  = $w2l_file;
                            } elsif ($src_type2 =~ /RiverCon/i) {
                                $br_list2   = $br_list;
                                @riv_lines2 = @riv_lines;
                                @riv_files2 = @riv_files;
                                $props{$id}{br_list2}   = $br_list2;
                                $props{$id}{riv_lines2} = [ @riv_lines2 ];
                                $props{$id}{riv_files2} = [ @riv_files2 ];
                            } elsif ($src_type2 =~ /SurfTemp|VolTemp|FlowTemp/i) {
                                $props{$id}{src_file2}  = $src_file2  = $src_file;
                                $props{$id}{src_lines2} = $src_lines2 = $src_lines;
                            }
                        } elsif ($map_type eq "filediff") {
                            $props{$id}{src_type2}  = $src_type2;
                            $props{$id}{parm2}      = $parm2     = $parm;
                            $props{$id}{parm2_sav}  = $parm2     = $parm;
                            $props{$id}{parm2_div}  = $parm2_div = $parm_div;
                            $props{$id}{pdiv2_sav}  = $parm2_div = $parm_div;
                            $props{$id}{ctype2}     = $ctype2    = $ctype;
                            $props{$id}{match_tol}  = $match_tol;
                            $props{$id}{swap_order} = $swap_order;
                            if ($src_type2 =~ /Contour/i) {
                                $props{$id}{tecplot2}   = [ @tecplot2   ];
                                $props{$id}{cpl_lines2} = [ @cpl_lines2 ];
                                $props{$id}{cpl_files2} = [ @cpl_files2 ];
                            } elsif ($src_type2 =~ /Vector/i) {
                                $props{$id}{w2l_file2}  = $w2l_file2;
                            } elsif ($src_type2 =~ /RiverCon/i) {
                                $br_list2 =~ s/,$//;
                                $props{$id}{br_list2}   = $br_list2;
                                $props{$id}{riv_lines2} = [ @riv_lines2 ];
                                $props{$id}{riv_files2} = [ @riv_files2 ];
                            } elsif ($src_type2 =~ /SurfTemp|VolTemp|FlowTemp/i) {
                                $props{$id}{src_file2}  = $src_file2;
                                $props{$id}{src_lines2} = $src_lines2;
                            }
                        }

                        &read_con($main, $id, $con_file);
                        $status_line = "Reading bathymetry files...";
                        Tkx::update_idletasks();
                        for ($n=0; $n<=$#wbs; $n++) {
                            &read_bth($main, $id, $wbs[$n], $bth_files[$n]);
                        }
                        $status_line = "";
                        Tkx::update_idletasks();

                        if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
                            $canvas->g_bind("<Motion>", "");
                            Tkx::event_generate($main, "<Motion>", -warp => 1,
                                                                   -x => ($coords[0]+$coords[2])/2,
                                                                   -y => ($coords[1]+$coords[3])/2);
                            $canvas->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"),
                                                                           $canvas, "menu" ]);
                            $main->g_focus;
                        }

                        if ($src_type =~ /Contour/i) {
                            for ($n=0; $n<=$#wbs; $n++) {
                                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $cpl_lines[$n],
                                                             "Reading W2 contour file...");
                                %sdata = &read_w2_cpl_file($main, $id, $wbs[$n], $cpl_files[$n],
                                                           $tecplot[$n], 0, $parm, $parm_div, $byear,
                                                           $tz_offset, $jd_skip, $pbar);
                                &destroy_progress_bar($main, $pbar_window);

                                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, 10,
                                                             "Computing profile stats...");
                                %tmp_data = &compute_pstat_from_slice($main, $id, $prof_stat,
                                                                      $wbs[$n], $pbar, %sdata);
                                &destroy_progress_bar($main, $pbar_window);

                                if ($#wbs == 0 || $n == 0) {
                                    %td_data = %tmp_data;
                                    @mydates = keys %td_data;
                                    $dsum    = &sum(@mydates);
                                } else {
                                    @mydates = keys %tmp_data;
                                    if ($dsum != &sum(@mydates)) {
                                        &pop_up_info($main,
                                                     "Contour file dates for waterbody " . $wbs[$n] . "\n"
                                                   . "do not match those for waterbody " . $wbs[0] . "\n"
                                                   . "This could lead to visualization problems.");
                                    }
                                    foreach $dt (@mydates) {                             # each date/time
                                        foreach $seg (keys %{ $tmp_data{$dt} }) {        # each segment
                                            $td_data{$dt}{$seg} = $tmp_data{$dt}{$seg};
                                        }
                                    }
                                }
                                undef %sdata;
                                undef %tmp_data;
                            }
                        } elsif ($src_type =~ /Vector/i) {
                            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, -s $w2l_file,
                                                         "Reading W2 vector file...");
                            $status_line = "Reading W2 vector file... Date = 1";
                            %sdata = &read_w2_vector_file($main, $id, $w2l_file, 0, $parm, $parm_div,
                                                          $byear, $tz_offset, $jd_skip, $pbar);
                            &destroy_progress_bar($main, $pbar_window);

                            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, 10,
                                                         "Computing profile stats...");
                            %td_data = &compute_pstat_from_slice($main, $id, $prof_stat,
                                                                 "all", $pbar, %sdata);
                            &destroy_progress_bar($main, $pbar_window);
                            undef %sdata;

                        } elsif ($src_type =~ /RiverCon/i) {
                            @brs = split(/,/, $br_list);
                            for ($n=0; $n<=$#brs; $n++) {
                                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $riv_lines[$n],
                                                                             "Reading W2 RiverCon file...");
                                %tmp_data = &read_w2_rivcon_file($main, $id, $riv_files[$n], $parm, $brs[$n],
                                                                 $byear, $tz_offset, $jd_skip, $pbar);
                                &destroy_progress_bar($main, $pbar_window);

                                if ($#brs == 0 || $n == 0) {
                                    %td_data = %tmp_data;
                                    @mydates = keys %td_data;
                                    $dsum    = &sum(@mydates);
                                } else {
                                    @mydates = keys %tmp_data;
                                    if ($dsum != &sum(@mydates)) {
                                        &pop_up_info($main,
                                                     "RiverCon file dates for branch " . $brs[$n] . "\n"
                                                   . "do not match those for branch " . $brs[0] . "\n"
                                                   . "This could lead to visualization problems.");
                                    }
                                    foreach $dt (@mydates) {                             # each date/time
                                        foreach $seg (keys %{ $tmp_data{$dt} }) {        # each segment
                                            $td_data{$dt}{$seg} = $tmp_data{$dt}{$seg};
                                        }
                                    }
                                }
                                undef %tmp_data;
                            }

                        } elsif ($src_type =~ /SurfTemp|VolTemp|FlowTemp/i) {
                            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $src_lines,
                                                         "Reading " . $src_type . "...");
                            %td_data = &read_w2_flowtemp_alt($main, $src_file, $parm, $parm_div,
                                                             $byear, $tz_offset, $jd_skip, $pbar);
                            &destroy_progress_bar($main, $pbar_window);
                        }

                        if (&list_match($ctype, @conv_types) > 0 || $ctype =~ /^Custom,/) {
                            $status_line = "Converting units...";
                            Tkx::update_idletasks();
                            %td_data = &convert_tdmap_data($main, $ctype, %td_data);
                            $status_line = "";
                            Tkx::update_idletasks();
                        }
                        $profile{td_data} = { %td_data };

                        if ($props{$id}{map_type} =~ /^(parmdiff|filediff)$/) {
                            if ($src_type2 =~ /Contour/i) {
                                for ($n=0; $n<=$#wbs; $n++) {
                                    ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300,
                                                              $cpl_lines2[$n], "Reading W2 contour file...");
                                    %sdata = &read_w2_cpl_file($main, $id, $wbs[$n], $cpl_files2[$n],
                                                               $tecplot2[$n], 0, $parm2, $parm2_div,
                                                               $byear, $tz_offset, $jd_skip, $pbar);
                                    &destroy_progress_bar($main, $pbar_window);

                                    ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, 10,
                                                                             "Computing profile stats...");
                                    %tmp_data = &compute_pstat_from_slice($main, $id, $props{$id}{prof_stat},
                                                                          $wbs[$n], $pbar, %sdata);
                                    &destroy_progress_bar($main, $pbar_window);

                                    if ($#wbs == 0 || $n == 0) {
                                        %td_data = %tmp_data;
                                        @mydates = keys %td_data;
                                        $dsum    = &sum(@mydates);
                                    } else {
                                        @mydates = keys %tmp_data;
                                        if ($dsum != &sum(@mydates)) {
                                            &pop_up_info($main,
                                                         "Contour file dates for waterbody " . $wbs[$n] . "\n"
                                                       . "do not match those for waterbody " . $wbs[0] . "\n"
                                                       . "This could lead to visualization problems.");
                                        }
                                        foreach $dt (@mydates) {                           # each date/time
                                            foreach $seg (keys %{ $tmp_data{$dt} }) {      # each segment
                                                $td_data{$dt}{$seg} = $tmp_data{$dt}{$seg};
                                            }
                                        }
                                    }
                                    undef %sdata;
                                    undef %tmp_data;
                                }

                            } elsif ($src_type2 =~ /Vector/i) {
                                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, -s $w2l_file2,
                                                                             "Reading W2 vector file...");
                                $status_line = "Reading W2 vector file... Date = 1";
                                %sdata = &read_w2_vector_file($main, $id, $w2l_file2, 0, $parm2, $parm2_div,
                                                              $byear, $tz_offset, $jd_skip, $pbar);
                                &destroy_progress_bar($main, $pbar_window);

                                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, 10,
                                                                             "Computing profile stats...");
                                %td_data = &compute_pstat_from_slice($main, $id, $prof_stat,
                                                                     "all", $pbar, %sdata);
                                &destroy_progress_bar($main, $pbar_window);
                                undef %sdata;

                            } elsif ($src_type2 =~ /RiverCon/i) {
                                @brs = split(/,/, $br_list2);
                                for ($n=0; $n<=$#brs; $n++) {
                                    ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300,
                                                              $riv_lines2[$n], "Reading W2 RiverCon file...");
                                    %tmp_data = &read_w2_rivcon_file($main, $id, $riv_files2[$n], $parm2,
                                                                     $brs[$n], $byear, $tz_offset,
                                                                     $jd_skip, $pbar);
                                    &destroy_progress_bar($main, $pbar_window);

                                    if ($#brs == 0 || $n == 0) {
                                        %td_data = %tmp_data;
                                        @mydates = keys %td_data;
                                        $dsum    = &sum(@mydates);
                                    } else {
                                        @mydates = keys %tmp_data;
                                        if ($dsum != &sum(@mydates)) {
                                            &pop_up_info($main,
                                                         "RiverCon file dates for branch " . $brs[$n] . "\n"
                                                       . "do not match those for branch " . $brs[0] . "\n"
                                                       . "This could lead to visualization problems.");
                                        }
                                        foreach $dt (@mydates) {                           # each date/time
                                            foreach $seg (keys %{ $tmp_data{$dt} }) {      # each segment
                                                $td_data{$dt}{$seg} = $tmp_data{$dt}{$seg};
                                            }
                                        }
                                    }
                                    undef %tmp_data;
                                }

                            } elsif ($src_type2 =~ /SurfTemp|VolTemp|FlowTemp/i) {
                                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $src_lines2,
                                                                             "Reading " . $src_type2 . "...");
                                %td_data = &read_w2_flowtemp_alt($main, $src_file2, $parm2, $parm2_div,
                                                                 $byear, $tz_offset, $jd_skip, $pbar);
                                &destroy_progress_bar($main, $pbar_window);
                            }

                            if (&list_match($ctype2, @conv_types) > 0 || $ctype2 =~ /^Custom,/) {
                                $status_line = "Converting units...";
                                Tkx::update_idletasks();
                                %td_data = &convert_tdmap_data($main, $ctype2, %td_data);
                                $status_line = "";
                                Tkx::update_idletasks();
                            }

#                           Compute differences
                            %tmp_data = %{ $profile{td_data} };                 # data for parameter 1
                            if ($props{$id}{map_type} eq "parmdiff") {
                                foreach $dt (keys %tmp_data) {                  # each date/time
                                    foreach $seg (keys %{ $tmp_data{$dt} }) {   # each segment
                                        if (! defined($td_data{$dt}{$seg}) || $td_data{$dt}{$seg}  == -99
                                                                           || $tmp_data{$dt}{$seg} == -99) {
                                            $tmp_data{$dt}{$seg} = -99;
                                        } else {
                                            $tmp_data{$dt}{$seg} -= $td_data{$dt}{$seg};
                                        }
                                    }
                                }
                            } elsif ($props{$id}{map_type} eq "filediff") {
                                foreach $dt (keys %tmp_data) {                  # each date/time
                                    $dt2 = $dt;
                                    if (! defined($td_data{$dt2}) && $props{$id}{match_tol} > 0) {
                                        for ($mi=1; $mi<=$props{$id}{match_tol}; $mi++) {
                                            $dt_adj = &adjust_dt($dt2, $mi);
                                            if (defined($td_data{$dt_adj})) {
                                                $dt2 = $dt_adj;
                                                last;
                                            }
                                            $dt_adj = &adjust_dt($dt2, -1 *$mi);
                                            if (defined($td_data{$dt_adj})) {
                                                $dt2 = $dt_adj;
                                                last;
                                            }
                                        }
                                    }
                                    foreach $seg (keys %{ $tmp_data{$dt} }) {   # each segment
                                        if (! defined($td_data{$dt2}{$seg}) || $td_data{$dt2}{$seg} == -99
                                                                            || $tmp_data{$dt}{$seg} == -99) {
                                            $tmp_data{$dt}{$seg} = -99;
                                        } else {
                                            $tmp_data{$dt}{$seg} -= $td_data{$dt2}{$seg};
                                        }
                                    }
                                }
                            }
                            if ($swap_order) {                                  # swap order of difference
                                foreach $dt (keys %tmp_data) {                  # each date/time
                                    foreach $seg (keys %{ $tmp_data{$dt} }) {   # each segment
                                        if ($tmp_data{$dt}{$seg} != -99) {
                                            $tmp_data{$dt}{$seg} *= -1.0;
                                        }
                                    }
                                }
                            }
                            %td_data           = %tmp_data;
                            $profile{td_data}  = { %td_data };
                            $props{$id}{data2} = 1;
                            undef %tmp_data;
                        }

                        %limits = &find_w2_tdmap_limits($id, %td_data);
                        $profile{date_min} = $limits{date_min};
                        $profile{date_max} = $limits{date_max};
                        $profile{parm_min} = $limits{parm_min};
                        $profile{parm_max} = $limits{parm_max};
                        undef %limits;

                        if ($props{$id}{parm} =~ /^(Temperature|TEMP|Tmin|Tmean|Tmax)$/) {
                            $props{$id}{parm} = "Temperature";
                        }
                        if ($props{$id}{parm_div} =~ /^(Temperature|TEMP|Tmin|Tmean|Tmax)$/) {
                            $props{$id}{parm_div} = "Temperature";
                        }
                        if ($props{$id}{map_type} =~ /^(parmdiff|filediff)$/) {
                            if ($props{$id}{parm2} =~ /^(Temperature|TEMP|Tmin|Tmean|Tmax)$/) {
                                $props{$id}{parm2} = "Temperature";
                            }
                            if ($props{$id}{parm2_div} =~ /^(Temperature|TEMP|Tmin|Tmean|Tmax)$/) {
                                $props{$id}{parm2_div} = "Temperature";
                            }
                        }

                    } elsif ($meta =~ /w2_wlevels/) {
                        %profile = ();
                        $props{$id}{files}     = 1;
                        $props{$id}{con_file}  = $con_file;
                        $props{$id}{src_type}  = $src_type;
                        $props{$id}{seg_list}  = $seg_list;
                        $props{$id}{wb_list}   = $wb_list;
                        $props{$id}{byear}     = $byear;
                        $props{$id}{tz_offset} = $tz_offset;
                        $props{$id}{jd_skip}   = $jd_skip;
                        if ($src_type =~ /Contour/i) {
                            $props{$id}{extra_chk} = 0;
                            $props{$id}{tecplot}   = [ @tecplot   ];
                            $props{$id}{cpl_lines} = [ @cpl_lines ];
                            $props{$id}{cpl_files} = [ @cpl_files ];
                            $props{$id}{bth_files} = [ @bth_files ];
                        } elsif ($src_type =~ /Vector/i) {
                            $props{$id}{extra_chk} = 0;
                            $props{$id}{w2l_file}  = $w2l_file;
                            $props{$id}{bth_files} = [ @bth_files ];
                        } elsif ($src_type =~ /Water Level/i) {
                            $props{$id}{extra_chk} = $extra_chk;
                            $props{$id}{wl_file}   = $wl_file;
                            $props{$id}{wl_lines}  = $wl_lines;
                            $props{$id}{bth_files} = [ @bth_files ];
                        }

                        &read_con($main, $id, $con_file);
                        $status_line = "Reading bathymetry files...";
                        Tkx::update_idletasks();
                        for ($n=0; $n<=$#wbs; $n++) {
                            &read_bth($main, $id, $wbs[$n], $bth_files[$n]);
                            &get_grid_elevations($main, $id, $wbs[$n]);
                        }
                        $status_line = "";
                        Tkx::update_idletasks();

                        if ($src_type =~ /Contour|Vector/i) {
                            @bs = @{ $grid{$id}{bs} };
                            @be = @{ $grid{$id}{be} };
                            @us = @{ $grid{$id}{us} };
                            @ds = @{ $grid{$id}{ds} };
                        }

                        if (Tkx::winfo_pointerx($main) != -1 && Tkx::winfo_pointery($main) != -1) {
                            $canvas->g_bind("<Motion>", "");
                            Tkx::event_generate($main, "<Motion>", -warp => 1,
                                                                   -x => ($coords[0]+$coords[2])/2,
                                                                   -y => ($coords[1]+$coords[3])/2);
                            $canvas->g_bind("<Motion>", [ \&object_select, Tkx::Ev("%x","%y"),
                                                                           $canvas, "menu" ]);
                            $main->g_focus;
                        }

                        if ($src_type =~ /Contour/i) {
                            for ($n=0; $n<=$#wbs; $n++) {
                                $jw = $wbs[$n];
                                ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $cpl_lines[$n],
                                                             "Reading W2 contour file...");
                                %sdata = &read_w2_cpl_file($main, $id, $jw, $cpl_files[$n],
                                                           $tecplot[$n], 0, "Temperature", "None",
                                                           $byear, $tz_offset, $jd_skip, $pbar);
                                $nd      = 0;
                                @mydates = sort keys %sdata;
                                $pbar_window->g_wm_title("Processing data...");
                                $status_line = "";
                                Tkx::update_idletasks();
                                &reset_progress_bar($pbar, $#mydates +1, "Processing data... Date = 1");

#                               Consolidate data from different waterbodies
                                if ($#wbs == 0 || $n == 0) {
                                    $dsum    = &sum(@mydates);
                                    %wl_data = ();
                                    foreach $dt (@mydates) {
                                        &update_progress_bar($pbar, ++$nd, $dt);
                                        @cus  = @{ $sdata{$dt}{cus}  };
                                        @elws = @{ $sdata{$dt}{elws} };
                                        for ($jb=$bs[$jw]; $jb<=$be[$jw]; $jb++) {
                                            for ($i=$us[$jb]; $i<=$ds[$jb]; $i++) {
                                                if (! defined($cus[$jb]) || ! defined($elws[$i])
                                                                         || $i < $cus[$jb]) {
                                                    $wl_data{$dt}[$i] = -999;
                                                } else {
                                                    $wl_data{$dt}[$i] = $elws[$i];
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if ($dsum != &sum(@mydates)) {
                                        &pop_up_info($main,
                                                     "Contour file dates for waterbody " . $wbs[$n] . "\n"
                                                   . "do not match those for waterbody " . $wbs[0] . "\n"
                                                   . "This could lead to visualization problems.");
                                    }
                                    foreach $dt (@mydates) {
                                        &update_progress_bar($pbar, ++$nd, $dt);
                                        @cus  = @{ $sdata{$dt}{cus}  };
                                        @elws = @{ $sdata{$dt}{elws} };
                                        for ($jb=$bs[$jw]; $jb<=$be[$jw]; $jb++) {
                                            for ($i=$us[$jb]; $i<=$ds[$jb]; $i++) {
                                                if (! defined($cus[$jb]) || ! defined($elws[$i])
                                                                         || $i < $cus[$jb]) {
                                                    $wl_data{$dt}[$i] = -999;
                                                } else {
                                                    $wl_data{$dt}[$i] = $elws[$i];
                                                }
                                            }
                                        }
                                    }
                                }
                                &destroy_progress_bar($main, $pbar_window);
                                $status_line = "Cleaning up...                           ";
                                Tkx::update_idletasks();
                                undef %sdata;
                                undef @cus;
                                undef @elws;
                            }

                        } elsif ($src_type =~ /Vector/i) {
                            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, -s $w2l_file,
                                                         "Reading W2 vector file...");
                            $status_line = "Reading W2 vector file... Date = 1";
                            %sdata = &read_w2_vector_file($main, $id, $w2l_file, 0, "Temperature", "None",
                                                          $byear, $tz_offset, $jd_skip, $pbar);
                            @mydates = sort keys %sdata;
                            $pbar_window->g_wm_title("Processing data...");
                            $status_line = "";
                            Tkx::update_idletasks();
                            &reset_progress_bar($pbar, $#mydates +1, "Processing data... Date = 1");

                            $nd      = 0;
                            %wl_data = ();
                            foreach $dt (@mydates) {
                                &update_progress_bar($pbar, ++$nd, $dt);
                                @cus  = @{ $sdata{$dt}{cus}  };
                                @elws = @{ $sdata{$dt}{elws} };
                                for ($jb=1; $jb<=$grid{$id}{nbr}; $jb++) {
                                    for ($i=$us[$jb]; $i<=$ds[$jb]; $i++) {
                                        if (! defined($cus[$jb]) || ! defined($elws[$i])
                                                                 || $i < $cus[$jb]) {
                                            $wl_data{$dt}[$i] = -999;
                                        } else {
                                            $wl_data{$dt}[$i] = $elws[$i];
                                        }
                                    }
                                }
                            }
                            &destroy_progress_bar($main, $pbar_window);
                            $status_line = "Cleaning up...                           ";
                            Tkx::update_idletasks();
                            undef %sdata;
                            undef @cus;
                            undef @elws;

                        } elsif ($src_type =~ /Water Level/i) {
                            ($pbar_window, $pbar) = &create_progress_bar($main, $id, 300, $wl_lines,
                                                                 "Reading W2 water levels file...");
                            %wl_data = &read_w2_wlevel($main, $id, $wl_file, $byear, $tz_offset,
                                                       "all", $jd_skip, $extra_chk, $pbar);
                            &destroy_progress_bar($main, $pbar_window);
                        }
                        $profile{wl_data} = { %wl_data };

                        %limits = &find_w2_wlevel_limits($id, %wl_data);
                        $profile{date_min} = $limits{date_min};
                        $profile{date_max} = $limits{date_max};
                        $profile{elev_min} = $limits{elev_min};
                        $profile{elev_max} = $limits{elev_max};
                        undef %limits;

                        $profile{yunits}    = $yunits;
                        $profile{xflip}     = $xflip;
                        $profile{xunits}    = $xunits;
                        $profile{xmax_auto} = $xmax_auto;

                    } elsif ($meta =~ /data_profile/) {
                        $props{$id}{files}      = 1;
                        $props{$id}{src_file}   = $src_file;
                        $props{$id}{parm}       = $parm;
                        $props{$id}{parm_units} = $parm_units;
                        %profile                = &read_profile($main, $src_file);

                        %limits            = &find_data_limits($id, %profile);
                        $profile{date_min} = $limits{date_min};
                        $profile{date_max} = $limits{date_max};
                        $profile{dpth_min} = $limits{dpth_min};
                        $profile{dpth_max} = $limits{dpth_max};
                        $profile{elev_min} = $limits{elev_min};
                        $profile{elev_max} = $limits{elev_max};
                        $profile{parm_min} = $limits{parm_min};
                        $profile{parm_max} = $limits{parm_max};
                        undef %limits;

                        $props{$id}{prof_type}  = $prof_type;
                        if ($prof_type =~ /difference/i) {
                            $props{$id}{dref_type} = $dref_type;
                            if ($dref_type =~ /Constant/i) {
                                $props{$id}{dref_val} = $dref_val;
                            } else {
                                $props{$id}{dref_file}  = $dref_file;
                                $props{$id}{dref_ftype} = $dref_ftype;
                                $props{$id}{dref_lines} = $dref_lines;
                                $props{$id}{dref_parm}  = $dref_parm;
                                $props{$id}{dref_ctype} = $dref_ctype;
                                $props{$id}{dref_tol}   = $dref_tol;
                                if ($props{$id}{dref_ftype} =~ /^W2 /) {
                                    $props{$id}{dref_byear} = $dref_byear;
                                    $props{$id}{dref_tzoff} = $dref_tzoff;
                                }
                            }
                        }
                        $profile{ytype}  = $ytype;
                        $profile{yunits} = $yunits;

                    } elsif ($meta eq "vert_wd_zone") {
                        $props{$id}{files}     = 1;
                        $props{$id}{wt_file}   = $wt_file;
                        $props{$id}{wt_units}  = $wt_units;
                        %profile               = &read_profile($main, $wt_file);

                        $props{$id}{flow_file} = $flow_file;
                        $props{$id}{bth_file}  = $bth_file;
                        $props{$id}{seg}       = $seg;
                        $props{$id}{elbot}     = $elbot;
                        $props{$id}{wd_alg}    = $wd_alg;

                        %rel_data = &read_release_rates($main, $flow_file);
                        if ($profile{daily} != $rel_data{daily}) {
                            return &pop_up_error2($main, "The input temperature and release-rate data\n"
                                                       . "are not on the same time scale.  One is daily\n"
                                                       . "and the other is subdaily.  Please start over.");
                        }
                        ($kmx, $kb_seg, $h_ref, $b_ref) = &read_bth_slice($main, $seg, $bth_file);
                        @h  = @{ $h_ref };
                        @b  = @{ $b_ref };
                        @el = ();
                        $el[$kmx] = $elbot;
                        for ($k=$kmx-1; $k>=1; $k--) {
                            $el[$k] = $el[$k+1] +$h[$k];
                        }
                        $profile{kmx} = $kmx;
                        $profile{kb}  = $kb_seg;
                        $profile{b}   = [ @b  ];
                        $profile{el}  = [ @el ];

                        @ktsw = @{ $rel_data{ktsw} };
                        @kbsw = @{ $rel_data{kbsw} };
                        for ($n=0; $n<$rel_data{nout}; $n++) {
                            $ktsw[$n] = $kb_seg   if ($ktsw[$n] > $kb_seg);                   # already >= 2
                            $kbsw[$n] = $kb_seg   if ($kbsw[$n] > $kb_seg || $kbsw[$n] == 0); # 0 if bad input
                            $kbsw[$n] = $ktsw[$n] if ($kbsw[$n] < $ktsw[$n]);
                        }
                        $profile{ktsw}   = [ @ktsw ];
                        $profile{kbsw}   = [ @kbsw ];
                        $profile{nout}   = $rel_data{nout};
                        $profile{sw_alg} = $rel_data{sw_alg};
                        $profile{names}  = $rel_data{names};
                        $profile{estr}   = $rel_data{estr};
                        $profile{lw}     = $rel_data{lw};
                        $profile{qdata}  = $rel_data{qdata};
                        $profile{qunits} = $qunits;
                        $profile{ytype}  = $ytype;
                        $profile{yunits} = $yunits;

                        %limits            = &find_data_limits($id, %profile);
                        $profile{date_min} = $limits{date_min};
                        $profile{date_max} = $limits{date_max};
                        $profile{dpth_min} = $limits{dpth_min};
                        $profile{dpth_max} = $limits{dpth_max};
                        $profile{elev_min} = $limits{elev_min};
                        $profile{elev_max} = $limits{elev_max};
                        $profile{parm_min} = $limits{parm_min};
                        $profile{parm_max} = $limits{parm_max};
                        $profile{flow_min} = $limits{flow_min};
                        $profile{flow_max} = $limits{flow_max};
                        undef %limits;

                        if ($wd_alg eq "Libby Dam") {
                            $props{$id}{lbc_file} = $lbc_file;
                            %bh_config = &read_libby_config($main, $lbc_file);
                            $profile{num_ww}    = $bh_config{num_ww};
                            $profile{ww_names}  = $bh_config{ww_names};
                            $profile{num_outs}  = $bh_config{num_outs};
                            $profile{num_slots} = $bh_config{num_slots};
                            $profile{num_rows}  = $bh_config{num_rows};
                            $profile{bh_width}  = $bh_config{bh_width};
                            $profile{bh_height} = $bh_config{bh_height};
                            $profile{base_elev} = $bh_config{base_elev};
                            $profile{hlc_base}  = $bh_config{hlc_base};
                            $profile{hlc_inc}   = $bh_config{hlc_inc};
                            $profile{bh_miss}   = $bh_config{bh_miss};

                            @sw_alg = @{ $rel_data{sw_alg} };
                            $nww = -1;
                            for ($n=0; $n<=$#sw_alg; $n++) {
                                $nww++ if ($sw_alg[$n] eq "LibbyDam");
                            }
                            if ($nww +1 != $bh_config{num_ww}) {
                                return &pop_up_error2($main,
                                          "Libby bulkhead configuration file is inconsistent with\n"
                                        . "outflow release file in terms of the number of outlets\n"
                                        . "using Libby-Dam-like wet-well selective withdrawal:\n"
                                        . "  $lbc_file\n  $flow_file");
                            }
                            undef %bh_config;

                            $profile{bh_show}   = $bh_show;
                            $profile{bh_docked} = $bh_docked;
                            $profile{bh_xpos}   = $bh_xpos;
                            $profile{bh_ypos}   = $bh_ypos;
                            $profile{bh_font}   = $bh_font;
                            $profile{bh_size}   = $bh_size;
                            $profile{bh_weight} = $bh_weight;
                            $profile{bh_tcolor} = $bh_tcolor;
                            $profile{bh_bwidth} = $bh_bwidth;
                            $profile{bh_bcolor} = $bh_bcolor;
                            $profile{bh_bcellw} = $bh_bcellw;
                            $profile{bh_bcellh} = $bh_bcellh;
                        }
                    }
                    $profile{redraw}  = 1;
                    $gr_props{$id}    = { %profile };
                    $props{$id}{data} = 1;
                    undef %profile;

                    if ($meta =~ /^(data_profile|w2_profile|w2_outflow|vert_wd_zone)$/) {
                        $gr_props{$id}{add_cs}    = $add_cs;
                        $gr_props{$id}{gs_size}   = $gs_size;
                        $gr_props{$id}{gs_weight} = $gs_weight;
                    } elsif ($meta =~ /w2_slice|w2_wlevels/) {
                        $gr_props{$id}{add_cs}    = 1 if ($meta eq "w2_slice");
                        $gr_props{$id}{xbase}     = ($xbase ne "") ? $xbase : $xmin;
                        $gr_props{$id}{xfirst}    = $xfirst;
                        $gr_props{$id}{gs_size}   = $gs_size;
                        $gr_props{$id}{gs_weight} = $gs_weight;
                        $gr_props{$id}{stype}     = $stype;
                        $gr_props{$id}{sfont}     = $sfont;
                        $gr_props{$id}{st_size}   = $st_size;
                        $gr_props{$id}{st_weight} = $st_weight;
                        $gr_props{$id}{sl_size}   = $sl_size;
                        $gr_props{$id}{sl_weight} = $sl_weight;
                        $gr_props{$id}{smajor}    = $smajor;
                        $gr_props{$id}{spr_tics}  = $spr_tics;
                        $gr_props{$id}{sop_tics}  = $sop_tics;
                        $gr_props{$id}{stic_loc}  = $stic_loc;
                        $gr_props{$id}{sgrid}     = $sgrid;
                        $gr_props{$id}{sgrid_col} = $sgrid_col;
                        $gr_props{$id}{bgrid}     = $bgrid;
                        $gr_props{$id}{bgrid_col} = $bgrid_col;
                        $gr_props{$id}{stitle}    = $stitle;
                        if ($meta eq "w2_wlevels") {
                            $gr_props{$id}{wl_color} = $wl_color;
                            $gr_props{$id}{wl_style} = $wl_style;
                            $gr_props{$id}{wl_grid}  = $wl_grid;
                            $gr_props{$id}{wl_gridc} = $wl_gridc;
                        }
                    } elsif ($meta eq "w2_tdmap") {
                        $gr_props{$id}{add_cs}     = 1;
                        $gr_props{$id}{datefmt}    = $datefmt;
                        $gr_props{$id}{base_yr}    = $base_yr;
                        $gr_props{$id}{gstitle}    = $gstitle;
                        $gr_props{$id}{gs_size}    = $gs_size;
                        $gr_props{$id}{gs_weight}  = $gs_weight;
                        $gr_props{$id}{hide_title} = $hide_title;
                        $gr_props{$id}{hide_taxis} = $hide_taxis;
                        $gr_props{$id}{hide_daxis} = $hide_daxis;
                    } elsif ($meta =~ /(data_profile_cmap|w2_profile_cmap|time_series)/) {
                        $gr_props{$id}{datefmt}   = $datefmt;
                        $gr_props{$id}{add_cs}    = 1 if ($meta =~ /profile_cmap/);
                        $gr_props{$id}{xtype}     = $xtype;
                        $gr_props{$id}{base_yr}   = $base_yr;
                        $gr_props{$id}{datelinec} = $datelinec;
                        if ($meta =~ /data_profile_cmap|w2_profile_cmap/) {
                            $gr_props{$id}{dateline} = ($dateline < 0) ? 1 : $dateline;
                        } else {
                            $gr_props{$id}{dateline} = ($dateline < 0) ? 0 : $dateline;
                        }
                    }
                    if ($meta !~ /time_series|w2_wlevels/) {
                        $gr_props{$id}{cs_hide}   = $cs_hide;
                        $gr_props{$id}{cs_link}   = $cs_link;
                        $gr_props{$id}{cscheme1}  = $cscheme1;
                        $gr_props{$id}{cscheme2}  = $cscheme2;
                        $gr_props{$id}{ncolors}   = $ncolors;
                        $gr_props{$id}{cs_rev}    = $cs_rev;
                        $gr_props{$id}{cs_min}    = $cs_min;
                        $gr_props{$id}{cs_max}    = $cs_max;
                        $gr_props{$id}{cs_width}  = $cs_width;
                        $gr_props{$id}{cs_height} = $cs_height;
                        $gr_props{$id}{xleg_off}  = $xleg_off;
                        $gr_props{$id}{yleg_off}  = $yleg_off;
                        $gr_props{$id}{keyfont}   = $keyfont;
                        $gr_props{$id}{keytitle}  = $keytitle;
                        $gr_props{$id}{kt_size}   = $kt_size;
                        $gr_props{$id}{kt_weight} = $kt_weight;
                        $gr_props{$id}{kn_size}   = $kn_size;
                        $gr_props{$id}{kn_weight} = $kn_weight;
                        $gr_props{$id}{kn_digits} = $kn_digits;
                        if ($cs_major eq "auto") {
                            $gr_props{$id}{cs_major} = "auto";
                        } elsif ($cs_major <= 0) {
                            $gr_props{$id}{cs_major} = "auto";
                        } elsif ($cs_major > abs($cs_max -$cs_min)) {
                            $gr_props{$id}{cs_major} = abs($cs_max -$cs_min);
                        } else {
                            $gr_props{$id}{cs_major} = $cs_major;
                        }
                    }

                    if ($meta eq "w2_tdmap") {
                        $gr_props{$id}{date_axis} = uc($date_axis);
                        $gr_props{$id}{ttitle}    = $ttitle;
                        $gr_props{$id}{tfont}     = $tfont;
                        $gr_props{$id}{tt_size}   = $tt_size;
                        $gr_props{$id}{tt_weight} = $tt_weight;
                        $gr_props{$id}{tl_size}   = $tl_size;
                        $gr_props{$id}{tl_weight} = $tl_weight;
                        $gr_props{$id}{tmin}      = $tmin;
                        $gr_props{$id}{tmax}      = $tmax;
                        $gr_props{$id}{tmajor}    = $tmajor;
                        $gr_props{$id}{tpr_tics}  = $tpr_tics;
                        $gr_props{$id}{top_tics}  = $top_tics;
                        $gr_props{$id}{ttype}     = $ttype;
                        $gr_props{$id}{tflip}     = $tflip;
                        $gr_props{$id}{tflip_img} = 0;
                        $gr_props{$id}{dtitle}    = $dtitle;
                        $gr_props{$id}{dfont}     = $dfont;
                        $gr_props{$id}{dt_size}   = $dt_size;
                        $gr_props{$id}{dt_weight} = $dt_weight;
                        $gr_props{$id}{dl_size}   = $dl_size;
                        $gr_props{$id}{dl_weight} = $dl_weight;
                        $gr_props{$id}{dbase}     = ($dbase ne "") ? $dbase : $dmin;
                        $gr_props{$id}{dmin}      = $dmin;
                        $gr_props{$id}{dmax}      = $dmax;
                        $gr_props{$id}{dmax_auto} = $dmax_auto;
                        $gr_props{$id}{dfirst}    = $dfirst;
                        $gr_props{$id}{dmajor}    = $dmajor;
                        $gr_props{$id}{dpr_tics}  = $dpr_tics;
                        $gr_props{$id}{dop_tics}  = $dop_tics;
                        $gr_props{$id}{dflip}     = $dflip;
                        $gr_props{$id}{dflip_img} = 0;
                        $gr_props{$id}{dunits}    = $dunits;
                        if ($gr_props{$id}{dunits} eq "miles") {
                            $gr_props{$id}{d_km} = ($dmax -$dmin) /(3280.84/5280.);
                        } else {
                            $gr_props{$id}{d_km} = ($dmax -$dmin);
                        }
                    } else {
                        $gr_props{$id}{xfont}     = $xfont;
                        $gr_props{$id}{xt_size}   = $xt_size;
                        $gr_props{$id}{xt_weight} = $xt_weight;
                        $gr_props{$id}{xl_size}   = $xl_size;
                        $gr_props{$id}{xl_weight} = $xl_weight;
                        $gr_props{$id}{xmin}      = $xmin;
                        $gr_props{$id}{xmax}      = $xmax;
                        $gr_props{$id}{xmajor}    = $xmajor;
                        $gr_props{$id}{xpr_tics}  = $xpr_tics;
                        $gr_props{$id}{xop_tics}  = $xop_tics;
                        $gr_props{$id}{xtitle}    = $xtitle;
                        $gr_props{$id}{yfont}     = $yfont;
                        $gr_props{$id}{yt_size}   = $yt_size;
                        $gr_props{$id}{yt_weight} = $yt_weight;
                        $gr_props{$id}{yl_size}   = $yl_size;
                        $gr_props{$id}{yl_weight} = $yl_weight;
                        $gr_props{$id}{ymin}      = $ymin;
                        $gr_props{$id}{ymax}      = $ymax;
                        $gr_props{$id}{ymajor}    = $ymajor;
                        $gr_props{$id}{ypr_tics}  = $ypr_tics;
                        $gr_props{$id}{yop_tics}  = $yop_tics;
                        $gr_props{$id}{ytitle}    = $ytitle;
                    }
                    $gr_props{$id}{gtfont}    = $gtfont;
                    $gr_props{$id}{gt_size}   = $gt_size;
                    $gr_props{$id}{gt_weight} = $gt_weight;
                    $gr_props{$id}{gtitle}    = $gtitle;

                    if ($meta =~ /time_series/) {
                        $gr_props{$id}{legtitle}  = $legtitle;
                        $gr_props{$id}{legfont}   = $legfont;
                        $gr_props{$id}{lt_size}   = $lt_size;
                        $gr_props{$id}{lt_weight} = $lt_weight;
                        $gr_props{$id}{le_size}   = $le_size;
                        $gr_props{$id}{le_weight} = $le_weight;
                        $gr_props{$id}{le_edge}   = $le_edge;
                        $gr_props{$id}{le_edgec}  = $le_edgec;
                        $gr_props{$id}{le_fill}   = $le_fill;
                        $gr_props{$id}{le_fillc}  = $le_fillc;
                        $gr_props{$id}{xleg_off}  = $xleg_off;
                        $gr_props{$id}{yleg_off}  = $yleg_off;
                        $gr_props{$id}{gap_tol}   = $gap_tol;
                        $gr_props{$id}{gridx}     = $gridx;
                        $gr_props{$id}{gridy}     = $gridy;
                        $gr_props{$id}{gridwidth} = $gridwidth;
                        $gr_props{$id}{gridcolor} = $gridcolor;
                        $props{$id}{ts_gnum}      = $ts_gnum;

                        %parms          = ();
                        $parms{ts_type} = $ts_type;
                        $parms{units}   = $ts_units;
                        if ($meta eq "linked_time_series") {
                            $parms{show}  = [ @ts_show ];
                            $parms{width} = [ @ts_width  ];
                            $parms{color} = [ @ts_color  ];
                        }
                        $props{$id}{ts_parms} = { %parms };

                        if ($#add_ts_setnum >= 0) {
                            @add_ts_lines = (0) x @add_ts_setnum;
                            %add_ts_parms             = ();
                            $add_ts_parms{ts_setnum}  = [ @add_ts_setnum ];
                            $add_ts_parms{ts_file}    = [ @add_ts_file   ];
                            $add_ts_parms{ts_show}    = [ @add_ts_show   ];
                            $add_ts_parms{ts_width}   = [ @add_ts_width  ];
                            $add_ts_parms{ts_color}   = [ @add_ts_color  ];
                            $add_ts_parms{ts_text}    = [ @add_ts_text   ];
                            $add_ts_parms{ts_ftype}   = [ @add_ts_ftype  ];
                            $add_ts_parms{ts_lines}   = [ @add_ts_lines  ];
                            $add_ts_parms{ts_param}   = [ @add_ts_param  ];
                            $add_ts_parms{ts_byear}   = [ @add_ts_byear  ];
                            $add_ts_parms{ts_tzoff}   = [ @add_ts_tzoff  ];
                            $add_ts_parms{ts_seg}     = [ @add_ts_seg    ];
                            $add_ts_parms{ts_ctype}   = [ @add_ts_ctype  ];
                            $add_ts_parms{ts_limits}  = [ ( )            ];
                            $add_ts_parms{ts_data}    = [ ( )            ];
                            $props{$id}{add_ts_parms} = { %add_ts_parms  };
                        }
                    }
                    push (@graph_nums, $gnum);
                    push (@graph_ids,  $id);

                    $status_line = "";
                    $canvas->configure(-cursor => $cursor_norm);
                    Tkx::update();
                    if ($meta eq "data_profile" || $meta eq "data_profile_cmap") {
                        if ($prof_type =~ /difference/i) {
                            &calculate_diffs($id);
                        }
                        &make_data_profile($canvas, $id, 1);

                    } elsif ($meta eq "vert_wd_zone") {
                        &make_wd_zone($canvas, $id, 1);

                    } elsif ($meta eq "w2_profile" || $meta eq "w2_profile_cmap") {
                        undef %kt_data;
                        undef %elev_data;
                        undef %parm_data;
                        &make_w2_profile($canvas, $id, 1);

                    } elsif ($meta eq "w2_outflow") {
                        undef %qdata;
                        undef %vdata;
                        if ($add_parm) {
                            undef %kt_data;
                            undef %elev_data;
                            undef %parm_data;
                        }
                        &make_w2_outflow($canvas, $id, 1);

                    } elsif ($meta eq "w2_slice") {
                        undef @slice_data;
                        &make_w2_slice($canvas, $id, 1);

                    } elsif ($meta eq "w2_tdmap") {
                        undef %td_data;
                        &make_w2_tdmap($canvas, $id, 1);

                    } elsif ($meta eq "w2_wlevels") {
                        &make_w2_wlevels($canvas, $id, 1);

                    } elsif ($meta eq "linked_time_series") {
                        $i = &list_match($ts_gnum, @graph_nums);
                        if ($i > -1) {
                            $props{$id}{link_id} = $graph_ids[$i];
                            &make_ts_graph($canvas, $id, 1);
                        } else {
                            push (@tslink_ids, $id);
                        }

                    } elsif ($meta eq "time_series") {
                        &make_ts_graph($canvas, $id, 1);
                    }
                    if ($meta =~ /^(data_profile|vert_wd_zone)$/) {
                        foreach $ts_id (@tslink_ids) {
                            if ($props{$ts_id}{ts_gnum} == $gnum) {
                                $props{$ts_id}{link_id} = $id;
                                &make_ts_graph($canvas, $ts_id, 1);
                            }
                        }
                    }
                    $graph_num = &max($gnum, $graph_num);
                }
            }

#           Add link info, if object is a link
            if ($got_link) {
                $link_props{$id}{gnum}   = $ln_gnum;
                $link_props{$id}{type}   = $ln_type;
                $link_props{$id}{form}   = $ln_form;
                $link_props{$id}{digits} = $ln_digits;
                if ($ln_form eq "stat") {
                    $link_props{$id}{tol}    = $ln_tol;
                    $link_props{$id}{interp} = $ln_interp;
                } else {
                    $link_props{$id}{outlet} = $ln_outlet;
                    $link_props{$id}{units}  = $ln_units;
                }
            }
            Tkx::update_idletasks();
        }
    }

    $savefile = $file if (! $revert);
    close ($fh);

#   Final details for any linked objects
    if (@animate_ids && $#animate_ids >= 0 && $got_links) {
        foreach $link_id (keys %link_props) {
            foreach $id (@animate_ids) {
                if ($link_props{$link_id}{gnum} == $props{$id}{gnum}) {
                    $link_props{$link_id}{id} = $id;
                    $canvas->addtag("link_gr" . $id, withtag => $link_id);
                    last;
                }
            }
        }
        foreach $id (@animate_ids) {
            &update_links($canvas, $id, $dates[$dti-1]);
        }
    }

#   Ensure that global date limits are active only when appropriate
    if ($global_dt_limits) {
        $global_dt_limits = 0;
        if (@animate_ids && $#animate_ids >= 0) {
            foreach $id (@animate_ids) {
                if ($props{$id}{meta}
                        =~ /^(data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)$/) {
                    $global_dt_limits = 1;
                    last;
                }
            }
        }
        if ($global_dt_limits) {
            $pref_menu->entryconfigure(0, -state => 'normal');
        } else {
            $global_dt_begin = $global_dt_end = "na";
        }
    }
    $delay_autosave = 0;

#   Put file name in title bar
    if ($revert) {
        $main->g_wm_title("W2 Animator");
        &pop_up_info($main, "Autosave file loaded. Please consider\n"
                          . "saving this project under a new name.", "Save File Notice");
    } else {
        $main->g_wm_title("W2 Animator  --  $file");
        &add_to_recent($file);
    }
}


sub pop_up_error2 {            # Needed to reset delay_autosave in open_file subroutine
    my ($parent, $msg) = @_;
    $delay_autosave = 0;
    &pop_up_error($parent, $msg);
}


sub add_to_recent {
    my ($file) = @_;
    my ($entry, $fh, $line, $n, $recent_file, $success,
        @entries,
       );

    $recent_file = "${prog_path}w2anim_recent.txt";
    @entries     = ();
    push (@entries, $file);   # Add current file to top of list

#   Delete any entries in the File/Recent menu
    $recent_menu->delete(0, 'end');

#   Check validity of recent file list, obtain the current list, then delete the file
    if (-e $recent_file) {
        $success = open ($fh, "<", $recent_file);
        if (defined($success)) {
            $line = <$fh>;
            if ($line =~ /^\# W2 Animator recent files list/) {
                while (defined( $entry = <$fh> )) {
                    $entry =~ s/^\s+//;
                    $entry =~ s/\s+$//;
                    next if ($entry =~ /^#/ || $entry eq "");
                    next if ($entry !~ /\.w2a$/ || ! -e $entry || -d $entry || -s $entry == 0);
                    $entry = File::Spec->rel2abs($entry);
                    if (File::Spec->case_tolerant()) {
                        next if (lc($entry) eq lc($file));
                    } else {
                        next if ($entry eq $file);
                    }
                    push (@entries, $entry);
                }
            }
            close ($fh);
        }
        unlink $recent_file;
    }

#   Write out the recent file list, with a maximum of 15 entries
    $success = open ($fh, ">", $recent_file);
    if (defined($success)) {
        print $fh "\# W2 Animator recent files list\n";
        for ($n=0; $n<=$#entries; $n++) {
            print $fh $entries[$n], "\n";
            $recent_menu->add_command(
                        -label   => $entries[$n],
                        -state   => 'normal',
                        -command => [ \&open_file, $entries[$n], 0 ],
                        );
            last if ($n == 14);
        }
        close ($fh);
        $recent_menu->add_command(
                    -label     => "Clear recent list",
                    -underline => 0,
                    -state     => 'normal',
                    -command   => \&clear_recent,
                    );
    } else {
        $recent_menu->add_command(
                    -label     => "None",
                    -underline => 0,
                    -state     => 'disabled',
                    );
    }
}


sub clear_recent {
    my ($fh, $recent_file, $success);

    $recent_file = "${prog_path}w2anim_recent.txt";

#   Delete any entries in the File/Recent menu and add None
    $recent_menu->delete(0, 'end');
    $recent_menu->add_command(
                -label     => "None",
                -underline => 0,
                -state     => 'disabled',
                );

#   Rewrite the recent files list
    $success = open ($fh, ">", $recent_file);
    if (defined($success)) {
        print $fh "\# W2 Animator recent files list\n";
        close ($fh);
    } else {
        unlink $recent_file if (-e $recent_file);
    }
}


sub autosave {
    my ($different, $id, $interval, $tmp_file, @id_list);

#   Remove any previously scheduled autosave jobs. Probably aren't any.
    if ($autosave_id1 ne "" && $autosave_id2 ne "") {
        foreach $id (Tkx::SplitList(Tkx::after_info())) {
            Tkx::after_cancel($id) if ($id eq $autosave_id1 ||
                                       $id eq $autosave_id2);
        }
    }

#   Delay the autosave by 1 minute if an animation is in progress or if exporting output
    if ($anim_tb_status ne "stopped" || $delay_autosave) {
        $interval = 60000;
        $autosave_id2 = Tkx::after_idle(sub {$autosave_id1 = Tkx::after($interval, [\&autosave]);});
        return;
    }

#   Proceed with the autosave, but only if objects are present that are worth saving
    @id_list = Tkx::SplitList($canvas->find_withtag("keep"));
    if ($#id_list >= 0) {
        $status_line = "Autosaving...";
        Tkx::update_idletasks();
        $tmp_file = "";
        if (-e $autosave_file) {
            ($tmp_file = $autosave_file) =~ s/\.w2a$/tmp\.w2a/;
            copy($autosave_file, $tmp_file);
        }
        &save_file($autosave_file, 1);
        if ($tmp_file ne "") {
            $different = &compare_saved($autosave_file, $tmp_file);
            if ($different) {
                unlink $autosave_file2 if (-e $autosave_file2);
                move($tmp_file, $autosave_file2);
                $autosave_menu->entryconfigure('end', -state => 'normal');
            } else {
                unlink $tmp_file;
            }
        }
        $autosave_menu->entryconfigure(8, -state => 'normal');  # entry 8 is "Revert, recent"
        $status_line = "Autosaving... done";
    }

#   The After interval is expressed in milliseconds.
#   One minute = 60,000 ms. Five minutes = 300,000 ms.
    $interval = 60000 *$autosave_interval;
    $autosave_id2 = Tkx::after_idle(sub {$autosave_id1 = Tkx::after($interval, [\&autosave]);});
}


sub reassign_autosave_files {
    my ($new_dir) = @_;
    my (
        $fh1, $fh2, $key, $line, $n, $new_autosave_file, $new_autosave_file2,
        $newfile, $oldfile, $pos, $random, $success1, $success2, $tmp_file,
        $val,
       );

    return if ($new_dir eq $temp_dir);
    $delay_autosave = 1;

    ($random = $autosave_file) =~ s/.*_autosave(\d+)\.w2a/$1/;
    $new_autosave_file  = "_autosave" . $random . ".w2a";
    $new_autosave_file2 = "_autosave" . $random . "_2.w2a";
    $new_autosave_file  = File::Spec->rel2abs($new_autosave_file,  $new_dir);
    $new_autosave_file2 = File::Spec->rel2abs($new_autosave_file2, $new_dir);

    for ($n=1; $n<=2; $n++) {
        if ($n==1) {
            $oldfile = $autosave_file;
            $newfile = $new_autosave_file;
        } else {
            $oldfile = $autosave_file2;
            $newfile = $new_autosave_file2;
        }
        if (-e $oldfile) {
            $success1 = open ($fh1, "<", $oldfile);
            $success2 = open ($fh2, ">", $newfile);
            if (defined($success1) && defined($success2)) {
                while (defined($line = <$fh1>)) {
                    if ($line =~ /_file: |_files: |_file2: | file: | add_data: /) {
                        $line =~ s/\s+$//;
                        $pos  = index($line, ":");
                        $key  = substr($line, 0, $pos);
                        $val  = substr($line, $pos +1);
                        $key  =~ s/^\s+//;
                        $val  =~ s/^\s+//;

                        if ($key =~ /cpl_files|cpl_file2|riv_files|riv_file2|bth_files|add_data/) {
                            (undef, $tmp_file) = split(/,/, $val);
                            $tmp_file =~ s/^\s+//;
                            $pos      = index($line, $tmp_file);
                            $tmp_file = File::Spec->rel2abs($tmp_file, $temp_dir);
                        } else {
                            $pos      = index($line, $val);
                            $tmp_file = File::Spec->rel2abs($val, $temp_dir);
                        }
                        $tmp_file = File::Spec->abs2rel($tmp_file, $new_dir);
                        $line = substr($line, 0, $pos) . $tmp_file . "\n";
                    }
                    print $fh2 $line;
                }
                close ($fh1);
                close ($fh2);
            }
            unlink $oldfile;
        }
    }
    $autosave_file  = $new_autosave_file;
    $autosave_file2 = $new_autosave_file2;
    $delay_autosave = 0;
}


sub compare_saved {
    my ($file1, $file2) = @_;
    my (
        $case_tol, $content1, $content2, $dir1, $dir2, $fh1, $fh2, $i,
        $key1, $key2, $line1, $line2, $n1, $n2, $pos, $success1, $success2,
        $tmp_file1, $tmp_file2, $val1, $val2, $vol1, $vol2,

        @lines1, @lines2,
       );

#   Files must exist and be readable
    return 0 if (! -e $file1 || ! -e $file2 || ! -r $file1 || ! -r $file2);

#   Must be able to open the files for reading
    $success1 = open ($fh1, "<", $file1);
    $success2 = open ($fh2, "<", $file2);
    return 0 if (! defined($success1) || ! defined($success2));

#   Simple tests to determine that these are W2Anim project files
    $line1 = <$fh1>;
    $line2 = <$fh2>;
    if ($line1 !~ /^\# W2 Animator data file, version/ || $line2 !~ /^\# W2 Animator data file, version/) {
        close ($fh1);
        close ($fh2);
        return 0;
    }
    $line1 = <$fh1>;
    $line2 = <$fh2>;
    if ($line1 !~ /^\# File created: / || $line2 !~ /^\# File created: /) {
        close ($fh1);
        close ($fh2);
        return 0;
    }

#   Slurp the rest of the files
    {
        local $/;    # Enable local slurp mode
        $content1 = <$fh1>;
        $content2 = <$fh2>;
    }
    close ($fh1);
    close ($fh2);

    @lines1 = split(/\n/, $content1);
    @lines2 = split(/\n/, $content2);
    return 1 if ($#lines1 != $#lines2);       # different number of lines

#   Get paths to files, as file names in project files have relative paths
    $case_tol = File::Spec->case_tolerant();
    ($vol1, $dir1, undef) = File::Spec->splitpath($file1);
    ($vol2, $dir2, undef) = File::Spec->splitpath($file2);
    for ($i=0; $i<=$#lines1; $i++) {
        if ($lines1[$i] =~ /_file: |_files: |_file2: | file: | add_data: /) {
            return 1 if ($lines2[$i] !~ /_file: |_files: |_file2: | file: | add_data: /);

            $lines1[$i] =~ s/^\s+//;
            $lines1[$i] =~ s/\s+$//;
            $pos  = index($lines1[$i], ":");
            $key1 = substr($lines1[$i], 0, $pos);
            $val1 = substr($lines1[$i], $pos +1);
            $val1 =~ s/^\s+//;

            $lines2[$i] =~ s/^\s+//;
            $lines2[$i] =~ s/\s+$//;
            $pos  = index($lines2[$i], ":");
            $key2 = substr($lines2[$i], 0, $pos);
            $val2 = substr($lines2[$i], $pos +1);
            $val2 =~ s/^\s+//;
            return 1 if ($key1 ne $key2);

            if ($key1 =~ /cpl_files|cpl_file2|riv_files|riv_file2|bth_files|add_data/) {
                ($n1, $tmp_file1) = split(/,/, $val1);
                ($n2, $tmp_file2) = split(/,/, $val2);
                $tmp_file1 =~ s/^\s+//;
                $tmp_file2 =~ s/^\s+//;
                $tmp_file1 = File::Spec->rel2abs($tmp_file1, $vol1 . $dir1);
                $tmp_file2 = File::Spec->rel2abs($tmp_file2, $vol2 . $dir2);
                return 1 if ($n1 ne $n2);
            } else {
                $tmp_file1 = File::Spec->rel2abs($val1, $vol1 . $dir1);
                $tmp_file2 = File::Spec->rel2abs($val2, $vol2 . $dir2);
            }
            if ($case_tol) {                # for case-tolerant systems like Windows
                $tmp_file1 = lc($tmp_file1);
                $tmp_file2 = lc($tmp_file2);
            }
            return 1 if ($tmp_file1 ne $tmp_file2);
        } else {
            return 1 if ($lines1[$i] ne $lines2[$i]);
        }
    }
    return 0;   # no differences found
}


sub save_file {
    my ($file, $silent) = @_;
    my (
        $bth_file, $colors, $con_file, $coordlist, $croplist, $date1, $date2,
        $dir, $fill, $fillcolor, $flow_file, $fname, $gnum, $group_tags,
        $i, $id, $img_file, $j, $lbc_file, $qla_file, $ref_file, $scale,
        $show_sets, $src_file, $tag, $type, $txt, $vol, $w2l_file, $wl_file,
        $widths, $wt_file, $xct, $xt, $yct, $yt,

        @bfiles, @brs, @byear, @cfiles, @clines, @color, @coords, @crop,
        @ctype, @ftype, @id_list, @param, @rfiles, @rlines, @seg, @setnum,
        @show, @tags, @text, @tecplot, @tsfile, @tzoff, @width,

        %parms,
       );

#   When autosaving, operate silently and do not check or save the file name
    $silent = 0 if (! defined($silent) || $silent != 1);

    if (defined($file) && ! $silent) {
        if (! -e $file) {
            undef $file;
        } else {
            return if ( lc(&pop_up_question($main, "Overwrite $file?")) eq "no" );
        }
    }
    if (! defined($file)) {
        $file = Tkx::tk___getSaveFile(
            -parent           => $main,
            -title            => "Save Project File",
            -initialdir       => abs_path(),
            -defaultextension => ".w2a",
            -filetypes => [ ['W2 Animator Files', '.w2a'],
                            ['All Files',  '*'],
                          ],
            );
    }
    return if (! defined($file) || $file eq "");
    $file = File::Spec->rel2abs($file);

    open (OUT, ">", $file) || return &pop_up_error($main, "Unable to save\n$file");
    if (! $silent) {
        $savefile = $file;
        &add_to_recent($file);
    }
    ($vol, $dir, $fname) = File::Spec->splitpath($file);
    $delay_autosave = 1;

#   Print header and canvas properties
    print OUT "# W2 Animator data file, version $version\n";
    print OUT "# File created: ", &get_datetime, "\n";
    print OUT "#\n";

    print OUT << "end_of_input";

==== CANVAS ====
  width:     $canvas_width
  height:    $canvas_height
  color:     $canvas_color
  text_slct: $text_select_color
  snap2grid: $snap2grid
  grid_spac: $grid_spacing
==== END CANVAS ====
end_of_input

#   Include global date limits, if present
    if ($global_dt_limits) {
        $date1 = $date2 = "na";
        if ($global_dt_begin =~ /^[12][0-9][0-9][0-9][01][0-9][0-3][0-9]0000$/) {
            $date1 = &date2datelabel($global_dt_begin, "Mon-DD-YYYY");
        }
        if ($global_dt_end =~ /^[12][0-9][0-9][0-9][01][0-9][0-3][0-9]0000$/) {
            $date2 = &date2datelabel($global_dt_end, "Mon-DD-YYYY");
        }
        if ($date1 ne "na" && $date2 ne "na") {
            print OUT << "end_of_input";

==== DATE LIMITS ====
  gdt_begin: $date1
  gdt_end:   $date2
==== END DATE LIMITS ====
end_of_input
        }
    }

#   Items from find command are returned in stacking order, w/ lowest first
    @id_list = Tkx::SplitList($canvas->find_withtag("keep"));
    print OUT "\n==== OBJECTS ====  From lowest to highest\n";

    for ($i=0; $i<=$#id_list; $i++) {
        $id   = $id_list[$i];
        $type = $props{$id}{type};
        $xt   = $props{$id}{x} -3;
        $yt   = $props{$id}{y} -3;
        @tags = Tkx::SplitList($canvas->itemcget($id, -tags));
        $group_tags = "";
        if (&list_search("group_", @tags) > -1) {
            foreach $tag (@tags) {
                $group_tags .= $tag . " " if ($tag =~ /^group_/);
            }
            $group_tags =~ s/\s+$//;
        }

        if ($type eq "graph") {
            $xct    = $props{$id}{xc} -3;
            $yct    = $props{$id}{yc} -3;
            @coords = @{ $props{$id}{coordlist} };
            $coordlist = sprintf("%.5f", $coords[0]-3);
            for ($j=1; $j<=$#coords; $j++) {
                $coordlist .= ', ' . sprintf("%.5f", $coords[$j]-3);
            }
            print OUT << "end_of_input";
$type
  meta:      $props{$id}{meta}
  gnum:      $props{$id}{gnum}
  x:         $xt
  y:         $yt
  xc:        $xct
  yc:        $yct
  anchor:    $props{$id}{anchor}
  color:     $props{$id}{color}
  width:     $props{$id}{width}
  fill:      $props{$id}{fill}
  coordlist: $coordlist
end_of_input
            if ($props{$id}{meta} =~ /data_profile/) {
                $src_file = File::Spec->abs2rel($props{$id}{src_file}, $vol . $dir);
                print OUT << "end_of_input";
  src_file:  $src_file
  parm:      $props{$id}{parm}
  parmunits: $props{$id}{parm_units}
  prof_type: $props{$id}{prof_type}
end_of_input
                if ($props{$id}{prof_type} =~ /difference/i) {
                    print OUT << "end_of_input";
  dref_type: $props{$id}{dref_type}
end_of_input
                    if ($props{$id}{dref_type} =~ /Constant/i) {
                        print OUT << "end_of_input";
  dref_val:  $props{$id}{dref_val}
end_of_input
                    } else {
                        $ref_file = File::Spec->abs2rel($props{$id}{dref_file}, $vol . $dir);
                        print OUT << "end_of_input";
  dref_file: $ref_file
  dref_ftyp: $props{$id}{dref_ftype}
  dref_line: $props{$id}{dref_lines}
  dref_parm: $props{$id}{dref_parm}
  dref_ctyp: $props{$id}{dref_ctype}
  dref_tol:  $props{$id}{dref_tol}
end_of_input
                        if ($props{$id}{dref_ftype} =~ /^W2 /) {
                            print OUT << "end_of_input";
  dref_byr:  $props{$id}{dref_byear}
  dref_tzof: $props{$id}{dref_tzoff}
end_of_input
                        }
                    }
                }
            } elsif ($props{$id}{meta} =~ /w2_profile/) {
                $con_file = File::Spec->abs2rel($props{$id}{con_file}, $vol . $dir);
                $src_file = File::Spec->abs2rel($props{$id}{src_file}, $vol . $dir);
                $bth_file = File::Spec->abs2rel($props{$id}{bth_file}, $vol . $dir);
                if ($props{$id}{src_type} =~ /Spreadsheet|Contour|LakeCon/i) {
                    print OUT << "end_of_input";
  con_file:  $con_file
  bth_file:  $bth_file
  src_type:  $props{$id}{src_type}
  src_file:  $src_file
  src_lines: $props{$id}{src_lines}
end_of_input
                    if ($props{$id}{src_type} =~ /Contour/i) {
                        print OUT << "end_of_input";
  tplot:     $props{$id}{tplot}
end_of_input
                    }
                } elsif ($props{$id}{src_type} =~ /Vector/i) {
                    print OUT << "end_of_input";
  con_file:  $con_file
  bth_file:  $bth_file
  src_type:  $props{$id}{src_type}
  src_file:  $src_file
end_of_input
                }
                print OUT << "end_of_input";
  parm:      $props{$id}{parm}
  parm_div:  $props{$id}{parm_div}
  parmunits: $props{$id}{parm_units}
  ctype:     $props{$id}{ctype}
  seg:       $props{$id}{seg}
  byear:     $props{$id}{byear}
  tz_offset: $props{$id}{tz_offset}
  jd_skip:   $props{$id}{jd_skip}
end_of_input
            } elsif ($props{$id}{meta} =~ /w2_slice/) {
                $con_file = File::Spec->abs2rel($props{$id}{con_file}, $vol . $dir);
                print OUT << "end_of_input";
  con_file:  $con_file
  src_type:  $props{$id}{src_type}
end_of_input
                if ($props{$id}{src_type} =~ /Contour/i) {
                    @tecplot = @{ $props{$id}{tecplot}   };
                    @clines  = @{ $props{$id}{cpl_lines} };
                    @cfiles  = @{ $props{$id}{cpl_files} };
                    @bfiles  = @{ $props{$id}{bth_files} };
                    for ($j=0; $j<=$#cfiles; $j++) {
                        $cfiles[$j] = File::Spec->abs2rel($cfiles[$j], $vol . $dir);
                        $bfiles[$j] = File::Spec->abs2rel($bfiles[$j], $vol . $dir);
                        print OUT << "end_of_input";
  cpl_info:  $j, $tecplot[$j], $clines[$j]
  cpl_files: $j, $cfiles[$j]
  bth_files: $j, $bfiles[$j]
end_of_input
                    }
                } elsif ($props{$id}{src_type} =~ /Vector/i) {
                    $w2l_file = File::Spec->abs2rel($props{$id}{w2l_file}, $vol . $dir);
                    print OUT << "end_of_input";
  w2l_file:  $w2l_file
end_of_input
                    @bfiles = @{ $props{$id}{bth_files} };
                    for ($j=0; $j<=$#bfiles; $j++) {
                        $bfiles[$j] = File::Spec->abs2rel($bfiles[$j], $vol . $dir);
                        print OUT << "end_of_input";
  bth_files: $j, $bfiles[$j]
end_of_input
                    }
                }
                print OUT << "end_of_input";
  seg_list:  $props{$id}{seg_list}
  wb_list:   $props{$id}{wb_list}
  parm:      $props{$id}{parm}
  parm_div:  $props{$id}{parm_div}
  parmunits: $props{$id}{parm_units}
  ctype:     $props{$id}{ctype}
  byear:     $props{$id}{byear}
  tz_offset: $props{$id}{tz_offset}
  jd_skip:   $props{$id}{jd_skip}
  dt_limits: $props{$id}{dt_limits}
end_of_input
                if ($props{$id}{dt_limits}) {
                    print OUT << "end_of_input";
  dt_begin:  $props{$id}{dt_begin}
  dt_end:    $props{$id}{dt_end}
end_of_input
                }
            } elsif ($props{$id}{meta} =~ /w2_wlevels/) {
                $con_file = File::Spec->abs2rel($props{$id}{con_file}, $vol . $dir);
                print OUT << "end_of_input";
  con_file:  $con_file
  src_type:  $props{$id}{src_type}
end_of_input
                if ($props{$id}{src_type} =~ /Contour/i) {
                    @tecplot = @{ $props{$id}{tecplot}   };
                    @clines  = @{ $props{$id}{cpl_lines} };
                    @cfiles  = @{ $props{$id}{cpl_files} };
                    @bfiles  = @{ $props{$id}{bth_files} };
                    for ($j=0; $j<=$#cfiles; $j++) {
                        $cfiles[$j] = File::Spec->abs2rel($cfiles[$j], $vol . $dir);
                        $bfiles[$j] = File::Spec->abs2rel($bfiles[$j], $vol . $dir);
                        print OUT << "end_of_input";
  cpl_info:  $j, $tecplot[$j], $clines[$j]
  cpl_files: $j, $cfiles[$j]
  bth_files: $j, $bfiles[$j]
end_of_input
                    }
                } elsif ($props{$id}{src_type} =~ /Vector/i) {
                    $w2l_file = File::Spec->abs2rel($props{$id}{w2l_file}, $vol . $dir);
                    print OUT << "end_of_input";
  w2l_file:  $w2l_file
end_of_input
                    @bfiles = @{ $props{$id}{bth_files} };
                    for ($j=0; $j<=$#bfiles; $j++) {
                        $bfiles[$j] = File::Spec->abs2rel($bfiles[$j], $vol . $dir);
                        print OUT << "end_of_input";
  bth_files: $j, $bfiles[$j]
end_of_input
                    }
                } elsif ($props{$id}{src_type} =~ /Water Level/i) {
                    $wl_file = File::Spec->abs2rel($props{$id}{wl_file}, $vol . $dir);
                    print OUT << "end_of_input";
  wl_file:   $wl_file
  wl_lines:  $props{$id}{wl_lines}
end_of_input
                    @bfiles = @{ $props{$id}{bth_files} };
                    for ($j=0; $j<=$#bfiles; $j++) {
                        $bfiles[$j] = File::Spec->abs2rel($bfiles[$j], $vol . $dir);
                        print OUT << "end_of_input";
  bth_files: $j, $bfiles[$j]
end_of_input
                    }
                }
                print OUT << "end_of_input";
  seg_list:  $props{$id}{seg_list}
  wb_list:   $props{$id}{wb_list}
  byear:     $props{$id}{byear}
  tz_offset: $props{$id}{tz_offset}
  jd_skip:   $props{$id}{jd_skip}
  extra_chk: $props{$id}{extra_chk}
end_of_input
            } elsif ($props{$id}{meta} =~ /w2_tdmap/) {
                $con_file = File::Spec->abs2rel($props{$id}{con_file}, $vol . $dir);
                print OUT << "end_of_input";
  map_type:  $props{$id}{map_type}
  con_file:  $con_file
  src_type:  $props{$id}{src_type}
end_of_input
                if ($props{$id}{src_type} =~ /Contour/i) {
                    @tecplot = @{ $props{$id}{tecplot}   };
                    @clines  = @{ $props{$id}{cpl_lines} };
                    @cfiles  = @{ $props{$id}{cpl_files} };
                    @bfiles  = @{ $props{$id}{bth_files} };
                    for ($j=0; $j<=$#cfiles; $j++) {
                        $cfiles[$j] = File::Spec->abs2rel($cfiles[$j], $vol . $dir);
                        $bfiles[$j] = File::Spec->abs2rel($bfiles[$j], $vol . $dir);
                        print OUT << "end_of_input";
  cpl_info:  $j, $tecplot[$j], $clines[$j]
  cpl_files: $j, $cfiles[$j]
  bth_files: $j, $bfiles[$j]
end_of_input
                    }
                } elsif ($props{$id}{src_type} =~ /Vector/i) {
                    $w2l_file = File::Spec->abs2rel($props{$id}{w2l_file}, $vol . $dir);
                    print OUT << "end_of_input";
  w2l_file:  $w2l_file
end_of_input
                    @bfiles = @{ $props{$id}{bth_files} };
                    for ($j=0; $j<=$#bfiles; $j++) {
                        $bfiles[$j] = File::Spec->abs2rel($bfiles[$j], $vol . $dir);
                        print OUT << "end_of_input";
  bth_files: $j, $bfiles[$j]
end_of_input
                    }
                } elsif ($props{$id}{src_type} =~ /RiverCon/i) {
                    @brs    = split(/,/, $props{$id}{br_list});
                    @rlines = @{ $props{$id}{riv_lines} };
                    @rfiles = @{ $props{$id}{riv_files} };
                    @bfiles = @{ $props{$id}{bth_files} };
                    for ($j=0; $j<=$#rfiles; $j++) {
                        $rfiles[$j] = File::Spec->abs2rel($rfiles[$j], $vol . $dir);
                        print OUT << "end_of_input";
  riv_info:  $j, $brs[$j], $rlines[$j]
  riv_files: $j, $rfiles[$j]
end_of_input
                    }
                    for ($j=0; $j<=$#bfiles; $j++) {
                        $bfiles[$j] = File::Spec->abs2rel($bfiles[$j], $vol . $dir);
                        print OUT << "end_of_input";
  bth_files: $j, $bfiles[$j]
end_of_input
                    }
                } elsif ($props{$id}{src_type} =~ /SurfTemp|VolTemp|FlowTemp/i) {
                    $src_file = File::Spec->abs2rel($props{$id}{src_file}, $vol . $dir);
                    print OUT << "end_of_input";
  src_file:  $src_file
  src_lines: $props{$id}{src_lines}
end_of_input
                    @bfiles = @{ $props{$id}{bth_files} };
                    for ($j=0; $j<=$#bfiles; $j++) {
                        $bfiles[$j] = File::Spec->abs2rel($bfiles[$j], $vol . $dir);
                        print OUT << "end_of_input";
  bth_files: $j, $bfiles[$j]
end_of_input
                    }
                }
                if ($props{$id}{map_type} eq "filediff") {
                    print OUT << "end_of_input";
  src_type2: $props{$id}{src_type2}
  match_tol: $props{$id}{match_tol}
end_of_input
                    if ($props{$id}{src_type2} =~ /Contour/i) {
                        @tecplot = @{ $props{$id}{tecplot2}   };
                        @clines  = @{ $props{$id}{cpl_lines2} };
                        @cfiles  = @{ $props{$id}{cpl_files2} };
                        for ($j=0; $j<=$#cfiles; $j++) {
                            $cfiles[$j] = File::Spec->abs2rel($cfiles[$j], $vol . $dir);
                            print OUT << "end_of_input";
  cpl_info2: $j, $tecplot[$j], $clines[$j]
  cpl_file2: $j, $cfiles[$j]
end_of_input
                        }
                    } elsif ($props{$id}{src_type2} =~ /Vector/i) {
                        $w2l_file = File::Spec->abs2rel($props{$id}{w2l_file2}, $vol . $dir);
                        print OUT << "end_of_input";
  w2l_file2: $w2l_file
end_of_input
                    } elsif ($props{$id}{src_type2} =~ /RiverCon/i) {
                        @brs    = split(/,/, $props{$id}{br_list2});
                        @rlines = @{ $props{$id}{riv_lines2} };
                        @rfiles = @{ $props{$id}{riv_files2} };
                        for ($j=0; $j<=$#rfiles; $j++) {
                            $rfiles[$j] = File::Spec->abs2rel($rfiles[$j], $vol . $dir);
                            print OUT << "end_of_input";
  riv_info2: $j, $brs[$j], $rlines[$j]
  riv_file2: $j, $rfiles[$j]
end_of_input
                        }
                    } elsif ($props{$id}{src_type2} =~ /SurfTemp|VolTemp|FlowTemp/i) {
                        $src_file = File::Spec->abs2rel($props{$id}{src_file2}, $vol . $dir);
                        print OUT << "end_of_input";
  src_file2: $src_file
  src_line2: $props{$id}{src_lines2}
end_of_input
                    }
                }
                print OUT << "end_of_input";
  seg_list:  $props{$id}{seg_list}
  wb_list:   $props{$id}{wb_list}
  parm:      $props{$id}{parm_sav}
  parm_div:  $props{$id}{pdiv_sav}
  ctype:     $props{$id}{ctype}
end_of_input
                if ($props{$id}{map_type} eq "parmdiff") {
                    print OUT << "end_of_input";
  parm2:     $props{$id}{parm2_sav}
  parm2_div: $props{$id}{pdiv2_sav}
  ctype2:    $props{$id}{ctype2}
end_of_input
                }
                if ($props{$id}{map_type} =~ /^(parmdiff|filediff)$/) {
                    print OUT << "end_of_input";
  diff_swap: $props{$id}{swap_order}
end_of_input
                }
                print OUT << "end_of_input";
  parmunits: $props{$id}{parm_units}
  prof_stat: $props{$id}{prof_stat}
  byear:     $props{$id}{byear}
  tz_offset: $props{$id}{tz_offset}
  jd_skip:   $props{$id}{jd_skip}
end_of_input
            } elsif ($props{$id}{meta} =~ /w2_outflow/) {
                $con_file = File::Spec->abs2rel($props{$id}{con_file}, $vol . $dir);
                $bth_file = File::Spec->abs2rel($props{$id}{bth_file}, $vol . $dir);
                $qla_file = File::Spec->abs2rel($props{$id}{qla_file}, $vol . $dir);
                print OUT << "end_of_input";
  con_file:  $con_file
  bth_file:  $bth_file
  qla_file:  $qla_file
  qla_lines: $props{$id}{qla_lines}
  seg:       $props{$id}{seg}
  byear:     $props{$id}{byear}
  tz_offset: $props{$id}{tz_offset}
  jd_skip:   $props{$id}{jd_skip}
  qla_parm:  $props{$id}{add_parm}
end_of_input
                if ($props{$id}{add_parm}) {
                    $src_file = File::Spec->abs2rel($props{$id}{src_file}, $vol . $dir);
                    print OUT << "end_of_input";
  src_type:  $props{$id}{src_type}
  src_file:  $src_file
end_of_input
                    if ($props{$id}{src_type} =~ /Spreadsheet|LakeCon/i) {
                        print OUT << "end_of_input";
  src_lines: $props{$id}{src_lines}
end_of_input
                    } elsif ($props{$id}{src_type} =~ /Contour/i) {
                        print OUT << "end_of_input";
  src_lines: $props{$id}{src_lines}
  tplot:     $props{$id}{tplot}
end_of_input
                    }
                    print OUT << "end_of_input";
  parm:      $props{$id}{parm}
  parm_div:  $props{$id}{parm_div}
  parmunits: $props{$id}{parm_units}
  ctype:     $props{$id}{parm_ctype}
  parm_skip: $props{$id}{parm_skip}
  match_tol: $props{$id}{match_tol}
  add_cs:    $gr_props{$id}{add_cs}
end_of_input
                }
            } elsif ($props{$id}{meta} eq "vert_wd_zone") {
                $wt_file   = File::Spec->abs2rel($props{$id}{wt_file}, $vol . $dir);
                $flow_file = File::Spec->abs2rel($props{$id}{flow_file}, $vol . $dir);
                $bth_file  = File::Spec->abs2rel($props{$id}{bth_file},  $vol . $dir);
                print OUT << "end_of_input";
  wt_file:   $wt_file
  flow_file: $flow_file
  bth_file:  $bth_file
end_of_input
                if ($props{$id}{wd_alg} eq "Libby Dam") {
                    $lbc_file = File::Spec->abs2rel($props{$id}{lbc_file}, $vol . $dir);
                    print OUT << "end_of_input";
  lbc_file:  $lbc_file
  bh_show:   $gr_props{$id}{bh_show}
  bh_docked: $gr_props{$id}{bh_docked}
  bh_xpos:   $gr_props{$id}{bh_xpos}
  bh_ypos:   $gr_props{$id}{bh_ypos}
  bh_font:   $gr_props{$id}{bh_font}
  bh_size:   $gr_props{$id}{bh_size}
  bh_weight: $gr_props{$id}{bh_weight}
  bh_tcolor: $gr_props{$id}{bh_tcolor}
  bh_bwidth: $gr_props{$id}{bh_bwidth}
  bh_bcolor: $gr_props{$id}{bh_bcolor}
  bh_bcellw: $gr_props{$id}{bh_bcellw}
  bh_bcellh: $gr_props{$id}{bh_bcellh}
end_of_input
                }
                print OUT << "end_of_input";
  wd_alg:    $props{$id}{wd_alg}
  seg:       $props{$id}{seg}
  elbot:     $props{$id}{elbot}
  add_cs:    $gr_props{$id}{add_cs}
end_of_input
            }
            if ($props{$id}{meta} =~ /^(data_profile|w2_profile)$/) {
                print OUT << "end_of_input";
  add_cs:    $gr_props{$id}{add_cs}
end_of_input
            }
            if ($props{$id}{meta} !~ /time_series/ && defined($gr_props{$id}{add_cs})) {
                print OUT << "end_of_input";
  cs_hide:   $gr_props{$id}{cs_hide}
  cs_link:   $gr_props{$id}{cs_link}
  cscheme1:  $gr_props{$id}{cscheme1}
  cscheme2:  $gr_props{$id}{cscheme2}
  ncolors:   $gr_props{$id}{ncolors}
  cs_rev:    $gr_props{$id}{cs_rev}
  cs_min:    $gr_props{$id}{cs_min}
  cs_max:    $gr_props{$id}{cs_max}
  cs_major:  $gr_props{$id}{cs_major}
  cs_width:  $gr_props{$id}{cs_width}
  cs_height: $gr_props{$id}{cs_height}
  xleg_off:  $gr_props{$id}{xleg_off}
  yleg_off:  $gr_props{$id}{yleg_off}
  keyfont:   $gr_props{$id}{keyfont}
  keytitle:  $gr_props{$id}{keytitle}
  kt_size:   $gr_props{$id}{kt_size}
  kt_weight: $gr_props{$id}{kt_weight}
  kn_size:   $gr_props{$id}{kn_size}
  kn_weight: $gr_props{$id}{kn_weight}
  kn_digits: $gr_props{$id}{kn_digits}
end_of_input
            }
            if ($props{$id}{meta} eq "w2_tdmap") {
                print OUT << "end_of_input";
  date_axis: $gr_props{$id}{date_axis}
  ttitle:    $gr_props{$id}{ttitle}
  tfont:     $gr_props{$id}{tfont}
  tt_size:   $gr_props{$id}{tt_size}
  tt_weight: $gr_props{$id}{tt_weight}
  tl_size:   $gr_props{$id}{tl_size}
  tl_weight: $gr_props{$id}{tl_weight}
  tmin:      $gr_props{$id}{tmin}
  tmax:      $gr_props{$id}{tmax}
  tmajor:    $gr_props{$id}{tmajor}
  tpr_tics:  $gr_props{$id}{tpr_tics}
  top_tics:  $gr_props{$id}{top_tics}
  ttype:     $gr_props{$id}{ttype}
  tflip:     $gr_props{$id}{tflip}
  base_yr:   $gr_props{$id}{base_yr}
  datefmt:   $gr_props{$id}{datefmt}
  dtitle:    $gr_props{$id}{dtitle}
  dfont:     $gr_props{$id}{dfont}
  dt_size:   $gr_props{$id}{dt_size}
  dt_weight: $gr_props{$id}{dt_weight}
  dl_size:   $gr_props{$id}{dl_size}
  dl_weight: $gr_props{$id}{dl_weight}
  dbase:     $gr_props{$id}{dbase}
  dmin:      $gr_props{$id}{dmin}
  dmax:      $gr_props{$id}{dmax}
  dmax_auto: $gr_props{$id}{dmax_auto}
  dfirst:    $gr_props{$id}{dfirst}
  dmajor:    $gr_props{$id}{dmajor}
  dpr_tics:  $gr_props{$id}{dpr_tics}
  dop_tics:  $gr_props{$id}{dop_tics}
  dflip:     $gr_props{$id}{dflip}
  dunits:    $gr_props{$id}{dunits}
end_of_input
            } else {
                print OUT << "end_of_input";
  xtitle:    $gr_props{$id}{xtitle}
  xfont:     $gr_props{$id}{xfont}
  xt_size:   $gr_props{$id}{xt_size}
  xt_weight: $gr_props{$id}{xt_weight}
  xl_size:   $gr_props{$id}{xl_size}
  xl_weight: $gr_props{$id}{xl_weight}
  xmin:      $gr_props{$id}{xmin}
  xmax:      $gr_props{$id}{xmax}
  xmajor:    $gr_props{$id}{xmajor}
  xpr_tics:  $gr_props{$id}{xpr_tics}
  xop_tics:  $gr_props{$id}{xop_tics}
end_of_input
            }
            if ($props{$id}{meta} =~ /w2_slice|w2_wlevels/) {
                print OUT << "end_of_input";
  xmax_auto: $gr_props{$id}{xmax_auto}
  xbase:     $gr_props{$id}{xbase}
  xfirst:    $gr_props{$id}{xfirst}
  xflip:     $gr_props{$id}{xflip}
  xunits:    $gr_props{$id}{xunits}
end_of_input
            }
            if ($props{$id}{meta} =~ /(data_profile_cmap|w2_profile_cmap|time_series)/) {
                if (! defined($gr_props{$id}{base_yr}) || $gr_props{$id}{base_yr} eq "") {
                    $gr_props{$id}{base_yr} = (localtime(time))[5] +1900;
                }
                print OUT << "end_of_input";
  xtype:     $gr_props{$id}{xtype}
  base_yr:   $gr_props{$id}{base_yr}
  datefmt:   $gr_props{$id}{datefmt}
  dateline:  $gr_props{$id}{dateline}
  datelinec: $gr_props{$id}{datelinec}
end_of_input
            }
            if ($props{$id}{meta} =~ /w2_outflow|vert_wd_zone/) {
                print OUT << "end_of_input";
  qunits:    $gr_props{$id}{qunits}
end_of_input
                if ($props{$id}{meta} eq "vert_wd_zone") {
                    print OUT << "end_of_input";
  wt_units:  $props{$id}{wt_units}
end_of_input
                }
            }
            if ($props{$id}{meta} =~ /(data_profile|w2_profile|w2_slice|w2_outflow|vert_wd_zone)/) {
                print OUT << "end_of_input";
  ytype:     $gr_props{$id}{ytype}
  yunits:    $gr_props{$id}{yunits}
end_of_input
            } elsif ($props{$id}{meta} eq "w2_wlevels") {
                print OUT << "end_of_input";
  yunits:    $gr_props{$id}{yunits}
end_of_input
            }
            if ($props{$id}{meta} ne "w2_tdmap") {
                print OUT << "end_of_input";
  ytitle:    $gr_props{$id}{ytitle}
  yfont:     $gr_props{$id}{yfont}
  yt_size:   $gr_props{$id}{yt_size}
  yt_weight: $gr_props{$id}{yt_weight}
  yl_size:   $gr_props{$id}{yl_size}
  yl_weight: $gr_props{$id}{yl_weight}
  ymin:      $gr_props{$id}{ymin}
  ymax:      $gr_props{$id}{ymax}
  ymajor:    $gr_props{$id}{ymajor}
  ypr_tics:  $gr_props{$id}{ypr_tics}
  yop_tics:  $gr_props{$id}{yop_tics}
end_of_input
            }
            if ($props{$id}{meta} =~ /w2_slice|w2_wlevels/) {
                print OUT << "end_of_input";
  stype:     $gr_props{$id}{stype}
  sfont:     $gr_props{$id}{sfont}
  st_size:   $gr_props{$id}{st_size}
  st_weight: $gr_props{$id}{st_weight}
  sl_size:   $gr_props{$id}{sl_size}
  sl_weight: $gr_props{$id}{sl_weight}
  stic_loc:  $gr_props{$id}{stic_loc}
  smajor:    $gr_props{$id}{smajor}
  spr_tics:  $gr_props{$id}{spr_tics}
  sop_tics:  $gr_props{$id}{sop_tics}
  sgrid:     $gr_props{$id}{sgrid}
  sgrid_col: $gr_props{$id}{sgrid_col}
  bgrid:     $gr_props{$id}{bgrid}
  bgrid_col: $gr_props{$id}{bgrid_col}
  stitle:    $gr_props{$id}{stitle}
end_of_input
            }
            print OUT << "end_of_input";
  gtitle:    $gr_props{$id}{gtitle}
end_of_input
            if ($props{$id}{meta} eq "w2_tdmap") {
                print OUT << "end_of_input";
  gstitle:   $gr_props{$id}{gstitle}
end_of_input
            }
            print OUT << "end_of_input";
  gtfont:    $gr_props{$id}{gtfont}
  gt_size:   $gr_props{$id}{gt_size}
  gt_weight: $gr_props{$id}{gt_weight}
end_of_input
            if ($props{$id}{meta} =~ /^(data_profile|w2_profile|w2_slice|w2_outflow|vert_wd_zone)$/) {
                print OUT << "end_of_input";
  gs_size:   $gr_props{$id}{gs_size}
  gs_weight: $gr_props{$id}{gs_weight}
end_of_input
            } elsif ($props{$id}{meta} eq "w2_wlevels") {
                print OUT << "end_of_input";
  gs_size:   $gr_props{$id}{gs_size}
  gs_weight: $gr_props{$id}{gs_weight}
  wl_color:  $gr_props{$id}{wl_color}
  wl_style:  $gr_props{$id}{wl_style}
  wl_grid:   $gr_props{$id}{wl_grid}
  wl_gridc:  $gr_props{$id}{wl_gridc}
end_of_input
            } elsif ($props{$id}{meta} eq "w2_tdmap") {
                print OUT << "end_of_input";
  gs_size:   $gr_props{$id}{gs_size}
  gs_weight: $gr_props{$id}{gs_weight}
  hidetitle: $gr_props{$id}{hide_title}
  hidetaxis: $gr_props{$id}{hide_taxis}
  hidedaxis: $gr_props{$id}{hide_daxis}
end_of_input
            }
            if ($props{$id}{meta} eq "w2_profile" && defined($props{$id}{ref_file})) {
                $ref_file = File::Spec->abs2rel($props{$id}{ref_file}, $vol . $dir);
                print OUT << "end_of_input";
  ref_file:  $ref_file
  ref_ctype: $props{$id}{ref_ctype}
  ref_tol:   $props{$id}{ref_tol}
  ref_color: $props{$id}{ref_color}
  ref_hide:  $props{$id}{ref_hide}
end_of_input
            }
            if ($props{$id}{meta} =~ /time_series/) {
                print OUT << "end_of_input";
  gridx:     $gr_props{$id}{gridx}
  gridy:     $gr_props{$id}{gridy}
  gridwidth: $gr_props{$id}{gridwidth}
  gridcolor: $gr_props{$id}{gridcolor}
  legtitle:  $gr_props{$id}{legtitle}
  legfont:   $gr_props{$id}{legfont}
  lt_size:   $gr_props{$id}{lt_size}
  lt_weight: $gr_props{$id}{lt_weight}
  le_size:   $gr_props{$id}{le_size}
  le_weight: $gr_props{$id}{le_weight}
  le_edge:   $gr_props{$id}{le_edge}
  le_edgec:  $gr_props{$id}{le_edgec}
  le_fill:   $gr_props{$id}{le_fill}
  le_fillc:  $gr_props{$id}{le_fillc}
  xleg_off:  $gr_props{$id}{xleg_off}
  yleg_off:  $gr_props{$id}{yleg_off}
  gap_tol:   $gr_props{$id}{gap_tol}
end_of_input
                if ($props{$id}{meta} eq "linked_time_series") {
                    $gnum = $props{$props{$id}{link_id}}{gnum};
                    print OUT << "end_of_input";
  ts_gnum:   $gnum
end_of_input
                }
                %parms = %{ $props{$id}{ts_parms} };
                print OUT << "end_of_input";
  ts_type:   $parms{ts_type}
  ts_units:  $parms{units}
end_of_input
                if ($props{$id}{meta} eq "linked_time_series") {
                    @show      = @{ $parms{show}  };
                    @width     = @{ $parms{width} };
                    @color     = @{ $parms{color} };
                    $show_sets = $show[0];
                    $widths    = $width[0];
                    $colors    = $color[0];
                    for ($j=1; $j<=$#show; $j++) {
                        $show_sets .= ', ' . $show[$j];
                        $widths    .= ', ' . $width[$j];
                        $colors    .= ', ' . $color[$j];
                    }
                    print OUT << "end_of_input";
  ts_show:   $show_sets
  ts_width:  $widths
  ts_color:  $colors
end_of_input
                }
                if (defined($props{$id}{add_ts_parms})) {
                    %parms  = %{ $props{$id}{add_ts_parms} };
                    @setnum = @{ $parms{ts_setnum} };
                    @tsfile = @{ $parms{ts_file}   };
                    @ftype  = @{ $parms{ts_ftype}  };
                    @show   = @{ $parms{ts_show}   };
                    @width  = @{ $parms{ts_width}  };
                    @color  = @{ $parms{ts_color}  };
                    @text   = @{ $parms{ts_text}   };
                    @param  = @{ $parms{ts_param}  };
                    @byear  = @{ $parms{ts_byear}  };
                    @tzoff  = @{ $parms{ts_tzoff}  };
                    @seg    = @{ $parms{ts_seg}    };
                    @ctype  = @{ $parms{ts_ctype}  };
                    for ($j=0; $j<=$#setnum; $j++) {
                        $tsfile[$j] = File::Spec->abs2rel($tsfile[$j], $vol . $dir);
                        print OUT << "end_of_input";
  add_data:  $setnum[$j], $tsfile[$j]
  add_ftype: $setnum[$j], $ftype[$j]
  add_ctype: $setnum[$j], $ctype[$j]
  add_parm:  $setnum[$j], $param[$j]
  add_show:  $setnum[$j], $show[$j]
  add_width: $setnum[$j], $width[$j]
  add_color: $setnum[$j], $color[$j]
  add_text:  $setnum[$j], $text[$j]
end_of_input
                        if ($ftype[$j] =~ /^W2 /) {
                            print OUT << "end_of_input";
  add_byear: $setnum[$j], $byear[$j]
  add_tzoff: $setnum[$j], $tzoff[$j]
  add_seg:   $setnum[$j], $seg[$j]
end_of_input
                        }
                    }
                }
            }

        } elsif ($type eq "text") {
            if (defined($link_props{$id}{id})) {        # saved link text should be generic
                if ($link_props{$id}{form} eq "stat") {
                    ($txt = $props{$id}{text}) =~ s/([a-zA-Z]): .*$/$1: link/;
                } else {
                    $txt = "link";
                }
            } else {
                $txt = $props{$id}{text};
            }
            print OUT << "end_of_input";
$type
  text:      $txt
  x:         $xt
  y:         $yt
  anchor:    $props{$id}{anchor}
  color:     $props{$id}{color}
  family:    $props{$id}{family}
  size:      $props{$id}{size}
  weight:    $props{$id}{weight}
  slant:     $props{$id}{slant}
  underline: $props{$id}{underline}
  angle:     $props{$id}{angle}
end_of_input
        } elsif ($type eq "image") {
            $scale = sprintf("%.5f", $props{$id}{iw} /$props{$id}{iwc});
            @crop  = @{ $props{$id}{crop} };
            $croplist = sprintf("%.5f", $crop[0]);
            for ($j=1; $j<=3; $j++) {
                $croplist .= ', ' . sprintf("%.5f", $crop[$j]);
            }
            $img_file = File::Spec->abs2rel($props{$id}{file}, $vol . $dir);
            print OUT << "end_of_input";
$type
  x:         $xt
  y:         $yt
  anchor:    $props{$id}{anchor}
  angle:     $props{$id}{angle}
  crop:      $croplist
  scale:     $scale
  flip:      $props{$id}{flip}
  file:      $img_file
end_of_input
        } else {
            $xct = $props{$id}{xc} -3;
            $yct = $props{$id}{yc} -3;
            print OUT << "end_of_input";
$type
  x:         $xt
  y:         $yt
  xc:        $xct
  yc:        $yct
  anchor:    $props{$id}{anchor}
  color:     $props{$id}{color}
  width:     $props{$id}{width}
end_of_input
            if ($type =~ /rectangle|diamond|polygon|circle|ellipse/i) {
                if (defined($link_props{$id}{id})) {
                    $fill      = 1;
                    $fillcolor = ""
                } else {
                    $fill      = $props{$id}{fill};
                    $fillcolor = $props{$id}{fillcolor};
                }
            }
            if ($type eq "ellipse") {
                print OUT << "end_of_input";
  fill:      $fill
  fillcolor: $fillcolor
  angle:     $props{$id}{angle}
  hw:        $props{$id}{hw}
  hh:        $props{$id}{hh}
end_of_input
            } else {
                @coords = @{ $props{$id}{coordlist} };
                $coordlist = sprintf("%.5f", $coords[0]-3);
                for ($j=1; $j<=$#coords; $j++) {
                    $coordlist .= ', ' . sprintf("%.5f", $coords[$j]-3);
                }
                
                if ($type =~ /^(rectangle|diamond)$/) {
                    print OUT << "end_of_input";
  fill:      $fill
  fillcolor: $fillcolor
  angle:     $props{$id}{angle}
  smooth:    $props{$id}{smooth}
  coordlist: $coordlist
end_of_input
                } elsif ($type eq "polygon") {
                    print OUT << "end_of_input";
  fill:      $fill
  fillcolor: $fillcolor
  angle:     $props{$id}{angle}
  coordlist: $coordlist
end_of_input
                } elsif ($type eq "polyline") {
                    print OUT << "end_of_input";
  angle:     $props{$id}{angle}
end_of_input
                } elsif ($type eq "circle") {
                    print OUT << "end_of_input";
  fill:      $fill
  fillcolor: $fillcolor
  coordlist: $coordlist
end_of_input
                }
                if ($type =~ /^(line|polyline)$/) {
                    print OUT << "end_of_input";
  arrow:     $props{$id}{arrow}
  ahd1:      $props{$id}{ahd1}
  ahd2:      $props{$id}{ahd2}
  ahd3:      $props{$id}{ahd3}
  coordlist: $coordlist
end_of_input
                }
            }
        }
        if (defined($link_props{$id}{id})) {
            if ($link_props{$id}{form} eq "stat") {
                print OUT << "end_of_input";
  ln_gnum:   $link_props{$id}{gnum}
  ln_form:   $link_props{$id}{form}
  ln_type:   $link_props{$id}{type}
  ln_tol:    $link_props{$id}{tol}
  ln_interp: $link_props{$id}{interp}
  ln_digits: $link_props{$id}{digits}
end_of_input
            } else {
                print OUT << "end_of_input";
  ln_gnum:   $link_props{$id}{gnum}
  ln_type:   $link_props{$id}{type}
  ln_outlet: $link_props{$id}{outlet}
  ln_form:   $link_props{$id}{form}
  ln_units:  $link_props{$id}{units}
  ln_digits: $link_props{$id}{digits}
end_of_input
            }
        }
        if ($group_tags ne "") {
            print OUT "  grouptags: $group_tags\n";
        }
        print OUT "end $type\n";
    }
    print OUT "==== END OBJECTS ====\n";
    $delay_autosave = 0;
    if (! $silent) {
        close (OUT) || return &pop_up_error($main, "Trouble closing\n$file");
        $main->g_wm_title("W2 Animator  --  $file");
    } else {
        close (OUT);
    }
}


sub print_canvas {
    my ($fmt, $scalefac, $print_file) = @_;
    my (
        $b, $code, $eps_file, $fh, $g, $img, $png_file, $png_height,
        $png_width, $ps_add, $psdata, $r, $replace_str, $rnum, $search_str,
        @cmd_args,
       );

#   Get output file name.
    if ($fmt eq "PostScript") {
        $print_file = Tkx::tk___getSaveFile(
            -parent           => $main,
            -title            => 'Save as Encapsulated PostScript',
            -initialdir       => abs_path(),
            -defaultextension => ".eps",
            -filetypes => [ ['Encapsulated PostScript Files', '.eps'],
                            ['All Files', '*'],
                          ],
            );
    } elsif ($fmt eq "PDF") {
        $print_file = Tkx::tk___getSaveFile(
            -parent           => $main,
            -title            => 'Save as PDF',
            -initialdir       => abs_path(),
            -defaultextension => ".pdf",
            -filetypes => [ ['Portable Document Format', '.pdf'],
                            ['All Files', '*'],
                          ],
            );
    }
    if (! defined($print_file) || $print_file eq "") {
        return &pop_up_error($main, "Output file not specified.\nAborting...");
    }
    if ($fmt eq "Raster") {
        if ($print_file !~ /(\.bmp|\.gif|\.jpg|\.jpeg|\.png|\.ppm|\.tga|\.tif|\.tiff)$/i) {
            return &pop_up_error($main, "Output file format not recognized from file name.\n"
                                      . "Please use a file name extension that is one of:\n"
                                      . ".bmp, .gif, .jpg, .jpeg, .png, .ppm, .tga, .tif, or .tiff\n"
                                      . "Aborting...");
        }
        ($fmt = lc($print_file)) =~ s/.*(bmp|gif|jpg|jpeg|png|ppm|tga|tif|tiff)$/$1/i;
        $fmt = "jpeg" if ($fmt eq "jpg");
    }

#   End any current selection.
    &end_select($canvas, $old_id) if (defined($old_id));

#   Set the application to a busy state.
    Tkx::tk_busy_hold($main, -cursor => $cursor_wait);
    $status_line = "Working on print file $print_file.  Please wait...";
    Tkx::update();

#   Generate PS code to fill the background with the canvas color.
    $code    = &get_rgb_code($canvas_color);
    $r       = &hex2decimal(substr($code,1,2)) /255.;   # as a fraction between 0 and 1
    $g       = &hex2decimal(substr($code,3,2)) /255.;
    $b       = &hex2decimal(substr($code,5,2)) /255.;
    $ps_add  = "3 1 moveto\n";
    $ps_add .= sprintf("%d 1 lineto\n", $canvas_width +2);
    $ps_add .= sprintf("%d %d lineto\n", $canvas_width +2, $canvas_height);
    $ps_add .= sprintf("3 %d lineto\n", $canvas_height);
    $ps_add .= "3 1 lineto\n";
    $ps_add .= sprintf("%5.3f %5.3f %5.3f setrgbcolor AdjustColor\n", $r, $g, $b);
    $ps_add .= "fill\ngrestore\ngsave\n";

#   PostScript option
    if ($fmt =~ /^(PostScript|PDF)$/) {
        $psdata = $canvas->postscript(-x => 3, -y => 3,
                                      -width      => $canvas_width,  -pagex => 0,
                                      -height     => $canvas_height, -pagey => 0,
                                      -pageanchor => 'sw',
                                      -pagewidth  => $canvas_width /$pixels_per_pt);

#       Swap "fill" for "eofill" commands
#       $psdata =~ s/eofill/fill/g;

#       Because of a bug in the canvas postscript method, need to redefine the scalefont function
#       Otherwise, all of the text will be too small
        $psdata =~ s/\%\%EndProlog/\/scalefont \{$pixels_per_pt mul scalefont\} bind def\n\%\%EndProlog/;

#       Fill the background with the canvas color.  Add code after "closepath clip newpath\ngsave"
        $psdata =~ s/closepath clip newpath\ngsave\n/closepath clip newpath\ngsave\n$ps_add/;

#       Tweak the bounding box in the EPS file slightly
        $search_str  = sprintf("%d %d", int(($canvas_width+1)  /$pixels_per_pt +0.5),
                                        int(($canvas_height+1) /$pixels_per_pt +0.5));
        $replace_str = sprintf("%d %d", int($canvas_width  /$pixels_per_pt +0.5),
                                        int($canvas_height /$pixels_per_pt +0.5));
        $psdata =~ s/\%\%BoundingBox: 0 0 $search_str/\%\%BoundingBox: 0 0 $replace_str/;

#       Write output
        if ($fmt eq "PostScript") {
            open ($fh, ">", $print_file)
                        || do { Tkx::tk_busy_forget($main);
                                $status_line = "Printing failed.";
                                return &pop_up_error($main, "Unable to open\n$print_file");
                              };
            print $fh $psdata;
            close ($fh) || do { Tkx::tk_busy_forget($main);
                                $status_line = "Printing failed.";
                                return &pop_up_error($main, "Trouble closing\n$print_file");
                              };
        } else {
            $rnum     = &get_random_number();
            $eps_file = "tmp_" . $rnum . ".eps";
            if ($use_temp) {
                $eps_file = $temp_dir . '/' . $eps_file;
            }
            open ($fh, ">", $eps_file)
                        || do { Tkx::tk_busy_forget($main);
                                $status_line = "Printing failed.";
                                return &pop_up_error($main, "Unable to open\n$eps_file");
                              };
            print $fh $psdata;
            close ($fh) || do { Tkx::tk_busy_forget($main);
                                $status_line = "Printing failed.";
                                return &pop_up_error($main, "Trouble closing\n$eps_file");
                              };

#           Break out each term of the command line to avoid problems with spaces in PATHs
            @cmd_args = ($GS_PROG, "-dSAFER", "-dBATCH", "-dNOPAUSE", "-dQUIET", "-sDEVICE=pdfimage24",
                         "-sFONTPATH=C:\\Windows\\Fonts", "-dEPSCrop", "-o", $print_file, $eps_file);
            system(@cmd_args);
            unlink $eps_file;
        }

    } else {
        $rnum     = &get_random_number();
        $eps_file = "tmp_" . $rnum . ".eps";
        if ($use_temp) {
            $eps_file = $temp_dir . '/' . $eps_file;
        }
        if ($fmt eq "png") {
            $png_file = $print_file;
        } else {
            $png_file = "tmp_" . $rnum . ".png";
            if ($use_temp) {
                $png_file = $temp_dir . '/' . $png_file;
            }
        }
        $png_width  = &round_to_int($canvas_width  *$scalefac /100);
        $png_height = &round_to_int($canvas_height *$scalefac /100);
        $psdata = $canvas->postscript(-x => 3, -y => 3,
                                      -width      => $canvas_width,  -pagex => 0,
                                      -height     => $canvas_height, -pagey => 0,
                                      -pageanchor => 'sw',
                                      -pagewidth  => $png_width);

#       Swap "fill" for "eofill" commands
#       $psdata =~ s/eofill/fill/g;

#       Because of a bug in the canvas postscript method, need to redefine the scalefont function
#       Otherwise, all of the text will be too small
        $psdata =~ s/\%\%EndProlog/\/scalefont \{$pixels_per_pt mul scalefont\} bind def\n\%\%EndProlog/;

#       Fill the background with the canvas color.  Add code after "closepath clip newpath\ngsave"
        $psdata =~ s/closepath clip newpath\ngsave\n/closepath clip newpath\ngsave\n$ps_add/;

        open ($fh, ">", $eps_file)
                    || do { Tkx::tk_busy_forget($main);
                            $status_line = "Printing failed.";
                            return &pop_up_error($main, "Unable to open temporary file\n$eps_file");
                          };
        print $fh $psdata;
        close ($fh) || do { Tkx::tk_busy_forget($main);
                            $status_line = "Printing failed.";
                            return &pop_up_error($main, "Trouble closing\n$eps_file");
                          };

#       Break out each term of the command line to avoid problems with spaces in PATHs
        @cmd_args = ($GS_PROG, "-dSAFER", "-dQUIET", "-sDEVICE=png16m", "-dGraphicsAlphaBits=2",
                     "-dTextAlphaBits=4", "-sFONTPATH=C:\\Windows\\Fonts",
                     "-g${png_width}x${png_height}", "-o", $png_file, $eps_file);
        system(@cmd_args);
        unlink $eps_file;
        if ($fmt ne "png") {
            $img = Imager->new;
            $img->read(file => $png_file)
                    || do { Tkx::tk_busy_forget($main);
                            $status_line = "Printing failed.";
                            return &pop_up_error($main,
                                                 "Problem loading temporary image file\n $img->errstr");
                          };
            if ($fmt eq "gif") {
                $img->write(file => $print_file, type => $fmt, translate => 'giflib', max_colors => 256)
                    || do { Tkx::tk_busy_forget($main);
                            $status_line = "Printing failed.";
                            return &pop_up_error($main, "Problem creating image file\n $img->errstr");
                          };
            } elsif ($fmt eq "jpeg") {
                $img->write(file => $print_file, type => $fmt, jpegquality => 100)
                    || do { Tkx::tk_busy_forget($main);
                            $status_line = "Printing failed.";
                            return &pop_up_error($main, "Problem creating image file\n $img->errstr");
                          };
            } else {
                $img->write(file => $print_file, type => $fmt)
                    || do { Tkx::tk_busy_forget($main);
                            $status_line = "Printing failed.";
                            return &pop_up_error($main, "Problem creating image file\n $img->errstr");
                          };
            }
            unlink $png_file;
        }
    }

#   Unset the busy status.
    Tkx::tk_busy_forget($main);

    $status_line = "Printing completed.";
}


sub scale_output {
    my ($fmt, $revisit) = @_;
    my (
        $bdate_label, $del_frames_tmp, $edate_label, $ext, $f, $fmt_chars,
        $fmt_choice, $format, $format_cb, $frame_rate_scale, $frame,
        $frame_end_scale, $frame_end_tmp, $frame_rate_max, $frame_rate_tmp,
        $frame_start_scale, $frame_start_tmp, $geom, $i, $ok_btn, $outfile,
        $row, $scalemin, $scalemax, $sfac_scale, $sfac_tmp, $X, $Y,

        @extension, @filetypes, @fmt_types, @type_text,
       );

    $revisit = 0 if (! defined($revisit));

    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $geom = sprintf("+%d+%d", $X+70, $Y+60);

    if (defined($scale_output_menu) && Tkx::winfo_exists($scale_output_menu)) {
        if ($scale_output_menu->g_wm_title() eq "Select and Scale Output") {
            $scale_output_menu->g_destroy();
            undef $scale_output_menu;
        }
    }
    $scale_output_menu = $main->new_toplevel();
    $scale_output_menu->g_wm_transient($main);
    $scale_output_menu->g_wm_title("Select and Scale Output");
    $scale_output_menu->configure(-cursor => $cursor_norm);
    $scale_output_menu->g_wm_geometry($geom);

    $outfile  =  "";
    $sfac_tmp = $scalefac;
    $scalemin =  50;
    $scalemax = 400;
    if ($fmt eq "Raster") {
        @filetypes = ( ['Portable Network Graphics files', '.png'],
                       ['Graphics Interchange Format files', '.gif'],
                       ['Joint Photographic Experts Group files', ['.jpg','.jpeg']],
                       ['Win32 bitmaps', '.bmp'],
                       ['Unix portable pixmaps', '.ppm'],
                       ['Targa images', '.tga'],
                       ['Tagged Image Format files', ['.tif','.tiff']],
                       ['All image formats',
                           ['.bmp','.gif','.jpg','.jpeg','.png',
                            '.ppm','.tga','.tif','.tiff']],
                     );
        @type_text = ( 'Portable Network Graphics (PNG)',
                       'Graphics Interchange Format (GIF)',
                       'Joint Photographic Experts Group (JPEG)',
                       'Win32 bitmap (BMP)',
                       'Unix portable pixmap (PPM)',
                       'Targa image (TGA)',
                       'Tagged Image Format (TIFF)',
                     );
        @extension = ( '.png',
                       '.gif',
                       '.jpg',
                       '.bmp',
                       '.ppm',
                       '.tga',
                       '.tiff',
                     );

    } elsif ($fmt eq "Animation") {
        if ($use_FFmpeg) {
            @filetypes = ( ['Audio Video Interleave files', '.avi'],
                           ['Flash Video files', '.flv'],
                           ['Graphics Interchange Format files', '.gif'],
                           ['QuickTime Movie files', '.mov'],
                           ['MPEG-4 files', '.mp4'],
                           ['All video formats', ['.avi','.flv','.gif','.mov','.mp4']],
                         );
            @type_text = ( 'Audio Video Interleave (AVI)',
                           'Flash Video (FLV)',
                           'Graphics Interchange Format (GIF)',
                           'QuickTime Movie (MOV)',
                           'MPEG-4 (MP4)',
                         );
            @extension = ( '.avi',
                           '.flv',
                           '.gif',
                           '.mov',
                           '.mp4',
                         );
        } else {
            @filetypes = ( ['Graphics Interchange Format files', '.gif'],
                           ['All video formats', ['.gif']],
                         );
            @type_text = ( 'Graphics Interchange Format (GIF)',
                         );
            @extension = ( '.gif',
                         );
        }
        $frame_end       = $dti_max if (! defined($frame_end)   || $frame_end   > $dti_max);
        $frame_start     = 1        if (! defined($frame_start) || $frame_start > $frame_end);
        $frame_start_tmp = $frame_start;
        $frame_end_tmp   = $frame_end;
        ($bdate_label    = &get_formatted_date($dates[$frame_start-1])) =~ s/^\s+//;
        ($edate_label    = &get_formatted_date($dates[$frame_end  -1])) =~ s/^\s+//;
        $frame_rate_max  = 60;
        $frame_rate      = 5 if (! defined($frame_rate));
        $frame_rate_tmp  = &max(1, &min($frame_rate, $frame_rate_max));
        $delete_frames   = 1 if (! defined($delete_frames));
        $del_frames_tmp  = $delete_frames;
    }
    $fmt_choice = 0;
    $format     = $type_text[$fmt_choice];
    $ext        = $extension[$fmt_choice];
    @fmt_types  = ( $filetypes[$fmt_choice], $filetypes[$#filetypes] );
    $fmt_chars  = length($type_text[0]);
    for ($i=1; $i<=$#type_text; $i++) {
        $fmt_chars = length($type_text[$i]) if (length($type_text[$i]) > $fmt_chars);
    }

    $frame = $scale_output_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -state   => 'disabled',
            -command => sub { my ($file_ext);
                              if (! defined($outfile) || $outfile eq "") {
                                  return &pop_up_error($scale_output_menu,
                                      "Output file not set. Please try again.");
                              }
                              if (! defined($sfac_tmp) || $sfac_tmp < $scalemin || $sfac_tmp > $scalemax) {
                                  return &pop_up_error($scale_output_menu,
                                      "Output scale factor not defined or outside of limits.");
                              }
                              if ($fmt eq "Animation") {
                                  $frame_start_tmp = 1        if ($frame_start_tmp < 1);
                                  $frame_end_tmp   = $dti_max if ($frame_end_tmp   > $dti_max);
                                  if ($frame_start_tmp > $frame_end_tmp) {
                                      return &pop_up_error($scale_output_menu,
                                          "Frame start index is greater than frame end index.");
                                  }
                                  $frame_rate_tmp = 1               if ($frame_rate_tmp < 1);
                                  $frame_rate_tmp = $frame_rate_max if ($frame_rate_tmp > $frame_rate_max);
                              }
                              ($file_ext = $outfile) =~ s/.*(\..*)$/$1/;
                              if (&list_match($file_ext, @extension) < 0) {
                                  return &pop_up_error($scale_output_menu,
                                      "File extension not consistent with chosen output format.");
                              }
                              $scalefac = $sfac_tmp;
                              $scale_output_menu->g_destroy();
                              undef $scale_output_menu;
                              if ($fmt eq "Raster") {
                                  &print_canvas($fmt, $scalefac, $outfile);
                              } else {
                                  $frame_start   = $frame_start_tmp;
                                  $frame_end     = $frame_end_tmp;
                                  $frame_rate    = $frame_rate_tmp;
                                  $delete_frames = $del_frames_tmp;
                                  if ($revisit) {
                                      return &make_animation($revisit, $outfile, $frame_end -$frame_start +1,
                                                             $frame_rate, $delete_frames);
                                  } else {
                                      return &make_anim_frames($scalefac, $outfile, $frame_start,
                                                               $frame_end, $frame_rate, $delete_frames);
                                  }
                              }
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $scale_output_menu->g_destroy();
                              undef $scale_output_menu;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

    $f = $scale_output_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f->g_pack(-side => 'top');

    $row = 0;
    $f->new_label(
            -text => "Output Format: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e', -pady => 2);
    ($format_cb = $f->new_ttk__combobox(
            -textvariable => \$format,
            -values       => [ @type_text ],
            -state        => 'readonly',
            -width        => $fmt_chars,
            ))->g_grid(-row => $row, -column => 1, -columnspan => 2, -sticky => 'w', -pady => 2);
    $format_cb->g_bind("<<ComboboxSelected>>",
                    sub { my ($n);
                          $n = &list_match($format, @type_text);
                          if ($n >= 0) {
                              $fmt_choice = $n;
                              $ext        = $extension[$fmt_choice];
                              @fmt_types  = ( $filetypes[$fmt_choice], $filetypes[$#filetypes] );
                              if (defined($outfile) && $outfile ne "" && $outfile !~ /$ext$/) {
                                  $outfile =~ s/(.*)\..*/$1$ext/;
                              }
                              if ($fmt eq "Animation") {
                                  $frame_rate_max = ($ext eq '.gif') ? 10 : 60;
                                  $frame_rate_tmp = &min($frame_rate_tmp, $frame_rate_max);
                                  $frame_rate_scale->configure(-to => $frame_rate_max);
                              }
                          }
                        }
                    );

    $row++;
    $f->new_label(
            -text => "Output File: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    $f->new_label(
            -textvariable => \$outfile,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            )->g_grid(-row => $row, -column => 1, -columnspan => 3, -sticky => 'ew');
    $f->new_button(
            -text    => "Browse",
            -command => sub { my ($file);
                              $file = Tkx::tk___getSaveFile(
                                      -parent           => $scale_output_menu,
                                      -title            => "Select Output File",
                                      -defaultextension => $ext,
                                      -initialdir       => abs_path(),
                                      -filetypes        => [ @fmt_types ],
                                      );
                              if ( $^O =~ /MSWin32/i ) {
                                  if (defined($file) && $file ne "") {
                                      $file =~ s/\//\\/g;
                                  }
                              }
                              if (defined($file) && $file ne "") {
                                  $outfile = $file;
                                  $ok_btn->configure(-state => 'normal');
                              } else {
                                  $ok_btn->configure(-state => 'disabled');
                              }
                            },
            )->g_grid(-row => $row, -column => 4, -sticky => 'ew', -padx => 2);

    $row++;
    $f->new_label(
            -text => "Scale Factor: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'se');
    ($sfac_scale = $f->new_scale(
            -orient       => 'horizontal',
            -from         => $scalemin,
            -to           => $scalemax,
            -variable     => \$sfac_tmp,
            -resolution   => 5,
            -length       => 150,
            -width        => 10,
            -sliderlength => 20,
            -takefocus    => 1,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'w');
    $f->new_label(
            -text => "percent",
            -font => 'default',
            )->g_grid(-row => $row, -column => 2, -sticky => 'sw', -padx => 2);
    $f->new_label(
            -text  => "",
            -font  => 'default',
            -width => 15,
            )->g_grid(-row => $row, -column => 3, -columnspan => 2, -sticky => 'sw', -padx => 2);

    if ($fmt eq "Animation") {
        $row++;
        $f->new_label(
                -text => "Start Frame: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'se');
        ($frame_start_scale = $f->new_scale(
                -orient       => 'horizontal',
                -from         => 1,
                -to           => $dti_max,
                -variable     => \$frame_start_tmp,
                -resolution   => 1,
                -length       => 150,
                -width        => 10,
                -sliderlength => 20,
                -takefocus    => 1,
                -command => sub { $frame_start_tmp = $frame_end_tmp if ($frame_start_tmp > $frame_end_tmp);
                                  $bdate_label = &get_formatted_date($dates[$frame_start_tmp-1]);
                                  $bdate_label =~ s/^\s+//;
                                },
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w');
        $f->new_label(
                -textvariable => \$bdate_label,
                -anchor       => 'w',
                -font         => 'default',
                )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'sw');

        $row++;
        $f->new_label(
                -text => "End Frame: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'se');
        ($frame_end_scale = $f->new_scale(
                -orient       => 'horizontal',
                -from         => 1,
                -to           => $dti_max,
                -variable     => \$frame_end_tmp,
                -resolution   => 1,
                -length       => 150,
                -width        => 10,
                -sliderlength => 20,
                -takefocus    => 1,
                -command => sub { $frame_end_tmp = $frame_start_tmp if ($frame_end_tmp < $frame_start_tmp);
                                  $edate_label = &get_formatted_date($dates[$frame_end_tmp-1]);
                                  $edate_label =~ s/^\s+//;
                                },
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w');
        $f->new_label(
                -textvariable => \$edate_label,
                -anchor       => 'w',
                -font         => 'default',
                )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'sw');

        $row++;
        $f->new_label(
                -text => "Frame Rate: ",
                -font => 'default',
                )->g_grid(-row => $row, -column => 0, -sticky => 'se');
        ($frame_rate_scale = $f->new_scale(
                -orient       => 'horizontal',
                -from         => 1,
                -to           => $frame_rate_max,
                -variable     => \$frame_rate_tmp,
                -resolution   => 1,
                -length       => 150,
                -width        => 10,
                -sliderlength => 20,
                -takefocus    => 1,
                ))->g_grid(-row => $row, -column => 1, -sticky => 'w');
        $f->new_label(
                -text   => "frames/sec",
                -anchor => 'w',
                -font   => 'default',
                )->g_grid(-row => $row, -column => 2, -columnspan => 3, -sticky => 'sw');

        $frame_rate_max = ($ext eq '.gif') ? 10 : 60;
        $frame_rate_tmp = &max(1, &min($frame_rate_tmp, $frame_rate_max));
        $frame_rate_scale->configure(-to => $frame_rate_max);

        $row++;
        $f->new_checkbutton(
                -onvalue  => 1,
                -offvalue => 0,
                -text     => "",
                -font     => 'default',
                -variable => \$del_frames_tmp,
                )->g_grid(-row => $row, -column => 0, -sticky => 'e');
        $f->new_label(
                -text   => "Delete frame images after creating video",
                -anchor => 'w',
                -font   => 'default',
                )->g_grid(-row => $row, -column => 1, -columnspan => 4, -sticky => 'w', -pady => 2);

        if ($revisit) {
            $sfac_scale->configure(-state => 'disabled');
            $frame_start_scale->configure(-state => 'disabled');
            $frame_end_scale->configure(-state => 'disabled');
        }
    }

    $f->g_grid_columnconfigure(2, -weight => 3);
    $f->g_grid_columnconfigure(3, -weight => 2);

    Tkx::wm_resizable($scale_output_menu,0,0);
    &adjust_window_position($scale_output_menu);
    $scale_output_menu->g_focus;
}


sub make_anim_frames {
    my ($scalefac, $anim_file, $frame_start, $frame_end, $frame_rate, $delete_frames) = @_;
    my (
        $answer, $b, $base_file, $code, $date_label, $eps_file, $fh, $fmt,
        $fr, $frame_delay, $g, $gif_frames, $geom, $gif_delay, $id, $n, $nf,
        $pbar, $pbar_frame, $pbar_img, $pbar_window, $png_file, $png_height,
        $png_width, $ps_add, $psdata, $r, $rnum, $stop_processing, $w,
        $X, $Y,

        @cmd_args, @imgs,
       );

#   Determine the format of the animation file.
    ($fmt = lc($anim_file)) =~ s/.*\.(.*)$/$1/;

#   Apply scale factor to the frame size and set up the Ghostscript command.
    $png_width  = &round_to_int($canvas_width  *$scalefac /100);
    $png_height = &round_to_int($canvas_height *$scalefac /100);
    @cmd_args = ($GS_PROG, "-dSAFER", "-dQUIET", "-sDEVICE=png16m", "-dGraphicsAlphaBits=2",
                 "-dTextAlphaBits=4", "-g${png_width}x${png_height}");
    if ( $^O =~ /MSWin32/i ) {
        push (@cmd_args, "-sFONTPATH=C:\\Windows\\Fonts");
    }

#   Set a base file name.
    $rnum      = &get_random_number();
    $base_file = "tmp_" . $rnum . "_";
    if ($use_temp) {
        $base_file = $temp_dir . '/' . $base_file;
        if ( $^O =~ /MSWin32/i ) { $base_file =~ s/\//\\/; }
    }
    $w = int(log10($frame_end)) +1;

#   Generate PS code to fill the background with the canvas color.
    $code    = &get_rgb_code($canvas_color);
    $r       = &hex2decimal(substr($code,1,2)) /255.;   # as a fraction between 0 and 1
    $g       = &hex2decimal(substr($code,3,2)) /255.;
    $b       = &hex2decimal(substr($code,5,2)) /255.;
    $ps_add  = "3 1 moveto\n";
    $ps_add .= sprintf("%d 1 lineto\n", $canvas_width +2);
    $ps_add .= sprintf("%d %d lineto\n", $canvas_width +2, $canvas_height);
    $ps_add .= sprintf("3 %d lineto\n", $canvas_height);
    $ps_add .= "3 1 lineto\n";
    $ps_add .= sprintf("%5.3f %5.3f %5.3f setrgbcolor AdjustColor\n", $r, $g, $b);
    $ps_add .= "fill\ngrestore\ngsave\n";

#   Create a progress bar with a cancel button.
    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $geom = sprintf("+%d+%d", $X+$canvas_width/2-200, $Y+$canvas_height/2);

    $pbar_window = $main->new_toplevel();
    $pbar_window->g_wm_transient($main);
    $pbar_window->g_wm_title("Making animation frames...");
    $pbar_window->g_wm_geometry($geom);
    $pbar_window->configure(-cursor => $cursor_wait);
    $pbar_window->g_focus;
    $pbar_window->g_bind('<Destroy>' => sub { $stop_processing = 1;
                                              $status_line = "Processing stopped.";
                                              $pbar_window->g_grab_release();
                                              $pbar_window->g_bind('<Destroy>' => "");
                                              Tkx::update_idletasks();
                                            });
    $pbar_frame = $pbar_window->new_frame(
                    -borderwidth => 2,
                    -relief      => 'groove');
    $pbar_frame->g_pack(-anchor => 'nw', -expand => 1, -fill => 'x');
    ($pbar = $pbar_frame->new_ttk__progressbar(
                    -orient  => 'horizontal',
                    -length  => 350,
                    -mode    => 'determinate',
                    -value   => 0,
                    -maximum => $frame_end -$frame_start +1,
                    ))->g_pack(-side => 'left');
    $pbar_frame->new_button(
                    -text    => "Cancel",
                    -font    => 'default',
                    -cursor  => $cursor_select,
                    -command => sub { $stop_processing = 1;
                                      $status_line = "Processing stopped.";
                                      Tkx::update_idletasks();
                                    },
                    )->g_pack(-side => 'right');

#   End any current selection.
    &end_select($canvas, $old_id) if (defined($old_id));

#   Prepare the application to appear busy.
    $status_line = "Creating frames for animation export.  Please wait...";
    $canvas->configure(-cursor => $cursor_wait);
    $main->configure(-cursor => $cursor_wait);
    $pbar_window->g_focus;
    $pbar_window->g_grab_set();
    Tkx::update();
    Tkx::wm_resizable($pbar_window,0,0);

#   Loop over the frames of the animation.
    $stop_processing = 0;
    $delay_autosave  = 1;
    for ($fr=$frame_start; $fr<=$frame_end; $fr++) {
        last if ($stop_processing);
        $dti = $fr;
        $date_label = &get_formatted_date($dates[$dti-1]);
        &update_animate($date_label);
        $dti_old = $fr;

        $png_file = $base_file . sprintf("%0${w}d", $fr -$frame_start +1) . ".png";
        $eps_file = $base_file . sprintf("%0${w}d", $fr -$frame_start +1) . ".eps";

        $psdata = $canvas->postscript(-x => 3, -y => 3,
                                      -width      => $canvas_width,  -pagex => 0,
                                      -height     => $canvas_height, -pagey => 0,
                                      -pageanchor => 'sw',
                                      -pagewidth  => $png_width);

#       Swap "fill" for "eofill" commands
#       $psdata =~ s/eofill/fill/g;

#       Because of a bug in the canvas postscript method, need to redefine the scalefont function
#       Otherwise, all of the text will be too small
        $psdata =~ s/\%\%EndProlog/\/scalefont \{$pixels_per_pt mul scalefont\} bind def\n\%\%EndProlog/;

#       Fill the background with the canvas color.  Add code after "closepath clip newpath\ngsave"
        $psdata =~ s/closepath clip newpath\ngsave\n/closepath clip newpath\ngsave\n$ps_add/;

        open ($fh, ">", $eps_file)
                    || return &stop_and_reset(1, $pbar_window, $delete_frames, $base_file,
                                              "Unable to open temporary file:\n $eps_file");
        print $fh $psdata;
        close ($fh) || return &stop_and_reset(1, $pbar_window, $delete_frames, $base_file,
                                              "Trouble closing EPS file:\n $eps_file");

#       Break out each term of the command line to avoid problems with spaces in PATHs
        system(@cmd_args, "-o", $png_file, $eps_file);
        unlink $eps_file;

#       Update the progress bar
        $pbar_window->g_wm_title(sprintf("Making animation frames... %d of %d",
                                         $fr -$frame_start +1, $frame_end -$frame_start +1));
        $pbar->configure(-value => $fr -$frame_start +1);
        Tkx::update();
    }

#   Make the video file
    if (! $stop_processing) {
        if ($fmt eq "gif") {
            $status_line = "Reading frames of animation.  Please wait...";
            $pbar_window->g_wm_title("Reading image frames...");
            $pbar->configure(-value => 0);
            Tkx::update_idletasks();

            @imgs = ();
            $n = 0;
            foreach $png_file (glob "${base_file}*.png") {
                $imgs[$n] = Imager->new;
                $imgs[$n]->read(file => $png_file)
                           or return &stop_and_reset(1, $pbar_window, $delete_frames, $base_file,
                                                     "Problem reading temporary image file\n"
                                                     . " $imgs[$n]->errstr");
                $n++;
                $pbar->configure(-value => $n);
                Tkx::update();
            }
            $pbar_window->g_wm_title("Exporting video file...");
            $status_line = "Exporting video file $anim_file.  Please wait...";
            Tkx::update_idletasks();
            $gif_delay = &round_to_int(100.0 /$frame_rate);
            Imager->write_multi({ file          => $anim_file,
                                  type          => $fmt,
                                  translate     => 'giflib',
                                  max_colors    => 256,
                                  gif_local_map => 1,
                                  gif_delay     => $gif_delay,
                                }, @imgs)
                           or return &stop_and_reset(1, $pbar_window, $delete_frames, $base_file,
                                                     "Problem writing GIF file");
        } else {
#           Modify the progress bar
            $nf          =  0;
            $gif_frames  = 80;
            $frame_delay = 20;
            $pbar_img = Tkx::image_create_photo(-file   => "${prog_path}images/pbar.gif",
                                                -format => "gif -index $nf");
            $pbar_img = Tkx::widget->new($pbar_img);
            $pbar->g_pack_forget();
            ($pbar = $pbar_frame->new_label(-image => $pbar_img,
                                           ))->g_pack(-side => 'left');
            undef $bg_proc if (defined($bg_proc));
            $delay_frame_id = Tkx::after($frame_delay,
                                         [\&next_gif_frame, $pbar_img, $nf, $gif_frames, $frame_delay]);

            $status_line = "Exporting video file $anim_file.  Please wait...";
            $pbar_window->g_wm_title("Exporting video file...");
            Tkx::update();

#           FFmpeg options:
#             -hide_banner      Do not print banner message
#             -y                Overwrite output files without asking
#             -loglevel quiet   Do not print log messages
#             -framerate X      Specify frame rate of X frames per second
#             -i file_%03d.png  Input files of the form "file_000.png"
#             -c:v codelib      Use the "codelib" encoder library (e.g., mpeg4, flv1, libx265)
#
#             -force_key_frames expr:gte(t,n_forced*5)  will force a key frame every 5 seconds

            @cmd_args = ($FFmpeg_PROG, "-hide_banner", "-y", "-loglevel", "quiet",
                         "-framerate", $frame_rate, "-i", "${base_file}\%0${w}d\.png");
            if ($fmt eq "avi") {
                push (@cmd_args, "-c:v", "mpeg4", "-qscale:v", "5", "-vtag", "xvid", $anim_file);

            } elsif ($fmt eq "flv") {
                push (@cmd_args, "-c:v", "flv1", "-qscale:v", "5", $anim_file);

            } elsif ($fmt eq "mov") {
                push (@cmd_args, "-c:v", "libx265", "-x265-params", "log-level=quiet",
                                                    "-crf", "28", $anim_file);

            } elsif ($fmt eq "mp4") {
                push (@cmd_args, "-c:v", "libx265", "-x265-params", "log-level=quiet",
                                                    "-crf", "28", "-tag:v", "hvc1", $anim_file);
            }

#           Run the process in the background
            $bg_proc = Proc::Background->new({ autodie => 1,
                                               command => \@cmd_args,
                                             });

#           Update the screen while the process runs
            while ($bg_proc->alive) {
                Tkx::update();
            }
            foreach $id (Tkx::SplitList(Tkx::after_info())) {
                Tkx::after_cancel($id) if ($id eq $delay_frame_id);
            }
        }
    }
    $delay_autosave = 0;

#   Remove progress bar and unset the busy status.
    if (defined($pbar_window) && Tkx::winfo_exists($pbar_window)) {
        $pbar_window->g_grab_release();
        $pbar_window->g_bind('<Destroy>' => "");
        $pbar_window->g_destroy();
    }
    $canvas->configure(-cursor => $cursor_norm);
    $main->configure(-cursor => $cursor_norm);
    if ($stop_processing) {
        if (defined($bg_proc) && $bg_proc->alive) {
            $bg_proc->terminate;
        }
        undef $bg_proc if (defined($bg_proc));
    } else {
        $status_line = "Export completed.";
    }

#   Remove image files, if requested.
    if ($delete_frames) {
        unlink glob "${base_file}*.png" || return &pop_up_error($main,
                                                                "Unable to remove image files:\n $!");
    } else {
        $answer = &pop_up_question($main, "Do you want to make another video file\n"
                                        . "using the same series of images, but\n"
                                        . "with a different format or frame rate?");
        if (lc($answer) eq "yes") {
            return &scale_output("Animation", $rnum);
        }
    }
}


sub make_animation {
    my ($rnum, $anim_file, $nframes, $frame_rate, $delete_frames) = @_;
    my (
        $answer, $base_file, $fmt, $frame_delay, $geom, $gif_delay,
        $gif_frames, $id, $n, $nf, $pbar, $pbar_frame, $pbar_img,
        $pbar_window, $png_file, $w, $X, $Y,

        @cmd_args, @imgs,
       );

#   Determine the format of the animation file.
    ($fmt = lc($anim_file)) =~ s/.*\.(.*)$/$1/;

#   Set parameters to identify frame files.
    $base_file = "tmp_" . $rnum . "_";
    if ($use_temp) {
        $base_file = $temp_dir . '/' . $base_file;
        if ( $^O =~ /MSWin32/i ) { $base_file =~ s/\//\\/; }
    }
    $w = int(log10($nframes)) +1;

#   Set up an indeterminate progress bar.
    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $geom = sprintf("+%d+%d", $X+$canvas_width/2-200, $Y+$canvas_height/2);

    $pbar_window = $main->new_toplevel();
    $pbar_window->g_wm_transient($main);
    $pbar_window->g_wm_geometry($geom);
    $pbar_window->configure(-cursor => $cursor_wait);

    $pbar_frame = $pbar_window->new_frame(
                    -borderwidth => 2,
                    -relief      => 'groove');
    $pbar_frame->g_pack(-anchor => 'nw', -expand => 1, -fill => 'x');

#   Make the video file.
    $delay_autosave = 1;
    if ($fmt eq "gif") {
        ($pbar = $pbar_frame->new_ttk__progressbar(
                        -orient  => 'horizontal',
                        -length  => 350,
                        -mode    => 'determinate',
                        -value   => 0,
                        -maximum => $nframes,
                        ))->g_pack(-side => 'left');

#       Give the program a busy status.
        $status_line = "Reading frames of animation.  Please wait...";
        $pbar_window->g_wm_title("Reading image frames...");
        $pbar_window->g_focus;
        Tkx::tk_busy_hold($main, -cursor => $cursor_wait);
        Tkx::update();
        Tkx::wm_resizable($pbar_window,0,0);

        @imgs = ();
        $n = 0;
        foreach $png_file (glob "${base_file}*.png") {
            $imgs[$n] = Imager->new;
            $imgs[$n]->read(file => $png_file)
                       or return &stop_and_reset(0, "", $delete_frames, $base_file,
                                                 "Problem reading temporary image file\n"
                                                 . " $imgs[$n]->errstr");
            $n++;
            $pbar->configure(-value => $n);
            Tkx::update_idletasks();
        }
        $pbar_window->g_wm_title("Exporting video file...");
        $status_line = "Exporting video file $anim_file.  Please wait...";
        Tkx::update_idletasks();
        $gif_delay = &round_to_int(100.0 /$frame_rate);
        Imager->write_multi({ file          => $anim_file,
                              type          => $fmt,
                              translate     => 'giflib',
                              max_colors    => 256,
                              gif_local_map => 1,
                              gif_delay     => $gif_delay,
                            }, @imgs)
                       or return &stop_and_reset(0, "", $delete_frames, $base_file,
                                                 "Problem writing GIF file");
    } else {
        $nf          =  0;
        $gif_frames  = 80;
        $frame_delay = 20;
        $pbar_img = Tkx::image_create_photo(-file   => "${prog_path}images/pbar.gif",
                                            -format => "gif -index $nf");
        $pbar_img = Tkx::widget->new($pbar_img);
        ($pbar = $pbar_frame->new_label(-image => $pbar_img,
                                       ))->g_pack(-side => 'left');
        undef $bg_proc if (defined($bg_proc));
        $delay_frame_id = Tkx::after($frame_delay,
                                     [\&next_gif_frame, $pbar_img, $nf, $gif_frames, $frame_delay]);

#       Give the program a busy status.
        $status_line = "Exporting video file $anim_file.  Please wait...";
        $pbar_window->g_wm_title("Exporting video file...");
        $pbar_window->g_focus;
        Tkx::tk_busy_hold($main, -cursor => $cursor_wait);
        Tkx::update();
        Tkx::wm_resizable($pbar_window,0,0);

#       FFmpeg options:
#         -hide_banner      Do not print banner message
#         -y                Overwrite output files without asking
#         -loglevel quiet   Do not print log messages
#         -framerate X      Specify frame rate of X frames per second
#         -i file_%03d.png  Input files of the form "file_000.png"
#         -c:v codelib      Use the "codelib" encoder library (e.g., mpeg4, flv1, libx265)
#
#         -force_key_frames expr:gte(t,n_forced*5)  will force a key frame every 5 seconds

        @cmd_args = ($FFmpeg_PROG, "-hide_banner", "-y", "-loglevel", "quiet",
                     "-framerate", $frame_rate, "-i", "${base_file}\%0${w}d\.png");
        if ($fmt eq "avi") {
            push (@cmd_args, "-c:v", "mpeg4", "-qscale:v", "5", "-vtag", "xvid", $anim_file);

        } elsif ($fmt eq "flv") {
            push (@cmd_args, "-c:v", "flv1", "-qscale:v", "5", $anim_file);

        } elsif ($fmt eq "mov") {
            push (@cmd_args, "-c:v", "libx265", "-x265-params", "log-level=quiet",
                                                "-crf", "28", $anim_file);

        } elsif ($fmt eq "mp4") {
            push (@cmd_args, "-c:v", "libx265", "-x265-params", "log-level=quiet",
                                                "-crf", "28", "-tag:v", "hvc1", $anim_file);
        }

#       Run the process in the background
        $bg_proc = Proc::Background->new({ autodie => 1,
                                           command => \@cmd_args,
                                         });

#       Update the screen while the process runs
        while ($bg_proc->alive) {
            Tkx::update();
        }
        foreach $id (Tkx::SplitList(Tkx::after_info())) {
            Tkx::after_cancel($id) if ($id eq $delay_frame_id);
        }
    }
    $delay_autosave = 0;

#   Remove progress window and unset the busy status.
    $pbar_window->g_destroy();
    Tkx::tk_busy_forget($main);
    $status_line = "Export completed.";
    Tkx::update_idletasks();

#   Remove image files, if requested.
    if ($delete_frames) {
        unlink glob "${base_file}*.png" || return &pop_up_error($main,
                                                                "Unable to remove image files:\n $!");
    } else {
        $answer = &pop_up_question($main, "Do you want to make another video file\n"
                                        . "using the same series of images, but\n"
                                        . "with a different format or frame rate?");
        if (lc($answer) eq "yes") {
            return &scale_output("Animation", $rnum);
        }
    }
}


sub next_gif_frame {
    my ($img, $nf, $gif_frames, $frame_delay) = @_;

    return if (defined($bg_proc) && ! $bg_proc->alive);
    $nf = ($nf < $gif_frames-1) ? $nf+1 : 0;
    $img->configure(-format => "gif -index $nf");
    $delay_frame_id = Tkx::after($frame_delay, [\&next_gif_frame, $img, $nf, $gif_frames, $frame_delay]);
}


sub stop_and_reset {
    my ($grab, $grab_window, $delete_frames, $base_file, $msg) = @_;

    if ($grab) {
        $grab_window->g_grab_release();
        $grab_window->g_bind('<Destroy>' => "");
        $grab_window->g_destroy();
        $canvas->configure(-cursor => $cursor_norm);
        $main->configure(-cursor => $cursor_norm);
    } else {
        Tkx::tk_busy_forget($main);
    }
    $status_line    = "Processing stopped.";
    $delay_autosave = 0;
    Tkx::update_idletasks();

    if ($msg ne "") {
        if ($delete_frames) {
            unlink glob "${base_file}*.png" || do { $msg .= "\nUnable to remove image files:\n $!"; };
        }
        return &pop_up_error($main, $msg);
    } elsif ($delete_frames) {
        unlink glob "${base_file}*.png" || return &pop_up_error($main, "Unable to remove image files:\n $!");
    }
}


################################################################################
#
# Window-related routines
#
################################################################################

sub footer {
    my ($window, $which) = @_;
    my ($frame, $geom, $label, $bgcolor, $r, $g, $b);

    $frame = $window->new_tk__frame(
                          -relief      => 'groove',
                          -borderwidth => 2,
                          );
    $frame->g_pack(-side => 'bottom', -fill => 'x');
    if ($which eq "main") {
        $frame->new_label(
                    -textvariable => \$status_line,
                    -justify      => 'left',
                    -font         => 'default',
                    )->g_pack(-side => 'left');
        Tkx::update();
        $geom = $frame->g_winfo_geometry();
        (undef, $main_footer_height, undef, undef) = split(/x|\+/, $geom);
    } else {
        $frame->new_label(
                    -textvariable => \$link_status{$window},
                    -justify      => 'left',
                    -font         => 'default',
                    )->g_pack(-side => 'left');
    }
    $label = $frame->new_label(
                -text       => "v" . $version,
                -justify    => 'right',
                -font       => 'default',
                );
    $label->g_pack(-side => 'right');
    $bgcolor = $label->cget(-background);
    ($r, $g, $b) = Tkx::SplitList(Tkx::winfo_rgb($window, $bgcolor));
    $bgcolor = &get_rgb_name(sprintf("#%02X%02X%02X", $r/256, $g/256, $b/256));
    return $bgcolor;
}


sub configure_helper_apps {
    my (
        $f, $FFmpeg_file_btn, $FFmpeg_frame, $FFmpeg_label, $FFmpeg_PROG_tmp,
        $FFmpeg_scan_btn, $frame, $geom, $GS_file_btn, $GS_frame, $GS_label,
        $GS_PROG_tmp, $GS_scan_btn, $initialdir, $initialfile, $ok_btn,
        $row, $temp_dir_tmp, $temp_file_btn, $temp_frame, $temp_label,
        $use_FFmpeg_tmp, $use_GS_tmp, $use_temp_tmp, $X, $Y,
       );

    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $geom = sprintf("+%d+%d", $X+70, $Y+60);

    if (defined($configure_helper_menu) && Tkx::winfo_exists($configure_helper_menu)) {
        if ($configure_helper_menu->g_wm_title() eq "Configure Helper Apps") {
            $configure_helper_menu->g_destroy();
            undef $configure_helper_menu;
        }
    }
    $configure_helper_menu = $main->new_toplevel();
    $configure_helper_menu->g_wm_transient($main);
    $configure_helper_menu->g_wm_title("Configure Helper Apps");
    $configure_helper_menu->configure(-cursor => $cursor_norm);
    $configure_helper_menu->g_wm_geometry($geom);

    $GS_PROG_tmp     = $GS_PROG;
    $FFmpeg_PROG_tmp = $FFmpeg_PROG;
    $temp_dir_tmp    = $temp_dir;
    $use_GS_tmp      = $use_GS;
    $use_FFmpeg_tmp  = $use_FFmpeg;
    $use_temp_tmp    = $use_temp;

    $frame = $configure_helper_menu->new_frame();
    $frame->g_pack(-side => 'bottom');
    ($ok_btn = $frame->new_button(
            -text    => "OK",
            -state   => 'disabled',
            -command => sub { my ($i, $success);
                              if ($use_GS_tmp && ($GS_PROG_tmp eq "" || ! -e $GS_PROG_tmp)) {
                                  return &pop_up_error($configure_helper_menu,
                                  "Ghostscript program file not set or does not exist:\n$GS_PROG_tmp");
                              }
                              if ($use_FFmpeg_tmp && ($FFmpeg_PROG_tmp eq "" || ! -e $FFmpeg_PROG_tmp)) {
                                  return &pop_up_error($configure_helper_menu,
                                  "FFmpeg program file not set or does not exist:\n$FFmpeg_PROG_tmp");
                              }
                              if ($use_temp_tmp) {
                                  if ($temp_dir_tmp eq "" || ! -e $temp_dir_tmp || ! -d $temp_dir_tmp) {
                                      return &pop_up_error($configure_helper_menu,
                                      "Temporary directory not set or does not exist:\n$temp_dir_tmp");
                                  }
                                  if (! -r $temp_dir_tmp || ! -w $temp_dir_tmp) {
                                      return &pop_up_error($configure_helper_menu,
                                      "Temporary directory not readable or writeable:\n$temp_dir_tmp");
                                  }
                              }
                              $use_GS     = $use_GS_tmp;
                              $use_FFmpeg = $use_FFmpeg_tmp;
                              $use_temp   = $use_temp_tmp;
                              if ($use_GS) {
                                  $GS_PROG = $GS_PROG_tmp;
                                  $export_menu->entryconfigure(1, -state => 'normal');
                                  $export_menu->entryconfigure(2, -state => 'normal');
                                  for ($i=0; $i<=$#animate_ids; $i++) {
                                      if ($props{$animate_ids[$i]}{meta}
                              =~ /^(data_profile|w2_profile|w2_slice|w2_outflow|w2_wlevels|vert_wd_zone)$/) {
                                          $export_menu->entryconfigure(3, -state => 'normal');
                                          last;
                                      }
                                  }
                              } else {
                                  $export_menu->entryconfigure(1, -state => 'disabled');
                                  $export_menu->entryconfigure(2, -state => 'disabled');
                                  $export_menu->entryconfigure(3, -state => 'disabled');
                              }
                              if ($use_FFmpeg) {
                                  $FFmpeg_PROG = $FFmpeg_PROG_tmp;
                              }
                              if (! $use_temp) {
                                  $temp_dir_tmp = File::Spec->rel2abs(abs_path(), $prog_path);
                                  $success = opendir($dir_handle, $temp_dir_tmp);
                                  if ($success) {
                                      while (defined($dir_entry = readdir($dir_handle))) {
                                          next if (! -d $dir_entry);
                                          next if (! -r $dir_entry || ! -w $dir_entry);
                                          if (lc($dir_entry) eq "tmp") {
                                              $temp_dir_tmp = File::Spec->rel2abs($dir_entry, $temp_dir_tmp);
                                              last;
                                          } elsif (lc($dir_entry) eq "temp") {
                                              $temp_dir_tmp = File::Spec->rel2abs($dir_entry, $temp_dir_tmp);
                                              last;
                                          }
                                      }
                                      closedir($dir_handle);
                                  }
                              }
                              if ($temp_dir_tmp ne $temp_dir) {
                                  &reassign_autosave_files($temp_dir_tmp);
                                  $temp_dir = $temp_dir_tmp;
                              }
                              $configure_helper_menu->g_destroy();
                              undef $configure_helper_menu;
                            },
            ))->g_pack(-side => 'left', -padx => 2, -pady => 2);
    $frame->new_button(
            -text    => "Cancel",
            -command => sub { $configure_helper_menu->g_destroy();
                              undef $configure_helper_menu;
                            },
            )->g_pack(-side => 'left', -padx => 2, -pady => 2);

    $f = $configure_helper_menu->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            );
    $f->g_pack(-side => 'top');

    ($GS_frame = $f->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_pack(-side => 'top', -fill => 'x', -expand => 1);
    ($FFmpeg_frame = $f->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_pack(-side => 'top', -fill => 'x', -expand => 1, -pady => 1);
    ($temp_frame = $f->new_frame(
            -borderwidth => 1,
            -relief      => 'groove',
            ))->g_pack(-side => 'top', -fill => 'x', -expand => 1, -pady => 1);

    $row = 0;
    $GS_frame->new_checkbutton(
            -onvalue  => 1,
            -offvalue => 0,
            -text     => "Use Ghostscript for PDF and raster output",
            -font     => 'default',
            -variable => \$use_GS_tmp,
            -command  => sub { if ($use_GS_tmp) {
                                   $GS_label->configure(-state => 'normal');
                                   $GS_scan_btn->configure(-state => 'normal');
                                   $GS_file_btn->configure(-state => 'normal');
                                   if ($GS_PROG_tmp ne "" && -e $GS_PROG_tmp) {
                                       $ok_btn->configure(-state => 'normal');
                                   } else {
                                       $ok_btn->configure(-state => 'disabled');
                                   }
                               } else {
                                   $GS_label->configure(-state => 'disabled');
                                   $GS_scan_btn->configure(-state => 'disabled');
                                   $GS_file_btn->configure(-state => 'disabled');
                                   $ok_btn->configure(-state => 'normal');
                               }
                               if ($use_FFmpeg_tmp) {
                                   if ($FFmpeg_PROG_tmp eq "" || ! -e $FFmpeg_PROG_tmp) {
                                       $ok_btn->configure(-state => 'disabled');
                                   }
                               }
                               if ($use_temp_tmp) {
                                   if ($temp_dir_tmp eq "" || ! -e $temp_dir_tmp
                                                           || ! -d $temp_dir_tmp) {
                                       $ok_btn->configure(-state => 'disabled');
                                   }
                               }
                             },
            )->g_grid(-row => $row, -column => 0, -columnspan => 3, -sticky => 'w');

    $row++;
    $GS_frame->new_label(
            -text => "Program Location: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    ($GS_label = $GS_frame->new_label(
            -textvariable => \$GS_PROG_tmp,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'ew');
    ($GS_scan_btn = $GS_frame->new_button(
            -text    => "Scan",
            -command => sub { my ($cancelled);
                              $geom = $configure_helper_menu->g_wm_geometry();
                              (undef, $X, $Y) = split(/\+/, $geom);
                              $cancelled = &helper_autosearch($X, $Y, "GS");
                              if (! $cancelled) {
                                  $GS_scan_btn->configure(-state => 'disabled');
                              }
                            },
            ))->g_grid(-row => $row, -column => 2, -sticky => 'ew', -padx => 2);
    ($GS_file_btn = $GS_frame->new_button(
            -text    => "Browse",
            -command => sub { my ($file);
                              if ( $^O =~ /MSWin32/i ) {
                                  if ($GS_PROG_tmp ne "" && -e $GS_PROG_tmp) {
                                      ($initialdir  = $GS_PROG_tmp) =~ s/^(.*)\\.*/$1/;
                                      ($initialfile = $GS_PROG_tmp) =~ s/^.*\\(.*)/$1/;
                                      $file = Tkx::tk___getOpenFile(
                                              -parent           => $configure_helper_menu,
                                              -title            => "Ghostscript Program File",
                                              -defaultextension => ".exe",
                                              -initialdir       => $initialdir,
                                              -initialfile      => $initialfile,
                                              -filetypes => [ ['Executable Files', '.exe'],
                                                              ['All Files',  '*'],
                                                            ],
                                              );
                                  } else {
                                      if (-e 'C:\Program Files') {
                                          $initialdir = 'C:\Program Files';
                                      } else {
                                          $initialdir = abs_path();
                                      }
                                      $file = Tkx::tk___getOpenFile(
                                              -parent           => $configure_helper_menu,
                                              -title            => "Ghostscript Program File",
                                              -initialdir       => $initialdir,
                                              -defaultextension => ".exe",
                                              -filetypes => [ ['Executable Files', '.exe'],
                                                              ['All Files',  '*'],
                                                            ],
                                              );
                                  }
                              } else {
                                  if ($GS_PROG_tmp ne "" && -e $GS_PROG_tmp) {
                                      ($initialdir  = $GS_PROG_tmp) =~ s/^(.*)\/.*/$1/;
                                      ($initialfile = $GS_PROG_tmp) =~ s/^.*\/(.*)/$1/;
                                      $file = Tkx::tk___getOpenFile(
                                              -parent      => $configure_helper_menu,
                                              -title       => "Ghostscript Program File",
                                              -initialdir  => $initialdir,
                                              -initialfile => $initialfile,
                                              -filetypes   => [ ['All Files',  '*'],
                                                              ],
                                              );
                                  } else {
                                      if (-e '/usr/bin') {
                                          $initialdir = '/usr/bin';
                                      } else {
                                          $initialdir = abs_path();
                                      }
                                      $file = Tkx::tk___getOpenFile(
                                              -parent     => $configure_helper_menu,
                                              -title      => "Ghostscript Program File",
                                              -initialdir => $initialdir,
                                              -filetypes  => [ ['All Files',  '*'],
                                                             ],
                                              );
                                  }
                              }
                              if (defined($file) && -e $file) {
                                  $GS_PROG_tmp = File::Spec->rel2abs($file, $prog_path);
                                  $ok_btn->configure(-state => 'normal');
                                  if ($use_FFmpeg_tmp) {
                                      if ($FFmpeg_PROG_tmp eq "" || ! -e $FFmpeg_PROG_tmp) {
                                          $ok_btn->configure(-state => 'disabled');
                                      }
                                  }
                                  if ($use_temp_tmp) {
                                      if ($temp_dir_tmp eq "" || ! -e $temp_dir_tmp
                                                              || ! -d $temp_dir_tmp) {
                                          $ok_btn->configure(-state => 'disabled');
                                      }
                                  }
                              } else {
                                  $ok_btn->configure(-state => 'disabled');
                              }
                            },
            ))->g_grid(-row => $row, -column => 3, -sticky => 'ew', -padx => 2);
    if (! $use_GS_tmp) {
        $GS_label->configure(-state => 'disabled');
        $GS_scan_btn->configure(-state => 'disabled');
        $GS_file_btn->configure(-state => 'disabled');
    }

    $row = 0;
    $FFmpeg_frame->new_checkbutton(
            -onvalue  => 1,
            -offvalue => 0,
            -text     => "Use FFmpeg for animation file creation",
            -font     => 'default',
            -variable => \$use_FFmpeg_tmp,
            -command  => sub { if ($use_FFmpeg_tmp) {
                                   $FFmpeg_label->configure(-state => 'normal');
                                   $FFmpeg_scan_btn->configure(-state => 'normal');
                                   $FFmpeg_file_btn->configure(-state => 'normal');
                                   if ($FFmpeg_PROG_tmp ne "" && -e $FFmpeg_PROG_tmp) {
                                       $ok_btn->configure(-state => 'normal');
                                   } else {
                                       $ok_btn->configure(-state => 'disabled');
                                   }
                               } else {
                                   $FFmpeg_label->configure(-state => 'disabled');
                                   $FFmpeg_scan_btn->configure(-state => 'disabled');
                                   $FFmpeg_file_btn->configure(-state => 'disabled');
                                   $ok_btn->configure(-state => 'normal');
                               }
                               if ($use_GS_tmp) {
                                   if ($GS_PROG_tmp eq "" || ! -e $GS_PROG_tmp) {
                                       $ok_btn->configure(-state => 'disabled');
                                   }
                               }
                               if ($use_temp_tmp) {
                                   if ($temp_dir_tmp eq "" || ! -e $temp_dir_tmp
                                                           || ! -d $temp_dir_tmp) {
                                       $ok_btn->configure(-state => 'disabled');
                                   }
                               }
                             },
            )->g_grid(-row => $row, -column => 0, -columnspan => 4, -sticky => 'w');

    $row++;
    $FFmpeg_frame->new_label(
            -text => "Program Location: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    ($FFmpeg_label = $FFmpeg_frame->new_label(
            -textvariable => \$FFmpeg_PROG_tmp,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'ew');
    ($FFmpeg_scan_btn = $FFmpeg_frame->new_button(
            -text    => "Scan",
            -command => sub { my ($cancelled);
                              $geom = $configure_helper_menu->g_wm_geometry();
                              (undef, $X, $Y) = split(/\+/, $geom);
                              $cancelled = &helper_autosearch($X, $Y, "FFmpeg");
                              if (! $cancelled) {
                                  $FFmpeg_scan_btn->configure(-state => 'disabled');
                              }
                            },
            ))->g_grid(-row => $row, -column => 2, -sticky => 'ew', -padx => 2);
    ($FFmpeg_file_btn = $FFmpeg_frame->new_button(
            -text    => "Browse",
            -command => sub { my ($file);
                              if ( $^O =~ /MSWin32/i ) {
                                  if ($FFmpeg_PROG_tmp ne "" && -e $FFmpeg_PROG_tmp) {
                                      ($initialdir  = $FFmpeg_PROG_tmp) =~ s/^(.*)\\.*/$1/;
                                      ($initialfile = $FFmpeg_PROG_tmp) =~ s/^.*\\(.*)/$1/;
                                      $file = Tkx::tk___getOpenFile(
                                              -parent           => $configure_helper_menu,
                                              -title            => "FFmpeg Program File",
                                              -defaultextension => ".exe",
                                              -initialdir       => $initialdir,
                                              -initialfile      => $initialfile,
                                              -filetypes => [ ['Executable Files', '.exe'],
                                                              ['All Files',  '*'],
                                                            ],
                                              );
                                  } else {
                                      if (-e 'C:\Program Files') {
                                          $initialdir = 'C:\Program Files';
                                      } else {
                                          $initialdir = abs_path();
                                      }
                                      $file = Tkx::tk___getOpenFile(
                                              -parent           => $configure_helper_menu,
                                              -title            => "FFmpeg Program File",
                                              -initialdir       => $initialdir,
                                              -defaultextension => ".exe",
                                              -filetypes => [ ['Executable Files', '.exe'],
                                                              ['All Files',  '*'],
                                                            ],
                                              );
                                  }
                              } else {
                                  if ($FFmpeg_PROG_tmp ne "" && -e $FFmpeg_PROG_tmp) {
                                      ($initialdir  = $FFmpeg_PROG_tmp) =~ s/^(.*)\/.*/$1/;
                                      ($initialfile = $FFmpeg_PROG_tmp) =~ s/^.*\/(.*)/$1/;
                                      $file = Tkx::tk___getOpenFile(
                                              -parent      => $configure_helper_menu,
                                              -title       => "FFmpeg Program File",
                                              -initialdir  => $initialdir,
                                              -initialfile => $initialfile,
                                              -filetypes   => [ ['All Files',  '*'],
                                                              ],
                                              );
                                  } else {
                                      if (-e '/usr/bin') {
                                          $initialdir = '/usr/bin';
                                      } else {
                                          $initialdir = abs_path();
                                      }
                                      $file = Tkx::tk___getOpenFile(
                                              -parent     => $configure_helper_menu,
                                              -title      => "FFmpeg Program File",
                                              -initialdir => $initialdir,
                                              -filetypes  => [ ['All Files',  '*'],
                                                             ],
                                              );
                                  }
                              }
                              if (defined($file) && -e $file) {
                                  $FFmpeg_PROG_tmp = File::Spec->rel2abs($file, $prog_path);
                                  $ok_btn->configure(-state => 'normal');
                                  if ($use_GS_tmp) {
                                      if ($GS_PROG_tmp eq "" || ! -e $GS_PROG_tmp) {
                                          $ok_btn->configure(-state => 'disabled');
                                      }
                                  }
                                  if ($use_temp_tmp) {
                                      if ($temp_dir_tmp eq "" || ! -e $temp_dir_tmp
                                                              || ! -d $temp_dir_tmp) {
                                          $ok_btn->configure(-state => 'disabled');
                                      }
                                  }
                              } else {
                                  $ok_btn->configure(-state => 'disabled');
                              }
                            },
            ))->g_grid(-row => $row, -column => 3, -sticky => 'ew', -padx => 2);
    if (! $use_FFmpeg_tmp) {
        $FFmpeg_label->configure(-state => 'disabled');
        $FFmpeg_scan_btn->configure(-state => 'disabled');
        $FFmpeg_file_btn->configure(-state => 'disabled');
    }

    $row = 0;
    $temp_frame->new_checkbutton(
            -onvalue  => 1,
            -offvalue => 0,
            -text     => "Use a specific directory for temporary files",
            -font     => 'default',
            -variable => \$use_temp_tmp,
            -command  => sub { if ($use_temp_tmp) {
                                   $temp_label->configure(-state => 'normal');
                                   $temp_file_btn->configure(-state => 'normal');
                                   if ($temp_dir_tmp ne "" && -e $temp_dir_tmp
                                                           && -d $temp_dir_tmp) {
                                       $ok_btn->configure(-state => 'normal');
                                   } else {
                                       $ok_btn->configure(-state => 'disabled');
                                   }
                               } else {
                                   $temp_label->configure(-state => 'disabled');
                                   $temp_file_btn->configure(-state => 'disabled');
                                   $ok_btn->configure(-state => 'normal');
                               }
                               if ($use_GS_tmp) {
                                   if ($GS_PROG_tmp eq "" || ! -e $GS_PROG_tmp) {
                                       $ok_btn->configure(-state => 'disabled');
                                   }
                               }
                               if ($use_FFmpeg_tmp) {
                                   if ($FFmpeg_PROG_tmp eq "" || ! -e $FFmpeg_PROG_tmp) {
                                       $ok_btn->configure(-state => 'disabled');
                                   }
                               }
                             },
            )->g_grid(-row => $row, -column => 0, -columnspan => 4, -sticky => 'w');

    $row++;
    $temp_frame->new_label(
            -text => "Temp directory: ",
            -font => 'default',
            )->g_grid(-row => $row, -column => 0, -sticky => 'e');
    ($temp_label = $temp_frame->new_label(
            -textvariable => \$temp_dir_tmp,
            -anchor       => 'w',
            -font         => 'default',
            -background   => 'white',
            -relief       => 'sunken',
            -borderwidth  => 1,
            ))->g_grid(-row => $row, -column => 1, -sticky => 'ew');
    ($temp_file_btn = $temp_frame->new_button(
            -text    => "Browse",
            -command => sub { my ($dir);
                              if ($temp_dir_tmp ne "" && -e $temp_dir_tmp
                                                      && -d $temp_dir_tmp) {
                                  $dir = Tkx::tk___chooseDirectory(
                                          -parent     => $configure_helper_menu,
                                          -title      => "Directory for Temporary Files",
                                          -initialdir => $temp_dir_tmp,
                                          );
                              } else {
                                  $dir = Tkx::tk___chooseDirectory(
                                          -parent     => $configure_helper_menu,
                                          -title      => "Directory for Temporary Files",
                                          -initialdir => abs_path(),
                                          );
                              }
                              if (defined($dir) && $dir ne "" && ! -e $dir) {
                                  mkdir( $dir ) or 
                                      return &pop_up_error($main,
                                                  "Failed to create temporary directory:\n  $dir");
                              }
                              if (defined($dir) && -e $dir && -d $dir) {
                                  $temp_dir_tmp = File::Spec->rel2abs($dir, $prog_path);
                                  $ok_btn->configure(-state => 'normal');
                                  if ($use_GS_tmp) {
                                      if ($GS_PROG_tmp eq "" || ! -e $GS_PROG_tmp) {
                                          $ok_btn->configure(-state => 'disabled');
                                      }
                                  }
                                  if ($use_FFmpeg_tmp) {
                                      if ($FFmpeg_PROG_tmp eq "" || ! -e $FFmpeg_PROG_tmp) {
                                          $ok_btn->configure(-state => 'disabled');
                                      }
                                  }
                              } else {
                                  $ok_btn->configure(-state => 'disabled');
                              }
                            },
            ))->g_grid(-row => $row, -column => 3, -sticky => 'ew', -padx => 2);
    if (! $use_temp_tmp) {
        $temp_label->configure(-state => 'disabled');
        $temp_file_btn->configure(-state => 'disabled');
    }

    $GS_frame->g_grid_columnconfigure(1, -weight => 2);
    $FFmpeg_frame->g_grid_columnconfigure(1, -weight => 2);
    $temp_frame->g_grid_columnconfigure(1, -weight => 2);

    Tkx::wm_resizable($configure_helper_menu,0,0);
    &adjust_window_position($configure_helper_menu);
    $configure_helper_menu->g_focus;
}


sub helper_prog_notice {
    my ($frame, $geom, $msg, $warn_img, $X, $Y);

    if ( $^O =~ /MSWin32/i ) {
        if (! $use_GS && $GS_PROG eq "" && ! $use_FFmpeg && $FFmpeg_PROG eq "") {
            $msg = "Unable to find the Ghostscript and FFmpeg helper programs.\n"
                 . "Use the Help/Configure menu to specify their locations.\n\n"
                 . "Ghostscript:\n"
                 . "Looking for the \"gswin64c.exe\" or \"gswin32c.exe\" program.\n"
                 . "Already searched under:\n"
                 . "  C:\\Program Files\\gs\n"
                 . "  C:\\Program Files\\Ghostscript\n"
                 . "  C:\\Program Files (x86)\\gs\n"
                 . "  C:\\Program Files (x86)\\Ghostscript\n\n"
                 . "FFmpeg:\n"
                 . "Looking for the \"ffmpeg.exe\" program.\n"
                 . "Already searched under:\n"
                 . "  C:\\Program Files\\FFmpeg\n"
                 . "  C:\\Program Files (x86)\\FFmpeg";
        } elsif (! $use_GS && $GS_PROG eq "") {
            $msg = "Unable to find the Ghostscript helper program.\n"
                 . "Use the Help/Configure menu to specify its location.\n\n"
                 . "Looking for the \"gswin64c.exe\" or \"gswin32c.exe\" program.\n"
                 . "Already searched under:\n"
                 . "  C:\\Program Files\\gs\n"
                 . "  C:\\Program Files\\Ghostscript\n"
                 . "  C:\\Program Files (x86)\\gs\n"
                 . "  C:\\Program Files (x86)\\Ghostscript";
        } elsif (! $use_FFmpeg && $FFmpeg_PROG eq "") {
            $msg = "Unable to find the FFmpeg helper program.\n"
                 . "Use the Help/Configure menu to specify its location.\n\n"
                 . "Looking for the \"ffmpeg.exe\" program.\n"
                 . "Already searched under:\n"
                 . "  C:\\Program Files\\FFmpeg\n"
                 . "  C:\\Program Files (x86)\\FFmpeg";
        }
    } else {
        if (! $use_GS && $GS_PROG eq "" && ! $use_FFmpeg && $FFmpeg_PROG eq "") {
            $msg = "Unable to find the Ghostscript and FFmpeg helper programs.\n"
                 . "Use the Help/Configure menu to specify their locations.\n\n"
                 . "Ghostscript:\n"
                 . "Looking for the \"gs\" program.\n"
                 . "Already searched under:\n"
                 . "  /usr/bin\n"
                 . "  /usr/local/bin\n"
                 . "  /bin\n\n"
                 . "FFmpeg:\n"
                 . "Looking for the \"ffmpeg\" program.\n"
                 . "Already searched under:\n"
                 . "  /usr/bin\n"
                 . "  /usr/local/bin\n"
                 . "  /bin";
        } elsif (! $use_GS && $GS_PROG eq "") {
            $msg = "Unable to find the Ghostscript helper program.\n"
                 . "Use the Help/Configure menu to specify its location.\n\n"
                 . "Looking for the \"gs\" program.\n"
                 . "Already searched under:\n"
                 . "  /usr/bin\n"
                 . "  /usr/local/bin\n"
                 . "  /bin";
        } elsif (! $use_FFmpeg && $FFmpeg_PROG eq "") {
            $msg = "Unable to find the FFmpeg helper program.\n"
                 . "Use the Help/Configure menu to specify its location.\n\n"
                 . "Looking for the \"ffmpeg\" program.\n"
                 . "Already searched under:\n"
                 . "  /usr/bin\n"
                 . "  /usr/local/bin\n"
                 . "  /bin";
        }
    }

#   Make an information window. Not using pop_up_info() because that takes control.
    if (defined($helper_note_win) && Tkx::winfo_exists($helper_note_win)) {
        if ($helper_note_win->g_wm_title() eq "Helper Program Problem") {
            $helper_note_win->g_destroy();
            undef $helper_note_win;
        }
    }

    Tkx::update_idletasks();
    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $geom = sprintf("+%d+%d", $X+100, $Y+90);

    $helper_note_win = $main->new_toplevel();
    $helper_note_win->g_wm_transient($main);
    $helper_note_win->g_wm_title("Helper Program Problem");
    $helper_note_win->configure(-cursor => $cursor_norm);
    $helper_note_win->g_wm_geometry($geom);

    ($frame = $helper_note_win->new_frame(
                  -borderwidth => 1,
                  -relief      => 'groove',
                  -background  => 'white',
                  ))->g_pack(-side => 'top', -expand => 1, -fill => 'both');

    if ( $^O =~ /MSWin32/i ) {   # If Windows, offer an automated search
        $msg .= "\n\nTry Auto Search, but it may take a few minutes.";
        $frame->new_button(
                      -text       => "Auto Search",
                      -background => '#F2F2F2',
                      -command    => sub { $geom = $helper_note_win->g_wm_geometry();
                                           (undef, $X, $Y) = split(/\+/, $geom);
                                           $helper_note_win->g_destroy();
                                           undef $helper_note_win;
                                           &helper_autosearch($X, $Y); },
                      )->g_grid(-row => 1, -column => 1, -sticky => 'e', -pady => 4);
    }
    $warn_img = Tkx::image_create_photo(-file => "${prog_path}images/warn.png");
    $frame->new_label(
                  -image      => $warn_img,
                  -background => 'white',
                  )->g_grid(-row => 0, -column => 0, -sticky => 'nw', -padx => 5, -pady => 2);
    $frame->new_label(
                  -text       => $msg,
                  -font       => 'default',
                  -background => 'white',
                  -justify    => 'left',
                  )->g_grid(-row => 0, -column => 1, -columnspan => 2, -sticky => 'nw', -pady => 4);
    $frame->new_button(
                  -text       => "OK",
                  -background => '#F2F2F2',
                  -command    => sub { $helper_note_win->g_destroy();
                                       undef $helper_note_win; },
                  )->g_grid(-row => 1, -column => 2, -sticky => 'e', -padx => 8, -pady => 4);

    $frame->g_grid_columnconfigure(1, -weight => 2);

    Tkx::wm_resizable($helper_note_win,0,0);
    &adjust_window_position($helper_note_win);
    $helper_note_win->g_focus;
}


sub helper_autosearch {
    my ($X, $Y, $which) = @_;
    my (
        $cancel, $cancel_btn, $dh, $dir, $dir_tree, $entry, $file, $frame,
        $geom, $msg, $ok_btn, $old_FFmpeg_PROG, $old_GS_PROG, $search_FFmpeg,
        $search_GS, $search_img,

        @dir_list2,
       );

    $which           = "" if (! defined($which));
    $geom            = sprintf("+%d+%d", $X, $Y);
    $cancel          = 0;
    $msg             = "";
    $old_GS_PROG     = $GS_PROG;
    $old_FFmpeg_PROG = $FFmpeg_PROG;
    $search_GS       = 0;
    $search_FFmpeg   = 0;

    if ($which eq "GS") {
        $search_GS     = 1;
        $search_FFmpeg = 0;
    } elsif ($which eq "FFmpeg") {
        $search_GS     = 0;
        $search_FFmpeg = 1;
    } else {
        $search_GS     = (! $GS_off     && $GS_PROG     eq "") ? 1 : 0;
        $search_FFmpeg = (! $FFmpeg_off && $FFmpeg_PROG eq "") ? 1 : 0;
    }
    $GS_PROG         = "" if ($search_GS);
    $FFmpeg_PROG     = "" if ($search_FFmpeg);

    if (defined($helper_search_win) && Tkx::winfo_exists($helper_search_win)) {
        if ($helper_search_win->g_wm_title() eq "Helper Program AutoSearch") {
            $helper_search_win->g_destroy();
            undef $helper_search_win;
        }
    }
    $helper_search_win = $main->new_toplevel();
    $helper_search_win->g_wm_transient($main);
    $helper_search_win->g_wm_title("Helper Program AutoSearch");
    $helper_search_win->configure(-cursor => $cursor_norm);
    $helper_search_win->g_wm_geometry($geom);

    ($frame = $helper_search_win->new_frame(
                  -borderwidth => 1,
                  -relief      => 'groove',
                  -background  => 'white',
                  ))->g_pack(-side => 'top', -expand => 1, -fill => 'both');

    $search_img = Tkx::image_create_photo(-file => "${prog_path}images/search.png");
    $frame->new_label(
                  -image      => $search_img,
                  -background => 'white',
                  )->g_grid(-row => 0, -column => 0, -sticky => 'nw', -padx => 2);
    $frame->new_label(
                  -textvariable => \$msg,
                  -font         => 'default',
                  -background   => 'white',
                  -width        => 80,
                  -anchor       => 'w',
                  )->g_grid(-row => 0, -column => 1, -sticky => 'w', -pady => 4);
    ($cancel_btn = $frame->new_button(
                  -text       => "Cancel",
                  -background => '#F2F2F2',
                  -state      => 'normal',
                  -command    => sub { $cancel = 1; },
                  ))->g_grid(-row => 0, -column => 2, -padx => 2, -pady => 4);
    ($ok_btn = $frame->new_button(
                  -text       => "OK",
                  -background => '#F2F2F2',
                  -state      => 'disabled',
                  -command    => sub { $helper_search_win->g_destroy();
                                       undef $helper_search_win; },
                  ))->g_grid(-row => 0, -column => 3, -padx => 8, -pady => 4);

    $frame->g_grid_columnconfigure(1, -weight => 2);
    Tkx::wm_resizable($helper_search_win,0,0);
#   &adjust_window_position($helper_search_win);
    $helper_search_win->g_focus;
    Tkx::update();

    {   local $SIG{__WARN__} = sub { warn @_  unless $_[0] =~ /^Can't opendir/; };
        @search_dirs = @dir_list2 = ();
        $dir = 'C:\Program Files';
        if (-e $dir && -r $dir) {
            opendir($dh, $dir) or &pop_up_error($main, "Failed to read directory:\n $dir");
            while (readdir($dh)) {
                next if ($_ eq "." || $_ eq ".." || $_ =~ /^Uninstall/i);
                $entry = File::Spec->rel2abs($_, $dir);
                if (-d $entry && -r $entry) {
                    if ($_ !~ /^Adobe/i && $_ !~ /^Microsoft/i && $_ !~ /^Windows/i) {
                        push (@search_dirs, $entry);
                    } else {
                        push (@dir_list2, $entry);
                    }
                }
            }
            closedir($dh);
        }
        $dir = 'C:\Program Files (x86)';
        if (-e $dir && -r $dir) {
            opendir($dh, $dir) or &pop_up_error($main, "Failed to read directory:\n $dir");
            while (readdir($dh)) {
                next if ($_ eq "." || $_ eq ".." || $_ =~ /^Uninstall/i);
                $entry = File::Spec->rel2abs($_, $dir);
                if (-d $entry && -r $entry) {
                    if ($_ !~ /^Adobe/i && $_ !~ /^Microsoft/i && $_ !~ /^Windows/i) {
                        push (@search_dirs, $entry);
                    } else {
                        push (@dir_list2, $entry);
                    }
                }
            }
            closedir($dh);
        }
        push (@search_dirs, @dir_list2) if ($#dir_list2 >= 0);

        if ($#search_dirs >= 0) {
            if ($FileFindObject) {
                $dir_tree = File::Find::Object->new({}, @search_dirs);
                while ($file = $dir_tree->next()) {
                    ($dir = $file) =~ s/(.*)[\/\\][^\/\\]+$/$1/;
                    if ($dir ne $msg) {
                        if (length($dir) > 90) {
                            $dir = substr($dir,0,50) . "..." . substr($dir,-40);
                        }
                        if ($dir ne $msg) {
                            $msg = $dir;
                            Tkx::update();
                        }
                    }
                    if ($search_GS) {
                        if ($file =~ /gswin\d\dc\.exe$/) {
                            $GS_PROG = $file;
                            last if (! $search_FFmpeg);
                        }
                    }
                    if ($search_FFmpeg) {
                        if ($file =~ /ffmpeg\.exe$/) {
                            $FFmpeg_PROG = $file;
                            last if (! $search_GS);
                        }
                    }
                    last if ($search_GS && $GS_PROG ne "" && $search_FFmpeg && $FFmpeg_PROG ne "");
                    last if ($cancel);
                }
            } else {
                foreach $search_dir (@search_dirs) {
                    find( { wanted => sub { $dir = $File::Find::dir;
                                            if ($dir ne $msg) {
                                                if (length($dir) > 90) {
                                                    $dir = substr($dir,0,50) . "..." . substr($dir,-40);
                                                }
                                                if ($dir ne $msg) {
                                                    $msg = $dir;
                                                    Tkx::update();
                                                }
                                            }
                                            if ($search_GS) {
                                                if ($_ =~ /gswin\d\dc\.exe$/) {
                                                    ($GS_PROG = $File::Find::name) =~ s/\//\\/g;
                                                }
                                            }
                                            if ($search_FFmpeg) {
                                                if ($_ =~ /ffmpeg\.exe$/) {
                                                    ($FFmpeg_PROG = $File::Find::name) =~ s/\//\\/g;
                                                }
                                            }
                                          },
                            no_chdir => 1 }, $search_dir);
                    $GS_PROG     = "" if ($search_GS     && $GS_PROG     !~ /gswin\d\dc\.exe$/);
                    $FFmpeg_PROG = "" if ($search_FFmpeg && $FFmpeg_PROG !~ /ffmpeg\.exe$/);
                    last if ($search_GS     && $GS_PROG     ne "" && ! $search_FFmpeg);
                    last if ($search_FFmpeg && $FFmpeg_PROG ne "" && ! $search_GS);
                    last if ($search_GS     && $GS_PROG     ne "" &&
                             $search_FFmpeg && $FFmpeg_PROG ne "");
                    last if ($cancel);
                }
            }
            $msg = "";
            if ($cancel) {
                $cancel_btn->configure(-state => 'disabled');
                $ok_btn->configure(-state => 'normal');
                $msg = "Search cancelled.";
                return $cancel;
            }
            if ($search_GS) {
                if ($GS_PROG =~ /gswin\d\dc\.exe$/) {
                    $use_GS  = 1;
                    $msg     = "Found Ghostscript.";
                } else {
                    if ($old_GS_PROG ne "" && -e $old_GS_PROG && ! -d $old_GS_PROG) {
                        $use_GS  = 1 if (! $GS_off);
                        $GS_PROG = $old_GS_PROG;
                    } else {
                        $use_GS  = 0;
                        $GS_PROG = "";
                    }
                    $msg = "Failed to find Ghostscript.";
                }
            }
            if ($search_FFmpeg) {
                $msg .= "  " if ($msg ne "");
                if ($FFmpeg_PROG =~ /ffmpeg\.exe$/) {
                    $use_FFmpeg  = 1;
                    $msg        .= "Found FFmpeg.";
                } else {
                    if ($old_FFmpeg_PROG ne "" && -e $old_FFmpeg_PROG && ! -d $old_FFmpeg_PROG) {
                        $use_FFmpeg  = 1 if (! $FFmpeg_off);
                        $FFmpeg_PROG = $old_FFmpeg_PROG;
                    } else {
                        $use_FFmpeg  = 0;
                        $FFmpeg_PROG = "";
                    }
                    $msg .= "Failed to find FFmpeg.";
                }
            }
            if ($msg =~ /Found/) {
                $msg .= "  Confirm with Help/Configure menu." if ($which eq "");
                if (defined($configure_helper_menu) && Tkx::winfo_exists($configure_helper_menu)) {
                    if ($configure_helper_menu->g_wm_title() eq "Configure Helper Apps") {
                        $configure_helper_menu->g_destroy();
                        undef $configure_helper_menu;
                    }
                }
                &configure_helper_apps;
                Tkx::after_idle(sub {Tkx::after(100, sub {$helper_search_win->g_raise();
                                                          $helper_search_win->g_focus;
                                                         });});
            }
        } else {
            $msg = 'Cannot search C:\Program Files or C:\Program Files (x86)';
        }
        $cancel_btn->configure(-state => 'disabled');
        $ok_btn->configure(-state => 'normal');
    }
}


sub support {
    my ($geom, $tw, $X, $Y);

    if (defined($support_window) && Tkx::winfo_exists($support_window)) {
        if ($support_window->g_wm_title() eq "W2 Animator Support") {
            $support_window->g_wm_deiconify();
            $support_window->g_raise();
            $support_window->g_focus;
            &adjust_window_position($support_window);
            return;
        }
    }

    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $geom = sprintf("+%d+%d", $X+70, $Y+60);

    $support_window = $main->new_toplevel();
    $support_window->g_wm_transient($main);
    $support_window->g_wm_title("W2 Animator Support");
    $support_window->g_wm_minsize(350,200);
    $support_window->configure(-cursor => $cursor_norm);
    $support_window->g_wm_geometry($geom);

    &footer($support_window, "support_window");

    $tw = $support_window->new_tkx_Scrolled('tkx_ROText',
            -width       => 91,
            -height      => 36,
            -relief      => 'flat',
            -font        => 'default',
            -cursor      => $cursor_norm,
            -background  => &get_rgb_code($background_color),
            -wrap        => 'word',
            -scrollbars  => 'oe',
            -insertwidth => 0,
            );
    $tw->g_pack(-fill => 'both', -expand => 1);

    &parse($tw, "
      <h1>W2Anim Support</h1>

      <h3>Updates</h3>

      <p>The latest release of The W2 Animator can be found on GitHub at
      <a href=\"https://github.com/sarounds/w2anim/releases/latest\">https://github.com/sarounds/w2anim/releases/latest</a>.</p>

      <h3>Documentation</h3>

      <p>Documentation for The W2 Animator is available in the form of a
      User Manual, available
      <a href=\"https://github.com/sarounds/w2anim/blob/main/src/user_manual/W2Anim_manual.pdf\">online</a>
      and in the W2Anim download package.  The manual will be updated as
      new features are added.</p>

      <h3>Questions and Bug Reports</h3>

      <p>If you have questions or wish to report a problem with The W2
      Animator, feel free to send me an email at
      <a href=\"mailto:roundsstewart\@gmail.com?subject=W2Anim\">roundsstewart\@gmail.com</a>.
      I will try to respond in a timely manner.  Alternatively, you can
      ask questions or report problems directly on the GitHub page for
      The W2 Animator at
      <a href=\"https://github.com/sarounds/w2anim\">https://github.com/sarounds/w2anim</a>.</p>

      <h3>Supporting W2 Tool Development</h3>

      <p>The W2 Animator is free and open-source software to assist anyone
      who uses the CE-QUAL-W2 water-quality model.  The W2 Animator
      may be redistributed and/or modified under the terms of the
      <a href=\"https://www.gnu.org/licenses/gpl.html\">GNU General Public
      License</a> as published by the Free Software Foundation, either
      version 3 of the License or (at your option) any later version.</p>

      <p>Developing The W2 Animator as a data visualization tool has been
      a hobby and obsession, and I am happy to make it available for free
      to the W2 user community.  Although this software is absolutely free
      of charge, it is my hope that some users of The W2 Animator, perhaps
      particularly those who may be using it as part of a business, will
      choose to independently support higher education in some fashion.
      Two worthy funds that might be considered are:<br>

      <ul>
        <li>The <i>CE-QUAL-W2 Model Development Fund (\#8610011)</i> at the
            <a href=\"https://giving.psuf.org/\">Portland State University
            Foundation</a>, and</li>
        <li>The <i>Stewart Rounds &amp; Bernadine Bonn Scholarship Fund</i>
            at the <a href=\"https://give.fororegonstate.org/\">Oregon
            State University Foundation</a>.</li>
      </ul></p>
      ");
    &adjust_window_position($support_window);
    $support_window->g_focus;
}


sub about {
    my ($geom, $tw, $X, $Y);

    if (defined($about_window) && Tkx::winfo_exists($about_window)) {
        if ($about_window->g_wm_title() eq "About the W2 Animator") {
            $about_window->g_wm_deiconify();
            $about_window->g_raise();
            $about_window->g_focus;
            &adjust_window_position($about_window);
            return;
        }
    }

    $geom = $main->g_wm_geometry();
    (undef, $X, $Y) = split(/\+/, $geom);
    $geom = sprintf("+%d+%d", $X+70, $Y+60);

    $about_window = $main->new_toplevel();
    $about_window->g_wm_transient($main);
    $about_window->g_wm_title("About the W2 Animator");
    $about_window->g_wm_minsize(350,200);
    $about_window->configure(-cursor => $cursor_norm);
    $about_window->g_wm_geometry($geom);

    $tw = $about_window->new_tkx_Scrolled('tkx_ROText',
            -width       => 59,
            -height      => 26,
            -relief      => 'flat',
            -font        => 'default',
            -cursor      => $cursor_norm,
            -background  => &get_rgb_code($background_color),
            -wrap        => 'word',
            -scrollbars  => 'oe',
            -insertwidth => 0,
            );
    $tw->g_pack(-fill => 'both', -expand => 1);

    &parse($tw, "
      <h1>The W2 Animator</h1>
      <p><b>Version:</b> $version
      <br><b>Author:</b> Stewart A. Rounds &lt;roundsstewart\@gmail.com&gt;
      <br>Copyright (c) 2022-2024</p>
      <p>The W2 Animator was developed as a free tool for anyone
      who uses the CE-QUAL-W2 water-quality model.  Although I use
      CE-QUAL-W2 in my work at the U.S. Geological Survey, this tool
      was created on my own time and with my own resources.  I offer it
      to the water-quality modeling community at no charge.  <b>Send me
      an <a href=\"mailto:roundsstewart\@gmail.com?subject=W2Anim\">email</a> if you
      like it!</b></p>
      <p>The W2 Animator was written in Perl with the Tcl/Tk toolkit
      and is free software; you may redistribute it and/or modify it
      under the terms of the GNU General Public License as published by
      the Free Software Foundation, either version 3 of the License or
      (at your option) any later version.</p>
      <p>This program is distributed in the hope that it will be
      useful, but WITHOUT ANY WARRANTY; without even the implied
      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
      See the GNU General Public License for more details:</p>
      <p><img src=\"${prog_path}images/gplv3.gif\" width=88 height=31> GNU
      <a href=\"https://www.gnu.org/licenses/gpl.html\">General Public License</a>.</p>
      ");
    &adjust_window_position($about_window);
    $about_window->g_focus;
}
